{
    "repo": "tj/commander.js",
    "url": "https://github.com/tj/commander.js",
    "branch": "master",
    "configs": [
        {
            "package": "commander",
            "lang": "ts",
            "dir": "tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "when arguments includes -- then stop processing options",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 61
            },
            "line": 8,
            "code": "test('when arguments includes -- then stop processing options', () => {\n  const program = new commander.Command();\n  program\n    .option('-f, --foo', 'add some foo')\n    .option('-b, --bar', 'add some bar');\n  program.parse(['node', 'test', '--foo', '--', '--bar', 'baz']);\n  // More than one assert, ported from legacy test\n  const opts = program.opts();\n  expect(opts.foo).toBe(true);\n  expect(opts.bar).toBeUndefined();\n  expect(program.args).toEqual(['--bar', 'baz']);\n});",
            "file": "args.literal.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when arguments include -- then more literals are passed-through as args",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 77
            },
            "line": 21,
            "code": "test('when arguments include -- then more literals are passed-through as args', () => {\n  const program = new commander.Command();\n  program\n    .option('-f, --foo', 'add some foo')\n    .option('-b, --bar', 'add some bar');\n  program.parse(['node', 'test', '--', 'cmd', '--', '--arg']);\n  expect(program.args).toEqual(['cmd', '--', '--arg']);\n});",
            "file": "args.literal.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no extra arguments specified for program then variadic arg is empty array",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 6,
                "column": 86
            },
            "line": 6,
            "code": "  test('when no extra arguments specified for program then variadic arg is empty array', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .arguments('<id> [variadicArg...]')\n      .action(actionMock);\n\n    program.parse(['node', 'test', 'id']);\n\n    expect(actionMock).toHaveBeenCalledWith('id', [], program.opts(), program);\n  });",
            "file": "args.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when extra arguments specified for program then variadic arg is array of values",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 18,
                "column": 87
            },
            "line": 18,
            "code": "  test('when extra arguments specified for program then variadic arg is array of values', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .arguments('<id> [variadicArg...]')\n      .action(actionMock);\n    const extraArguments = ['a', 'b', 'c'];\n\n    program.parse(['node', 'test', 'id', ...extraArguments]);\n\n    expect(actionMock).toHaveBeenCalledWith('id', extraArguments, program.opts(), program);\n  });",
            "file": "args.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no extra arguments specified for command then variadic arg is empty array",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 31,
                "column": 86
            },
            "line": 31,
            "code": "  test('when no extra arguments specified for command then variadic arg is empty array', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    const cmd = program\n      .command('sub [variadicArg...]')\n      .action(actionMock);\n\n    program.parse(['node', 'test', 'sub']);\n\n    expect(actionMock).toHaveBeenCalledWith([], cmd.opts(), cmd);\n  });",
            "file": "args.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when extra arguments specified for command then variadic arg is array of values",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 43,
                "column": 87
            },
            "line": 43,
            "code": "  test('when extra arguments specified for command then variadic arg is array of values', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    const cmd = program\n      .command('sub [variadicArg...]')\n      .action(actionMock);\n    const extraArguments = ['a', 'b', 'c'];\n\n    program.parse(['node', 'test', 'sub', ...extraArguments]);\n\n    expect(actionMock).toHaveBeenCalledWith(extraArguments, cmd.opts(), cmd);\n  });",
            "file": "args.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program variadic argument not last then error",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 56,
                "column": 58
            },
            "line": 56,
            "code": "  test('when program variadic argument not last then error', () => {\n    const program = new commander.Command();\n\n    expect(() => {\n      program.arguments('<variadicArg...> [optionalArg]');\n    }).toThrow(\"only the last argument can be variadic 'variadicArg'\");\n  });",
            "file": "args.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command variadic argument not last then error",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 64,
                "column": 58
            },
            "line": 64,
            "code": "  test('when command variadic argument not last then error', () => {\n    const program = new commander.Command();\n\n    expect(() => {\n      program.command('sub <variadicArg...> [optionalArg]');\n    }).toThrow(\"only the last argument can be variadic 'variadicArg'\");\n  });",
            "file": "args.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic argument then usage shows variadic",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 72,
                "column": 56
            },
            "line": 72,
            "code": "  test('when variadic argument then usage shows variadic', () => {\n    const program = new commander.Command();\n    program\n      .name('foo')\n      .arguments('[args...]');\n\n    expect(program.usage()).toBe('[options] [args...]');\n  });",
            "file": "args.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .default() then returns this",
            "suites": [
                "Argument methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 4,
                "column": 46
            },
            "line": 4,
            "code": "  test('when call .default() then returns this', () => {\n    const argument = new Argument('<value>');\n    const result = argument.default(3);\n    expect(result).toBe(argument);\n  });",
            "file": "argument.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .argParser() then returns this",
            "suites": [
                "Argument methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 10,
                "column": 48
            },
            "line": 10,
            "code": "  test('when call .argParser() then returns this', () => {\n    const argument = new Argument('<value>');\n    const result = argument.argParser(() => { });\n    expect(result).toBe(argument);\n  });",
            "file": "argument.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .choices() then returns this",
            "suites": [
                "Argument methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 16,
                "column": 46
            },
            "line": 16,
            "code": "  test('when call .choices() then returns this', () => {\n    const argument = new Argument('<value>');\n    const result = argument.choices(['a']);\n    expect(result).toBe(argument);\n  });",
            "file": "argument.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .argRequired() then returns this",
            "suites": [
                "Argument methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 22,
                "column": 50
            },
            "line": 22,
            "code": "  test('when call .argRequired() then returns this', () => {\n    const argument = new Argument('<value>');\n    const result = argument.argRequired();\n    expect(result).toBe(argument);\n  });",
            "file": "argument.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .argOptional() then returns this",
            "suites": [
                "Argument methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 28,
                "column": 50
            },
            "line": 28,
            "code": "  test('when call .argOptional() then returns this', () => {\n    const argument = new Argument('<value>');\n    const result = argument.argOptional();\n    expect(result).toBe(argument);\n  });",
            "file": "argument.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument not specified then callback not called",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 58
            },
            "line": 6,
            "code": "test('when argument not specified then callback not called', () => {\n  const mockCoercion = jest.fn();\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', mockCoercion)\n    .action(() => {});\n  program.parse([], { from: 'user' });\n  expect(mockCoercion).not.toHaveBeenCalled();\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument not specified then action argument undefined",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 64
            },
            "line": 16,
            "code": "test('when argument not specified then action argument undefined', () => {\n  let actionValue = 'foo';\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', parseFloat)\n    .action((arg) => {\n      actionValue = arg;\n    });\n  program.parse([], { from: 'user' });\n  expect(actionValue).toBeUndefined();\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom with starting value and argument not specified then callback not called",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 89
            },
            "line": 28,
            "code": "test('when custom with starting value and argument not specified then callback not called', () => {\n  const mockCoercion = jest.fn();\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', parseFloat, 1)\n    .action(() => {});\n  program.parse([], { from: 'user' });\n  expect(mockCoercion).not.toHaveBeenCalled();\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom with starting value and argument not specified with action handler then action argument is starting value",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 123
            },
            "line": 38,
            "code": "test('when custom with starting value and argument not specified with action handler then action argument is starting value', () => {\n  const startingValue = 1;\n  let actionValue;\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', parseFloat, startingValue)\n    .action((arg) => {\n      actionValue = arg;\n    });\n  program.parse([], { from: 'user' });\n  expect(actionValue).toEqual(startingValue);\n  expect(program.processedArgs).toEqual([startingValue]);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom with starting value and argument not specified without action handler then .processedArgs has starting value",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 126
            },
            "line": 52,
            "code": "test('when custom with starting value and argument not specified without action handler then .processedArgs has starting value', () => {\n  const startingValue = 1;\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', parseFloat, startingValue);\n  program.parse([], { from: 'user' });\n  expect(program.processedArgs).toEqual([startingValue]);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default value is defined (without custom processing) and argument not specified with action handler then action argument is default value",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 148
            },
            "line": 61,
            "code": "test('when default value is defined (without custom processing) and argument not specified with action handler then action argument is default value', () => {\n  const defaultValue = 1;\n  let actionValue;\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', defaultValue)\n    .action((arg) => {\n      actionValue = arg;\n    });\n  program.parse([], { from: 'user' });\n  expect(actionValue).toEqual(defaultValue);\n  expect(program.processedArgs).toEqual([defaultValue]);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default value is defined (without custom processing) and argument not specified without action handler then .processedArgs is default value",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 150
            },
            "line": 75,
            "code": "test('when default value is defined (without custom processing) and argument not specified without action handler then .processedArgs is default value', () => {\n  const defaultValue = 1;\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', defaultValue);\n  program.parse([], { from: 'user' });\n  expect(program.processedArgs).toEqual([defaultValue]);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument specified then callback called with value",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 61
            },
            "line": 84,
            "code": "test('when argument specified then callback called with value', () => {\n  const mockCoercion = jest.fn();\n  const value = '1';\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', mockCoercion)\n    .action(() => {});\n  program.parse([value], { from: 'user' });\n  expect(mockCoercion).toHaveBeenCalledWith(value, undefined);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument specified with action handler then action value is as returned from callback",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 96
            },
            "line": 95,
            "code": "test('when argument specified with action handler then action value is as returned from callback', () => {\n  const callbackResult = 2;\n  let actionValue;\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', () => {\n      return callbackResult;\n    })\n    .action((arg) => {\n      actionValue = arg;\n    });\n  program.parse(['node', 'test', 'alpha']);\n  expect(actionValue).toEqual(callbackResult);\n  expect(program.processedArgs).toEqual([callbackResult]);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument specified without action handler then .processedArgs is as returned from callback",
            "suites": [],
            "updatePoint": {
                "line": 111,
                "column": 101
            },
            "line": 111,
            "code": "test('when argument specified without action handler then .processedArgs is as returned from callback', () => {\n  const callbackResult = 2;\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', () => {\n      return callbackResult;\n    });\n  program.parse(['node', 'test', 'alpha']);\n  expect(program.processedArgs).toEqual([callbackResult]);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument specified then program.args has original rather than custom",
            "suites": [],
            "updatePoint": {
                "line": 122,
                "column": 79
            },
            "line": 122,
            "code": "test('when argument specified then program.args has original rather than custom', () => {\n  // This is as intended, so check behaviour.\n  const callbackResult = 2;\n  const program = new commander.Command();\n  program\n    .argument('[n]', 'number', () => {\n      return callbackResult;\n    })\n    .action(() => {});\n  program.parse(['node', 'test', 'alpha']);\n  expect(program.args).toEqual(['alpha']);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom with starting value and argument specified then callback called with value and starting value",
            "suites": [],
            "updatePoint": {
                "line": 135,
                "column": 111
            },
            "line": 135,
            "code": "test('when custom with starting value and argument specified then callback called with value and starting value', () => {\n  const mockCoercion = jest.fn();\n  const startingValue = 1;\n  const value = '2';\n  const program = new commander.Command()\n    .argument('[n]', 'number', mockCoercion, startingValue)\n    .action(() => {});\n  program.parse(['node', 'test', value]);\n  expect(mockCoercion).toHaveBeenCalledWith(value, startingValue);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic argument specified multiple times then callback called with value and previousValue",
            "suites": [],
            "updatePoint": {
                "line": 146,
                "column": 103
            },
            "line": 146,
            "code": "test('when variadic argument specified multiple times then callback called with value and previousValue', () => {\n  const mockCoercion = jest.fn().mockImplementation(() => {\n    return 'callback';\n  });\n  const program = new commander.Command();\n  program\n    .argument('<n...>', 'number', mockCoercion)\n    .action(() => {});\n  program.parse(['1', '2'], { from: 'user' });\n  expect(mockCoercion).toHaveBeenCalledTimes(2);\n  expect(mockCoercion).toHaveBeenNthCalledWith(1, '1', undefined);\n  expect(mockCoercion).toHaveBeenNthCalledWith(2, '2', 'callback');\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic argument without action handler then .processedArg has array",
            "suites": [],
            "updatePoint": {
                "line": 160,
                "column": 80
            },
            "line": 160,
            "code": "test('when variadic argument without action handler then .processedArg has array', () => {\n  const program = new commander.Command();\n  program\n    .argument('<n...>', 'number');\n  program.parse(['1', '2'], { from: 'user' });\n  expect(program.processedArgs).toEqual([['1', '2']]);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when parseFloat \"1e2\" then action argument is 100",
            "suites": [],
            "updatePoint": {
                "line": 168,
                "column": 55
            },
            "line": 168,
            "code": "test('when parseFloat \"1e2\" then action argument is 100', () => {\n  let actionValue;\n  const program = new commander.Command();\n  program\n    .argument('<number>', 'float argument', parseFloat)\n    .action((arg) => {\n      actionValue = arg;\n    });\n  program.parse(['1e2'], { from: 'user' });\n  expect(actionValue).toEqual(100);\n  expect(program.processedArgs).toEqual([actionValue]);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when defined default value for required argument then throw",
            "suites": [],
            "updatePoint": {
                "line": 181,
                "column": 65
            },
            "line": 181,
            "code": "test('when defined default value for required argument then throw', () => {\n  const program = new commander.Command();\n  expect(() => {\n    program.argument('<number>', 'float argument', 4);\n  }).toThrow();\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom processing for argument throws plain error then not CommanderError caught",
            "suites": [],
            "updatePoint": {
                "line": 188,
                "column": 91
            },
            "line": 188,
            "code": "test('when custom processing for argument throws plain error then not CommanderError caught', () => {\n  function justSayNo(value) {\n    throw new Error('no no no');\n  }\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .argument('[n]', 'number', justSayNo)\n    .action(() => {});\n\n  let caughtErr;\n  try {\n    program.parse(['green'], { from: 'user' });\n  } catch (err) {\n    caughtErr = err;\n  }\n\n  expect(caughtErr).toBeInstanceOf(Error);\n  expect(caughtErr).not.toBeInstanceOf(commander.CommanderError);\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument argument in choices then argument set",
            "suites": [],
            "updatePoint": {
                "line": 210,
                "column": 57
            },
            "line": 210,
            "code": "test('when argument argument in choices then argument set', () => {\n  const program = new commander.Command();\n  let shade;\n  program\n    .exitOverride()\n    .addArgument(new commander.Argument('<shade>').choices(['red', 'blue']))\n    .action((shadeParam) => { shade = shadeParam; });\n  program.parse(['red'], { from: 'user' });\n  expect(shade).toBe('red');\n});",
            "file": "argument.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when name with surrounding <> then argument required",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 58
            },
            "line": 6,
            "code": "test('when name with surrounding <> then argument required', () => {\n  const argument = new commander.Argument('<name>');\n  expect(argument.required).toBe(true);\n});",
            "file": "argument.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when name with surrounding [] then argument optional",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 58
            },
            "line": 11,
            "code": "test('when name with surrounding [] then argument optional', () => {\n  const argument = new commander.Argument('[name]');\n  expect(argument.required).toBe(false);\n});",
            "file": "argument.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when name without surrounding brackets then argument required",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 67
            },
            "line": 16,
            "code": "test('when name without surrounding brackets then argument required', () => {\n  // default behaviour, allowed from Commander 8\n  const argument = new commander.Argument('name');\n  expect(argument.required).toBe(true);\n});",
            "file": "argument.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .argRequired() then argument required",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 53
            },
            "line": 22,
            "code": "test('when call .argRequired() then argument required', () => {\n  const argument = new commander.Argument('name');\n  argument.required = false;\n  argument.argRequired();\n  expect(argument.required).toBe(true);\n});",
            "file": "argument.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .argOptional() then argument optional",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 53
            },
            "line": 29,
            "code": "test('when call .argOptional() then argument optional', () => {\n  const argument = new commander.Argument('name');\n  argument.required = true;\n  argument.argOptional();\n  expect(argument.required).toBe(false);\n});",
            "file": "argument.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no extra arguments specified for program then variadic arg is empty array",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 6,
                "column": 86
            },
            "line": 6,
            "code": "  test('when no extra arguments specified for program then variadic arg is empty array', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .argument('<id>')\n      .argument('[variadicArg...]')\n      .action(actionMock);\n\n    program.parse(['node', 'test', 'id']);\n\n    expect(actionMock).toHaveBeenCalledWith('id', [], program.opts(), program);\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when extra arguments specified for program then variadic arg is array of values",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 19,
                "column": 87
            },
            "line": 19,
            "code": "  test('when extra arguments specified for program then variadic arg is array of values', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .addArgument(new commander.Argument('<id>'))\n      .argument('[variadicArg...]')\n      .action(actionMock);\n    const extraArguments = ['a', 'b', 'c'];\n\n    program.parse(['node', 'test', 'id', ...extraArguments]);\n\n    expect(actionMock).toHaveBeenCalledWith('id', extraArguments, program.opts(), program);\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no extra arguments specified for command then variadic arg is empty array",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 33,
                "column": 86
            },
            "line": 33,
            "code": "  test('when no extra arguments specified for command then variadic arg is empty array', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    const cmd = program\n      .command('sub [variadicArg...]')\n      .action(actionMock);\n\n    program.parse(['node', 'test', 'sub']);\n\n    expect(actionMock).toHaveBeenCalledWith([], cmd.opts(), cmd);\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when extra arguments specified for command then variadic arg is array of values",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 45,
                "column": 87
            },
            "line": 45,
            "code": "  test('when extra arguments specified for command then variadic arg is array of values', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    const cmd = program\n      .command('sub [variadicArg...]')\n      .action(actionMock);\n    const extraArguments = ['a', 'b', 'c'];\n\n    program.parse(['node', 'test', 'sub', ...extraArguments]);\n\n    expect(actionMock).toHaveBeenCalledWith(extraArguments, cmd.opts(), cmd);\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program variadic argument not last then error",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 58,
                "column": 58
            },
            "line": 58,
            "code": "  test('when program variadic argument not last then error', () => {\n    const program = new commander.Command();\n\n    expect(() => {\n      program\n        .argument('<variadicArg...>')\n        .argument('[optionalArg]');\n    }).toThrow(\"only the last argument can be variadic 'variadicArg'\");\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command variadic argument not last then error",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 68,
                "column": 58
            },
            "line": 68,
            "code": "  test('when command variadic argument not last then error', () => {\n    const program = new commander.Command();\n\n    expect(() => {\n      program.command('sub <variadicArg...> [optionalArg]');\n    }).toThrow(\"only the last argument can be variadic 'variadicArg'\");\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic argument then usage shows variadic",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 76,
                "column": 56
            },
            "line": 76,
            "code": "  test('when variadic argument then usage shows variadic', () => {\n    const program = new commander.Command();\n    program\n      .name('foo')\n      .argument('[args...]');\n\n    expect(program.usage()).toBe('[options] [args...]');\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic used with choices and one value then set in array",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 85,
                "column": 71
            },
            "line": 85,
            "code": "  test('when variadic used with choices and one value then set in array', () => {\n    const program = new commander.Command();\n    let passedArg;\n    program\n      .addArgument(new commander.Argument('<value...>').choices(['one', 'two']))\n      .action((value) => { passedArg = value; });\n\n    program.parse(['one'], { from: 'user' });\n    expect(passedArg).toEqual(['one']);\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic used with choices and two values then set in array",
            "suites": [
                "variadic argument"
            ],
            "updatePoint": {
                "line": 96,
                "column": 72
            },
            "line": 96,
            "code": "  test('when variadic used with choices and two values then set in array', () => {\n    const program = new commander.Command();\n    let passedArg;\n    program\n      .addArgument(new commander.Argument('<value...>').choices(['one', 'two']))\n      .action((value) => { passedArg = value; });\n\n    program.parse(['one', 'two'], { from: 'user' });\n    expect(passedArg).toEqual(['one', 'two']);\n  });",
            "file": "argument.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action called then command passed to action",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 55
            },
            "line": 5,
            "code": "test('when .action called then command passed to action', () => {\n  const actionMock = jest.fn();\n  const program = new commander.Command();\n  const cmd = program\n    .command('info')\n    .action(actionMock);\n  program.parse(['node', 'test', 'info']);\n  expect(actionMock).toHaveBeenCalledWith(cmd.opts(), cmd);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action called then program.args only contains args",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 62
            },
            "line": 15,
            "code": "test('when .action called then program.args only contains args', () => {\n  // At one time program.args was being modified to contain the same args as the call to .action\n  // and so included the command as an extra and unexpected complex item in array.\n  const program = new commander.Command();\n  program\n    .command('info <file>')\n    .action(() => {});\n  program.parse(['node', 'test', 'info', 'my-file']);\n  expect(program.args).toEqual(['info', 'my-file']);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action on program with required argument via %s and argument supplied then action called",
            "suites": [],
            "line": 26,
            "code": "test.each(getTestCases('<file>'))('when .action on program with required argument via %s and argument supplied then action called', (methodName, program) => {\n  const actionMock = jest.fn();\n  program.action(actionMock);\n  program.parse(['node', 'test', 'my-file']);\n  expect(actionMock).toHaveBeenCalledWith('my-file', program.opts(), program);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action on program with required argument via %s and argument not supplied then action not called",
            "suites": [],
            "line": 33,
            "code": "test.each(getTestCases('<file>'))('when .action on program with required argument via %s and argument not supplied then action not called', (methodName, program) => {\n  const actionMock = jest.fn();\n  program\n    .exitOverride()\n    .configureOutput({ writeErr: () => {} })\n    .action(actionMock);\n  expect(() => {\n    program.parse(['node', 'test']);\n  }).toThrow();\n  expect(actionMock).not.toHaveBeenCalled();\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action on program and no arguments then action called",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 65
            },
            "line": 46,
            "code": "test('when .action on program and no arguments then action called', () => {\n  const actionMock = jest.fn();\n  const program = new commander.Command();\n  program\n    .action(actionMock);\n  program.parse(['node', 'test']);\n  expect(actionMock).toHaveBeenCalledWith(program.opts(), program);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action on program with optional argument via %s supplied then action called",
            "suites": [],
            "line": 55,
            "code": "test.each(getTestCases('[file]'))('when .action on program with optional argument via %s supplied then action called', (methodName, program) => {\n  const actionMock = jest.fn();\n  program.action(actionMock);\n  program.parse(['node', 'test', 'my-file']);\n  expect(actionMock).toHaveBeenCalledWith('my-file', program.opts(), program);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action on program without optional argument supplied then action called",
            "suites": [],
            "line": 62,
            "code": "test.each(getTestCases('[file]'))('when .action on program without optional argument supplied then action called', (methodName, program) => {\n  const actionMock = jest.fn();\n  program.action(actionMock);\n  program.parse(['node', 'test']);\n  expect(actionMock).toHaveBeenCalledWith(undefined, program.opts(), program);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action on program with optional argument via %s and subcommand and program argument then program action called",
            "suites": [],
            "line": 69,
            "code": "test.each(getTestCases('[file]'))('when .action on program with optional argument via %s and subcommand and program argument then program action called', (methodName, program) => {\n  const actionMock = jest.fn();\n  program.action(actionMock);\n  program\n    .command('subcommand');\n\n  program.parse(['node', 'test', 'a']);\n\n  expect(actionMock).toHaveBeenCalledWith('a', program.opts(), program);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .action on program with optional argument via %s and subcommand and no program argument then program action called",
            "suites": [],
            "line": 81,
            "code": "test.each(getTestCases('[file]'))('when .action on program with optional argument via %s and subcommand and no program argument then program action called', (methodName, program) => {\n  const actionMock = jest.fn();\n  program.action(actionMock);\n  program.command('subcommand');\n\n  program.parse(['node', 'test']);\n\n  expect(actionMock).toHaveBeenCalledWith(undefined, program.opts(), program);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when action is async then can await parseAsync",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 52
            },
            "line": 91,
            "code": "test('when action is async then can await parseAsync', async() => {\n  let asyncFinished = false;\n  async function delay() {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    asyncFinished = true;\n  };\n  const program = new commander.Command();\n  program\n    .action(delay);\n\n  const later = program.parseAsync(['node', 'test']);\n  expect(asyncFinished).toBe(false);\n  await later;\n  expect(asyncFinished).toBe(true);\n});",
            "file": "command.action.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when addCommand and specify subcommand then called",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 56
            },
            "line": 4,
            "code": "test('when addCommand and specify subcommand then called', () => {\n  const program = new commander.Command();\n  const leafAction = jest.fn();\n  const sub = new commander.Command();\n  sub\n    .name('sub')\n    .action(leafAction);\n  program\n    .addCommand(sub);\n\n  program.parse('node test.js sub'.split(' '));\n  expect(leafAction).toHaveBeenCalled();\n});",
            "file": "command.addCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when commands added using .addCommand and .command then internals similar",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 79
            },
            "line": 18,
            "code": "test('when commands added using .addCommand and .command then internals similar', () => {\n  const program1 = new commander.Command();\n  program1.command('sub');\n  const program2 = new commander.Command();\n  program2.addCommand(new commander.Command('sub'));\n\n  // This is a bit of a cheat to check using .addCommand() produces similar result to .command(),\n  // since .command() is well tested and understood.\n\n  const cmd1 = program1.commands[0];\n  const cmd2 = program2.commands[0];\n  expect(cmd1.parent).toBe(program1);\n  expect(cmd2.parent).toBe(program2);\n\n  for (const key of Object.keys(cmd1)) {\n    switch (typeof cmd1[key]) {\n      case 'string':\n      case 'boolean':\n      case 'number':\n      case 'undefined':\n        // Compare values in a way that will be readable in test failure message.\n        // eslint-disable-next-line jest/no-conditional-expect\n        expect(`${key}:${cmd1[key]}`).toEqual(`${key}:${cmd2[key]}`);\n        break;\n    }\n  }\n});",
            "file": "command.addCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command without name passed to .addCommand then throw",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 64
            },
            "line": 46,
            "code": "test('when command without name passed to .addCommand then throw', () => {\n  const program = new commander.Command();\n  const cmd = new commander.Command();\n  expect(() => {\n    program.addCommand(cmd);\n  }).toThrow();\n});",
            "file": "command.addCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when executable command without custom executableFile passed to .addCommand then throw",
            "suites": [],
            "updatePoint": {
                "line": 54,
                "column": 92
            },
            "line": 54,
            "code": "test('when executable command without custom executableFile passed to .addCommand then throw', () => {\n  const program = new commander.Command();\n  const cmd = new commander.Command('sub');\n  cmd.command('exec', 'exec description');\n  expect(() => {\n    program.addCommand(cmd);\n  }).toThrow();\n});",
            "file": "command.addCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when executable command with custom executableFile passed to .addCommand then ok",
            "suites": [],
            "updatePoint": {
                "line": 63,
                "column": 86
            },
            "line": 63,
            "code": "test('when executable command with custom executableFile passed to .addCommand then ok', () => {\n  const program = new commander.Command();\n  const cmd = new commander.Command('sub');\n  cmd.command('exec', 'exec description', { executableFile: 'custom' });\n  expect(() => {\n    program.addCommand(cmd);\n  }).not.toThrow();\n});",
            "file": "command.addCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"before\" string then string before built-in help",
            "suites": [
                "program calls to addHelpText"
            ],
            "updatePoint": {
                "line": 20,
                "column": 61
            },
            "line": 20,
            "code": "  test('when \"before\" string then string before built-in help', () => {\n    const program = new commander.Command();\n    program.addHelpText('before', 'text');\n    program.outputHelp();\n    expect(writeSpy).toHaveBeenNthCalledWith(1, 'text\\n');\n    expect(writeSpy).toHaveBeenNthCalledWith(2, program.helpInformation());\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"before\" function then function result before built-in help",
            "suites": [
                "program calls to addHelpText"
            ],
            "updatePoint": {
                "line": 28,
                "column": 72
            },
            "line": 28,
            "code": "  test('when \"before\" function then function result before built-in help', () => {\n    const program = new commander.Command();\n    program.addHelpText('before', () => 'text');\n    program.outputHelp();\n    expect(writeSpy).toHaveBeenNthCalledWith(1, 'text\\n');\n    expect(writeSpy).toHaveBeenNthCalledWith(2, program.helpInformation());\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"before\" function returns nothing then no effect",
            "suites": [
                "program calls to addHelpText"
            ],
            "updatePoint": {
                "line": 36,
                "column": 61
            },
            "line": 36,
            "code": "  test('when \"before\" function returns nothing then no effect', () => {\n    const program = new commander.Command();\n    program.addHelpText('before', () => { });\n    program.outputHelp();\n    expect(writeSpy).toHaveBeenNthCalledWith(1, program.helpInformation());\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"beforeAll\" string then string before built-in help",
            "suites": [
                "program calls to addHelpText"
            ],
            "updatePoint": {
                "line": 43,
                "column": 64
            },
            "line": 43,
            "code": "  test('when \"beforeAll\" string then string before built-in help', () => {\n    const program = new commander.Command();\n    program.addHelpText('beforeAll', 'text');\n    program.outputHelp();\n    expect(writeSpy).toHaveBeenNthCalledWith(1, 'text\\n');\n    expect(writeSpy).toHaveBeenNthCalledWith(2, program.helpInformation());\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"after\" string then string after built-in help",
            "suites": [
                "program calls to addHelpText"
            ],
            "updatePoint": {
                "line": 51,
                "column": 59
            },
            "line": 51,
            "code": "  test('when \"after\" string then string after built-in help', () => {\n    const program = new commander.Command();\n    program.addHelpText('after', 'text');\n    program.outputHelp();\n    expect(writeSpy).toHaveBeenNthCalledWith(1, program.helpInformation());\n    expect(writeSpy).toHaveBeenNthCalledWith(2, 'text\\n');\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"afterAll\" string then string after built-in help",
            "suites": [
                "program calls to addHelpText"
            ],
            "updatePoint": {
                "line": 59,
                "column": 62
            },
            "line": 59,
            "code": "  test('when \"afterAll\" string then string after built-in help', () => {\n    const program = new commander.Command();\n    program.addHelpText('afterAll', 'text');\n    program.outputHelp();\n    expect(writeSpy).toHaveBeenNthCalledWith(1, program.helpInformation());\n    expect(writeSpy).toHaveBeenNthCalledWith(2, 'text\\n');\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when all the simple positions then strings in order",
            "suites": [
                "program calls to addHelpText"
            ],
            "updatePoint": {
                "line": 67,
                "column": 59
            },
            "line": 67,
            "code": "  test('when all the simple positions then strings in order', () => {\n    const program = new commander.Command();\n    program.addHelpText('before', 'before');\n    program.addHelpText('after', 'after');\n    program.addHelpText('beforeAll', 'beforeAll');\n    program.addHelpText('afterAll', 'afterAll');\n    program.outputHelp();\n    expect(writeSpy).toHaveBeenNthCalledWith(1, 'beforeAll\\n');\n    expect(writeSpy).toHaveBeenNthCalledWith(2, 'before\\n');\n    expect(writeSpy).toHaveBeenNthCalledWith(3, program.helpInformation());\n    expect(writeSpy).toHaveBeenNthCalledWith(4, 'after\\n');\n    expect(writeSpy).toHaveBeenNthCalledWith(5, 'afterAll\\n');\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"silly\" position then throw",
            "suites": [
                "program calls to addHelpText"
            ],
            "updatePoint": {
                "line": 81,
                "column": 40
            },
            "line": 81,
            "code": "  test('when \"silly\" position then throw', () => {\n    const program = new commander.Command();\n    expect(() => {\n      program.addHelpText('silly', 'text');\n    }).toThrow();\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"before\" on program then not called on subcommand",
            "suites": [
                "program and subcommand calls to addHelpText"
            ],
            "updatePoint": {
                "line": 104,
                "column": 62
            },
            "line": 104,
            "code": "  test('when \"before\" on program then not called on subcommand', () => {\n    const program = new commander.Command();\n    const sub = program.command('sub');\n    const testMock = jest.fn();\n    program.addHelpText('before', testMock);\n    sub.outputHelp();\n    expect(testMock).not.toHaveBeenCalled();\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"beforeAll\" on program then is called on subcommand",
            "suites": [
                "program and subcommand calls to addHelpText"
            ],
            "updatePoint": {
                "line": 113,
                "column": 64
            },
            "line": 113,
            "code": "  test('when \"beforeAll\" on program then is called on subcommand', () => {\n    const program = new commander.Command();\n    const sub = program.command('sub');\n    const testMock = jest.fn();\n    program.addHelpText('beforeAll', testMock);\n    sub.outputHelp();\n    expect(testMock).toHaveBeenCalled();\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"after\" on program then not called on subcommand",
            "suites": [
                "program and subcommand calls to addHelpText"
            ],
            "updatePoint": {
                "line": 122,
                "column": 61
            },
            "line": 122,
            "code": "  test('when \"after\" on program then not called on subcommand', () => {\n    const program = new commander.Command();\n    const sub = program.command('sub');\n    const testMock = jest.fn();\n    program.addHelpText('after', testMock);\n    sub.outputHelp();\n    expect(testMock).not.toHaveBeenCalled();\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"afterAll\" on program then is called on subcommand",
            "suites": [
                "program and subcommand calls to addHelpText"
            ],
            "updatePoint": {
                "line": 131,
                "column": 63
            },
            "line": 131,
            "code": "  test('when \"afterAll\" on program then is called on subcommand', () => {\n    const program = new commander.Command();\n    const sub = program.command('sub');\n    const testMock = jest.fn();\n    program.addHelpText('afterAll', testMock);\n    sub.outputHelp();\n    expect(testMock).toHaveBeenCalled();\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help requested then text is on stdout",
            "suites": [
                "context checks with full parse"
            ],
            "updatePoint": {
                "line": 160,
                "column": 50
            },
            "line": 160,
            "code": "  test('when help requested then text is on stdout', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addHelpText('before', 'text');\n    expect(() => {\n      program.parse(['--help'], { from: 'user' });\n    }).toThrow();\n    expect(stdoutSpy).toHaveBeenCalledWith('text\\n');\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help for error then text is on stderr",
            "suites": [
                "context checks with full parse"
            ],
            "updatePoint": {
                "line": 171,
                "column": 50
            },
            "line": 171,
            "code": "  test('when help for error then text is on stderr', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addHelpText('before', 'text')\n      .command('sub');\n    expect(() => {\n      program.parse([], { from: 'user' });\n    }).toThrow();\n    expect(stderrSpy).toHaveBeenCalledWith('text\\n');\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help requested then context.error is false",
            "suites": [
                "context checks with full parse"
            ],
            "updatePoint": {
                "line": 183,
                "column": 55
            },
            "line": 183,
            "code": "  test('when help requested then context.error is false', () => {\n    let context = {};\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addHelpText('before', (contextParam) => { context = contextParam; });\n    expect(() => {\n      program.parse(['--help'], { from: 'user' });\n    }).toThrow();\n    expect(context.error).toBe(false);\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help for error then context.error is true",
            "suites": [
                "context checks with full parse"
            ],
            "updatePoint": {
                "line": 195,
                "column": 54
            },
            "line": 195,
            "code": "  test('when help for error then context.error is true', () => {\n    let context = {};\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addHelpText('before', (contextParam) => { context = contextParam; })\n      .command('sub');\n    expect(() => {\n      program.parse([], { from: 'user' });\n    }).toThrow();\n    expect(context.error).toBe(true);\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help on program then context.command is program",
            "suites": [
                "context checks with full parse"
            ],
            "updatePoint": {
                "line": 208,
                "column": 60
            },
            "line": 208,
            "code": "  test('when help on program then context.command is program', () => {\n    let context = {};\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addHelpText('before', (contextParam) => { context = contextParam; });\n    expect(() => {\n      program.parse(['--help'], { from: 'user' });\n    }).toThrow();\n    expect(context.command).toBe(program);\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help on subcommand and \"before\" subcommand then context.command is subcommand",
            "suites": [
                "context checks with full parse"
            ],
            "updatePoint": {
                "line": 220,
                "column": 90
            },
            "line": 220,
            "code": "  test('when help on subcommand and \"before\" subcommand then context.command is subcommand', () => {\n    let context = {};\n    const program = new commander.Command();\n    program\n      .exitOverride();\n    const sub = program.command('sub')\n      .addHelpText('before', (contextParam) => { context = contextParam; });\n    expect(() => {\n      program.parse(['sub', '--help'], { from: 'user' });\n    }).toThrow();\n    expect(context.command).toBe(sub);\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help on subcommand and \"beforeAll\" on program then context.command is subcommand",
            "suites": [
                "context checks with full parse"
            ],
            "updatePoint": {
                "line": 233,
                "column": 93
            },
            "line": 233,
            "code": "  test('when help on subcommand and \"beforeAll\" on program then context.command is subcommand', () => {\n    let context = {};\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addHelpText('beforeAll', (contextParam) => { context = contextParam; });\n    const sub = program.command('sub');\n    expect(() => {\n      program.parse(['sub', '--help'], { from: 'user' });\n    }).toThrow();\n    expect(context.command).toBe(sub);\n  });",
            "file": "command.addHelpText.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has alias then appears in help",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 49
            },
            "line": 6,
            "code": "test('when command has alias then appears in help', () => {\n  const program = new commander.Command();\n  program\n    .command('info [thing]')\n    .alias('i');\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('info|i');\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has aliases added separately then only first appears in help",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 79
            },
            "line": 15,
            "code": "test('when command has aliases added separately then only first appears in help', () => {\n  const program = new commander.Command();\n  program\n    .command('list [thing]')\n    .alias('ls')\n    .alias('dir');\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('list|ls ');\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has aliases then only first appears in help",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 62
            },
            "line": 25,
            "code": "test('when command has aliases then only first appears in help', () => {\n  const program = new commander.Command();\n  program\n    .command('list [thing]')\n    .aliases(['ls', 'dir']);\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('list|ls ');\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command name = alias then error",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 42
            },
            "line": 34,
            "code": "test('when command name = alias then error', () => {\n  const program = new commander.Command();\n  expect(() => {\n    program\n      .command('fail')\n      .alias('fail');\n  }).toThrow(\"Command alias can't be the same as its name\");\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when use alias then action handler called",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 47
            },
            "line": 43,
            "code": "test('when use alias then action handler called', () => {\n  const program = new commander.Command();\n  const actionMock = jest.fn();\n  program\n    .command('list')\n    .alias('ls')\n    .action(actionMock);\n  program.parse(['ls'], { from: 'user' });\n  expect(actionMock).toHaveBeenCalled();\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when use second alias added separately then action handler called",
            "suites": [],
            "updatePoint": {
                "line": 54,
                "column": 71
            },
            "line": 54,
            "code": "test('when use second alias added separately then action handler called', () => {\n  const program = new commander.Command();\n  const actionMock = jest.fn();\n  program\n    .command('list')\n    .alias('ls')\n    .alias('dir')\n    .action(actionMock);\n  program.parse(['dir'], { from: 'user' });\n  expect(actionMock).toHaveBeenCalled();\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when use second of aliases then action handler called",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 59
            },
            "line": 66,
            "code": "test('when use second of aliases then action handler called', () => {\n  const program = new commander.Command();\n  const actionMock = jest.fn();\n  program\n    .command('list')\n    .aliases(['ls', 'dir'])\n    .action(actionMock);\n  program.parse(['dir'], { from: 'user' });\n  expect(actionMock).toHaveBeenCalled();\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set alias then can get alias",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 39
            },
            "line": 77,
            "code": "test('when set alias then can get alias', () => {\n  const program = new commander.Command();\n  const alias = 'abcde';\n  program.alias(alias);\n  expect(program.alias()).toEqual(alias);\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set aliases then can get aliases",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 43
            },
            "line": 84,
            "code": "test('when set aliases then can get aliases', () => {\n  const program = new commander.Command();\n  const aliases = ['a', 'b'];\n  program.aliases(aliases);\n  expect(program.aliases()).toEqual(aliases);\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set alias on executable then can get alias",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 53
            },
            "line": 91,
            "code": "test('when set alias on executable then can get alias', () => {\n  const program = new commander.Command();\n  const alias = 'abcde';\n  program\n    .command('external', 'external command')\n    .alias(alias);\n  expect(program.commands[0].alias()).toEqual(alias);\n});",
            "file": "command.alias.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "allowExcessArguments when action handler: %s",
            "suites": [],
            "line": 5,
            "code": "describe.each([true, false])('allowExcessArguments when action handler: %s', (hasActionHandler) => {\n  function configureCommand(cmd) {\n    cmd\n      .exitOverride()\n      .configureOutput({\n        writeErr: () => {}\n      });\n    if (hasActionHandler) {\n      cmd.action(() => {});\n    }\n  }\n\n  test('when specify excess program argument then no error by default', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n\n    expect(() => {\n      program.parse(['excess'], { from: 'user' });\n    }).not.toThrow();\n  });\n\n  test('when specify excess program argument and allowExcessArguments(false) then error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['excess'], { from: 'user' });\n    }).toThrow();\n  });\n\n  test('when specify excess program argument and allowExcessArguments() then no error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .allowExcessArguments();\n\n    expect(() => {\n      program.parse(['excess'], { from: 'user' });\n    }).not.toThrow();\n  });\n\n  test('when specify excess program argument and allowExcessArguments(true) then no error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .allowExcessArguments(true);\n\n    expect(() => {\n      program.parse(['excess'], { from: 'user' });\n    }).not.toThrow();\n  });\n\n  test('when specify excess command argument then no error (by default)', () => {\n    const program = new commander.Command();\n    const sub = program\n      .command('sub');\n    configureCommand(sub);\n\n    expect(() => {\n      program.parse(['sub', 'excess'], { from: 'user' });\n    }).not.toThrow();\n  });\n\n  test('when specify excess command argument and allowExcessArguments(false) then error', () => {\n    const program = new commander.Command();\n    const sub = program\n      .command('sub')\n      .allowExcessArguments(false);\n    configureCommand(sub);\n\n    expect(() => {\n      program.parse(['sub', 'excess'], { from: 'user' });\n    }).toThrow();\n  });\n\n  test('when specify expected arg and allowExcessArguments(false) then no error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .argument('<file>')\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['file'], { from: 'user' });\n    }).not.toThrow();\n  });\n\n  test('when specify excess after <arg> and allowExcessArguments(false) then error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .argument('<file>')\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['file', 'excess'], { from: 'user' });\n    }).toThrow();\n  });\n\n  test('when specify excess after [arg] and allowExcessArguments(false) then error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .argument('[file]')\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['file', 'excess'], { from: 'user' });\n    }).toThrow();\n  });\n\n  test('when specify args for [args...] and allowExcessArguments(false) then no error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .argument('[files...]')\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['file1', 'file2', 'file3'], { from: 'user' });\n    }).not.toThrow();\n  });\n});",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess program argument then no error by default",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 69
            },
            "line": 17,
            "code": "  test('when specify excess program argument then no error by default', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n\n    expect(() => {\n      program.parse(['excess'], { from: 'user' });\n    }).not.toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess program argument and allowExcessArguments(false) then error",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 87
            },
            "line": 26,
            "code": "  test('when specify excess program argument and allowExcessArguments(false) then error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['excess'], { from: 'user' });\n    }).toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess program argument and allowExcessArguments() then no error",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 85
            },
            "line": 37,
            "code": "  test('when specify excess program argument and allowExcessArguments() then no error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .allowExcessArguments();\n\n    expect(() => {\n      program.parse(['excess'], { from: 'user' });\n    }).not.toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess program argument and allowExcessArguments(true) then no error",
            "suites": [],
            "updatePoint": {
                "line": 48,
                "column": 89
            },
            "line": 48,
            "code": "  test('when specify excess program argument and allowExcessArguments(true) then no error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .allowExcessArguments(true);\n\n    expect(() => {\n      program.parse(['excess'], { from: 'user' });\n    }).not.toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess command argument then no error (by default)",
            "suites": [],
            "updatePoint": {
                "line": 59,
                "column": 71
            },
            "line": 59,
            "code": "  test('when specify excess command argument then no error (by default)', () => {\n    const program = new commander.Command();\n    const sub = program\n      .command('sub');\n    configureCommand(sub);\n\n    expect(() => {\n      program.parse(['sub', 'excess'], { from: 'user' });\n    }).not.toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess command argument and allowExcessArguments(false) then error",
            "suites": [],
            "updatePoint": {
                "line": 70,
                "column": 87
            },
            "line": 70,
            "code": "  test('when specify excess command argument and allowExcessArguments(false) then error', () => {\n    const program = new commander.Command();\n    const sub = program\n      .command('sub')\n      .allowExcessArguments(false);\n    configureCommand(sub);\n\n    expect(() => {\n      program.parse(['sub', 'excess'], { from: 'user' });\n    }).toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify expected arg and allowExcessArguments(false) then no error",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 79
            },
            "line": 82,
            "code": "  test('when specify expected arg and allowExcessArguments(false) then no error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .argument('<file>')\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['file'], { from: 'user' });\n    }).not.toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess after <arg> and allowExcessArguments(false) then error",
            "suites": [],
            "updatePoint": {
                "line": 94,
                "column": 82
            },
            "line": 94,
            "code": "  test('when specify excess after <arg> and allowExcessArguments(false) then error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .argument('<file>')\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['file', 'excess'], { from: 'user' });\n    }).toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess after [arg] and allowExcessArguments(false) then error",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 82
            },
            "line": 106,
            "code": "  test('when specify excess after [arg] and allowExcessArguments(false) then error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .argument('[file]')\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['file', 'excess'], { from: 'user' });\n    }).toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify args for [args...] and allowExcessArguments(false) then no error",
            "suites": [],
            "updatePoint": {
                "line": 118,
                "column": 85
            },
            "line": 118,
            "code": "  test('when specify args for [args...] and allowExcessArguments(false) then no error', () => {\n    const program = new commander.Command();\n    configureCommand(program);\n    program\n      .argument('[files...]')\n      .allowExcessArguments(false);\n\n    expect(() => {\n      program.parse(['file1', 'file2', 'file3'], { from: 'user' });\n    }).not.toThrow();\n  });",
            "file": "command.allowExcessArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown program option then error",
            "suites": [
                "allowUnknownOption"
            ],
            "updatePoint": {
                "line": 21,
                "column": 54
            },
            "line": 21,
            "code": "  test('when specify unknown program option then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .option('-p, --pepper', 'add pepper');\n\n    expect(() => {\n      program.parse(['node', 'test', '-m']);\n    }).toThrow();\n  });",
            "file": "command.allowUnknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown program option and allowUnknownOption(false) then error",
            "suites": [
                "allowUnknownOption"
            ],
            "updatePoint": {
                "line": 32,
                "column": 84
            },
            "line": 32,
            "code": "  test('when specify unknown program option and allowUnknownOption(false) then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .allowUnknownOption(false)\n      .option('-p, --pepper', 'add pepper');\n\n    expect(() => {\n      program.parse(['node', 'test', '-m']);\n    }).toThrow();\n  });",
            "file": "command.allowUnknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown program option and allowUnknownOption() then no error",
            "suites": [
                "allowUnknownOption"
            ],
            "updatePoint": {
                "line": 44,
                "column": 82
            },
            "line": 44,
            "code": "  test('when specify unknown program option and allowUnknownOption() then no error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .allowUnknownOption()\n      .option('-p, --pepper', 'add pepper');\n\n    expect(() => {\n      program.parse(['node', 'test', '-m']);\n    }).not.toThrow();\n  });",
            "file": "command.allowUnknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown program option and allowUnknownOption(true) then no error",
            "suites": [
                "allowUnknownOption"
            ],
            "updatePoint": {
                "line": 56,
                "column": 86
            },
            "line": 56,
            "code": "  test('when specify unknown program option and allowUnknownOption(true) then no error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .allowUnknownOption(true)\n      .option('-p, --pepper', 'add pepper');\n\n    expect(() => {\n      program.parse(['node', 'test', '-m']);\n    }).not.toThrow();\n  });",
            "file": "command.allowUnknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown command option then error",
            "suites": [
                "allowUnknownOption"
            ],
            "updatePoint": {
                "line": 68,
                "column": 54
            },
            "line": 68,
            "code": "  test('when specify unknown command option then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('sub')\n      .option('-p, --pepper', 'add pepper')\n      .action(() => { });\n\n    expect(() => {\n      program.parse(['node', 'test', 'sub', '-m']);\n    }).toThrow();\n  });",
            "file": "command.allowUnknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown command option and allowUnknownOption then no error",
            "suites": [
                "allowUnknownOption"
            ],
            "updatePoint": {
                "line": 81,
                "column": 80
            },
            "line": 81,
            "code": "  test('when specify unknown command option and allowUnknownOption then no error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('sub')\n      .argument('[args...]') // unknown option will be passed as an argument\n      .allowUnknownOption()\n      .option('-p, --pepper', 'add pepper')\n      .action(() => { });\n\n    expect(() => {\n      program.parse(['node', 'test', 'sub', '-m']);\n    }).not.toThrow();\n  });",
            "file": "command.allowUnknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add \"<arg>\" using %s then argument required",
            "suites": [],
            "line": 6,
            "code": "test.each(getSingleArgCases('<explicit-required>'))('when add \"<arg>\" using %s then argument required', (methodName, cmd) => {\n  const argument = cmd._args[0];\n  const expectedShape = {\n    _name: 'explicit-required',\n    required: true,\n    variadic: false,\n    description: ''\n  };\n  expect(argument).toEqual(expectedShape);\n});",
            "file": "command.argumentVariations.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add \"arg\" using %s then argument required",
            "suites": [],
            "line": 17,
            "code": "test.each(getSingleArgCases('implicit-required'))('when add \"arg\" using %s then argument required', (methodName, cmd) => {\n  const argument = cmd._args[0];\n  const expectedShape = {\n    _name: 'implicit-required',\n    required: true,\n    variadic: false,\n    description: ''\n  };\n  expect(argument).toEqual(expectedShape);\n});",
            "file": "command.argumentVariations.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add \"[arg]\" using %s then argument optional",
            "suites": [],
            "line": 28,
            "code": "test.each(getSingleArgCases('[optional]'))('when add \"[arg]\" using %s then argument optional', (methodName, cmd) => {\n  const argument = cmd._args[0];\n  const expectedShape = {\n    _name: 'optional',\n    required: false,\n    variadic: false,\n    description: ''\n  };\n  expect(argument).toEqual(expectedShape);\n});",
            "file": "command.argumentVariations.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add \"<arg...>\" using %s then argument required and variadic",
            "suites": [],
            "line": 39,
            "code": "test.each(getSingleArgCases('<explicit-required...>'))('when add \"<arg...>\" using %s then argument required and variadic', (methodName, cmd) => {\n  const argument = cmd._args[0];\n  const expectedShape = {\n    _name: 'explicit-required',\n    required: true,\n    variadic: true,\n    description: ''\n  };\n  expect(argument).toEqual(expectedShape);\n});",
            "file": "command.argumentVariations.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add \"arg...\" using %s then argument required and variadic",
            "suites": [],
            "line": 50,
            "code": "test.each(getSingleArgCases('implicit-required...'))('when add \"arg...\" using %s then argument required and variadic', (methodName, cmd) => {\n  const argument = cmd._args[0];\n  const expectedShape = {\n    _name: 'implicit-required',\n    required: true,\n    variadic: true,\n    description: ''\n  };\n  expect(argument).toEqual(expectedShape);\n});",
            "file": "command.argumentVariations.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add \"[arg...]\" using %s then argument optional and variadic",
            "suites": [],
            "line": 61,
            "code": "test.each(getSingleArgCases('[optional...]'))('when add \"[arg...]\" using %s then argument optional and variadic', (methodName, cmd) => {\n  const argument = cmd._args[0];\n  const expectedShape = {\n    _name: 'optional',\n    required: false,\n    variadic: true,\n    description: ''\n  };\n  expect(argument).toEqual(expectedShape);\n});",
            "file": "command.argumentVariations.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add two arguments using %s then two arguments",
            "suites": [],
            "line": 81,
            "code": "test.each(getMultipleArgCases('<first>', '[second]'))('when add two arguments using %s then two arguments', (methodName, cmd) => {\n  expect(cmd._args[0].name()).toEqual('first');\n  expect(cmd._args[1].name()).toEqual('second');\n});",
            "file": "command.argumentVariations.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add arguments using multiple methods then all added",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 62
            },
            "line": 95,
            "code": "test('when add arguments using multiple methods then all added', () => {\n  // This is not a key use case, but explicitly test that additive behaviour.\n  const program = new commander.Command();\n  const cmd = program.command('sub <arg1> <arg2>');\n  cmd.arguments('<arg3> <arg4>');\n  cmd.argument('<arg5>');\n  cmd.addArgument(new commander.Argument('arg6'));\n  const argNames = cmd._args.map(arg => arg.name());\n  expect(argNames).toEqual(['arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6']);\n});",
            "file": "command.argumentVariations.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no arguments then asterisk action not called",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 14,
                "column": 57
            },
            "line": 14,
            "code": "  test('when no arguments then asterisk action not called', () => {\n    const writeMock = jest.spyOn(process.stderr, 'write').mockImplementation(() => { });\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride() // to catch help\n      .command('*')\n      .action(mockAction);\n    try {\n      program.parse(['node', 'test']);\n    } catch (err) {\n      ;\n    }\n    expect(mockAction).not.toHaveBeenCalled();\n    writeMock.mockRestore();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unrecognised argument then asterisk action called",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 31,
                "column": 62
            },
            "line": 31,
            "code": "  test('when unrecognised argument then asterisk action called', () => {\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('*')\n      .argument('[args...]')\n      .action(mockAction);\n    program.parse(['node', 'test', 'unrecognised-command']);\n    expect(mockAction).toHaveBeenCalled();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when recognised command then asterisk action not called",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 42,
                "column": 63
            },
            "line": 42,
            "code": "  test('when recognised command then asterisk action not called', () => {\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('install')\n      .action(() => { });\n    program\n      .command('*')\n      .action(mockAction);\n    program.parse(['node', 'test', 'install']);\n    expect(mockAction).not.toHaveBeenCalled();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unrecognised command/argument then asterisk action called",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 55,
                "column": 70
            },
            "line": 55,
            "code": "  test('when unrecognised command/argument then asterisk action called', () => {\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('install');\n    program\n      .command('*')\n      .argument('[args...]')\n      .action(mockAction);\n    program.parse(['node', 'test', 'unrecognised-command']);\n    expect(mockAction).toHaveBeenCalled();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unrecognised argument and known option then asterisk action called",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 68,
                "column": 79
            },
            "line": 68,
            "code": "  test('when unrecognised argument and known option then asterisk action called', () => {\n    // This tests for a regression between v4 and v5. Known default option should not be rejected by program.\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('install');\n    const star = program\n      .command('*')\n      .argument('[args...]')\n      .option('-d, --debug')\n      .action(mockAction);\n    program.parse(['node', 'test', 'unrecognised-command', '--debug']);\n    expect(mockAction).toHaveBeenCalled();\n    expect(star.opts().debug).toEqual(true);\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when non-command argument and unknown option then error for unknown option",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 84,
                "column": 82
            },
            "line": 84,
            "code": "  test('when non-command argument and unknown option then error for unknown option', () => {\n    // This is a change in behaviour from v2 which did not error, but is consistent with modern better detection of invalid options\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({\n        writeErr: () => {}\n      })\n      .command('install');\n    program\n      .command('*')\n      .argument('[args...]')\n      .action(mockAction);\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'some-argument', '--unknown']);\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toEqual('commander.unknownOption');\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no arguments then listener not called",
            "suites": [
                ".on('command:*')"
            ],
            "updatePoint": {
                "line": 110,
                "column": 50
            },
            "line": 110,
            "code": "  test('when no arguments then listener not called', () => {\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .on('command:*', mockAction);\n    program.parse(['node', 'test']);\n    expect(mockAction).not.toHaveBeenCalled();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unrecognised argument then listener called",
            "suites": [
                ".on('command:*')"
            ],
            "updatePoint": {
                "line": 119,
                "column": 55
            },
            "line": 119,
            "code": "  test('when unrecognised argument then listener called', () => {\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .on('command:*', mockAction);\n    program.parse(['node', 'test', 'unrecognised-command']);\n    expect(mockAction).toHaveBeenCalled();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when recognised command then listener not called",
            "suites": [
                ".on('command:*')"
            ],
            "updatePoint": {
                "line": 128,
                "column": 56
            },
            "line": 128,
            "code": "  test('when recognised command then listener not called', () => {\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('install')\n      .action(() => { });\n    program\n      .on('command:*', mockAction);\n    program.parse(['node', 'test', 'install']);\n    expect(mockAction).not.toHaveBeenCalled();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unrecognised command/argument then listener called",
            "suites": [
                ".on('command:*')"
            ],
            "updatePoint": {
                "line": 140,
                "column": 63
            },
            "line": 140,
            "code": "  test('when unrecognised command/argument then listener called', () => {\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('install');\n    program\n      .on('command:*', mockAction);\n    program.parse(['node', 'test', 'unrecognised-command']);\n    expect(mockAction).toHaveBeenCalled();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unrecognised command/argument and unknown option then listener called",
            "suites": [
                ".on('command:*')"
            ],
            "updatePoint": {
                "line": 151,
                "column": 82
            },
            "line": 151,
            "code": "  test('when unrecognised command/argument and unknown option then listener called', () => {\n    // Give listener a chance to make a suggestion for misspelled command. The option\n    // could only be unknown because the command is not correct.\n    // Regression identified in https://github.com/tj/commander.js/issues/1460#issuecomment-772313494\n    const mockAction = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('install');\n    program\n      .on('command:*', mockAction);\n    program.parse(['node', 'test', 'intsall', '--unknown']);\n    expect(mockAction).toHaveBeenCalled();\n  });",
            "file": "command.asterisk.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .command() with description for stand-alone executable then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 7,
                "column": 90
            },
            "line": 7,
            "code": "  test('when call .command() with description for stand-alone executable then returns this', () => {\n    const program = new Command();\n    const result = program.command('foo', 'foo description');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .addCommand() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 13,
                "column": 49
            },
            "line": 13,
            "code": "  test('when call .addCommand() then returns this', () => {\n    const program = new Command();\n    const result = program.addCommand(new Command('name'));\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .argument() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 19,
                "column": 47
            },
            "line": 19,
            "code": "  test('when call .argument() then returns this', () => {\n    const program = new Command();\n    const result = program.argument('<file>');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .addArgument() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 25,
                "column": 50
            },
            "line": 25,
            "code": "  test('when call .addArgument() then returns this', () => {\n    const program = new Command();\n    const result = program.addArgument(new Argument('<file>'));\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set .arguments() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 31,
                "column": 47
            },
            "line": 31,
            "code": "  test('when set .arguments() then returns this', () => {\n    const program = new Command();\n    const result = program.arguments('<file>');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .addHelpCommand() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 37,
                "column": 53
            },
            "line": 37,
            "code": "  test('when call .addHelpCommand() then returns this', () => {\n    const program = new Command();\n    const result = program.addHelpCommand(false);\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .exitOverride() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 43,
                "column": 51
            },
            "line": 43,
            "code": "  test('when call .exitOverride() then returns this', () => {\n    const program = new Command();\n    const result = program.exitOverride(() => { });\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .action() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 49,
                "column": 45
            },
            "line": 49,
            "code": "  test('when call .action() then returns this', () => {\n    const program = new Command();\n    const result = program.action(() => { });\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .addOption() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 55,
                "column": 48
            },
            "line": 55,
            "code": "  test('when call .addOption() then returns this', () => {\n    const program = new Command();\n    const result = program.addOption(new Option('-e'));\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .option() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 61,
                "column": 45
            },
            "line": 61,
            "code": "  test('when call .option() then returns this', () => {\n    const program = new Command();\n    const result = program.option('-e');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .requiredOption() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 67,
                "column": 53
            },
            "line": 67,
            "code": "  test('when call .requiredOption() then returns this', () => {\n    const program = new Command();\n    const result = program.requiredOption('-r');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .combineFlagAndOptionalValue() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 73,
                "column": 66
            },
            "line": 73,
            "code": "  test('when call .combineFlagAndOptionalValue() then returns this', () => {\n    const program = new Command();\n    const result = program.combineFlagAndOptionalValue();\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .allowUnknownOption() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 79,
                "column": 57
            },
            "line": 79,
            "code": "  test('when call .allowUnknownOption() then returns this', () => {\n    const program = new Command();\n    const result = program.allowUnknownOption();\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .allowExcessArguments() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 85,
                "column": 59
            },
            "line": 85,
            "code": "  test('when call .allowExcessArguments() then returns this', () => {\n    const program = new Command();\n    const result = program.allowExcessArguments();\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .storeOptionsAsProperties() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 91,
                "column": 63
            },
            "line": 91,
            "code": "  test('when call .storeOptionsAsProperties() then returns this', () => {\n    const program = new Command();\n    const result = program.storeOptionsAsProperties();\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .version() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 97,
                "column": 46
            },
            "line": 97,
            "code": "  test('when call .version() then returns this', () => {\n    const program = new Command();\n    const result = program.version('1.2.3');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set .description() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 103,
                "column": 49
            },
            "line": 103,
            "code": "  test('when set .description() then returns this', () => {\n    const program = new Command();\n    const result = program.description('description');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set .alias() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 109,
                "column": 43
            },
            "line": 109,
            "code": "  test('when set .alias() then returns this', () => {\n    const program = new Command();\n    const result = program.alias('alias');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set .aliases() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 115,
                "column": 45
            },
            "line": 115,
            "code": "  test('when set .aliases() then returns this', () => {\n    const program = new Command();\n    const result = program.aliases(['foo', 'bar']);\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set .usage() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 121,
                "column": 43
            },
            "line": 121,
            "code": "  test('when set .usage() then returns this', () => {\n    const program = new Command();\n    const result = program.usage('[options]');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set .name() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 127,
                "column": 42
            },
            "line": 127,
            "code": "  test('when set .name() then returns this', () => {\n    const program = new Command();\n    const result = program.name('easy');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .helpOption() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 133,
                "column": 49
            },
            "line": 133,
            "code": "  test('when call .helpOption() then returns this', () => {\n    const program = new Command();\n    const result = program.helpOption(false);\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .addHelpText() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 139,
                "column": 50
            },
            "line": 139,
            "code": "  test('when call .addHelpText() then returns this', () => {\n    const program = new Command();\n    const result = program.addHelpText('before', 'example');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .configureHelp() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 145,
                "column": 52
            },
            "line": 145,
            "code": "  test('when call .configureHelp() then returns this', () => {\n    const program = new Command();\n    const result = program.configureHelp({ });\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .configureOutput() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 151,
                "column": 54
            },
            "line": 151,
            "code": "  test('when call .configureOutput() then returns this', () => {\n    const program = new Command();\n    const result = program.configureOutput({ });\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .passThroughOptions() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 157,
                "column": 57
            },
            "line": 157,
            "code": "  test('when call .passThroughOptions() then returns this', () => {\n    const program = new Command();\n    const result = program.passThroughOptions();\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .enablePositionalOptions() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 163,
                "column": 62
            },
            "line": 163,
            "code": "  test('when call .enablePositionalOptions() then returns this', () => {\n    const program = new Command();\n    const result = program.enablePositionalOptions();\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .hook() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 169,
                "column": 43
            },
            "line": 169,
            "code": "  test('when call .hook() then returns this', () => {\n    const program = new Command();\n    const result = program.hook('preAction', () => {});\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .setOptionValue() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 175,
                "column": 53
            },
            "line": 175,
            "code": "  test('when call .setOptionValue() then returns this', () => {\n    const program = new Command();\n    const result = program.setOptionValue('foo', 'bar');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .setOptionValueWithSource() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 181,
                "column": 63
            },
            "line": 181,
            "code": "  test('when call .setOptionValueWithSource() then returns this', () => {\n    const program = new Command();\n    const result = program.setOptionValueWithSource('foo', 'bar', 'cli');\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .showHelpAfterError() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 187,
                "column": 57
            },
            "line": 187,
            "code": "  test('when call .showHelpAfterError() then returns this', () => {\n    const program = new Command();\n    const result = program.showHelpAfterError();\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .showSuggestionAfterError() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 193,
                "column": 63
            },
            "line": 193,
            "code": "  test('when call .showSuggestionAfterError() then returns this', () => {\n    const program = new Command();\n    const result = program.showSuggestionAfterError();\n    expect(result).toBe(program);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .copyInheritedSettings() then returns this",
            "suites": [
                "Command methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 199,
                "column": 60
            },
            "line": 199,
            "code": "  test('when call .copyInheritedSettings() then returns this', () => {\n    const program = new Command();\n    const cmd = new Command();\n    const result = cmd.copyInheritedSettings(program);\n    expect(result).toBe(cmd);\n  });",
            "file": "command.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has command then appears in help",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 51
            },
            "line": 5,
            "code": "test('when program has command then appears in help', () => {\n  const program = new commander.Command();\n  program\n    .command('bare');\n  const commandHelp = program.helpInformation();\n  expect(commandHelp).toMatch(/Commands:\\n +bare\\n/);\n});",
            "file": "command.commandHelp.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has command with optional arg then appears in help",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 69
            },
            "line": 13,
            "code": "test('when program has command with optional arg then appears in help', () => {\n  const program = new commander.Command();\n  program\n    .command('bare [bare-arg]');\n  const commandHelp = program.helpInformation();\n  expect(commandHelp).toMatch(/Commands:\\n +bare \\[bare-arg\\]\\n/);\n});",
            "file": "command.commandHelp.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when configure program then affects program helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 65
            },
            "line": 3,
            "code": "test('when configure program then affects program helpInformation', () => {\n  const program = new commander.Command();\n  program.configureHelp({ formatHelp: () => { return 'custom'; } });\n  expect(program.helpInformation()).toEqual('custom');\n});",
            "file": "command.configureHelp.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when configure program then affects subcommand helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 68
            },
            "line": 9,
            "code": "test('when configure program then affects subcommand helpInformation', () => {\n  const program = new commander.Command();\n  program.configureHelp({ formatHelp: () => { return 'custom'; } });\n  const sub = program.command('sub');\n  expect(sub.helpInformation()).toEqual('custom');\n});",
            "file": "command.configureHelp.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when configure with unknown property then createHelp has unknown property",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 79
            },
            "line": 16,
            "code": "test('when configure with unknown property then createHelp has unknown property', () => {\n  const program = new commander.Command();\n  program.configureHelp({ mySecretValue: 'secret' });\n  expect(program.createHelp().mySecretValue).toEqual('secret');\n});",
            "file": "command.configureHelp.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when configure with unknown property then helper passed to formatHelp has unknown property",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 96
            },
            "line": 22,
            "code": "test('when configure with unknown property then helper passed to formatHelp has unknown property', () => {\n  const program = new commander.Command();\n  program.configureHelp({\n    mySecretValue: 'secret',\n    formatHelp: (cmd, helper) => {\n      return helper.mySecretValue;\n    }\n  });\n  expect(program.helpInformation()).toEqual('secret');\n});",
            "file": "command.configureHelp.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default writeErr() then error on stderr",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 50
            },
            "line": 3,
            "code": "test('when default writeErr() then error on stderr', () => {\n  const writeSpy = jest.spyOn(process.stderr, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program.exitOverride();\n\n  try {\n    program.parse(['--unknown'], { from: 'user' });\n  } catch (err) {\n  }\n\n  expect(writeSpy).toHaveBeenCalledTimes(1);\n  writeSpy.mockRestore();\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom writeErr() then error on custom output",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 56
            },
            "line": 17,
            "code": "test('when custom writeErr() then error on custom output', () => {\n  const writeSpy = jest.spyOn(process.stderr, 'write').mockImplementation(() => { });\n  const customWrite = jest.fn();\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .configureOutput({ writeErr: customWrite });\n\n  try {\n    program.parse(['--unknown'], { from: 'user' });\n  } catch (err) {\n  }\n\n  expect(writeSpy).toHaveBeenCalledTimes(0);\n  expect(customWrite).toHaveBeenCalledTimes(1);\n  writeSpy.mockRestore();\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default write() then version on stdout",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 49
            },
            "line": 35,
            "code": "test('when default write() then version on stdout', () => {\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .version('1.2.3');\n\n  expect(() => {\n    program.parse(['--version'], { from: 'user' });\n  }).toThrow();\n\n  expect(writeSpy).toHaveBeenCalledTimes(1);\n  writeSpy.mockRestore();\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom write() then version on custom output",
            "suites": [],
            "updatePoint": {
                "line": 50,
                "column": 55
            },
            "line": 50,
            "code": "test('when custom write() then version on custom output', () => {\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const customWrite = jest.fn();\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .version('1.2.3')\n    .configureOutput({ writeOut: customWrite });\n\n  expect(() => {\n    program.parse(['--version'], { from: 'user' });\n  }).toThrow();\n\n  expect(writeSpy).toHaveBeenCalledTimes(0);\n  expect(customWrite).toHaveBeenCalledTimes(1);\n  writeSpy.mockRestore();\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default write() then help on stdout",
            "suites": [],
            "updatePoint": {
                "line": 68,
                "column": 46
            },
            "line": 68,
            "code": "test('when default write() then help on stdout', () => {\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program.outputHelp();\n\n  expect(writeSpy).toHaveBeenCalledTimes(1);\n  writeSpy.mockRestore();\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom write() then help error on custom output",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 58
            },
            "line": 77,
            "code": "test('when custom write() then help error on custom output', () => {\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const customWrite = jest.fn();\n  const program = new commander.Command();\n  program.configureOutput({ writeOut: customWrite });\n  program.outputHelp();\n\n  expect(writeSpy).toHaveBeenCalledTimes(0);\n  expect(customWrite).toHaveBeenCalledTimes(1);\n  writeSpy.mockRestore();\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default writeErr then help error on stderr",
            "suites": [],
            "updatePoint": {
                "line": 89,
                "column": 53
            },
            "line": 89,
            "code": "test('when default writeErr then help error on stderr', () => {\n  const writeSpy = jest.spyOn(process.stderr, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program.outputHelp({ error: true });\n\n  expect(writeSpy).toHaveBeenCalledTimes(1);\n  writeSpy.mockRestore();\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom writeErr then help error on custom output",
            "suites": [],
            "updatePoint": {
                "line": 98,
                "column": 59
            },
            "line": 98,
            "code": "test('when custom writeErr then help error on custom output', () => {\n  const writeSpy = jest.spyOn(process.stderr, 'write').mockImplementation(() => { });\n  const customWrite = jest.fn();\n  const program = new commander.Command();\n  program.configureOutput({ writeErr: customWrite });\n  program.outputHelp({ error: true });\n\n  expect(writeSpy).toHaveBeenCalledTimes(0);\n  expect(customWrite).toHaveBeenCalledTimes(1);\n  writeSpy.mockRestore();\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default getOutHelpWidth then help helpWidth from stdout",
            "suites": [],
            "updatePoint": {
                "line": 110,
                "column": 66
            },
            "line": 110,
            "code": "test('when default getOutHelpWidth then help helpWidth from stdout', () => {\n  const expectedColumns = 123;\n  const holdIsTTY = process.stdout.isTTY;\n  const holdColumns = process.stdout.columns;\n  let helpWidth;\n\n  process.stderr.isTTY = true;\n  process.stdout.columns = expectedColumns;\n  process.stdout.isTTY = true;\n  const program = new commander.Command();\n  program\n    .configureHelp({\n      formatHelp: (cmd, helper) => {\n        helpWidth = helper.helpWidth;\n        return '';\n      }\n    });\n  program.outputHelp();\n\n  expect(helpWidth).toBe(expectedColumns);\n  process.stdout.columns = holdColumns;\n  process.stdout.isTTY = holdIsTTY;\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom getOutHelpWidth then help helpWidth custom",
            "suites": [],
            "updatePoint": {
                "line": 134,
                "column": 60
            },
            "line": 134,
            "code": "test('when custom getOutHelpWidth then help helpWidth custom', () => {\n  const expectedColumns = 123;\n  let helpWidth;\n\n  const program = new commander.Command();\n  program\n    .configureHelp({\n      formatHelp: (cmd, helper) => {\n        helpWidth = helper.helpWidth;\n        return '';\n      }\n    }).configureOutput({\n      getOutHelpWidth: () => expectedColumns\n    });\n  program.outputHelp();\n\n  expect(helpWidth).toBe(expectedColumns);\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default getErrHelpWidth then help error helpWidth from stderr",
            "suites": [],
            "updatePoint": {
                "line": 153,
                "column": 72
            },
            "line": 153,
            "code": "test('when default getErrHelpWidth then help error helpWidth from stderr', () => {\n  const expectedColumns = 123;\n  const holdIsTTY = process.stderr.isTTY;\n  const holdColumns = process.stderr.columns;\n  let helpWidth;\n\n  process.stderr.isTTY = true;\n  process.stderr.columns = expectedColumns;\n  const program = new commander.Command();\n  program\n    .configureHelp({\n      formatHelp: (cmd, helper) => {\n        helpWidth = helper.helpWidth;\n        return '';\n      }\n    });\n  program.outputHelp({ error: true });\n\n  expect(helpWidth).toBe(expectedColumns);\n  process.stderr.isTTY = holdIsTTY;\n  process.stderr.columns = holdColumns;\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom getErrHelpWidth then help error helpWidth custom",
            "suites": [],
            "updatePoint": {
                "line": 176,
                "column": 66
            },
            "line": 176,
            "code": "test('when custom getErrHelpWidth then help error helpWidth custom', () => {\n  const expectedColumns = 123;\n  let helpWidth;\n\n  const program = new commander.Command();\n  program\n    .configureHelp({\n      formatHelp: (cmd, helper) => {\n        helpWidth = helper.helpWidth;\n        return '';\n      }\n    }).configureOutput({\n      getErrHelpWidth: () => expectedColumns\n    });\n  program.outputHelp({ error: true });\n\n  expect(helpWidth).toBe(expectedColumns);\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom getOutHelpWidth and configureHelp:helpWidth then help helpWidth from configureHelp",
            "suites": [],
            "updatePoint": {
                "line": 195,
                "column": 100
            },
            "line": 195,
            "code": "test('when custom getOutHelpWidth and configureHelp:helpWidth then help helpWidth from configureHelp', () => {\n  const expectedColumns = 123;\n  let helpWidth;\n\n  const program = new commander.Command();\n  program\n    .configureHelp({\n      formatHelp: (cmd, helper) => {\n        helpWidth = helper.helpWidth;\n        return '';\n      },\n      helpWidth: expectedColumns\n    }).configureOutput({\n      getOutHelpWidth: () => 999\n    });\n  program.outputHelp();\n\n  expect(helpWidth).toBe(expectedColumns);\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom getErrHelpWidth and configureHelp:helpWidth then help error helpWidth from configureHelp",
            "suites": [],
            "updatePoint": {
                "line": 215,
                "column": 106
            },
            "line": 215,
            "code": "test('when custom getErrHelpWidth and configureHelp:helpWidth then help error helpWidth from configureHelp', () => {\n  const expectedColumns = 123;\n  let helpWidth;\n\n  const program = new commander.Command();\n  program\n    .configureHelp({\n      formatHelp: (cmd, helper) => {\n        helpWidth = helper.helpWidth;\n        return '';\n      },\n      helpWidth: expectedColumns\n    }).configureOutput({\n      getErrHelpWidth: () => 999\n    });\n  program.outputHelp({ error: true });\n\n  expect(helpWidth).toBe(expectedColumns);\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set configureOutput then get configureOutput",
            "suites": [],
            "updatePoint": {
                "line": 235,
                "column": 55
            },
            "line": 235,
            "code": "test('when set configureOutput then get configureOutput', () => {\n  const outputOptions = {\n    writeOut: jest.fn(),\n    writeErr: jest.fn(),\n    getOutHelpWidth: jest.fn(),\n    getErrHelpWidth: jest.fn(),\n    outputError: jest.fn()\n  };\n  const program = new commander.Command();\n  program.configureOutput(outputOptions);\n  expect(program.configureOutput()).toEqual(outputOptions);\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom outputErr and error then outputErr called",
            "suites": [],
            "updatePoint": {
                "line": 248,
                "column": 59
            },
            "line": 248,
            "code": "test('when custom outputErr and error then outputErr called', () => {\n  const outputError = jest.fn();\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .configureOutput({\n      outputError\n    });\n\n  expect(() => {\n    program.parse(['--unknownOption'], { from: 'user' });\n  }).toThrow();\n  expect(outputError).toHaveBeenCalledWith(\"error: unknown option '--unknownOption'\\n\", program._outputConfiguration.writeErr);\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom outputErr and writeErr and error then outputErr passed writeErr",
            "suites": [],
            "updatePoint": {
                "line": 263,
                "column": 81
            },
            "line": 263,
            "code": "test('when custom outputErr and writeErr and error then outputErr passed writeErr', () => {\n  const writeErr = () => jest.fn();\n  const outputError = jest.fn();\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .configureOutput({ writeErr, outputError });\n\n  expect(() => {\n    program.parse(['--unknownOption'], { from: 'user' });\n  }).toThrow();\n  expect(outputError).toHaveBeenCalledWith(\"error: unknown option '--unknownOption'\\n\", writeErr);\n});",
            "file": "command.configureOutput.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add subcommand with .command() then calls copyInheritedSettings from parent",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 86
            },
            "line": 6,
            "code": "test('when add subcommand with .command() then calls copyInheritedSettings from parent', () => {\n  const program = new commander.Command();\n\n  // This is a bit intrusive, but check expectation that copyInheritedSettings is called internally.\n  const copySettingMock = jest.fn();\n  program.createCommand = (name) => {\n    const cmd = new commander.Command(name);\n    cmd.copyInheritedSettings = copySettingMock;\n    return cmd;\n  };\n  program.command('sub');\n\n  expect(copySettingMock).toHaveBeenCalledWith(program);\n});",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies outputConfiguration(config)",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 22,
                "column": 74
            },
            "line": 22,
            "code": "  test('when copyInheritedSettings then copies outputConfiguration(config)', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    source.configureOutput({ foo: 'bar' });\n    cmd.copyInheritedSettings(source);\n    expect(cmd.configureOutput().foo).toEqual('bar');\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies helpOption(false)",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 31,
                "column": 64
            },
            "line": 31,
            "code": "  test('when copyInheritedSettings then copies helpOption(false)', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n    expect(cmd._hasHelpOption).toBeTruthy();\n\n    source.helpOption(false);\n    cmd.copyInheritedSettings(source);\n    expect(cmd._hasHelpOption).toBeFalsy();\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies helpOption(flags, description)",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 41,
                "column": 77
            },
            "line": 41,
            "code": "  test('when copyInheritedSettings then copies helpOption(flags, description)', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    source.helpOption('-Z, --zz', 'ddd');\n    cmd.copyInheritedSettings(source);\n    expect(cmd._helpFlags).toBe('-Z, --zz');\n    expect(cmd._helpDescription).toBe('ddd');\n    expect(cmd._helpShortFlag).toBe('-Z');\n    expect(cmd._helpLongFlag).toBe('--zz');\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies addHelpCommand(name, description)",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 53,
                "column": 80
            },
            "line": 53,
            "code": "  test('when copyInheritedSettings then copies addHelpCommand(name, description)', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    source.addHelpCommand('HELP [cmd]', 'ddd');\n    cmd.copyInheritedSettings(source);\n    expect(cmd._helpCommandName).toBe('HELP');\n    expect(cmd._helpCommandnameAndArgs).toBe('HELP [cmd]');\n    expect(cmd._helpCommandDescription).toBe('ddd');\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies configureHelp(config)",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 64,
                "column": 68
            },
            "line": 64,
            "code": "  test('when copyInheritedSettings then copies configureHelp(config)', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    const configuration = { foo: 'bar', helpWidth: 123, sortSubcommands: true };\n    source.configureHelp(configuration);\n    cmd.copyInheritedSettings(source);\n    expect(cmd.configureHelp()).toEqual(configuration);\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies exitOverride()",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 74,
                "column": 61
            },
            "line": 74,
            "code": "  test('when copyInheritedSettings then copies exitOverride()', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    expect(cmd._exitCallback).toBeFalsy();\n    source.exitOverride();\n    cmd.copyInheritedSettings(source);\n    expect(cmd._exitCallback).toBeTruthy(); // actually a function\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies storeOptionsAsProperties()",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 84,
                "column": 73
            },
            "line": 84,
            "code": "  test('when copyInheritedSettings then copies storeOptionsAsProperties()', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    expect(cmd._storeOptionsAsProperties).toBeFalsy();\n    source.storeOptionsAsProperties();\n    cmd.copyInheritedSettings(source);\n    expect(cmd._storeOptionsAsProperties).toBeTruthy();\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies combineFlagAndOptionalValue()",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 94,
                "column": 76
            },
            "line": 94,
            "code": "  test('when copyInheritedSettings then copies combineFlagAndOptionalValue()', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    expect(cmd._combineFlagAndOptionalValue).toBeTruthy();\n    source.combineFlagAndOptionalValue(false);\n    cmd.copyInheritedSettings(source);\n    expect(cmd._combineFlagAndOptionalValue).toBeFalsy();\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies allowExcessArguments()",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 104,
                "column": 69
            },
            "line": 104,
            "code": "  test('when copyInheritedSettings then copies allowExcessArguments()', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    expect(cmd._allowExcessArguments).toBeTruthy();\n    source.allowExcessArguments(false);\n    cmd.copyInheritedSettings(source);\n    expect(cmd._allowExcessArguments).toBeFalsy();\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies enablePositionalOptions()",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 114,
                "column": 72
            },
            "line": 114,
            "code": "  test('when copyInheritedSettings then copies enablePositionalOptions()', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    expect(cmd._enablePositionalOptions).toBeFalsy();\n    source.enablePositionalOptions();\n    cmd.copyInheritedSettings(source);\n    expect(cmd._enablePositionalOptions).toBeTruthy();\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when copyInheritedSettings then copies showHelpAfterError()",
            "suites": [
                "copyInheritedSettings property tests"
            ],
            "updatePoint": {
                "line": 124,
                "column": 67
            },
            "line": 124,
            "code": "  test('when copyInheritedSettings then copies showHelpAfterError()', () => {\n    const source = new commander.Command();\n    const cmd = new commander.Command();\n\n    expect(cmd._showHelpAfterError).toBeFalsy();\n    source.showHelpAfterError();\n    cmd.copyInheritedSettings(source);\n    expect(cmd._showHelpAfterError).toBeTruthy();\n  });",
            "file": "command.copySettings.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createArgument then used for argument()",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 59
            },
            "line": 21,
            "code": "test('when override createArgument then used for argument()', () => {\n  const program = new MyCommand();\n  program.argument('<file>');\n  expect(program._args.length).toEqual(1);\n  expect(program._args[0].myProperty).toEqual('MyArgument');\n});",
            "file": "command.createArgument.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createArgument then used for arguments()",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 60
            },
            "line": 28,
            "code": "test('when override createArgument then used for arguments()', () => {\n  const program = new MyCommand();\n  program.arguments('<file>');\n  expect(program._args.length).toEqual(1);\n  expect(program._args[0].myProperty).toEqual('MyArgument');\n});",
            "file": "command.createArgument.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createArgument and createCommand then used for argument of command()",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 88
            },
            "line": 35,
            "code": "test('when override createArgument and createCommand then used for argument of command()', () => {\n  const program = new MyCommand();\n  const sub = program.command('sub <file>');\n  expect(sub._args.length).toEqual(1);\n  expect(sub._args[0].myProperty).toEqual('MyArgument');\n});",
            "file": "command.createArgument.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createCommand then affects help",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 51
            },
            "line": 3,
            "code": "test('when override createCommand then affects help', () => {\n  class MyHelp extends commander.Help {\n    formatHelp(cmd, helper) {\n      return 'custom';\n    }\n  }\n\n  class MyCommand extends commander.Command {\n    createHelp() {\n      return Object.assign(new MyHelp(), this.configureHelp());\n    };\n  }\n\n  const program = new MyCommand();\n  expect(program.helpInformation()).toEqual('custom');\n});",
            "file": "command.createHelp.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createOption then used for option()",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 55
            },
            "line": 16,
            "code": "test('when override createOption then used for option()', () => {\n  const program = new MyCommand();\n  program.option('-a, --alpha');\n  expect(program.options.length).toEqual(1);\n  expect(program.options[0].myProperty).toEqual('MyOption');\n});",
            "file": "command.createOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createOption then used for requiredOption()",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 63
            },
            "line": 23,
            "code": "test('when override createOption then used for requiredOption()', () => {\n  const program = new MyCommand();\n  program.requiredOption('-a, --alpha');\n  expect(program.options.length).toEqual(1);\n  expect(program.options[0].myProperty).toEqual('MyOption');\n});",
            "file": "command.createOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createOption then used for version()",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 56
            },
            "line": 30,
            "code": "test('when override createOption then used for version()', () => {\n  const program = new MyCommand();\n  program.version('1.2.3');\n  expect(program.options.length).toEqual(1);\n  expect(program.options[0].myProperty).toEqual('MyOption');\n});",
            "file": "command.createOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createOption then used for help option in visibleOptions",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 76
            },
            "line": 37,
            "code": "test('when override createOption then used for help option in visibleOptions', () => {\n  const program = new MyCommand();\n  const visibleOptions = program.createHelp().visibleOptions(program);\n  expect(visibleOptions.length).toEqual(1);\n  expect(visibleOptions[0].myProperty).toEqual('MyOption');\n});",
            "file": "command.createOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and no command then call default",
            "suites": [
                "default executable command"
            ],
            "updatePoint": {
                "line": 12,
                "column": 64
            },
            "line": 12,
            "code": "  test('when default subcommand and no command then call default', async() => {\n    const { stdout } = await execFileAsync('node', [pm]);\n    expect(stdout).toBe('default\\n');\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and unrecognised argument then call default with argument",
            "suites": [
                "default executable command"
            ],
            "updatePoint": {
                "line": 17,
                "column": 89
            },
            "line": 17,
            "code": "  test('when default subcommand and unrecognised argument then call default with argument', async() => {\n    const { stdout } = await execFileAsync('node', [pm, 'an-argument']);\n    expect(stdout).toBe(\"default\\n[ 'an-argument' ]\\n\");\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and unrecognised option then call default with option",
            "suites": [
                "default executable command"
            ],
            "updatePoint": {
                "line": 22,
                "column": 85
            },
            "line": 22,
            "code": "  test('when default subcommand and unrecognised option then call default with option', async() => {\n    const { stdout } = await execFileAsync('node', [pm, '--an-option']);\n    expect(stdout).toBe(\"default\\n[ '--an-option' ]\\n\");\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and no command then call default",
            "suites": [
                "default action command"
            ],
            "updatePoint": {
                "line": 42,
                "column": 64
            },
            "line": 42,
            "code": "  test('when default subcommand and no command then call default', () => {\n    const { program, actionMock } = makeProgram();\n    program.parse('node test.js'.split(' '));\n    expect(actionMock).toHaveBeenCalled();\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and unrecognised argument then call default",
            "suites": [
                "default action command"
            ],
            "updatePoint": {
                "line": 48,
                "column": 75
            },
            "line": 48,
            "code": "  test('when default subcommand and unrecognised argument then call default', () => {\n    const { program, actionMock } = makeProgram();\n    program.parse('node test.js an-argument'.split(' '));\n    expect(actionMock).toHaveBeenCalled();\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and unrecognised option then call default",
            "suites": [
                "default action command"
            ],
            "updatePoint": {
                "line": 54,
                "column": 73
            },
            "line": 54,
            "code": "  test('when default subcommand and unrecognised option then call default', () => {\n    const { program, actionMock } = makeProgram();\n    program.parse('node test.js --an-option'.split(' '));\n    expect(actionMock).toHaveBeenCalled();\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and no command then call default",
            "suites": [
                "default added command"
            ],
            "updatePoint": {
                "line": 77,
                "column": 64
            },
            "line": 77,
            "code": "  test('when default subcommand and no command then call default', () => {\n    const { program, actionMock } = makeProgram();\n    program.parse('node test.js'.split(' '));\n    expect(actionMock).toHaveBeenCalled();\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and unrecognised argument then call default",
            "suites": [
                "default added command"
            ],
            "updatePoint": {
                "line": 83,
                "column": 75
            },
            "line": 83,
            "code": "  test('when default subcommand and unrecognised argument then call default', () => {\n    const { program, actionMock } = makeProgram();\n    program.parse('node test.js an-argument'.split(' '));\n    expect(actionMock).toHaveBeenCalled();\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default subcommand and unrecognised option then call default",
            "suites": [
                "default added command"
            ],
            "updatePoint": {
                "line": 89,
                "column": 73
            },
            "line": 89,
            "code": "  test('when default subcommand and unrecognised option then call default', () => {\n    const { program, actionMock } = makeProgram();\n    program.parse('node test.js --an-option'.split(' '));\n    expect(actionMock).toHaveBeenCalled();\n  });",
            "file": "command.default.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set description then get description",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 47
            },
            "line": 3,
            "code": "test('when set description then get description', () => {\n  const program = new commander.Command();\n  const description = 'abcdef';\n  program.description(description);\n  expect(program.description()).toMatch(description);\n});",
            "file": "command.description.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when execArgv empty then spawn execArgs empty",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 51
            },
            "line": 12,
            "code": "test('when execArgv empty then spawn execArgs empty', async() => {\n  const { stdout } = await execFileAsync('node', [inspectCommand, 'sub']);\n  expect(stdout).toBe('[]\\n');\n});",
            "file": "command.executableSubcommand.inspect.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when execArgv --harmony then spawn execArgs --harmony",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 59
            },
            "line": 17,
            "code": "test('when execArgv --harmony then spawn execArgs --harmony', async() => {\n  const { stdout } = await execFileAsync('node', ['--harmony', inspectCommand, 'sub']);\n  expect(stdout).toBe(\"[ '--harmony' ]\\n\");\n});",
            "file": "command.executableSubcommand.inspect.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when execArgv --inspect then spawn execArgs using port 9230",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 65
            },
            "line": 23,
            "code": "test('when execArgv --inspect then spawn execArgs using port 9230', async() => {\n  const { stdout } = await execFileAsync('node', ['--inspect', inspectCommand, 'sub']);\n  expect(stdout).toBe(\"[ '--inspect=127.0.0.1:9230' ]\\n\");\n});",
            "file": "command.executableSubcommand.inspect.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when execArgv --inspect=9240 then spawn execArgs using port 9241",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 70
            },
            "line": 29,
            "code": "test('when execArgv --inspect=9240 then spawn execArgs using port 9241', async() => {\n  const { stdout } = await execFileAsync('node', ['--inspect=9240', inspectCommand, 'sub']);\n  expect(stdout).toBe(\"[ '--inspect=127.0.0.1:9241' ]\\n\");\n});",
            "file": "command.executableSubcommand.inspect.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when execArgv --inspect=0 then spawn execArgs --inspect=0",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 63
            },
            "line": 35,
            "code": "test('when execArgv --inspect=0 then spawn execArgs --inspect=0', async() => {\n  const { stdout } = await execFileAsync('node', ['--inspect=0', inspectCommand, 'sub']);\n  expect(stdout).toBe(\"[ '--inspect=0' ]\\n\");\n});",
            "file": "command.executableSubcommand.inspect.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when execArgv --inspect=127.0.0.1:9250 then spawn execArgs --inspect=127.0.0.1:9251",
            "suites": [],
            "updatePoint": {
                "line": 41,
                "column": 89
            },
            "line": 41,
            "code": "test('when execArgv --inspect=127.0.0.1:9250 then spawn execArgs --inspect=127.0.0.1:9251', async() => {\n  const { stdout } = await execFileAsync('node', ['--inspect=127.0.0.1:9250', inspectCommand, 'sub']);\n  expect(stdout).toBe(\"[ '--inspect=127.0.0.1:9251' ]\\n\");\n});",
            "file": "command.executableSubcommand.inspect.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when execArgv --inspect=localhost:9260 then spawn execArgs --inspect=localhost:9261",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 89
            },
            "line": 47,
            "code": "test('when execArgv --inspect=localhost:9260 then spawn execArgs --inspect=localhost:9261', async() => {\n  const { stdout } = await execFileAsync('node', ['--inspect=localhost:9260', inspectCommand, 'sub']);\n  expect(stdout).toBe(\"[ '--inspect=localhost:9261' ]\\n\");\n});",
            "file": "command.executableSubcommand.inspect.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when execArgv --inspect-port=9270 then spawn execArgs --inspect-port=127.0.0.1:9271",
            "suites": [],
            "updatePoint": {
                "line": 53,
                "column": 89
            },
            "line": 53,
            "code": "test('when execArgv --inspect-port=9270 then spawn execArgs --inspect-port=127.0.0.1:9271', async() => {\n  const { stdout } = await execFileAsync('node', ['--inspect-port=9270', inspectCommand, 'sub']);\n  expect(stdout).toBe(\"[ '--inspect-port=127.0.0.1:9271' ]\\n\");\n});",
            "file": "command.executableSubcommand.inspect.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand file missing then error",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 45
            },
            "line": 14,
            "code": "test('when subcommand file missing then error', () => {\n  expect.assertions(1);\n  return execFileAsync('node', [pm, 'list']).catch((err) => {\n    if (process.platform === 'win32') {\n      // Get uncaught thrown error on Windows\n      // eslint-disable-next-line jest/no-conditional-expect\n      expect(err.stderr).toBeDefined();\n    } else {\n      // eslint-disable-next-line jest/no-conditional-expect\n      expect(err.stderr).toMatch(/Error: 'pm-list' does not exist/);\n    }\n  });\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when alias subcommand file missing then error",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 51
            },
            "line": 28,
            "code": "test('when alias subcommand file missing then error', () => {\n  expect.assertions(1);\n  return execFileAsync('node', [pm, 'lst']).catch((err) => {\n    if (process.platform === 'win32') {\n      // Get uncaught thrown error on Windows\n      // eslint-disable-next-line jest/no-conditional-expect\n      expect(err.stderr).toBeDefined();\n    } else {\n      // eslint-disable-next-line jest/no-conditional-expect\n      expect(err.stderr).toMatch(/Error: 'pm-list' does not exist/);\n    }\n  });\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand file has no suffix then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 61
            },
            "line": 42,
            "code": "test('when subcommand file has no suffix then lookup succeeds', async() => {\n  const { stdout } = await execFileAsync('node', [pm, 'install']);\n  expect(stdout).toBe('install\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when alias subcommand file has no suffix then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 67
            },
            "line": 47,
            "code": "test('when alias subcommand file has no suffix then lookup succeeds', async() => {\n  const { stdout } = await execFileAsync('node', [pm, 'i']);\n  expect(stdout).toBe('install\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand target executablefile has no suffix then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 78
            },
            "line": 52,
            "code": "test('when subcommand target executablefile has no suffix then lookup succeeds', async() => {\n  const { stdout } = await execFileAsync('node', [pm, 'specifyInstall']);\n  expect(stdout).toBe('install\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand file suffix .js then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 58
            },
            "line": 57,
            "code": "test('when subcommand file suffix .js then lookup succeeds', async() => {\n  const { stdout } = await execFileAsync('node', [pm, 'publish']);\n  expect(stdout).toBe('publish\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when alias subcommand file suffix .js then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 64
            },
            "line": 62,
            "code": "test('when alias subcommand file suffix .js then lookup succeeds', async() => {\n  const { stdout } = await execFileAsync('node', [pm, 'p']);\n  expect(stdout).toBe('publish\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand target executablefile has suffix .js then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 79
            },
            "line": 67,
            "code": "test('when subcommand target executablefile has suffix .js then lookup succeeds', async() => {\n  const { stdout } = await execFileAsync('node', [pm, 'specifyPublish']);\n  expect(stdout).toBe('publish\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand suffix is .ts then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 56
            },
            "line": 84,
            "code": "test('when subcommand suffix is .ts then lookup succeeds', async() => {\n  // We support looking for ts files for ts-node in particular, but don't need to test ts-node itself.\n  // The subcommand is both plain JavaScript code for this test.\n  const binLinkTs = path.join(__dirname, 'fixtures-extensions', 'pm.js');\n  // childProcess.execFile('node', ['-r', 'ts-node/register', binLinkTs, 'install'], function(_error, stdout, stderr) {\n  const { stdout } = await execFileAsync('node', [binLinkTs, 'try-ts']);\n  expect(stdout).toBe('found .ts\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand suffix is .cjs then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 93,
                "column": 57
            },
            "line": 93,
            "code": "test('when subcommand suffix is .cjs then lookup succeeds', async() => {\n  const binLinkTs = path.join(__dirname, 'fixtures-extensions', 'pm.js');\n  const { stdout } = await execFileAsync('node', [binLinkTs, 'try-cjs']);\n  expect(stdout).toBe('found .cjs\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand suffix is .mjs then lookup succeeds",
            "suites": [],
            "updatePoint": {
                "line": 99,
                "column": 57
            },
            "line": 99,
            "code": "test('when subcommand suffix is .mjs then lookup succeeds', async() => {\n  const binLinkTs = path.join(__dirname, 'fixtures-extensions', 'pm.js');\n  const { stdout } = await execFileAsync('node', [binLinkTs, 'try-mjs']);\n  expect(stdout).toBe('found .mjs\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subsubcommand then lookup sub-sub-command",
            "suites": [],
            "updatePoint": {
                "line": 105,
                "column": 52
            },
            "line": 105,
            "code": "test('when subsubcommand then lookup sub-sub-command', async() => {\n  const { stdout } = await execFileAsync('node', [pm, 'cache', 'clear']);\n  expect(stdout).toBe('cache-clear\\n');\n});",
            "file": "command.executableSubcommand.lookup.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand executable missing (ENOENT) then throw custom message",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 75
            },
            "line": 15,
            "code": "test('when subcommand executable missing (ENOENT) then throw custom message', () => {\n  // If the command is not found, we show a custom error with an explanation and offer\n  // some advice for possible fixes.\n  const mockProcess = new EventEmitter();\n  const spawnSpy = jest.spyOn(childProcess, 'spawn').mockImplementation(() => { return mockProcess; });\n  const program = new commander.Command();\n  program.exitOverride();\n  program.command('executable', 'executable description');\n  program.parse(['executable'], { from: 'user' });\n  expect(() => {\n    mockProcess.emit('error', makeSystemError('ENOENT'));\n  }).toThrow('use the executableFile option to supply a custom name'); // part of custom message\n  spawnSpy.mockRestore();\n});",
            "file": "command.executableSubcommand.mock.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand executable not executable (EACCES) then throw custom message",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 82
            },
            "line": 30,
            "code": "test('when subcommand executable not executable (EACCES) then throw custom message', () => {\n  // Side note: this error does not actually happen on Windows! But we can still simulate the behaviour on other platforms.\n  const mockProcess = new EventEmitter();\n  const spawnSpy = jest.spyOn(childProcess, 'spawn').mockImplementation(() => { return mockProcess; });\n  const program = new commander.Command();\n  program.exitOverride();\n  program.command('executable', 'executable description');\n  program.parse(['executable'], { from: 'user' });\n  expect(() => {\n    mockProcess.emit('error', makeSystemError('EACCES'));\n  }).toThrow('not executable'); // part of custom message\n  spawnSpy.mockRestore();\n});",
            "file": "command.executableSubcommand.mock.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand executable fails with other error  and exitOverride then return in custom wrapper",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 103
            },
            "line": 44,
            "code": "test('when subcommand executable fails with other error  and exitOverride then return in custom wrapper', () => {\n  // The existing behaviour is to just silently fail for unexpected errors, as it is happening\n  // asynchronously in spawned process and client can not catch errors.\n  const mockProcess = new EventEmitter();\n  const spawnSpy = jest.spyOn(childProcess, 'spawn').mockImplementation(() => { return mockProcess; });\n  const program = new commander.Command();\n  program.exitOverride((err) => {\n    throw err;\n  });\n  program.command('executable', 'executable description');\n  program.parse(['executable'], { from: 'user' });\n  let caughtErr;\n  try {\n    mockProcess.emit('error', makeSystemError('OTHER'));\n  } catch (err) {\n    caughtErr = err;\n  }\n  expect(caughtErr.code).toEqual('commander.executeSubCommandAsync');\n  expect(caughtErr.nestedError.code).toEqual('OTHER');\n  spawnSpy.mockRestore();\n});",
            "file": "command.executableSubcommand.mock.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand executable fails with other error then exit",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 65
            },
            "line": 66,
            "code": "test('when subcommand executable fails with other error then exit', () => {\n  // The existing behaviour is to just silently fail for unexpected errors, as it is happening\n  // asynchronously in spawned process and client can not catch errors.\n  const mockProcess = new EventEmitter();\n  const spawnSpy = jest.spyOn(childProcess, 'spawn').mockImplementation(() => { return mockProcess; });\n  const exitSpy = jest.spyOn(process, 'exit').mockImplementation(() => { });\n  const program = new commander.Command();\n  program.command('executable', 'executable description');\n  program.parse(['executable'], { from: 'user' });\n  mockProcess.emit('error', makeSystemError('OTHER'));\n  expect(exitSpy).toHaveBeenCalledWith(1);\n  exitSpy.mockRestore();\n  spawnSpy.mockRestore();\n});",
            "file": "command.executableSubcommand.mock.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "test signal handling in executableSubcommand",
            "suites": [],
            "line": 17,
            "code": "describeOrSkipOnWindows.each([['SIGINT'], ['SIGHUP'], ['SIGTERM'], ['SIGUSR1'], ['SIGUSR2']])(\n  'test signal handling in executableSubcommand', (value) => {\n    // Slightly tricky test, stick with callback and disable lint warning.\n    // eslint-disable-next-line jest/no-done-callback\n    test(`when command killed with ${value} then executableSubcommand receives ${value}`, (done) => {\n      const pmPath = path.join(__dirname, './fixtures/pm');\n\n      // The child process writes to stdout.\n      const proc = childProcess.spawn(pmPath, ['listen'], {});\n\n      let processOutput = '';\n      proc.stdout.on('data', (data) => {\n        if (processOutput.length === 0) {\n          proc.kill(`${value}`);\n        }\n        processOutput += data.toString();\n      });\n      proc.on('close', (code) => {\n        expect(processOutput).toBe(`Listening for signal...${value}`);\n        done();\n      });\n    });\n  });",
            "file": "command.executableSubcommand.signals.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command killed with  then executableSubcommand receives ",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 87
            },
            "line": 21,
            "code": "    test(`when command killed with ${value} then executableSubcommand receives ${value}`, (done) => {\n      const pmPath = path.join(__dirname, './fixtures/pm');\n\n      // The child process writes to stdout.\n      const proc = childProcess.spawn(pmPath, ['listen'], {});\n\n      let processOutput = '';\n      proc.stdout.on('data', (data) => {\n        if (processOutput.length === 0) {\n          proc.kill(`${value}`);\n        }\n        processOutput += data.toString();\n      });\n      proc.on('close', (code) => {\n        expect(processOutput).toBe(`Listening for signal...${value}`);\n        done();\n      });\n    });",
            "file": "command.executableSubcommand.signals.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no command specified and executable then display help",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 64
            },
            "line": 6,
            "code": "test('when no command specified and executable then display help', () => {\n  // Optional. Suppress normal output to keep test output clean.\n  const writeSpy = jest.spyOn(process.stderr, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program\n    .exitOverride((err) => { throw err; })\n    .command('install', 'install description');\n  expect(() => {\n    program.parse(['node', 'test']);\n  }).toThrow('(outputHelp)');\n  writeSpy.mockClear();\n});",
            "file": "command.executableSubcommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown program option then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 34,
                "column": 69
            },
            "line": 34,
            "code": "  test('when specify unknown program option then throw CommanderError', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride();\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', '-m']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(stderrSpy).toHaveBeenCalled();\n    expectCommanderError(caughtErr, 1, 'commander.unknownOption', \"error: unknown option '-m'\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown command then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 50,
                "column": 62
            },
            "line": 50,
            "code": "  test('when specify unknown command then throw CommanderError', () => {\n    const program = new commander.Command();\n    program\n      .name('prog')\n      .exitOverride()\n      .command('sub');\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'oops']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(stderrSpy).toHaveBeenCalled();\n    expectCommanderError(caughtErr, 1, 'commander.unknownCommand', \"error: unknown command 'oops'\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when supply custom handler then throw custom error",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 69,
                "column": 58
            },
            "line": 69,
            "code": "  test('when supply custom handler then throw custom error', () => {\n    const customError = new commander.CommanderError(123, 'custom-code', 'custom-message');\n    const program = new commander.Command();\n    program\n      .exitOverride((_err) => {\n        throw customError;\n      });\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', '-m']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, customError.exitCode, customError.code, customError.message);\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify option without required value then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 87,
                "column": 76
            },
            "line": 87,
            "code": "  test('when specify option without required value then throw CommanderError', () => {\n    const optionFlags = '-p, --pepper <type>';\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .option(optionFlags, 'add pepper');\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', '--pepper']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(stderrSpy).toHaveBeenCalled();\n    expectCommanderError(caughtErr, 1, 'commander.optionMissingArgument', `error: option '${optionFlags}' argument missing`);\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify command without required argument then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 105,
                "column": 80
            },
            "line": 105,
            "code": "  test('when specify command without required argument then throw CommanderError', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('compress <arg-name>')\n      .action(() => { });\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'compress']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(stderrSpy).toHaveBeenCalled();\n    expectCommanderError(caughtErr, 1, 'commander.missingArgument', \"error: missing required argument 'arg-name'\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify program without required argument and no action handler then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 123,
                "column": 102
            },
            "line": 123,
            "code": "  test('when specify program without required argument and no action handler then throw CommanderError', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .argument('<arg-name>');\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(stderrSpy).toHaveBeenCalled();\n    expectCommanderError(caughtErr, 1, 'commander.missingArgument', \"error: missing required argument 'arg-name'\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify excess argument then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 140,
                "column": 62
            },
            "line": 140,
            "code": "  test('when specify excess argument then throw CommanderError', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .allowExcessArguments(false)\n      .action(() => { });\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'excess']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(stderrSpy).toHaveBeenCalled();\n    expectCommanderError(caughtErr, 1, 'commander.excessArguments', 'error: too many arguments. Expected 0 arguments but got 1.');\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify command with excess argument then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 158,
                "column": 75
            },
            "line": 158,
            "code": "  test('when specify command with excess argument then throw CommanderError', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('speak')\n      .allowExcessArguments(false)\n      .action(() => { });\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'speak', 'excess']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(stderrSpy).toHaveBeenCalled();\n    expectCommanderError(caughtErr, 1, 'commander.excessArguments', \"error: too many arguments for 'speak'. Expected 0 arguments but got 1.\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify --help then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 177,
                "column": 53
            },
            "line": 177,
            "code": "  test('when specify --help then throw CommanderError', () => {\n    const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n    const program = new commander.Command();\n    program\n      .exitOverride();\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', '--help']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, 0, 'commander.helpDisplayed', '(outputHelp)');\n    writeSpy.mockRestore();\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when executable subcommand and no command specified then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 194,
                "column": 85
            },
            "line": 194,
            "code": "  test('when executable subcommand and no command specified then throw CommanderError', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('compress', 'compress description');\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, 1, 'commander.help', '(outputHelp)');\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify --version then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 210,
                "column": 56
            },
            "line": 210,
            "code": "  test('when specify --version then throw CommanderError', () => {\n    const stdoutSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n    const myVersion = '1.2.3';\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .version(myVersion);\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', '--version']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, 0, 'commander.version', myVersion);\n    stdoutSpy.mockRestore();\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when executableSubcommand succeeds then call exitOverride",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 229,
                "column": 65
            },
            "line": 229,
            "code": "  test('when executableSubcommand succeeds then call exitOverride', async() => {\n    expect.hasAssertions();\n    const pm = path.join(__dirname, 'fixtures/pm');\n    const program = new commander.Command();\n    await new Promise((resolve) => {\n      program\n        .exitOverride((err) => {\n          expectCommanderError(err, 0, 'commander.executeSubCommandAsync', '(close)');\n          resolve();\n        })\n        .command('silent', 'description');\n      program.parse(['node', pm, 'silent']);\n    });\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when mandatory program option missing then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 244,
                "column": 71
            },
            "line": 244,
            "code": "  test('when mandatory program option missing then throw CommanderError', () => {\n    const optionFlags = '-p, --pepper <type>';\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption(optionFlags, 'add pepper');\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, 1, 'commander.missingMandatoryOptionValue', `error: required option '${optionFlags}' not specified`);\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option argument not in choices then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 261,
                "column": 69
            },
            "line": 261,
            "code": "  test('when option argument not in choices then throw CommanderError', () => {\n    const optionFlags = '--colour <shade>';\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addOption(new commander.Option(optionFlags).choices(['red', 'blue']));\n\n    let caughtErr;\n    try {\n      program.parse(['--colour', 'green'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, 1, 'commander.invalidArgument', \"error: option '--colour <shade>' argument 'green' is invalid. Allowed choices are red, blue.\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command argument not in choices then throw CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 278,
                "column": 70
            },
            "line": 278,
            "code": "  test('when command argument not in choices then throw CommanderError', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addArgument(new commander.Argument('<shade>').choices(['red', 'blue']))\n      .action(() => {});\n\n    let caughtErr;\n    try {\n      program.parse(['green'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, 1, 'commander.invalidArgument', \"error: command-argument value 'green' is invalid for argument 'shade'. Allowed choices are red, blue.\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom processing for option throws InvalidArgumentError then catch CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 295,
                "column": 95
            },
            "line": 295,
            "code": "  test('when custom processing for option throws InvalidArgumentError then catch CommanderError', () => {\n    function justSayNo(value) {\n      throw new commander.InvalidArgumentError('NO');\n    }\n    const optionFlags = '--colour <shade>';\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .option(optionFlags, 'specify shade', justSayNo);\n\n    let caughtErr;\n    try {\n      program.parse(['--colour', 'green'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, 1, 'commander.invalidArgument', \"error: option '--colour <shade>' argument 'green' is invalid. NO\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom processing for argument throws InvalidArgumentError then catch CommanderError",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 315,
                "column": 97
            },
            "line": 315,
            "code": "  test('when custom processing for argument throws InvalidArgumentError then catch CommanderError', () => {\n    function justSayNo(value) {\n      throw new commander.InvalidArgumentError('NO');\n    }\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .argument('[n]', 'number', justSayNo)\n      .action(() => {});\n\n    let caughtErr;\n    try {\n      program.parse(['green'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expectCommanderError(caughtErr, 1, 'commander.invalidArgument', \"error: command-argument value 'green' is invalid for argument 'n'. NO\");\n  });",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no override and error then exit(1)",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 336,
                "column": 45
            },
            "line": 336,
            "code": "test('when no override and error then exit(1)', () => {\n  const exitSpy = jest.spyOn(process, 'exit').mockImplementation(() => { });\n  const program = new commander.Command();\n  program.configureOutput({ outputError: () => {} });\n  program.parse(['--unknownOption'], { from: 'user' });\n  expect(exitSpy).toHaveBeenCalledWith(1);\n  exitSpy.mockRestore();\n});",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom processing throws custom error then throw custom error",
            "suites": [
                ".exitOverride and error details"
            ],
            "updatePoint": {
                "line": 345,
                "column": 72
            },
            "line": 345,
            "code": "test('when custom processing throws custom error then throw custom error', () => {\n  function justSayNo(value) {\n    throw new Error('custom');\n  }\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .option('-s, --shade <value>', 'specify shade', justSayNo);\n\n  expect(() => {\n    program.parse(['--shade', 'green'], { from: 'user' });\n  }).toThrow('custom');\n});",
            "file": "command.exitOverride.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call helpInformation for program then help format is as expected (usage, options, commands)",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 102
            },
            "line": 9,
            "code": "test('when call helpInformation for program then help format is as expected (usage, options, commands)', () => {\n  const program = new commander.Command();\n  program\n    .command('my-command <file>');\n  const expectedHelpInformation =\n`Usage: test [options] [command]\n\nOptions:\n  -h, --help         display help for command\n\nCommands:\n  my-command <file>\n  help [command]     display help for command\n`;\n\n  program.name('test');\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toBe(expectedHelpInformation);\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when use .description for command then help includes description",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 70
            },
            "line": 29,
            "code": "test('when use .description for command then help includes description', () => {\n  const program = new commander.Command();\n  program\n    .command('simple-command')\n    .description('custom-description');\n  program._help = 'test';\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch(/simple-command +custom-description/);\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .help then exit",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 31
            },
            "line": 39,
            "code": "test('when call .help then exit', () => {\n  // Optional. Suppress normal output to keep test output clean.\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program\n    .exitOverride();\n  expect(() => {\n    program.help();\n  }).toThrow('(outputHelp)');\n  writeSpy.mockClear();\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify --help then exit",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 35
            },
            "line": 51,
            "code": "test('when specify --help then exit', () => {\n  // Optional. Suppress normal output to keep test output clean.\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program\n    .exitOverride();\n  expect(() => {\n    program.parse(['node', 'test', '--help']);\n  }).toThrow('(outputHelp)');\n  writeSpy.mockClear();\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call help(cb) then display cb output and exit",
            "suites": [],
            "updatePoint": {
                "line": 63,
                "column": 56
            },
            "line": 63,
            "code": "test('when call help(cb) then display cb output and exit', () => {\n  // Using spy to detect custom output\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const helpReplacement = 'reformatted help';\n  const program = new commander.Command();\n  program\n    .exitOverride();\n  expect(() => {\n    program.help((helpInformation) => {\n      return helpReplacement;\n    });\n  }).toThrow('(outputHelp)');\n  expect(writeSpy).toHaveBeenCalledWith(helpReplacement);\n  writeSpy.mockClear();\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call outputHelp(cb) then display cb output",
            "suites": [],
            "updatePoint": {
                "line": 79,
                "column": 53
            },
            "line": 79,
            "code": "test('when call outputHelp(cb) then display cb output', () => {\n  // Using spy to detect custom output\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const helpReplacement = 'reformatted help';\n  const program = new commander.Command();\n  program.outputHelp((helpInformation) => {\n    return helpReplacement;\n  });\n  expect(writeSpy).toHaveBeenCalledWith(helpReplacement);\n  writeSpy.mockClear();\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call deprecated outputHelp(cb) with wrong callback return type then throw",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 84
            },
            "line": 91,
            "code": "test('when call deprecated outputHelp(cb) with wrong callback return type then throw', () => {\n  const program = new commander.Command();\n  expect(() => {\n    program.outputHelp((helpInformation) => 3);\n  }).toThrow();\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command sets deprecated noHelp then not displayed in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 98,
                "column": 79
            },
            "line": 98,
            "code": "test('when command sets deprecated noHelp then not displayed in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .command('secret', 'secret description', { noHelp: true });\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).not.toMatch('secret');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command sets hidden then not displayed in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 68
            },
            "line": 106,
            "code": "test('when command sets hidden then not displayed in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .command('secret', 'secret description', { hidden: true });\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).not.toMatch('secret');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when addCommand with hidden:true then not displayed in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 114,
                "column": 76
            },
            "line": 114,
            "code": "test('when addCommand with hidden:true then not displayed in helpInformation', () => {\n  const secretCmd = new commander.Command('secret');\n\n  const program = new commander.Command();\n  program\n    .addCommand(secretCmd, { hidden: true });\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).not.toMatch('secret');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help short flag masked then not displayed in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 124,
                "column": 71
            },
            "line": 124,
            "code": "test('when help short flag masked then not displayed in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .option('-h, --host', 'select host');\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).not.toMatch(/\\W-h\\W.*display help/);\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when both help flags masked then not displayed in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 132,
                "column": 71
            },
            "line": 132,
            "code": "test('when both help flags masked then not displayed in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .option('-h, --help', 'custom');\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).not.toMatch('display help');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .help then output on stdout",
            "suites": [],
            "updatePoint": {
                "line": 140,
                "column": 43
            },
            "line": 140,
            "code": "test('when call .help then output on stdout', () => {\n  const writeSpy = jest.spyOn(process.stdout, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program\n    .exitOverride();\n  expect(() => {\n    program.help();\n  }).toThrow('(outputHelp)');\n  expect(writeSpy).toHaveBeenCalledWith(program.helpInformation());\n  writeSpy.mockClear();\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .help with { error: true } then output on stderr",
            "suites": [],
            "updatePoint": {
                "line": 152,
                "column": 64
            },
            "line": 152,
            "code": "test('when call .help with { error: true } then output on stderr', () => {\n  const writeSpy = jest.spyOn(process.stderr, 'write').mockImplementation(() => { });\n  const program = new commander.Command();\n  program\n    .exitOverride();\n  expect(() => {\n    program.help({ error: true });\n  }).toThrow('(outputHelp)');\n  expect(writeSpy).toHaveBeenCalledWith(program.helpInformation());\n  writeSpy.mockClear();\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no options then Options not included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 164,
                "column": 66
            },
            "line": 164,
            "code": "test('when no options then Options not included in helpInformation', () => {\n  const program = new commander.Command();\n  // No custom options, no version option, no help option\n  program\n    .helpOption(false);\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).not.toMatch('Options');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when negated option then option included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 173,
                "column": 65
            },
            "line": 173,
            "code": "test('when negated option then option included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .option('-C, --no-colour', 'colourless');\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('--no-colour');\n  expect(helpInformation).toMatch('colourless');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option.hideHelp() then option not included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 182,
                "column": 72
            },
            "line": 182,
            "code": "test('when option.hideHelp() then option not included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .addOption(new commander.Option('-s,--secret', 'secret option').hideHelp());\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).not.toMatch('secret');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option.hideHelp(true) then option not included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 190,
                "column": 76
            },
            "line": 190,
            "code": "test('when option.hideHelp(true) then option not included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .addOption(new commander.Option('-s,--secret', 'secret option').hideHelp(true));\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).not.toMatch('secret');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option.hideHelp(false) then option included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 198,
                "column": 73
            },
            "line": 198,
            "code": "test('when option.hideHelp(false) then option included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .addOption(new commander.Option('-s,--secret', 'secret option').hideHelp(false));\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('secret');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has default value then default included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 206,
                "column": 76
            },
            "line": 206,
            "code": "test('when option has default value then default included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .option('-p, --port <portNumber>', 'port number', 80);\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('(default: 80)');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has default value description then default description included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 214,
                "column": 100
            },
            "line": 214,
            "code": "test('when option has default value description then default description included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .addOption(new commander.Option('-a, --address <dotted>', 'ip address').default('127.0.0.1', 'home'));\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('(default: home)');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has choices then choices included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 222,
                "column": 70
            },
            "line": 222,
            "code": "test('when option has choices then choices included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .addOption(new commander.Option('-c, --colour <colour>').choices(['red', 'blue']));\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('(choices: \"red\", \"blue\")');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has choices and default then both included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 230,
                "column": 79
            },
            "line": 230,
            "code": "test('when option has choices and default then both included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .addOption(new commander.Option('-c, --colour <colour>').choices(['red', 'blue']).default('red'));\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('(choices: \"red\", \"blue\", default: \"red\")');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument then included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 238,
                "column": 52
            },
            "line": 238,
            "code": "test('when argument then included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .name('foo')\n    .argument('<file>');\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('Usage: foo [options] <file>');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument described then included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 247,
                "column": 62
            },
            "line": 247,
            "code": "test('when argument described then included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .argument('<file>', 'input source')\n    .helpOption(false);\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch(/Arguments:\\n +file +input source/);\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument described with default then included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 256,
                "column": 75
            },
            "line": 256,
            "code": "test('when argument described with default then included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .argument('[file]', 'input source', 'test.txt')\n    .helpOption(false);\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch(/Arguments:\\n +file +input source \\(default: \"test.txt\"\\)/);\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when arguments described in deprecated way then included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 265,
                "column": 81
            },
            "line": 265,
            "code": "test('when arguments described in deprecated way then included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .arguments('<file>')\n    .helpOption(false)\n    .description('description', { file: 'input source' });\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch(/Arguments:\\n +file +input source/);\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when arguments described in deprecated way and empty description then arguments still included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 275,
                "column": 119
            },
            "line": 275,
            "code": "test('when arguments described in deprecated way and empty description then arguments still included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .arguments('<file>')\n    .helpOption(false)\n    .description('', { file: 'input source' });\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch(/Arguments:\\n +file +input source/);\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument has choices then choices included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 285,
                "column": 72
            },
            "line": 285,
            "code": "test('when argument has choices then choices included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .addArgument(new commander.Argument('<colour>', 'preferred colour').choices(['red', 'blue']));\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('(choices: \"red\", \"blue\")');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument has choices and default then both included in helpInformation",
            "suites": [],
            "updatePoint": {
                "line": 293,
                "column": 81
            },
            "line": 293,
            "code": "test('when argument has choices and default then both included in helpInformation', () => {\n  const program = new commander.Command();\n  program\n    .addArgument(new commander.Argument('<colour>', 'preferred colour').choices(['red', 'blue']).default('red'));\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch('(choices: \"red\", \"blue\", default: \"red\")');\n});",
            "file": "command.help.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has no subcommands then no automatic help command",
            "suites": [
                "help command listed in helpInformation"
            ],
            "updatePoint": {
                "line": 4,
                "column": 70
            },
            "line": 4,
            "code": "  test('when program has no subcommands then no automatic help command', () => {\n    const program = new commander.Command();\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).not.toMatch(/help \\[command\\]/);\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has no subcommands and add help command then has help command",
            "suites": [
                "help command listed in helpInformation"
            ],
            "updatePoint": {
                "line": 10,
                "column": 82
            },
            "line": 10,
            "code": "  test('when program has no subcommands and add help command then has help command', () => {\n    const program = new commander.Command();\n    program.addHelpCommand(true);\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).toMatch(/help \\[command\\]/);\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has subcommands then has automatic help command",
            "suites": [
                "help command listed in helpInformation"
            ],
            "updatePoint": {
                "line": 17,
                "column": 68
            },
            "line": 17,
            "code": "  test('when program has subcommands then has automatic help command', () => {\n    const program = new commander.Command();\n    program.command('foo');\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).toMatch(/help \\[command\\]/);\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has subcommands and specify only unknown option then display help",
            "suites": [
                "help command listed in helpInformation"
            ],
            "updatePoint": {
                "line": 24,
                "column": 86
            },
            "line": 24,
            "code": "  test('when program has subcommands and specify only unknown option then display help', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ formatHelp: () => '' })\n      .exitOverride()\n      .allowUnknownOption()\n      .command('foo');\n    let caughtErr;\n    try {\n      program.parse(['--unknown'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toEqual('commander.help');\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has subcommands and suppress help command then no help command",
            "suites": [
                "help command listed in helpInformation"
            ],
            "updatePoint": {
                "line": 40,
                "column": 83
            },
            "line": 40,
            "code": "  test('when program has subcommands and suppress help command then no help command', () => {\n    const program = new commander.Command();\n    program.addHelpCommand(false);\n    program.command('foo');\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).not.toMatch(/help \\[command\\]/);\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add custom help command then custom help command",
            "suites": [
                "help command listed in helpInformation"
            ],
            "updatePoint": {
                "line": 48,
                "column": 61
            },
            "line": 48,
            "code": "  test('when add custom help command then custom help command', () => {\n    const program = new commander.Command();\n    program.addHelpCommand('myHelp', 'help description');\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).toMatch(/myHelp +help description/);\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"program help\" then program",
            "suites": [
                "help command processed on correct command"
            ],
            "updatePoint": {
                "line": 76,
                "column": 40
            },
            "line": 76,
            "code": "  test('when \"program help\" then program', () => {\n    const program = new commander.Command();\n    program.exitOverride();\n    program.command('sub1');\n    program.exitOverride(() => { throw new Error('program'); });\n    expect(() => {\n      program.parse('node test.js help'.split(' '));\n    }).toThrow('program');\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"program help unknown\" then program",
            "suites": [
                "help command processed on correct command"
            ],
            "updatePoint": {
                "line": 86,
                "column": 48
            },
            "line": 86,
            "code": "  test('when \"program help unknown\" then program', () => {\n    const program = new commander.Command();\n    program.exitOverride();\n    program.command('sub1');\n    program.exitOverride(() => { throw new Error('program'); });\n    expect(() => {\n      program.parse('node test.js help unknown'.split(' '));\n    }).toThrow('program');\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"program help sub1\" then sub1",
            "suites": [
                "help command processed on correct command"
            ],
            "updatePoint": {
                "line": 96,
                "column": 42
            },
            "line": 96,
            "code": "  test('when \"program help sub1\" then sub1', () => {\n    const program = new commander.Command();\n    program.exitOverride();\n    const sub1 = program.command('sub1');\n    sub1.exitOverride(() => { throw new Error('sub1'); });\n    expect(() => {\n      program.parse('node test.js help sub1'.split(' '));\n    }).toThrow('sub1');\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"program sub1 help sub2\" then sub2",
            "suites": [
                "help command processed on correct command"
            ],
            "updatePoint": {
                "line": 106,
                "column": 47
            },
            "line": 106,
            "code": "  test('when \"program sub1 help sub2\" then sub2', () => {\n    const program = new commander.Command();\n    program.exitOverride();\n    const sub1 = program.command('sub1');\n    const sub2 = sub1.command('sub2');\n    sub2.exitOverride(() => { throw new Error('sub2'); });\n    expect(() => {\n      program.parse('node test.js sub1 help sub2'.split(' '));\n    }).toThrow('sub2');\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default command and \"program help\" then program",
            "suites": [
                "help command processed on correct command"
            ],
            "updatePoint": {
                "line": 117,
                "column": 60
            },
            "line": 117,
            "code": "  test('when default command and \"program help\" then program', () => {\n    const program = new commander.Command();\n    program.exitOverride();\n    program.command('sub1', { isDefault: true });\n    program.exitOverride(() => { throw new Error('program'); });\n    expect(() => {\n      program.parse('node test.js help'.split(' '));\n    }).toThrow('program');\n  });",
            "file": "command.helpCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption has custom flags then custom short flag invokes help",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 23,
                "column": 76
            },
            "line": 23,
            "code": "  test('when helpOption has custom flags then custom short flag invokes help', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .helpOption('-c,--custom-help', 'custom help output');\n    expect(() => {\n      program.parse(['-c'], { from: 'user' });\n    }).toThrow('(outputHelp)');\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption has custom flags then custom long flag invokes help",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 33,
                "column": 75
            },
            "line": 33,
            "code": "  test('when helpOption has custom flags then custom long flag invokes help', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .helpOption('-c,--custom-help', 'custom help output');\n    expect(() => {\n      program.parse(['--custom-help'], { from: 'user' });\n    }).toThrow('(outputHelp)');\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption has just custom short flag then custom short flag invokes help",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 43,
                "column": 86
            },
            "line": 43,
            "code": "  test('when helpOption has just custom short flag then custom short flag invokes help', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .helpOption('-c', 'custom help output');\n    expect(() => {\n      program.parse(['-c'], { from: 'user' });\n    }).toThrow('(outputHelp)');\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption has just custom long flag then custom long flag invokes help",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 53,
                "column": 84
            },
            "line": 53,
            "code": "  test('when helpOption has just custom long flag then custom long flag invokes help', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .helpOption('--custom-help', 'custom help output');\n    expect(() => {\n      program.parse(['--custom-help'], { from: 'user' });\n    }).toThrow('(outputHelp)');\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption has custom description then helpInformation include custom description",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 63,
                "column": 94
            },
            "line": 63,
            "code": "  test('when helpOption has custom description then helpInformation include custom description', () => {\n    const program = new commander.Command();\n    program\n      .helpOption('-C,--custom-help', 'custom help output');\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).toMatch(/-C,--custom-help +custom help output/);\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption has just flags then helpInformation includes default description",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 71,
                "column": 88
            },
            "line": 71,
            "code": "  test('when helpOption has just flags then helpInformation includes default description', () => {\n    const program = new commander.Command();\n    program\n      .helpOption('-C,--custom-help');\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).toMatch(/-C,--custom-help +display help for command/);\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption has just description then helpInformation includes default flags",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 79,
                "column": 88
            },
            "line": 79,
            "code": "  test('when helpOption has just description then helpInformation includes default flags', () => {\n    const program = new commander.Command();\n    program\n      .helpOption(undefined, 'custom help output');\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).toMatch(/-h, --help +custom help output/);\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption(false) then helpInformation does not include --help",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 87,
                "column": 75
            },
            "line": 87,
            "code": "  test('when helpOption(false) then helpInformation does not include --help', () => {\n    const program = new commander.Command();\n    program\n      .helpOption(false);\n    const helpInformation = program.helpInformation();\n    expect(helpInformation).not.toMatch('--help');\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption(false) then --help is an unknown option",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 95,
                "column": 63
            },
            "line": 95,
            "code": "  test('when helpOption(false) then --help is an unknown option', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .helpOption(false);\n    let caughtErr;\n    try {\n      program.parse(['--help'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption(false) then -h is an unknown option",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 109,
                "column": 59
            },
            "line": 109,
            "code": "  test('when helpOption(false) then -h is an unknown option', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .helpOption(false);\n    let caughtErr;\n    try {\n      program.parse(['-h'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when helpOption(false) then unknown command error does not suggest --help",
            "suites": [
                "helpOption"
            ],
            "updatePoint": {
                "line": 123,
                "column": 81
            },
            "line": 123,
            "code": "  test('when helpOption(false) then unknown command error does not suggest --help', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .helpOption(false)\n      .command('foo');\n    expect(() => {\n      program.parse(['UNKNOWN'], { from: 'user' });\n    }).toThrow(\"error: unknown command 'UNKNOWN'\");\n  });",
            "file": "command.helpOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook event wrong then throw",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 38
            },
            "line": 3,
            "code": "test('when hook event wrong then throw', () => {\n  const program = new commander.Command();\n  expect(() => {\n    program.hook('silly', () => {});\n  }).toThrow();\n});",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no action then action hooks not called",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 49
            },
            "line": 10,
            "code": "test('when no action then action hooks not called', () => {\n  const hook = jest.fn();\n  const program = new commander.Command();\n  program\n    .hook('preAction', hook)\n    .hook('postAction', hook);\n  program.parse([], { from: 'user' });\n  expect(hook).not.toHaveBeenCalled();\n});",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook preAction then hook called before action",
            "suites": [
                "action hooks with synchronous hooks, order"
            ],
            "updatePoint": {
                "line": 21,
                "column": 58
            },
            "line": 21,
            "code": "  test('when hook preAction then hook called before action', () => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', () => calls.push('before'))\n      .action(() => calls.push('action'));\n    program.parse([], { from: 'user' });\n    expect(calls).toEqual(['before', 'action']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook postAction then hook called after action",
            "suites": [
                "action hooks with synchronous hooks, order"
            ],
            "updatePoint": {
                "line": 31,
                "column": 58
            },
            "line": 31,
            "code": "  test('when hook postAction then hook called after action', () => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('postAction', () => calls.push('after'))\n      .action(() => calls.push('action'));\n    program.parse([], { from: 'user' });\n    expect(calls).toEqual(['action', 'after']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook preAction twice then hooks called FIFO",
            "suites": [
                "action hooks with synchronous hooks, order"
            ],
            "updatePoint": {
                "line": 41,
                "column": 56
            },
            "line": 41,
            "code": "  test('when hook preAction twice then hooks called FIFO', () => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', () => calls.push('1'))\n      .hook('preAction', () => calls.push('2'))\n      .action(() => calls.push('action'));\n    program.parse([], { from: 'user' });\n    expect(calls).toEqual(['1', '2', 'action']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook postAction twice then hooks called LIFO",
            "suites": [
                "action hooks with synchronous hooks, order"
            ],
            "updatePoint": {
                "line": 52,
                "column": 57
            },
            "line": 52,
            "code": "  test('when hook postAction twice then hooks called LIFO', () => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('postAction', () => calls.push('1'))\n      .hook('postAction', () => calls.push('2'))\n      .action(() => calls.push('action'));\n    program.parse([], { from: 'user' });\n    expect(calls).toEqual(['action', '2', '1']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook preAction at program and sub then hooks called program then sub",
            "suites": [
                "action hooks with synchronous hooks, order"
            ],
            "updatePoint": {
                "line": 63,
                "column": 81
            },
            "line": 63,
            "code": "  test('when hook preAction at program and sub then hooks called program then sub', () => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', () => calls.push('program'));\n    program.command('sub')\n      .hook('preAction', () => calls.push('sub'))\n      .action(() => calls.push('action'));\n    program.parse(['sub'], { from: 'user' });\n    expect(calls).toEqual(['program', 'sub', 'action']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook postAction at program and sub then hooks called sub then program",
            "suites": [
                "action hooks with synchronous hooks, order"
            ],
            "updatePoint": {
                "line": 75,
                "column": 82
            },
            "line": 75,
            "code": "  test('when hook postAction at program and sub then hooks called sub then program', () => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('postAction', () => calls.push('program'));\n    program.command('sub')\n      .hook('postAction', () => calls.push('sub'))\n      .action(() => calls.push('action'));\n    program.parse(['sub'], { from: 'user' });\n    expect(calls).toEqual(['action', 'sub', 'program']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook everything then hooks called nested",
            "suites": [
                "action hooks with synchronous hooks, order"
            ],
            "updatePoint": {
                "line": 87,
                "column": 53
            },
            "line": 87,
            "code": "  test('when hook everything then hooks called nested', () => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', () => calls.push('pb1'))\n      .hook('postAction', () => calls.push('pa1'));\n    program\n      .hook('preAction', () => calls.push('pb2'))\n      .hook('postAction', () => calls.push('pa2'));\n    program.command('sub')\n      .hook('preAction', () => calls.push('sb'))\n      .hook('postAction', () => calls.push('sa'))\n      .action(() => calls.push('action'));\n    program.parse(['sub'], { from: 'user' });\n    expect(calls).toEqual(['pb1', 'pb2', 'sb', 'action', 'sa', 'pa2', 'pa1']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook on program then passed program/program",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 106,
                "column": 56
            },
            "line": 106,
            "code": "  test('when hook on program then passed program/program', () => {\n    const hook = jest.fn();\n    const program = new commander.Command();\n    program\n      .hook('preAction', hook)\n      .action(() => {});\n    program.parse([], { from: 'user' });\n    expect(hook).toHaveBeenCalledWith(program, program);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook on program and call sub then passed program/sub",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 116,
                "column": 65
            },
            "line": 116,
            "code": "  test('when hook on program and call sub then passed program/sub', () => {\n    const hook = jest.fn();\n    const program = new commander.Command();\n    program\n      .hook('preAction', hook);\n    const sub = program.command('sub')\n      .action(() => {});\n    program.parse(['sub'], { from: 'user' });\n    expect(hook).toHaveBeenCalledWith(program, sub);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook on sub and call sub then passed sub/sub",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 127,
                "column": 57
            },
            "line": 127,
            "code": "  test('when hook on sub and call sub then passed sub/sub', () => {\n    const hook = jest.fn();\n    const program = new commander.Command();\n    const sub = program.command('sub')\n      .hook('preAction', hook)\n      .action(() => {});\n    program.parse(['sub'], { from: 'user' });\n    expect(hook).toHaveBeenCalledWith(sub, sub);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook program on preAction then thisCommand has options set",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 137,
                "column": 71
            },
            "line": 137,
            "code": "  test('when hook program on preAction then thisCommand has options set', () => {\n    expect.assertions(1);\n    const program = new commander.Command();\n    program\n      .option('--debug')\n      .hook('preAction', (thisCommand) => {\n        expect(thisCommand.opts().debug).toEqual(true);\n      })\n      .action(() => {});\n    program.parse(['--debug'], { from: 'user' });\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook program on preAction and call sub then thisCommand has program options set",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 149,
                "column": 92
            },
            "line": 149,
            "code": "  test('when hook program on preAction and call sub then thisCommand has program options set', () => {\n    expect.assertions(1);\n    const program = new commander.Command();\n    program\n      .option('--debug')\n      .hook('preAction', (thisCommand) => {\n        expect(thisCommand.opts().debug).toEqual(true);\n      });\n    program.command('sub')\n      .action(() => {});\n    program.parse(['sub', '--debug'], { from: 'user' });\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook program on preAction and call sub then actionCommand has sub options set",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 162,
                "column": 90
            },
            "line": 162,
            "code": "  test('when hook program on preAction and call sub then actionCommand has sub options set', () => {\n    expect.assertions(1);\n    const program = new commander.Command();\n    program\n      .hook('preAction', (thisCommand, actionCommand) => {\n        expect(actionCommand.opts().debug).toEqual(true);\n      });\n    program.command('sub')\n      .option('--debug')\n      .action(() => {});\n    program.parse(['sub', '--debug'], { from: 'user' });\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook program on preAction then actionCommand has args set",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 175,
                "column": 70
            },
            "line": 175,
            "code": "  test('when hook program on preAction then actionCommand has args set', () => {\n    expect.assertions(1);\n    const program = new commander.Command();\n    program\n      .argument('[arg]')\n      .hook('preAction', (thisCommand, actionCommand) => {\n        expect(actionCommand.args).toEqual(['value']);\n      })\n      .action(() => {});\n    program.parse(['value'], { from: 'user' });\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook program on preAction then actionCommand has args set with options removed",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 187,
                "column": 91
            },
            "line": 187,
            "code": "  test('when hook program on preAction then actionCommand has args set with options removed', () => {\n    expect.assertions(1);\n    const program = new commander.Command();\n    program\n      .argument('[arg]')\n      .option('--debug')\n      .hook('preAction', (thisCommand, actionCommand) => {\n        expect(actionCommand.args).toEqual(['value']);\n      })\n      .action(() => {});\n    program.parse(['value', '--debug'], { from: 'user' });\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook program on preAction and call sub then thisCommand has program args set",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 200,
                "column": 89
            },
            "line": 200,
            "code": "  test('when hook program on preAction and call sub then thisCommand has program args set', () => {\n    expect.assertions(1);\n    const program = new commander.Command();\n    program\n      .argument('[arg]')\n      .hook('preAction', (thisCommand) => {\n        expect(thisCommand.args).toEqual(['sub', 'value']);\n      });\n    program.command('sub')\n      .action(() => {});\n    program.parse(['sub', 'value'], { from: 'user' });\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when hook program on preAction and call sub then actionCommand has sub args set",
            "suites": [
                "action hooks context"
            ],
            "updatePoint": {
                "line": 213,
                "column": 87
            },
            "line": 213,
            "code": "  test('when hook program on preAction and call sub then actionCommand has sub args set', () => {\n    expect.assertions(1);\n    const program = new commander.Command();\n    program\n      .hook('preAction', (thisCommand, actionCommand) => {\n        expect(actionCommand.args).toEqual(['value']);\n      });\n    program.command('sub')\n      .action(() => {});\n    program.parse(['sub', 'value'], { from: 'user' });\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when async preAction then async from preAction",
            "suites": [
                "action hooks async"
            ],
            "updatePoint": {
                "line": 227,
                "column": 54
            },
            "line": 227,
            "code": "  test('when async preAction then async from preAction', async() => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', async() => {\n        await 0;\n        calls.push('before');\n      })\n      .action(() => calls.push('action'));\n    const result = program.parseAsync([], { from: 'user' });\n    expect(calls).toEqual([]);\n    await result;\n    expect(calls).toEqual(['before', 'action']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when async postAction then async from postAction",
            "suites": [
                "action hooks async"
            ],
            "updatePoint": {
                "line": 242,
                "column": 56
            },
            "line": 242,
            "code": "  test('when async postAction then async from postAction', async() => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('postAction', async() => {\n        await 0;\n        calls.push('after');\n      })\n      .action(() => calls.push('action'));\n    const result = program.parseAsync([], { from: 'user' });\n    expect(calls).toEqual(['action']);\n    await result;\n    expect(calls).toEqual(['action', 'after']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when async action then async from action",
            "suites": [
                "action hooks async"
            ],
            "updatePoint": {
                "line": 257,
                "column": 48
            },
            "line": 257,
            "code": "  test('when async action then async from action', async() => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', () => calls.push('before'))\n      .hook('postAction', () => calls.push('after'))\n      .action(async() => {\n        await 0;\n        calls.push('action');\n      });\n    const result = program.parseAsync([], { from: 'user' });\n    expect(calls).toEqual(['before']);\n    await result;\n    expect(calls).toEqual(['before', 'action', 'after']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when async first preAction then async from first preAction",
            "suites": [
                "action hooks async"
            ],
            "updatePoint": {
                "line": 273,
                "column": 66
            },
            "line": 273,
            "code": "  test('when async first preAction then async from first preAction', async() => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', async() => {\n        await 0;\n        calls.push('1');\n      })\n      .hook('preAction', () => calls.push('2'))\n      .action(() => calls.push('action'));\n    const result = program.parseAsync([], { from: 'user' });\n    expect(calls).toEqual([]);\n    await result;\n    expect(calls).toEqual(['1', '2', 'action']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when async second preAction then async from second preAction",
            "suites": [
                "action hooks async"
            ],
            "updatePoint": {
                "line": 289,
                "column": 68
            },
            "line": 289,
            "code": "  test('when async second preAction then async from second preAction', async() => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', () => calls.push('1'))\n      .hook('preAction', async() => {\n        await 0;\n        calls.push('2');\n      })\n      .action(() => calls.push('action'));\n    const result = program.parseAsync([], { from: 'user' });\n    expect(calls).toEqual(['1']);\n    await result;\n    expect(calls).toEqual(['1', '2', 'action']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when async hook everything then hooks called nested",
            "suites": [
                "action hooks async"
            ],
            "updatePoint": {
                "line": 305,
                "column": 59
            },
            "line": 305,
            "code": "  test('when async hook everything then hooks called nested', async() => {\n    const calls = [];\n    const program = new commander.Command();\n    program\n      .hook('preAction', async() => { await 0; calls.push('pb1'); })\n      .hook('postAction', async() => { await 0; calls.push('pa1'); });\n    program\n      .hook('preAction', async() => { await 0; calls.push('pb2'); })\n      .hook('postAction', async() => { await 0; calls.push('pa2'); });\n    program.command('sub')\n      .hook('preAction', async() => { await 0; calls.push('sb'); })\n      .hook('postAction', async() => { await 0; calls.push('sa'); })\n      .action(async() => { await 0; calls.push('action'); });\n    const result = program.parseAsync(['sub'], { from: 'user' });\n    expect(calls).toEqual([]);\n    await result;\n    expect(calls).toEqual(['pb1', 'pb2', 'sb', 'action', 'sa', 'pa2', 'pa1']);\n  });",
            "file": "command.hook.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set program name and parse then name is as assigned",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 62
            },
            "line": 3,
            "code": "test('when set program name and parse then name is as assigned', () => {\n  const program = new commander.Command();\n  program.name('custom');\n  program.parse(['node', 'test']);\n  expect(program.name()).toBe('custom');\n});",
            "file": "command.name.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program name not set and parse then name is found from arguments",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 75
            },
            "line": 10,
            "code": "test('when program name not set and parse then name is found from arguments', () => {\n  const program = new commander.Command();\n  program.parse(['node', 'test']);\n  expect(program.name()).toBe('test');\n});",
            "file": "command.name.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add command then command is named",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 44
            },
            "line": 16,
            "code": "test('when add command then command is named', () => {\n  const program = new commander.Command();\n  const subcommand = program\n    .command('mycommand <file>');\n  expect(subcommand.name()).toBe('mycommand');\n});",
            "file": "command.name.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when set program name then name appears in help",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 53
            },
            "line": 23,
            "code": "test('when set program name then name appears in help', () => {\n  const program = new commander.Command();\n  program.name('custom-name');\n  const helpInformation = program.helpInformation();\n  expect(helpInformation).toMatch(/^Usage: custom-name/);\n});",
            "file": "command.name.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call nested subcommand then runs",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 43
            },
            "line": 3,
            "code": "test('when call nested subcommand then runs', () => {\n  const program = new commander.Command();\n  const leafAction = jest.fn();\n  program\n    .command('sub1')\n    .command('sub2')\n    .action(leafAction);\n  program.parse('node test.js sub1 sub2'.split(' '));\n  expect(leafAction).toHaveBeenCalled();\n});",
            "file": "command.nested.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when action handler for subcommand then emit command:subcommand",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 7,
                "column": 71
            },
            "line": 7,
            "code": "  test('when action handler for subcommand then emit command:subcommand', () => {\n    const mockListener = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('sub')\n      .action(() => {});\n    program.on('command:sub', mockListener);\n    program.parse(['sub'], { from: 'user' });\n    expect(mockListener).toHaveBeenCalled();\n  });",
            "file": "command.onCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no action handler for subcommand then still emit command:subcommand",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 18,
                "column": 80
            },
            "line": 18,
            "code": "  test('when no action handler for subcommand then still emit command:subcommand', () => {\n    const mockListener = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('sub');\n    program.on('command:sub', mockListener);\n    program.parse(['sub'], { from: 'user' });\n    expect(mockListener).toHaveBeenCalled();\n  });",
            "file": "command.onCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand has argument then emit command:subcommand with argument",
            "suites": [
                ".command('*')"
            ],
            "updatePoint": {
                "line": 28,
                "column": 79
            },
            "line": 28,
            "code": "  test('when subcommand has argument then emit command:subcommand with argument', () => {\n    const mockListener = jest.fn();\n    const program = new commander.Command();\n    program\n      .command('sub <file>')\n      .action(() => {});\n    program.on('command:sub', mockListener);\n    program.parse(['sub', 'file'], { from: 'user' });\n    expect(mockListener).toHaveBeenCalledWith(['file'], []);\n  });",
            "file": "command.onCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no args then use process.argv and app/script/args",
            "suites": [
                ".parse() args from"
            ],
            "updatePoint": {
                "line": 8,
                "column": 62
            },
            "line": 8,
            "code": "  test('when no args then use process.argv and app/script/args', () => {\n    const program = new commander.Command();\n    const hold = process.argv;\n    process.argv = 'node script.js user'.split(' ');\n    program.parse();\n    process.argv = hold;\n    expect(program.args).toEqual(['user']);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no args and electron properties and not default app then use process.argv and app/args",
            "suites": [
                ".parse() args from"
            ],
            "updatePoint": {
                "line": 17,
                "column": 99
            },
            "line": 17,
            "code": "  test('when no args and electron properties and not default app then use process.argv and app/args', () => {\n    const program = new commander.Command();\n    const holdArgv = process.argv;\n    process.versions.electron = '1.2.3';\n    process.argv = 'node user'.split(' ');\n    program.parse();\n    delete process.versions.electron;\n    process.argv = holdArgv;\n    expect(program.args).toEqual(['user']);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when args then app/script/args",
            "suites": [
                ".parse() args from"
            ],
            "updatePoint": {
                "line": 28,
                "column": 38
            },
            "line": 28,
            "code": "  test('when args then app/script/args', () => {\n    const program = new commander.Command();\n    program.parse('node script.js user'.split(' '));\n    expect(program.args).toEqual(['user']);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when args from \"node\" then app/script/args",
            "suites": [
                ".parse() args from"
            ],
            "updatePoint": {
                "line": 34,
                "column": 50
            },
            "line": 34,
            "code": "  test('when args from \"node\" then app/script/args', () => {\n    const program = new commander.Command();\n    program.parse('node script.js user'.split(' '), { from: 'node' });\n    expect(program.args).toEqual(['user']);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when args from \"electron\" and not default app then app/args",
            "suites": [
                ".parse() args from"
            ],
            "updatePoint": {
                "line": 40,
                "column": 67
            },
            "line": 40,
            "code": "  test('when args from \"electron\" and not default app then app/args', () => {\n    const program = new commander.Command();\n    const hold = process.defaultApp;\n    process.defaultApp = undefined;\n    program.parse('customApp user'.split(' '), { from: 'electron' });\n    process.defaultApp = hold;\n    expect(program.args).toEqual(['user']);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when args from \"electron\" and default app then app/script/args",
            "suites": [
                ".parse() args from"
            ],
            "updatePoint": {
                "line": 49,
                "column": 70
            },
            "line": 49,
            "code": "  test('when args from \"electron\" and default app then app/script/args', () => {\n    const program = new commander.Command();\n    const hold = process.defaultApp;\n    process.defaultApp = true;\n    program.parse('electron script user'.split(' '), { from: 'electron' });\n    process.defaultApp = hold;\n    expect(program.args).toEqual(['user']);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when args from \"user\" then args",
            "suites": [
                ".parse() args from"
            ],
            "updatePoint": {
                "line": 58,
                "column": 39
            },
            "line": 58,
            "code": "  test('when args from \"user\" then args', () => {\n    const program = new commander.Command();\n    program.parse('user'.split(' '), { from: 'user' });\n    expect(program.args).toEqual(['user']);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when args from \"silly\" then throw",
            "suites": [
                ".parse() args from"
            ],
            "updatePoint": {
                "line": 64,
                "column": 41
            },
            "line": 64,
            "code": "  test('when args from \"silly\" then throw', () => {\n    const program = new commander.Command();\n    expect(() => {\n      program.parse(['node', 'script.js'], { from: 'silly' });\n    }).toThrow();\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .parse then returns program",
            "suites": [
                "return type"
            ],
            "updatePoint": {
                "line": 73,
                "column": 45
            },
            "line": 73,
            "code": "  test('when call .parse then returns program', () => {\n    const program = new commander.Command();\n    program\n      .action(() => { });\n\n    const result = program.parse(['node', 'test']);\n    expect(result).toBe(program);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when await .parseAsync then returns program",
            "suites": [
                "return type"
            ],
            "updatePoint": {
                "line": 82,
                "column": 51
            },
            "line": 82,
            "code": "  test('when await .parseAsync then returns program', async() => {\n    const program = new commander.Command();\n    program\n      .action(() => { });\n\n    const result = await program.parseAsync(['node', 'test']);\n    expect(result).toBe(program);\n  });",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when parse strings instead of array then throw",
            "suites": [
                "return type"
            ],
            "updatePoint": {
                "line": 93,
                "column": 52
            },
            "line": 93,
            "code": "test('when parse strings instead of array then throw', () => {\n  const program = new commander.Command();\n  expect(() => {\n    program.parse('node', 'test');\n  }).toThrow();\n});",
            "file": "command.parse.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify subcommand and argument then program.args not empty",
            "suites": [
                "regression tests"
            ],
            "updatePoint": {
                "line": 25,
                "column": 72
            },
            "line": 25,
            "code": "  test('when specify subcommand and argument then program.args not empty', () => {\n    const program = createProgram1032();\n    program.parse(['node', 'test.js', 'doit', 'myid']);\n    expect(program.args.length).toBeGreaterThan(0);\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify subcommand and option and argument then program.args not empty",
            "suites": [
                "regression tests"
            ],
            "updatePoint": {
                "line": 32,
                "column": 83
            },
            "line": 32,
            "code": "  test('when specify subcommand and option and argument then program.args not empty', () => {\n    const program = createProgram1032();\n    program.parse(['node', 'test.js', 'doit', '--better', 'myid']);\n    expect(program.args.length).toBeGreaterThan(0);\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when arguments to executable include option flags then argument order preserved",
            "suites": [
                "regression tests"
            ],
            "updatePoint": {
                "line": 39,
                "column": 87
            },
            "line": 39,
            "code": "  test('when arguments to executable include option flags then argument order preserved', async() => {\n    const pm = path.join(__dirname, 'fixtures/pm');\n    const { stdout } = await execFileAsync('node', [pm, 'echo', '1', '2', '--dry-run', '3', '4', '5', '6']);\n    expect(stdout).toBe(\"[ '1', '2', '--dry-run', '3', '4', '5', '6' ]\\n\");\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when empty args then empty results",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 61,
                "column": 42
            },
            "line": 61,
            "code": "  test('when empty args then empty results', () => {\n    const program = createProgram();\n    const result = program.parseOptions([]);\n    expect(result).toEqual({ operands: [], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when only operands then results has all operands",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 67,
                "column": 56
            },
            "line": 67,
            "code": "  test('when only operands then results has all operands', () => {\n    const program = createProgram();\n    const result = program.parseOptions('one two three'.split(' '));\n    expect(result).toEqual({ operands: ['one', 'two', 'three'], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand and operand then results has subcommand and operand",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 73,
                "column": 75
            },
            "line": 73,
            "code": "  test('when subcommand and operand then results has subcommand and operand', () => {\n    const program = createProgram();\n    const result = program.parseOptions('sub one'.split(' '));\n    expect(result).toEqual({ operands: ['sub', 'one'], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has flag then option removed",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 79,
                "column": 49
            },
            "line": 79,
            "code": "  test('when program has flag then option removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions('--global-flag'.split(' '));\n    expect(result).toEqual({ operands: [], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has option with value then option removed",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 85,
                "column": 62
            },
            "line": 85,
            "code": "  test('when program has option with value then option removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions('--global-value foo'.split(' '));\n    expect(result).toEqual({ operands: [], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has flag before operand then option removed",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 91,
                "column": 64
            },
            "line": 91,
            "code": "  test('when program has flag before operand then option removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions('--global-flag arg'.split(' '));\n    expect(result).toEqual({ operands: ['arg'], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has flag after operand then option removed",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 97,
                "column": 63
            },
            "line": 97,
            "code": "  test('when program has flag after operand then option removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions('arg --global-flag'.split(' '));\n    expect(result).toEqual({ operands: ['arg'], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has flag after subcommand then option removed",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 103,
                "column": 66
            },
            "line": 103,
            "code": "  test('when program has flag after subcommand then option removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions('sub --global-flag'.split(' '));\n    expect(result).toEqual({ operands: ['sub'], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has unknown option then option returned in unknown",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 109,
                "column": 71
            },
            "line": 109,
            "code": "  test('when program has unknown option then option returned in unknown', () => {\n    const program = createProgram();\n    const result = program.parseOptions('--unknown'.split(' '));\n    expect(result).toEqual({ operands: [], unknown: ['--unknown'] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has unknown option before operands then all unknown in same order",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 115,
                "column": 86
            },
            "line": 115,
            "code": "  test('when program has unknown option before operands then all unknown in same order', () => {\n    const program = createProgram();\n    const result = program.parseOptions('--unknown arg'.split(' '));\n    expect(result).toEqual({ operands: [], unknown: ['--unknown', 'arg'] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has unknown option after operand then option returned in unknown",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 121,
                "column": 85
            },
            "line": 121,
            "code": "  test('when program has unknown option after operand then option returned in unknown', () => {\n    const program = createProgram();\n    const result = program.parseOptions('arg --unknown'.split(' '));\n    expect(result).toEqual({ operands: ['arg'], unknown: ['--unknown'] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has flag after unknown option then flag removed",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 127,
                "column": 68
            },
            "line": 127,
            "code": "  test('when program has flag after unknown option then flag removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions('--unknown --global-flag'.split(' '));\n    expect(result).toEqual({ operands: [], unknown: ['--unknown'] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand has flag then flag returned as unknown",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 133,
                "column": 62
            },
            "line": 133,
            "code": "  test('when subcommand has flag then flag returned as unknown', () => {\n    const program = createProgram();\n    const result = program.parseOptions('sub --sub-flag'.split(' '));\n    expect(result).toEqual({ operands: ['sub'], unknown: ['--sub-flag'] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has literal before known flag then option returned as operand",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 139,
                "column": 82
            },
            "line": 139,
            "code": "  test('when program has literal before known flag then option returned as operand', () => {\n    const program = createProgram();\n    const result = program.parseOptions('-- --global-flag'.split(' '));\n    expect(result).toEqual({ operands: ['--global-flag'], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has literal before unknown option then option returned as operand",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 145,
                "column": 86
            },
            "line": 145,
            "code": "  test('when program has literal before unknown option then option returned as operand', () => {\n    const program = createProgram();\n    const result = program.parseOptions('-- --unknown uuu'.split(' '));\n    expect(result).toEqual({ operands: ['--unknown', 'uuu'], unknown: [] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has literal after unknown option then literal preserved too",
            "suites": [
                "parseOptions"
            ],
            "updatePoint": {
                "line": 151,
                "column": 80
            },
            "line": 151,
            "code": "  test('when program has literal after unknown option then literal preserved too', () => {\n    const program = createProgram();\n    const result = program.parseOptions('--unknown1 -- --unknown2'.split(' '));\n    expect(result).toEqual({ operands: [], unknown: ['--unknown1', '--', '--unknown2'] });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has known flag and operand then option removed and operand returned",
            "suites": [
                "parse and program.args"
            ],
            "updatePoint": {
                "line": 160,
                "column": 88
            },
            "line": 160,
            "code": "  test('when program has known flag and operand then option removed and operand returned', () => {\n    const program = new commander.Command();\n    program\n      .option('--global-flag');\n    program.parse('node test.js --global-flag arg'.split(' '));\n    expect(program.args).toEqual(['arg']);\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has mixed arguments then known options removed and rest returned in same order",
            "suites": [
                "parse and program.args"
            ],
            "updatePoint": {
                "line": 168,
                "column": 99
            },
            "line": 168,
            "code": "  test('when program has mixed arguments then known options removed and rest returned in same order', () => {\n    const program = new commander.Command();\n    program\n      .allowUnknownOption()\n      .option('--global-flag')\n      .option('--global-value <value>');\n    program.parse('node test.js aaa --global-flag bbb --unknown ccc --global-value value'.split(' '));\n    expect(program.args).toEqual(['aaa', 'bbb', '--unknown', 'ccc']);\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand has mixed arguments then program flags removed and rest returned in same order",
            "suites": [
                "parse and program.args"
            ],
            "updatePoint": {
                "line": 178,
                "column": 102
            },
            "line": 178,
            "code": "  test('when subcommand has mixed arguments then program flags removed and rest returned in same order', () => {\n    const program = new commander.Command();\n    program\n      .option('--global-flag')\n      .option('--global-value <value>')\n      .command('sub [args...]')\n      .option('--sub-flag');\n    program.parse('node test.js --global-flag sub --sub-flag arg --global-value value'.split(' '));\n    expect(program.args).toEqual(['sub', '--sub-flag', 'arg']);\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has combo known boolean short flags then arg removed",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 236,
                "column": 73
            },
            "line": 236,
            "code": "  test('when program has combo known boolean short flags then arg removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions(['-ab']);\n    expect(result).toEqual({ operands: [], unknown: [] });\n    expect(program.opts()).toEqual({ aaa: true, bbb: true });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has combo unknown short flags then arg preserved",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 243,
                "column": 69
            },
            "line": 243,
            "code": "  test('when program has combo unknown short flags then arg preserved', () => {\n    const program = createProgram();\n    const result = program.parseOptions(['-pq']);\n    expect(result).toEqual({ operands: [], unknown: ['-pq'] });\n    expect(program.opts()).toEqual({ });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has combo known short option and required value then arg removed",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 250,
                "column": 85
            },
            "line": 250,
            "code": "  test('when program has combo known short option and required value then arg removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions(['-cvalue']);\n    expect(result).toEqual({ operands: [], unknown: [] });\n    expect(program.opts()).toEqual({ ccc: 'value' });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has combo known short option and optional value then arg removed",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 257,
                "column": 85
            },
            "line": 257,
            "code": "  test('when program has combo known short option and optional value then arg removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions(['-dvalue']);\n    expect(result).toEqual({ operands: [], unknown: [] });\n    expect(program.opts()).toEqual({ ddd: 'value' });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has known combo short boolean flags and required value then arg removed",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 264,
                "column": 92
            },
            "line": 264,
            "code": "  test('when program has known combo short boolean flags and required value then arg removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions(['-abcvalue']);\n    expect(result).toEqual({ operands: [], unknown: [] });\n    expect(program.opts()).toEqual({ aaa: true, bbb: true, ccc: 'value' });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has known combo short boolean flags and optional value then arg removed",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 271,
                "column": 92
            },
            "line": 271,
            "code": "  test('when program has known combo short boolean flags and optional value then arg removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions(['-abdvalue']);\n    expect(result).toEqual({ operands: [], unknown: [] });\n    expect(program.opts()).toEqual({ aaa: true, bbb: true, ddd: 'value' });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has known long flag=value then arg removed",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 278,
                "column": 63
            },
            "line": 278,
            "code": "  test('when program has known long flag=value then arg removed', () => {\n    const program = createProgram();\n    const result = program.parseOptions(['--ccc=value']);\n    expect(result).toEqual({ operands: [], unknown: [] });\n    expect(program.opts()).toEqual({ ccc: 'value' });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has unknown long flag=value then arg preserved",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 285,
                "column": 67
            },
            "line": 285,
            "code": "  test('when program has unknown long flag=value then arg preserved', () => {\n    const program = createProgram();\n    const result = program.parseOptions(['--rrr=value']);\n    expect(result).toEqual({ operands: [], unknown: ['--rrr=value'] });\n    expect(program.opts()).toEqual({ });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has combo optional and combineFlagAndOptionalValue() then treat as value",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 292,
                "column": 93
            },
            "line": 292,
            "code": "  test('when program has combo optional and combineFlagAndOptionalValue() then treat as value', () => {\n    const program = createProgram();\n    program.combineFlagAndOptionalValue();\n    program.parseOptions(['-db']);\n    expect(program.opts()).toEqual({ ddd: 'b' });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has combo optional and combineFlagAndOptionalValue(true) then treat as value",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 299,
                "column": 97
            },
            "line": 299,
            "code": "  test('when program has combo optional and combineFlagAndOptionalValue(true) then treat as value', () => {\n    const program = createProgram();\n    program.combineFlagAndOptionalValue(true);\n    program.parseOptions(['-db']);\n    expect(program.opts()).toEqual({ ddd: 'b' });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has combo optional and combineFlagAndOptionalValue(false) then treat as boolean",
            "suites": [
                "Utility Conventions"
            ],
            "updatePoint": {
                "line": 306,
                "column": 100
            },
            "line": 306,
            "code": "  test('when program has combo optional and combineFlagAndOptionalValue(false) then treat as boolean', () => {\n    const program = createProgram();\n    program.combineFlagAndOptionalValue(false);\n    program.parseOptions(['-db']);\n    expect(program.opts()).toEqual({ ddd: true, bbb: true });\n  });",
            "file": "command.parseOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option before command-argument then option parsed",
            "suites": [
                "program with passThrough"
            ],
            "updatePoint": {
                "line": 16,
                "column": 62
            },
            "line": 16,
            "code": "  test('when option before command-argument then option parsed', () => {\n    const program = makeProgram();\n    program.parse(['--debug', 'arg'], { from: 'user' });\n    expect(program.args).toEqual(['arg']);\n    expect(program.opts().debug).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when known option after command-argument then option passed through",
            "suites": [
                "program with passThrough"
            ],
            "updatePoint": {
                "line": 23,
                "column": 75
            },
            "line": 23,
            "code": "  test('when known option after command-argument then option passed through', () => {\n    const program = makeProgram();\n    program.parse(['arg', '--debug'], { from: 'user' });\n    expect(program.args).toEqual(['arg', '--debug']);\n    expect(program.opts().debug).toBeUndefined();\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown option after command-argument then option passed through",
            "suites": [
                "program with passThrough"
            ],
            "updatePoint": {
                "line": 30,
                "column": 77
            },
            "line": 30,
            "code": "  test('when unknown option after command-argument then option passed through', () => {\n    const program = makeProgram();\n    program.parse(['arg', '--pass'], { from: 'user' });\n    expect(program.args).toEqual(['arg', '--pass']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when action handler and unknown option after command-argument then option passed through",
            "suites": [
                "program with passThrough"
            ],
            "updatePoint": {
                "line": 36,
                "column": 96
            },
            "line": 36,
            "code": "  test('when action handler and unknown option after command-argument then option passed through', () => {\n    const program = makeProgram();\n    const mockAction = jest.fn();\n    program.action(mockAction);\n    program.parse(['arg', '--pass'], { from: 'user' });\n    expect(mockAction).toHaveBeenCalledWith(['arg', '--pass'], program.opts(), program);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help option (without command-argument) then help called",
            "suites": [
                "program with passThrough"
            ],
            "updatePoint": {
                "line": 44,
                "column": 68
            },
            "line": 44,
            "code": "  test('when help option (without command-argument) then help called', () => {\n    const program = makeProgram();\n    const mockHelp = jest.fn(() => '');\n\n    program\n      .exitOverride()\n      .configureHelp({ formatHelp: mockHelp });\n    try {\n      program.parse(['--help'], { from: 'user' });\n    } catch (err) {\n    }\n    expect(mockHelp).toHaveBeenCalled();\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help option after command-argument then option passed through",
            "suites": [
                "program with passThrough"
            ],
            "updatePoint": {
                "line": 58,
                "column": 74
            },
            "line": 58,
            "code": "  test('when help option after command-argument then option passed through', () => {\n    const program = makeProgram();\n    program.parse(['arg', '--help'], { from: 'user' });\n    expect(program.args).toEqual(['arg', '--help']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when version option after command-argument then option passed through",
            "suites": [
                "program with passThrough"
            ],
            "updatePoint": {
                "line": 64,
                "column": 77
            },
            "line": 64,
            "code": "  test('when version option after command-argument then option passed through', () => {\n    const program = makeProgram();\n    program.version('1.2.3');\n    program.parse(['arg', '--version'], { from: 'user' });\n    expect(program.args).toEqual(['arg', '--version']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global option before subcommand then global option parsed",
            "suites": [
                "program with positionalOptions and subcommand"
            ],
            "updatePoint": {
                "line": 89,
                "column": 70
            },
            "line": 89,
            "code": "  test('when global option before subcommand then global option parsed', () => {\n    const { program } = makeProgram();\n    program.parse(['--shared', 'program', 'sub'], { from: 'user' });\n    expect(program.opts().shared).toEqual('program');\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when shared option after subcommand then parsed by subcommand",
            "suites": [
                "program with positionalOptions and subcommand"
            ],
            "updatePoint": {
                "line": 95,
                "column": 69
            },
            "line": 95,
            "code": "  test('when shared option after subcommand then parsed by subcommand', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['sub', '--shared', 'local'], { from: 'user' });\n    expect(sub.opts().shared).toEqual('local');\n    expect(program.opts().shared).toBeUndefined();\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when shared option after subcommand argument then parsed by subcommand",
            "suites": [
                "program with positionalOptions and subcommand"
            ],
            "updatePoint": {
                "line": 102,
                "column": 78
            },
            "line": 102,
            "code": "  test('when shared option after subcommand argument then parsed by subcommand', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['sub', 'arg', '--shared', 'local'], { from: 'user' });\n    expect(sub.opts().shared).toEqual('local');\n    expect(sub.args).toEqual(['arg']);\n    expect(program.opts().shared).toBeUndefined();\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when shared option before and after subcommand then both parsed",
            "suites": [
                "program with positionalOptions and subcommand"
            ],
            "updatePoint": {
                "line": 110,
                "column": 71
            },
            "line": 110,
            "code": "  test('when shared option before and after subcommand then both parsed', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['--shared', 'program', 'sub', '--shared', 'local'], { from: 'user' });\n    expect(program.opts().shared).toEqual('program');\n    expect(sub.opts().shared).toEqual('local');\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "help: when user args %p then program/sub help called %p/%p",
            "suites": [
                "program with positionalOptions and subcommand"
            ],
            "line": 117,
            "code": "  test.each([\n    [[], 1, 0],\n    [['sub'], 0, 0],\n    [['--help'], 1, 0],\n    [['sub', '--help'], 0, 1],\n    [['sub', 'foo', '--help'], 0, 1],\n    [['help'], 1, 0],\n    [['help', 'sub'], 0, 1]\n  ])('help: when user args %p then program/sub help called %p/%p', (userArgs, expectProgramHelpCount, expectSubHelpCount) => {\n    const { program, sub } = makeProgram();\n    const mockProgramHelp = jest.fn();\n    program\n      .exitOverride()\n      .configureHelp({ formatHelp: mockProgramHelp });\n    const mockSubHelp = jest.fn();\n    sub\n      .exitOverride()\n      .configureHelp({ formatHelp: mockSubHelp });\n\n    try {\n      program.parse(userArgs, { from: 'user' });\n    } catch (err) {\n    }\n    expect(mockProgramHelp).toHaveBeenCalledTimes(expectProgramHelpCount);\n    expect(mockSubHelp).toHaveBeenCalledTimes(expectSubHelpCount);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program option before sub option then program option read by program",
            "suites": [
                "program with positionalOptions and default subcommand (called sub)"
            ],
            "updatePoint": {
                "line": 165,
                "column": 81
            },
            "line": 165,
            "code": "  test('when program option before sub option then program option read by program', () => {\n    const { program } = makeProgram();\n    program.parse(['--global', '--default'], { from: 'user' });\n    expect(program.opts().global).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program option before sub option then sub option read by sub",
            "suites": [
                "program with positionalOptions and default subcommand (called sub)"
            ],
            "updatePoint": {
                "line": 171,
                "column": 73
            },
            "line": 171,
            "code": "  test('when program option before sub option then sub option read by sub', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['--global', '--default'], { from: 'user' });\n    expect(sub.opts().default).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when shared option before sub argument then option read by program",
            "suites": [
                "program with positionalOptions and default subcommand (called sub)"
            ],
            "updatePoint": {
                "line": 177,
                "column": 74
            },
            "line": 177,
            "code": "  test('when shared option before sub argument then option read by program', () => {\n    const { program } = makeProgram();\n    program.parse(['--shared', 'foo'], { from: 'user' });\n    expect(program.opts().shared).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when shared option after sub argument then option read by sub",
            "suites": [
                "program with positionalOptions and default subcommand (called sub)"
            ],
            "updatePoint": {
                "line": 183,
                "column": 69
            },
            "line": 183,
            "code": "  test('when shared option after sub argument then option read by sub', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['foo', '--shared'], { from: 'user' });\n    expect(sub.opts().shared).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "help: when user args %p then program/sub help called %p/%p",
            "suites": [
                "program with positionalOptions and default subcommand (called sub)"
            ],
            "line": 189,
            "code": "  test.each([\n    [[], 0, 0],\n    [['--help'], 1, 0],\n    [['help'], 1, 0]\n  ])('help: when user args %p then program/sub help called %p/%p', (userArgs, expectProgramHelpCount, expectSubHelpCount) => {\n    const { program, sub } = makeProgram();\n    const mockProgramHelp = jest.fn();\n    program\n      .exitOverride()\n      .configureHelp({ formatHelp: mockProgramHelp });\n    const mockSubHelp = jest.fn();\n    sub\n      .exitOverride()\n      .configureHelp({ formatHelp: mockSubHelp });\n\n    try {\n      program.parse(userArgs, { from: 'user' });\n    } catch (err) {\n    }\n    expect(mockProgramHelp).toHaveBeenCalledTimes(expectProgramHelpCount);\n    expect(mockSubHelp).toHaveBeenCalledTimes(expectSubHelpCount);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option before command-argument then option parsed",
            "suites": [
                "subcommand with passThrough"
            ],
            "updatePoint": {
                "line": 232,
                "column": 62
            },
            "line": 232,
            "code": "  test('when option before command-argument then option parsed', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['sub', '--debug', 'arg'], { from: 'user' });\n    expect(sub.args).toEqual(['arg']);\n    expect(sub.opts().debug).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when known option after command-argument then option passed through",
            "suites": [
                "subcommand with passThrough"
            ],
            "updatePoint": {
                "line": 239,
                "column": 75
            },
            "line": 239,
            "code": "  test('when known option after command-argument then option passed through', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['sub', 'arg', '--debug'], { from: 'user' });\n    expect(sub.args).toEqual(['arg', '--debug']);\n    expect(sub.opts().debug).toBeUndefined();\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown option after command-argument then option passed through",
            "suites": [
                "subcommand with passThrough"
            ],
            "updatePoint": {
                "line": 246,
                "column": 77
            },
            "line": 246,
            "code": "  test('when unknown option after command-argument then option passed through', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['sub', 'arg', '--pass'], { from: 'user' });\n    expect(sub.args).toEqual(['arg', '--pass']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when action handler and unknown option after command-argument then option passed through",
            "suites": [
                "subcommand with passThrough"
            ],
            "updatePoint": {
                "line": 252,
                "column": 96
            },
            "line": 252,
            "code": "  test('when action handler and unknown option after command-argument then option passed through', () => {\n    const { program, sub } = makeProgram();\n    const mockAction = jest.fn();\n    sub.action(mockAction);\n    program.parse(['sub', 'arg', '--pass'], { from: 'user' });\n    expect(mockAction).toHaveBeenCalledWith(['arg', '--pass'], sub.opts(), sub);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help option after command-argument then option passed through",
            "suites": [
                "subcommand with passThrough"
            ],
            "updatePoint": {
                "line": 260,
                "column": 74
            },
            "line": 260,
            "code": "  test('when help option after command-argument then option passed through', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['sub', 'arg', '--help'], { from: 'user' });\n    expect(sub.args).toEqual(['arg', '--help']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when version option after command-argument then option passed through",
            "suites": [
                "subcommand with passThrough"
            ],
            "updatePoint": {
                "line": 266,
                "column": 77
            },
            "line": 266,
            "code": "  test('when version option after command-argument then option passed through', () => {\n    const { program, sub } = makeProgram();\n    program.version('1.2.3');\n    program.parse(['sub', 'arg', '--version'], { from: 'user' });\n    expect(sub.args).toEqual(['arg', '--version']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when shared option before sub and after sub and after sub parameter then all three parsed",
            "suites": [
                "subcommand with passThrough"
            ],
            "updatePoint": {
                "line": 273,
                "column": 97
            },
            "line": 273,
            "code": "  test('when shared option before sub and after sub and after sub parameter then all three parsed', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['--shared=global', 'sub', '--shared=local', 'arg', '--shared'], { from: 'user' });\n    expect(program.opts().shared).toEqual('global');\n    expect(sub.opts().shared).toEqual('local');\n    expect(sub.args).toEqual(['arg', '--shared']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option before command-argument then option parsed",
            "suites": [
                "default command with passThrough"
            ],
            "updatePoint": {
                "line": 298,
                "column": 62
            },
            "line": 298,
            "code": "  test('when option before command-argument then option parsed', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['--debug', 'arg'], { from: 'user' });\n    expect(sub.args).toEqual(['arg']);\n    expect(sub.opts().debug).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when known option after command-argument then option passed through",
            "suites": [
                "default command with passThrough"
            ],
            "updatePoint": {
                "line": 305,
                "column": 75
            },
            "line": 305,
            "code": "  test('when known option after command-argument then option passed through', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['arg', '--debug'], { from: 'user' });\n    expect(sub.args).toEqual(['arg', '--debug']);\n    expect(sub.opts().debug).toBeUndefined();\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown option after command-argument then option passed through",
            "suites": [
                "default command with passThrough"
            ],
            "updatePoint": {
                "line": 312,
                "column": 77
            },
            "line": 312,
            "code": "  test('when unknown option after command-argument then option passed through', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['arg', '--pass'], { from: 'user' });\n    expect(sub.args).toEqual(['arg', '--pass']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when action handler and unknown option after command-argument then option passed through",
            "suites": [
                "default command with passThrough"
            ],
            "updatePoint": {
                "line": 318,
                "column": 96
            },
            "line": 318,
            "code": "  test('when action handler and unknown option after command-argument then option passed through', () => {\n    const { program, sub } = makeProgram();\n    const mockAction = jest.fn();\n    sub.action(mockAction);\n    program.parse(['arg', '--pass'], { from: 'user' });\n    expect(mockAction).toHaveBeenCalledWith(['arg', '--pass'], sub.opts(), sub);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global option before parameter then global option parsed",
            "suites": [
                "program with action handler and positionalOptions and subcommand"
            ],
            "updatePoint": {
                "line": 344,
                "column": 69
            },
            "line": 344,
            "code": "  test('when global option before parameter then global option parsed', () => {\n    const { program } = makeProgram();\n    program.parse(['--global', 'foo'], { from: 'user' });\n    expect(program.opts().global).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global option after parameter then global option parsed",
            "suites": [
                "program with action handler and positionalOptions and subcommand"
            ],
            "updatePoint": {
                "line": 350,
                "column": 68
            },
            "line": 350,
            "code": "  test('when global option after parameter then global option parsed', () => {\n    const { program } = makeProgram();\n    program.parse(['foo', '--global'], { from: 'user' });\n    expect(program.opts().global).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global option after parameter with same name as subcommand then global option parsed",
            "suites": [
                "program with action handler and positionalOptions and subcommand"
            ],
            "updatePoint": {
                "line": 356,
                "column": 97
            },
            "line": 356,
            "code": "  test('when global option after parameter with same name as subcommand then global option parsed', () => {\n    const { program } = makeProgram();\n    program.parse(['foo', 'sub', '--global'], { from: 'user' });\n    expect(program.opts().global).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program not positional and turn on passthrough in subcommand then error",
            "suites": [
                "program with action handler and positionalOptions and subcommand"
            ],
            "updatePoint": {
                "line": 365,
                "column": 82
            },
            "line": 365,
            "code": "test('when program not positional and turn on passthrough in subcommand then error', () => {\n  const program = new commander.Command();\n  const sub = program.command('sub');\n\n  expect(() => {\n    sub.passThroughOptions();\n  }).toThrow();\n});",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global option before parameter then global option parsed",
            "suites": [
                "program with action handler and passThrough and subcommand"
            ],
            "updatePoint": {
                "line": 393,
                "column": 69
            },
            "line": 393,
            "code": "  test('when global option before parameter then global option parsed', () => {\n    const { program } = makeProgram();\n    program.parse(['--global', 'foo'], { from: 'user' });\n    expect(program.opts().global).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global option after parameter then passed through",
            "suites": [
                "program with action handler and passThrough and subcommand"
            ],
            "updatePoint": {
                "line": 399,
                "column": 62
            },
            "line": 399,
            "code": "  test('when global option after parameter then passed through', () => {\n    const { program } = makeProgram();\n    program.parse(['foo', '--global'], { from: 'user' });\n    expect(program.args).toEqual(['foo', '--global']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand option after subcommand then option parsed",
            "suites": [
                "program with action handler and passThrough and subcommand"
            ],
            "updatePoint": {
                "line": 405,
                "column": 66
            },
            "line": 405,
            "code": "  test('when subcommand option after subcommand then option parsed', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['sub', '--debug'], { from: 'user' });\n    expect(sub.opts().debug).toBe(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when shared option after subcommand then parsed by subcommand",
            "suites": [
                "program with action handler and passThrough and subcommand"
            ],
            "updatePoint": {
                "line": 412,
                "column": 69
            },
            "line": 412,
            "code": "  test('when shared option after subcommand then parsed by subcommand', () => {\n    const { program, sub } = makeProgram();\n    program.parse(['sub', '-g'], { from: 'user' });\n    expect(sub.opts().group).toBe(true);\n    expect(program.opts().global).toBeUndefined();\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when passThroughOptions and unknown option then arguments from unknown passed through",
            "suites": [
                "program with allowUnknownOption"
            ],
            "updatePoint": {
                "line": 423,
                "column": 93
            },
            "line": 423,
            "code": "  test('when passThroughOptions and unknown option then arguments from unknown passed through', () => {\n    const program = new commander.Command();\n    program\n      .passThroughOptions()\n      .allowUnknownOption()\n      .option('--debug');\n\n    program.parse(['--unknown', '--debug'], { from: 'user' });\n    expect(program.args).toEqual(['--unknown', '--debug']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when positionalOptions and unknown option then known options then known option parsed",
            "suites": [
                "program with allowUnknownOption"
            ],
            "updatePoint": {
                "line": 434,
                "column": 93
            },
            "line": 434,
            "code": "  test('when positionalOptions and unknown option then known options then known option parsed', () => {\n    const program = new commander.Command();\n    program\n      .enablePositionalOptions()\n      .allowUnknownOption()\n      .option('--debug');\n\n    program.parse(['--unknown', '--debug'], { from: 'user' });\n    expect(program.opts().debug).toBe(true);\n    expect(program.args).toEqual(['--unknown']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when passThroughOptions() then option passed through",
            "suites": [
                "passThroughOptions(xxx) and option after command-argument"
            ],
            "updatePoint": {
                "line": 458,
                "column": 60
            },
            "line": 458,
            "code": "  test('when passThroughOptions() then option passed through', () => {\n    const program = makeProgram();\n    program.passThroughOptions();\n    program.parse(['foo', '--debug'], { from: 'user' });\n    expect(program.args).toEqual(['foo', '--debug']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when passThroughOptions(true) then option passed through",
            "suites": [
                "passThroughOptions(xxx) and option after command-argument"
            ],
            "updatePoint": {
                "line": 465,
                "column": 64
            },
            "line": 465,
            "code": "  test('when passThroughOptions(true) then option passed through', () => {\n    const program = makeProgram();\n    program.passThroughOptions(true);\n    program.parse(['foo', '--debug'], { from: 'user' });\n    expect(program.args).toEqual(['foo', '--debug']);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when passThroughOptions(false) then option parsed",
            "suites": [
                "passThroughOptions(xxx) and option after command-argument"
            ],
            "updatePoint": {
                "line": 472,
                "column": 57
            },
            "line": 472,
            "code": "  test('when passThroughOptions(false) then option parsed', () => {\n    const program = makeProgram();\n    program.passThroughOptions(false);\n    program.parse(['foo', '--debug'], { from: 'user' });\n    expect(program.args).toEqual(['foo']);\n    expect(program.opts().debug).toEqual(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when enablePositionalOptions() then option parsed by subcommand",
            "suites": [
                "enablePositionalOptions(xxx) and shared option after subcommand"
            ],
            "updatePoint": {
                "line": 494,
                "column": 71
            },
            "line": 494,
            "code": "  test('when enablePositionalOptions() then option parsed by subcommand', () => {\n    const { program, sub } = makeProgram();\n    program.enablePositionalOptions();\n    program.parse(['sub', '--debug'], { from: 'user' });\n    expect(sub.opts().debug).toEqual(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when enablePositionalOptions(true) then option parsed by subcommand",
            "suites": [
                "enablePositionalOptions(xxx) and shared option after subcommand"
            ],
            "updatePoint": {
                "line": 501,
                "column": 75
            },
            "line": 501,
            "code": "  test('when enablePositionalOptions(true) then option parsed by subcommand', () => {\n    const { program, sub } = makeProgram();\n    program.enablePositionalOptions(true);\n    program.parse(['sub', '--debug'], { from: 'user' });\n    expect(sub.opts().debug).toEqual(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when enablePositionalOptions(false) then option parsed by program",
            "suites": [
                "enablePositionalOptions(xxx) and shared option after subcommand"
            ],
            "updatePoint": {
                "line": 508,
                "column": 73
            },
            "line": 508,
            "code": "  test('when enablePositionalOptions(false) then option parsed by program', () => {\n    const { program, sub } = makeProgram();\n    program.enablePositionalOptions(false);\n    program.parse(['sub', '--debug'], { from: 'user' });\n    expect(sub.opts().debug).toBeUndefined();\n    expect(program.opts().debug).toEqual(true);\n  });",
            "file": "command.positionalOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when missing command-argument then shows help",
            "suites": [
                "showHelpAfterError with message"
            ],
            "updatePoint": {
                "line": 17,
                "column": 53
            },
            "line": 17,
            "code": "  test('when missing command-argument then shows help', () => {\n    const { program, writeMock } = makeProgram();\n    program.argument('<file>');\n    let caughtErr;\n    try {\n      program.parse([], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.missingArgument');\n    expect(writeMock).toHaveBeenLastCalledWith(`${customHelpMessage}\\n`);\n  });",
            "file": "command.showHelpAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when missing option-argument then shows help",
            "suites": [
                "showHelpAfterError with message"
            ],
            "updatePoint": {
                "line": 30,
                "column": 52
            },
            "line": 30,
            "code": "  test('when missing option-argument then shows help', () => {\n    const { program, writeMock } = makeProgram();\n    program.option('--output <file>');\n    let caughtErr;\n    try {\n      program.parse(['--output'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.optionMissingArgument');\n    expect(writeMock).toHaveBeenLastCalledWith(`${customHelpMessage}\\n`);\n  });",
            "file": "command.showHelpAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when missing mandatory option then shows help",
            "suites": [
                "showHelpAfterError with message"
            ],
            "updatePoint": {
                "line": 43,
                "column": 53
            },
            "line": 43,
            "code": "  test('when missing mandatory option then shows help', () => {\n    const { program, writeMock } = makeProgram();\n    program.requiredOption('--password <cipher>');\n    let caughtErr;\n    try {\n      program.parse([], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.missingMandatoryOptionValue');\n    expect(writeMock).toHaveBeenLastCalledWith(`${customHelpMessage}\\n`);\n  });",
            "file": "command.showHelpAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown option then shows help",
            "suites": [
                "showHelpAfterError with message"
            ],
            "updatePoint": {
                "line": 56,
                "column": 43
            },
            "line": 56,
            "code": "  test('when unknown option then shows help', () => {\n    const { program, writeMock } = makeProgram();\n    let caughtErr;\n    try {\n      program.parse(['--unknown-option'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n    expect(writeMock).toHaveBeenLastCalledWith(`${customHelpMessage}\\n`);\n  });",
            "file": "command.showHelpAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when too many command-arguments then shows help",
            "suites": [
                "showHelpAfterError with message"
            ],
            "updatePoint": {
                "line": 68,
                "column": 55
            },
            "line": 68,
            "code": "  test('when too many command-arguments then shows help', () => {\n    const { program, writeMock } = makeProgram();\n    program\n      .allowExcessArguments(false);\n    let caughtErr;\n    try {\n      program.parse(['surprise'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.excessArguments');\n    expect(writeMock).toHaveBeenLastCalledWith(`${customHelpMessage}\\n`);\n  });",
            "file": "command.showHelpAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown command then shows help",
            "suites": [
                "showHelpAfterError with message"
            ],
            "updatePoint": {
                "line": 82,
                "column": 44
            },
            "line": 82,
            "code": "  test('when unknown command then shows help', () => {\n    const { program, writeMock } = makeProgram();\n    program.command('sub1');\n    let caughtErr;\n    try {\n      program.parse(['sub2'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownCommand');\n    expect(writeMock).toHaveBeenLastCalledWith(`${customHelpMessage}\\n`);\n  });",
            "file": "command.showHelpAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when invalid option choice then shows help",
            "suites": [
                "showHelpAfterError with message"
            ],
            "updatePoint": {
                "line": 95,
                "column": 50
            },
            "line": 95,
            "code": "  test('when invalid option choice then shows help', () => {\n    const { program, writeMock } = makeProgram();\n    program.addOption(new commander.Option('--color').choices(['red', 'blue']));\n    let caughtErr;\n    try {\n      program.parse(['--color', 'pink'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.invalidArgument');\n    expect(writeMock).toHaveBeenLastCalledWith(`${customHelpMessage}\\n`);\n  });",
            "file": "command.showHelpAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when showHelpAfterError() and error and then shows full help",
            "suites": [
                "showHelpAfterError with message"
            ],
            "updatePoint": {
                "line": 109,
                "column": 66
            },
            "line": 109,
            "code": "test('when showHelpAfterError() and error and then shows full help', () => {\n  const writeMock = jest.fn();\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .showHelpAfterError()\n    .configureOutput({ writeErr: writeMock });\n\n  try {\n    program.parse(['--unknown-option'], { from: 'user' });\n  } catch (err) {\n  }\n  expect(writeMock).toHaveBeenLastCalledWith(program.helpInformation());\n});",
            "file": "command.showHelpAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown command and showSuggestionAfterError() then show suggestion",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 78
            },
            "line": 20,
            "code": "test('when unknown command and showSuggestionAfterError() then show suggestion', () => {\n  const program = new Command();\n  program.showSuggestionAfterError();\n  program.command('example');\n  const suggestion = getSuggestion(program, 'exampel');\n  expect(suggestion).toBe('example');\n});",
            "file": "command.showSuggestionAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown command and showSuggestionAfterError(false) then do not show suggestion",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 90
            },
            "line": 28,
            "code": "test('when unknown command and showSuggestionAfterError(false) then do not show suggestion', () => {\n  const program = new Command();\n  program.showSuggestionAfterError(false);\n  program.command('example');\n  const suggestion = getSuggestion(program, 'exampel');\n  expect(suggestion).toBe(null);\n});",
            "file": "command.showSuggestionAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown option and showSuggestionAfterError() then show suggestion",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 77
            },
            "line": 36,
            "code": "test('when unknown option and showSuggestionAfterError() then show suggestion', () => {\n  const program = new Command();\n  program.showSuggestionAfterError();\n  program.option('--example');\n  const suggestion = getSuggestion(program, '--exampel');\n  expect(suggestion).toBe('--example');\n});",
            "file": "command.showSuggestionAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown option and showSuggestionAfterError(false) then do not show suggestion",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 89
            },
            "line": 44,
            "code": "test('when unknown option and showSuggestionAfterError(false) then do not show suggestion', () => {\n  const program = new Command();\n  program.showSuggestionAfterError(false);\n  program.option('--example');\n  const suggestion = getSuggestion(program, '--exampel');\n  expect(suggestion).toBe(null);\n});",
            "file": "command.showSuggestionAfterError.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown argument in simple program then no error",
            "suites": [
                "unknownCommand"
            ],
            "updatePoint": {
                "line": 19,
                "column": 61
            },
            "line": 19,
            "code": "  test('when unknown argument in simple program then no error', () => {\n    const program = new commander.Command();\n    program.exitOverride();\n    expect(() => {\n      program.parse('node test.js unknown'.split(' '));\n    }).not.toThrow();\n  });",
            "file": "command.unknownCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown command but action handler taking arg then no error",
            "suites": [
                "unknownCommand"
            ],
            "updatePoint": {
                "line": 27,
                "column": 72
            },
            "line": 27,
            "code": "  test('when unknown command but action handler taking arg then no error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('sub');\n    program\n      .argument('[args...]')\n      .action(() => { });\n    expect(() => {\n      program.parse('node test.js unknown'.split(' '));\n    }).not.toThrow();\n  });",
            "file": "command.unknownCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown command but listener then no error",
            "suites": [
                "unknownCommand"
            ],
            "updatePoint": {
                "line": 40,
                "column": 55
            },
            "line": 40,
            "code": "  test('when unknown command but listener then no error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('sub');\n    program\n      .on('command:*', () => { });\n    expect(() => {\n      program.parse('node test.js unknown'.split(' '));\n    }).not.toThrow();\n  });",
            "file": "command.unknownCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown command then error",
            "suites": [
                "unknownCommand"
            ],
            "updatePoint": {
                "line": 52,
                "column": 39
            },
            "line": 52,
            "code": "  test('when unknown command then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('sub');\n    let caughtErr;\n    try {\n      program.parse('node test.js unknown'.split(' '));\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownCommand');\n  });",
            "file": "command.unknownCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unknown command and unknown option then error is for unknown command",
            "suites": [
                "unknownCommand"
            ],
            "updatePoint": {
                "line": 66,
                "column": 81
            },
            "line": 66,
            "code": "  test('when unknown command and unknown option then error is for unknown command', () => {\n    //  The unknown command is more useful since the option is for an unknown command (and might be\n    // ok if the command had been correctly spelled, say).\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('sub');\n    let caughtErr;\n    try {\n      program.parse('node test.js sbu --silly'.split(' '));\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownCommand');\n  });",
            "file": "command.unknownCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown option with subcommand and action handler then error",
            "suites": [
                "unknownOption"
            ],
            "updatePoint": {
                "line": 21,
                "column": 81
            },
            "line": 21,
            "code": "  test('when specify unknown option with subcommand and action handler then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('info')\n      .action(() => {});\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'info', '--NONSENSE']);\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n  });",
            "file": "command.unknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown option with subcommand argument and action handler then error",
            "suites": [
                "unknownOption"
            ],
            "updatePoint": {
                "line": 37,
                "column": 90
            },
            "line": 37,
            "code": "  test('when specify unknown option with subcommand argument and action handler then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('info <file>')\n      .action(() => {});\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'info', 'a', '--NONSENSE']);\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n  });",
            "file": "command.unknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown option with program and action handler then error",
            "suites": [
                "unknownOption"
            ],
            "updatePoint": {
                "line": 53,
                "column": 78
            },
            "line": 53,
            "code": "  test('when specify unknown option with program and action handler then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .argument('[file]')\n      .action(() => {});\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', '--NONSENSE']);\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n  });",
            "file": "command.unknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown option with program argument and action handler then error",
            "suites": [
                "unknownOption"
            ],
            "updatePoint": {
                "line": 69,
                "column": 87
            },
            "line": 69,
            "code": "  test('when specify unknown option with program argument and action handler then error', () => {\n    // Regression test from #965\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .argument('[file]')\n      .action(() => {});\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'info', 'a', '--NONSENSE']);\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n  });",
            "file": "command.unknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown option with simple program then error",
            "suites": [
                "unknownOption"
            ],
            "updatePoint": {
                "line": 86,
                "column": 66
            },
            "line": 86,
            "code": "  test('when specify unknown option with simple program then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride();\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', '--NONSENSE']);\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n  });",
            "file": "command.unknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify unknown global option before subcommand then error",
            "suites": [
                "unknownOption"
            ],
            "updatePoint": {
                "line": 99,
                "column": 71
            },
            "line": 99,
            "code": "  test('when specify unknown global option before subcommand then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride();\n    program.command('sub');\n\n    let caughtErr;\n    try {\n      program.parse(['--NONSENSE', 'sub'], { from: 'user' });\n    } catch (err) {\n      caughtErr = err;\n    }\n    expect(caughtErr.code).toBe('commander.unknownOption');\n  });",
            "file": "command.unknownOption.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default usage and check program help then starts with default usage",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 78
            },
            "line": 3,
            "code": "test('when default usage and check program help then starts with default usage', () => {\n  const program = new commander.Command();\n\n  program.name('test');\n  const helpInformation = program.helpInformation();\n\n  expect(helpInformation).toMatch(/^Usage: test \\[options\\]/);\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom usage and check program help then starts with custom usage",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 76
            },
            "line": 12,
            "code": "test('when custom usage and check program help then starts with custom usage', () => {\n  const myUsage = 'custom';\n  const program = new commander.Command();\n  program\n    .usage(myUsage);\n\n  program.name('test');\n  const helpInformation = program.helpInformation();\n\n  expect(helpInformation).toMatch(new RegExp(`^Usage: test ${myUsage}`));\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default usage and check subcommand help then starts with default usage including program name",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 104
            },
            "line": 24,
            "code": "test('when default usage and check subcommand help then starts with default usage including program name', () => {\n  const program = new commander.Command();\n  const subCommand = program\n    .command('info');\n\n  program.name('test');\n  const helpInformation = subCommand.helpInformation();\n\n  expect(helpInformation).toMatch(/^Usage: test info \\[options\\]/);\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom usage and check subcommand help then starts with custom usage including program name",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 102
            },
            "line": 35,
            "code": "test('when custom usage and check subcommand help then starts with custom usage including program name', () => {\n  const myUsage = 'custom';\n  const program = new commander.Command();\n  const subCommand = program\n    .command('info')\n    .usage(myUsage);\n\n  program.name('test');\n  const helpInformation = subCommand.helpInformation();\n\n  expect(helpInformation).toMatch(new RegExp(`^Usage: test info ${myUsage}`));\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when has option then [options] included in usage",
            "suites": [],
            "updatePoint": {
                "line": 48,
                "column": 54
            },
            "line": 48,
            "code": "test('when has option then [options] included in usage', () => {\n  const program = new commander.Command();\n\n  program\n    .option('--foo');\n\n  expect(program.usage()).toMatch('[options]');\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no options then [options] not included in usage",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 58
            },
            "line": 57,
            "code": "test('when no options then [options] not included in usage', () => {\n  const program = new commander.Command();\n\n  program\n    .helpOption(false);\n\n  expect(program.usage()).not.toMatch('[options]');\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when has command then [command] included in usage",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 55
            },
            "line": 66,
            "code": "test('when has command then [command] included in usage', () => {\n  const program = new commander.Command();\n\n  program\n    .command('foo');\n\n  expect(program.usage()).toMatch('[command]');\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no commands then [command] not included in usage",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 59
            },
            "line": 75,
            "code": "test('when no commands then [command] not included in usage', () => {\n  const program = new commander.Command();\n\n  expect(program.usage()).not.toMatch('[command]');\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument then argument included in usage",
            "suites": [],
            "updatePoint": {
                "line": 81,
                "column": 51
            },
            "line": 81,
            "code": "test('when argument then argument included in usage', () => {\n  const program = new commander.Command();\n\n  program\n    .argument('<file>');\n\n  expect(program.usage()).toMatch('<file>');\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when options and command and argument then all three included in usage",
            "suites": [],
            "updatePoint": {
                "line": 90,
                "column": 76
            },
            "line": 90,
            "code": "test('when options and command and argument then all three included in usage', () => {\n  const program = new commander.Command();\n\n  program\n    .argument('<file>')\n    .option('--alpha')\n    .command('beta');\n\n  expect(program.usage()).toEqual('[options] [command] <file>');\n});",
            "file": "command.usage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default then options not stored on command",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 53
            },
            "line": 7,
            "code": "test('when default then options not stored on command', () => {\n  const program = new commander.Command();\n  program\n    .option('--foo <value>', 'description');\n  program.parse(['node', 'test', '--foo', 'bar']);\n  expect(program.foo).toBeUndefined();\n  expect(program.opts().foo).toBe('bar');\n});",
            "file": "commander.configureCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default then options+command passed to action",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 56
            },
            "line": 16,
            "code": "test('when default then options+command passed to action', () => {\n  const program = new commander.Command();\n  const callback = jest.fn();\n  program\n    .argument('<value>')\n    .action(callback);\n  program.parse(['node', 'test', 'value']);\n  expect(callback).toHaveBeenCalledWith('value', program.opts(), program);\n});",
            "file": "commander.configureCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when storeOptionsAsProperties() then options stored on command",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 68
            },
            "line": 28,
            "code": "test('when storeOptionsAsProperties() then options stored on command', () => {\n  const program = new commander.Command();\n  program\n    .storeOptionsAsProperties()\n    .option('--foo <value>', 'description');\n  program.parse(['node', 'test', '--foo', 'bar']);\n  expect(program.foo).toBe('bar');\n  expect(program.opts().foo).toBe('bar');\n});",
            "file": "commander.configureCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when storeOptionsAsProperties(true) then options stored on command",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 72
            },
            "line": 38,
            "code": "test('when storeOptionsAsProperties(true) then options stored on command', () => {\n  const program = new commander.Command();\n  program\n    .storeOptionsAsProperties(true)\n    .option('--foo <value>', 'description');\n  program.parse(['node', 'test', '--foo', 'bar']);\n  expect(program.foo).toBe('bar');\n  expect(program.opts().foo).toBe('bar');\n});",
            "file": "commander.configureCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when storeOptionsAsProperties(false) then options not stored on command",
            "suites": [],
            "updatePoint": {
                "line": 48,
                "column": 77
            },
            "line": 48,
            "code": "test('when storeOptionsAsProperties(false) then options not stored on command', () => {\n  const program = new commander.Command();\n  program\n    .storeOptionsAsProperties(false)\n    .option('--foo <value>', 'description');\n  program.parse(['node', 'test', '--foo', 'bar']);\n  expect(program.foo).toBeUndefined();\n  expect(program.opts().foo).toBe('bar');\n});",
            "file": "commander.configureCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when storeOptionsAsProperties() then command+command passed to action",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 75
            },
            "line": 58,
            "code": "test('when storeOptionsAsProperties() then command+command passed to action', () => {\n  const program = new commander.Command();\n  const callback = jest.fn();\n  program\n    .storeOptionsAsProperties()\n    .argument('<value>')\n    .action(callback);\n  program.parse(['node', 'test', 'value']);\n  expect(callback).toHaveBeenCalledWith('value', program, program);\n});",
            "file": "commander.configureCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when storeOptionsAsProperties(false) then opts+command passed to action",
            "suites": [],
            "updatePoint": {
                "line": 69,
                "column": 77
            },
            "line": 69,
            "code": "test('when storeOptionsAsProperties(false) then opts+command passed to action', () => {\n  const program = new commander.Command();\n  const callback = jest.fn();\n  program\n    .storeOptionsAsProperties(false)\n    .argument('<value>')\n    .action(callback);\n  program.parse(['node', 'test', 'value']);\n  expect(callback).toHaveBeenCalledWith('value', program.opts(), program);\n});",
            "file": "commander.configureCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when storeOptionsAsProperties() after adding option then throw",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 68
            },
            "line": 80,
            "code": "test('when storeOptionsAsProperties() after adding option then throw', () => {\n  const program = new commander.Command();\n  program.option('--port <number>', 'port number', '80');\n  expect(() => {\n    program.storeOptionsAsProperties(false);\n  }).toThrow();\n});",
            "file": "commander.configureCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when createCommand then unattached",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 40
            },
            "line": 3,
            "code": "test('when createCommand then unattached', () => {\n  const program = new commander.Command();\n  const cmd = program.createCommand();\n  expect(program.commands.length).toBe(0);\n  expect(cmd.parent).toBeFalsy(); // (actually null, but use weaker test for unattached)\n});",
            "file": "createCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subclass overrides createCommand then subcommand is subclass",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 71
            },
            "line": 10,
            "code": "test('when subclass overrides createCommand then subcommand is subclass', () => {\n  class MyClass extends commander.Command {\n    constructor(name) {\n      super();\n      this.myProperty = 'myClass';\n    };\n\n    createCommand(name) {\n      return new MyClass(name);\n    };\n  };\n  const program = new MyClass();\n  const sub = program.command('sub');\n  expect(sub.myProperty).toEqual('myClass');\n});",
            "file": "createCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when override createCommand then subcommand is custom",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 59
            },
            "line": 26,
            "code": "test('when override createCommand then subcommand is custom', () => {\n  function createCustom(name) {\n    const cmd = new commander.Command();\n    cmd.myProperty = 'custom';\n    return cmd;\n  }\n  const program = createCustom();\n  program.createCommand = createCustom;\n  const sub = program.command('sub');\n  expect(sub.myProperty).toEqual('custom');\n});",
            "file": "createCommand.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option not given then value is default",
            "suites": [
                "option with regular expression instead of custom processing function"
            ],
            "updatePoint": {
                "line": 8,
                "column": 51
            },
            "line": 8,
            "code": "  test('when option not given then value is default', () => {\n    const program = new commander.Command();\n    program\n      .option('--cheese <type>', 'cheese type', /mild|tasty/, 'mild');\n    program.parse([], { from: 'user' });\n    expect(program.opts().cheese).toEqual('mild');\n  });",
            "file": "deprecated.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument matches regexp then value is as specified",
            "suites": [
                "option with regular expression instead of custom processing function"
            ],
            "updatePoint": {
                "line": 16,
                "column": 63
            },
            "line": 16,
            "code": "  test('when argument matches regexp then value is as specified', () => {\n    const program = new commander.Command();\n    program\n      .option('--cheese <type>', 'cheese type', /mild|tasty/, 'mild');\n    program.parse(['--cheese', 'tasty'], { from: 'user' });\n    expect(program.opts().cheese).toEqual('tasty');\n  });",
            "file": "deprecated.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument does mot matches regexp then value is default",
            "suites": [
                "option with regular expression instead of custom processing function"
            ],
            "updatePoint": {
                "line": 24,
                "column": 67
            },
            "line": 24,
            "code": "  test('when argument does mot matches regexp then value is default', () => {\n    const program = new commander.Command();\n    program\n      .option('--cheese <type>', 'cheese type', /mild|tasty/, 'mild');\n    program.parse(['--cheese', 'other'], { from: 'user' });\n    expect(program.opts().cheese).toEqual('mild');\n  });",
            "file": "deprecated.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument has no description then empty string",
            "suites": [
                "argumentDescription"
            ],
            "updatePoint": {
                "line": 6,
                "column": 58
            },
            "line": 6,
            "code": "  test('when argument has no description then empty string', () => {\n    const argument = new commander.Argument('[n]');\n    const helper = new commander.Help();\n    expect(helper.argumentDescription(argument)).toEqual('');\n  });",
            "file": "help.argumentDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument has description then return description",
            "suites": [
                "argumentDescription"
            ],
            "updatePoint": {
                "line": 12,
                "column": 61
            },
            "line": 12,
            "code": "  test('when argument has description then return description', () => {\n    const description = 'description';\n    const argument = new commander.Argument('[n]', description);\n    const helper = new commander.Help();\n    expect(helper.argumentDescription(argument)).toEqual(description);\n  });",
            "file": "help.argumentDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument has default value then return description and default value",
            "suites": [
                "argumentDescription"
            ],
            "updatePoint": {
                "line": 19,
                "column": 81
            },
            "line": 19,
            "code": "  test('when argument has default value then return description and default value', () => {\n    const argument = new commander.Argument('[n]', 'description').default('default');\n    const helper = new commander.Help();\n    expect(helper.argumentDescription(argument)).toEqual('description (default: \"default\")');\n  });",
            "file": "help.argumentDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument has default value description then return description and custom default description",
            "suites": [
                "argumentDescription"
            ],
            "updatePoint": {
                "line": 25,
                "column": 106
            },
            "line": 25,
            "code": "  test('when argument has default value description then return description and custom default description', () => {\n    const argument = new commander.Argument('[n]', 'description').default('default value', 'custom');\n    const helper = new commander.Help();\n    expect(helper.argumentDescription(argument)).toEqual('description (default: custom)');\n  });",
            "file": "help.argumentDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when an argument has default value and no description then still return default value",
            "suites": [
                "argumentDescription"
            ],
            "updatePoint": {
                "line": 31,
                "column": 93
            },
            "line": 31,
            "code": "  test('when an argument has default value and no description then still return default value', () => {\n    const argument = new commander.Argument('[n]').default('default');\n    const helper = new commander.Help();\n    expect(helper.argumentDescription(argument)).toEqual('(default: \"default\")');\n  });",
            "file": "help.argumentDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has no description then empty string",
            "suites": [
                "subcommandDescription"
            ],
            "updatePoint": {
                "line": 7,
                "column": 57
            },
            "line": 7,
            "code": "  test('when program has no description then empty string', () => {\n    const program = new commander.Command();\n    const helper = new commander.Help();\n    expect(helper.subcommandDescription(program)).toEqual('');\n  });",
            "file": "help.commandDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has description then return description",
            "suites": [
                "subcommandDescription"
            ],
            "updatePoint": {
                "line": 13,
                "column": 60
            },
            "line": 13,
            "code": "  test('when program has description then return description', () => {\n    const description = 'description';\n    const program = new commander.Command();\n    program.description(description);\n    const helper = new commander.Help();\n    expect(helper.subcommandDescription(program)).toEqual(description);\n  });",
            "file": "help.commandDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when plain command then returns name",
            "suites": [
                "subcommandTerm"
            ],
            "updatePoint": {
                "line": 8,
                "column": 44
            },
            "line": 8,
            "code": "  test('when plain command then returns name', () => {\n    const command = new commander.Command('program');\n    const helper = new commander.Help();\n    expect(helper.subcommandTerm(command)).toEqual('program');\n  });",
            "file": "help.commandTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has alias then returns name|alias",
            "suites": [
                "subcommandTerm"
            ],
            "updatePoint": {
                "line": 14,
                "column": 54
            },
            "line": 14,
            "code": "  test('when command has alias then returns name|alias', () => {\n    const command = new commander.Command('program')\n      .alias('alias');\n    const helper = new commander.Help();\n    expect(helper.subcommandTerm(command)).toEqual('program|alias');\n  });",
            "file": "help.commandTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has options then returns name [options]",
            "suites": [
                "subcommandTerm"
            ],
            "updatePoint": {
                "line": 21,
                "column": 60
            },
            "line": 21,
            "code": "  test('when command has options then returns name [options]', () => {\n    const command = new commander.Command('program')\n      .option('-a,--all');\n    const helper = new commander.Help();\n    expect(helper.subcommandTerm(command)).toEqual('program [options]');\n  });",
            "file": "help.commandTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has <argument> then returns name <argument>",
            "suites": [
                "subcommandTerm"
            ],
            "updatePoint": {
                "line": 28,
                "column": 64
            },
            "line": 28,
            "code": "  test('when command has <argument> then returns name <argument>', () => {\n    const command = new commander.Command('program')\n      .argument('<argument>');\n    const helper = new commander.Help();\n    expect(helper.subcommandTerm(command)).toEqual('program <argument>');\n  });",
            "file": "help.commandTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has everything then returns name|alias [options] <argument>",
            "suites": [
                "subcommandTerm"
            ],
            "updatePoint": {
                "line": 35,
                "column": 80
            },
            "line": 35,
            "code": "  test('when command has everything then returns name|alias [options] <argument>', () => {\n    const command = new commander.Command('program')\n      .alias('alias')\n      .option('-a,--all')\n      .argument('<argument>');\n    const helper = new commander.Help();\n    expect(helper.subcommandTerm(command)).toEqual('program|alias [options] <argument>');\n  });",
            "file": "help.commandTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when single program then \"program [options]\"",
            "suites": [
                "commandUsage"
            ],
            "updatePoint": {
                "line": 7,
                "column": 52
            },
            "line": 7,
            "code": "  test('when single program then \"program [options]\"', () => {\n    const program = new commander.Command();\n    program.name('program');\n    const helper = new commander.Help();\n    expect(helper.commandUsage(program)).toEqual('program [options]');\n  });",
            "file": "help.commandUsage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when multi program then \"program [options] [command]\"",
            "suites": [
                "commandUsage"
            ],
            "updatePoint": {
                "line": 14,
                "column": 61
            },
            "line": 14,
            "code": "  test('when multi program then \"program [options] [command]\"', () => {\n    const program = new commander.Command();\n    program.name('program');\n    program.command('sub');\n    const helper = new commander.Help();\n    expect(helper.commandUsage(program)).toEqual('program [options] [command]');\n  });",
            "file": "help.commandUsage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has alias then usage includes alias",
            "suites": [
                "commandUsage"
            ],
            "updatePoint": {
                "line": 22,
                "column": 56
            },
            "line": 22,
            "code": "  test('when program has alias then usage includes alias', () => {\n    const program = new commander.Command();\n    program\n      .name('program')\n      .alias('alias');\n    const helper = new commander.Help();\n    expect(helper.commandUsage(program)).toEqual('program|alias [options]');\n  });",
            "file": "help.commandUsage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help for subcommand then usage includes hierarchy",
            "suites": [
                "commandUsage"
            ],
            "updatePoint": {
                "line": 31,
                "column": 62
            },
            "line": 31,
            "code": "  test('when help for subcommand then usage includes hierarchy', () => {\n    const program = new commander.Command();\n    program\n      .name('program');\n    const sub = program.command('sub')\n      .name('sub');\n    const helper = new commander.Help();\n    expect(helper.commandUsage(sub)).toEqual('program sub [options]');\n  });",
            "file": "help.commandUsage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has argument then usage includes argument",
            "suites": [
                "commandUsage"
            ],
            "updatePoint": {
                "line": 41,
                "column": 62
            },
            "line": 41,
            "code": "  test('when program has argument then usage includes argument', () => {\n    const program = new commander.Command();\n    program\n      .name('program')\n      .argument('<file>');\n    const helper = new commander.Help();\n    expect(helper.commandUsage(program)).toEqual('program [options] <file>');\n  });",
            "file": "help.commandUsage.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no arguments then returns zero",
            "suites": [
                "longestArgumentTermLength"
            ],
            "updatePoint": {
                "line": 7,
                "column": 43
            },
            "line": 7,
            "code": "  test('when no arguments then returns zero', () => {\n    const program = new commander.Command();\n    const helper = new commander.Help();\n    expect(helper.longestArgumentTermLength(program, helper)).toEqual(0);\n  });",
            "file": "help.longestArgumentTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when has argument description then returns argument length",
            "suites": [
                "longestArgumentTermLength"
            ],
            "updatePoint": {
                "line": 13,
                "column": 66
            },
            "line": 13,
            "code": "  test('when has argument description then returns argument length', () => {\n    const program = new commander.Command();\n    program.argument('<wonder>', 'wonder description');\n    const helper = new commander.Help();\n    expect(helper.longestArgumentTermLength(program, helper)).toEqual('wonder'.length);\n  });",
            "file": "help.longestArgumentTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when has multiple argument descriptions then returns longest",
            "suites": [
                "longestArgumentTermLength"
            ],
            "updatePoint": {
                "line": 20,
                "column": 68
            },
            "line": 20,
            "code": "  test('when has multiple argument descriptions then returns longest', () => {\n    const program = new commander.Command();\n    program.argument('<alpha>', 'x');\n    program.argument('<longest>', 'x');\n    program.argument('<beta>', 'x');\n    const helper = new commander.Help();\n    expect(helper.longestArgumentTermLength(program, helper)).toEqual('longest'.length);\n  });",
            "file": "help.longestArgumentTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no commands then returns zero",
            "suites": [
                "longestSubcommandTermLength"
            ],
            "updatePoint": {
                "line": 7,
                "column": 42
            },
            "line": 7,
            "code": "  test('when no commands then returns zero', () => {\n    const program = new commander.Command();\n    const helper = new commander.Help();\n    expect(helper.longestSubcommandTermLength(program, helper)).toEqual(0);\n  });",
            "file": "help.longestCommandTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command and no help then returns length of term",
            "suites": [
                "longestSubcommandTermLength"
            ],
            "updatePoint": {
                "line": 13,
                "column": 60
            },
            "line": 13,
            "code": "  test('when command and no help then returns length of term', () => {\n    const sub = new commander.Command('sub');\n    const program = new commander.Command();\n    program\n      .addHelpCommand(false)\n      .addCommand(sub);\n    const helper = new commander.Help();\n    expect(helper.longestSubcommandTermLength(program, helper)).toEqual(helper.subcommandTerm(sub).length);\n  });",
            "file": "help.longestCommandTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command with arg and no help then returns length of term",
            "suites": [
                "longestSubcommandTermLength"
            ],
            "updatePoint": {
                "line": 23,
                "column": 69
            },
            "line": 23,
            "code": "  test('when command with arg and no help then returns length of term', () => {\n    const sub = new commander.Command('sub <file)');\n    const program = new commander.Command();\n    program\n      .addHelpCommand(false)\n      .addCommand(sub);\n    const helper = new commander.Help();\n    expect(helper.longestSubcommandTermLength(program, helper)).toEqual(helper.subcommandTerm(sub).length);\n  });",
            "file": "help.longestCommandTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when multiple commands then returns longest length",
            "suites": [
                "longestSubcommandTermLength"
            ],
            "updatePoint": {
                "line": 33,
                "column": 58
            },
            "line": 33,
            "code": "  test('when multiple commands then returns longest length', () => {\n    const longestCommandName = 'alphabet-soup <longer_than_help>';\n    const program = new commander.Command();\n    program\n      .addHelpCommand(false)\n      .command('before', 'desc')\n      .command(longestCommandName, 'desc')\n      .command('after', 'desc');\n    const helper = new commander.Help();\n    expect(helper.longestSubcommandTermLength(program, helper)).toEqual(longestCommandName.length);\n  });",
            "file": "help.longestCommandTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when just help command then returns length of help term",
            "suites": [
                "longestSubcommandTermLength"
            ],
            "updatePoint": {
                "line": 45,
                "column": 63
            },
            "line": 45,
            "code": "  test('when just help command then returns length of help term', () => {\n    const program = new commander.Command();\n    program\n      .addHelpCommand(true);\n    const helper = new commander.Help();\n    expect(helper.longestSubcommandTermLength(program, helper)).toEqual('help [command]'.length);\n  });",
            "file": "help.longestCommandTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no option then returns zero",
            "suites": [
                "longestOptionTermLength"
            ],
            "updatePoint": {
                "line": 7,
                "column": 40
            },
            "line": 7,
            "code": "  test('when no option then returns zero', () => {\n    const program = new commander.Command();\n    program.helpOption(false);\n    const helper = new commander.Help();\n    expect(helper.longestOptionTermLength(program, helper)).toEqual(0);\n  });",
            "file": "help.longestOptionTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when just implicit help option returns length of help flags",
            "suites": [
                "longestOptionTermLength"
            ],
            "updatePoint": {
                "line": 14,
                "column": 67
            },
            "line": 14,
            "code": "  test('when just implicit help option returns length of help flags', () => {\n    const program = new commander.Command();\n    const helper = new commander.Help();\n    expect(helper.longestOptionTermLength(program, helper)).toEqual('-h, --help'.length);\n  });",
            "file": "help.longestOptionTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when multiple option then returns longest length",
            "suites": [
                "longestOptionTermLength"
            ],
            "updatePoint": {
                "line": 20,
                "column": 56
            },
            "line": 20,
            "code": "  test('when multiple option then returns longest length', () => {\n    const longestOptionFlags = '-l, --longest <value>';\n    const program = new commander.Command();\n    program\n      .option('--before', 'optional description of flags')\n      .option(longestOptionFlags)\n      .option('--after');\n    const helper = new commander.Help();\n    expect(helper.longestOptionTermLength(program, helper)).toEqual(longestOptionFlags.length);\n  });",
            "file": "help.longestOptionTermLength.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has no description then empty string",
            "suites": [
                "optionDescription"
            ],
            "updatePoint": {
                "line": 7,
                "column": 56
            },
            "line": 7,
            "code": "  test('when option has no description then empty string', () => {\n    const option = new commander.Option('-a');\n    const helper = new commander.Help();\n    expect(helper.optionDescription(option)).toEqual('');\n  });",
            "file": "help.optionDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has description then return description",
            "suites": [
                "optionDescription"
            ],
            "updatePoint": {
                "line": 13,
                "column": 59
            },
            "line": 13,
            "code": "  test('when option has description then return description', () => {\n    const description = 'description';\n    const option = new commander.Option('-a', description);\n    const helper = new commander.Help();\n    expect(helper.optionDescription(option)).toEqual(description);\n  });",
            "file": "help.optionDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has default value then return description and default value",
            "suites": [
                "optionDescription"
            ],
            "updatePoint": {
                "line": 20,
                "column": 79
            },
            "line": 20,
            "code": "  test('when option has default value then return description and default value', () => {\n    const description = 'description';\n    const option = new commander.Option('-a', description).default('default');\n    const helper = new commander.Help();\n    expect(helper.optionDescription(option)).toEqual('description (default: \"default\")');\n  });",
            "file": "help.optionDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has env then return description and env name",
            "suites": [
                "optionDescription"
            ],
            "updatePoint": {
                "line": 27,
                "column": 64
            },
            "line": 27,
            "code": "  test('when option has env then return description and env name', () => {\n    const description = 'description';\n    const option = new commander.Option('-a', description).env('ENV');\n    const helper = new commander.Help();\n    expect(helper.optionDescription(option)).toEqual('description (env: ENV)');\n  });",
            "file": "help.optionDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has default value description then return description and custom default description",
            "suites": [
                "optionDescription"
            ],
            "updatePoint": {
                "line": 34,
                "column": 104
            },
            "line": 34,
            "code": "  test('when option has default value description then return description and custom default description', () => {\n    const description = 'description';\n    const defaultValueDescription = 'custom';\n    const option = new commander.Option('-a', description).default('default value', defaultValueDescription);\n    const helper = new commander.Help();\n    expect(helper.optionDescription(option)).toEqual(`description (default: ${defaultValueDescription})`);\n  });",
            "file": "help.optionDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option has choices then return description and choices",
            "suites": [
                "optionDescription"
            ],
            "updatePoint": {
                "line": 42,
                "column": 67
            },
            "line": 42,
            "code": "  test('when option has choices then return description and choices', () => {\n    const description = 'description';\n    const choices = ['one', 'two'];\n    const option = new commander.Option('-a', description).choices(choices);\n    const helper = new commander.Help();\n    expect(helper.optionDescription(option)).toEqual('description (choices: \"one\", \"two\")');\n  });",
            "file": "help.optionDescription.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when -s flags then returns flags",
            "suites": [
                "optionTerm"
            ],
            "updatePoint": {
                "line": 7,
                "column": 40
            },
            "line": 7,
            "code": "  test('when -s flags then returns flags', () => {\n    const flags = '-s';\n    const option = new commander.Option(flags);\n    const helper = new commander.Help();\n    expect(helper.optionTerm(option)).toEqual(flags);\n  });",
            "file": "help.optionTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --short flags then returns flags",
            "suites": [
                "optionTerm"
            ],
            "updatePoint": {
                "line": 14,
                "column": 45
            },
            "line": 14,
            "code": "  test('when --short flags then returns flags', () => {\n    const flags = '--short';\n    const option = new commander.Option(flags);\n    const helper = new commander.Help();\n    expect(helper.optionTerm(option)).toEqual(flags);\n  });",
            "file": "help.optionTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when -s,--short flags then returns flags",
            "suites": [
                "optionTerm"
            ],
            "updatePoint": {
                "line": 21,
                "column": 48
            },
            "line": 21,
            "code": "  test('when -s,--short flags then returns flags', () => {\n    const flags = '-s,--short';\n    const option = new commander.Option(flags);\n    const helper = new commander.Help();\n    expect(helper.optionTerm(option)).toEqual(flags);\n  });",
            "file": "help.optionTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when -s|--short flags then returns flags",
            "suites": [
                "optionTerm"
            ],
            "updatePoint": {
                "line": 28,
                "column": 48
            },
            "line": 28,
            "code": "  test('when -s|--short flags then returns flags', () => {\n    const flags = '-s|--short';\n    const option = new commander.Option(flags);\n    const helper = new commander.Help();\n    expect(helper.optionTerm(option)).toEqual(flags);\n  });",
            "file": "help.optionTerm.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument term longest return argument length",
            "suites": [
                "padWidth"
            ],
            "updatePoint": {
                "line": 7,
                "column": 57
            },
            "line": 7,
            "code": "  test('when argument term longest return argument length', () => {\n    const longestThing = 'veryLongThingBiggerThanOthers';\n    const program = new commander.Command();\n    program\n      .argument(`<${longestThing}>`, 'description')\n      .option('-o');\n    program\n      .command('sub');\n    const helper = new commander.Help();\n    expect(helper.padWidth(program, helper)).toEqual(longestThing.length);\n  });",
            "file": "help.padWidth.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option term longest return option length",
            "suites": [
                "padWidth"
            ],
            "updatePoint": {
                "line": 19,
                "column": 53
            },
            "line": 19,
            "code": "  test('when option term longest return option length', () => {\n    const longestThing = '--very-long-thing-bigger-than-others';\n    const program = new commander.Command();\n    program\n      .argument('<file>', 'desc')\n      .option(longestThing);\n    program\n      .command('sub');\n    const helper = new commander.Help();\n    expect(helper.padWidth(program, helper)).toEqual(longestThing.length);\n  });",
            "file": "help.padWidth.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command term longest return command length",
            "suites": [
                "padWidth"
            ],
            "updatePoint": {
                "line": 31,
                "column": 55
            },
            "line": 31,
            "code": "  test('when command term longest return command length', () => {\n    const longestThing = 'very-long-thing-bigger-than-others';\n    const program = new commander.Command();\n    program\n      .argument('<file>', 'desc')\n      .option('-o');\n    program\n      .command(longestThing);\n    const helper = new commander.Help();\n    expect(helper.padWidth(program, helper)).toEqual(longestThing.length);\n  });",
            "file": "help.padWidth.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unsorted then commands in order added",
            "suites": [
                "sortSubcommands"
            ],
            "updatePoint": {
                "line": 7,
                "column": 50
            },
            "line": 7,
            "code": "  test('when unsorted then commands in order added', () => {\n    const program = new commander.Command();\n    program\n      .command('ccc', 'desc')\n      .command('aaa', 'desc')\n      .command('bbb', 'desc');\n    const helper = program.createHelp();\n    const visibleCommandNames = helper.visibleCommands(program).map(cmd => cmd.name());\n    expect(visibleCommandNames).toEqual(['ccc', 'aaa', 'bbb', 'help']);\n  });",
            "file": "help.sortCommands.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when sortSubcommands:true then commands sorted",
            "suites": [
                "sortSubcommands"
            ],
            "updatePoint": {
                "line": 18,
                "column": 54
            },
            "line": 18,
            "code": "  test('when sortSubcommands:true then commands sorted', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ sortSubcommands: true })\n      .command('ccc', 'desc')\n      .command('aaa', 'desc')\n      .command('bbb', 'desc');\n    const helper = program.createHelp();\n    const visibleCommandNames = helper.visibleCommands(program).map(cmd => cmd.name());\n    expect(visibleCommandNames).toEqual(['aaa', 'bbb', 'ccc', 'help']);\n  });",
            "file": "help.sortCommands.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when unsorted then options in order added",
            "suites": [
                "sortOptions"
            ],
            "updatePoint": {
                "line": 7,
                "column": 49
            },
            "line": 7,
            "code": "  test('when unsorted then options in order added', () => {\n    const program = new commander.Command();\n    program\n      .option('--zzz', 'desc')\n      .option('--aaa', 'desc')\n      .option('--bbb', 'desc');\n    const helper = program.createHelp();\n    const visibleOptionNames = helper.visibleOptions(program).map(option => option.name());\n    expect(visibleOptionNames).toEqual(['zzz', 'aaa', 'bbb', 'help']);\n  });",
            "file": "help.sortOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when sortOptions:true then options sorted alphabetically",
            "suites": [
                "sortOptions"
            ],
            "updatePoint": {
                "line": 18,
                "column": 64
            },
            "line": 18,
            "code": "  test('when sortOptions:true then options sorted alphabetically', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ sortOptions: true })\n      .option('--zzz', 'desc')\n      .option('--aaa', 'desc')\n      .option('--bbb', 'desc');\n    const helper = program.createHelp();\n    const visibleOptionNames = helper.visibleOptions(program).map(cmd => cmd.name());\n    expect(visibleOptionNames).toEqual(['aaa', 'bbb', 'help', 'zzz']);\n  });",
            "file": "help.sortOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when both short and long flags then sort on short flag",
            "suites": [
                "sortOptions"
            ],
            "updatePoint": {
                "line": 30,
                "column": 62
            },
            "line": 30,
            "code": "  test('when both short and long flags then sort on short flag', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ sortOptions: true })\n      .option('-m,--zzz', 'desc')\n      .option('-n,--aaa', 'desc')\n      .option('-o,--bbb', 'desc');\n    const helper = program.createHelp();\n    const visibleOptionNames = helper.visibleOptions(program).map(cmd => cmd.name());\n    expect(visibleOptionNames).toEqual(['help', 'zzz', 'aaa', 'bbb']);\n  });",
            "file": "help.sortOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when lone short and long flags then sort on lone flag",
            "suites": [
                "sortOptions"
            ],
            "updatePoint": {
                "line": 42,
                "column": 61
            },
            "line": 42,
            "code": "  test('when lone short and long flags then sort on lone flag', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ sortOptions: true })\n      .option('--zzz', 'desc')\n      .option('--aaa', 'desc')\n      .option('-b', 'desc');\n    const helper = program.createHelp();\n    const visibleOptionNames = helper.visibleOptions(program).map(cmd => cmd.name());\n    expect(visibleOptionNames).toEqual(['aaa', 'b', 'help', 'zzz']);\n  });",
            "file": "help.sortOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when mixed case flags then sort is case insensitive",
            "suites": [
                "sortOptions"
            ],
            "updatePoint": {
                "line": 54,
                "column": 59
            },
            "line": 54,
            "code": "  test('when mixed case flags then sort is case insensitive', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ sortOptions: true })\n      .option('-B', 'desc')\n      .option('-a', 'desc')\n      .option('-c', 'desc');\n    const helper = program.createHelp();\n    const visibleOptionNames = helper.visibleOptions(program).map(cmd => cmd.name());\n    expect(visibleOptionNames).toEqual(['a', 'B', 'c', 'help']);\n  });",
            "file": "help.sortOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when negated option then sort negated option separately",
            "suites": [
                "sortOptions"
            ],
            "updatePoint": {
                "line": 66,
                "column": 63
            },
            "line": 66,
            "code": "  test('when negated option then sort negated option separately', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ sortOptions: true })\n      .option('--bbb', 'desc')\n      .option('--ccc', 'desc')\n      .option('--no-bbb', 'desc')\n      .option('--aaa', 'desc');\n    const helper = program.createHelp();\n    const visibleOptionNames = helper.visibleOptions(program).map(cmd => cmd.name());\n    expect(visibleOptionNames).toEqual(['aaa', 'bbb', 'ccc', 'help', 'no-bbb']);\n  });",
            "file": "help.sortOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when cli of %s and commands %j then suggest %s because %s",
            "suites": [],
            "line": 29,
            "code": "test.each([\n  ['yyy', ['zzz'], null, 'none similar'],\n  ['a', ['b'], null, 'one edit away but not similar'],\n  ['a', ['ab'], 'ab', 'one edit away'],\n  ['ab', ['a'], null, 'one edit away'],\n  ['at', ['cat'], 'cat', '1 insertion'],\n  ['cat', ['at'], 'at', '1 deletion'],\n  ['bat', ['cat'], 'cat', '1 substitution'],\n  ['act', ['cat'], 'cat', '1 transposition'],\n  ['cxx', ['cat'], null, '2 edits away and short string'],\n  ['caxx', ['cart'], 'cart', '2 edits away and longer string'],\n  ['1234567', ['1234567890'], '1234567890', '3 edits away is similar for long string'],\n  ['123456', ['1234567890'], null, '4 edits is too far'],\n  ['xat', ['rat', 'cat', 'bat'], 'bat, cat, rat', 'sorted possibles'],\n  ['cart', ['camb', 'cant', 'bard'], 'cant', 'only closest of different edit distances']\n])('when cli of %s and commands %j then suggest %s because %s', (arg, commandNames, expected) => {\n  const program = new Command();\n  commandNames.forEach(name => { program.command(name); });\n  const suggestion = getSuggestion(program, arg);\n  expect(suggestion).toBe(expected);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when similar alias then suggest alias",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 43
            },
            "line": 51,
            "code": "test('when similar alias then suggest alias', () => {\n  const program = new Command();\n  program.command('xyz')\n    .alias('car');\n  const suggestion = getSuggestion(program, 'bar');\n  expect(suggestion).toBe('car');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when similar hidden alias then not suggested",
            "suites": [],
            "updatePoint": {
                "line": 59,
                "column": 50
            },
            "line": 59,
            "code": "test('when similar hidden alias then not suggested', () => {\n  const program = new Command();\n  program.command('xyz')\n    .alias('visible')\n    .alias('silent');\n  const suggestion = getSuggestion(program, 'slent');\n  expect(suggestion).toBe(null);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when similar command and alias then suggest both",
            "suites": [],
            "updatePoint": {
                "line": 68,
                "column": 54
            },
            "line": 68,
            "code": "test('when similar command and alias then suggest both', () => {\n  const program = new Command();\n  program.command('aaaaa')\n    .alias('cat');\n  program.command('bat');\n  program.command('ccccc');\n  const suggestion = getSuggestion(program, 'mat');\n  expect(suggestion).toBe('bat, cat');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when implicit help command then help is candidate for suggestion",
            "suites": [],
            "updatePoint": {
                "line": 78,
                "column": 70
            },
            "line": 78,
            "code": "test('when implicit help command then help is candidate for suggestion', () => {\n  const program = new Command();\n  program.command('sub');\n  const suggestion = getSuggestion(program, 'hepl');\n  expect(suggestion).toBe('help');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help command disabled then not candidate for suggestion",
            "suites": [],
            "updatePoint": {
                "line": 85,
                "column": 66
            },
            "line": 85,
            "code": "test('when help command disabled then not candidate for suggestion', () => {\n  const program = new Command();\n  program.addHelpCommand(false);\n  program.command('sub');\n  const suggestion = getSuggestion(program, 'hepl');\n  expect(suggestion).toBe(null);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default help option then --help is candidate for suggestion",
            "suites": [],
            "updatePoint": {
                "line": 93,
                "column": 70
            },
            "line": 93,
            "code": "test('when default help option then --help is candidate for suggestion', () => {\n  const program = new Command();\n  const suggestion = getSuggestion(program, '--hepl');\n  expect(suggestion).toBe('--help');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom help option then --custom-help is candidate for suggestion",
            "suites": [],
            "updatePoint": {
                "line": 99,
                "column": 76
            },
            "line": 99,
            "code": "test('when custom help option then --custom-help is candidate for suggestion', () => {\n  const program = new Command();\n  program.helpOption('-H, --custom-help');\n  const suggestion = getSuggestion(program, '--custom-hepl');\n  expect(suggestion).toBe('--custom-help');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help option disabled then not candidate for suggestion",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 65
            },
            "line": 106,
            "code": "test('when help option disabled then not candidate for suggestion', () => {\n  const program = new Command();\n  program.helpOption(false);\n  const suggestion = getSuggestion(program, '--hepl');\n  expect(suggestion).toBe(null);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command:* listener and unknown command then no suggestion",
            "suites": [],
            "updatePoint": {
                "line": 113,
                "column": 68
            },
            "line": 113,
            "code": "test('when command:* listener and unknown command then no suggestion', () => {\n  // Because one use for command:* was to handle unknown commands.\n  // Listener actually stops error being thrown, but we just care about affect on suggestion in this test.\n  const program = new Command();\n  program.on('command:*', () => {});\n  program.command('rat');\n  const suggestion = getSuggestion(program, 'cat');\n  expect(suggestion).toBe(null);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when cli of %s and options %j then suggest %s because %s",
            "suites": [],
            "line": 125,
            "code": "test.each([\n  ['--yyy', ['--zzz'], null, 'none similar'],\n  ['--a', ['--b'], null, 'one edit away but not similar'],\n  ['--a', ['--ab'], '--ab', 'one edit away'],\n  ['--ab', ['--a'], null, 'one edit away'],\n  ['--at', ['--cat'], '--cat', '1 insertion'],\n  ['--cat', ['--at'], '--at', '1 deletion'],\n  ['--bat', ['--cat'], '--cat', '1 substitution'],\n  ['--act', ['--cat'], '--cat', '1 transposition'],\n  ['--cxx', ['--cat'], null, '2 edits away and short string'],\n  ['--caxx', ['--cart'], '--cart', '2 edits away and longer string'],\n  ['--1234567', ['--1234567890'], '--1234567890', '3 edits away is similar for long string'],\n  ['--123456', ['--1234567890'], null, '4 edits is too far'],\n  ['--xat', ['--rat', '--cat', '--bat'], '--bat, --cat, --rat', 'sorted possibles'],\n  ['--cart', ['--camb', '--cant', '--bard'], '--cant', 'only closest of different edit distances']\n])('when cli of %s and options %j then suggest %s because %s', (arg, commandNames, expected) => {\n  const program = new Command();\n  commandNames.forEach(name => { program.option(name); });\n  const suggestion = getSuggestion(program, arg);\n  expect(suggestion).toBe(expected);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no options then no suggestion",
            "suites": [],
            "updatePoint": {
                "line": 147,
                "column": 40
            },
            "line": 147,
            "code": "test('when no options then no suggestion', () => {\n  // Checking nothing blows up as much as no suggestion!\n  const program = new Command();\n  program\n    .helpOption(false);\n  const suggestion = getSuggestion(program, '--option');\n  expect(suggestion).toBe(null);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when subcommand option then candidate for subcommand option suggestion",
            "suites": [],
            "updatePoint": {
                "line": 156,
                "column": 76
            },
            "line": 156,
            "code": "test('when subcommand option then candidate for subcommand option suggestion', () => {\n  const program = new Command();\n  program.command('sub')\n    .option('-l,--local');\n  const suggestion = getSuggestion(program, ['sub', '--loca']);\n  expect(suggestion).toBe('--local');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global option then candidate for subcommand option suggestion",
            "suites": [],
            "updatePoint": {
                "line": 164,
                "column": 72
            },
            "line": 164,
            "code": "test('when global option then candidate for subcommand option suggestion', () => {\n  const program = new Command();\n  program.option('-g, --global');\n  program.command('sub');\n  const suggestion = getSuggestion(program, ['sub', '--globla']);\n  expect(suggestion).toBe('--global');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global option but positionalOptions then not candidate for subcommand suggestion",
            "suites": [],
            "updatePoint": {
                "line": 172,
                "column": 91
            },
            "line": 172,
            "code": "test('when global option but positionalOptions then not candidate for subcommand suggestion', () => {\n  const program = new Command();\n  program\n    .enablePositionalOptions();\n  program.option('-g, --global');\n  program.command('sub');\n  const suggestion = getSuggestion(program, ['sub', '--globla']);\n  expect(suggestion).toBe(null);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when global and local options then both candidates",
            "suites": [],
            "updatePoint": {
                "line": 182,
                "column": 56
            },
            "line": 182,
            "code": "test('when global and local options then both candidates', () => {\n  const program = new Command();\n  program.option('--cat');\n  program.command('sub')\n    .option('--rat');\n  const suggestion = getSuggestion(program, ['sub', '--bat']);\n  expect(suggestion).toBe('--cat, --rat');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command hidden then not suggested as candidate",
            "suites": [],
            "updatePoint": {
                "line": 191,
                "column": 57
            },
            "line": 191,
            "code": "test('when command hidden then not suggested as candidate', () => {\n  const program = new Command();\n  program.command('secret', { hidden: true });\n  const suggestion = getSuggestion(program, 'secrt');\n  expect(suggestion).toBe(null);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option hidden then not suggested as candidate",
            "suites": [],
            "updatePoint": {
                "line": 198,
                "column": 56
            },
            "line": 198,
            "code": "test('when option hidden then not suggested as candidate', () => {\n  const program = new Command();\n  program.addOption(new Option('--secret').hideHelp());\n  const suggestion = getSuggestion(program, '--secrt');\n  expect(suggestion).toBe(null);\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when may be duplicate identical candidates then only return one",
            "suites": [],
            "updatePoint": {
                "line": 205,
                "column": 69
            },
            "line": 205,
            "code": "test('when may be duplicate identical candidates then only return one', () => {\n  const program = new Command();\n  program.command('sub');\n  const suggestion = getSuggestion(program, ['sub', '--hepl']);\n  expect(suggestion).toBe('--help');\n});",
            "file": "help.suggestion.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no arguments then empty array",
            "suites": [
                "visibleArguments"
            ],
            "updatePoint": {
                "line": 7,
                "column": 42
            },
            "line": 7,
            "code": "  test('when no arguments then empty array', () => {\n    const program = new commander.Command();\n    const helper = new commander.Help();\n    expect(helper.visibleArguments(program)).toEqual([]);\n  });",
            "file": "help.visibleArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument but no argument description then empty array",
            "suites": [
                "visibleArguments"
            ],
            "updatePoint": {
                "line": 13,
                "column": 66
            },
            "line": 13,
            "code": "  test('when argument but no argument description then empty array', () => {\n    const program = new commander.Command();\n    program.argument('<file>');\n    const helper = new commander.Help();\n    expect(helper.visibleArguments(program)).toEqual([]);\n  });",
            "file": "help.visibleArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument and argument description then returned",
            "suites": [
                "visibleArguments"
            ],
            "updatePoint": {
                "line": 20,
                "column": 60
            },
            "line": 20,
            "code": "  test('when argument and argument description then returned', () => {\n    const program = new commander.Command();\n    program.argument('<file>', 'file description');\n    const helper = new commander.Help();\n    const visibleArguments = helper.visibleArguments(program);\n    expect(visibleArguments.length).toEqual(1);\n    expect(visibleArguments[0]).toEqual(new commander.Argument('<file>', 'file description'));\n  });",
            "file": "help.visibleArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when argument and legacy argument description then returned",
            "suites": [
                "visibleArguments"
            ],
            "updatePoint": {
                "line": 29,
                "column": 67
            },
            "line": 29,
            "code": "  test('when argument and legacy argument description then returned', () => {\n    const program = new commander.Command();\n    program.argument('<file>');\n    program.description('', {\n      file: 'file description'\n    });\n    const helper = new commander.Help();\n    const visibleArguments = helper.visibleArguments(program);\n    expect(visibleArguments.length).toEqual(1);\n    expect(visibleArguments[0]).toEqual(new commander.Argument('<file>', 'file description'));\n  });",
            "file": "help.visibleArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when arguments and some described then all returned",
            "suites": [
                "visibleArguments"
            ],
            "updatePoint": {
                "line": 41,
                "column": 59
            },
            "line": 41,
            "code": "  test('when arguments and some described then all returned', () => {\n    const program = new commander.Command();\n    program.argument('<file1>', 'file1 description');\n    program.argument('<file2>');\n    const helper = new commander.Help();\n    const visibleArguments = helper.visibleArguments(program);\n    expect(visibleArguments.length).toEqual(2);\n    expect(visibleArguments[0]).toEqual(new commander.Argument('<file1>', 'file1 description'));\n    expect(visibleArguments[1]).toEqual(new commander.Argument('<file2>'));\n  });",
            "file": "help.visibleArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when arguments and some legacy described then all returned",
            "suites": [
                "visibleArguments"
            ],
            "updatePoint": {
                "line": 52,
                "column": 66
            },
            "line": 52,
            "code": "  test('when arguments and some legacy described then all returned', () => {\n    const program = new commander.Command();\n    program.argument('<file1>');\n    program.argument('<file2>');\n    program.description('', {\n      file1: 'file1 description'\n    });\n    const helper = new commander.Help();\n    const visibleArguments = helper.visibleArguments(program);\n    expect(visibleArguments.length).toEqual(2);\n    expect(visibleArguments[0]).toEqual(new commander.Argument('<file1>', 'file1 description'));\n    expect(visibleArguments[1]).toEqual(new commander.Argument('<file2>'));\n  });",
            "file": "help.visibleArguments.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no subcommands then empty array",
            "suites": [
                "visibleCommands"
            ],
            "updatePoint": {
                "line": 7,
                "column": 44
            },
            "line": 7,
            "code": "  test('when no subcommands then empty array', () => {\n    const program = new commander.Command();\n    const helper = new commander.Help();\n    expect(helper.visibleCommands(program)).toEqual([]);\n  });",
            "file": "help.visibleCommands.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add command then visible (with help)",
            "suites": [
                "visibleCommands"
            ],
            "updatePoint": {
                "line": 13,
                "column": 49
            },
            "line": 13,
            "code": "  test('when add command then visible (with help)', () => {\n    const program = new commander.Command();\n    program\n      .command('sub');\n    const helper = new commander.Help();\n    const visibleCommandNames = helper.visibleCommands(program).map(cmd => cmd.name());\n    expect(visibleCommandNames).toEqual(['sub', 'help']);\n  });",
            "file": "help.visibleCommands.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when commands hidden then not visible",
            "suites": [
                "visibleCommands"
            ],
            "updatePoint": {
                "line": 22,
                "column": 45
            },
            "line": 22,
            "code": "  test('when commands hidden then not visible', () => {\n    const program = new commander.Command();\n    program\n      .command('visible', 'desc')\n      .command('invisible-executable', 'desc', { hidden: true });\n    program\n      .command('invisible-action', { hidden: true });\n    const helper = new commander.Help();\n    const visibleCommandNames = helper.visibleCommands(program).map(cmd => cmd.name());\n    expect(visibleCommandNames).toEqual(['visible', 'help']);\n  });",
            "file": "help.visibleCommands.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no options then just help visible",
            "suites": [
                "visibleOptions"
            ],
            "updatePoint": {
                "line": 7,
                "column": 46
            },
            "line": 7,
            "code": "  test('when no options then just help visible', () => {\n    const program = new commander.Command();\n    const helper = new commander.Help();\n    const visibleOptionNames = helper.visibleOptions(program).map(option => option.name());\n    expect(visibleOptionNames).toEqual(['help']);\n  });",
            "file": "help.visibleOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no options and no help option then empty array",
            "suites": [
                "visibleOptions"
            ],
            "updatePoint": {
                "line": 14,
                "column": 59
            },
            "line": 14,
            "code": "  test('when no options and no help option then empty array', () => {\n    const program = new commander.Command();\n    program.helpOption(false);\n    const helper = new commander.Help();\n    expect(helper.visibleOptions(program)).toEqual([]);\n  });",
            "file": "help.visibleOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when add option then visible (with help)",
            "suites": [
                "visibleOptions"
            ],
            "updatePoint": {
                "line": 21,
                "column": 48
            },
            "line": 21,
            "code": "  test('when add option then visible (with help)', () => {\n    const program = new commander.Command();\n    program.option('-v,--visible');\n    const helper = new commander.Help();\n    const visibleOptionNames = helper.visibleOptions(program).map(option => option.name());\n    expect(visibleOptionNames).toEqual(['visible', 'help']);\n  });",
            "file": "help.visibleOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option hidden then not visible",
            "suites": [
                "visibleOptions"
            ],
            "updatePoint": {
                "line": 29,
                "column": 43
            },
            "line": 29,
            "code": "  test('when option hidden then not visible', () => {\n    const program = new commander.Command();\n    program\n      .option('-v,--visible')\n      .addOption(new commander.Option('--invisible').hideHelp());\n    const helper = new commander.Help();\n    const visibleOptionNames = helper.visibleOptions(program).map(option => option.name());\n    expect(visibleOptionNames).toEqual(['visible', 'help']);\n  });",
            "file": "help.visibleOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default then help term is -h, --help",
            "suites": [
                "implicit help"
            ],
            "updatePoint": {
                "line": 41,
                "column": 49
            },
            "line": 41,
            "code": "  test('when default then help term is -h, --help', () => {\n    const program = new commander.Command();\n    const helper = new commander.Help();\n    const implicitHelp = helper.visibleOptions(program)[0];\n    expect(helper.optionTerm(implicitHelp)).toEqual('-h, --help');\n  });",
            "file": "help.visibleOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when short flag obscured then help term is --help",
            "suites": [
                "implicit help"
            ],
            "updatePoint": {
                "line": 48,
                "column": 57
            },
            "line": 48,
            "code": "  test('when short flag obscured then help term is --help', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option('-h, --huge').hideHelp());\n    const helper = new commander.Help();\n    const implicitHelp = helper.visibleOptions(program)[0];\n    expect(helper.optionTerm(implicitHelp)).toEqual('--help');\n  });",
            "file": "help.visibleOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long flag obscured then help term is --h",
            "suites": [
                "implicit help"
            ],
            "updatePoint": {
                "line": 56,
                "column": 53
            },
            "line": 56,
            "code": "  test('when long flag obscured then help term is --h', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option('-H, --help').hideHelp());\n    const helper = new commander.Help();\n    const implicitHelp = helper.visibleOptions(program)[0];\n    expect(helper.optionTerm(implicitHelp)).toEqual('-h');\n  });",
            "file": "help.visibleOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when help flags obscured then implicit help hidden",
            "suites": [
                "implicit help"
            ],
            "updatePoint": {
                "line": 64,
                "column": 58
            },
            "line": 64,
            "code": "  test('when help flags obscured then implicit help hidden', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option('-h, --help').hideHelp());\n    const helper = new commander.Help();\n    expect(helper.visibleOptions(program)).toEqual([]);\n  });",
            "file": "help.visibleOptions.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when string fits into width then returns input",
            "suites": [
                "wrap"
            ],
            "updatePoint": {
                "line": 7,
                "column": 54
            },
            "line": 7,
            "code": "  test('when string fits into width then returns input', () => {\n    const text = 'a '.repeat(24) + 'a';\n    const helper = new commander.Help();\n    const wrapped = helper.wrap(text, 50, 3);\n    expect(wrapped).toEqual(text);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when string shorter than indent then returns input",
            "suites": [
                "wrap"
            ],
            "updatePoint": {
                "line": 14,
                "column": 58
            },
            "line": 14,
            "code": "  test('when string shorter than indent then returns input', () => {\n    const text = 'a';\n    const helper = new commander.Help();\n    const wrapped = helper.wrap(text, 50, 3);\n    expect(wrapped).toEqual(text);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when string exceeds width then wrap",
            "suites": [
                "wrap"
            ],
            "updatePoint": {
                "line": 21,
                "column": 43
            },
            "line": 21,
            "code": "  test('when string exceeds width then wrap', () => {\n    const text = 'a '.repeat(30) + 'a';\n    const helper = new commander.Help();\n    const wrapped = helper.wrap(text, 50, 0);\n    expect(wrapped).toEqual(`${'a '.repeat(24)}a\n${'a '.repeat(5)}a`);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when string exceeds width then wrap and indent",
            "suites": [
                "wrap"
            ],
            "updatePoint": {
                "line": 29,
                "column": 54
            },
            "line": 29,
            "code": "  test('when string exceeds width then wrap and indent', () => {\n    const text = 'a '.repeat(30) + 'a';\n    const helper = new commander.Help();\n    const wrapped = helper.wrap(text, 50, 10);\n    expect(wrapped).toEqual(`${'a '.repeat(24)}a\n${' '.repeat(10)}${'a '.repeat(5)}a`);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when width < 40 then do not wrap",
            "suites": [
                "wrap"
            ],
            "updatePoint": {
                "line": 37,
                "column": 40
            },
            "line": 37,
            "code": "  test('when width < 40 then do not wrap', () => {\n    const text = 'a '.repeat(30) + 'a';\n    const helper = new commander.Help();\n    const wrapped = helper.wrap(text, 39, 0);\n    expect(wrapped).toEqual(text);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when text has line breaks then respect and indent",
            "suites": [
                "wrap"
            ],
            "updatePoint": {
                "line": 44,
                "column": 57
            },
            "line": 44,
            "code": "  test('when text has line breaks then respect and indent', () => {\n    const text = 'term description\\nanother line';\n    const helper = new commander.Help();\n    const wrapped = helper.wrap(text, 78, 5);\n    expect(wrapped).toEqual('term description\\n     another line');\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when text already formatted with line breaks and indent then do not touch",
            "suites": [
                "wrap"
            ],
            "updatePoint": {
                "line": 51,
                "column": 81
            },
            "line": 51,
            "code": "  test('when text already formatted with line breaks and indent then do not touch', () => {\n    const text = 'term a '.repeat(25) + '\\n   ' + 'a '.repeat(25) + 'a';\n    const helper = new commander.Help();\n    const wrapped = helper.wrap(text, 78, 5);\n    expect(wrapped).toEqual(text);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long option description then wrap and indent",
            "suites": [
                "wrapping by formatHelp"
            ],
            "updatePoint": {
                "line": 63,
                "column": 57
            },
            "line": 63,
            "code": "  test('when long option description then wrap and indent', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ helpWidth: 80 })\n      .option('-x --extra-long-option-switch', 'kjsahdkajshkahd kajhsd akhds kashd kajhs dkha dkh aksd ka dkha kdh kasd ka kahs dkh sdkh askdh aksd kashdk ahsd kahs dkha skdh');\n\n    const expectedOutput =\n`Usage:  [options]\n\nOptions:\n  -x --extra-long-option-switch  kjsahdkajshkahd kajhsd akhds kashd kajhs dkha\n                                 dkh aksd ka dkha kdh kasd ka kahs dkh sdkh\n                                 askdh aksd kashdk ahsd kahs dkha skdh\n  -h, --help                     display help for command\n`;\n\n    expect(program.helpInformation()).toBe(expectedOutput);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long option description and default then wrap and indent",
            "suites": [
                "wrapping by formatHelp"
            ],
            "updatePoint": {
                "line": 82,
                "column": 69
            },
            "line": 82,
            "code": "  test('when long option description and default then wrap and indent', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ helpWidth: 80 })\n      .option('-x --extra-long-option <value>', 'kjsahdkajshkahd kajhsd akhds', 'aaa bbb ccc ddd eee fff ggg');\n\n    const expectedOutput =\n`Usage:  [options]\n\nOptions:\n  -x --extra-long-option <value>  kjsahdkajshkahd kajhsd akhds (default: \"aaa\n                                  bbb ccc ddd eee fff ggg\")\n  -h, --help                      display help for command\n`;\n\n    expect(program.helpInformation()).toBe(expectedOutput);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long command description then wrap and indent",
            "suites": [
                "wrapping by formatHelp"
            ],
            "updatePoint": {
                "line": 100,
                "column": 58
            },
            "line": 100,
            "code": "  test('when long command description then wrap and indent', () => {\n    const program = new commander.Command();\n    program\n      .configureHelp({ helpWidth: 80 })\n      .option('-x --extra-long-option-switch', 'x')\n      .command('alpha', 'Lorem mollit quis dolor ex do eu quis ad insa a commodo esse.');\n\n    const expectedOutput =\n`Usage:  [options] [command]\n\nOptions:\n  -x --extra-long-option-switch  x\n  -h, --help                     display help for command\n\nCommands:\n  alpha                          Lorem mollit quis dolor ex do eu quis ad insa\n                                 a commodo esse.\n  help [command]                 display help for command\n`;\n\n    expect(program.helpInformation()).toBe(expectedOutput);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when not enough room then help not wrapped",
            "suites": [
                "wrapping by formatHelp"
            ],
            "updatePoint": {
                "line": 123,
                "column": 50
            },
            "line": 123,
            "code": "  test('when not enough room then help not wrapped', () => {\n    // Not wrapping if less than 40 columns available for wrapping.\n    const program = new commander.Command();\n    const commandDescription = 'description text of very long command which should not be automatically be wrapped. Do fugiat eiusmod ipsum laboris excepteur pariatur sint ullamco tempor labore eu.';\n    program\n      .configureHelp({ helpWidth: 60 })\n      .command('1234567801234567890x', commandDescription);\n\n    const expectedOutput =\n`Usage:  [options] [command]\n\nOptions:\n  -h, --help            display help for command\n\nCommands:\n  1234567801234567890x  ${commandDescription}\n  help [command]        display help for command\n`;\n\n    expect(program.helpInformation()).toBe(expectedOutput);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option descripton preformatted then only add small indent",
            "suites": [
                "wrapping by formatHelp"
            ],
            "updatePoint": {
                "line": 145,
                "column": 70
            },
            "line": 145,
            "code": "  test('when option descripton preformatted then only add small indent', () => {\n    // #396: leave custom format alone, apart from space-space indent\n    const optionSpec = '-t, --time <HH:MM>';\n    const program = new commander.Command();\n    program\n      .configureHelp({ helpWidth: 80 })\n      .option(optionSpec, `select time\n\nTime can also be specified using special values:\n  \"dawn\" - From night to sunrise.\n`);\n\n    const expectedOutput =\n`Usage:  [options]\n\nOptions:\n  ${optionSpec}  select time\n  \n  Time can also be specified using special values:\n    \"dawn\" - From night to sunrise.\n  \n  -h, --help          display help for command\n`;\n\n    expect(program.helpInformation()).toBe(expectedOutput);\n  });",
            "file": "help.wrap.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 40,
                "column": 37
            },
            "line": 40,
            "code": "  test('when --inspect then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect=127.0.0.1:9230']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect=100 then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 48,
                "column": 41
            },
            "line": 48,
            "code": "  test('when --inspect=100 then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect=100'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect=127.0.0.1:101']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect=1.2.3.4:100 then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 56,
                "column": 49
            },
            "line": 56,
            "code": "  test('when --inspect=1.2.3.4:100 then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect=1.2.3.4:100'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect=1.2.3.4:101']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect=1.2.3.4 then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 64,
                "column": 45
            },
            "line": 64,
            "code": "  test('when --inspect=1.2.3.4 then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect=1.2.3.4'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect=1.2.3.4:9230']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect-brk then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 72,
                "column": 41
            },
            "line": 72,
            "code": "  test('when --inspect-brk then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect-brk'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect-brk=127.0.0.1:9230']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect-brk=100 then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 80,
                "column": 45
            },
            "line": 80,
            "code": "  test('when --inspect-brk=100 then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect-brk=100'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect-brk=127.0.0.1:101']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect-brk=1.2.3.4 then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 88,
                "column": 49
            },
            "line": 88,
            "code": "  test('when --inspect-brk=1.2.3.4 then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect-brk=1.2.3.4'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect-brk=1.2.3.4:9230']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect-brk=1.2.3.4:100 then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 96,
                "column": 53
            },
            "line": 96,
            "code": "  test('when --inspect-brk=1.2.3.4:100 then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect-brk=1.2.3.4:100'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect-brk=1.2.3.4:101']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect-port=100 then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 104,
                "column": 46
            },
            "line": 104,
            "code": "  test('when --inspect-port=100 then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect-port=100'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect-port=127.0.0.1:101']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect-port=1.2.3.4:100 then bump port",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 112,
                "column": 54
            },
            "line": 112,
            "code": "  test('when --inspect-port=1.2.3.4:100 then bump port', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect-port=1.2.3.4:100'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect-port=1.2.3.4:101']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --inspect-unexpected then unchanged",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 120,
                "column": 48
            },
            "line": 120,
            "code": "  test('when --inspect-unexpected then unchanged', () => {\n    const program = makeProgram();\n    process.execArgv = ['--inspect-unexpected'];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--inspect-unexpected']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when --frozen-intrinsics  then unchanged",
            "suites": [
                "incrementNodeInspectorPort"
            ],
            "updatePoint": {
                "line": 128,
                "column": 48
            },
            "line": 128,
            "code": "  test('when --frozen-intrinsics  then unchanged', () => {\n    const program = makeProgram();\n    process.execArgv = ['--frozen-intrinsics '];\n    program.parse(['node', 'test', 'cache']);\n    const execArgs = extractMockExecArgs(spawnSpy);\n    expect(execArgs).toEqual(['--frozen-intrinsics ']);\n  });",
            "file": "incrementNodeInspectorPort.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .default() then returns this",
            "suites": [
                "Option methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 4,
                "column": 46
            },
            "line": 4,
            "code": "  test('when call .default() then returns this', () => {\n    const option = new Option('-e,--example <value>');\n    const result = option.default(3);\n    expect(result).toBe(option);\n  });",
            "file": "option.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .argParser() then returns this",
            "suites": [
                "Option methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 10,
                "column": 48
            },
            "line": 10,
            "code": "  test('when call .argParser() then returns this', () => {\n    const option = new Option('-e,--example <value>');\n    const result = option.argParser(() => { });\n    expect(result).toBe(option);\n  });",
            "file": "option.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .makeOptionMandatory() then returns this",
            "suites": [
                "Option methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 16,
                "column": 58
            },
            "line": 16,
            "code": "  test('when call .makeOptionMandatory() then returns this', () => {\n    const option = new Option('-e,--example <value>');\n    const result = option.makeOptionMandatory();\n    expect(result).toBe(option);\n  });",
            "file": "option.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .hideHelp() then returns this",
            "suites": [
                "Option methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 22,
                "column": 47
            },
            "line": 22,
            "code": "  test('when call .hideHelp() then returns this', () => {\n    const option = new Option('-e,--example <value>');\n    const result = option.hideHelp();\n    expect(result).toBe(option);\n  });",
            "file": "option.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .choices() then returns this",
            "suites": [
                "Option methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 28,
                "column": 46
            },
            "line": 28,
            "code": "  test('when call .choices() then returns this', () => {\n    const option = new Option('-e,--example <value>');\n    const result = option.choices(['a']);\n    expect(result).toBe(option);\n  });",
            "file": "option.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when call .env() then returns this",
            "suites": [
                "Option methods that should return this for chaining"
            ],
            "updatePoint": {
                "line": 34,
                "column": 42
            },
            "line": 34,
            "code": "  test('when call .env() then returns this', () => {\n    const option = new Option('-e,--example <value>');\n    const result = option.env('e');\n    expect(result).toBe(option);\n  });",
            "file": "option.chain.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo not specified then value is undefined",
            "suites": [
                "boolean option combo with no default"
            ],
            "updatePoint": {
                "line": 16,
                "column": 64
            },
            "line": 16,
            "code": "  test('when boolean combo not specified then value is undefined', () => {\n    const program = createPepperProgram();\n    program.parse(['node', 'test']);\n    expect(program.opts().pepper).toBeUndefined();\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo positive then value is true",
            "suites": [
                "boolean option combo with no default"
            ],
            "updatePoint": {
                "line": 22,
                "column": 54
            },
            "line": 22,
            "code": "  test('when boolean combo positive then value is true', () => {\n    const program = createPepperProgram();\n    program.parse(['node', 'test', '--pepper']);\n    expect(program.opts().pepper).toBe(true);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo negative then value is false",
            "suites": [
                "boolean option combo with no default"
            ],
            "updatePoint": {
                "line": 28,
                "column": 55
            },
            "line": 28,
            "code": "  test('when boolean combo negative then value is false', () => {\n    const program = createPepperProgram();\n    program.parse(['node', 'test', '--no-pepper']);\n    expect(program.opts().pepper).toBe(false);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo last is positive then value is true",
            "suites": [
                "boolean option combo with no default"
            ],
            "updatePoint": {
                "line": 34,
                "column": 62
            },
            "line": 34,
            "code": "  test('when boolean combo last is positive then value is true', () => {\n    const program = createPepperProgram();\n    program.parse(['node', 'test', '--no-pepper', '--pepper']);\n    expect(program.opts().pepper).toBe(true);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo last is negative then value is false",
            "suites": [
                "boolean option combo with no default"
            ],
            "updatePoint": {
                "line": 40,
                "column": 63
            },
            "line": 40,
            "code": "  test('when boolean combo last is negative then value is false', () => {\n    const program = createPepperProgram();\n    program.parse(['node', 'test', '--pepper', '--no-pepper']);\n    expect(program.opts().pepper).toBe(false);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo not specified then value is true",
            "suites": [
                "boolean option combo, default true, long flags"
            ],
            "updatePoint": {
                "line": 59,
                "column": 59
            },
            "line": 59,
            "code": "  test('when boolean combo not specified then value is true', () => {\n    const program = createPepperProgramWithDefault(true);\n    program.parse(['node', 'test']);\n    expect(program.opts().pepper).toBe(true);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo positive then value is true",
            "suites": [
                "boolean option combo, default true, long flags"
            ],
            "updatePoint": {
                "line": 65,
                "column": 54
            },
            "line": 65,
            "code": "  test('when boolean combo positive then value is true', () => {\n    const program = createPepperProgramWithDefault(true);\n    program.parse(['node', 'test', '--pepper']);\n    expect(program.opts().pepper).toBe(true);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo negative then value is false",
            "suites": [
                "boolean option combo, default true, long flags"
            ],
            "updatePoint": {
                "line": 71,
                "column": 55
            },
            "line": 71,
            "code": "  test('when boolean combo negative then value is false', () => {\n    const program = createPepperProgramWithDefault(true);\n    program.parse(['node', 'test', '--no-pepper']);\n    expect(program.opts().pepper).toBe(false);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo not specified then value is false",
            "suites": [
                "boolean option combo, default false, short flags"
            ],
            "updatePoint": {
                "line": 80,
                "column": 60
            },
            "line": 80,
            "code": "  test('when boolean combo not specified then value is false', () => {\n    const program = createPepperProgramWithDefault(false);\n    program.parse(['node', 'test']);\n    expect(program.opts().pepper).toBe(false);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo positive then value is true",
            "suites": [
                "boolean option combo, default false, short flags"
            ],
            "updatePoint": {
                "line": 86,
                "column": 54
            },
            "line": 86,
            "code": "  test('when boolean combo positive then value is true', () => {\n    const program = createPepperProgramWithDefault(false);\n    program.parse(['node', 'test', '-p']);\n    expect(program.opts().pepper).toBe(true);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo negative then value is false",
            "suites": [
                "boolean option combo, default false, short flags"
            ],
            "updatePoint": {
                "line": 92,
                "column": 55
            },
            "line": 92,
            "code": "  test('when boolean combo negative then value is false', () => {\n    const program = createPepperProgramWithDefault(false);\n    program.parse(['node', 'test', '-P']);\n    expect(program.opts().pepper).toBe(false);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo not specified then value is undefined",
            "suites": [
                "boolean option combo with non-boolean default"
            ],
            "updatePoint": {
                "line": 104,
                "column": 64
            },
            "line": 104,
            "code": "  test('when boolean combo not specified then value is undefined', () => {\n    const flagValue = 'red';\n    const program = createPepperProgramWithDefault(flagValue);\n    program.parse(['node', 'test']);\n    expect(program.opts().pepper).toBeUndefined();\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo positive then value is \"default\" value",
            "suites": [
                "boolean option combo with non-boolean default"
            ],
            "updatePoint": {
                "line": 111,
                "column": 65
            },
            "line": 111,
            "code": "  test('when boolean combo positive then value is \"default\" value', () => {\n    const flagValue = 'red';\n    const program = createPepperProgramWithDefault(flagValue);\n    program.parse(['node', 'test', '--pepper']);\n    expect(program.opts().pepper).toBe(flagValue);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean combo negative then value is false",
            "suites": [
                "boolean option combo with non-boolean default"
            ],
            "updatePoint": {
                "line": 118,
                "column": 55
            },
            "line": 118,
            "code": "  test('when boolean combo negative then value is false', () => {\n    const flagValue = 'red';\n    const program = createPepperProgramWithDefault(flagValue);\n    program.parse(['node', 'test', '--no-pepper']);\n    expect(program.opts().pepper).toBe(false);\n  });",
            "file": "options.bool.combo.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when when multiple short flags specified then all values are true",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 71
            },
            "line": 3,
            "code": "test('when when multiple short flags specified then all values are true', () => {\n  const program = new commander.Command();\n  program\n    .option('-p, --pepper', 'add pepper')\n    .option('-c, --cheese', 'add cheese');\n\n  program.parse(['node', 'test', '-pc']);\n\n  expect(program.opts().pepper).toBe(true);\n  expect(program.opts().cheese).toBe(true);\n});",
            "file": "options.bool.small.combined.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean flag not specified then value is undefined",
            "suites": [
                "boolean flag on program"
            ],
            "updatePoint": {
                "line": 7,
                "column": 63
            },
            "line": 7,
            "code": "  test('when boolean flag not specified then value is undefined', () => {\n    const program = new commander.Command();\n    program\n      .option('--pepper', 'add pepper');\n    program.parse(['node', 'test']);\n    expect(program.opts().pepper).toBeUndefined();\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean flag specified then value is true",
            "suites": [
                "boolean flag on program"
            ],
            "updatePoint": {
                "line": 15,
                "column": 54
            },
            "line": 15,
            "code": "  test('when boolean flag specified then value is true', () => {\n    const program = new commander.Command();\n    program\n      .option('--pepper', 'add pepper');\n    program.parse(['node', 'test', '--pepper']);\n    expect(program.opts().pepper).toBe(true);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when negatable boolean flag not specified then value is true",
            "suites": [
                "boolean flag on program"
            ],
            "updatePoint": {
                "line": 23,
                "column": 68
            },
            "line": 23,
            "code": "  test('when negatable boolean flag not specified then value is true', () => {\n    const program = new commander.Command();\n    program\n      .option('--no-cheese', 'remove cheese');\n    program.parse(['node', 'test']);\n    expect(program.opts().cheese).toBe(true);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when negatable boolean flag specified then value is false",
            "suites": [
                "boolean flag on program"
            ],
            "updatePoint": {
                "line": 31,
                "column": 65
            },
            "line": 31,
            "code": "  test('when negatable boolean flag specified then value is false', () => {\n    const program = new commander.Command();\n    program\n      .option('--no-cheese', 'remove cheese');\n    program.parse(['node', 'test', '--no-cheese']);\n    expect(program.opts().cheese).toBe(false);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean flag not specified then value is undefined",
            "suites": [
                "boolean flag on command"
            ],
            "updatePoint": {
                "line": 42,
                "column": 63
            },
            "line": 42,
            "code": "  test('when boolean flag not specified then value is undefined', () => {\n    let subCommandOptions;\n    const program = new commander.Command();\n    program\n      .command('sub')\n      .option('--pepper', 'add pepper')\n      .action((options) => { subCommandOptions = options; });\n    program.parse(['node', 'test', 'sub']);\n    expect(subCommandOptions.pepper).toBeUndefined();\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean flag specified then value is true",
            "suites": [
                "boolean flag on command"
            ],
            "updatePoint": {
                "line": 53,
                "column": 54
            },
            "line": 53,
            "code": "  test('when boolean flag specified then value is true', () => {\n    let subCommandOptions;\n    const program = new commander.Command();\n    program\n      .command('sub')\n      .option('--pepper', 'add pepper')\n      .action((options) => { subCommandOptions = options; });\n    program.parse(['node', 'test', 'sub', '--pepper']);\n    expect(subCommandOptions.pepper).toBe(true);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when negatable boolean flag not specified then value is true",
            "suites": [
                "boolean flag on command"
            ],
            "updatePoint": {
                "line": 64,
                "column": 68
            },
            "line": 64,
            "code": "  test('when negatable boolean flag not specified then value is true', () => {\n    let subCommandOptions;\n    const program = new commander.Command();\n    program\n      .command('sub')\n      .option('--no-cheese', 'remove cheese')\n      .action((options) => { subCommandOptions = options; });\n    program.parse(['node', 'test', 'sub']);\n    expect(subCommandOptions.cheese).toBe(true);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when negatable boolean flag specified then value is false",
            "suites": [
                "boolean flag on command"
            ],
            "updatePoint": {
                "line": 75,
                "column": 65
            },
            "line": 75,
            "code": "  test('when negatable boolean flag specified then value is false', () => {\n    let subCommandOptions;\n    const program = new commander.Command();\n    program\n      .command('sub')\n      .option('--no-cheese', 'remove cheese')\n      .action((options) => { subCommandOptions = options; });\n    program.parse(['node', 'test', 'sub', '--no-cheese']);\n    expect(subCommandOptions.cheese).toBe(false);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when flag not specified then value is undefined",
            "suites": [
                "boolean flag with non-boolean default"
            ],
            "updatePoint": {
                "line": 92,
                "column": 55
            },
            "line": 92,
            "code": "  test('when flag not specified then value is undefined', () => {\n    const flagValue = 'black';\n    const program = new commander.Command();\n    program\n      .option('--olives', 'Add olives? Sorry we only have black.', flagValue);\n    program.parse(['node', 'test']);\n    expect(program.opts().olives).toBeUndefined();\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when flag specified then value is \"default\" value",
            "suites": [
                "boolean flag with non-boolean default"
            ],
            "updatePoint": {
                "line": 101,
                "column": 57
            },
            "line": 101,
            "code": "  test('when flag specified then value is \"default\" value', () => {\n    const flagValue = 'black';\n    const program = new commander.Command();\n    program\n      .option('-v, --olives', 'Add olives? Sorry we only have black.', flagValue);\n    program.parse(['node', 'test', '--olives']);\n    expect(program.opts().olives).toBe(flagValue);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when flag implied and negated then value is false",
            "suites": [
                "boolean flag with non-boolean default"
            ],
            "updatePoint": {
                "line": 110,
                "column": 57
            },
            "line": 110,
            "code": "  test('when flag implied and negated then value is false', () => {\n    const flagValue = 'black';\n    const program = new commander.Command();\n    program\n      .option('-v, --olives', 'Add olives? Sorry we only have black.', flagValue)\n      .option('--no-olives');\n    program.parse(['node', 'test', '--olives', '--no-olives']);\n    expect(program.opts().olives).toBe(false);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when flag not specified then value is undefined",
            "suites": [
                "regression test for -no- in middle of option flag"
            ],
            "updatePoint": {
                "line": 123,
                "column": 55
            },
            "line": 123,
            "code": "  test('when flag not specified then value is undefined', () => {\n    const program = new commander.Command();\n    program\n      .option('--module-no-parse');\n    program.parse(['node', 'test']);\n    expect(program.opts().moduleNoParse).toBeUndefined();\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when flag specified then value is true",
            "suites": [
                "regression test for -no- in middle of option flag"
            ],
            "updatePoint": {
                "line": 131,
                "column": 46
            },
            "line": 131,
            "code": "  test('when flag specified then value is true', () => {\n    const program = new commander.Command();\n    program\n      .option('--module-no-parse');\n    program.parse(['node', 'test', '--module-no-parse']);\n    expect(program.opts().moduleNoParse).toEqual(true);\n  });",
            "file": "options.bool.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option defined with --word-word then option property is wordWord",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 75
            },
            "line": 5,
            "code": "test('when option defined with --word-word then option property is wordWord', () => {\n  const program = new commander.Command();\n  program\n    .option('--my-option', 'description');\n  program.parse(['node', 'test', '--my-option']);\n  expect(program.opts().myOption).toBe(true);\n});",
            "file": "options.camelcase.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option defined with --word-wORD then option property is wordWORD",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 75
            },
            "line": 13,
            "code": "test('when option defined with --word-wORD then option property is wordWORD', () => {\n  const program = new commander.Command();\n  program\n    .option('--my-oPTION', 'description');\n  program.parse(['node', 'test', '--my-oPTION']);\n  expect(program.opts().myOPTION).toBe(true);\n});",
            "file": "options.camelcase.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option defined with --word-WORD then option property is wordWORD",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 75
            },
            "line": 21,
            "code": "test('when option defined with --word-WORD then option property is wordWORD', () => {\n  const program = new commander.Command();\n  program\n    .option('--my-OPTION', 'description');\n  program.parse(['node', 'test', '--my-OPTION']);\n  expect(program.opts().myOPTION).toBe(true);\n});",
            "file": "options.camelcase.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option defined with --word-word-word then option property is wordWordWord",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 84
            },
            "line": 29,
            "code": "test('when option defined with --word-word-word then option property is wordWordWord', () => {\n  const program = new commander.Command();\n  program\n    .option('--my-special-option', 'description');\n  program.parse(['node', 'test', '--my-special-option']);\n  expect(program.opts().mySpecialOption).toBe(true);\n});",
            "file": "options.camelcase.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option defined with --word-WORD-word then option property is wordWORDWord",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 84
            },
            "line": 37,
            "code": "test('when option defined with --word-WORD-word then option property is wordWORDWord', () => {\n  const program = new commander.Command();\n  program\n    .option('--my-SPECIAL-option', 'description');\n  program.parse(['node', 'test', '--my-SPECIAL-option']);\n  expect(program.opts().mySPECIALOption).toBe(true);\n});",
            "file": "options.camelcase.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option defined with --Word then option property is Word",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 66
            },
            "line": 45,
            "code": "test('when option defined with --Word then option property is Word', () => {\n  const program = new commander.Command();\n  program\n    .option('--Myoption', 'description');\n  program.parse(['node', 'test', '--Myoption']);\n  expect(program.opts().Myoption).toBe(true);\n});",
            "file": "options.camelcase.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option not specified then callback not called",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 56
            },
            "line": 20,
            "code": "test('when option not specified then callback not called', () => {\n  const mockCoercion = jest.fn();\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <n>', 'number', mockCoercion);\n  program.parse(['node', 'test']);\n  expect(mockCoercion).not.toHaveBeenCalled();\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option not specified then value is undefined",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 55
            },
            "line": 29,
            "code": "test('when option not specified then value is undefined', () => {\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <n>', 'number', myParseInt);\n  program.parse(['node', 'test']);\n  expect(program.opts().integer).toBeUndefined();\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when starting value is defined and option not specified then callback not called",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 86
            },
            "line": 37,
            "code": "test('when starting value is defined and option not specified then callback not called', () => {\n  const mockCoercion = jest.fn();\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <n>', 'number', mockCoercion, 1);\n  program.parse(['node', 'test']);\n  expect(mockCoercion).not.toHaveBeenCalled();\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when starting value is defined and option not specified then value is starting value",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 90
            },
            "line": 46,
            "code": "test('when starting value is defined and option not specified then value is starting value', () => {\n  // NB: Can not specify a starting value for a boolean flag! Discovered when writing this test...\n  const startingValue = 1;\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <n>', 'number', myParseInt, startingValue);\n  program.parse(['node', 'test']);\n  expect(program.opts().integer).toBe(startingValue);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified then callback called with value",
            "suites": [],
            "updatePoint": {
                "line": 56,
                "column": 59
            },
            "line": 56,
            "code": "test('when option specified then callback called with value', () => {\n  const mockCoercion = jest.fn();\n  const value = '1';\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <n>', 'number', mockCoercion);\n  program.parse(['node', 'test', '-i', value]);\n  expect(mockCoercion).toHaveBeenCalledWith(value, undefined);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified then value is as returned from callback",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 67
            },
            "line": 66,
            "code": "test('when option specified then value is as returned from callback', () => {\n  const callbackResult = 2;\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <n>', 'number', () => {\n      return callbackResult;\n    });\n  program.parse(['node', 'test', '-i', '0']);\n  expect(program.opts().integer).toBe(callbackResult);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when starting value is defined and option specified then callback called with value and starting value",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 108
            },
            "line": 77,
            "code": "test('when starting value is defined and option specified then callback called with value and starting value', () => {\n  const mockCoercion = jest.fn();\n  const startingValue = 1;\n  const value = '2';\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <n>', 'number', mockCoercion, startingValue);\n  program.parse(['node', 'test', '-i', value]);\n  expect(mockCoercion).toHaveBeenCalledWith(value, startingValue);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified multiple times then callback called with value and previousValue",
            "suites": [],
            "updatePoint": {
                "line": 88,
                "column": 92
            },
            "line": 88,
            "code": "test('when option specified multiple times then callback called with value and previousValue', () => {\n  const mockCoercion = jest.fn().mockImplementation(() => {\n    return 'callback';\n  });\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <n>', 'number', mockCoercion);\n  program.parse(['node', 'test', '-i', '1', '-i', '2']);\n  expect(mockCoercion).toHaveBeenCalledTimes(2);\n  expect(mockCoercion).toHaveBeenNthCalledWith(1, '1', undefined);\n  expect(mockCoercion).toHaveBeenNthCalledWith(2, '2', 'callback');\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option argument in choices then option set",
            "suites": [],
            "updatePoint": {
                "line": 102,
                "column": 53
            },
            "line": 102,
            "code": "test('when option argument in choices then option set', () => {\n  const program = new commander.Command();\n  program\n    .exitOverride()\n    .addOption(new commander.Option('--colour <shade>').choices(['red', 'blue']));\n  program.parse(['--colour', 'red'], { from: 'user' });\n  expect(program.opts().colour).toBe('red');\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when parseFloat \"1e2\" then value is 100",
            "suites": [],
            "updatePoint": {
                "line": 113,
                "column": 45
            },
            "line": 113,
            "code": "test('when parseFloat \"1e2\" then value is 100', () => {\n  const program = new commander.Command();\n  program\n    .option('-f, --float <number>', 'float argument', parseFloat);\n  program.parse(['node', 'test', '-f', '1e2']);\n  expect(program.opts().float).toBe(100);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when myParseInt \"1\" then value is 1",
            "suites": [],
            "updatePoint": {
                "line": 121,
                "column": 41
            },
            "line": 121,
            "code": "test('when myParseInt \"1\" then value is 1', () => {\n  const program = new commander.Command();\n  program\n    .option('-i, --integer <number>', 'integer argument', myParseInt);\n  program.parse(['node', 'test', '-i', '1']);\n  expect(program.opts().integer).toBe(1);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when increaseVerbosity -v -v -v then value is 3",
            "suites": [],
            "updatePoint": {
                "line": 129,
                "column": 53
            },
            "line": 129,
            "code": "test('when increaseVerbosity -v -v -v then value is 3', () => {\n  const program = new commander.Command();\n  program\n    .option('-v, --verbose', 'verbosity that can be increased', increaseVerbosity, 0);\n  program.parse(['node', 'test', '-v', '-v', '-v']);\n  expect(program.opts().verbose).toBe(3);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when collect -c a -c b -c c then value is [a, b, c]",
            "suites": [],
            "updatePoint": {
                "line": 137,
                "column": 57
            },
            "line": 137,
            "code": "test('when collect -c a -c b -c c then value is [a, b, c]', () => {\n  const program = new commander.Command();\n  program\n    .option('-c, --collect <value>', 'repeatable value', collect, []);\n  program.parse(['node', 'test', '-c', 'a', '-c', 'b', '-c', 'c']);\n  expect(program.opts().collect).toEqual(['a', 'b', 'c']);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when commaSeparatedList x,y,z then value is [x, y, z]",
            "suites": [],
            "updatePoint": {
                "line": 145,
                "column": 59
            },
            "line": 145,
            "code": "test('when commaSeparatedList x,y,z then value is [x, y, z]', () => {\n  const program = new commander.Command();\n  program\n    .option('-l, --list <items>', 'comma separated list', commaSeparatedList);\n  program.parse(['node', 'test', '--list', 'x,y,z']);\n  expect(program.opts().list).toEqual(['x', 'y', 'z']);\n});",
            "file": "options.custom-processing.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "option declared as: %s",
            "suites": [],
            "line": 4,
            "code": "describe.each(['-f, --foo <required-arg>', '-f, --foo [optional-arg]'])('option declared as: %s', (fooFlags) => {\n  test('when env undefined and no cli then option undefined', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBeUndefined();\n  });\n\n  test('when env defined and no cli then option from env', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('env');\n    delete process.env.BAR;\n  });\n\n  test('when env defined and cli then option from cli', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.parse(['--foo', 'cli'], { from: 'user' });\n    expect(program.opts().foo).toBe('cli');\n    delete process.env.BAR;\n  });\n\n  test('when env defined and value source is config then option from env', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.setOptionValueWithSource('foo', 'config', 'config');\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('env');\n    delete process.env.BAR;\n  });\n\n  test('when env defined and value source is unspecified then option unchanged', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.setOptionValue('foo', 'client');\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('client');\n    delete process.env.BAR;\n  });\n\n  test('when default and env undefined and no cli then option from default', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option(fooFlags).env('BAR').default('default'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('default');\n  });\n\n  test('when default and env defined and no cli then option from env', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR').default('default'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('env');\n    delete process.env.BAR;\n  });\n\n  test('when default and env defined and cli then option from cli', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR').default('default'));\n    program.parse(['--foo', 'cli'], { from: 'user' });\n    expect(program.opts().foo).toBe('cli');\n    delete process.env.BAR;\n  });\n});",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env undefined and no cli then option undefined",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 59
            },
            "line": 5,
            "code": "  test('when env undefined and no cli then option undefined', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBeUndefined();\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and no cli then option from env",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 56
            },
            "line": 12,
            "code": "  test('when env defined and no cli then option from env', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('env');\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and cli then option from cli",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 53
            },
            "line": 21,
            "code": "  test('when env defined and cli then option from cli', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.parse(['--foo', 'cli'], { from: 'user' });\n    expect(program.opts().foo).toBe('cli');\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and value source is config then option from env",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 72
            },
            "line": 30,
            "code": "  test('when env defined and value source is config then option from env', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.setOptionValueWithSource('foo', 'config', 'config');\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('env');\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and value source is unspecified then option unchanged",
            "suites": [],
            "updatePoint": {
                "line": 40,
                "column": 78
            },
            "line": 40,
            "code": "  test('when env defined and value source is unspecified then option unchanged', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR'));\n    program.setOptionValue('foo', 'client');\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('client');\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default and env undefined and no cli then option from default",
            "suites": [],
            "updatePoint": {
                "line": 50,
                "column": 74
            },
            "line": 50,
            "code": "  test('when default and env undefined and no cli then option from default', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option(fooFlags).env('BAR').default('default'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('default');\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default and env defined and no cli then option from env",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 68
            },
            "line": 57,
            "code": "  test('when default and env defined and no cli then option from env', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR').default('default'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('env');\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default and env defined and cli then option from cli",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 65
            },
            "line": 66,
            "code": "  test('when default and env defined and cli then option from cli', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option(fooFlags).env('BAR').default('default'));\n    program.parse(['--foo', 'cli'], { from: 'user' });\n    expect(program.opts().foo).toBe('cli');\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env undefined and no cli then option undefined",
            "suites": [
                "boolean flag"
            ],
            "updatePoint": {
                "line": 77,
                "column": 59
            },
            "line": 77,
            "code": "  test('when env undefined and no cli then option undefined', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option('-f, --foo').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBeUndefined();\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined with value and no cli then option true",
            "suites": [
                "boolean flag"
            ],
            "updatePoint": {
                "line": 84,
                "column": 63
            },
            "line": 84,
            "code": "  test('when env defined with value and no cli then option true', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe(true);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env is \"\" and no cli then option true",
            "suites": [
                "boolean flag"
            ],
            "updatePoint": {
                "line": 93,
                "column": 50
            },
            "line": 93,
            "code": "  test('when env is \"\" and no cli then option true', () => {\n    // any string, including \"\"\n    const program = new commander.Command();\n    process.env.BAR = '';\n    program.addOption(new commander.Option('-f, --foo').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe(true);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env is \"0\" and no cli then option true",
            "suites": [
                "boolean flag"
            ],
            "updatePoint": {
                "line": 103,
                "column": 51
            },
            "line": 103,
            "code": "  test('when env is \"0\" and no cli then option true', () => {\n    // any string, including \"0\"\n    const program = new commander.Command();\n    process.env.BAR = '0';\n    program.addOption(new commander.Option('-f, --foo').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe(true);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env is \"false\" and no cli then option true",
            "suites": [
                "boolean flag"
            ],
            "updatePoint": {
                "line": 113,
                "column": 55
            },
            "line": 113,
            "code": "  test('when env is \"false\" and no cli then option true', () => {\n    // any string, including \"false\"\n    const program = new commander.Command();\n    process.env.BAR = 'false';\n    program.addOption(new commander.Option('-f, --foo').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe(true);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env undefined and no cli then option true",
            "suites": [
                "boolean no-flag"
            ],
            "updatePoint": {
                "line": 125,
                "column": 54
            },
            "line": 125,
            "code": "  test('when env undefined and no cli then option true', () => {\n    const program = new commander.Command();\n    program.addOption(new commander.Option('-F, --no-foo').env('NO_BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe(true);\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and no cli then option false",
            "suites": [
                "boolean no-flag"
            ],
            "updatePoint": {
                "line": 132,
                "column": 53
            },
            "line": 132,
            "code": "  test('when env defined and no cli then option false', () => {\n    const program = new commander.Command();\n    process.env.NO_BAR = 'env';\n    program.addOption(new commander.Option('-F, --no-foo').env('NO_BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe(false);\n    delete process.env.NO_BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env undefined and no cli then option undefined",
            "suites": [
                "boolean flag and negatable"
            ],
            "updatePoint": {
                "line": 143,
                "column": 59
            },
            "line": 143,
            "code": "  test('when env undefined and no cli then option undefined', () => {\n    const program = new commander.Command();\n    program\n      .addOption(new commander.Option('-f, --foo').env('BAR'))\n      .addOption(new commander.Option('-F, --no-foo').env('NO_BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBeUndefined();\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and no cli then option true",
            "suites": [
                "boolean flag and negatable"
            ],
            "updatePoint": {
                "line": 152,
                "column": 52
            },
            "line": 152,
            "code": "  test('when env defined and no cli then option true', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program\n      .addOption(new commander.Option('-f, --foo').env('BAR'))\n      .addOption(new commander.Option('-F, --no-foo').env('NO_BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe(true);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and cli --no-foo then option false",
            "suites": [
                "boolean flag and negatable"
            ],
            "updatePoint": {
                "line": 163,
                "column": 59
            },
            "line": 163,
            "code": "  test('when env defined and cli --no-foo then option false', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program\n      .addOption(new commander.Option('-f, --foo').env('BAR'))\n      .addOption(new commander.Option('-F, --no-foo').env('NO_BAR'));\n    program.parse(['--no-foo'], { from: 'user' });\n    expect(program.opts().foo).toBe(false);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no_env defined and no cli then option false",
            "suites": [
                "boolean flag and negatable"
            ],
            "updatePoint": {
                "line": 174,
                "column": 56
            },
            "line": 174,
            "code": "  test('when no_env defined and no cli then option false', () => {\n    const program = new commander.Command();\n    process.env.NO_BAR = 'env';\n    program\n      .addOption(new commander.Option('-f, --foo').env('BAR'))\n      .addOption(new commander.Option('-F, --no-foo').env('NO_BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe(false);\n    delete process.env.NO_BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no_env defined and cli --foo then option true",
            "suites": [
                "boolean flag and negatable"
            ],
            "updatePoint": {
                "line": 185,
                "column": 58
            },
            "line": 185,
            "code": "  test('when no_env defined and cli --foo then option true', () => {\n    const program = new commander.Command();\n    process.env.NO_BAR = 'env';\n    program\n      .addOption(new commander.Option('-f, --foo').env('BAR'))\n      .addOption(new commander.Option('-F, --no-foo').env('NO_BAR'));\n    program.parse(['--foo'], { from: 'user' });\n    expect(program.opts().foo).toBe(true);\n    delete process.env.NO_BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and no cli then custom parse from env",
            "suites": [
                "custom argParser"
            ],
            "updatePoint": {
                "line": 198,
                "column": 62
            },
            "line": 198,
            "code": "  test('when env defined and no cli then custom parse from env', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo <required>').env('BAR').argParser(str => str.toUpperCase()));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toBe('ENV');\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and no cli then array from env",
            "suites": [
                "variadic"
            ],
            "updatePoint": {
                "line": 209,
                "column": 55
            },
            "line": 209,
            "code": "  test('when env defined and no cli then array from env', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo <required...>').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(program.opts().foo).toEqual(['env']);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined and cli then array from cli",
            "suites": [
                "variadic"
            ],
            "updatePoint": {
                "line": 218,
                "column": 52
            },
            "line": 218,
            "code": "  test('when env defined and cli then array from cli', () => {\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo <required...>').env('BAR'));\n    program.parse(['--foo', 'cli'], { from: 'user' });\n    expect(program.opts().foo).toEqual(['cli']);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined on another subcommand then env not applied",
            "suites": [
                "env only processed when applies"
            ],
            "updatePoint": {
                "line": 229,
                "column": 67
            },
            "line": 229,
            "code": "  test('when env defined on another subcommand then env not applied', () => {\n    // Doing selective processing. Not processing env at addOption time.\n    const program = new commander.Command();\n    process.env.BAR = 'env';\n    program.command('one')\n      .action(() => {});\n    const two = program.command('two')\n      .addOption(new commander.Option('-f, --foo <required...>').env('BAR').default('default'))\n      .action(() => {});\n    program.parse(['one'], { from: 'user' });\n    expect(two.opts().foo).toBe('default');\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env and cli defined then only emit option event for cli",
            "suites": [
                "env only processed when applies"
            ],
            "updatePoint": {
                "line": 243,
                "column": 68
            },
            "line": 243,
            "code": "  test('when env and cli defined then only emit option event for cli', () => {\n    const program = new commander.Command();\n    const optionEventMock = jest.fn();\n    const optionEnvEventMock = jest.fn();\n    program.on('option:foo', optionEventMock);\n    program.on('optionEnv:foo', optionEnvEventMock);\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo <required...>').env('BAR'));\n    program.parse(['--foo', 'cli'], { from: 'user' });\n    expect(optionEventMock).toHaveBeenCalledWith('cli');\n    expect(optionEventMock).toHaveBeenCalledTimes(1);\n    expect(optionEnvEventMock).toHaveBeenCalledTimes(0);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env and cli defined then only parse value for cli",
            "suites": [
                "env only processed when applies"
            ],
            "updatePoint": {
                "line": 258,
                "column": 62
            },
            "line": 258,
            "code": "  test('when env and cli defined then only parse value for cli', () => {\n    const program = new commander.Command();\n    const parseMock = jest.fn();\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo <required...>').env('BAR').argParser(parseMock));\n    program.parse(['--foo', 'cli'], { from: 'user' });\n    expect(parseMock).toHaveBeenCalledWith('cli', undefined);\n    expect(parseMock).toHaveBeenCalledTimes(1);\n    delete process.env.BAR;\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined then emit \"optionEnv\" and not \"option\"",
            "suites": [
                "events dispatched for env"
            ],
            "updatePoint": {
                "line": 278,
                "column": 63
            },
            "line": 278,
            "code": "  test('when env defined then emit \"optionEnv\" and not \"option\"', () => {\n    // Decided to do separate events, so test stays that way.\n    const program = new commander.Command();\n    const optionEventMock = jest.fn();\n    program.on('option:foo', optionEventMock);\n    program.on('optionEnv:foo', optionEnvEventMock);\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo <required>').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(optionEventMock).toHaveBeenCalledTimes(0);\n    expect(optionEnvEventMock).toHaveBeenCalledTimes(1);\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined for required then emit \"optionEnv\" with value",
            "suites": [
                "events dispatched for env"
            ],
            "updatePoint": {
                "line": 291,
                "column": 70
            },
            "line": 291,
            "code": "  test('when env defined for required then emit \"optionEnv\" with value', () => {\n    const program = new commander.Command();\n    program.on('optionEnv:foo', optionEnvEventMock);\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo <required>').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(optionEnvEventMock).toHaveBeenCalledWith('env');\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined for optional then emit \"optionEnv\" with value",
            "suites": [
                "events dispatched for env"
            ],
            "updatePoint": {
                "line": 300,
                "column": 70
            },
            "line": 300,
            "code": "  test('when env defined for optional then emit \"optionEnv\" with value', () => {\n    const program = new commander.Command();\n    program.on('optionEnv:foo', optionEnvEventMock);\n    process.env.BAR = 'env';\n    program.addOption(new commander.Option('-f, --foo [optional]').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(optionEnvEventMock).toHaveBeenCalledWith('env');\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined for boolean then emit \"optionEnv\" with no param",
            "suites": [
                "events dispatched for env"
            ],
            "updatePoint": {
                "line": 309,
                "column": 72
            },
            "line": 309,
            "code": "  test('when env defined for boolean then emit \"optionEnv\" with no param', () => {\n    // check matches historical boolean action event\n    const program = new commander.Command();\n    program.on('optionEnv:foo', optionEnvEventMock);\n    process.env.BAR = 'anything';\n    program.addOption(new commander.Option('-f, --foo').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(optionEnvEventMock).toHaveBeenCalledWith();\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when env defined for negated boolean then emit \"optionEnv\" with no param",
            "suites": [
                "events dispatched for env"
            ],
            "updatePoint": {
                "line": 319,
                "column": 80
            },
            "line": 319,
            "code": "  test('when env defined for negated boolean then emit \"optionEnv\" with no param', () => {\n    // check matches historical boolean action event\n    const program = new commander.Command();\n    program.on('optionEnv:no-foo', optionEnvEventMock);\n    process.env.BAR = 'anything';\n    program.addOption(new commander.Option('-F, --no-foo').env('BAR'));\n    program.parse([], { from: 'user' });\n    expect(optionEnvEventMock).toHaveBeenCalledWith();\n  });",
            "file": "options.env.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when only short flag defined and not specified then value is undefined",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 76
            },
            "line": 5,
            "code": "test('when only short flag defined and not specified then value is undefined', () => {\n  const program = new commander.Command();\n  program\n    .option('-p', 'add pepper');\n  program.parse(['node', 'test']);\n  expect(program.opts().p).toBeUndefined();\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when only short flag defined and specified then value is true",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 67
            },
            "line": 13,
            "code": "test('when only short flag defined and specified then value is true', () => {\n  const program = new commander.Command();\n  program\n    .option('-p', 'add pepper');\n  program.parse(['node', 'test', '-p']);\n  expect(program.opts().p).toBe(true);\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when only long flag defined and not specified then value is undefined",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 75
            },
            "line": 21,
            "code": "test('when only long flag defined and not specified then value is undefined', () => {\n  const program = new commander.Command();\n  program\n    .option('--pepper', 'add pepper');\n  program.parse(['node', 'test']);\n  expect(program.opts().pepper).toBeUndefined();\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when only long flag defined and specified then value is true",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 66
            },
            "line": 29,
            "code": "test('when only long flag defined and specified then value is true', () => {\n  const program = new commander.Command();\n  program\n    .option('--pepper', 'add pepper');\n  program.parse(['node', 'test', '--pepper']);\n  expect(program.opts().pepper).toBe(true);\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"short,long\" flags defined and short specified then value is true",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 76
            },
            "line": 37,
            "code": "test('when \"short,long\" flags defined and short specified then value is true', () => {\n  const program = new commander.Command();\n  program\n    .option('-p,--pepper', 'add pepper');\n  program.parse(['node', 'test', '-p']);\n  expect(program.opts().pepper).toBe(true);\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"short,long\" flags defined and long specified then value is true",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 75
            },
            "line": 45,
            "code": "test('when \"short,long\" flags defined and long specified then value is true', () => {\n  const program = new commander.Command();\n  program\n    .option('-p,--pepper', 'add pepper');\n  program.parse(['node', 'test', '--pepper']);\n  expect(program.opts().pepper).toBe(true);\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"short|long\" flags defined and short specified then value is true",
            "suites": [],
            "updatePoint": {
                "line": 53,
                "column": 76
            },
            "line": 53,
            "code": "test('when \"short|long\" flags defined and short specified then value is true', () => {\n  const program = new commander.Command();\n  program\n    .option('-p|--pepper', 'add pepper');\n  program.parse(['node', 'test', '-p']);\n  expect(program.opts().pepper).toBe(true);\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"short|long\" flags defined and long specified then value is true",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 75
            },
            "line": 61,
            "code": "test('when \"short|long\" flags defined and long specified then value is true', () => {\n  const program = new commander.Command();\n  program\n    .option('-p|--pepper', 'add pepper');\n  program.parse(['node', 'test', '--pepper']);\n  expect(program.opts().pepper).toBe(true);\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"short long\" flags defined and short specified then value is true",
            "suites": [],
            "updatePoint": {
                "line": 69,
                "column": 76
            },
            "line": 69,
            "code": "test('when \"short long\" flags defined and short specified then value is true', () => {\n  const program = new commander.Command();\n  program\n    .option('-p --pepper', 'add pepper');\n  program.parse(['node', 'test', '-p']);\n  expect(program.opts().pepper).toBe(true);\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when \"short long\" flags defined and long specified then value is true",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 75
            },
            "line": 77,
            "code": "test('when \"short long\" flags defined and long specified then value is true', () => {\n  const program = new commander.Command();\n  program\n    .option('-p --pepper', 'add pepper');\n  program.parse(['node', 'test', '--pepper']);\n  expect(program.opts().pepper).toBe(true);\n});",
            "file": "options.flags.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "storeOptionsAsProperties is %s",
            "suites": [],
            "line": 3,
            "code": "describe.each([true, false])('storeOptionsAsProperties is %s', (storeOptionsAsProperties) => {\n  test('when option specified on CLI then value returned by getOptionValue', () => {\n    const program = new commander.Command();\n    program\n      .storeOptionsAsProperties(storeOptionsAsProperties)\n      .option('--cheese [type]', 'cheese type');\n    const cheeseType = 'blue';\n    program.parse(['node', 'test', '--cheese', cheeseType]);\n    expect(program.getOptionValue('cheese')).toBe(cheeseType);\n  });\n\n  test('when setOptionValue then value returned by opts', () => {\n    const program = new commander.Command();\n    const cheeseType = 'blue';\n    // Note: opts() only returns declared options when options stored as properties\n    program\n      .storeOptionsAsProperties(storeOptionsAsProperties)\n      .option('--cheese [type]', 'cheese type')\n      .setOptionValue('cheese', cheeseType);\n    expect(program.opts().cheese).toBe(cheeseType);\n  });\n});",
            "file": "options.getset.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified on CLI then value returned by getOptionValue",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 74
            },
            "line": 4,
            "code": "  test('when option specified on CLI then value returned by getOptionValue', () => {\n    const program = new commander.Command();\n    program\n      .storeOptionsAsProperties(storeOptionsAsProperties)\n      .option('--cheese [type]', 'cheese type');\n    const cheeseType = 'blue';\n    program.parse(['node', 'test', '--cheese', cheeseType]);\n    expect(program.getOptionValue('cheese')).toBe(cheeseType);\n  });",
            "file": "options.getset.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when setOptionValue then value returned by opts",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 55
            },
            "line": 14,
            "code": "  test('when setOptionValue then value returned by opts', () => {\n    const program = new commander.Command();\n    const cheeseType = 'blue';\n    // Note: opts() only returns declared options when options stored as properties\n    program\n      .storeOptionsAsProperties(storeOptionsAsProperties)\n      .option('--cheese [type]', 'cheese type')\n      .setOptionValue('cheese', cheeseType);\n    expect(program.opts().cheese).toBe(cheeseType);\n  });",
            "file": "options.getset.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when setOptionValueWithSource then value returned by opts",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 63
            },
            "line": 26,
            "code": "test('when setOptionValueWithSource then value returned by opts', () => {\n  const program = new commander.Command();\n  const cheeseValue = 'blue';\n  program\n    .option('--cheese [type]', 'cheese type')\n    .setOptionValue('cheese', cheeseValue);\n  expect(program.opts().cheese).toBe(cheeseValue);\n});",
            "file": "options.getset.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when setOptionValueWithSource then source returned by getOptionValueSource",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 80
            },
            "line": 35,
            "code": "test('when setOptionValueWithSource then source returned by getOptionValueSource', () => {\n  const program = new commander.Command();\n  program\n    .option('--cheese [type]', 'cheese type')\n    .setOptionValueWithSource('cheese', 'blue', 'config');\n  expect(program.getOptionValueSource('cheese')).toBe('config');\n});",
            "file": "options.getset.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option value parsed from env then option source is env",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 65
            },
            "line": 43,
            "code": "test('when option value parsed from env then option source is env', () => {\n  const program = new commander.Command();\n  process.env.BAR = 'env';\n  program\n    .addOption(new commander.Option('-f, --foo').env('BAR'));\n  program.parse([], { from: 'user' });\n  expect(program.getOptionValueSource('foo')).toBe('env');\n  delete process.env.BAR;\n});",
            "file": "options.getset.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option value parsed from cli then option source is cli",
            "suites": [],
            "updatePoint": {
                "line": 53,
                "column": 65
            },
            "line": 53,
            "code": "test('when option value parsed from cli then option source is cli', () => {\n  const program = new commander.Command();\n  program\n    .addOption(new commander.Option('-f, --foo').env('BAR'));\n  program.parse(['--foo'], { from: 'user' });\n  expect(program.getOptionValueSource('foo')).toBe('cli');\n});",
            "file": "options.getset.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has required value specified then value as specified",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 7,
                "column": 73
            },
            "line": 7,
            "code": "  test('when program has required value specified then value as specified', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type');\n    program.parse(['node', 'test', '--cheese', 'blue']);\n    expect(program.opts().cheese).toBe('blue');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has option with name different than property then still recognised",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 16,
                "column": 87
            },
            "line": 16,
            "code": "  test('when program has option with name different than property then still recognised', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese-type <type>', 'cheese type');\n    program.parse(['node', 'test', '--cheese-type', 'blue']);\n    expect(program.opts().cheeseType).toBe('blue');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has required value default then default value",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 25,
                "column": 66
            },
            "line": 25,
            "code": "  test('when program has required value default then default value', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type', 'default');\n    program.parse(['node', 'test']);\n    expect(program.opts().cheese).toBe('default');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has optional value flag specified then true",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 34,
                "column": 64
            },
            "line": 34,
            "code": "  test('when program has optional value flag specified then true', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese [type]', 'cheese type');\n    program.parse(['node', 'test', '--cheese']);\n    expect(program.opts().cheese).toBe(true);\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has optional value default then default value",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 43,
                "column": 66
            },
            "line": 43,
            "code": "  test('when program has optional value default then default value', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese [type]', 'cheese type', 'default');\n    program.parse(['node', 'test']);\n    expect(program.opts().cheese).toBe('default');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has value/no flag specified with value then specified value",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 52,
                "column": 80
            },
            "line": 52,
            "code": "  test('when program has value/no flag specified with value then specified value', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type')\n      .requiredOption('--no-cheese', 'no cheese thanks');\n    program.parse(['node', 'test', '--cheese', 'blue']);\n    expect(program.opts().cheese).toBe('blue');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has mandatory-yes/no flag specified with flag then true",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 62,
                "column": 76
            },
            "line": 62,
            "code": "  test('when program has mandatory-yes/no flag specified with flag then true', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese', 'cheese type')\n      .option('--no-cheese', 'no cheese thanks');\n    program.parse(['node', 'test', '--cheese']);\n    expect(program.opts().cheese).toBe(true);\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has mandatory-yes/mandatory-no flag specified with flag then true",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 72,
                "column": 86
            },
            "line": 72,
            "code": "  test('when program has mandatory-yes/mandatory-no flag specified with flag then true', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese', 'cheese type')\n      .requiredOption('--no-cheese', 'no cheese thanks');\n    program.parse(['node', 'test', '--cheese']);\n    expect(program.opts().cheese).toBe(true);\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has yes/no flag specified negated then false",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 82,
                "column": 65
            },
            "line": 82,
            "code": "  test('when program has yes/no flag specified negated then false', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type')\n      .option('--no-cheese', 'no cheese thanks');\n    program.parse(['node', 'test', '--no-cheese']);\n    expect(program.opts().cheese).toBe(false);\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has required value specified and subcommand then specified value",
            "suites": [
                "required program option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 92,
                "column": 85
            },
            "line": 92,
            "code": "  test('when program has required value specified and subcommand then specified value', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type')\n      .command('sub')\n      .action(() => {});\n    program.parse(['node', 'test', '--cheese', 'blue', 'sub']);\n    expect(program.opts().cheese).toBe('blue');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has required option not specified then error",
            "suites": [
                "required program option with mandatory value not specified"
            ],
            "updatePoint": {
                "line": 120,
                "column": 65
            },
            "line": 120,
            "code": "  test('when program has required option not specified then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type');\n\n    expect(() => {\n      program.parse(['node', 'test']);\n    }).toThrow();\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has optional option not specified then error",
            "suites": [
                "required program option with mandatory value not specified"
            ],
            "updatePoint": {
                "line": 131,
                "column": 65
            },
            "line": 131,
            "code": "  test('when program has optional option not specified then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese [type]', 'cheese type');\n\n    expect(() => {\n      program.parse(['node', 'test']);\n    }).toThrow();\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has yes/no not specified then error",
            "suites": [
                "required program option with mandatory value not specified"
            ],
            "updatePoint": {
                "line": 142,
                "column": 56
            },
            "line": 142,
            "code": "  test('when program has yes/no not specified then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese', 'cheese type')\n      .option('--no-cheese', 'no cheese thanks');\n\n    expect(() => {\n      program.parse(['node', 'test']);\n    }).toThrow();\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has required value not specified and subcommand then error",
            "suites": [
                "required program option with mandatory value not specified"
            ],
            "updatePoint": {
                "line": 154,
                "column": 79
            },
            "line": 154,
            "code": "  test('when program has required value not specified and subcommand then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type')\n      .command('sub')\n      .action(() => {});\n\n    expect(() => {\n      program.parse(['node', 'test', 'sub']);\n    }).toThrow();\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has required value specified then no error and option has specified value",
            "suites": [
                "required command option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 169,
                "column": 94
            },
            "line": 169,
            "code": "  test('when command has required value specified then no error and option has specified value', () => {\n    const program = new commander.Command();\n    let cmdOptions;\n    program\n      .exitOverride()\n      .command('sub')\n      .requiredOption('--subby <type>', 'description')\n      .action((options) => {\n        cmdOptions = options;\n      });\n\n    program.parse(['node', 'test', 'sub', '--subby', 'blue']);\n\n    expect(cmdOptions.subby).toBe('blue');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has required value specified using env then no error and option has specified value",
            "suites": [
                "required command option with mandatory value specified"
            ],
            "updatePoint": {
                "line": 185,
                "column": 104
            },
            "line": 185,
            "code": "  test('when command has required value specified using env then no error and option has specified value', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .addOption(new commander.Option('-p, --port <number>', 'port number').makeOptionMandatory().env('FOO'));\n\n    process.env.FOO = 'bar';\n    program.parse([], { from: 'user' });\n    delete process.env.FOO;\n\n    expect(program.opts().port).toBe('bar');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has required value not specified then error",
            "suites": [
                "required command option with mandatory value not specified"
            ],
            "updatePoint": {
                "line": 215,
                "column": 64
            },
            "line": 215,
            "code": "  test('when command has required value not specified then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('sub')\n      .requiredOption('--subby <type>', 'description')\n      .action(() => {});\n\n    expect(() => {\n      program.parse(['node', 'test', 'sub']);\n    }).toThrow();\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when command has required value but not called then no error",
            "suites": [
                "required command option with mandatory value not specified"
            ],
            "updatePoint": {
                "line": 228,
                "column": 68
            },
            "line": 228,
            "code": "  test('when command has required value but not called then no error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .command('sub')\n      .requiredOption('--subby <type>', 'description')\n      .action(() => {});\n    program\n      .command('sub2');\n\n    expect(() => {\n      program.parse(['node', 'test', 'sub2']);\n    }).not.toThrow();\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has required option not specified and --help then help",
            "suites": [
                "missing mandatory option but help requested"
            ],
            "updatePoint": {
                "line": 260,
                "column": 75
            },
            "line": 260,
            "code": "  test('when program has required option not specified and --help then help', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type');\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', '--help']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(caughtErr.code).toEqual('commander.helpDisplayed');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when program has required option not specified and subcommand --help then help",
            "suites": [
                "missing mandatory option but help requested"
            ],
            "updatePoint": {
                "line": 276,
                "column": 86
            },
            "line": 276,
            "code": "  test('when program has required option not specified and subcommand --help then help', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .requiredOption('--cheese <type>', 'cheese type')\n      .command('sub')\n      .action(() => {});\n\n    let caughtErr;\n    try {\n      program.parse(['node', 'test', 'sub', '--help']);\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    expect(caughtErr.code).toEqual('commander.helpDisplayed');\n  });",
            "file": "options.mandatory.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option not specified then value is undefined",
            "suites": [
                "option with optional value, no default"
            ],
            "updatePoint": {
                "line": 5,
                "column": 57
            },
            "line": 5,
            "code": "  test('when option not specified then value is undefined', () => {\n    const program = new commander.Command();\n    program\n      .option('--cheese [type]', 'cheese type');\n    program.parse(['node', 'test']);\n    expect(program.opts().cheese).toBeUndefined();\n  });",
            "file": "options.optional.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified then value is as specified",
            "suites": [
                "option with optional value, no default"
            ],
            "updatePoint": {
                "line": 13,
                "column": 56
            },
            "line": 13,
            "code": "  test('when option specified then value is as specified', () => {\n    const program = new commander.Command();\n    program\n      .option('--cheese [type]', 'cheese type');\n    const cheeseType = 'blue';\n    program.parse(['node', 'test', '--cheese', cheeseType]);\n    expect(program.opts().cheese).toBe(cheeseType);\n  });",
            "file": "options.optional.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified without value then value is true",
            "suites": [
                "option with optional value, no default"
            ],
            "updatePoint": {
                "line": 22,
                "column": 62
            },
            "line": 22,
            "code": "  test('when option specified without value then value is true', () => {\n    const program = new commander.Command();\n    program\n      .option('--cheese [type]', 'cheese type');\n    program.parse(['node', 'test', '--cheese']);\n    expect(program.opts().cheese).toBe(true);\n  });",
            "file": "options.optional.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified without value and following option then value is true",
            "suites": [
                "option with optional value, no default"
            ],
            "updatePoint": {
                "line": 30,
                "column": 83
            },
            "line": 30,
            "code": "  test('when option specified without value and following option then value is true', () => {\n    // optional options do not eat values with dashes\n    const program = new commander.Command();\n    program\n      .option('--cheese [type]', 'cheese type')\n      .option('--some-option');\n    program.parse(['node', 'test', '--cheese', '--some-option']);\n    expect(program.opts().cheese).toBe(true);\n  });",
            "file": "options.optional.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option not specified then value is default",
            "suites": [
                "option with optional value, with default"
            ],
            "updatePoint": {
                "line": 43,
                "column": 55
            },
            "line": 43,
            "code": "  test('when option not specified then value is default', () => {\n    const defaultValue = 'default';\n    const program = new commander.Command();\n    program\n      .option('--cheese [type]', 'cheese type', defaultValue);\n    program.parse(['node', 'test']);\n    expect(program.opts().cheese).toBe(defaultValue);\n  });",
            "file": "options.optional.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified then value is as specified",
            "suites": [
                "option with optional value, with default"
            ],
            "updatePoint": {
                "line": 52,
                "column": 56
            },
            "line": 52,
            "code": "  test('when option specified then value is as specified', () => {\n    const defaultValue = 'default';\n    const program = new commander.Command();\n    program\n      .option('--cheese [type]', 'cheese type', defaultValue);\n    const cheeseType = 'blue';\n    program.parse(['node', 'test', '--cheese', cheeseType]);\n    expect(program.opts().cheese).toBe(cheeseType);\n  });",
            "file": "options.optional.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified without value then value is default",
            "suites": [
                "option with optional value, with default"
            ],
            "updatePoint": {
                "line": 62,
                "column": 65
            },
            "line": 62,
            "code": "  test('when option specified without value then value is default', () => {\n    const defaultValue = 'default';\n    const program = new commander.Command();\n    program\n      .option('--cheese [type]', 'cheese type', defaultValue);\n    program.parse(['node', 'test', '--cheese']);\n    expect(program.opts().cheese).toBe(defaultValue);\n  });",
            "file": "options.optional.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .version used with storeOptionsAsProperties() then version in opts",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 77
            },
            "line": 6,
            "code": "test('when .version used with storeOptionsAsProperties() then version in opts', () => {\n  const program = new commander.Command();\n  const version = '0.0.1';\n  program\n    .storeOptionsAsProperties()\n    .version(version);\n  program.parse(['node', 'test']);\n  expect(program.opts()).toEqual({ version });\n});",
            "file": "options.opts.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when .version used with storeOptionsAsProperties(false) then version not in opts",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 86
            },
            "line": 16,
            "code": "test('when .version used with storeOptionsAsProperties(false) then version not in opts', () => {\n  // New behaviour, stop storing version as an option value.\n  const program = new commander.Command();\n  const version = '0.0.1';\n  program\n    .storeOptionsAsProperties(false)\n    .version(version);\n  program.parse(['node', 'test']);\n  expect(program.opts()).toEqual({ });\n});",
            "file": "options.opts.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "storeOptionsAsProperties is %s",
            "suites": [],
            "line": 27,
            "code": "describe.each([true, false])('storeOptionsAsProperties is %s', (storeOptionsAsProperties) => {\n  test('when boolean flag not specified then not in opts', () => {\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper', 'add pepper');\n    program.parse(['node', 'test']);\n    expect(program.opts()).toEqual({ });\n  });\n\n  test('when boolean flag specified then value true', () => {\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper', 'add pepper');\n    program.parse(['node', 'test', '--pepper']);\n    expect(program.opts()).toEqual({ pepper: true });\n  });\n\n  test('when option with required value not specified then not in opts', () => {\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper <flavour>', 'add pepper');\n    program.parse(['node', 'test']);\n    expect(program.opts()).toEqual({ });\n  });\n\n  test('when option with required value specified then value as specified', () => {\n    const pepperValue = 'red';\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper <flavour>', 'add pepper');\n    program.parse(['node', 'test', '--pepper', pepperValue]);\n    expect(program.opts()).toEqual({ pepper: pepperValue });\n  });\n\n  test('when option with default value not specified then default value in opts', () => {\n    const pepperDefault = 'red';\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper <flavour>', 'add pepper', pepperDefault);\n    program.parse(['node', 'test']);\n    expect(program.opts()).toEqual({ pepper: pepperDefault });\n  });\n});",
            "file": "options.opts.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean flag not specified then not in opts",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 56
            },
            "line": 28,
            "code": "  test('when boolean flag not specified then not in opts', () => {\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper', 'add pepper');\n    program.parse(['node', 'test']);\n    expect(program.opts()).toEqual({ });\n  });",
            "file": "options.opts.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when boolean flag specified then value true",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 51
            },
            "line": 37,
            "code": "  test('when boolean flag specified then value true', () => {\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper', 'add pepper');\n    program.parse(['node', 'test', '--pepper']);\n    expect(program.opts()).toEqual({ pepper: true });\n  });",
            "file": "options.opts.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option with required value not specified then not in opts",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 70
            },
            "line": 46,
            "code": "  test('when option with required value not specified then not in opts', () => {\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper <flavour>', 'add pepper');\n    program.parse(['node', 'test']);\n    expect(program.opts()).toEqual({ });\n  });",
            "file": "options.opts.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option with required value specified then value as specified",
            "suites": [],
            "updatePoint": {
                "line": 55,
                "column": 73
            },
            "line": 55,
            "code": "  test('when option with required value specified then value as specified', () => {\n    const pepperValue = 'red';\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper <flavour>', 'add pepper');\n    program.parse(['node', 'test', '--pepper', pepperValue]);\n    expect(program.opts()).toEqual({ pepper: pepperValue });\n  });",
            "file": "options.opts.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option with default value not specified then default value in opts",
            "suites": [],
            "updatePoint": {
                "line": 65,
                "column": 79
            },
            "line": 65,
            "code": "  test('when option with default value not specified then default value in opts', () => {\n    const pepperDefault = 'red';\n    const program = new commander.Command();\n    program.storeOptionsAsProperties(storeOptionsAsProperties);\n    program\n      .option('--pepper <flavour>', 'add pepper', pepperDefault);\n    program.parse(['node', 'test']);\n    expect(program.opts()).toEqual({ pepper: pepperDefault });\n  });",
            "file": "options.opts.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option not specified then value is undefined",
            "suites": [
                "option with required value, no default"
            ],
            "updatePoint": {
                "line": 5,
                "column": 57
            },
            "line": 5,
            "code": "  test('when option not specified then value is undefined', () => {\n    const program = new commander.Command();\n    program\n      .option('--cheese <type>', 'cheese type');\n    program.parse(['node', 'test']);\n    expect(program.opts().cheese).toBeUndefined();\n  });",
            "file": "options.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified then value is as specified",
            "suites": [
                "option with required value, no default"
            ],
            "updatePoint": {
                "line": 13,
                "column": 56
            },
            "line": 13,
            "code": "  test('when option specified then value is as specified', () => {\n    const program = new commander.Command();\n    program\n      .option('--cheese <type>', 'cheese type');\n    const cheeseType = 'blue';\n    program.parse(['node', 'test', '--cheese', cheeseType]);\n    expect(program.opts().cheese).toBe(cheeseType);\n  });",
            "file": "options.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option value not specified then error",
            "suites": [
                "option with required value, no default"
            ],
            "updatePoint": {
                "line": 22,
                "column": 50
            },
            "line": 22,
            "code": "  test('when option value not specified then error', () => {\n    // Arrange. Mock error routine to allow interception.\n    const mockOptionMissingArgument = jest.fn(() => {\n      throw new Error('optionMissingArgument');\n    });\n    const program = new commander.Command();\n    program.optionMissingArgument = mockOptionMissingArgument;\n    program\n      .option('--cheese <type>', 'cheese type');\n\n    // Act. The throw is due to the above mock, and not default behaviour.\n    expect(() => {\n      program.parse(['node', 'test', '--cheese']);\n    }).toThrow();\n\n    // Assert\n    expect(mockOptionMissingArgument).toHaveBeenCalled();\n  });",
            "file": "options.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option not specified then value is default",
            "suites": [
                "option with required value, with default"
            ],
            "updatePoint": {
                "line": 44,
                "column": 55
            },
            "line": 44,
            "code": "  test('when option not specified then value is default', () => {\n    const defaultValue = 'default';\n    const program = new commander.Command();\n    program\n      .option('--cheese <type>', 'cheese type', defaultValue);\n    program.parse(['node', 'test']);\n    expect(program.opts().cheese).toBe(defaultValue);\n  });",
            "file": "options.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option specified then value is as specified",
            "suites": [
                "option with required value, with default"
            ],
            "updatePoint": {
                "line": 53,
                "column": 56
            },
            "line": 53,
            "code": "  test('when option specified then value is as specified', () => {\n    const defaultValue = 'default';\n    const program = new commander.Command();\n    program\n      .option('--cheese <type>', 'cheese type', defaultValue);\n    const cheeseType = 'blue';\n    program.parse(['node', 'test', '--cheese', cheeseType]);\n    expect(program.opts().cheese).toBe(cheeseType);\n  });",
            "file": "options.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option value not specified then error",
            "suites": [
                "option with required value, with default"
            ],
            "updatePoint": {
                "line": 63,
                "column": 50
            },
            "line": 63,
            "code": "  test('when option value not specified then error', () => {\n    // Arrange. Mock error routine to allow interception.\n    const mockOptionMissingArgument = jest.fn(() => {\n      throw new Error('optionMissingArgument');\n    });\n    const defaultValue = 'default';\n    const program = new commander.Command();\n    program.optionMissingArgument = mockOptionMissingArgument;\n    program\n      .option('--cheese <type>', 'cheese type', defaultValue);\n\n    // Act. The throw is due to the above mock, and not default behaviour.\n    expect(() => {\n      program.parse(['node', 'test', '--cheese']);\n    }).toThrow();\n\n    // Assert\n    expect(mockOptionMissingArgument).toHaveBeenCalled();\n  });",
            "file": "options.required.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "option with required value specified as %s",
            "suites": [],
            "line": 9,
            "code": "describe.each([['str'], ['80'], ['-'], ['-5'], ['--flag']])(\n  'option with required value specified as %s', (value) => {\n    function createPortProgram() {\n      const program = new commander.Command();\n      program\n        .option('-p,--port <number>', 'specify port');\n      return program;\n    }\n\n    test('when short flag followed by value then value is as specified', () => {\n      const program = createPortProgram();\n      program.parse(['node', 'test', '-p', value]);\n      expect(program.opts().port).toBe(value);\n    });\n\n    test('when short flag concatenated with value then value is as specified', () => {\n      const program = createPortProgram();\n      program.parse(['node', 'test', `-p${value}`]);\n      expect(program.opts().port).toBe(value);\n    });\n\n    test('when long flag followed by value then value is as specified', () => {\n      const program = createPortProgram();\n      program.parse(['node', 'test', '--port', value]);\n      expect(program.opts().port).toBe(value);\n    });\n\n    test('when long flag = value then value is as specified', () => {\n      const program = createPortProgram();\n      program.parse(['node', 'test', `--port=${value}`]);\n      expect(program.opts().port).toBe(value);\n    });\n  });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when short flag followed by value then value is as specified",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 70
            },
            "line": 18,
            "code": "    test('when short flag followed by value then value is as specified', () => {\n      const program = createPortProgram();\n      program.parse(['node', 'test', '-p', value]);\n      expect(program.opts().port).toBe(value);\n    });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when short flag concatenated with value then value is as specified",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 76
            },
            "line": 24,
            "code": "    test('when short flag concatenated with value then value is as specified', () => {\n      const program = createPortProgram();\n      program.parse(['node', 'test', `-p${value}`]);\n      expect(program.opts().port).toBe(value);\n    });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long flag followed by value then value is as specified",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 69
            },
            "line": 30,
            "code": "    test('when long flag followed by value then value is as specified', () => {\n      const program = createPortProgram();\n      program.parse(['node', 'test', '--port', value]);\n      expect(program.opts().port).toBe(value);\n    });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long flag = value then value is as specified",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 59
            },
            "line": 36,
            "code": "    test('when long flag = value then value is as specified', () => {\n      const program = createPortProgram();\n      program.parse(['node', 'test', `--port=${value}`]);\n      expect(program.opts().port).toBe(value);\n    });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when short flag followed by value then value is as specified",
            "suites": [
                "option with optional value"
            ],
            "updatePoint": {
                "line": 52,
                "column": 68
            },
            "line": 52,
            "code": "  test('when short flag followed by value then value is as specified', () => {\n    const program = createPortProgram();\n    program.parse('node test -p 80'.split(' '));\n    expect(program.opts().port).toBe('80');\n  });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when short flag concatenated with value then value is as specified",
            "suites": [
                "option with optional value"
            ],
            "updatePoint": {
                "line": 58,
                "column": 74
            },
            "line": 58,
            "code": "  test('when short flag concatenated with value then value is as specified', () => {\n    const program = createPortProgram();\n    program.parse('node test -p80'.split(' '));\n    expect(program.opts().port).toBe('80');\n  });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long flag followed by value then value is as specified",
            "suites": [
                "option with optional value"
            ],
            "updatePoint": {
                "line": 64,
                "column": 67
            },
            "line": 64,
            "code": "  test('when long flag followed by value then value is as specified', () => {\n    const program = createPortProgram();\n    program.parse('node test --port 80'.split(' '));\n    expect(program.opts().port).toBe('80');\n  });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long flag = value then value is as specified",
            "suites": [
                "option with optional value"
            ],
            "updatePoint": {
                "line": 70,
                "column": 57
            },
            "line": 70,
            "code": "  test('when long flag = value then value is as specified', () => {\n    const program = createPortProgram();\n    program.parse('node test --port=80'.split(' '));\n    expect(program.opts().port).toBe('80');\n  });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when long flag followed empty string then value is empty string",
            "suites": [
                "option with optional value"
            ],
            "updatePoint": {
                "line": 76,
                "column": 71
            },
            "line": 76,
            "code": "  test('when long flag followed empty string then value is empty string', () => {\n    const program = createPortProgram();\n    program\n      .option('-c, --cheese [type]', 'optionally specify the type of cheese');\n    program.parse(['node', 'test', '--cheese', '']);\n    expect(program.opts().cheese).toBe('');\n  });",
            "file": "options.values.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with value missing then error",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 4,
                "column": 51
            },
            "line": 4,
            "code": "  test('when variadic with value missing then error', () => {\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({ writeErr: jest.fn() })\n      .option('-r,--required <value...>');\n\n    expect(() => {\n      program.parse(['--required'], { from: 'user' });\n    }).toThrow();\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with one value then set in array",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 16,
                "column": 54
            },
            "line": 16,
            "code": "  test('when variadic with one value then set in array', () => {\n    const program = new commander.Command();\n    program\n      .option('-r,--required <value...>');\n\n    program.parse(['--required', 'one'], { from: 'user' });\n    expect(program.opts().required).toEqual(['one']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with two values then set in array",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 25,
                "column": 55
            },
            "line": 25,
            "code": "  test('when variadic with two values then set in array', () => {\n    const program = new commander.Command();\n    program\n      .option('-r,--required <value...>');\n\n    program.parse(['--required', 'one', 'two'], { from: 'user' });\n    expect(program.opts().required).toEqual(['one', 'two']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with repeated values then set in array",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 34,
                "column": 60
            },
            "line": 34,
            "code": "  test('when variadic with repeated values then set in array', () => {\n    const program = new commander.Command();\n    program\n      .option('-r,--required <value...>');\n\n    program.parse(['--required', 'one', '--required', 'two'], { from: 'user' });\n    expect(program.opts().required).toEqual(['one', 'two']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic used with choices and one value then set in array",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 43,
                "column": 71
            },
            "line": 43,
            "code": "  test('when variadic used with choices and one value then set in array', () => {\n    const program = new commander.Command();\n    program\n      .addOption(new commander.Option('-r,--required <value...>').choices(['one', 'two']));\n\n    program.parse(['--required', 'one'], { from: 'user' });\n    expect(program.opts().required).toEqual(['one']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic used with choices and two values then set in array",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 52,
                "column": 72
            },
            "line": 52,
            "code": "  test('when variadic used with choices and two values then set in array', () => {\n    const program = new commander.Command();\n    program\n      .addOption(new commander.Option('-r,--required <value...>').choices(['one', 'two']));\n\n    program.parse(['--required', 'one', 'two'], { from: 'user' });\n    expect(program.opts().required).toEqual(['one', 'two']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with short combined argument then not variadic",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 61,
                "column": 68
            },
            "line": 61,
            "code": "  test('when variadic with short combined argument then not variadic', () => {\n    const program = new commander.Command();\n    program\n      .option('-r,--required <value...>')\n      .argument('[arg]');\n\n    program.parse(['-rone', 'operand'], { from: 'user' });\n    expect(program.opts().required).toEqual(['one']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with long combined argument then not variadic",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 71,
                "column": 67
            },
            "line": 71,
            "code": "  test('when variadic with long combined argument then not variadic', () => {\n    const program = new commander.Command();\n    program\n      .option('-r,--required <value...>')\n      .argument('[arg]');\n\n    program.parse(['--required=one', 'operand'], { from: 'user' });\n    expect(program.opts().required).toEqual(['one']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with value followed by option then option not eaten",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 81,
                "column": 73
            },
            "line": 81,
            "code": "  test('when variadic with value followed by option then option not eaten', () => {\n    const program = new commander.Command();\n    program\n      .option('-r,--required <value...>')\n      .option('-f, --flag')\n      .argument('[arg]');\n\n    program.parse(['-r', 'one', '-f'], { from: 'user' });\n    const opts = program.opts();\n    expect(opts.required).toEqual(['one']);\n    expect(opts.flag).toBe(true);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with no value and default then set to default",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 94,
                "column": 67
            },
            "line": 94,
            "code": "  test('when variadic with no value and default then set to default', () => {\n    const program = new commander.Command();\n    program\n      .option('-r,--required <value...>', 'variadic description', 'default');\n\n    program.parse([], { from: 'user' });\n    expect(program.opts().required).toEqual('default');\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with coercion then coercion sets value",
            "suites": [
                "variadic option with required value"
            ],
            "updatePoint": {
                "line": 103,
                "column": 60
            },
            "line": 103,
            "code": "  test('when variadic with coercion then coercion sets value', () => {\n    const program = new commander.Command();\n    program\n      .option('-r,--required <value...>', 'variadic description', parseFloat);\n\n    // variadic processing reads the multiple values, but up to custom coercion what it does.\n    program.parse(['--required', '1e2', '1e3'], { from: 'user' });\n    expect(program.opts().required).toEqual(1000);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic not specified then value undefined",
            "suites": [
                "variadic option with optional value"
            ],
            "updatePoint": {
                "line": 116,
                "column": 56
            },
            "line": 116,
            "code": "  test('when variadic not specified then value undefined', () => {\n    const program = new commander.Command();\n    program\n      .option('-o,--optional [value...]');\n\n    program.parse([], { from: 'user' });\n    expect(program.opts().optional).toBeUndefined();\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic used as boolean flag then value true",
            "suites": [
                "variadic option with optional value"
            ],
            "updatePoint": {
                "line": 125,
                "column": 58
            },
            "line": 125,
            "code": "  test('when variadic used as boolean flag then value true', () => {\n    const program = new commander.Command();\n    program\n      .option('-o,--optional [value...]');\n\n    program.parse(['--optional'], { from: 'user' });\n    expect(program.opts().optional).toBe(true);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with one value then set in array",
            "suites": [
                "variadic option with optional value"
            ],
            "updatePoint": {
                "line": 134,
                "column": 54
            },
            "line": 134,
            "code": "  test('when variadic with one value then set in array', () => {\n    const program = new commander.Command();\n    program\n      .option('-o,--optional [value...]');\n\n    program.parse(['--optional', 'one'], { from: 'user' });\n    expect(program.opts().optional).toEqual(['one']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when variadic with two values then set in array",
            "suites": [
                "variadic option with optional value"
            ],
            "updatePoint": {
                "line": 143,
                "column": 55
            },
            "line": 143,
            "code": "  test('when variadic with two values then set in array', () => {\n    const program = new commander.Command();\n    program\n      .option('-o,--optional [value...]');\n\n    program.parse(['--optional', 'one', 'two'], { from: 'user' });\n    expect(program.opts().optional).toEqual(['one', 'two']);\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option flags has word character before dots then is variadic",
            "suites": [
                "variadic special cases"
            ],
            "updatePoint": {
                "line": 154,
                "column": 73
            },
            "line": 154,
            "code": "  test('when option flags has word character before dots then is variadic', () => {\n    const program = new commander.Command();\n    program\n      .option('-c,--comma [value...]');\n\n    expect(program.options[0].variadic).toBeTruthy();\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when option flags has special characters before dots then not variadic",
            "suites": [
                "variadic special cases"
            ],
            "updatePoint": {
                "line": 162,
                "column": 78
            },
            "line": 162,
            "code": "  test('when option flags has special characters before dots then not variadic', () => {\n    // This might be used to describe coercion for comma separated values, and is not variadic.\n    const program = new commander.Command();\n    program\n      .option('-c,--comma [value,...]');\n\n    expect(program.options[0].variadic).toBeFalsy();\n  });",
            "file": "options.variadic.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no .version and specify --version then unknown option error",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 6,
                "column": 72
            },
            "line": 6,
            "code": "  test('when no .version and specify --version then unknown option error', () => {\n    const errorMessage = 'unknownOption';\n    const program = new commander.Command();\n    // Override unknownOption as convenient way to check fails as expected.\n    jest.spyOn(program, 'unknownOption').mockImplementation(() => { throw new Error(errorMessage); });\n\n    expect(() => {\n      program.parse(['node', 'test', '--version']);\n    }).toThrow(errorMessage);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when no .version then helpInformation does not include version",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 17,
                "column": 70
            },
            "line": 17,
            "code": "  test('when no .version then helpInformation does not include version', () => {\n    const program = new commander.Command();\n\n    const helpInformation = program.helpInformation();\n\n    expect(helpInformation.includes('Usage')).toBe(true);\n    expect(helpInformation.includes('version')).toBe(false);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify default short flag then display version",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 26,
                "column": 60
            },
            "line": 26,
            "code": "  test('when specify default short flag then display version', () => {\n    const myVersion = '1.2.3';\n    const writeMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({ writeOut: writeMock })\n      .version(myVersion);\n\n    expect(() => {\n      program.parse(['node', 'test', '-V']);\n    }).toThrow(myVersion);\n    expect(writeMock).toHaveBeenCalledWith(`${myVersion}\\n`);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify default long flag then display version",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 41,
                "column": 59
            },
            "line": 41,
            "code": "  test('when specify default long flag then display version', () => {\n    const myVersion = '1.2.3';\n    const writeMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({ writeOut: writeMock })\n      .version(myVersion);\n\n    expect(() => {\n      program.parse(['node', 'test', '--version']);\n    }).toThrow(myVersion);\n    expect(writeMock).toHaveBeenCalledWith(`${myVersion}\\n`);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when default .version then helpInformation includes default version help",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 56,
                "column": 80
            },
            "line": 56,
            "code": "  test('when default .version then helpInformation includes default version help', () => {\n    const myVersion = '1.2.3';\n    const program = new commander.Command();\n    program\n      .version(myVersion);\n\n    const helpInformation = program.helpInformation();\n\n    expect(helpInformation.includes('-V, --version')).toBe(true);\n    expect(helpInformation.includes('output the version number')).toBe(true);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify custom short flag then display version",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 68,
                "column": 59
            },
            "line": 68,
            "code": "  test('when specify custom short flag then display version', () => {\n    const myVersion = '1.2.3';\n    const writeMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({ writeOut: writeMock })\n      .version(myVersion, '-r, --revision');\n\n    expect(() => {\n      program.parse(['node', 'test', '-r']);\n    }).toThrow(myVersion);\n    expect(writeMock).toHaveBeenCalledWith(`${myVersion}\\n`);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify just custom short flag then display version",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 83,
                "column": 64
            },
            "line": 83,
            "code": "  test('when specify just custom short flag then display version', () => {\n    const myVersion = '1.2.3';\n    const writeMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({ writeOut: writeMock })\n      .version(myVersion, '-r');\n\n    expect(() => {\n      program.parse(['node', 'test', '-r']);\n    }).toThrow(myVersion);\n    expect(writeMock).toHaveBeenCalledWith(`${myVersion}\\n`);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify custom long flag then display version",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 98,
                "column": 58
            },
            "line": 98,
            "code": "  test('when specify custom long flag then display version', () => {\n    const myVersion = '1.2.3';\n    const writeMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({ writeOut: writeMock })\n      .version(myVersion, '-r, --revision');\n\n    expect(() => {\n      program.parse(['node', 'test', '--revision']);\n    }).toThrow(myVersion);\n    expect(writeMock).toHaveBeenCalledWith(`${myVersion}\\n`);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify just custom long flag then display version",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 113,
                "column": 63
            },
            "line": 113,
            "code": "  test('when specify just custom long flag then display version', () => {\n    const myVersion = '1.2.3';\n    const writeMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({ writeOut: writeMock })\n      .version(myVersion, '--revision');\n\n    expect(() => {\n      program.parse(['node', 'test', '--revision']);\n    }).toThrow(myVersion);\n    expect(writeMock).toHaveBeenCalledWith(`${myVersion}\\n`);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when custom .version then helpInformation includes custom version help",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 128,
                "column": 78
            },
            "line": 128,
            "code": "  test('when custom .version then helpInformation includes custom version help', () => {\n    const myVersion = '1.2.3';\n    const myVersionFlags = '-r, --revision';\n    const myVersionDescription = 'custom description';\n    const program = new commander.Command();\n    program\n      .version(myVersion, myVersionFlags, myVersionDescription);\n\n    const helpInformation = program.helpInformation();\n\n    expect(helpInformation.includes(myVersionFlags)).toBe(true);\n    expect(helpInformation.includes(myVersionDescription)).toBe(true);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when have .version+version and specify version then command called",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 142,
                "column": 74
            },
            "line": 142,
            "code": "  test('when have .version+version and specify version then command called', () => {\n    const actionMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .version('1.2.3')\n      .command('version')\n      .action(actionMock);\n\n    program.parse(['node', 'test', 'version']);\n\n    expect(actionMock).toHaveBeenCalled();\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when have .version+version and specify --version then version displayed",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 155,
                "column": 79
            },
            "line": 155,
            "code": "  test('when have .version+version and specify --version then version displayed', () => {\n    const myVersion = '1.2.3';\n    const writeMock = jest.fn();\n    const program = new commander.Command();\n    program\n      .exitOverride()\n      .configureOutput({ writeOut: writeMock })\n      .version(myVersion)\n      .command('version')\n      .action(() => {});\n\n    expect(() => {\n      program.parse(['node', 'test', '--version']);\n    }).toThrow(myVersion);\n    expect(writeMock).toHaveBeenCalledWith(`${myVersion}\\n`);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when specify version then can get version",
            "suites": [
                ".version"
            ],
            "updatePoint": {
                "line": 172,
                "column": 49
            },
            "line": 172,
            "code": "  test('when specify version then can get version', () => {\n    const myVersion = '1.2.3';\n    const program = new commander.Command();\n    program.version(myVersion);\n    expect(program.version()).toEqual(myVersion);\n  });",
            "file": "options.version.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when require commander then is a Command (default export of global)",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 73
            },
            "line": 5,
            "code": "test('when require commander then is a Command (default export of global)', () => {\n  // Deprecated global command\n  const program = commander;\n  expect(program.constructor.name).toBe('Command');\n});",
            "file": "program.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when require commander then has program (named export of global)",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 70
            },
            "line": 11,
            "code": "test('when require commander then has program (named export of global)', () => {\n  // program added in v5\n  const program = commander.program;\n  expect(program.constructor.name).toBe('Command');\n});",
            "file": "program.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "when require commander then has newable Command",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 53
            },
            "line": 17,
            "code": "test('when require commander then has newable Command', () => {\n  const cmd = new commander.Command();\n  expect(cmd.constructor.name).toBe('Command');\n});",
            "file": "program.test.js",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "legacy default export of global Command",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 45
            },
            "line": 14,
            "code": "test('legacy default export of global Command', () => {\n  checkClass(commander, 'Command');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "program",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 13
            },
            "line": 18,
            "code": "test('program', () => {\n  checkClass(program, 'Command');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "createCommand",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 19
            },
            "line": 22,
            "code": "test('createCommand', () => {\n  checkClass(createCommand(), 'Command');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "Command",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 13
            },
            "line": 26,
            "code": "test('Command', () => {\n  checkClass(new Command('name'), 'Command');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "Option",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 12
            },
            "line": 30,
            "code": "test('Option', () => {\n  checkClass(new Option('-e, --example', 'description'), 'Option');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "CommanderError",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 20
            },
            "line": 34,
            "code": "test('CommanderError', () => {\n  checkClass(new CommanderError(1, 'code', 'failed'), 'CommanderError');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "InvalidArgumentError",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 26
            },
            "line": 38,
            "code": "test('InvalidArgumentError', () => {\n  checkClass(new InvalidArgumentError('failed'), 'InvalidArgumentError');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "InvalidOptionArgumentError",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 32
            },
            "line": 42,
            "code": "test('InvalidOptionArgumentError', () => { // Deprecated\n  checkClass(new InvalidOptionArgumentError('failed'), 'InvalidArgumentError');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        },
        {
            "name": "Help",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 10
            },
            "line": 47,
            "code": "test('Help', () => {\n  checkClass(new Help(), 'Help');\n});",
            "file": "ts-imports.test.ts",
            "skipped": false,
            "dir": "tests"
        }
    ],
    "badge": "tj__commander_js.svg"
}