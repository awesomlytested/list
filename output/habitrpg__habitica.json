{"repo":"HabitRPG/habitica","url":"https://github.com/HabitRPG/habitica","branch":"develop","configs":[{"package":"habitica","lang":"js","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"habitica-client","lang":"js","dir":"website/client/tests","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"returns mock methods when not in production","suites":["analyticsService","#getServiceByEnvironment"],"updatePoint":{"line":16,"column":51,"index":611},"line":16,"code":"    it('returns mock methods when not in production', () => {\n      sandbox.stub(nconf, 'get').withArgs('IS_PROD').returns(false);\n      expect(analyticsService.getAnalyticsServiceByEnvironment()).to.equal(analyticsService.mockAnalyticsService);\n    });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"returns real methods when in production","suites":["analyticsService","#getServiceByEnvironment"],"updatePoint":{"line":20,"column":47,"index":861},"line":20,"code":"    it('returns real methods when in production', () => {\n      sandbox.stub(nconf, 'get').withArgs('IS_PROD').returns(true);\n      expect(analyticsService.getAnalyticsServiceByEnvironment().track).to.equal(analyticsService.track);\n      expect(analyticsService.getAnalyticsServiceByEnvironment().trackPurchase).to.equal(analyticsService.trackPurchase);\n    });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"calls out to amplitude","suites":["analyticsService","#track","Amplitude"],"updatePoint":{"line":44,"column":32,"index":1631},"line":44,"code":"      it('calls out to amplitude', () => analyticsService.track(eventType, data).then(() => {\n        expect(Amplitude.prototype.track).to.be.calledOnce;\n      }));","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"uses a dummy user id if none is provided","suites":["analyticsService","#track","Amplitude"],"updatePoint":{"line":47,"column":50,"index":1814},"line":47,"code":"      it('uses a dummy user id if none is provided', () => {\n        delete data.uuid;\n        return analyticsService.track(eventType, data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            user_id: 'no-user-id-was-provided'\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs web platform","suites":["analyticsService","#track","Amplitude","platform"],"updatePoint":{"line":56,"column":29,"index":2133},"line":56,"code":"        it('logs web platform', () => {\n          data.headers = {\n            'x-client': 'habitica-web'\n          };\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: 'Web'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs iOS platform","suites":["analyticsService","#track","Amplitude","platform"],"updatePoint":{"line":66,"column":29,"index":2464},"line":66,"code":"        it('logs iOS platform', () => {\n          data.headers = {\n            'x-client': 'habitica-ios'\n          };\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: 'iOS'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs Android platform","suites":["analyticsService","#track","Amplitude","platform"],"updatePoint":{"line":76,"column":33,"index":2799},"line":76,"code":"        it('logs Android platform', () => {\n          data.headers = {\n            'x-client': 'habitica-android'\n          };\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: 'Android'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs 3rd Party platform","suites":["analyticsService","#track","Amplitude","platform"],"updatePoint":{"line":86,"column":35,"index":3144},"line":86,"code":"        it('logs 3rd Party platform', () => {\n          data.headers = {\n            'x-client': 'some-third-party'\n          };\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: '3rd Party'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs unknown if headers are not passed in","suites":["analyticsService","#track","Amplitude","platform"],"updatePoint":{"line":96,"column":53,"index":3509},"line":96,"code":"        it('logs unknown if headers are not passed in', () => {\n          delete data.headers;\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: 'Unknown'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sets default","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":106,"column":24,"index":3843},"line":106,"code":"        it('sets default', () => {\n          data.headers = {\n            'x-client': 'third-party',\n            'user-agent': 'foo'\n          };\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              os_name: 'Other',\n              os_version: '0'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sets iOS","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":118,"column":20,"index":4229},"line":118,"code":"        it('sets iOS', () => {\n          data.headers = {\n            'x-client': 'habitica-ios',\n            'user-agent': 'Habitica/148 (iPhone; iOS 9.3; Scale/2.00)'\n          };\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              os_name: 'iOS',\n              os_version: '9.3.0'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sets Android","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":130,"column":24,"index":4661},"line":130,"code":"        it('sets Android', () => {\n          data.headers = {\n            'x-client': 'habitica-android',\n            'user-agent': 'Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19'\n          };\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              os_name: 'Android',\n              os_version: '4.0.4'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sets Unknown if headers are not passed in","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":142,"column":53,"index":5230},"line":142,"code":"        it('sets Unknown if headers are not passed in', () => {\n          delete data.headers;\n          return analyticsService.track(eventType, data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              os_name: undefined,\n              os_version: undefined\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends details about event","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":152,"column":35,"index":5569},"line":152,"code":"      it('sends details about event', () => analyticsService.track(eventType, data).then(() => {\n        expect(Amplitude.prototype.track).to.be.calledWithMatch({\n          event_properties: {\n            category: 'behavior',\n            resting: true,\n            cronCount: 5\n          }\n        });\n      }));","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends english item name for gear if itemKey is provided","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":161,"column":65,"index":5913},"line":161,"code":"      it('sends english item name for gear if itemKey is provided', () => {\n        data.itemKey = 'headAccessory_special_foxEars';\n        return analyticsService.track(eventType, data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            event_properties: {\n              itemKey: data.itemKey,\n              itemName: 'Fox Ears'\n            }\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends english item name for egg if itemKey is provided","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":172,"column":64,"index":6334},"line":172,"code":"      it('sends english item name for egg if itemKey is provided', () => {\n        data.itemKey = 'Wolf';\n        return analyticsService.track(eventType, data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            event_properties: {\n              itemKey: data.itemKey,\n              itemName: 'Wolf Egg'\n            }\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends english item name for food if itemKey is provided","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":183,"column":65,"index":6731},"line":183,"code":"      it('sends english item name for food if itemKey is provided', () => {\n        data.itemKey = 'Cake_Skeleton';\n        return analyticsService.track(eventType, data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            event_properties: {\n              itemKey: data.itemKey,\n              itemName: 'Bare Bones Cake'\n            }\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends english item name for hatching potion if itemKey is provided","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":194,"column":76,"index":7155},"line":194,"code":"      it('sends english item name for hatching potion if itemKey is provided', () => {\n        data.itemKey = 'Golden';\n        return analyticsService.track(eventType, data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            event_properties: {\n              itemKey: data.itemKey,\n              itemName: 'Golden Hatching Potion'\n            }\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends english item name for quest if itemKey is provided","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":205,"column":66,"index":7569},"line":205,"code":"      it('sends english item name for quest if itemKey is provided', () => {\n        data.itemKey = 'atom1';\n        return analyticsService.track(eventType, data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            event_properties: {\n              itemKey: data.itemKey,\n              itemName: 'Attack of the Mundane, Part 1: Dish Disaster!'\n            }\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends english item name for purchased spell if itemKey is provided","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":216,"column":76,"index":8015},"line":216,"code":"      it('sends english item name for purchased spell if itemKey is provided', () => {\n        data.itemKey = 'seafoam';\n        return analyticsService.track(eventType, data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            event_properties: {\n              itemKey: data.itemKey,\n              itemName: 'Seafoam'\n            }\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends user data if provided","suites":["analyticsService","#track","Amplitude","Operating System"],"updatePoint":{"line":227,"column":37,"index":8386},"line":227,"code":"      it('sends user data if provided', () => {\n        const stats = {\n          class: 'wizard',\n          exp: 5,\n          gp: 23,\n          hp: 10,\n          lvl: 4,\n          mp: 30\n        };\n        const user = {\n          stats,\n          contributor: {\n            level: 1\n          },\n          purchased: {\n            plan: {\n              planId: 'foo-plan'\n            }\n          },\n          flags: {\n            tour: {\n              intro: -2\n            }\n          },\n          habits: [{\n            _id: 'habit'\n          }],\n          dailys: [{\n            _id: 'daily'\n          }],\n          todos: [{\n            _id: 'todo'\n          }],\n          rewards: [{\n            _id: 'reward'\n          }],\n          balance: 12,\n          loginIncentives: 1\n        };\n        data.user = user;\n        return analyticsService.track(eventType, data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            user_properties: {\n              Class: 'wizard',\n              Experience: 5,\n              Gold: 23,\n              Health: 10,\n              Level: 4,\n              Mana: 30,\n              tutorialComplete: true,\n              'Number Of Tasks': {\n                habits: 1,\n                dailys: 1,\n                todos: 1,\n                rewards: 1\n              },\n              contributorLevel: 1,\n              subscription: 'foo-plan',\n              balance: 12,\n              balanceGemAmount: 48,\n              loginIncentives: 1\n            }\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"calls out to GA","suites":["analyticsService","#track","GA"],"updatePoint":{"line":294,"column":25,"index":9971},"line":294,"code":"      it('calls out to GA', () => analyticsService.track(eventType, data).then(() => {\n        expect(Visitor.prototype.event).to.be.calledOnce;\n      }));","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends details about event","suites":["analyticsService","#track","GA"],"updatePoint":{"line":297,"column":35,"index":10137},"line":297,"code":"      it('sends details about event', () => analyticsService.track(eventType, data).then(() => {\n        expect(Visitor.prototype.event).to.be.calledWith({\n          ea: 'Cron',\n          ec: 'behavior'\n        });\n      }));","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"calls out to amplitude","suites":["analyticsService","#trackPurchase","Amplitude"],"updatePoint":{"line":331,"column":32,"index":11050},"line":331,"code":"      it('calls out to amplitude', () => analyticsService.trackPurchase(data).then(() => {\n        expect(Amplitude.prototype.track).to.be.calledOnce;\n      }));","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"uses a dummy user id if none is provided","suites":["analyticsService","#trackPurchase","Amplitude"],"updatePoint":{"line":334,"column":50,"index":11230},"line":334,"code":"      it('uses a dummy user id if none is provided', () => {\n        delete data.uuid;\n        return analyticsService.trackPurchase(data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            user_id: 'no-user-id-was-provided'\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs web platform","suites":["analyticsService","#trackPurchase","Amplitude","platform"],"updatePoint":{"line":343,"column":29,"index":11546},"line":343,"code":"        it('logs web platform', () => {\n          data.headers = {\n            'x-client': 'habitica-web'\n          };\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: 'Web'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs iOS platform","suites":["analyticsService","#trackPurchase","Amplitude","platform"],"updatePoint":{"line":353,"column":29,"index":11874},"line":353,"code":"        it('logs iOS platform', () => {\n          data.headers = {\n            'x-client': 'habitica-ios'\n          };\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: 'iOS'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs Android platform","suites":["analyticsService","#trackPurchase","Amplitude","platform"],"updatePoint":{"line":363,"column":33,"index":12206},"line":363,"code":"        it('logs Android platform', () => {\n          data.headers = {\n            'x-client': 'habitica-android'\n          };\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: 'Android'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs 3rd Party platform","suites":["analyticsService","#trackPurchase","Amplitude","platform"],"updatePoint":{"line":373,"column":35,"index":12548},"line":373,"code":"        it('logs 3rd Party platform', () => {\n          data.headers = {\n            'x-client': 'some-third-party'\n          };\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: '3rd Party'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"logs unknown if headers are not passed in","suites":["analyticsService","#trackPurchase","Amplitude","platform"],"updatePoint":{"line":383,"column":53,"index":12910},"line":383,"code":"        it('logs unknown if headers are not passed in', () => {\n          delete data.headers;\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              platform: 'Unknown'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sets default","suites":["analyticsService","#trackPurchase","Amplitude","Operating System"],"updatePoint":{"line":393,"column":24,"index":13241},"line":393,"code":"        it('sets default', () => {\n          data.headers = {\n            'x-client': 'third-party',\n            'user-agent': 'foo'\n          };\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              os_name: 'Other',\n              os_version: '0'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sets iOS","suites":["analyticsService","#trackPurchase","Amplitude","Operating System"],"updatePoint":{"line":405,"column":20,"index":13624},"line":405,"code":"        it('sets iOS', () => {\n          data.headers = {\n            'x-client': 'habitica-ios',\n            'user-agent': 'Habitica/148 (iPhone; iOS 9.3; Scale/2.00)'\n          };\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              os_name: 'iOS',\n              os_version: '9.3.0'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sets Android","suites":["analyticsService","#trackPurchase","Amplitude","Operating System"],"updatePoint":{"line":417,"column":24,"index":14053},"line":417,"code":"        it('sets Android', () => {\n          data.headers = {\n            'x-client': 'habitica-android',\n            'user-agent': 'Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19'\n          };\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              os_name: 'Android',\n              os_version: '4.0.4'\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sets Unknown if headers are not passed in","suites":["analyticsService","#trackPurchase","Amplitude","Operating System"],"updatePoint":{"line":429,"column":53,"index":14619},"line":429,"code":"        it('sets Unknown if headers are not passed in', () => {\n          delete data.headers;\n          return analyticsService.trackPurchase(data).then(() => {\n            expect(Amplitude.prototype.track).to.be.calledWithMatch({\n              os_name: undefined,\n              os_version: undefined\n            });\n          });\n        });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends details about purchase","suites":["analyticsService","#trackPurchase","Amplitude","Operating System"],"updatePoint":{"line":439,"column":38,"index":14958},"line":439,"code":"      it('sends details about purchase', () => analyticsService.trackPurchase(data).then(() => {\n        expect(Amplitude.prototype.track).to.be.calledWithMatch({\n          event_properties: {\n            gift: false,\n            itemPurchased: 'Gems',\n            paymentMethod: 'PayPal',\n            purchaseType: 'checkout',\n            quantity: 1,\n            sku: 'paypal-checkout'\n          }\n        });\n      }));","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends user data if provided","suites":["analyticsService","#trackPurchase","Amplitude","Operating System"],"updatePoint":{"line":451,"column":37,"index":15380},"line":451,"code":"      it('sends user data if provided', () => {\n        const stats = {\n          class: 'wizard',\n          exp: 5,\n          gp: 23,\n          hp: 10,\n          lvl: 4,\n          mp: 30\n        };\n        const user = {\n          stats,\n          contributor: {\n            level: 1\n          },\n          purchased: {\n            plan: {\n              planId: 'foo-plan'\n            }\n          },\n          flags: {\n            tour: {\n              intro: -2\n            }\n          },\n          habits: [{\n            _id: 'habit'\n          }],\n          dailys: [{\n            _id: 'daily'\n          }],\n          todos: [{\n            _id: 'todo'\n          }],\n          rewards: [{\n            _id: 'reward'\n          }]\n        };\n        data.user = user;\n        return analyticsService.trackPurchase(data).then(() => {\n          expect(Amplitude.prototype.track).to.be.calledWithMatch({\n            user_properties: {\n              Class: 'wizard',\n              Experience: 5,\n              Gold: 23,\n              Health: 10,\n              Level: 4,\n              Mana: 30,\n              tutorialComplete: true,\n              'Number Of Tasks': {\n                habits: 1,\n                dailys: 1,\n                todos: 1,\n                rewards: 1\n              },\n              contributorLevel: 1,\n              subscription: 'foo-plan'\n            }\n          });\n        });\n      });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"calls out to GA","suites":["analyticsService","#trackPurchase","GA"],"updatePoint":{"line":513,"column":25,"index":16812},"line":513,"code":"      it('calls out to GA', () => analyticsService.trackPurchase(data).then(() => {\n        expect(Visitor.prototype.event).to.be.calledOnce;\n        expect(Visitor.prototype.transaction).to.be.calledOnce;\n      }));","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"sends details about purchase","suites":["analyticsService","#trackPurchase","GA"],"updatePoint":{"line":517,"column":38,"index":17042},"line":517,"code":"      it('sends details about purchase', () => analyticsService.trackPurchase(data).then(() => {\n        expect(Visitor.prototype.event).to.be.calledWith({\n          ea: 'checkout',\n          ec: 'commerce',\n          el: 'PayPal',\n          ev: 8\n        });\n        expect(Visitor.prototype.transaction).to.be.calledWith('user-id', 8);\n        expect(itemSpy).to.be.calledWith(8, 1, 'paypal-checkout', 'Gems', 'checkout');\n      }));","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"has stubbed track method","suites":["analyticsService","mockAnalyticsService"],"updatePoint":{"line":530,"column":32,"index":17529},"line":530,"code":"    it('has stubbed track method', () => {\n      expect(analyticsService.mockAnalyticsService).to.respondTo('track');\n    });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"has stubbed trackPurchase method","suites":["analyticsService","mockAnalyticsService"],"updatePoint":{"line":533,"column":40,"index":17663},"line":533,"code":"    it('has stubbed trackPurchase method', () => {\n      expect(analyticsService.mockAnalyticsService).to.respondTo('trackPurchase');\n    });","file":"api/unit/libs/analyticsService.test.js","skipped":false,"dir":"test"},{"name":"throws if \"typeKey\" is not set to $type","suites":["Base model plugin"],"updatePoint":{"line":11,"column":45,"index":328},"line":11,"code":"  it('throws if \"typeKey\" is not set to $type', () => {\n    const schemaWithoutTypeKey = new mongoose.Schema();\n    expect(() => schemaWithoutTypeKey.plugin(baseModel)).to.throw;\n  });","file":"api/unit/libs/baseModel.test.js","skipped":false,"dir":"test"},{"name":"adds a _id field to the schema","suites":["Base model plugin"],"updatePoint":{"line":15,"column":36,"index":504},"line":15,"code":"  it('adds a _id field to the schema', () => {\n    schema.plugin(baseModel);\n    expect(schema.add).to.be.calledWith(sinon.match({\n      _id: sinon.match.object\n    }));\n  });","file":"api/unit/libs/baseModel.test.js","skipped":false,"dir":"test"},{"name":"can add timestamps fields","suites":["Base model plugin"],"updatePoint":{"line":21,"column":31,"index":675},"line":21,"code":"  it('can add timestamps fields', () => {\n    schema.plugin(baseModel, {\n      timestamps: true\n    });\n    expect(schema.add).to.be.calledTwice;\n  });","file":"api/unit/libs/baseModel.test.js","skipped":false,"dir":"test"},{"name":"can sanitize input objects","suites":["Base model plugin"],"updatePoint":{"line":27,"column":32,"index":828},"line":27,"code":"  it('can sanitize input objects', () => {\n    schema.plugin(baseModel, {\n      noSet: ['noUpdateForMe']\n    });\n    expect(schema.statics.sanitize).to.exist;\n    const sanitized = schema.statics.sanitize({\n      ok: true,\n      noUpdateForMe: true\n    });\n    expect(sanitized).to.have.property('ok');\n    expect(sanitized).not.to.have.property('noUpdateForMe');\n    expect(sanitized.noUpdateForMe).to.equal(undefined);\n  });","file":"api/unit/libs/baseModel.test.js","skipped":false,"dir":"test"},{"name":"accepts an array of additional fields to sanitize at runtime","suites":["Base model plugin"],"updatePoint":{"line":40,"column":66,"index":1289},"line":40,"code":"  it('accepts an array of additional fields to sanitize at runtime', () => {\n    schema.plugin(baseModel, {\n      noSet: ['noUpdateForMe']\n    });\n    expect(schema.statics.sanitize).to.exist;\n    const sanitized = schema.statics.sanitize({\n      ok: true,\n      noUpdateForMe: true,\n      usuallySettable: true\n    }, ['usuallySettable']);\n    expect(sanitized).to.have.property('ok');\n    expect(sanitized).not.to.have.property('noUpdateForMe');\n    expect(sanitized).not.to.have.property('usuallySettable');\n  });","file":"api/unit/libs/baseModel.test.js","skipped":false,"dir":"test"},{"name":"can make fields private","suites":["Base model plugin"],"updatePoint":{"line":54,"column":29,"index":1769},"line":54,"code":"  it('can make fields private', () => {\n    schema.plugin(baseModel, {\n      private: ['amPrivate']\n    });\n    expect(schema.options.toJSON.transform).to.exist;\n    const objToTransform = {\n      ok: true,\n      amPrivate: true\n    };\n    const privatized = schema.options.toJSON.transform({}, objToTransform);\n    expect(privatized).to.have.property('ok');\n    expect(privatized).not.to.have.property('amPrivate');\n  });","file":"api/unit/libs/baseModel.test.js","skipped":false,"dir":"test"},{"name":"accepts a further transform function for toJSON","suites":["Base model plugin"],"updatePoint":{"line":67,"column":53,"index":2216},"line":67,"code":"  it('accepts a further transform function for toJSON', () => {\n    const options = {\n      private: ['amPrivate'],\n      toJSONTransform: sandbox.stub().returns(true)\n    };\n    schema.plugin(baseModel, options);\n    const objToTransform = {\n      ok: true,\n      amPrivate: true\n    };\n    const doc = {\n      doc: true\n    };\n    const privatized = schema.options.toJSON.transform(doc, objToTransform);\n    expect(privatized).to.equals(true);\n    expect(options.toJSONTransform).to.be.calledWith(objToTransform, doc);\n  });","file":"api/unit/libs/baseModel.test.js","skipped":false,"dir":"test"},{"name":"accepts a transform function for sanitize","suites":["Base model plugin"],"updatePoint":{"line":84,"column":47,"index":2737},"line":84,"code":"  it('accepts a transform function for sanitize', () => {\n    const options = {\n      private: ['amPrivate'],\n      sanitizeTransform: sandbox.stub().returns(true)\n    };\n    schema.plugin(baseModel, options);\n    expect(schema.options.toJSON.transform).to.exist;\n    const objToSanitize = {\n      ok: true,\n      noUpdateForMe: true\n    };\n    const sanitized = schema.statics.sanitize(objToSanitize);\n    expect(sanitized).to.equals(true);\n    expect(options.sanitizeTransform).to.be.calledWith(objToSanitize);\n  });","file":"api/unit/libs/baseModel.test.js","skipped":false,"dir":"test"},{"name":"sends a mail using sendTxn","suites":["bug-report"],"updatePoint":{"line":15,"column":32,"index":589},"line":15,"code":"  it('sends a mail using sendTxn', async () => {\n    const userId = '2b58daeb-bc50-4a83-b5d3-4ac52c7c0608';\n    const userMail = 'me@me.com';\n    const userMessage = 'The power is over 9000, please fix it';\n    const userAgent = 'The UserAgent with a bunch of weird browser engine levels';\n    const user = generateUser({\n      _id: userId\n    });\n    const result = await bugReportLogic(user, userMail, userMessage, userAgent);\n    expect(emailLib.sendTxn).to.be.called;\n    expect(result).to.deep.equal({\n      sendMailResult: undefined,\n      emailData: {\n        BROWSER_UA: userAgent,\n        REPORT_MSG: userMessage,\n        USER_CLASS: 'warrior',\n        USER_CONSECUTIVE_MONTHS: 0,\n        USER_COSTUME: 'false',\n        USER_CUSTOMER_ID: undefined,\n        USER_CUSTOM_DAY: 0,\n        USER_DAILIES_PAUSED: 'false',\n        USER_EMAIL: userMail,\n        USER_HOURGLASSES: 0,\n        USER_ID: userId,\n        USER_LEVEL: 1,\n        USER_OFFSET_MONTHS: 0,\n        USER_PAYMENT_PLATFORM: undefined,\n        USER_SUBSCRIPTION: undefined,\n        USER_TIMEZONE_OFFSET: 0,\n        USER_USERNAME: undefined\n      }\n    });\n  });","file":"api/unit/libs/bug-report.test.js","skipped":false,"dir":"test"},{"name":"removes element from array","suites":["Collection Manipulators","removeFromArray"],"updatePoint":{"line":5,"column":34,"index":240},"line":5,"code":"    it('removes element from array', () => {\n      const array = ['a', 'b', 'c', 'd'];\n      removeFromArray(array, 'c');\n      expect(array).to.not.include('c');\n    });","file":"api/unit/libs/collectionManipulators.test.js","skipped":false,"dir":"test"},{"name":"removes object from array","suites":["Collection Manipulators","removeFromArray"],"updatePoint":{"line":10,"column":33,"index":410},"line":10,"code":"    it('removes object from array', () => {\n      const array = [{\n        id: 'a',\n        foo: 'bar'\n      }, {\n        id: 'b',\n        foo: 'bar'\n      }, {\n        id: 'c',\n        foo: 'bar'\n      }, {\n        id: 'd',\n        foo: 'bar'\n      }, {\n        id: 'e',\n        foo: 'bar'\n      }];\n      removeFromArray(array, {\n        id: 'c'\n      });\n      expect(array).to.not.include({\n        id: 'c',\n        foo: 'bar'\n      });\n    });","file":"api/unit/libs/collectionManipulators.test.js","skipped":false,"dir":"test"},{"name":"does not change array if value is not found","suites":["Collection Manipulators","removeFromArray"],"updatePoint":{"line":35,"column":51,"index":877},"line":35,"code":"    it('does not change array if value is not found', () => {\n      const array = ['a', 'b', 'c', 'd'];\n      removeFromArray(array, 'z');\n      expect(array).to.have.a.lengthOf(4);\n      expect(array[0]).to.eql('a');\n      expect(array[1]).to.eql('b');\n      expect(array[2]).to.eql('c');\n      expect(array[3]).to.eql('d');\n    });","file":"api/unit/libs/collectionManipulators.test.js","skipped":false,"dir":"test"},{"name":"returns the removed element","suites":["Collection Manipulators","removeFromArray"],"updatePoint":{"line":44,"column":35,"index":1195},"line":44,"code":"    it('returns the removed element', () => {\n      const array = ['a', 'b', 'c'];\n      const result = removeFromArray(array, 'b');\n      expect(result).to.eql('b');\n    });","file":"api/unit/libs/collectionManipulators.test.js","skipped":false,"dir":"test"},{"name":"returns the removed object element","suites":["Collection Manipulators","removeFromArray"],"updatePoint":{"line":49,"column":42,"index":1377},"line":49,"code":"    it('returns the removed object element', () => {\n      const array = [{\n        id: 'a',\n        foo: 'bar'\n      }, {\n        id: 'b',\n        foo: 'bar'\n      }, {\n        id: 'c',\n        foo: 'bar'\n      }, {\n        id: 'd',\n        foo: 'bar'\n      }, {\n        id: 'e',\n        foo: 'bar'\n      }];\n      const result = removeFromArray(array, {\n        id: 'c'\n      });\n      expect(result).to.eql({\n        id: 'c',\n        foo: 'bar'\n      });\n    });","file":"api/unit/libs/collectionManipulators.test.js","skipped":false,"dir":"test"},{"name":"returns false if item is not found","suites":["Collection Manipulators","removeFromArray"],"updatePoint":{"line":74,"column":42,"index":1843},"line":74,"code":"    it('returns false if item is not found', () => {\n      const array = ['a', 'b', 'c'];\n      const result = removeFromArray(array, 'z');\n      expect(result).to.eql(false);\n    });","file":"api/unit/libs/collectionManipulators.test.js","skipped":false,"dir":"test"},{"name":"persists removal of element when mongoose document is saved","suites":["Collection Manipulators","removeFromArray"],"updatePoint":{"line":79,"column":67,"index":2052},"line":79,"code":"    it('persists removal of element when mongoose document is saved', async () => {\n      const schema = new mongoose.Schema({\n        array: Array\n      });\n      const Model = mongoose.model('ModelToTestRemoveFromArray', schema);\n      const model = await new Model({\n        array: ['a', 'b', 'c']\n      }).save(); // Initial creation\n\n      removeFromArray(model.array, 'b');\n      const savedModel = await model.save();\n      expect(savedModel.array).to.not.include('b');\n    });","file":"api/unit/libs/collectionManipulators.test.js","skipped":false,"dir":"test"},{"name":"exports CONTENT_CACHE_PATH","suites":["contentLib","CONTENT_CACHE_PATH"],"updatePoint":{"line":5,"column":34,"index":243},"line":5,"code":"    it('exports CONTENT_CACHE_PATH', () => {\n      expect(contentLib.CONTENT_CACHE_PATH).to.be.a.string;\n    });","file":"api/unit/libs/content.test.js","skipped":false,"dir":"test"},{"name":"clones, not modify, the original content data","suites":["contentLib","getLocalizedContentResponse"],"updatePoint":{"line":10,"column":53,"index":431},"line":10,"code":"    it('clones, not modify, the original content data', () => {\n      contentLib.getLocalizedContentResponse();\n      expect(typeof content.backgrounds.backgrounds062014.beach.text).to.equal('function');\n    });","file":"api/unit/libs/content.test.js","skipped":false,"dir":"test"},{"name":"updates user.preferences.timezoneOffsetAtLastCron","suites":["cron"],"updatePoint":{"line":41,"column":55,"index":1277},"line":41,"code":"  it('updates user.preferences.timezoneOffsetAtLastCron', async () => {\n    const timezoneUtcOffsetFromUserPrefs = -1;\n    await cron({\n      user,\n      tasksByType,\n      daysMissed,\n      analytics,\n      timezoneUtcOffsetFromUserPrefs\n    });\n    expect(user.preferences.timezoneOffsetAtLastCron).to.equal(1);\n  });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"resets user.items.lastDrop.count","suites":["cron"],"updatePoint":{"line":52,"column":38,"index":1580},"line":52,"code":"  it('resets user.items.lastDrop.count', async () => {\n    user.items.lastDrop.count = 4;\n    await cron({\n      user,\n      tasksByType,\n      daysMissed,\n      analytics\n    });\n    expect(user.items.lastDrop.count).to.equal(0);\n  });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments user cron count","suites":["cron"],"updatePoint":{"line":62,"column":32,"index":1811},"line":62,"code":"  it('increments user cron count', async () => {\n    const cronCountBefore = user.flags.cronCount;\n    await cron({\n      user,\n      tasksByType,\n      daysMissed,\n      analytics\n    });\n    expect(user.flags.cronCount).to.be.greaterThan(cronCountBefore);\n  });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"calls analytics","suites":["cron"],"updatePoint":{"line":72,"column":21,"index":2064},"line":72,"code":"  it('calls analytics', async () => {\n    await cron({\n      user,\n      tasksByType,\n      daysMissed,\n      analytics\n    });\n    expect(analytics.track.callCount).to.equal(1);\n  });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"calls analytics when user is sleeping","suites":["cron"],"updatePoint":{"line":81,"column":43,"index":2271},"line":81,"code":"  it('calls analytics when user is sleeping', async () => {\n    user.preferences.sleep = true;\n    await cron({\n      user,\n      tasksByType,\n      daysMissed,\n      analytics\n    });\n    expect(analytics.track.callCount).to.equal(1);\n  });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards current mystery items to subscriber","suites":["cron","end of the month perks"],"updatePoint":{"line":96,"column":50,"index":2744},"line":96,"code":"    it('awards current mystery items to subscriber', async () => {\n      user.purchased.plan.dateUpdated = new Date('2018-12-11');\n      clock = sinon.useFakeTimers(new Date('2019-01-29'));\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.mysteryItems.length).to.eql(2);\n      const filteredNotifications = user.notifications.filter(n => n.type === 'NEW_MYSTERY_ITEMS');\n      expect(filteredNotifications.length).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards multiple mystery item sets if user skipped months between logins","suites":["cron","end of the month perks"],"updatePoint":{"line":109,"column":79,"index":3294},"line":109,"code":"    it('awards multiple mystery item sets if user skipped months between logins', async () => {\n      user.purchased.plan.dateUpdated = new Date('2018-11-11');\n      clock = sinon.useFakeTimers(new Date('2019-01-29'));\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.mysteryItems.length).to.eql(4);\n      const filteredNotifications = user.notifications.filter(n => n.type === 'NEW_MYSTERY_ITEMS');\n      expect(filteredNotifications.length).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"resets plan.gemsBought on a new month","suites":["cron","end of the month perks"],"updatePoint":{"line":122,"column":45,"index":3810},"line":122,"code":"    it('resets plan.gemsBought on a new month', async () => {\n      user.purchased.plan.gemsBought = 10;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.gemsBought).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"resets plan.gemsBought on a new month if user does not have purchased.plan.dateUpdated","suites":["cron","end of the month perks"],"updatePoint":{"line":132,"column":94,"index":4132},"line":132,"code":"    it('resets plan.gemsBought on a new month if user does not have purchased.plan.dateUpdated', async () => {\n      user.purchased.plan.gemsBought = 10;\n      user.purchased.plan.dateUpdated = undefined;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.gemsBought).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not reset plan.gemsBought within the month","suites":["cron","end of the month perks"],"updatePoint":{"line":143,"column":55,"index":4466},"line":143,"code":"    it('does not reset plan.gemsBought within the month', async () => {\n      clock = sinon.useFakeTimers(moment().startOf('month').add(2, 'days').toDate());\n      user.purchased.plan.dateUpdated = moment().startOf('month').toDate();\n      user.purchased.plan.gemsBought = 10;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.gemsBought).to.equal(10);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"resets plan.dateUpdated on a new month","suites":["cron","end of the month perks"],"updatePoint":{"line":155,"column":46,"index":4903},"line":155,"code":"    it('resets plan.dateUpdated on a new month', async () => {\n      const currentMonth = moment().startOf('month');\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(moment(user.purchased.plan.dateUpdated).startOf('month').isSame(currentMonth)).to.eql(true);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments plan.consecutive.count","suites":["cron","end of the month perks"],"updatePoint":{"line":165,"column":41,"index":5231},"line":165,"code":"    it('increments plan.consecutive.count', async () => {\n      user.purchased.plan.consecutive.count = 0;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.count).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments plan.consecutive.count by more than 1 if user skipped months between logins","suites":["cron","end of the month perks"],"updatePoint":{"line":175,"column":94,"index":5566},"line":175,"code":"    it('increments plan.consecutive.count by more than 1 if user skipped months between logins', async () => {\n      user.purchased.plan.dateUpdated = moment().subtract(2, 'months').toDate();\n      user.purchased.plan.consecutive.count = 0;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.count).to.equal(2);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"decrements plan.consecutive.offset when offset is greater than 0","suites":["cron","end of the month perks"],"updatePoint":{"line":186,"column":72,"index":5960},"line":186,"code":"    it('decrements plan.consecutive.offset when offset is greater than 0', async () => {\n      user.purchased.plan.consecutive.offset = 2;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.offset).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not award unearned plan.consecutive.trinkets if subscription ended during an absence","suites":["cron","end of the month perks"],"updatePoint":{"line":196,"column":97,"index":6300},"line":196,"code":"    it('does not award unearned plan.consecutive.trinkets if subscription ended during an absence', async () => {\n      user.purchased.plan.dateUpdated = moment().subtract(6, 'months').toDate();\n      user.purchased.plan.dateTerminated = moment().subtract(3, 'months').toDate();\n      user.purchased.plan.consecutive.count = 5;\n      user.purchased.plan.consecutive.trinkets = 1;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.trinkets).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment plan.consecutive.gemCapExtra when user has reached the gemCap limit","suites":["cron","end of the month perks"],"updatePoint":{"line":209,"column":94,"index":6855},"line":209,"code":"    it('does not increment plan.consecutive.gemCapExtra when user has reached the gemCap limit', async () => {\n      user.purchased.plan.consecutive.gemCapExtra = 25;\n      user.purchased.plan.consecutive.count = 5;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not reset plan stats if we are before the last day of the cancelled month","suites":["cron","end of the month perks"],"updatePoint":{"line":220,"column":86,"index":7245},"line":220,"code":"    it('does not reset plan stats if we are before the last day of the cancelled month', async () => {\n      user.purchased.plan.dateTerminated = moment(new Date()).add({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.customerId).to.exist;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does reset plan stats if we are after the last day of the cancelled month","suites":["cron","end of the month perks"],"updatePoint":{"line":232,"column":81,"index":7602},"line":232,"code":"    it('does reset plan stats if we are after the last day of the cancelled month', async () => {\n      user.purchased.plan.dateTerminated = moment(new Date()).subtract({\n        days: 1\n      });\n      user.purchased.plan.consecutive.gemCapExtra = 20;\n      user.purchased.plan.consecutive.count = 5;\n      user.purchased.plan.consecutive.offset = 1;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.customerId).to.not.exist;\n      expect(user.purchased.plan.consecutive.gemCapExtra).to.equal(0);\n      expect(user.purchased.plan.consecutive.count).to.equal(0);\n      expect(user.purchased.plan.consecutive.offset).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits after the first month","suites":["cron","end of the month perks","for a 1-month recurring subscription"],"updatePoint":{"line":272,"column":71,"index":9232},"line":272,"code":"      it('does not increment consecutive benefits after the first month', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(1, 'months').add(2, 'days').toDate()); // Add 1 month to simulate what happens a month after the subscription was created.\n        // Add 2 days so that we're sure we're not affected by any start-of-month effects\n        // e.g., from time zone oddness.\n\n        await cron({\n          user: user1,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user1.purchased.plan.consecutive.count).to.equal(1);\n        expect(user1.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user1.purchased.plan.consecutive.trinkets).to.equal(0);\n        expect(user1.purchased.plan.consecutive.gemCapExtra).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits after the second month","suites":["cron","end of the month perks","for a 1-month recurring subscription"],"updatePoint":{"line":288,"column":72,"index":10068},"line":288,"code":"      it('does not increment consecutive benefits after the second month', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(2, 'months').add(2, 'days').toDate()); // Add 1 month to simulate what happens a month after the subscription was created.\n        // Add 2 days so that we're sure we're not affected by any start-of-month effects\n        // e.g., from time zone oddness.\n\n        await cron({\n          user: user1,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user1.purchased.plan.consecutive.count).to.equal(2);\n        expect(user1.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user1.purchased.plan.consecutive.trinkets).to.equal(0);\n        expect(user1.purchased.plan.consecutive.gemCapExtra).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits after the third month","suites":["cron","end of the month perks","for a 1-month recurring subscription"],"updatePoint":{"line":304,"column":63,"index":10895},"line":304,"code":"      it('increments consecutive benefits after the third month', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(3, 'months').add(2, 'days').toDate()); // Add 1 month to simulate what happens a month after the subscription was created.\n        // Add 2 days so that we're sure we're not affected by any start-of-month effects\n        // e.g., from time zone oddness.\n\n        await cron({\n          user: user1,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user1.purchased.plan.consecutive.count).to.equal(3);\n        expect(user1.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user1.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user1.purchased.plan.consecutive.gemCapExtra).to.equal(5);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits after the fourth month","suites":["cron","end of the month perks","for a 1-month recurring subscription"],"updatePoint":{"line":320,"column":72,"index":11731},"line":320,"code":"      it('does not increment consecutive benefits after the fourth month', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(4, 'months').add(2, 'days').toDate()); // Add 1 month to simulate what happens a month after the subscription was created.\n        // Add 2 days so that we're sure we're not affected by any start-of-month effects\n        // e.g., from time zone oddness.\n\n        await cron({\n          user: user1,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user1.purchased.plan.consecutive.count).to.equal(4);\n        expect(user1.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user1.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user1.purchased.plan.consecutive.gemCapExtra).to.equal(5);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits correctly if user has been absent with continuous subscription","suites":["cron","end of the month perks","for a 1-month recurring subscription"],"updatePoint":{"line":336,"column":104,"index":12599},"line":336,"code":"      it('increments consecutive benefits correctly if user has been absent with continuous subscription', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(10, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user1,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user1.purchased.plan.consecutive.count).to.equal(10);\n        expect(user1.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user1.purchased.plan.consecutive.trinkets).to.equal(3);\n        expect(user1.purchased.plan.consecutive.gemCapExtra).to.equal(15);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the first month of the first paid period that they already have benefits for","suites":["cron","end of the month perks","for a 3-month recurring subscription"],"updatePoint":{"line":371,"column":129,"index":14116},"line":371,"code":"      it('does not increment consecutive benefits in the first month of the first paid period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(1, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3.purchased.plan.consecutive.count).to.equal(1);\n        expect(user3.purchased.plan.consecutive.offset).to.equal(2);\n        expect(user3.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user3.purchased.plan.consecutive.gemCapExtra).to.equal(5);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the middle of the period that they already have benefits for","suites":["cron","end of the month perks","for a 3-month recurring subscription"],"updatePoint":{"line":384,"column":113,"index":14777},"line":384,"code":"      it('does not increment consecutive benefits in the middle of the period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(2, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3.purchased.plan.consecutive.count).to.equal(2);\n        expect(user3.purchased.plan.consecutive.offset).to.equal(1);\n        expect(user3.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user3.purchased.plan.consecutive.gemCapExtra).to.equal(5);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the final month of the period that they already have benefits for","suites":["cron","end of the month perks","for a 3-month recurring subscription"],"updatePoint":{"line":397,"column":118,"index":15443},"line":397,"code":"      it('does not increment consecutive benefits in the final month of the period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(3, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3.purchased.plan.consecutive.count).to.equal(3);\n        expect(user3.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user3.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user3.purchased.plan.consecutive.gemCapExtra).to.equal(5);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits the month after the second paid period has started","suites":["cron","end of the month perks","for a 3-month recurring subscription"],"updatePoint":{"line":410,"column":92,"index":16083},"line":410,"code":"      it('increments consecutive benefits the month after the second paid period has started', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(4, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3.purchased.plan.consecutive.count).to.equal(4);\n        expect(user3.purchased.plan.consecutive.offset).to.equal(2);\n        expect(user3.purchased.plan.consecutive.trinkets).to.equal(2);\n        expect(user3.purchased.plan.consecutive.gemCapExtra).to.equal(10);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the second month of the second period that they already have benefits for","suites":["cron","end of the month perks","for a 3-month recurring subscription"],"updatePoint":{"line":423,"column":126,"index":16758},"line":423,"code":"      it('does not increment consecutive benefits in the second month of the second period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(5, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3.purchased.plan.consecutive.count).to.equal(5);\n        expect(user3.purchased.plan.consecutive.offset).to.equal(1);\n        expect(user3.purchased.plan.consecutive.trinkets).to.equal(2);\n        expect(user3.purchased.plan.consecutive.gemCapExtra).to.equal(10);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the final month of the second period that they already have benefits for","suites":["cron","end of the month perks","for a 3-month recurring subscription"],"updatePoint":{"line":436,"column":125,"index":17432},"line":436,"code":"      it('does not increment consecutive benefits in the final month of the second period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(6, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3.purchased.plan.consecutive.count).to.equal(6);\n        expect(user3.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user3.purchased.plan.consecutive.trinkets).to.equal(2);\n        expect(user3.purchased.plan.consecutive.gemCapExtra).to.equal(10);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits the month after the third paid period has started","suites":["cron","end of the month perks","for a 3-month recurring subscription"],"updatePoint":{"line":449,"column":91,"index":18072},"line":449,"code":"      it('increments consecutive benefits the month after the third paid period has started', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(7, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3.purchased.plan.consecutive.count).to.equal(7);\n        expect(user3.purchased.plan.consecutive.offset).to.equal(2);\n        expect(user3.purchased.plan.consecutive.trinkets).to.equal(3);\n        expect(user3.purchased.plan.consecutive.gemCapExtra).to.equal(15);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits correctly if user has been absent with continuous subscription","suites":["cron","end of the month perks","for a 3-month recurring subscription"],"updatePoint":{"line":462,"column":104,"index":18725},"line":462,"code":"      it('increments consecutive benefits correctly if user has been absent with continuous subscription', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(10, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3.purchased.plan.consecutive.count).to.equal(10);\n        expect(user3.purchased.plan.consecutive.offset).to.equal(2);\n        expect(user3.purchased.plan.consecutive.trinkets).to.equal(4);\n        expect(user3.purchased.plan.consecutive.gemCapExtra).to.equal(20);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the first month of the first paid period that they already have benefits for","suites":["cron","end of the month perks","for a 6-month recurring subscription"],"updatePoint":{"line":497,"column":129,"index":20244},"line":497,"code":"      it('does not increment consecutive benefits in the first month of the first paid period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(1, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6.purchased.plan.consecutive.count).to.equal(1);\n        expect(user6.purchased.plan.consecutive.offset).to.equal(5);\n        expect(user6.purchased.plan.consecutive.trinkets).to.equal(2);\n        expect(user6.purchased.plan.consecutive.gemCapExtra).to.equal(10);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the final month of the period that they already have benefits for","suites":["cron","end of the month perks","for a 6-month recurring subscription"],"updatePoint":{"line":510,"column":118,"index":20911},"line":510,"code":"      it('does not increment consecutive benefits in the final month of the period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(6, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6.purchased.plan.consecutive.count).to.equal(6);\n        expect(user6.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user6.purchased.plan.consecutive.trinkets).to.equal(2);\n        expect(user6.purchased.plan.consecutive.gemCapExtra).to.equal(10);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits the month after the second paid period has started","suites":["cron","end of the month perks","for a 6-month recurring subscription"],"updatePoint":{"line":523,"column":92,"index":21552},"line":523,"code":"      it('increments consecutive benefits the month after the second paid period has started', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(7, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6.purchased.plan.consecutive.count).to.equal(7);\n        expect(user6.purchased.plan.consecutive.offset).to.equal(5);\n        expect(user6.purchased.plan.consecutive.trinkets).to.equal(4);\n        expect(user6.purchased.plan.consecutive.gemCapExtra).to.equal(20);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits the month after the third paid period has started","suites":["cron","end of the month perks","for a 6-month recurring subscription"],"updatePoint":{"line":536,"column":91,"index":22192},"line":536,"code":"      it('increments consecutive benefits the month after the third paid period has started', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(13, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6.purchased.plan.consecutive.count).to.equal(13);\n        expect(user6.purchased.plan.consecutive.offset).to.equal(5);\n        expect(user6.purchased.plan.consecutive.trinkets).to.equal(6);\n        expect(user6.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits correctly if user has been absent with continuous subscription","suites":["cron","end of the month perks","for a 6-month recurring subscription"],"updatePoint":{"line":549,"column":104,"index":22847},"line":549,"code":"      it('increments consecutive benefits correctly if user has been absent with continuous subscription', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(19, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6.purchased.plan.consecutive.count).to.equal(19);\n        expect(user6.purchased.plan.consecutive.offset).to.equal(5);\n        expect(user6.purchased.plan.consecutive.trinkets).to.equal(8);\n        expect(user6.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the first month of the first paid period that they already have benefits for","suites":["cron","end of the month perks","for a 12-month recurring subscription"],"updatePoint":{"line":584,"column":129,"index":24381},"line":584,"code":"      it('does not increment consecutive benefits in the first month of the first paid period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(1, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user12,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user12.purchased.plan.consecutive.count).to.equal(1);\n        expect(user12.purchased.plan.consecutive.offset).to.equal(11);\n        expect(user12.purchased.plan.consecutive.trinkets).to.equal(4);\n        expect(user12.purchased.plan.consecutive.gemCapExtra).to.equal(20);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the final month of the period that they already have benefits for","suites":["cron","end of the month perks","for a 12-month recurring subscription"],"updatePoint":{"line":597,"column":118,"index":25054},"line":597,"code":"      it('does not increment consecutive benefits in the final month of the period that they already have benefits for', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(12, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user12,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user12.purchased.plan.consecutive.count).to.equal(12);\n        expect(user12.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user12.purchased.plan.consecutive.trinkets).to.equal(4);\n        expect(user12.purchased.plan.consecutive.gemCapExtra).to.equal(20);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits the month after the second paid period has started","suites":["cron","end of the month perks","for a 12-month recurring subscription"],"updatePoint":{"line":610,"column":92,"index":25702},"line":610,"code":"      it('increments consecutive benefits the month after the second paid period has started', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(13, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user12,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user12.purchased.plan.consecutive.count).to.equal(13);\n        expect(user12.purchased.plan.consecutive.offset).to.equal(11);\n        expect(user12.purchased.plan.consecutive.trinkets).to.equal(8);\n        expect(user12.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits the month after the third paid period has started","suites":["cron","end of the month perks","for a 12-month recurring subscription"],"updatePoint":{"line":623,"column":91,"index":26350},"line":623,"code":"      it('increments consecutive benefits the month after the third paid period has started', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(25, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user12,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user12.purchased.plan.consecutive.count).to.equal(25);\n        expect(user12.purchased.plan.consecutive.offset).to.equal(11);\n        expect(user12.purchased.plan.consecutive.trinkets).to.equal(12);\n        expect(user12.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits correctly if user has been absent with continuous subscription","suites":["cron","end of the month perks","for a 12-month recurring subscription"],"updatePoint":{"line":636,"column":104,"index":27012},"line":636,"code":"      it('increments consecutive benefits correctly if user has been absent with continuous subscription', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(37, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user12,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user12.purchased.plan.consecutive.count).to.equal(37);\n        expect(user12.purchased.plan.consecutive.offset).to.equal(11);\n        expect(user12.purchased.plan.consecutive.trinkets).to.equal(16);\n        expect(user12.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the first month of the gift subscription","suites":["cron","end of the month perks","for a 3-month gift subscription (non-recurring)"],"updatePoint":{"line":672,"column":93,"index":28617},"line":672,"code":"      it('does not increment consecutive benefits in the first month of the gift subscription', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(1, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3g,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3g.purchased.plan.consecutive.count).to.equal(1);\n        expect(user3g.purchased.plan.consecutive.offset).to.equal(2);\n        expect(user3g.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user3g.purchased.plan.consecutive.gemCapExtra).to.equal(5);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the second month of the gift subscription","suites":["cron","end of the month perks","for a 3-month gift subscription (non-recurring)"],"updatePoint":{"line":685,"column":94,"index":29264},"line":685,"code":"      it('does not increment consecutive benefits in the second month of the gift subscription', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(2, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3g,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3g.purchased.plan.consecutive.count).to.equal(2);\n        expect(user3g.purchased.plan.consecutive.offset).to.equal(1);\n        expect(user3g.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user3g.purchased.plan.consecutive.gemCapExtra).to.equal(5);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the third month of the gift subscription","suites":["cron","end of the month perks","for a 3-month gift subscription (non-recurring)"],"updatePoint":{"line":698,"column":93,"index":29910},"line":698,"code":"      it('does not increment consecutive benefits in the third month of the gift subscription', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(3, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3g,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user3g.purchased.plan.consecutive.count).to.equal(3);\n        expect(user3g.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user3g.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user3g.purchased.plan.consecutive.gemCapExtra).to.equal(5);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the month after the gift subscription has ended","suites":["cron","end of the month perks","for a 3-month gift subscription (non-recurring)"],"updatePoint":{"line":711,"column":100,"index":30563},"line":711,"code":"      it('does not increment consecutive benefits in the month after the gift subscription has ended', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(4, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user3g,\n          tasksByType,\n          daysMissed,\n          analytics\n        }); // subscription has been erased by now\n\n        expect(user3g.purchased.plan.consecutive.count).to.equal(0);\n        expect(user3g.purchased.plan.consecutive.offset).to.equal(0);\n        expect(user3g.purchased.plan.consecutive.trinkets).to.equal(1);\n        expect(user3g.purchased.plan.consecutive.gemCapExtra).to.equal(0); // erased\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits in the first month since the fix for #4819 goes live","suites":["cron","end of the month perks","for a 6-month recurring subscription where the user has incorrect consecutive month data from prior bugs"],"updatePoint":{"line":748,"column":94,"index":32231},"line":748,"code":"      it('increments consecutive benefits in the first month since the fix for #4819 goes live', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(1, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6x,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6x.purchased.plan.consecutive.count).to.equal(9);\n        expect(user6x.purchased.plan.consecutive.offset).to.equal(5);\n        expect(user6x.purchased.plan.consecutive.trinkets).to.equal(5);\n        expect(user6x.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the second month after the fix goes live","suites":["cron","end of the month perks","for a 6-month recurring subscription where the user has incorrect consecutive month data from prior bugs"],"updatePoint":{"line":761,"column":93,"index":32878},"line":761,"code":"      it('does not increment consecutive benefits in the second month after the fix goes live', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(2, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6x,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6x.purchased.plan.consecutive.count).to.equal(10);\n        expect(user6x.purchased.plan.consecutive.offset).to.equal(4);\n        expect(user6x.purchased.plan.consecutive.trinkets).to.equal(5);\n        expect(user6x.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment consecutive benefits in the third month after the fix goes live","suites":["cron","end of the month perks","for a 6-month recurring subscription where the user has incorrect consecutive month data from prior bugs"],"updatePoint":{"line":774,"column":92,"index":33525},"line":774,"code":"      it('does not increment consecutive benefits in the third month after the fix goes live', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(3, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6x,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6x.purchased.plan.consecutive.count).to.equal(11);\n        expect(user6x.purchased.plan.consecutive.offset).to.equal(3);\n        expect(user6x.purchased.plan.consecutive.trinkets).to.equal(5);\n        expect(user6x.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments consecutive benefits in the seventh month after the fix goes live","suites":["cron","end of the month perks","for a 6-month recurring subscription where the user has incorrect consecutive month data from prior bugs"],"updatePoint":{"line":787,"column":86,"index":34166},"line":787,"code":"      it('increments consecutive benefits in the seventh month after the fix goes live', async () => {\n        clock = sinon.useFakeTimers(moment().utcOffset(0).startOf('month').add(7, 'months').add(2, 'days').toDate());\n        await cron({\n          user: user6x,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(user6x.purchased.plan.consecutive.count).to.equal(15);\n        expect(user6x.purchased.plan.consecutive.offset).to.equal(5);\n        expect(user6x.purchased.plan.consecutive.trinkets).to.equal(7);\n        expect(user6x.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"resets plan.gemsBought on a new month","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":806,"column":45,"index":34977},"line":806,"code":"    it('resets plan.gemsBought on a new month', async () => {\n      user.purchased.plan.gemsBought = 10;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.gemsBought).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not reset plan.gemsBought within the month","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":816,"column":55,"index":35260},"line":816,"code":"    it('does not reset plan.gemsBought within the month', async () => {\n      clock = sinon.useFakeTimers(moment().startOf('month').add(2, 'days').unix());\n      user.purchased.plan.dateUpdated = moment().startOf('month').toDate();\n      user.purchased.plan.gemsBought = 10;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.gemsBought).to.equal(10);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not reset plan.dateUpdated on a new month","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":828,"column":54,"index":35703},"line":828,"code":"    it('does not reset plan.dateUpdated on a new month', async () => {\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.dateUpdated).to.be.empty;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment plan.consecutive.count","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":837,"column":49,"index":35938},"line":837,"code":"    it('does not increment plan.consecutive.count', async () => {\n      user.purchased.plan.consecutive.count = 0;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.count).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not decrement plan.consecutive.offset when offset is greater than 0","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":847,"column":80,"index":36259},"line":847,"code":"    it('does not decrement plan.consecutive.offset when offset is greater than 0', async () => {\n      user.purchased.plan.consecutive.offset = 1;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.offset).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment plan.consecutive.trinkets when user has reached a month that is a multiple of 3","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":857,"column":106,"index":36608},"line":857,"code":"    it('does not increment plan.consecutive.trinkets when user has reached a month that is a multiple of 3', async () => {\n      user.purchased.plan.consecutive.count = 5;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.trinkets).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment plan.consecutive.gemCapExtra when user has reached a month that is a multiple of 3","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":867,"column":109,"index":36961},"line":867,"code":"    it('does not increment plan.consecutive.gemCapExtra when user has reached a month that is a multiple of 3', async () => {\n      user.purchased.plan.consecutive.count = 5;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.gemCapExtra).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment plan.consecutive.gemCapExtra when user has reached the gemCap limit","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":877,"column":94,"index":37302},"line":877,"code":"    it('does not increment plan.consecutive.gemCapExtra when user has reached the gemCap limit', async () => {\n      user.purchased.plan.consecutive.gemCapExtra = 25;\n      user.purchased.plan.consecutive.count = 5;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.consecutive.gemCapExtra).to.equal(25);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does nothing to plan stats if we are before the last day of the cancelled month","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":888,"column":87,"index":37693},"line":888,"code":"    it('does nothing to plan stats if we are before the last day of the cancelled month', async () => {\n      user.purchased.plan.dateTerminated = moment(new Date()).add({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.customerId).to.not.exist;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does nothing to plan stats when we are after the last day of the cancelled month","suites":["cron","end of the month perks when user is not subscribed"],"updatePoint":{"line":900,"column":89,"index":38062},"line":900,"code":"    xit('does nothing to plan stats when we are after the last day of the cancelled month', async () => {\n      user.purchased.plan.dateTerminated = moment(new Date()).subtract({\n        days: 1\n      });\n      user.purchased.plan.consecutive.gemCapExtra = 20;\n      user.purchased.plan.consecutive.count = 5;\n      user.purchased.plan.consecutive.offset = 1;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.purchased.plan.customerId).to.exist;\n      expect(user.purchased.plan.consecutive.gemCapExtra).to.exist;\n      expect(user.purchased.plan.consecutive.count).to.exist;\n      expect(user.purchased.plan.consecutive.offset).to.exist;\n    });","skipped":true,"file":"api/unit/libs/cron.test.js","dir":"test"},{"name":"should make uncompleted todos redder","suites":["cron","todos"],"updatePoint":{"line":934,"column":44,"index":39138},"line":934,"code":"    it('should make uncompleted todos redder', async () => {\n      const valueBefore = tasksByType.todos[0].value;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.todos[0].value).to.be.lessThan(valueBefore);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not make completed todos redder","suites":["cron","todos"],"updatePoint":{"line":944,"column":46,"index":39435},"line":944,"code":"    it('should not make completed todos redder', async () => {\n      tasksByType.todos[0].completed = true;\n      const valueBefore = tasksByType.todos[0].value;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.todos[0].value).to.equal(valueBefore);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should add history of completed todos to user history","suites":["cron","todos"],"updatePoint":{"line":955,"column":61,"index":39786},"line":955,"code":"    it('should add history of completed todos to user history', async () => {\n      tasksByType.todos[0].completed = true;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.history.todos).to.be.lengthOf(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should remove completed todos from users taskOrder list","suites":["cron","todos"],"updatePoint":{"line":965,"column":63,"index":40073},"line":965,"code":"    it('should remove completed todos from users taskOrder list', async () => {\n      const todo = {\n        text: 'test todo',\n        type: 'todo',\n        value: 0\n      };\n      const task = new Tasks.todo(Tasks.Task.sanitize(todo)); // eslint-disable-line new-cap\n\n      tasksByType.todos.push(task);\n      tasksByType.todos[0].completed = true;\n      user.tasksOrder.todos = tasksByType.todos.map(taskTodo => taskTodo._id); // Since ideally tasksByType should not contain completed todos,\n      // fake ids should be filtered too\n\n      user.tasksOrder.todos.push('00000000-0000-0000-0000-000000000000');\n      expect(tasksByType.todos).to.be.lengthOf(2);\n      expect(user.tasksOrder.todos).to.be.lengthOf(3);\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      }); // user.tasksOrder.todos should be filtered while tasks by type remains unchanged\n\n      expect(tasksByType.todos).to.be.lengthOf(2);\n      expect(user.tasksOrder.todos).to.be.lengthOf(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should preserve todos order in task list","suites":["cron","todos"],"updatePoint":{"line":991,"column":48,"index":41074},"line":991,"code":"    it('should preserve todos order in task list', async () => {\n      const todo = {\n        text: 'test todo',\n        type: 'todo',\n        value: 0\n      };\n      let task = new Tasks.todo(Tasks.Task.sanitize(todo)); // eslint-disable-line new-cap\n\n      tasksByType.todos.push(task);\n      task = new Tasks.todo(Tasks.Task.sanitize(todo)); // eslint-disable-line new-cap\n\n      tasksByType.todos.push(task);\n      task = new Tasks.todo(Tasks.Task.sanitize(todo)); // eslint-disable-line new-cap\n\n      tasksByType.todos.push(task); // Set up user.tasksOrder list in a specific order\n\n      user.tasksOrder.todos = tasksByType.todos.map(todoTask => todoTask._id).reverse();\n      const original = user.tasksOrder.todos; // Preserve the original order\n\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      let listsAreEqual = true;\n      user.tasksOrder.todos.forEach((taskId, index) => {\n        if (original[index]._id !== taskId) {\n          listsAreEqual = false;\n        }\n      });\n      expect(listsAreEqual);\n      expect(user.tasksOrder.todos).to.be.lengthOf(original.length);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"computes isDue","suites":["cron","dailys"],"updatePoint":{"line":1045,"column":22,"index":42823},"line":1045,"code":"    it('computes isDue', async () => {\n      tasksByType.dailys[0].frequency = 'daily';\n      tasksByType.dailys[0].everyX = 5;\n      tasksByType.dailys[0].startDate = moment().add(1, 'days').toDate();\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].isDue).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"computes isDue when user is sleeping","suites":["cron","dailys"],"updatePoint":{"line":1057,"column":44,"index":43212},"line":1057,"code":"    it('computes isDue when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      tasksByType.dailys[0].frequency = 'daily';\n      tasksByType.dailys[0].everyX = 5;\n      tasksByType.dailys[0].startDate = moment().toDate();\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].isDue).to.exist;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"computes nextDue","suites":["cron","dailys"],"updatePoint":{"line":1070,"column":24,"index":43600},"line":1070,"code":"    it('computes nextDue', async () => {\n      tasksByType.dailys[0].frequency = 'daily';\n      tasksByType.dailys[0].everyX = 5;\n      tasksByType.dailys[0].startDate = moment().add(1, 'days').toDate();\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].nextDue.length).to.eql(6);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should add history","suites":["cron","dailys"],"updatePoint":{"line":1082,"column":26,"index":43978},"line":1082,"code":"    it('should add history', async () => {\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].history).to.be.lengthOf(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should set tasks completed to false","suites":["cron","dailys"],"updatePoint":{"line":1091,"column":43,"index":44211},"line":1091,"code":"    it('should set tasks completed to false', async () => {\n      tasksByType.dailys[0].completed = true;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].completed).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should set tasks completed to false when user is sleeping","suites":["cron","dailys"],"updatePoint":{"line":1101,"column":65,"index":44508},"line":1101,"code":"    it('should set tasks completed to false when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      tasksByType.dailys[0].completed = true;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].completed).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset task checklist for completed dailys","suites":["cron","dailys"],"updatePoint":{"line":1112,"column":56,"index":44833},"line":1112,"code":"    it('should reset task checklist for completed dailys', async () => {\n      tasksByType.dailys[0].checklist.push({\n        title: 'test',\n        completed: false\n      });\n      tasksByType.dailys[0].completed = true;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].checklist[0].completed).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset task checklist for completed dailys when user is sleeping","suites":["cron","dailys"],"updatePoint":{"line":1126,"column":78,"index":45259},"line":1126,"code":"    it('should reset task checklist for completed dailys when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      tasksByType.dailys[0].checklist.push({\n        title: 'test',\n        completed: false\n      });\n      tasksByType.dailys[0].completed = true;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].checklist[0].completed).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset task checklist for dailys with scheduled misses","suites":["cron","dailys"],"updatePoint":{"line":1141,"column":68,"index":45712},"line":1141,"code":"    it('should reset task checklist for dailys with scheduled misses', async () => {\n      daysMissed = 10;\n      tasksByType.dailys[0].checklist.push({\n        title: 'test',\n        completed: false\n      });\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.dailys[0].checklist[0].completed).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should do damage for missing a daily","suites":["cron","dailys"],"updatePoint":{"line":1158,"column":44,"index":46177},"line":1158,"code":"    it('should do damage for missing a daily', async () => {\n      daysMissed = 1;\n      const hpBefore = user.stats.hp;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.hp).to.be.lessThan(hpBefore);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not do damage for missing a daily when user is sleeping","suites":["cron","dailys"],"updatePoint":{"line":1172,"column":70,"index":46584},"line":1172,"code":"    it('should not do damage for missing a daily when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      daysMissed = 1;\n      const hpBefore = user.stats.hp;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.hp).to.equal(hpBefore);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not do damage for missing a daily when CRON_SAFE_MODE is set","suites":["cron","dailys"],"updatePoint":{"line":1187,"column":75,"index":47027},"line":1187,"code":"    it('should not do damage for missing a daily when CRON_SAFE_MODE is set', async () => {\n      sandbox.stub(nconf, 'get').withArgs('CRON_SAFE_MODE').returns('true');\n      const cronOverride = requireAgain(pathToCronLib).cron;\n      daysMissed = 1;\n      const hpBefore = user.stats.hp;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      cronOverride({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.hp).to.equal(hpBefore);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not do damage for missing a daily if user stealth buff is greater than or equal to days missed","suites":["cron","dailys"],"updatePoint":{"line":1203,"column":109,"index":47607},"line":1203,"code":"    it('should not do damage for missing a daily if user stealth buff is greater than or equal to days missed', async () => {\n      daysMissed = 1;\n      const hpBefore = user.stats.hp;\n      user.stats.buffs.stealth = 2;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.hp).to.equal(hpBefore);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should do less damage for missing a daily with partial completion","suites":["cron","dailys"],"updatePoint":{"line":1218,"column":73,"index":48047},"line":1218,"code":"    it('should do less damage for missing a daily with partial completion', async () => {\n      daysMissed = 1;\n      let hpBefore = user.stats.hp;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      const hpDifferenceOfFullyIncompleteDaily = hpBefore - user.stats.hp;\n      hpBefore = user.stats.hp;\n      tasksByType.dailys[0].checklist.push({\n        title: 'test',\n        completed: true\n      });\n      tasksByType.dailys[0].checklist.push({\n        title: 'test2',\n        completed: false\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      const hpDifferenceOfPartiallyIncompleteDaily = hpBefore - user.stats.hp;\n      expect(hpDifferenceOfPartiallyIncompleteDaily).to.be.lessThan(hpDifferenceOfFullyIncompleteDaily);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should decrement quest.progress.down for missing a daily","suites":["cron","dailys"],"updatePoint":{"line":1249,"column":64,"index":48991},"line":1249,"code":"    it('should decrement quest.progress.down for missing a daily', async () => {\n      daysMissed = 1;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      const progress = await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(progress.down).to.equal(-1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not decrement quest.progress.down for missing a daily when user is sleeping","suites":["cron","dailys"],"updatePoint":{"line":1262,"column":90,"index":49385},"line":1262,"code":"    it('should not decrement quest.progress.down for missing a daily when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      daysMissed = 1;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      const progress = await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(progress.down).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should do damage for only yesterday's dailies","suites":["cron","dailys"],"updatePoint":{"line":1276,"column":54,"index":49779},"line":1276,"code":"    it('should do damage for only yesterday\\'s dailies', async () => {\n      daysMissed = 3;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      const daily = {\n        text: 'test daily',\n        type: 'daily'\n      };\n      const task = new Tasks.daily(Tasks.Task.sanitize(daily)); // eslint-disable-line new-cap\n\n      tasksByType.dailys.push(task);\n      tasksByType.dailys[1].startDate = moment(new Date()).subtract({\n        days: 2\n      });\n      tasksByType.dailys[1].everyX = 2;\n      tasksByType.dailys[1].frequency = 'daily';\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.hp).to.equal(48);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should decrement only up value","suites":["cron","habits"],"updatePoint":{"line":1313,"column":38,"index":50826},"line":1313,"code":"    it('should decrement only up value', async () => {\n      tasksByType.habits[0].value = 1;\n      tasksByType.habits[0].down = false;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.habits[0].value).to.be.lessThan(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should decrement only down value","suites":["cron","habits"],"updatePoint":{"line":1324,"column":40,"index":51135},"line":1324,"code":"    it('should decrement only down value', async () => {\n      tasksByType.habits[0].value = 1;\n      tasksByType.habits[0].up = false;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.habits[0].value).to.be.lessThan(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should do nothing to habits with both up and down","suites":["cron","habits"],"updatePoint":{"line":1335,"column":57,"index":51459},"line":1335,"code":"    it('should do nothing to habits with both up and down', async () => {\n      tasksByType.habits[0].value = 1;\n      tasksByType.habits[0].up = true;\n      tasksByType.habits[0].down = true;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(tasksByType.habits[0].value).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset a daily habit counter each day","suites":["cron","habits","counters"],"updatePoint":{"line":1354,"column":53,"index":52102},"line":1354,"code":"      it('should reset a daily habit counter each day', async () => {\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1;\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset habit counters even if user is sleeping","suites":["cron","habits","counters"],"updatePoint":{"line":1366,"column":62,"index":52521},"line":1366,"code":"      it('should reset habit counters even if user is sleeping', async () => {\n        user.preferences.sleep = true;\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1;\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset a weekly habit counter each Monday","suites":["cron","habits","counters"],"updatePoint":{"line":1379,"column":57,"index":52974},"line":1379,"code":"      it('should reset a weekly habit counter each Monday', async () => {\n        tasksByType.habits[0].frequency = 'weekly';\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1; // should not reset\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(1);\n        expect(tasksByType.habits[0].counterDown).to.equal(1); // should reset\n\n        daysMissed = 8;\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset a weekly habit counter with custom daily start","suites":["cron","habits","counters"],"updatePoint":{"line":1403,"column":69,"index":53752},"line":1403,"code":"      it('should reset a weekly habit counter with custom daily start', async () => {\n        clock.restore(); // Server clock: Monday 12am UTC\n\n        let monday = new Date('May 22, 2017 00:00:00 GMT').getTime();\n        clock = sinon.useFakeTimers(monday); // cron runs at 2am\n\n        user.preferences.dayStart = 2;\n        tasksByType.habits[0].frequency = 'weekly';\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1;\n        daysMissed = 1; // should not reset\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(1);\n        expect(tasksByType.habits[0].counterDown).to.equal(1);\n        clock.restore(); // Server clock: Monday 3am UTC\n\n        monday = new Date('May 22, 2017 03:00:00 GMT').getTime();\n        clock = sinon.useFakeTimers(monday); // should reset after user CDS\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not reset a weekly habit counter when server tz is Monday but user's tz is Tuesday","suites":["cron","habits","counters"],"updatePoint":{"line":1437,"column":100,"index":54979},"line":1437,"code":"      it('should not reset a weekly habit counter when server tz is Monday but user\\'s tz is Tuesday', async () => {\n        clock.restore(); // Server clock: Monday 11pm UTC\n\n        const monday = new Date('May 22, 2017 23:00:00 GMT').getTime();\n        clock = sinon.useFakeTimers(monday); // User clock: Tuesday 1am UTC + 2\n\n        user.preferences.timezoneOffset = -120;\n        tasksByType.habits[0].frequency = 'weekly';\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1;\n        daysMissed = 1; // should not reset\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(1);\n        expect(tasksByType.habits[0].counterDown).to.equal(1); // User missed one cron, which will subtract User clock back to Monday 1am UTC + 2\n        // should reset\n\n        daysMissed = 2;\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset a weekly habit counter when server tz is Sunday but user's tz is Monday","suites":["cron","habits","counters"],"updatePoint":{"line":1469,"column":95,"index":56158},"line":1469,"code":"      it('should reset a weekly habit counter when server tz is Sunday but user\\'s tz is Monday', async () => {\n        clock.restore(); // Server clock: Sunday 11pm UTC\n\n        const sunday = new Date('May 21, 2017 23:00:00 GMT').getTime();\n        clock = sinon.useFakeTimers(sunday); // User clock: Monday 2am UTC + 3\n\n        user.preferences.timezoneOffset = -180;\n        tasksByType.habits[0].frequency = 'weekly';\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1;\n        daysMissed = 1; // should reset\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not reset a weekly habit counter when server tz is Monday but user's tz is Sunday","suites":["cron","habits","counters"],"updatePoint":{"line":1490,"column":99,"index":56966},"line":1490,"code":"      it('should not reset a weekly habit counter when server tz is Monday but user\\'s tz is Sunday', async () => {\n        clock.restore(); // Server clock: Monday 2am UTC\n\n        const monday = new Date('May 22, 2017 02:00:00 GMT').getTime();\n        clock = sinon.useFakeTimers(monday); // User clock: Sunday 11pm UTC - 3\n\n        user.preferences.timezoneOffset = 180;\n        tasksByType.habits[0].frequency = 'weekly';\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1;\n        daysMissed = 1; // should not reset\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(1);\n        expect(tasksByType.habits[0].counterDown).to.equal(1);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset a monthly habit counter the first day of each month","suites":["cron","habits","counters"],"updatePoint":{"line":1511,"column":74,"index":57752},"line":1511,"code":"      it('should reset a monthly habit counter the first day of each month', async () => {\n        tasksByType.habits[0].frequency = 'monthly';\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1; // should not reset\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(1);\n        expect(tasksByType.habits[0].counterDown).to.equal(1); // should reset\n\n        daysMissed = 32;\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should reset a monthly habit counter when server tz is last day of month but user tz is first day of the month","suites":["cron","habits","counters"],"updatePoint":{"line":1535,"column":120,"index":58583},"line":1535,"code":"      it('should reset a monthly habit counter when server tz is last day of month but user tz is first day of the month', async () => {\n        clock.restore();\n        daysMissed = 0; // Server clock: 4/30/17 11pm UTC\n\n        const monday = new Date('April 30, 2017 23:00:00 GMT').getTime();\n        clock = sinon.useFakeTimers(monday); // User clock: 5/1/17 2am UTC + 3\n\n        user.preferences.timezoneOffset = -180;\n        tasksByType.habits[0].frequency = 'monthly';\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1;\n        daysMissed = 1; // should reset\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not reset a monthly habit counter when server tz is first day of month but user tz is 2nd day of the month","suites":["cron","habits","counters"],"updatePoint":{"line":1557,"column":123,"index":59443},"line":1557,"code":"      it('should not reset a monthly habit counter when server tz is first day of month but user tz is 2nd day of the month', async () => {\n        clock.restore(); // Server clock: 5/1/17 11pm UTC\n\n        const monday = new Date('May 1, 2017 23:00:00 GMT').getTime();\n        clock = sinon.useFakeTimers(monday); // User clock: 5/2/17 2am UTC + 3\n\n        user.preferences.timezoneOffset = -180;\n        tasksByType.habits[0].frequency = 'monthly';\n        tasksByType.habits[0].counterUp = 1;\n        tasksByType.habits[0].counterDown = 1;\n        daysMissed = 1; // should not reset\n\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(1);\n        expect(tasksByType.habits[0].counterDown).to.equal(1); // User missed one day, which will subtract User clock back to 5/1/17 2am UTC + 3\n        // should reset\n\n        daysMissed = 2;\n        await cron({\n          user,\n          tasksByType,\n          daysMissed,\n          analytics\n        });\n        expect(tasksByType.habits[0].counterUp).to.equal(0);\n        expect(tasksByType.habits[0].counterDown).to.equal(0);\n      });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"stores a new entry in user.history.exp","suites":["cron","perfect day"],"updatePoint":{"line":1610,"column":46,"index":61207},"line":1610,"code":"    it('stores a new entry in user.history.exp', async () => {\n      user.stats.lvl = 2;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.history.exp).to.have.lengthOf(1);\n      expect(user.history.exp[0].value).to.equal(25);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments perfect day achievement if all (at least 1) due dailies were completed","suites":["cron","perfect day"],"updatePoint":{"line":1621,"column":89,"index":61555},"line":1621,"code":"    it('increments perfect day achievement if all (at least 1) due dailies were completed', async () => {\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = true;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.achievements.perfect).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"does not increment perfect day achievement if no due dailies","suites":["cron","perfect day"],"updatePoint":{"line":1635,"column":68,"index":61967},"line":1635,"code":"    it('does not increment perfect day achievement if no due dailies', async () => {\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = true;\n      tasksByType.dailys[0].startDate = moment(new Date()).add({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.achievements.perfect).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"gives perfect day buff if all (at least 1) due dailies were completed","suites":["cron","perfect day"],"updatePoint":{"line":1649,"column":77,"index":62383},"line":1649,"code":"    it('gives perfect day buff if all (at least 1) due dailies were completed', async () => {\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = true;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      const previousBuffs = user.stats.buffs.toObject();\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.buffs.str).to.be.greaterThan(previousBuffs.str);\n      expect(user.stats.buffs.int).to.be.greaterThan(previousBuffs.int);\n      expect(user.stats.buffs.per).to.be.greaterThan(previousBuffs.per);\n      expect(user.stats.buffs.con).to.be.greaterThan(previousBuffs.con);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"gives perfect day buff if all (at least 1) due dailies were completed when user is sleeping","suites":["cron","perfect day"],"updatePoint":{"line":1667,"column":99,"index":63122},"line":1667,"code":"    it('gives perfect day buff if all (at least 1) due dailies were completed when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = true;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      const previousBuffs = user.stats.buffs.toObject();\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.buffs.str).to.be.greaterThan(previousBuffs.str);\n      expect(user.stats.buffs.int).to.be.greaterThan(previousBuffs.int);\n      expect(user.stats.buffs.per).to.be.greaterThan(previousBuffs.per);\n      expect(user.stats.buffs.con).to.be.greaterThan(previousBuffs.con);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"clears buffs if user does not have a perfect day (no due dailys)","suites":["cron","perfect day"],"updatePoint":{"line":1686,"column":72,"index":63871},"line":1686,"code":"    it('clears buffs if user does not have a perfect day (no due dailys)', async () => {\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = true;\n      tasksByType.dailys[0].startDate = moment(new Date()).add({\n        days: 1\n      });\n      user.stats.buffs = {\n        str: 1,\n        int: 1,\n        per: 1,\n        con: 1,\n        stealth: 0,\n        streaks: true\n      };\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.buffs.str).to.equal(0);\n      expect(user.stats.buffs.int).to.equal(0);\n      expect(user.stats.buffs.per).to.equal(0);\n      expect(user.stats.buffs.con).to.equal(0);\n      expect(user.stats.buffs.stealth).to.equal(0);\n      expect(user.stats.buffs.streaks).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"clears buffs if user does not have a perfect day (no due dailys) when user is sleeping","suites":["cron","perfect day"],"updatePoint":{"line":1713,"column":94,"index":64689},"line":1713,"code":"    it('clears buffs if user does not have a perfect day (no due dailys) when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = true;\n      tasksByType.dailys[0].startDate = moment(new Date()).add({\n        days: 1\n      });\n      user.stats.buffs = {\n        str: 1,\n        int: 1,\n        per: 1,\n        con: 1,\n        stealth: 0,\n        streaks: true\n      };\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.buffs.str).to.equal(0);\n      expect(user.stats.buffs.int).to.equal(0);\n      expect(user.stats.buffs.per).to.equal(0);\n      expect(user.stats.buffs.con).to.equal(0);\n      expect(user.stats.buffs.stealth).to.equal(0);\n      expect(user.stats.buffs.streaks).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"clears buffs if user does not have a perfect day (at least one due daily not completed)","suites":["cron","perfect day"],"updatePoint":{"line":1741,"column":95,"index":65545},"line":1741,"code":"    it('clears buffs if user does not have a perfect day (at least one due daily not completed)', async () => {\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = false;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      user.stats.buffs = {\n        str: 1,\n        int: 1,\n        per: 1,\n        con: 1,\n        stealth: 0,\n        streaks: true\n      };\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.buffs.str).to.equal(0);\n      expect(user.stats.buffs.int).to.equal(0);\n      expect(user.stats.buffs.per).to.equal(0);\n      expect(user.stats.buffs.con).to.equal(0);\n      expect(user.stats.buffs.stealth).to.equal(0);\n      expect(user.stats.buffs.streaks).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"clears buffs if user does not have a perfect day (at least one due daily not completed) when user is sleeping","suites":["cron","perfect day"],"updatePoint":{"line":1768,"column":117,"index":66392},"line":1768,"code":"    it('clears buffs if user does not have a perfect day (at least one due daily not completed) when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = false;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      user.stats.buffs = {\n        str: 1,\n        int: 1,\n        per: 1,\n        con: 1,\n        stealth: 0,\n        streaks: true\n      };\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.buffs.str).to.equal(0);\n      expect(user.stats.buffs.int).to.equal(0);\n      expect(user.stats.buffs.per).to.equal(0);\n      expect(user.stats.buffs.con).to.equal(0);\n      expect(user.stats.buffs.stealth).to.equal(0);\n      expect(user.stats.buffs.streaks).to.be.false;\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"always grants a perfect day buff when CRON_SAFE_MODE is set","suites":["cron","perfect day"],"updatePoint":{"line":1796,"column":67,"index":67226},"line":1796,"code":"    it('always grants a perfect day buff when CRON_SAFE_MODE is set', async () => {\n      sandbox.stub(nconf, 'get').withArgs('CRON_SAFE_MODE').returns('true');\n      const cronOverride = requireAgain(pathToCronLib).cron;\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = false;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      const previousBuffs = user.stats.buffs.toObject();\n      cronOverride({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.buffs.str).to.be.greaterThan(previousBuffs.str);\n      expect(user.stats.buffs.int).to.be.greaterThan(previousBuffs.int);\n      expect(user.stats.buffs.per).to.be.greaterThan(previousBuffs.per);\n      expect(user.stats.buffs.con).to.be.greaterThan(previousBuffs.con);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"always grants a perfect day buff when CRON_SAFE_MODE is set when user is sleeping","suites":["cron","perfect day"],"updatePoint":{"line":1816,"column":89,"index":68096},"line":1816,"code":"    it('always grants a perfect day buff when CRON_SAFE_MODE is set when user is sleeping', async () => {\n      user.preferences.sleep = true;\n      sandbox.stub(nconf, 'get').withArgs('CRON_SAFE_MODE').returns('true');\n      const cronOverride = requireAgain(pathToCronLib).cron;\n      daysMissed = 1;\n      tasksByType.dailys[0].completed = false;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      const previousBuffs = user.stats.buffs.toObject();\n      cronOverride({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.buffs.str).to.be.greaterThan(previousBuffs.str);\n      expect(user.stats.buffs.int).to.be.greaterThan(previousBuffs.int);\n      expect(user.stats.buffs.per).to.be.greaterThan(previousBuffs.per);\n      expect(user.stats.buffs.con).to.be.greaterThan(previousBuffs.con);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should add mp to user","suites":["cron","adding mp"],"updatePoint":{"line":1839,"column":29,"index":68987},"line":1839,"code":"    it('should add mp to user', async () => {\n      const statsComputedRes = common.statsComputed(user);\n      const stubbedStatsComputed = sinon.stub(common, 'statsComputed');\n      const mpBefore = user.stats.mp;\n      tasksByType.dailys[0].completed = true;\n      stubbedStatsComputed.returns(Object.assign(statsComputedRes, {\n        maxMP: 100\n      }));\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.mp).to.be.greaterThan(mpBefore);\n      common.statsComputed.restore();\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"should not add mp to user when user is sleeping","suites":["cron","adding mp"],"updatePoint":{"line":1856,"column":55,"index":69578},"line":1856,"code":"    it('should not add mp to user when user is sleeping', async () => {\n      const statsComputedRes = common.statsComputed(user);\n      const stubbedStatsComputed = sinon.stub(common, 'statsComputed');\n      user.preferences.sleep = true;\n      const mpBefore = user.stats.mp;\n      tasksByType.dailys[0].completed = true;\n      stubbedStatsComputed.returns(Object.assign(statsComputedRes, {\n        maxMP: 100\n      }));\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.mp).to.equal(mpBefore);\n      common.statsComputed.restore();\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"set user's mp to statsComputed.maxMP when user.stats.mp is greater","suites":["cron","adding mp"],"updatePoint":{"line":1874,"column":75,"index":70217},"line":1874,"code":"    it('set user\\'s mp to statsComputed.maxMP when user.stats.mp is greater', async () => {\n      const statsComputedRes = common.statsComputed(user);\n      const stubbedStatsComputed = sinon.stub(common, 'statsComputed');\n      user.stats.mp = 120;\n      stubbedStatsComputed.returns(Object.assign(statsComputedRes, {\n        maxMP: 100\n      }));\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.stats.mp).to.equal(common.statsComputed(user).maxMP);\n      common.statsComputed.restore();\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"resets user progress","suites":["cron","quest progress"],"updatePoint":{"line":1914,"column":28,"index":71488},"line":1914,"code":"    it('resets user progress', async () => {\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.party.quest.progress.up).to.equal(0);\n      expect(user.party.quest.progress.down).to.equal(0);\n      expect(user.party.quest.progress.collectedItems).to.equal(0);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"applies the user progress","suites":["cron","quest progress"],"updatePoint":{"line":1925,"column":33,"index":71830},"line":1925,"code":"    it('applies the user progress', async () => {\n      const progress = await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(progress.down).to.equal(-1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"adds a user notification","suites":["cron","notifications"],"updatePoint":{"line":1936,"column":32,"index":72096},"line":1936,"code":"    it('adds a user notification', async () => {\n      const mpBefore = user.stats.mp;\n      tasksByType.dailys[0].completed = true;\n      const statsComputedRes = common.statsComputed(user);\n      const stubbedStatsComputed = sinon.stub(common, 'statsComputed');\n      stubbedStatsComputed.returns(Object.assign(statsComputedRes, {\n        maxMP: 100\n      }));\n      daysMissed = 1;\n      const hpBefore = user.stats.hp;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.notifications.length).to.be.greaterThan(0);\n      expect(user.notifications[1].type).to.equal('CRON');\n      expect(user.notifications[1].data).to.eql({\n        hp: user.stats.hp - hpBefore,\n        mp: user.stats.mp - mpBefore\n      });\n      common.statsComputed.restore();\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"condenses multiple notifications into one","suites":["cron","notifications"],"updatePoint":{"line":1963,"column":49,"index":73036},"line":1963,"code":"    it('condenses multiple notifications into one', async () => {\n      const mpBefore1 = user.stats.mp;\n      tasksByType.dailys[0].completed = true;\n      const statsComputedRes = common.statsComputed(user);\n      const stubbedStatsComputed = sinon.stub(common, 'statsComputed');\n      stubbedStatsComputed.returns(Object.assign(statsComputedRes, {\n        maxMP: 100\n      }));\n      daysMissed = 1;\n      const hpBefore1 = user.stats.hp;\n      tasksByType.dailys[0].startDate = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.notifications.length).to.be.greaterThan(0);\n      expect(user.notifications[1].type).to.equal('CRON');\n      expect(user.notifications[1].data).to.eql({\n        hp: user.stats.hp - hpBefore1,\n        mp: user.stats.mp - mpBefore1\n      });\n      const notifsBefore2 = user.notifications.length;\n      const hpBefore2 = user.stats.hp;\n      const mpBefore2 = user.stats.mp;\n      user.lastCron = moment(new Date()).subtract({\n        days: 2\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.notifications.length - notifsBefore2).to.equal(0);\n      expect(user.notifications[0].type).to.not.equal('CRON');\n      expect(user.notifications[1].type).to.equal('CRON');\n      expect(user.notifications[1].data).to.eql({\n        hp: user.stats.hp - hpBefore2 - (hpBefore2 - hpBefore1),\n        mp: user.stats.mp - mpBefore2 - (mpBefore2 - mpBefore1)\n      });\n      expect(user.notifications[0].type).to.not.equal('CRON');\n      common.statsComputed.restore();\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments incentive counter each cron","suites":["cron","login incentives"],"updatePoint":{"line":2040,"column":46,"index":75505},"line":2040,"code":"    it('increments incentive counter each cron', async () => {\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(1);\n      user.lastCron = moment(new Date()).subtract({\n        days: 1\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(2);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"pushes a notification of the day's incentive each cron","suites":["cron","login incentives"],"updatePoint":{"line":2059,"column":63,"index":75967},"line":2059,"code":"    it('pushes a notification of the day\\'s incentive each cron', async () => {\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.notifications.length).to.be.greaterThan(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"replaces previous notifications","suites":["cron","login incentives"],"updatePoint":{"line":2069,"column":39,"index":76263},"line":2069,"code":"    it('replaces previous notifications', async () => {\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      const filteredNotifications = user.notifications.filter(n => n.type === 'LOGIN_INCENTIVE');\n      expect(filteredNotifications.length).to.equal(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments loginIncentives by 1 even if days are skipped in between","suites":["cron","login incentives"],"updatePoint":{"line":2091,"column":75,"index":76823},"line":2091,"code":"    it('increments loginIncentives by 1 even if days are skipped in between', async () => {\n      daysMissed = 3;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increments loginIncentives by 1 even if user is sleeping","suites":["cron","login incentives"],"updatePoint":{"line":2101,"column":64,"index":77082},"line":2101,"code":"    it('increments loginIncentives by 1 even if user is sleeping', async () => {\n      user.preferences.sleep = true;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(1);\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user bard robes if login incentive is 1","suites":["cron","login incentives"],"updatePoint":{"line":2111,"column":54,"index":77346},"line":2111,"code":"    it('awards user bard robes if login incentive is 1', async () => {\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(1);\n      expect(user.items.gear.owned.armor_special_bardRobes).to.eql(true);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user incentive backgrounds if login incentive is 2","suites":["cron","login incentives"],"updatePoint":{"line":2122,"column":65,"index":77726},"line":2122,"code":"    it('awards user incentive backgrounds if login incentive is 2', async () => {\n      user.loginIncentives = 1;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(2);\n      expect(user.purchased.background.blue).to.eql(true);\n      expect(user.purchased.background.green).to.eql(true);\n      expect(user.purchased.background.purple).to.eql(true);\n      expect(user.purchased.background.red).to.eql(true);\n      expect(user.purchased.background.yellow).to.eql(true);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user Bard Hat if login incentive is 3","suites":["cron","login incentives"],"updatePoint":{"line":2138,"column":52,"index":78350},"line":2138,"code":"    it('awards user Bard Hat if login incentive is 3', async () => {\n      user.loginIncentives = 2;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(3);\n      expect(user.items.gear.owned.head_special_bardHat).to.eql(true);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user RoyalPurple Hatching Potion if login incentive is 4","suites":["cron","login incentives"],"updatePoint":{"line":2150,"column":71,"index":78765},"line":2150,"code":"    it('awards user RoyalPurple Hatching Potion if login incentive is 4', async () => {\n      user.loginIncentives = 3;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(4);\n      expect(user.items.hatchingPotions.RoyalPurple).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user a Chocolate, Meat and Pink Contton Candy if login incentive is 5","suites":["cron","login incentives"],"updatePoint":{"line":2162,"column":84,"index":79186},"line":2162,"code":"    it('awards user a Chocolate, Meat and Pink Contton Candy if login incentive is 5', async () => {\n      user.loginIncentives = 4;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(5);\n      expect(user.items.food.Chocolate).to.eql(1);\n      expect(user.items.food.Meat).to.eql(1);\n      expect(user.items.food.CottonCandyPink).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user moon quest if login incentive is 7","suites":["cron","login incentives"],"updatePoint":{"line":2176,"column":54,"index":79667},"line":2176,"code":"    it('awards user moon quest if login incentive is 7', async () => {\n      user.loginIncentives = 6;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(7);\n      expect(user.items.quests.moon1).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user RoyalPurple Hatching Potion if login incentive is 10","suites":["cron","login incentives"],"updatePoint":{"line":2188,"column":72,"index":80061},"line":2188,"code":"    it('awards user RoyalPurple Hatching Potion if login incentive is 10', async () => {\n      user.loginIncentives = 9;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(10);\n      expect(user.items.hatchingPotions.RoyalPurple).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user a Strawberry, Patato and Blue Contton Candy if login incentive is 14","suites":["cron","login incentives"],"updatePoint":{"line":2200,"column":88,"index":80487},"line":2200,"code":"    it('awards user a Strawberry, Patato and Blue Contton Candy if login incentive is 14', async () => {\n      user.loginIncentives = 13;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(14);\n      expect(user.items.food.Strawberry).to.eql(1);\n      expect(user.items.food.Potatoe).to.eql(1);\n      expect(user.items.food.CottonCandyBlue).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user a bard instrument if login incentive is 18","suites":["cron","login incentives"],"updatePoint":{"line":2214,"column":62,"index":80982},"line":2214,"code":"    it('awards user a bard instrument if login incentive is 18', async () => {\n      user.loginIncentives = 17;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(18);\n      expect(user.items.gear.owned.weapon_special_bardInstrument).to.eql(true);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user second moon quest if login incentive is 22","suites":["cron","login incentives"],"updatePoint":{"line":2226,"column":62,"index":81399},"line":2226,"code":"    it('awards user second moon quest if login incentive is 22', async () => {\n      user.loginIncentives = 21;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(22);\n      expect(user.items.quests.moon2).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user a RoyalPurple hatching potion if login incentive is 26","suites":["cron","login incentives"],"updatePoint":{"line":2238,"column":74,"index":81797},"line":2238,"code":"    it('awards user a RoyalPurple hatching potion if login incentive is 26', async () => {\n      user.loginIncentives = 25;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(26);\n      expect(user.items.hatchingPotions.RoyalPurple).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user Fish, Milk, Rotten Meat and Honey if login incentive is 30","suites":["cron","login incentives"],"updatePoint":{"line":2250,"column":78,"index":82214},"line":2250,"code":"    it('awards user Fish, Milk, Rotten Meat and Honey if login incentive is 30', async () => {\n      user.loginIncentives = 29;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(30);\n      expect(user.items.food.Fish).to.eql(1);\n      expect(user.items.food.Milk).to.eql(1);\n      expect(user.items.food.RottenMeat).to.eql(1);\n      expect(user.items.food.Honey).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user a RoyalPurple hatching potion if login incentive is 35","suites":["cron","login incentives"],"updatePoint":{"line":2265,"column":74,"index":82754},"line":2265,"code":"    it('awards user a RoyalPurple hatching potion if login incentive is 35', async () => {\n      user.loginIncentives = 34;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(35);\n      expect(user.items.hatchingPotions.RoyalPurple).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user the third moon quest if login incentive is 40","suites":["cron","login incentives"],"updatePoint":{"line":2277,"column":65,"index":83158},"line":2277,"code":"    it('awards user the third moon quest if login incentive is 40', async () => {\n      user.loginIncentives = 39;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(40);\n      expect(user.items.quests.moon3).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user a RoyalPurple hatching potion if login incentive is 45","suites":["cron","login incentives"],"updatePoint":{"line":2289,"column":74,"index":83556},"line":2289,"code":"    it('awards user a RoyalPurple hatching potion if login incentive is 45', async () => {\n      user.loginIncentives = 44;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(45);\n      expect(user.items.hatchingPotions.RoyalPurple).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"awards user a saddle if login incentive is 50","suites":["cron","login incentives"],"updatePoint":{"line":2301,"column":53,"index":83948},"line":2301,"code":"    it('awards user a saddle if login incentive is 50', async () => {\n      user.loginIncentives = 49;\n      await cron({\n        user,\n        tasksByType,\n        daysMissed,\n        analytics\n      });\n      expect(user.loginIncentives).to.eql(50);\n      expect(user.items.food.Saddle).to.eql(1);\n      expect(user.notifications[0].type).to.eql('LOGIN_INCENTIVE');\n    });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"throws an error if user cannot be found","suites":["recoverCron"],"updatePoint":{"line":2345,"column":45,"index":84972},"line":2345,"code":"  it('throws an error if user cannot be found', async () => {\n    execStub.returns(Promise.resolve(null));\n\n    try {\n      await recoverCron(status, locals);\n      throw new Error('no exception when user cannot be found');\n    } catch (err) {\n      expect(err.message).to.eql(`User ${locals.user._id} not found while recovering.`);\n    }\n  });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"increases status.times count and reruns up to 4 times","suites":["recoverCron"],"updatePoint":{"line":2355,"column":59,"index":85331},"line":2355,"code":"  it('increases status.times count and reruns up to 4 times', async () => {\n    execStub.returns(Promise.resolve({\n      _cronSignature: 'RUNNING_CRON'\n    }));\n    execStub.onCall(4).returns(Promise.resolve({\n      _cronSignature: 'NOT_RUNNING'\n    }));\n    await recoverCron(status, locals);\n    expect(status.times).to.eql(4);\n    expect(locals.user).to.eql({\n      _cronSignature: 'NOT_RUNNING'\n    });\n  });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"throws an error if recoverCron runs 5 times","suites":["recoverCron"],"updatePoint":{"line":2368,"column":49,"index":85734},"line":2368,"code":"  it('throws an error if recoverCron runs 5 times', async () => {\n    execStub.returns(Promise.resolve({\n      _cronSignature: 'RUNNING_CRON'\n    }));\n\n    try {\n      await recoverCron(status, locals);\n      throw new Error('no exception when recoverCron runs 5 times');\n    } catch (err) {\n      expect(status.times).to.eql(5);\n      expect(err.message).to.eql(`Impossible to recover from cron for user ${locals.user._id}.`);\n    }\n  });","file":"api/unit/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"returns an empty object if no field request","suites":["emails","getUserInfo"],"updatePoint":{"line":46,"column":51,"index":1006},"line":46,"code":"    it('returns an empty object if no field request', () => {\n      const attachEmail = requireAgain(pathToEmailLib);\n      const {\n        getUserInfo\n      } = attachEmail;\n      expect(getUserInfo({}, [])).to.be.empty;\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"returns correct user data","suites":["emails","getUserInfo"],"updatePoint":{"line":53,"column":33,"index":1218},"line":53,"code":"    it('returns correct user data', () => {\n      const attachEmail = requireAgain(pathToEmailLib);\n      const {\n        getUserInfo\n      } = attachEmail;\n      const user = getUser();\n      const data = getUserInfo(user, ['name', 'email', '_id', 'canSend']);\n      expect(data).to.have.property('name', user.auth.local.username);\n      expect(data).to.have.property('email', user.auth.local.email);\n      expect(data).to.have.property('_id', user._id);\n      expect(data).to.have.property('canSend', true);\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"returns correct user data [facebook users]","suites":["emails","getUserInfo"],"updatePoint":{"line":65,"column":50,"index":1753},"line":65,"code":"    it('returns correct user data [facebook users]', () => {\n      const attachEmail = requireAgain(pathToEmailLib);\n      const {\n        getUserInfo\n      } = attachEmail;\n      const user = getUser();\n      delete user.profile.name;\n      delete user.auth.local.email;\n      delete user.auth.google.emails;\n      delete user.auth.apple.emails;\n      const data = getUserInfo(user, ['name', 'email', '_id', 'canSend']);\n      expect(data).to.have.property('name', user.auth.local.username);\n      expect(data).to.have.property('email', user.auth.facebook.emails[0].value);\n      expect(data).to.have.property('_id', user._id);\n      expect(data).to.have.property('canSend', true);\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"returns correct user data [google users]","suites":["emails","getUserInfo"],"updatePoint":{"line":81,"column":48,"index":2442},"line":81,"code":"    it('returns correct user data [google users]', () => {\n      const attachEmail = requireAgain(pathToEmailLib);\n      const {\n        getUserInfo\n      } = attachEmail;\n      const user = getUser();\n      delete user.profile.name;\n      delete user.auth.local.email;\n      delete user.auth.facebook.emails;\n      delete user.auth.apple.emails;\n      const data = getUserInfo(user, ['name', 'email', '_id', 'canSend']);\n      expect(data).to.have.property('name', user.auth.local.username);\n      expect(data).to.have.property('email', user.auth.google.emails[0].value);\n      expect(data).to.have.property('_id', user._id);\n      expect(data).to.have.property('canSend', true);\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"returns correct user data [apple users]","suites":["emails","getUserInfo"],"updatePoint":{"line":97,"column":47,"index":3130},"line":97,"code":"    it('returns correct user data [apple users]', () => {\n      const attachEmail = requireAgain(pathToEmailLib);\n      const {\n        getUserInfo\n      } = attachEmail;\n      const user = getUser();\n      delete user.profile.name;\n      delete user.auth.local.email;\n      delete user.auth.google.emails;\n      delete user.auth.facebook.emails;\n      const data = getUserInfo(user, ['name', 'email', '_id', 'canSend']);\n      expect(data).to.have.property('name', user.auth.local.username);\n      expect(data).to.have.property('email', user.auth.apple.emails[0].value);\n      expect(data).to.have.property('_id', user._id);\n      expect(data).to.have.property('canSend', true);\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"has fallbacks for missing data","suites":["emails","getUserInfo"],"updatePoint":{"line":113,"column":38,"index":3809},"line":113,"code":"    it('has fallbacks for missing data', () => {\n      const attachEmail = requireAgain(pathToEmailLib);\n      const {\n        getUserInfo\n      } = attachEmail;\n      const user = getUser();\n      delete user.auth.local.email;\n      delete user.auth.facebook;\n      delete user.auth.google;\n      delete user.auth.apple;\n      const data = getUserInfo(user, ['name', 'email', '_id', 'canSend']);\n      expect(data).to.have.property('name', user.auth.local.username);\n      expect(data).not.to.have.property('email');\n      expect(data).to.have.property('_id', user._id);\n      expect(data).to.have.property('canSend', true);\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"returns correct url if group is the tavern","suites":["emails","getGroupUrl"],"updatePoint":{"line":131,"column":50,"index":4495},"line":131,"code":"    it('returns correct url if group is the tavern', () => {\n      const {\n        getGroupUrl\n      } = require(pathToEmailLib); // eslint-disable-line import/no-dynamic-require, max-len\n\n\n      expect(getGroupUrl({\n        _id: TAVERN_ID,\n        type: 'guild'\n      })).to.eql('/groups/tavern');\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"returns correct url if group is a guild","suites":["emails","getGroupUrl"],"updatePoint":{"line":142,"column":47,"index":4799},"line":142,"code":"    it('returns correct url if group is a guild', () => {\n      const {\n        getGroupUrl\n      } = require(pathToEmailLib); // eslint-disable-line import/no-dynamic-require, max-len\n\n\n      expect(getGroupUrl({\n        _id: 'random _id',\n        type: 'guild'\n      })).to.eql('/groups/guild/random _id');\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"returns correct url if group is a party","suites":["emails","getGroupUrl"],"updatePoint":{"line":153,"column":47,"index":5116},"line":153,"code":"    it('returns correct url if group is a party', () => {\n      const {\n        getGroupUrl\n      } = require(pathToEmailLib); // eslint-disable-line import/no-dynamic-require, max-len\n\n\n      expect(getGroupUrl({\n        _id: 'random _id',\n        type: 'party'\n      })).to.eql('party');\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"can send a txn email to one recipient","suites":["emails","sendTxn"],"updatePoint":{"line":178,"column":45,"index":5879},"line":178,"code":"    it('can send a txn email to one recipient', () => {\n      const emailType = 'an email type';\n      const mailingInfo = {\n        name: 'my name',\n        email: 'my@email'\n      };\n      sendTxn(mailingInfo, emailType);\n      expect(got.post).to.be.called;\n      expect(got.post).to.be.calledWith('undefined/job', sinon.match({\n        json: {\n          data: {\n            emailType: sinon.match.same(emailType),\n            to: sinon.match(value => Array.isArray(value) && value[0].name === mailingInfo.name, 'matches mailing info array')\n          }\n        }\n      }));\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"does not send email if address is missing","suites":["emails","sendTxn"],"updatePoint":{"line":195,"column":49,"index":6469},"line":195,"code":"    it('does not send email if address is missing', () => {\n      const emailType = 'an email type';\n      const mailingInfo = {\n        name: 'my name' // email: 'my@email',\n\n      };\n      sendTxn(mailingInfo, emailType);\n      expect(got.post).not.to.be.called;\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"throws error when mail target is only a string","suites":["emails","sendTxn"],"updatePoint":{"line":204,"column":54,"index":6747},"line":204,"code":"    it('throws error when mail target is only a string', () => {\n      const emailType = 'an email type';\n      const mailingInfo = 'my email';\n      expect(sendTxn(mailingInfo, emailType)).to.throw;\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"throws error when mail target has no _id or email","suites":["emails","sendTxn"],"updatePoint":{"line":209,"column":57,"index":6958},"line":209,"code":"    it('throws error when mail target has no _id or email', () => {\n      const emailType = 'an email type';\n      const mailingInfo = {};\n      expect(sendTxn(mailingInfo, emailType)).to.throw;\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"throws error when variables not an array","suites":["emails","sendTxn"],"updatePoint":{"line":214,"column":48,"index":7152},"line":214,"code":"    it('throws error when variables not an array', () => {\n      const emailType = 'an email type';\n      const mailingInfo = {\n        name: 'my name',\n        email: 'my@email'\n      };\n      const variables = {};\n      expect(sendTxn(mailingInfo, emailType, variables)).to.throw;\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"throws error when variables array not contain name/content","suites":["emails","sendTxn"],"updatePoint":{"line":223,"column":66,"index":7461},"line":223,"code":"    it('throws error when variables array not contain name/content', () => {\n      const emailType = 'an email type';\n      const mailingInfo = {\n        name: 'my name',\n        email: 'my@email'\n      };\n      const variables = [{}];\n      expect(sendTxn(mailingInfo, emailType, variables)).to.throw;\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"throws no error when variables array contain name but no content","suites":["emails","sendTxn"],"updatePoint":{"line":232,"column":72,"index":7778},"line":232,"code":"    it('throws no error when variables array contain name but no content', () => {\n      const emailType = 'an email type';\n      const mailingInfo = {\n        name: 'my name',\n        email: 'my@email'\n      };\n      const variables = [{\n        name: 'MY_VAR'\n      }];\n      expect(sendTxn(mailingInfo, emailType, variables)).to.not.throw;\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"uses getUserInfo in case of user data","suites":["emails","sendTxn"],"updatePoint":{"line":243,"column":45,"index":8102},"line":243,"code":"    it('uses getUserInfo in case of user data', () => {\n      const emailType = 'an email type';\n      const mailingInfo = getUser();\n      sendTxn(mailingInfo, emailType);\n      expect(got.post).to.be.called;\n      expect(got.post).to.be.calledWith('undefined/job', sinon.match({\n        json: {\n          data: {\n            emailType: sinon.match.same(emailType),\n            to: sinon.match(val => val[0]._id === mailingInfo._id)\n          }\n        }\n      }));\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"sends email with some default variables","suites":["emails","sendTxn"],"updatePoint":{"line":257,"column":47,"index":8579},"line":257,"code":"    it('sends email with some default variables', () => {\n      const emailType = 'an email type';\n      const mailingInfo = {\n        name: 'my name',\n        email: 'my@email'\n      };\n      const variables = [];\n      sendTxn(mailingInfo, emailType, variables);\n      expect(got.post).to.be.called;\n      expect(got.post).to.be.calledWith('undefined/job', sinon.match({\n        json: {\n          data: {\n            variables: sinon.match(value => value[0].name === 'BASE_URL', 'matches variables'),\n            personalVariables: sinon.match(value => value[0].rcpt === mailingInfo.email && value[0].vars[0].name === 'RECIPIENT_NAME' && value[0].vars[1].name === 'RECIPIENT_UNSUB_URL', 'matches personal variables')\n          }\n        }\n      }));\n    });","file":"api/unit/libs/email.test.js","skipped":false,"dir":"test"},{"name":"can encrypt and decrypt","suites":["encryption"],"updatePoint":{"line":3,"column":29,"index":140},"line":3,"code":"  it('can encrypt and decrypt', () => {\n    const data = 'some secret text';\n    const encrypted = encrypt(data);\n    const decrypted = decrypt(encrypted);\n    expect(encrypted).not.to.equal(data);\n    expect(data).to.equal(decrypted);\n  });","file":"api/unit/libs/encryption.test.js","skipped":false,"dir":"test"},{"name":"is an instance of Error","suites":["Custom Errors","CustomError"],"updatePoint":{"line":6,"column":31,"index":349},"line":6,"code":"    it('is an instance of Error', () => {\n      const customError = new CustomError();\n      expect(customError).to.be.an.instanceOf(Error);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"is an instance of CustomError","suites":["Custom Errors","NotAuthorized"],"updatePoint":{"line":12,"column":37,"index":546},"line":12,"code":"    it('is an instance of CustomError', () => {\n      const notAuthorizedError = new NotAuthorized();\n      expect(notAuthorizedError).to.be.an.instanceOf(CustomError);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"it returns an http code of 401","suites":["Custom Errors","NotAuthorized"],"updatePoint":{"line":16,"column":38,"index":724},"line":16,"code":"    it('it returns an http code of 401', () => {\n      const notAuthorizedError = new NotAuthorized();\n      expect(notAuthorizedError.httpCode).to.eql(401);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"returns a default message","suites":["Custom Errors","NotAuthorized"],"updatePoint":{"line":20,"column":33,"index":885},"line":20,"code":"    it('returns a default message', () => {\n      const notAuthorizedError = new NotAuthorized();\n      expect(notAuthorizedError.message).to.eql('Not authorized.');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"allows a custom message","suites":["Custom Errors","NotAuthorized"],"updatePoint":{"line":24,"column":31,"index":1057},"line":24,"code":"    it('allows a custom message', () => {\n      const notAuthorizedError = new NotAuthorized('Custom Error Message');\n      expect(notAuthorizedError.message).to.eql('Custom Error Message');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"is an instance of CustomError","suites":["Custom Errors","NotFound"],"updatePoint":{"line":30,"column":37,"index":1299},"line":30,"code":"    it('is an instance of CustomError', () => {\n      const notAuthorizedError = new NotFound();\n      expect(notAuthorizedError).to.be.an.instanceOf(CustomError);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"it returns an http code of 404","suites":["Custom Errors","NotFound"],"updatePoint":{"line":34,"column":38,"index":1472},"line":34,"code":"    it('it returns an http code of 404', () => {\n      const notAuthorizedError = new NotFound();\n      expect(notAuthorizedError.httpCode).to.eql(404);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"returns a default message","suites":["Custom Errors","NotFound"],"updatePoint":{"line":38,"column":33,"index":1628},"line":38,"code":"    it('returns a default message', () => {\n      const notAuthorizedError = new NotFound();\n      expect(notAuthorizedError.message).to.eql('Not found.');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"allows a custom message","suites":["Custom Errors","NotFound"],"updatePoint":{"line":42,"column":31,"index":1790},"line":42,"code":"    it('allows a custom message', () => {\n      const notAuthorizedError = new NotFound('Custom Error Message');\n      expect(notAuthorizedError.message).to.eql('Custom Error Message');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"is an instance of NotFound","suites":["Custom Errors","NotFound","NotificationNotFound"],"updatePoint":{"line":47,"column":36,"index":2034},"line":47,"code":"      it('is an instance of NotFound', () => {\n        const notificationNotFoundErr = new NotificationNotFound();\n        expect(notificationNotFoundErr).to.be.an.instanceOf(NotFound);\n      });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"it returns an http code of 404","suites":["Custom Errors","NotFound","NotificationNotFound"],"updatePoint":{"line":51,"column":40,"index":2234},"line":51,"code":"      it('it returns an http code of 404', () => {\n        const notificationNotFoundErr = new NotificationNotFound();\n        expect(notificationNotFoundErr.httpCode).to.eql(404);\n      });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"returns a standard message","suites":["Custom Errors","NotFound","NotificationNotFound"],"updatePoint":{"line":55,"column":36,"index":2421},"line":55,"code":"      it('returns a standard message', () => {\n        const notificationNotFoundErr = new NotificationNotFound();\n        expect(notificationNotFoundErr.message).to.eql(i18n.t('messageNotificationNotFound'));\n      });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"is an instance of CustomError","suites":["Custom Errors","BadRequest"],"updatePoint":{"line":62,"column":37,"index":2689},"line":62,"code":"    it('is an instance of CustomError', () => {\n      const badRequestError = new BadRequest();\n      expect(badRequestError).to.be.an.instanceOf(CustomError);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"it returns an http code of 401","suites":["Custom Errors","BadRequest"],"updatePoint":{"line":66,"column":38,"index":2858},"line":66,"code":"    it('it returns an http code of 401', () => {\n      const badRequestError = new BadRequest();\n      expect(badRequestError.httpCode).to.eql(400);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"returns a default message","suites":["Custom Errors","BadRequest"],"updatePoint":{"line":70,"column":33,"index":3010},"line":70,"code":"    it('returns a default message', () => {\n      const badRequestError = new BadRequest();\n      expect(badRequestError.message).to.eql('Bad request.');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"allows a custom message","suites":["Custom Errors","BadRequest"],"updatePoint":{"line":74,"column":31,"index":3170},"line":74,"code":"    it('allows a custom message', () => {\n      const badRequestError = new BadRequest('Custom Error Message');\n      expect(badRequestError.message).to.eql('Custom Error Message');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"is an instance of CustomError","suites":["Custom Errors","Forbidden"],"updatePoint":{"line":80,"column":37,"index":3404},"line":80,"code":"    it('is an instance of CustomError', () => {\n      const forbiddenError = new Forbidden();\n      expect(forbiddenError).to.be.an.instanceOf(CustomError);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"it returns an http code of 401","suites":["Custom Errors","Forbidden"],"updatePoint":{"line":84,"column":38,"index":3570},"line":84,"code":"    it('it returns an http code of 401', () => {\n      const forbiddenError = new Forbidden();\n      expect(forbiddenError.httpCode).to.eql(403);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"returns a default message","suites":["Custom Errors","Forbidden"],"updatePoint":{"line":88,"column":33,"index":3719},"line":88,"code":"    it('returns a default message', () => {\n      const forbiddenError = new Forbidden();\n      expect(forbiddenError.message).to.eql('Access forbidden.');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"allows a custom message","suites":["Custom Errors","Forbidden"],"updatePoint":{"line":92,"column":31,"index":3881},"line":92,"code":"    it('allows a custom message', () => {\n      const forbiddenError = new Forbidden('Custom Error Message');\n      expect(forbiddenError.message).to.eql('Custom Error Message');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"is an instance of CustomError","suites":["Custom Errors","InternalServerError"],"updatePoint":{"line":98,"column":37,"index":4122},"line":98,"code":"    it('is an instance of CustomError', () => {\n      const internalServerError = new InternalServerError();\n      expect(internalServerError).to.be.an.instanceOf(CustomError);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"it returns an http code of 500","suites":["Custom Errors","InternalServerError"],"updatePoint":{"line":102,"column":38,"index":4308},"line":102,"code":"    it('it returns an http code of 500', () => {\n      const internalServerError = new InternalServerError();\n      expect(internalServerError.httpCode).to.eql(500);\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"returns a default message","suites":["Custom Errors","InternalServerError"],"updatePoint":{"line":106,"column":33,"index":4477},"line":106,"code":"    it('returns a default message', () => {\n      const internalServerError = new InternalServerError();\n      expect(internalServerError.message).to.eql('An unexpected error occurred.');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"allows a custom message","suites":["Custom Errors","InternalServerError"],"updatePoint":{"line":110,"column":31,"index":4671},"line":110,"code":"    it('allows a custom message', () => {\n      const internalServerError = new InternalServerError('Custom Error Message');\n      expect(internalServerError.message).to.eql('Custom Error Message');\n    });","file":"api/unit/libs/errors.test.js","skipped":false,"dir":"test"},{"name":"doesn't change text without mentions","suites":["highlightMentions"],"updatePoint":{"line":59,"column":43,"index":1174},"line":59,"code":"  it('doesn\\'t change text without mentions', async () => {\n    const text = 'some chat text';\n    const result = await highlightMentions(text);\n    expect(result[0]).to.equal(text);\n  });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"highlights existing users","suites":["highlightMentions"],"updatePoint":{"line":64,"column":31,"index":1351},"line":64,"code":"  it('highlights existing users', async () => {\n    const text = '@user: message';\n    const result = await highlightMentions(text);\n    expect(result[0]).to.equal('[@user](/profile/111): message');\n  });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"highlights special characters","suites":["highlightMentions"],"updatePoint":{"line":69,"column":35,"index":1560},"line":69,"code":"  it('highlights special characters', async () => {\n    const text = '@user-dash: message @user_underscore';\n    const result = await highlightMentions(text);\n    expect(result[0]).to.equal('[@user-dash](/profile/444): message [@user_underscore](/profile/555)');\n  });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight nonexisting users","suites":["highlightMentions"],"updatePoint":{"line":74,"column":42,"index":1836},"line":74,"code":"  it('doesn\\'t highlight nonexisting users', async () => {\n    const text = '@nouser message';\n    const result = await highlightMentions(text);\n    expect(result[0]).to.equal('@nouser message');\n  });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"highlights multiple existing users","suites":["highlightMentions"],"updatePoint":{"line":79,"column":40,"index":2036},"line":79,"code":"  it('highlights multiple existing users', async () => {\n    const text = '@user message (@user2) @user3 @user';\n    const result = await highlightMentions(text);\n    expect(result[0]).to.equal('[@user](/profile/111) message ([@user2](/profile/222)) [@user3](/profile/333) [@user](/profile/111)');\n  });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight more than 5 users","suites":["highlightMentions"],"updatePoint":{"line":84,"column":42,"index":2342},"line":84,"code":"  it('doesn\\'t highlight more than 5 users', async () => {\n    const text = '@user @user2 @user3 @user4 @user5 @user6';\n    const result = await highlightMentions(text);\n    expect(result[0]).to.equal(text);\n  });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight users in link","suites":["highlightMentions","link interactions"],"updatePoint":{"line":90,"column":40,"index":2600},"line":90,"code":"    it('doesn\\'t highlight users in link', async () => {\n      const text = 'http://www.medium.com/@user/blog';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight user in link between brackets","suites":["highlightMentions","link interactions"],"updatePoint":{"line":95,"column":56,"index":2828},"line":95,"code":"    it('doesn\\'t highlight user in link between brackets', async () => {\n      const text = '(http://www.medium.com/@user/blog)';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight user in an autolink","suites":["highlightMentions","link interactions"],"updatePoint":{"line":100,"column":46,"index":3048},"line":100,"code":"    it('doesn\\'t highlight user in an autolink', async () => {\n      const text = '<http://www.medium.com/@user/blog>';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight users in link text","suites":["highlightMentions","link interactions"],"updatePoint":{"line":105,"column":45,"index":3267},"line":105,"code":"    it('doesn\\'t highlight users in link text', async () => {\n      const text = '[Check awesome blog written by @user](http://www.medium.com/@user/blog)';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight users in link with newlines and markup","suites":["highlightMentions","link interactions"],"updatePoint":{"line":110,"column":65,"index":3543},"line":110,"code":"    it('doesn\\'t highlight users in link with newlines and markup', async () => {\n      const text = '[Check `awesome` \\nblog **written** by @user](http://www.medium.com/@user/blog)';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight users in link when followed by same @user mention","suites":["highlightMentions","link interactions"],"updatePoint":{"line":115,"column":76,"index":3838},"line":115,"code":"    it('doesn\\'t highlight users in link when followed by same @user mention', async () => {\n      const text = 'http://www.medium.com/@user/blog @user';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal('http://www.medium.com/@user/blog [@user](/profile/111)');\n    }); // https://spec.commonmark.org/0.29/#example-483","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight user in a link without url","suites":["highlightMentions","link interactions"],"updatePoint":{"line":121,"column":53,"index":4171},"line":121,"code":"    it('doesn\\'t highlight user in a link without url', async () => {\n      const text = '[@user2]()';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    }); // https://github.com/HabitRPG/habitica/issues/12217","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight user in link with url-escapable characters","suites":["highlightMentions","link interactions"],"updatePoint":{"line":127,"column":69,"index":4444},"line":127,"code":"    it('doesn\\'t highlight user in link with url-escapable characters', async () => {\n      const text = '[test](https://habitica.fandom.com/ru/@wiki/Снаряжение)';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    }); // https://github.com/HabitRPG/habitica/issues/12223","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"matches a link in between two the same links","suites":["highlightMentions","link interactions"],"updatePoint":{"line":133,"column":52,"index":4745},"line":133,"code":"    it('matches a link in between two the same links', async () => {\n      const text = '[here](http://habitica.wikia.com/wiki/The_Keep:Pirate_Cove/FAQ)\\n@user\\n[hier](http://habitica.wikia.com/wiki/The_Keep:Pirate_Cove/FAQ)';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal('[here](http://habitica.wikia.com/wiki/The_Keep:Pirate_Cove/FAQ)\\n[@user](/profile/111)\\n[hier](http://habitica.wikia.com/wiki/The_Keep:Pirate_Cove/FAQ)');\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight user in inline code block","suites":["highlightMentions","exceptions in code blocks"],"updatePoint":{"line":140,"column":52,"index":5275},"line":140,"code":"    it('doesn\\'t highlight user in inline code block', async () => {\n      const text = '`@user`';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight user in fenced code block","suites":["highlightMentions","exceptions in code blocks"],"updatePoint":{"line":145,"column":52,"index":5474},"line":145,"code":"    it('doesn\\'t highlight user in fenced code block', async () => {\n      const text = 'Text\\n\\n```\\n// code referencing @user\\n```\\n\\nText';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"doesn't highlight user in indented code block","suites":["highlightMentions","exceptions in code blocks"],"updatePoint":{"line":150,"column":54,"index":5719},"line":150,"code":"    it('doesn\\'t highlight user in indented code block', async () => {\n      const text = '      @user';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"does highlight user that's after in-line code block","suites":["highlightMentions","exceptions in code blocks"],"updatePoint":{"line":155,"column":60,"index":5930},"line":155,"code":"    it('does highlight user that\\'s after in-line code block', async () => {\n      const text = '`<code />` for @user';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal('`<code />` for [@user](/profile/111)');\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"does highlight same content properly","suites":["highlightMentions","exceptions in code blocks"],"updatePoint":{"line":160,"column":44,"index":6168},"line":160,"code":"    it('does highlight same content properly', async () => {\n      const text = '@user `@user`';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal('[@user](/profile/111) `@user`');\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"github issue 12118, method crashes when square brackets are used","suites":["highlightMentions","issues"],"updatePoint":{"line":167,"column":72,"index":6455},"line":167,"code":"    it('github issue 12118, method crashes when square brackets are used', async () => {\n      const text = '[test]';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"github issue 12138, method crashes when regex chars are used in code block","suites":["highlightMentions","issues"],"updatePoint":{"line":172,"column":82,"index":6683},"line":172,"code":"    it('github issue 12138, method crashes when regex chars are used in code block', async () => {\n      const text = '`[test]`';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"github issue 12586, method crashes when empty link is used","suites":["highlightMentions","issues"],"updatePoint":{"line":177,"column":66,"index":6897},"line":177,"code":"    it('github issue 12586, method crashes when empty link is used', async () => {\n      const text = '[]()';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"github issue 12586, method crashes when link without title is used","suites":["highlightMentions","issues"],"updatePoint":{"line":182,"column":74,"index":7115},"line":182,"code":"    it('github issue 12586, method crashes when link without title is used', async () => {\n      const text = '[](www.google.com)';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal(text);\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"should prefix habitica.com if it is production","suites":["highlightMentions","base url"],"updatePoint":{"line":189,"column":54,"index":7364},"line":189,"code":"    it('should prefix habitica.com if it is production', async () => {\n      const OLD_NODE_ENV = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'production';\n      const text = '@user';\n      const result = await highlightMentions(text);\n      expect(result[0]).to.equal('[@user](https://habitica.com/profile/111)');\n      process.env.NODE_ENV = OLD_NODE_ENV;\n    });","file":"api/unit/libs/highlightMentions.test.js","skipped":false,"dir":"test"},{"name":"includes a translation object for each locale","suites":["i18n","translations"],"updatePoint":{"line":5,"column":53,"index":263},"line":5,"code":"    it('includes a translation object for each locale', () => {\n      listOfLocales.forEach(locale => {\n        expect(translations[locale]).to.be.an('object');\n      });\n    });","file":"api/unit/libs/i18n.test.js","skipped":false,"dir":"test"},{"name":"is a list of all the language codes","suites":["i18n","langCodes"],"updatePoint":{"line":12,"column":43,"index":470},"line":12,"code":"    it('is a list of all the language codes', () => {\n      expect(langCodes.sort()).to.eql(listOfLocales);\n    });","file":"api/unit/libs/i18n.test.js","skipped":false,"dir":"test"},{"name":"clones the result object","suites":["Items Utils","getDefaultOwnedGear"],"updatePoint":{"line":5,"column":32,"index":255},"line":5,"code":"    it('clones the result object', () => {\n      const res1 = getDefaultOwnedGear();\n      res1.extraProperty = true;\n      const res2 = getDefaultOwnedGear();\n      expect(res2).not.to.have.property('extraProperty');\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"returns false if not an item path","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":13,"column":41,"index":535},"line":13,"code":"    it('returns false if not an item path', () => {\n      expect(validateItemPath('notitems.gear.owned.item')).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"returns true if a valid schema path","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":16,"column":43,"index":673},"line":16,"code":"    it('returns true if a valid schema path', () => {\n      expect(validateItemPath('items.gear.equipped.weapon')).to.equal(true);\n      expect(validateItemPath('items.currentPet')).to.equal(true);\n      expect(validateItemPath('items.special.snowball')).to.equal(true);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"works with owned gear paths","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":21,"column":35,"index":944},"line":21,"code":"    it('works with owned gear paths', () => {\n      expect(validateItemPath('items.gear.owned.head_armoire_crownOfHearts')).to.equal(true);\n      expect(validateItemPath('items.gear.owned.head_invalid')).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"works with pets paths","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":25,"column":29,"index":1167},"line":25,"code":"    it('works with pets paths', () => {\n      expect(validateItemPath('items.pets.Wolf-CottonCandyPink')).to.equal(true);\n      expect(validateItemPath('items.pets.Wolf-Invalid')).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"works with eggs paths","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":29,"column":29,"index":1372},"line":29,"code":"    it('works with eggs paths', () => {\n      expect(validateItemPath('items.eggs.LionCub')).to.equal(true);\n      expect(validateItemPath('items.eggs.Armadillo')).to.equal(true);\n      expect(validateItemPath('items.eggs.NotAnArmadillo')).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"works with hatching potions paths","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":34,"column":41,"index":1649},"line":34,"code":"    it('works with hatching potions paths', () => {\n      expect(validateItemPath('items.hatchingPotions.Base')).to.equal(true);\n      expect(validateItemPath('items.hatchingPotions.StarryNight')).to.equal(true);\n      expect(validateItemPath('items.hatchingPotions.Invalid')).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"works with food paths","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":39,"column":29,"index":1939},"line":39,"code":"    it('works with food paths', () => {\n      expect(validateItemPath('items.food.Cake_Base')).to.equal(true);\n      expect(validateItemPath('items.food.Cake_Invalid')).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"works with mounts paths","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":43,"column":31,"index":2135},"line":43,"code":"    it('works with mounts paths', () => {\n      expect(validateItemPath('items.mounts.Cactus-Base')).to.equal(true);\n      expect(validateItemPath('items.mounts.Aether-Invisible')).to.equal(true);\n      expect(validateItemPath('items.mounts.Aether-Invalid')).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"works with quests paths","suites":["Items Utils","validateItemPath"],"updatePoint":{"line":48,"column":31,"index":2419},"line":48,"code":"    it('works with quests paths', () => {\n      expect(validateItemPath('items.quests.atom3')).to.equal(true);\n      expect(validateItemPath('items.quests.invalid')).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"returns the item val untouched if not an item path","suites":["Items Utils","castItemVal"],"updatePoint":{"line":54,"column":58,"index":2677},"line":54,"code":"    it('returns the item val untouched if not an item path', () => {\n      expect(castItemVal('notitems.gear.owned.item', 'a string')).to.equal('a string');\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"returns the item val untouched if an unsupported path","suites":["Items Utils","castItemVal"],"updatePoint":{"line":57,"column":61,"index":2845},"line":57,"code":"    it('returns the item val untouched if an unsupported path', () => {\n      expect(castItemVal('items.gear.equipped.weapon', 'a string')).to.equal('a string');\n      expect(castItemVal('items.currentPet', 'a string')).to.equal('a string');\n      expect(castItemVal('items.special.snowball', 'a string')).to.equal('a string');\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"converts values for pets paths to numbers","suites":["Items Utils","castItemVal"],"updatePoint":{"line":62,"column":49,"index":3169},"line":62,"code":"    it('converts values for pets paths to numbers', () => {\n      expect(castItemVal('items.pets.Wolf-CottonCandyPink', '5')).to.equal(5);\n      expect(castItemVal('items.pets.Wolf-Invalid', '5')).to.equal(5);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"converts values for eggs paths to numbers","suites":["Items Utils","castItemVal"],"updatePoint":{"line":66,"column":49,"index":3387},"line":66,"code":"    it('converts values for eggs paths to numbers', () => {\n      expect(castItemVal('items.eggs.LionCub', '5')).to.equal(5);\n      expect(castItemVal('items.eggs.Armadillo', '5')).to.equal(5);\n      expect(castItemVal('items.eggs.NotAnArmadillo', '5')).to.equal(5);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"converts values for hatching potions paths to numbers","suites":["Items Utils","castItemVal"],"updatePoint":{"line":71,"column":61,"index":3674},"line":71,"code":"    it('converts values for hatching potions paths to numbers', () => {\n      expect(castItemVal('items.hatchingPotions.Base', '5')).to.equal(5);\n      expect(castItemVal('items.hatchingPotions.StarryNight', '5')).to.equal(5);\n      expect(castItemVal('items.hatchingPotions.Invalid', '5')).to.equal(5);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"converts values for food paths to numbers","suites":["Items Utils","castItemVal"],"updatePoint":{"line":76,"column":49,"index":3974},"line":76,"code":"    it('converts values for food paths to numbers', () => {\n      expect(castItemVal('items.food.Cake_Base', '5')).to.equal(5);\n      expect(castItemVal('items.food.Cake_Invalid', '5')).to.equal(5);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"converts values for mounts paths to numbers","suites":["Items Utils","castItemVal"],"updatePoint":{"line":80,"column":51,"index":4183},"line":80,"code":"    it('converts values for mounts paths to numbers', () => {\n      expect(castItemVal('items.mounts.Cactus-Base', 'true')).to.equal(true);\n      expect(castItemVal('items.mounts.Aether-Invisible', 'false')).to.equal(false);\n      expect(castItemVal('items.mounts.Aether-Invalid', 'true')).to.equal(true);\n      expect(castItemVal('items.mounts.Aether-Invalid', 'truish')).to.equal(true);\n      expect(castItemVal('items.mounts.Aether-Invalid', 0)).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"converts values for quests paths to numbers","suites":["Items Utils","castItemVal"],"updatePoint":{"line":87,"column":51,"index":4657},"line":87,"code":"    it('converts values for quests paths to numbers', () => {\n      expect(castItemVal('items.quests.atom3', '5')).to.equal(5);\n      expect(castItemVal('items.quests.invalid', '5')).to.equal(5);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"converts values for owned gear","suites":["Items Utils","castItemVal"],"updatePoint":{"line":91,"column":38,"index":4848},"line":91,"code":"    it('converts values for owned gear', () => {\n      expect(castItemVal('items.gear.owned.shield_warrior_0', 'true')).to.equal(true);\n      expect(castItemVal('items.gear.owned.invalid', 'false')).to.equal(false);\n      expect(castItemVal('items.gear.owned.invalid', 'thruthy')).to.equal(true);\n      expect(castItemVal('items.gear.owned.invalid', 0)).to.equal(false);\n    });","file":"api/unit/libs/items/utils.test.js","skipped":false,"dir":"test"},{"name":"uses the user preferred language if avalaible","suites":["language lib","getLanguageFromUser"],"updatePoint":{"line":9,"column":53,"index":360},"line":9,"code":"    it('uses the user preferred language if avalaible', () => {\n      const user = {\n        preferences: {\n          language: 'it'\n        }\n      };\n      expect(getLanguageFromUser(user, req)).to.equal('it');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"falls back to english if the user preferred language is not avalaible","suites":["language lib","getLanguageFromUser"],"updatePoint":{"line":17,"column":77,"index":605},"line":17,"code":"    it('falls back to english if the user preferred language is not avalaible', () => {\n      const user = {\n        preferences: {\n          language: 'bla'\n        }\n      };\n      expect(getLanguageFromUser(user, req)).to.equal('en');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses browser specificed language","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":27,"column":40,"index":865},"line":27,"code":"    it('uses browser specificed language', () => {\n      req.headers['accept-language'] = 'pt';\n      expect(getLanguageFromBrowser(req)).to.equal('pt');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses first language in series if browser specifies multiple","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":31,"column":67,"index":1054},"line":31,"code":"    it('uses first language in series if browser specifies multiple', () => {\n      req.headers['accept-language'] = 'he, pt, it';\n      expect(getLanguageFromBrowser(req)).to.equal('he');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"skips invalid lanaguages and uses first language in series if browser specifies multiple","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":35,"column":96,"index":1280},"line":35,"code":"    it('skips invalid lanaguages and uses first language in series if browser specifies multiple', () => {\n      req.headers['accept-language'] = 'blah, he, pt, it';\n      expect(getLanguageFromBrowser(req)).to.equal('he');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses normal version of language if specialized locale is passed in","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":39,"column":74,"index":1490},"line":39,"code":"    it('uses normal version of language if specialized locale is passed in', () => {\n      req.headers['accept-language'] = 'fr-CA';\n      expect(getLanguageFromBrowser(req)).to.equal('fr');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses normal version of language if specialized locale is passed in","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":43,"column":74,"index":1689},"line":43,"code":"    it('uses normal version of language if specialized locale is passed in', () => {\n      req.headers['accept-language'] = 'fr-CA';\n      expect(getLanguageFromBrowser(req)).to.equal('fr');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses es if es is passed in","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":47,"column":34,"index":1848},"line":47,"code":"    it('uses es if es is passed in', () => {\n      req.headers['accept-language'] = 'es';\n      expect(getLanguageFromBrowser(req)).to.equal('es');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses es_419 if applicable es-languages are passed in","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":51,"column":60,"index":2030},"line":51,"code":"    it('uses es_419 if applicable es-languages are passed in', () => {\n      req.headers['accept-language'] = 'es-mx';\n      expect(getLanguageFromBrowser(req)).to.equal('es_419');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses es_419 if multiple es languages are passed in","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":55,"column":58,"index":2217},"line":55,"code":"    it('uses es_419 if multiple es languages are passed in', () => {\n      req.headers['accept-language'] = 'es-GT, es-MX, es-CR';\n      expect(getLanguageFromBrowser(req)).to.equal('es_419');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"zh","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":59,"column":10,"index":2370},"line":59,"code":"    it('zh', () => {\n      req.headers['accept-language'] = 'zh-TW';\n      expect(getLanguageFromBrowser(req)).to.equal('zh_TW');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses english if browser specified language is not compatible","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":63,"column":68,"index":2566},"line":63,"code":"    it('uses english if browser specified language is not compatible', () => {\n      req.headers['accept-language'] = 'blah';\n      expect(getLanguageFromBrowser(req)).to.equal('en');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses english if browser does not specify","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":67,"column":48,"index":2738},"line":67,"code":"    it('uses english if browser does not specify', () => {\n      req.headers['accept-language'] = '';\n      expect(getLanguageFromBrowser(req)).to.equal('en');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"uses english if browser does not supply an accept-language header","suites":["language lib","getLanguageFromBrowser"],"updatePoint":{"line":71,"column":73,"index":2931},"line":71,"code":"    it('uses english if browser does not supply an accept-language header', () => {\n      delete req.headers['accept-language'];\n      expect(getLanguageFromBrowser(req)).to.equal('en');\n    });","file":"api/unit/libs/language.test.js","skipped":false,"dir":"test"},{"name":"can compare a correct password hashed with SHA1","suites":["Password Utilities","compare"],"updatePoint":{"line":8,"column":55,"index":523},"line":8,"code":"    it('can compare a correct password hashed with SHA1', async () => {\n      const textPassword = 'mySecretPassword';\n      const salt = sha1MakeSalt();\n      const hashedPassword = sha1EncryptPassword(textPassword, salt);\n      const user = {\n        auth: {\n          local: {\n            hashed_password: hashedPassword,\n            salt,\n            passwordHashMethod: 'sha1'\n          }\n        }\n      };\n      const isValidPassword = await compare(user, textPassword);\n      expect(isValidPassword).to.eql(true);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"can compare an invalid password hashed with SHA1","suites":["Password Utilities","compare"],"updatePoint":{"line":24,"column":56,"index":1054},"line":24,"code":"    it('can compare an invalid password hashed with SHA1', async () => {\n      const textPassword = 'mySecretPassword';\n      const salt = sha1MakeSalt();\n      const hashedPassword = sha1EncryptPassword(textPassword, salt);\n      const user = {\n        auth: {\n          local: {\n            hashed_password: hashedPassword,\n            salt,\n            passwordHashMethod: 'sha1'\n          }\n        }\n      };\n      const isValidPassword = await compare(user, 'wrongPassword');\n      expect(isValidPassword).to.eql(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"can compare a correct password hashed with bcrypt","suites":["Password Utilities","compare"],"updatePoint":{"line":40,"column":57,"index":1590},"line":40,"code":"    it('can compare a correct password hashed with bcrypt', async () => {\n      const textPassword = 'mySecretPassword';\n      const hashedPassword = await bcryptHash(textPassword);\n      const user = {\n        auth: {\n          local: {\n            hashed_password: hashedPassword,\n            passwordHashMethod: 'bcrypt'\n          }\n        }\n      };\n      const isValidPassword = await compare(user, textPassword);\n      expect(isValidPassword).to.eql(true);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"can compare an invalid password hashed with bcrypt","suites":["Password Utilities","compare"],"updatePoint":{"line":54,"column":58,"index":2063},"line":54,"code":"    it('can compare an invalid password hashed with bcrypt', async () => {\n      const textPassword = 'mySecretPassword';\n      const hashedPassword = await bcryptHash(textPassword);\n      const user = {\n        auth: {\n          local: {\n            hashed_password: hashedPassword,\n            passwordHashMethod: 'bcrypt'\n          }\n        }\n      };\n      const isValidPassword = await compare(user, 'wrongPassword');\n      expect(isValidPassword).to.eql(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"throws an error if user is missing","suites":["Password Utilities","compare"],"updatePoint":{"line":68,"column":42,"index":2524},"line":68,"code":"    it('throws an error if user is missing', async () => {\n      try {\n        await compare(null, 'some password');\n      } catch (e) {\n        expect(e.toString()).to.equal('Error: user and passwordToCheck are required parameters.');\n      }\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"throws an error if passwordToCheck is missing","suites":["Password Utilities","compare"],"updatePoint":{"line":75,"column":53,"index":2787},"line":75,"code":"    it('throws an error if passwordToCheck is missing', async () => {\n      try {\n        await compare({\n          a: true\n        });\n      } catch (e) {\n        expect(e.toString()).to.equal('Error: user and passwordToCheck are required parameters.');\n      }\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"defaults to SHA1 encryption if salt is provided","suites":["Password Utilities","compare"],"updatePoint":{"line":84,"column":55,"index":3060},"line":84,"code":"    it('defaults to SHA1 encryption if salt is provided', async () => {\n      const textPassword = 'mySecretPassword';\n      const salt = sha1MakeSalt();\n      const hashedPassword = sha1EncryptPassword(textPassword, salt);\n      const user = {\n        auth: {\n          local: {\n            hashed_password: hashedPassword,\n            salt,\n            passwordHashMethod: ''\n          }\n        }\n      };\n      const isValidPassword = await compare(user, textPassword);\n      expect(isValidPassword).to.eql(true);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"throws an error if an invalid hashing method is used","suites":["Password Utilities","compare"],"updatePoint":{"line":100,"column":60,"index":3591},"line":100,"code":"    it('throws an error if an invalid hashing method is used', async () => {\n      try {\n        await compare({\n          auth: {\n            local: {\n              passwordHashMethod: 'invalid'\n            }\n          }\n        }, 'pass');\n      } catch (e) {\n        expect(e.toString()).to.equal('Error: Invalid password hash method.');\n      }\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns true if comparing the same password","suites":["Password Utilities","compare"],"updatePoint":{"line":113,"column":51,"index":3939},"line":113,"code":"    it('returns true if comparing the same password', async () => {\n      const textPassword = 'mySecretPassword';\n      const hashedPassword = await bcryptHash(textPassword);\n      const isValidPassword = await bcryptCompare(textPassword, hashedPassword);\n      expect(isValidPassword).to.eql(true);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns true if comparing a different password","suites":["Password Utilities","compare"],"updatePoint":{"line":119,"column":54,"index":4251},"line":119,"code":"    it('returns true if comparing a different password', async () => {\n      const textPassword = 'mySecretPassword';\n      const hashedPassword = await bcryptHash(textPassword);\n      const isValidPassword = await bcryptCompare('anotherPassword', hashedPassword);\n      expect(isValidPassword).to.eql(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"converts an user password hashed with sha1 to bcrypt","suites":["Password Utilities","convertToBcrypt"],"updatePoint":{"line":127,"column":60,"index":4619},"line":127,"code":"    it('converts an user password hashed with sha1 to bcrypt', async () => {\n      const textPassword = 'mySecretPassword';\n      const salt = sha1MakeSalt();\n      const hashedPassword = sha1EncryptPassword(textPassword, salt);\n      const user = {\n        auth: {\n          local: {\n            hashed_password: hashedPassword,\n            salt,\n            passwordHashMethod: 'sha1'\n          }\n        }\n      };\n      await convertToBcrypt(user, textPassword);\n      expect(user.auth.local.salt).to.be.undefined;\n      expect(user.auth.local.passwordHashMethod).to.equal('bcrypt');\n      expect(user.auth.local.hashed_password).to.be.a.string;\n      const isValidPassword = await compare(user, textPassword);\n      expect(isValidPassword).to.eql(true);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"throws an error if user is missing","suites":["Password Utilities","convertToBcrypt"],"updatePoint":{"line":147,"column":42,"index":5368},"line":147,"code":"    it('throws an error if user is missing', async () => {\n      try {\n        await convertToBcrypt(null, 'string');\n      } catch (e) {\n        expect(e.toString()).to.equal('Error: user and plainTextPassword are required parameters.');\n      }\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"throws an error if plainTextPassword is missing","suites":["Password Utilities","convertToBcrypt"],"updatePoint":{"line":154,"column":55,"index":5636},"line":154,"code":"    it('throws an error if plainTextPassword is missing', async () => {\n      try {\n        await convertToBcrypt({\n          a: true\n        });\n      } catch (e) {\n        expect(e.toString()).to.equal('Error: user and plainTextPassword are required parameters.');\n      }\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns false if the code is missing","suites":["Password Utilities","validatePasswordResetCodeAndFindUser"],"updatePoint":{"line":165,"column":44,"index":5973},"line":165,"code":"    it('returns false if the code is missing', async () => {\n      const res = await validatePasswordResetCodeAndFindUser();\n      expect(res).to.equal(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns false if the code is invalid json","suites":["Password Utilities","validatePasswordResetCodeAndFindUser"],"updatePoint":{"line":169,"column":49,"index":6146},"line":169,"code":"    it('returns false if the code is invalid json', async () => {\n      const res = await validatePasswordResetCodeAndFindUser('invalid json');\n      expect(res).to.equal(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns false if the code cannot be decrypted","suites":["Password Utilities","validatePasswordResetCodeAndFindUser"],"updatePoint":{"line":173,"column":53,"index":6337},"line":173,"code":"    it('returns false if the code cannot be decrypted', async () => {\n      const user = await generateUser();\n      const res = await validatePasswordResetCodeAndFindUser(JSON.stringify({\n        // not encrypted\n        userId: user._id,\n        expiresAt: new Date()\n      }));\n      expect(res).to.equal(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns false if the code is expired","suites":["Password Utilities","validatePasswordResetCodeAndFindUser"],"updatePoint":{"line":182,"column":44,"index":6652},"line":182,"code":"    it('returns false if the code is expired', async () => {\n      const user = await generateUser();\n      const code = encrypt(JSON.stringify({\n        userId: user._id,\n        expiresAt: moment().subtract({\n          minutes: 1\n        })\n      }));\n      await user.update({\n        'auth.local.passwordResetCode': code\n      });\n      const res = await validatePasswordResetCodeAndFindUser(code);\n      expect(res).to.equal(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns false if the user does not exist","suites":["Password Utilities","validatePasswordResetCodeAndFindUser"],"updatePoint":{"line":196,"column":48,"index":7102},"line":196,"code":"    it('returns false if the user does not exist', async () => {\n      const res = await validatePasswordResetCodeAndFindUser(encrypt(JSON.stringify({\n        userId: Date.now().toString(),\n        expiresAt: moment().add({\n          days: 1\n        })\n      })));\n      expect(res).to.equal(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns false if the user has no local auth","suites":["Password Utilities","validatePasswordResetCodeAndFindUser"],"updatePoint":{"line":205,"column":51,"index":7413},"line":205,"code":"    it('returns false if the user has no local auth', async () => {\n      const user = await generateUser({\n        auth: {\n          facebook: {}\n        }\n      });\n      const res = await validatePasswordResetCodeAndFindUser(encrypt(JSON.stringify({\n        userId: user._id,\n        expiresAt: moment().add({\n          days: 1\n        })\n      })));\n      expect(res).to.equal(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns false if the code doesn't match the one saved at user.auth.passwordResetCode","suites":["Password Utilities","validatePasswordResetCodeAndFindUser"],"updatePoint":{"line":219,"column":93,"index":7852},"line":219,"code":"    it('returns false if the code doesn\\'t match the one saved at user.auth.passwordResetCode', async () => {\n      const user = await generateUser();\n      const code = encrypt(JSON.stringify({\n        userId: user._id,\n        expiresAt: moment().add({\n          days: 1\n        })\n      }));\n      await user.update({\n        'auth.local.passwordResetCode': 'invalid'\n      });\n      const res = await validatePasswordResetCodeAndFindUser(code);\n      expect(res).to.equal(false);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns the user if the password reset code is valid","suites":["Password Utilities","validatePasswordResetCodeAndFindUser"],"updatePoint":{"line":233,"column":60,"index":8311},"line":233,"code":"    it('returns the user if the password reset code is valid', async () => {\n      const user = await generateUser();\n      const code = encrypt(JSON.stringify({\n        userId: user._id,\n        expiresAt: moment().add({\n          days: 1\n        })\n      }));\n      await user.update({\n        'auth.local.passwordResetCode': code\n      });\n      const res = await validatePasswordResetCodeAndFindUser(code);\n      expect(res).not.to.equal(false);\n      expect(res._id).to.equal(user._id);\n    });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns a hashed string","suites":["Password Utilities","bcrypt","Hash"],"updatePoint":{"line":251,"column":33,"index":8848},"line":251,"code":"      it('returns a hashed string', async () => {\n        const textPassword = 'mySecretPassword';\n        const hashedPassword = await bcryptHash(textPassword);\n        expect(hashedPassword).to.be.a.string;\n      });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns true if comparing the same password","suites":["Password Utilities","bcrypt","Compare"],"updatePoint":{"line":258,"column":53,"index":9127},"line":258,"code":"      it('returns true if comparing the same password', async () => {\n        const textPassword = 'mySecretPassword';\n        const hashedPassword = await bcryptHash(textPassword);\n        const isValidPassword = await bcryptCompare(textPassword, hashedPassword);\n        expect(isValidPassword).to.eql(true);\n      });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"returns true if comparing a different password","suites":["Password Utilities","bcrypt","Compare"],"updatePoint":{"line":264,"column":56,"index":9451},"line":264,"code":"      it('returns true if comparing a different password', async () => {\n        const textPassword = 'mySecretPassword';\n        const hashedPassword = await bcryptHash(textPassword);\n        const isValidPassword = await bcryptCompare('anotherPassword', hashedPassword);\n        expect(isValidPassword).to.eql(false);\n      });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"always encrypt the same password to the same value when using the same salt","suites":["Password Utilities","SHA1","Encrypt"],"updatePoint":{"line":274,"column":85,"index":9883},"line":274,"code":"      it('always encrypt the same password to the same value when using the same salt', () => {\n        const textPassword = 'mySecretPassword';\n        const salt = sha1MakeSalt();\n        const encryptedPassword = sha1EncryptPassword(textPassword, salt);\n        expect(sha1EncryptPassword(textPassword, salt)).to.eql(encryptedPassword);\n      });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"never encrypt the same password to the same value when using a different salt","suites":["Password Utilities","SHA1","Encrypt"],"updatePoint":{"line":280,"column":87,"index":10235},"line":280,"code":"      it('never encrypt the same password to the same value when using a different salt', () => {\n        const textPassword = 'mySecretPassword';\n        const aSalt = sha1MakeSalt();\n        const anotherSalt = sha1MakeSalt();\n        const anEncryptedPassword = sha1EncryptPassword(textPassword, aSalt);\n        const anotherEncryptedPassword = sha1EncryptPassword(textPassword, anotherSalt);\n        expect(anEncryptedPassword).not.to.eql(anotherEncryptedPassword);\n      });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"creates a salt with length 10 by default","suites":["Password Utilities","SHA1","Make Salt"],"updatePoint":{"line":290,"column":50,"index":10720},"line":290,"code":"      it('creates a salt with length 10 by default', () => {\n        const salt = sha1MakeSalt();\n        expect(salt.length).to.eql(10);\n      });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"can create a salt of any length","suites":["Password Utilities","SHA1","Make Salt"],"updatePoint":{"line":294,"column":41,"index":10859},"line":294,"code":"      it('can create a salt of any length', () => {\n        const length = 24;\n        const salt = sha1MakeSalt(length);\n        expect(salt.length).to.eql(length);\n      });","file":"api/unit/libs/password.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if we are missing a subscription","suites":["Amazon Payments - Cancel Subscription"],"updatePoint":{"line":96,"column":60,"index":3264},"line":96,"code":"  it('should throw an error if we are missing a subscription', async () => {\n    user.purchased.plan.customerId = undefined;\n    await expect(amzLib.cancelSubscription({\n      user\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      name: 'NotAuthorized',\n      message: i18n.t('missingSubscription')\n    });\n  });","file":"api/unit/libs/payments/amazon/cancel.test.js","skipped":false,"dir":"test"},{"name":"should cancel a user subscription","suites":["Amazon Payments - Cancel Subscription"],"updatePoint":{"line":106,"column":39,"index":3580},"line":106,"code":"  it('should cancel a user subscription', async () => {\n    billingAgreementId = user.purchased.plan.customerId;\n    await amzLib.cancelSubscription({\n      user,\n      headers\n    });\n    expectAmazonCancelUserSubscriptionSpy();\n    expectAmazonStubs();\n  });","file":"api/unit/libs/payments/amazon/cancel.test.js","skipped":false,"dir":"test"},{"name":"should close a user subscription if amazon not closed","suites":["Amazon Payments - Cancel Subscription"],"updatePoint":{"line":115,"column":59,"index":3861},"line":115,"code":"  it('should close a user subscription if amazon not closed', async () => {\n    amzLib.getBillingAgreementDetails.restore();\n    expectBillingAggreementDetailSpy();\n    const closeBillingAgreementSpy = sinon.stub(amzLib, 'closeBillingAgreement').resolves({});\n    billingAgreementId = user.purchased.plan.customerId;\n    await amzLib.cancelSubscription({\n      user,\n      headers\n    });\n    expectAmazonStubs();\n    expect(closeBillingAgreementSpy).to.be.calledOnce;\n    expect(closeBillingAgreementSpy).to.be.calledWith({\n      AmazonBillingAgreementId: billingAgreementId\n    });\n    expectAmazonCancelUserSubscriptionSpy();\n    amzLib.closeBillingAgreement.restore();\n  });","file":"api/unit/libs/payments/amazon/cancel.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if group is not found","suites":["Amazon Payments - Cancel Subscription"],"updatePoint":{"line":132,"column":49,"index":4530},"line":132,"code":"  it('should throw an error if group is not found', async () => {\n    await expect(amzLib.cancelSubscription({\n      user,\n      groupId: 'fake-id'\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 404,\n      name: 'NotFound',\n      message: i18n.t('groupNotFound')\n    });\n  });","file":"api/unit/libs/payments/amazon/cancel.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if user is not group leader","suites":["Amazon Payments - Cancel Subscription"],"updatePoint":{"line":142,"column":55,"index":4829},"line":142,"code":"  it('should throw an error if user is not group leader', async () => {\n    const nonLeader = await createNonLeaderGroupMember(group);\n    await expect(amzLib.cancelSubscription({\n      user: nonLeader,\n      groupId: group._id\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      name: 'NotAuthorized',\n      message: i18n.t('onlyGroupLeaderCanManageSubscription')\n    });\n  });","file":"api/unit/libs/payments/amazon/cancel.test.js","skipped":false,"dir":"test"},{"name":"should cancel a group subscription","suites":["Amazon Payments - Cancel Subscription"],"updatePoint":{"line":153,"column":40,"index":5215},"line":153,"code":"  it('should cancel a group subscription', async () => {\n    billingAgreementId = group.purchased.plan.customerId;\n    await amzLib.cancelSubscription({\n      user,\n      groupId: group._id,\n      headers\n    });\n    expectAmazonCancelGroupSubscriptionSpy(group._id);\n    expectAmazonStubs();\n  });","file":"api/unit/libs/payments/amazon/cancel.test.js","skipped":false,"dir":"test"},{"name":"should close a group subscription if amazon not closed","suites":["Amazon Payments - Cancel Subscription"],"updatePoint":{"line":163,"column":60,"index":5534},"line":163,"code":"  it('should close a group subscription if amazon not closed', async () => {\n    amzLib.getBillingAgreementDetails.restore();\n    expectBillingAggreementDetailSpy();\n    const closeBillingAgreementSpy = sinon.stub(amzLib, 'closeBillingAgreement').resolves({});\n    billingAgreementId = group.purchased.plan.customerId;\n    await amzLib.cancelSubscription({\n      user,\n      groupId: group._id,\n      headers\n    });\n    expectAmazonStubs();\n    expect(closeBillingAgreementSpy).to.be.calledOnce;\n    expect(closeBillingAgreementSpy).to.be.calledWith({\n      AmazonBillingAgreementId: billingAgreementId\n    });\n    expectAmazonCancelGroupSubscriptionSpy(group._id);\n    amzLib.closeBillingAgreement.restore();\n  });","file":"api/unit/libs/payments/amazon/cancel.test.js","skipped":false,"dir":"test"},{"name":"should purchase gems","suites":["Amazon Payments - Checkout"],"updatePoint":{"line":121,"column":26,"index":4137},"line":121,"code":"  it('should purchase gems', async () => {\n    sinon.stub(user, 'canGetGems').resolves(true);\n    await amzLib.checkout({\n      user,\n      orderReferenceId,\n      headers,\n      gemsBlock: gemsBlockKey\n    });\n    expectBuyGemsStub(amzLib.constants.PAYMENT_METHOD);\n    expectAmazonStubs();\n    expect(user.canGetGems).to.be.calledOnce;\n    user.canGetGems.restore();\n  });","file":"api/unit/libs/payments/amazon/checkout.test.js","skipped":false,"dir":"test"},{"name":"should error if gem amount is too low","suites":["Amazon Payments - Checkout"],"updatePoint":{"line":134,"column":43,"index":4529},"line":134,"code":"  it('should error if gem amount is too low', async () => {\n    const receivingUser = new User();\n    receivingUser.save();\n    const gift = {\n      type: 'gems',\n      gems: {\n        amount: 0,\n        uuid: receivingUser._id\n      }\n    };\n    await expect(amzLib.checkout({\n      gift,\n      user,\n      orderReferenceId,\n      headers\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 400,\n      message: 'Amount must be at least 1.',\n      name: 'BadRequest'\n    });\n  });","file":"api/unit/libs/payments/amazon/checkout.test.js","skipped":false,"dir":"test"},{"name":"should error if user cannot get gems gems","suites":["Amazon Payments - Checkout"],"updatePoint":{"line":155,"column":47,"index":5025},"line":155,"code":"  it('should error if user cannot get gems gems', async () => {\n    sinon.stub(user, 'canGetGems').resolves(false);\n    await expect(amzLib.checkout({\n      user,\n      orderReferenceId,\n      headers,\n      gemsBlock: gemsBlockKey\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      message: i18n.t('groupPolicyCannotGetGems'),\n      name: 'NotAuthorized'\n    });\n    user.canGetGems.restore();\n  });","file":"api/unit/libs/payments/amazon/checkout.test.js","skipped":false,"dir":"test"},{"name":"should error if gems block is not valid","suites":["Amazon Payments - Checkout"],"updatePoint":{"line":169,"column":45,"index":5447},"line":169,"code":"  it('should error if gems block is not valid', async () => {\n    await expect(amzLib.checkout({\n      user,\n      orderReferenceId,\n      headers,\n      gemsBlock: 'invalid'\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 400,\n      message: apiError('invalidGemsBlock'),\n      name: 'BadRequest'\n    });\n  });","file":"api/unit/libs/payments/amazon/checkout.test.js","skipped":false,"dir":"test"},{"name":"should gift gems","suites":["Amazon Payments - Checkout"],"updatePoint":{"line":181,"column":22,"index":5751},"line":181,"code":"  it('should gift gems', async () => {\n    const receivingUser = new User();\n    await receivingUser.save();\n    const gift = {\n      type: 'gems',\n      uuid: receivingUser._id,\n      gems: {\n        amount: 16\n      }\n    };\n    amount = 16 / 4;\n    await amzLib.checkout({\n      gift,\n      user,\n      orderReferenceId,\n      headers\n    });\n    expectBuyGemsStub(amzLib.constants.PAYMENT_METHOD_GIFT, gift);\n    expectAmazonStubs();\n  });","file":"api/unit/libs/payments/amazon/checkout.test.js","skipped":false,"dir":"test"},{"name":"should gift a subscription","suites":["Amazon Payments - Checkout"],"updatePoint":{"line":201,"column":32,"index":6205},"line":201,"code":"  it('should gift a subscription', async () => {\n    const receivingUser = new User();\n    receivingUser.save();\n    const gift = {\n      type: 'subscription',\n      subscription: {\n        key: subKey,\n        uuid: receivingUser._id\n      }\n    };\n    amount = common.content.subscriptionBlocks[subKey].price;\n    await amzLib.checkout({\n      user,\n      orderReferenceId,\n      headers,\n      gift\n    });\n    gift.member = receivingUser;\n    expect(paymentCreateSubscritionStub).to.be.calledOnce;\n    expect(paymentCreateSubscritionStub).to.be.calledWith({\n      user,\n      paymentMethod: amzLib.constants.PAYMENT_METHOD_GIFT,\n      headers,\n      gift,\n      gemsBlock: undefined\n    });\n    expectAmazonStubs();\n  });","file":"api/unit/libs/payments/amazon/checkout.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if we are missing a subscription","suites":["Amazon Payments - Subscribe"],"updatePoint":{"line":113,"column":60,"index":4065},"line":113,"code":"  it('should throw an error if we are missing a subscription', async () => {\n    await expect(amzLib.subscribe({\n      billingAgreementId,\n      coupon,\n      user,\n      groupId,\n      headers\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 400,\n      name: 'BadRequest',\n      message: i18n.t('missingSubscriptionCode')\n    });\n  });","file":"api/unit/libs/payments/amazon/subscribe.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if we are missing a billingAgreementId","suites":["Amazon Payments - Subscribe"],"updatePoint":{"line":126,"column":66,"index":4422},"line":126,"code":"  it('should throw an error if we are missing a billingAgreementId', async () => {\n    await expect(amzLib.subscribe({\n      sub,\n      coupon,\n      user,\n      groupId,\n      headers\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 400,\n      name: 'BadRequest',\n      message: 'Missing req.body.billingAgreementId'\n    });\n  });","file":"api/unit/libs/payments/amazon/subscribe.test.js","skipped":false,"dir":"test"},{"name":"should throw an error when coupon code is missing","suites":["Amazon Payments - Subscribe"],"updatePoint":{"line":139,"column":55,"index":4757},"line":139,"code":"  it('should throw an error when coupon code is missing', async () => {\n    sub.discount = 40;\n    await expect(amzLib.subscribe({\n      billingAgreementId,\n      sub,\n      coupon,\n      user,\n      groupId,\n      headers\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 400,\n      name: 'BadRequest',\n      message: i18n.t('couponCodeRequired')\n    });\n  });","file":"api/unit/libs/payments/amazon/subscribe.test.js","skipped":false,"dir":"test"},{"name":"should throw an error when coupon code is invalid","suites":["Amazon Payments - Subscribe"],"updatePoint":{"line":154,"column":55,"index":5132},"line":154,"code":"  it('should throw an error when coupon code is invalid', async () => {\n    sub.discount = 40;\n    sub.key = 'google_6mo';\n    coupon = 'example-coupon';\n    const couponModel = new Coupon();\n    couponModel.event = 'google_6mo';\n    await couponModel.save();\n    sinon.stub(cc, 'validate').returns('invalid');\n    await expect(amzLib.subscribe({\n      billingAgreementId,\n      sub,\n      coupon,\n      user,\n      groupId,\n      headers\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      name: 'NotAuthorized',\n      message: i18n.t('invalidCoupon')\n    });\n    cc.validate.restore();\n  });","file":"api/unit/libs/payments/amazon/subscribe.test.js","skipped":false,"dir":"test"},{"name":"subscribes with amazon with a coupon","suites":["Amazon Payments - Subscribe"],"updatePoint":{"line":176,"column":42,"index":5735},"line":176,"code":"  it('subscribes with amazon with a coupon', async () => {\n    sub.discount = 40;\n    sub.key = 'google_6mo';\n    coupon = 'example-coupon';\n    const couponModel = new Coupon();\n    couponModel.event = 'google_6mo';\n    const updatedCouponModel = await couponModel.save();\n    sinon.stub(cc, 'validate').returns(updatedCouponModel._id);\n    await amzLib.subscribe({\n      billingAgreementId,\n      sub,\n      coupon,\n      user,\n      groupId,\n      headers\n    });\n    expectCreateSpy();\n    cc.validate.restore();\n  });","file":"api/unit/libs/payments/amazon/subscribe.test.js","skipped":false,"dir":"test"},{"name":"subscribes with amazon","suites":["Amazon Payments - Subscribe"],"updatePoint":{"line":195,"column":28,"index":6244},"line":195,"code":"  it('subscribes with amazon', async () => {\n    user.guilds.push(groupId);\n    await user.save();\n    await amzLib.subscribe({\n      billingAgreementId,\n      sub,\n      coupon,\n      user,\n      groupId,\n      headers\n    });\n    expectAmazonSetBillingAgreementDetailsSpy();\n    expect(amazonConfirmBillingAgreementSpy).to.be.calledOnce;\n    expect(amazonConfirmBillingAgreementSpy).to.be.calledWith({\n      AmazonBillingAgreementId: billingAgreementId\n    });\n    expectAmazonAuthorizeBillingAgreementSpy();\n    expectCreateSpy();\n  });","file":"api/unit/libs/payments/amazon/subscribe.test.js","skipped":false,"dir":"test"},{"name":"subscribes with amazon with price to existing users","suites":["Amazon Payments - Subscribe"],"updatePoint":{"line":214,"column":57,"index":6813},"line":214,"code":"  it('subscribes with amazon with price to existing users', async () => {\n    user = new User();\n    user.guilds.push(groupId);\n    await user.save(); // Add existing users\n\n    user = new User();\n    user.guilds.push(groupId);\n    await user.save(); // Set expected amount\n\n    sub.key = 'group_monthly';\n    sub.price = 9;\n    amount = 12;\n    await amzLib.subscribe({\n      billingAgreementId,\n      sub,\n      coupon,\n      user,\n      groupId,\n      headers\n    });\n    expectAmazonSetBillingAgreementDetailsSpy();\n    expect(amazonConfirmBillingAgreementSpy).to.be.calledOnce;\n    expect(amazonConfirmBillingAgreementSpy).to.be.calledWith({\n      AmazonBillingAgreementId: billingAgreementId\n    });\n    expectAmazonAuthorizeBillingAgreementSpy();\n    expectCreateSpy();\n  });","file":"api/unit/libs/payments/amazon/subscribe.test.js","skipped":false,"dir":"test"},{"name":"charges for a new member","suites":["#upgradeGroupPlan"],"updatePoint":{"line":49,"column":30,"index":1477},"line":49,"code":"  it('charges for a new member', async () => {\n    data.paymentMethod = amzLib.constants.PAYMENT_METHOD;\n    await payments.createSubscription(data);\n    const updatedGroup = await Group.findById(group._id).exec();\n    updatedGroup.memberCount += 1;\n    await updatedGroup.save();\n    await amzLib.chargeForAdditionalGroupMember(updatedGroup);\n    expect(spy.calledOnce).to.be.true;\n    expect(spy).to.be.calledWith({\n      AmazonBillingAgreementId: updatedGroup.purchased.plan.customerId,\n      AuthorizationReferenceId: uuidString.substring(0, 32),\n      AuthorizationAmount: {\n        CurrencyCode: amzLib.constants.CURRENCY_CODE,\n        Amount: 3\n      },\n      SellerAuthorizationNote: amzLib.constants.SELLER_NOTE_GROUP_NEW_MEMBER,\n      TransactionTimeout: 0,\n      CaptureNow: true,\n      SellerNote: amzLib.constants.SELLER_NOTE_GROUP_NEW_MEMBER,\n      SellerOrderAttributes: {\n        SellerOrderId: uuidString,\n        StoreName: amzLib.constants.STORE_NAME\n      }\n    });\n  });","file":"api/unit/libs/payments/amazon/upgrade-groupplan.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if receipt is invalid","suites":["Apple Payments","verifyGemPurchase"],"updatePoint":{"line":50,"column":51,"index":1881},"line":50,"code":"    it('should throw an error if receipt is invalid', async () => {\n      iap.isValidated.restore();\n      iapIsValidatedStub = sinon.stub(iap, 'isValidated').returns(false);\n      await expect(applePayments.verifyGemPurchase({\n        user,\n        receipt,\n        headers\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: applePayments.constants.RESPONSE_INVALID_RECEIPT\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if getPurchaseData is invalid","suites":["Apple Payments","verifyGemPurchase"],"updatePoint":{"line":63,"column":59,"index":2351},"line":63,"code":"    it('should throw an error if getPurchaseData is invalid', async () => {\n      iapGetPurchaseDataStub.restore();\n      iapGetPurchaseDataStub = sinon.stub(iap, 'getPurchaseData').returns([]);\n      await expect(applePayments.verifyGemPurchase({\n        user,\n        receipt,\n        headers\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: applePayments.constants.RESPONSE_NO_ITEM_PURCHASED\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"errors if the user cannot purchase gems","suites":["Apple Payments","verifyGemPurchase"],"updatePoint":{"line":76,"column":47,"index":2823},"line":76,"code":"    it('errors if the user cannot purchase gems', async () => {\n      sinon.stub(user, 'canGetGems').resolves(false);\n      await expect(applePayments.verifyGemPurchase({\n        user,\n        receipt,\n        headers\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: i18n.t('groupPolicyCannotGetGems')\n      });\n      user.canGetGems.restore();\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"errors if gemsBlock does not exist","suites":["Apple Payments","verifyGemPurchase"],"updatePoint":{"line":89,"column":42,"index":3242},"line":89,"code":"    it('errors if gemsBlock does not exist', async () => {\n      sinon.stub(user, 'canGetGems').resolves(true);\n      iapGetPurchaseDataStub.restore();\n      iapGetPurchaseDataStub = sinon.stub(iap, 'getPurchaseData').returns([{\n        productId: 'badProduct',\n        transactionId: token\n      }]);\n      await expect(applePayments.verifyGemPurchase({\n        user,\n        receipt,\n        headers\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: applePayments.constants.RESPONSE_INVALID_ITEM\n      });\n      user.canGetGems.restore();\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"purchases  gems","suites":["Apple Payments","verifyGemPurchase"],"updatePoint":{"line":124,"column":45,"index":4373},"line":124,"code":"      it(`purchases ${gemTest.productId} gems`, async () => {\n        iapGetPurchaseDataStub.restore();\n        iapGetPurchaseDataStub = sinon.stub(iap, 'getPurchaseData').returns([{\n          productId: gemTest.productId,\n          transactionId: token\n        }]);\n        sinon.stub(user, 'canGetGems').resolves(true);\n        await applePayments.verifyGemPurchase({\n          user,\n          receipt,\n          headers\n        });\n        expect(iapSetupStub).to.be.calledOnce;\n        expect(iapValidateStub).to.be.calledOnce;\n        expect(iapValidateStub).to.be.calledWith(iap.APPLE, receipt);\n        expect(iapIsValidatedStub).to.be.calledOnce;\n        expect(iapIsValidatedStub).to.be.calledWith({});\n        expect(iapGetPurchaseDataStub).to.be.calledOnce;\n        expect(validateGiftMessageStub).to.not.be.called;\n        expect(paymentBuyGemsStub).to.be.calledOnce;\n        expect(paymentBuyGemsStub).to.be.calledWith({\n          user,\n          paymentMethod: applePayments.constants.PAYMENT_METHOD_APPLE,\n          gemsBlock: common.content.gems[gemTest.gemsBlock],\n          headers,\n          gift: undefined\n        });\n        expect(user.canGetGems).to.be.calledOnce;\n        user.canGetGems.restore();\n      });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"gifts gems","suites":["Apple Payments","verifyGemPurchase"],"updatePoint":{"line":155,"column":18,"index":5588},"line":155,"code":"    it('gifts gems', async () => {\n      const receivingUser = new User();\n      await receivingUser.save();\n      iapGetPurchaseDataStub.restore();\n      iapGetPurchaseDataStub = sinon.stub(iap, 'getPurchaseData').returns([{\n        productId: gemsCanPurchase[0].productId,\n        transactionId: token\n      }]);\n      const gift = {\n        uuid: receivingUser._id\n      };\n      await applePayments.verifyGemPurchase({\n        user,\n        gift,\n        receipt,\n        headers\n      });\n      expect(iapSetupStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledWith(iap.APPLE, receipt);\n      expect(iapIsValidatedStub).to.be.calledOnce;\n      expect(iapIsValidatedStub).to.be.calledWith({});\n      expect(iapGetPurchaseDataStub).to.be.calledOnce;\n      expect(validateGiftMessageStub).to.be.calledOnce;\n      expect(validateGiftMessageStub).to.be.calledWith(gift, user);\n      expect(paymentBuyGemsStub).to.be.calledOnce;\n      expect(paymentBuyGemsStub).to.be.calledWith({\n        user,\n        paymentMethod: applePayments.constants.PAYMENT_METHOD_APPLE,\n        headers,\n        gift: {\n          type: 'gems',\n          gems: {\n            amount: 4\n          },\n          member: sinon.match({\n            _id: receivingUser._id\n          }),\n          uuid: receivingUser._id\n        },\n        gemsBlock: common.content.gems['4gems']\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if sku is empty","suites":["Apple Payments","subscribe"],"updatePoint":{"line":252,"column":45,"index":8717},"line":252,"code":"    it('should throw an error if sku is empty', async () => {\n      await expect(applePayments.subscribe('', user, receipt, headers, nextPaymentProcessing)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('missingSubscriptionCode')\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if receipt is invalid","suites":["Apple Payments","subscribe"],"updatePoint":{"line":259,"column":51,"index":9039},"line":259,"code":"    it('should throw an error if receipt is invalid', async () => {\n      iap.isValidated.restore();\n      iapIsValidatedStub = sinon.stub(iap, 'isValidated').returns(false);\n      await expect(applePayments.subscribe(sku, user, receipt, headers, nextPaymentProcessing)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: applePayments.constants.RESPONSE_INVALID_RECEIPT\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"creates a user subscription for ","suites":["Apple Payments","subscribe"],"updatePoint":{"line":282,"column":55,"index":9909},"line":282,"code":"      it(`creates a user subscription for ${option.sku}`, async () => {\n        iap.getPurchaseData.restore();\n        iapGetPurchaseDataStub = sinon.stub(iap, 'getPurchaseData').returns([{\n          expirationDate: moment.utc().add({\n            day: 1\n          }).toDate(),\n          productId: option.sku,\n          transactionId: token\n        }]);\n        sub = common.content.subscriptionBlocks[option.subKey];\n        await applePayments.subscribe(option.sku, user, receipt, headers, nextPaymentProcessing);\n        expect(iapSetupStub).to.be.calledOnce;\n        expect(iapValidateStub).to.be.calledOnce;\n        expect(iapValidateStub).to.be.calledWith(iap.APPLE, receipt);\n        expect(iapIsValidatedStub).to.be.calledOnce;\n        expect(iapIsValidatedStub).to.be.calledWith({});\n        expect(iapGetPurchaseDataStub).to.be.calledOnce;\n        expect(paymentsCreateSubscritionStub).to.be.calledOnce;\n        expect(paymentsCreateSubscritionStub).to.be.calledWith({\n          user,\n          customerId: token,\n          paymentMethod: applePayments.constants.PAYMENT_METHOD_APPLE,\n          sub,\n          headers,\n          additionalData: receipt,\n          nextPaymentProcessing\n        });\n      });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"errors when a user is already subscribed","suites":["Apple Payments","subscribe"],"updatePoint":{"line":311,"column":48,"index":11128},"line":311,"code":"    it('errors when a user is already subscribed', async () => {\n      payments.createSubscription.restore();\n      user = new User();\n      await applePayments.subscribe(sku, user, receipt, headers, nextPaymentProcessing);\n      await expect(applePayments.subscribe(sku, user, receipt, headers, nextPaymentProcessing)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: applePayments.constants.RESPONSE_ALREADY_USED\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if we are missing a subscription","suites":["Apple Payments","cancelSubscribe "],"updatePoint":{"line":363,"column":62,"index":13088},"line":363,"code":"    it('should throw an error if we are missing a subscription', async () => {\n      user.purchased.plan.paymentMethod = undefined;\n      await expect(applePayments.cancelSubscribe(user, headers)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: i18n.t('missingSubscription')\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if subscription is still valid","suites":["Apple Payments","cancelSubscribe "],"updatePoint":{"line":371,"column":60,"index":13441},"line":371,"code":"    it('should throw an error if subscription is still valid', async () => {\n      iap.getPurchaseData.restore();\n      iapGetPurchaseDataStub = sinon.stub(iap, 'getPurchaseData').returns([{\n        expirationDate: expirationDate.add({\n          day: 1\n        }).toDate()\n      }]);\n      await expect(applePayments.cancelSubscribe(user, headers)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: applePayments.constants.RESPONSE_STILL_VALID\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if receipt is invalid","suites":["Apple Payments","cancelSubscribe "],"updatePoint":{"line":384,"column":51,"index":13954},"line":384,"code":"    it('should throw an error if receipt is invalid', async () => {\n      iap.isValidated.restore();\n      iapIsValidatedStub = sinon.stub(iap, 'isValidated').returns(false);\n      await expect(applePayments.cancelSubscribe(user, headers)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: applePayments.constants.RESPONSE_INVALID_RECEIPT\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"should cancel a user subscription","suites":["Apple Payments","cancelSubscribe "],"updatePoint":{"line":393,"column":41,"index":14361},"line":393,"code":"    it('should cancel a user subscription', async () => {\n      await applePayments.cancelSubscribe(user, headers);\n      expect(iapSetupStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledWith(iap.APPLE, receipt);\n      expect(iapIsValidatedStub).to.be.calledOnce;\n      expect(iapIsValidatedStub).to.be.calledWith({\n        expirationDate\n      });\n      expect(iapGetPurchaseDataStub).to.be.calledOnce;\n      expect(paymentCancelSubscriptionSpy).to.be.calledOnce;\n      expect(paymentCancelSubscriptionSpy).to.be.calledWith({\n        user,\n        paymentMethod: applePayments.constants.PAYMENT_METHOD_APPLE,\n        nextBill: expirationDate.toDate(),\n        headers\n      });\n    });","file":"api/unit/libs/payments/apple.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the gem block key is invalid","suites":["payments/gems","#getGemsBlock"],"updatePoint":{"line":9,"column":55,"index":382},"line":9,"code":"    it('throws an error if the gem block key is invalid', () => {\n      expect(() => getGemsBlock('invalid')).to.throw;\n    });","file":"api/unit/libs/payments/gems.test.js","skipped":false,"dir":"test"},{"name":"returns the gem block for the given key","suites":["payments/gems","#getGemsBlock"],"updatePoint":{"line":12,"column":47,"index":502},"line":12,"code":"    it('returns the gem block for the given key', () => {\n      expect(getGemsBlock('21gems')).to.equal(common.content.gems['21gems']);\n    });","file":"api/unit/libs/payments/gems.test.js","skipped":false,"dir":"test"},{"name":"throws if the gift message is too long","suites":["payments/gems","#validateGiftMessage"],"updatePoint":{"line":31,"column":46,"index":1124},"line":31,"code":"    it('throws if the gift message is too long', () => {\n      let expectedErr;\n\n      try {\n        validateGiftMessage(gift, user);\n      } catch (err) {\n        expectedErr = err;\n      }\n\n      expect(expectedErr).to.exist;\n      expect(expectedErr).to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('giftMessageTooLong', {\n          maxGiftMessageLength: 200\n        })\n      });\n    });","file":"api/unit/libs/payments/gems.test.js","skipped":false,"dir":"test"},{"name":"does not throw if the gift message is not too long","suites":["payments/gems","#validateGiftMessage"],"updatePoint":{"line":49,"column":58,"index":1563},"line":49,"code":"    it('does not throw if the gift message is not too long', () => {\n      gift.message = gift.message.substring(0, 200);\n      expect(() => validateGiftMessage(gift, user)).to.not.throw;\n    });","file":"api/unit/libs/payments/gems.test.js","skipped":false,"dir":"test"},{"name":"does not throw if it is not a gift","suites":["payments/gems","#validateGiftMessage"],"updatePoint":{"line":53,"column":42,"index":1743},"line":53,"code":"    it('does not throw if it is not a gift', () => {\n      expect(() => validateGiftMessage(null, user)).to.not.throw;\n    });","file":"api/unit/libs/payments/gems.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if receipt is invalid","suites":["Google Payments","verifyGemPurchase"],"updatePoint":{"line":46,"column":51,"index":1714},"line":46,"code":"    it('should throw an error if receipt is invalid', async () => {\n      iap.isValidated.restore();\n      iapIsValidatedStub = sinon.stub(iap, 'isValidated').returns(false);\n      await expect(googlePayments.verifyGemPurchase({\n        user,\n        receipt,\n        signature,\n        headers\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: googlePayments.constants.RESPONSE_INVALID_RECEIPT\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if productId is invalid","suites":["Google Payments","verifyGemPurchase"],"updatePoint":{"line":60,"column":53,"index":2199},"line":60,"code":"    it('should throw an error if productId is invalid', async () => {\n      receipt = `{\"token\": \"${token}\", \"productId\": \"invalid\"}`;\n      await expect(googlePayments.verifyGemPurchase({\n        user,\n        receipt,\n        signature,\n        headers\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: googlePayments.constants.RESPONSE_INVALID_ITEM\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if user cannot purchase gems","suites":["Google Payments","verifyGemPurchase"],"updatePoint":{"line":73,"column":58,"index":2644},"line":73,"code":"    it('should throw an error if user cannot purchase gems', async () => {\n      sinon.stub(user, 'canGetGems').resolves(false);\n      await expect(googlePayments.verifyGemPurchase({\n        user,\n        receipt,\n        signature,\n        headers\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: i18n.t('groupPolicyCannotGetGems')\n      });\n      user.canGetGems.restore();\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"purchases gems","suites":["Google Payments","verifyGemPurchase"],"updatePoint":{"line":87,"column":22,"index":3063},"line":87,"code":"    it('purchases gems', async () => {\n      sinon.stub(user, 'canGetGems').resolves(true);\n      await googlePayments.verifyGemPurchase({\n        user,\n        receipt,\n        signature,\n        headers\n      });\n      expect(validateGiftMessageStub).to.not.be.called;\n      expect(iapSetupStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledWith(iap.GOOGLE, {\n        data: receipt,\n        signature\n      });\n      expect(iapIsValidatedStub).to.be.calledOnce;\n      expect(iapIsValidatedStub).to.be.calledWith({});\n      expect(paymentBuyGemsStub).to.be.calledOnce;\n      expect(paymentBuyGemsStub).to.be.calledWith({\n        user,\n        paymentMethod: googlePayments.constants.PAYMENT_METHOD_GOOGLE,\n        gemsBlock,\n        headers,\n        gift: undefined\n      });\n      expect(user.canGetGems).to.be.calledOnce;\n      user.canGetGems.restore();\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"gifts gems","suites":["Google Payments","verifyGemPurchase"],"updatePoint":{"line":115,"column":18,"index":3988},"line":115,"code":"    it('gifts gems', async () => {\n      const receivingUser = new User();\n      await receivingUser.save();\n      const gift = {\n        uuid: receivingUser._id\n      };\n      await googlePayments.verifyGemPurchase({\n        user,\n        gift,\n        receipt,\n        signature,\n        headers\n      });\n      expect(validateGiftMessageStub).to.be.calledOnce;\n      expect(validateGiftMessageStub).to.be.calledWith(gift, user);\n      expect(iapSetupStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledWith(iap.GOOGLE, {\n        data: receipt,\n        signature\n      });\n      expect(iapIsValidatedStub).to.be.calledOnce;\n      expect(iapIsValidatedStub).to.be.calledWith({});\n      expect(paymentBuyGemsStub).to.be.calledOnce;\n      expect(paymentBuyGemsStub).to.be.calledWith({\n        user,\n        paymentMethod: googlePayments.constants.PAYMENT_METHOD_GOOGLE,\n        gemsBlock,\n        headers,\n        gift: {\n          type: 'gems',\n          gems: {\n            amount: 21\n          },\n          member: sinon.match({\n            _id: receivingUser._id\n          }),\n          uuid: receivingUser._id\n        }\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if receipt is invalid","suites":["Google Payments","subscribe"],"updatePoint":{"line":191,"column":51,"index":6310},"line":191,"code":"    it('should throw an error if receipt is invalid', async () => {\n      iap.isValidated.restore();\n      iapIsValidatedStub = sinon.stub(iap, 'isValidated').returns(false);\n      await expect(googlePayments.subscribe(sku, user, receipt, signature, headers, nextPaymentProcessing)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: googlePayments.constants.RESPONSE_INVALID_RECEIPT\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if sku is invalid","suites":["Google Payments","subscribe"],"updatePoint":{"line":200,"column":47,"index":6767},"line":200,"code":"    it('should throw an error if sku is invalid', async () => {\n      sku = 'invalid';\n      await expect(googlePayments.subscribe(sku, user, receipt, signature, headers, nextPaymentProcessing)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: googlePayments.constants.RESPONSE_INVALID_ITEM\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"creates a user subscription","suites":["Google Payments","subscribe"],"updatePoint":{"line":208,"column":35,"index":7125},"line":208,"code":"    it('creates a user subscription', async () => {\n      await googlePayments.subscribe(sku, user, receipt, signature, headers, nextPaymentProcessing);\n      expect(iapSetupStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledWith(iap.GOOGLE, {\n        data: receipt,\n        signature\n      });\n      expect(iapIsValidatedStub).to.be.calledOnce;\n      expect(iapIsValidatedStub).to.be.calledWith({});\n      expect(paymentsCreateSubscritionStub).to.be.calledOnce;\n      expect(paymentsCreateSubscritionStub).to.be.calledWith({\n        user,\n        customerId: token,\n        paymentMethod: googlePayments.constants.PAYMENT_METHOD_GOOGLE,\n        sub,\n        headers,\n        additionalData: {\n          data: receipt,\n          signature\n        },\n        nextPaymentProcessing\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if we are missing a subscription","suites":["Google Payments","cancelSubscribe "],"updatePoint":{"line":280,"column":62,"index":9580},"line":280,"code":"    it('should throw an error if we are missing a subscription', async () => {\n      user.purchased.plan.paymentMethod = undefined;\n      await expect(googlePayments.cancelSubscribe(user, headers)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: i18n.t('missingSubscription')\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if receipt is invalid","suites":["Google Payments","cancelSubscribe "],"updatePoint":{"line":288,"column":51,"index":9925},"line":288,"code":"    it('should throw an error if receipt is invalid', async () => {\n      iap.isValidated.restore();\n      iapIsValidatedStub = sinon.stub(iap, 'isValidated').returns(false);\n      await expect(googlePayments.cancelSubscribe(user, headers)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: googlePayments.constants.RESPONSE_INVALID_RECEIPT\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"should cancel a user subscription","suites":["Google Payments","cancelSubscribe "],"updatePoint":{"line":297,"column":41,"index":10334},"line":297,"code":"    it('should cancel a user subscription', async () => {\n      await googlePayments.cancelSubscribe(user, headers);\n      expect(iapSetupStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledWith(iap.GOOGLE, {\n        data: receipt,\n        signature\n      });\n      expect(iapIsValidatedStub).to.be.calledOnce;\n      expect(iapIsValidatedStub).to.be.calledWith({\n        expirationDate\n      });\n      expect(iapGetPurchaseDataStub).to.be.calledOnce;\n      expect(paymentCancelSubscriptionSpy).to.be.calledOnce;\n      expect(paymentCancelSubscriptionSpy).to.be.calledWith({\n        user,\n        paymentMethod: googlePayments.constants.PAYMENT_METHOD_GOOGLE,\n        nextBill: expirationDate.toDate(),\n        headers\n      });\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"should not cancel a user subscription with autorenew","suites":["Google Payments","cancelSubscribe "],"updatePoint":{"line":318,"column":60,"index":11151},"line":318,"code":"    it('should not cancel a user subscription with autorenew', async () => {\n      iap.getPurchaseData.restore();\n      iapGetPurchaseDataStub = sinon.stub(iap, 'getPurchaseData').returns([{\n        autoRenewing: true\n      }]);\n      await googlePayments.cancelSubscribe(user, headers);\n      expect(iapSetupStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledOnce;\n      expect(iapValidateStub).to.be.calledWith(iap.GOOGLE, {\n        data: receipt,\n        signature\n      });\n      expect(iapIsValidatedStub).to.be.calledOnce;\n      expect(iapIsValidatedStub).to.be.calledWith({\n        expirationDate\n      });\n      expect(iapGetPurchaseDataStub).to.be.calledOnce;\n      expect(paymentCancelSubscriptionSpy).to.not.be.called;\n    });","file":"api/unit/libs/payments/google.test.js","skipped":false,"dir":"test"},{"name":"adds a month termination date by default","suites":["Canceling a subscription for group"],"updatePoint":{"line":60,"column":46,"index":1678},"line":60,"code":"  it('adds a month termination date by default', async () => {\n    data.groupId = group._id;\n    await api.cancelSubscription(data);\n    const now = new Date();\n    const updatedGroup = await Group.findById(group._id).exec();\n    const daysTillTermination = moment(updatedGroup.purchased.plan.dateTerminated).diff(now, 'days');\n    expect(daysTillTermination).to.be.within(29, 30); // 1 month +/- 1 days\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"adds extraMonths to dateTerminated value","suites":["Canceling a subscription for group"],"updatePoint":{"line":68,"column":46,"index":2088},"line":68,"code":"  it('adds extraMonths to dateTerminated value', async () => {\n    group.purchased.plan.extraMonths = 2;\n    await group.save();\n    data.groupId = group._id;\n    await api.cancelSubscription(data);\n    const now = new Date();\n    const updatedGroup = await Group.findById(group._id).exec();\n    const daysTillTermination = moment(updatedGroup.purchased.plan.dateTerminated).diff(now, 'days');\n    expect(daysTillTermination).to.be.within(89, 90); // 3 months +/- 1 days\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"handles extra month fractions","suites":["Canceling a subscription for group"],"updatePoint":{"line":78,"column":35,"index":2554},"line":78,"code":"  it('handles extra month fractions', async () => {\n    group.purchased.plan.extraMonths = 0.3;\n    await group.save();\n    data.groupId = group._id;\n    await api.cancelSubscription(data);\n    const now = new Date();\n    const updatedGroup = await Group.findById(group._id).exec();\n    const daysTillTermination = moment(updatedGroup.purchased.plan.dateTerminated).diff(now, 'days');\n    expect(daysTillTermination).to.be.within(38, 39); // should be about 1 month + 1/3 month\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"terminates at next billing date if it exists","suites":["Canceling a subscription for group"],"updatePoint":{"line":88,"column":50,"index":3053},"line":88,"code":"  it('terminates at next billing date if it exists', async () => {\n    data.nextBill = moment().add({\n      days: 15\n    });\n    data.groupId = group._id;\n    await api.cancelSubscription(data);\n    const now = new Date();\n    const updatedGroup = await Group.findById(group._id).exec();\n    const daysTillTermination = moment(updatedGroup.purchased.plan.dateTerminated).diff(now, 'days');\n    expect(daysTillTermination).to.be.within(13, 15);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"resets plan.extraMonths","suites":["Canceling a subscription for group"],"updatePoint":{"line":99,"column":29,"index":3482},"line":99,"code":"  it('resets plan.extraMonths', async () => {\n    group.purchased.plan.extraMonths = 5;\n    await group.save();\n    data.groupId = group._id;\n    await api.cancelSubscription(data);\n    const updatedGroup = await Group.findById(group._id).exec();\n    expect(updatedGroup.purchased.plan.extraMonths).to.eql(0);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"sends an email","suites":["Canceling a subscription for group"],"updatePoint":{"line":107,"column":20,"index":3789},"line":107,"code":"  it('sends an email', async () => {\n    data.groupId = group._id;\n    await api.cancelSubscription(data);\n    expect(sender.sendTxn).to.be.calledOnce;\n    expect(sender.sendTxn.firstCall.args[0]._id).to.equal(user._id);\n    expect(sender.sendTxn.firstCall.args[1]).to.equal('group-cancel-subscription');\n    expect(sender.sendTxn.firstCall.args[2]).to.eql([{\n      name: 'GROUP_NAME',\n      content: group.name\n    }]);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"prevents non group leader from managing subscription","suites":["Canceling a subscription for group"],"updatePoint":{"line":118,"column":58,"index":4254},"line":118,"code":"  it('prevents non group leader from managing subscription', async () => {\n    const groupMember = new User();\n    groupMember.guilds.push(group._id);\n    await groupMember.save();\n    data.user = groupMember;\n    data.groupId = group._id;\n    await expect(api.cancelSubscription(data)).eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      message: i18n.t('onlyGroupLeaderCanManageSubscription'),\n      name: 'NotAuthorized'\n    });\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"allows old group leader to cancel if they created the subscription","suites":["Canceling a subscription for group"],"updatePoint":{"line":130,"column":72,"index":4717},"line":130,"code":"  it('allows old group leader to cancel if they created the subscription', async () => {\n    data.groupId = group._id;\n    data.sub = {\n      key: 'group_monthly'\n    };\n    data.paymentMethod = 'Payment Method';\n    await api.createSubscription(data);\n    let updatedGroup = await Group.findById(group._id).exec();\n    const newLeader = new User();\n    newLeader.profile.name = 'newLeader';\n    updatedGroup.leader = newLeader._id;\n    await newLeader.save();\n    await updatedGroup.save();\n    await api.cancelSubscription(data);\n    updatedGroup = await Group.findById(group._id).exec();\n    expect(updatedGroup.purchased.plan.dateTerminated).to.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"cancels member subscriptions","suites":["Canceling a subscription for group"],"updatePoint":{"line":147,"column":34,"index":5341},"line":147,"code":"  it('cancels member subscriptions', async () => {\n    data = {\n      user,\n      sub: {\n        key: 'basic_3mo'\n      },\n      customerId: 'customer-id',\n      paymentMethod: 'Payment Method',\n      headers: {\n        'x-client': 'habitica-web',\n        'user-agent': ''\n      }\n    };\n    expect(group.purchased.plan.planId).to.not.exist;\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    await api.cancelSubscription(data);\n    const now = new Date();\n    now.setHours(0, 0, 0, 0);\n    const updatedLeader = await User.findById(user._id).exec();\n    const daysTillTermination = moment(updatedLeader.purchased.plan.dateTerminated).diff(now, 'days');\n    expect(daysTillTermination).to.be.within(2, 3); // only a few days\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"sends an email to members of group","suites":["Canceling a subscription for group"],"updatePoint":{"line":170,"column":40,"index":6101},"line":170,"code":"  it('sends an email to members of group', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    await api.cancelSubscription(data);\n    expect(sender.sendTxn).to.be.have.callCount(6);\n    const recipientCall = sender.sendTxn.getCalls().find(call => {\n      const isRecipient = call.args[0]._id === recipient._id;\n      const isGroupMemberCancel = call.args[1] === 'group-member-cancel';\n      return isRecipient && isGroupMemberCancel;\n    });\n    expect(recipientCall.args[0]._id).to.equal(recipient._id);\n    expect(recipientCall.args[1]).to.equal('group-member-cancel');\n    expect(recipientCall.args[2]).to.eql([{\n      name: 'LEADER',\n      content: user.profile.name\n    }, {\n      name: 'GROUP_NAME',\n      content: group.name\n    }]);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"does not cancel member subscriptions when member does not have a group plan sub (i.e. UNLIMITED_CUSTOMER_ID)","suites":["Canceling a subscription for group"],"updatePoint":{"line":194,"column":114,"index":7101},"line":194,"code":"  it('does not cancel member subscriptions when member does not have a group plan sub (i.e. UNLIMITED_CUSTOMER_ID)', async () => {\n    plan.key = 'basic_earned';\n    plan.customerId = api.constants.UNLIMITED_CUSTOMER_ID;\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.cancelSubscription(data);\n    const updatedLeader = await User.findById(user._id).exec();\n    expect(updatedLeader.purchased.plan.dateTerminated).to.not.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"does not cancel a user subscription if they are still in another active group plan","suites":["Canceling a subscription for group"],"updatePoint":{"line":207,"column":88,"index":7685},"line":207,"code":"  it('does not cancel a user subscription if they are still in another active group plan', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    let updatedUser = await User.findById(recipient._id).exec();\n    const firstDateCreated = updatedUser.purchased.plan.dateCreated;\n    const extraMonthsBeforeSecond = updatedUser.purchased.plan.extraMonths;\n    const group2 = generateGroup({\n      name: 'test group2',\n      type: 'guild',\n      privacy: 'private',\n      leader: user._id\n    });\n    data.groupId = group2._id;\n    await group2.save();\n    user.guilds.push(group2._id);\n    await user.save();\n    recipient.guilds.push(group2._id);\n    await recipient.save();\n    await api.createSubscription(data);\n    await api.cancelSubscription(data);\n    updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('group_plan_auto');\n    expect(updatedUser.purchased.plan.customerId).to.eql('group-plan');\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql('Group Plan');\n    expect(updatedUser.purchased.plan.extraMonths).to.eql(extraMonthsBeforeSecond);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.eql(firstDateCreated);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"does cancel a leader subscription with two cancelled group plans","suites":["Canceling a subscription for group"],"updatePoint":{"line":244,"column":70,"index":9369},"line":244,"code":"  it('does cancel a leader subscription with two cancelled group plans', async () => {\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    let updatedUser = await User.findById(user._id).exec();\n    const firstDateCreated = updatedUser.purchased.plan.dateCreated;\n    const extraMonthsBeforeSecond = updatedUser.purchased.plan.extraMonths;\n    const group2 = generateGroup({\n      name: 'test group2',\n      type: 'guild',\n      privacy: 'private',\n      leader: user._id\n    });\n    user.guilds.push(group2._id);\n    await user.save();\n    data.groupId = group2._id;\n    await group2.save();\n    await api.createSubscription(data);\n    await api.cancelSubscription(data);\n    data.groupId = group._id;\n    await api.cancelSubscription(data);\n    updatedUser = await User.findById(user._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('group_plan_auto');\n    expect(updatedUser.purchased.plan.customerId).to.eql('group-plan');\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql('Group Plan');\n    expect(updatedUser.purchased.plan.extraMonths).to.eql(extraMonthsBeforeSecond);\n    expect(updatedUser.purchased.plan.dateTerminated).to.exist;\n    expect(updatedUser.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.eql(firstDateCreated);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-cancel.test.js","skipped":false,"dir":"test"},{"name":"creates a group plan","suites":["Purchasing a group plan for group"],"updatePoint":{"line":87,"column":26,"index":2879},"line":87,"code":"  it('creates a group plan', async () => {\n    expect(group.purchased.plan.planId).to.not.exist;\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedGroup = await Group.findById(group._id).exec();\n    expect(updatedGroup.purchased.plan.planId).to.eql('basic_3mo');\n    expect(updatedGroup.purchased.plan.customerId).to.eql('customer-id');\n    expect(updatedGroup.purchased.plan.dateUpdated).to.exist;\n    expect(updatedGroup.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedGroup.purchased.plan.paymentMethod).to.eql('Payment Method');\n    expect(updatedGroup.purchased.plan.extraMonths).to.eql(0);\n    expect(updatedGroup.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedGroup.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedGroup.purchased.plan.dateCreated).to.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"does not create a group plan for a public guild","suites":["Purchasing a group plan for group"],"updatePoint":{"line":102,"column":53,"index":3754},"line":102,"code":"  it('does not create a group plan for a public guild', async () => {\n    const publicGroup = generateGroup({\n      name: groupName,\n      type: 'guild',\n      privacy: 'public',\n      leader: user._id\n    });\n    await publicGroup.save();\n    expect(publicGroup.purchased.plan.planId).to.not.exist;\n    data.groupId = publicGroup._id;\n    await expect(api.createSubscription(data)).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      name: 'NotAuthorized',\n      message: i18n.t('onlyPrivateGuildsCanUpgrade')\n    });\n    const updatedGroup = await Group.findById(publicGroup._id).exec();\n    expect(updatedGroup.purchased.plan.planId).to.not.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"sends an email","suites":["Purchasing a group plan for group"],"updatePoint":{"line":120,"column":20,"index":4392},"line":120,"code":"  it('sends an email', async () => {\n    expect(group.purchased.plan.planId).to.not.exist;\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    expect(sender.sendTxn).to.be.calledWith(user, 'group-subscription-begins');\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"sets extraMonths if plan has dateTerminated date","suites":["Purchasing a group plan for group"],"updatePoint":{"line":126,"column":54,"index":4673},"line":126,"code":"  it('sets extraMonths if plan has dateTerminated date', async () => {\n    group.purchased.plan = plan;\n    group.purchased.plan.dateTerminated = moment(new Date()).add(2, 'months');\n    await group.save();\n    expect(group.purchased.plan.extraMonths).to.eql(0);\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedGroup = await Group.findById(group._id).exec();\n    expect(updatedGroup.purchased.plan.extraMonths).to.within(1.9, 2);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"does not set negative extraMonths if plan has past dateTerminated date","suites":["Purchasing a group plan for group"],"updatePoint":{"line":136,"column":76,"index":5170},"line":136,"code":"  it('does not set negative extraMonths if plan has past dateTerminated date', async () => {\n    group.purchased.plan = plan;\n    group.purchased.plan.dateTerminated = moment(new Date()).subtract(2, 'months');\n    await group.save();\n    expect(group.purchased.plan.extraMonths).to.eql(0);\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedGroup = await Group.findById(group._id).exec();\n    expect(updatedGroup.purchased.plan.extraMonths).to.eql(0);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"grants all members of a group a subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":146,"column":50,"index":5638},"line":146,"code":"  it('grants all members of a group a subscription', async () => {\n    expect(group.purchased.plan.planId).to.not.exist;\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedLeader = await User.findById(user._id).exec();\n    expect(updatedLeader.purchased.plan.planId).to.eql('group_plan_auto');\n    expect(updatedLeader.purchased.plan.customerId).to.eql('group-plan');\n    expect(updatedLeader.purchased.plan.dateUpdated).to.exist;\n    expect(updatedLeader.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedLeader.purchased.plan.paymentMethod).to.eql('Group Plan');\n    expect(updatedLeader.purchased.plan.extraMonths).to.eql(0);\n    expect(updatedLeader.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedLeader.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedLeader.purchased.plan.dateCreated).to.exist;\n    expect(updatedLeader.items.mounts['Jackalope-RoyalPurple']).to.be.true;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"sends an email to member of group who was not a subscriber","suites":["Purchasing a group plan for group"],"updatePoint":{"line":162,"column":64,"index":6609},"line":162,"code":"  it('sends an email to member of group who was not a subscriber', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    expect(sender.sendTxn).to.be.calledThrice;\n    const recipientCall = sender.sendTxn.getCalls().find(call => {\n      const isRecipient = call.args[0]._id === recipient._id;\n      const isJoin = call.args[1] === 'group-member-join';\n      return isRecipient && isJoin;\n    });\n    expect(recipientCall.args[0]._id).to.equal(recipient._id);\n    expect(recipientCall.args[1]).to.equal('group-member-join');\n    expect(recipientCall.args[2]).to.eql([{\n      name: 'LEADER',\n      content: user.profile.name\n    }, {\n      name: 'GROUP_NAME',\n      content: group.name\n    }, {\n      name: 'PREVIOUS_SUBSCRIPTION_TYPE',\n      content: EMAIL_TEMPLATE_SUBSCRIPTION_TYPE_NONE\n    }]); // confirm that the other email sent is appropriate:\n\n    const leaderCall = sender.sendTxn.getCalls().find(call => {\n      const isLeader = call.args[0]._id === group.leader;\n      const isSubscriptionBegin = call.args[1] === 'group-subscription-begins';\n      return isLeader && isSubscriptionBegin;\n    });\n    expect(leaderCall.args[0]._id).to.equal(group.leader);\n    expect(leaderCall.args[1]).to.equal('group-subscription-begins');\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"sends one email to subscribed member of group, stating subscription is cancelled (Stripe)","suites":["Purchasing a group plan for group"],"updatePoint":{"line":196,"column":95,"index":8058},"line":196,"code":"  it('sends one email to subscribed member of group, stating subscription is cancelled (Stripe)', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    plan.paymentMethod = stripePayments.constants.PAYMENT_METHOD;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    expect(sender.sendTxn).to.be.calledThrice;\n    const recipientCall = sender.sendTxn.getCalls().find(call => {\n      const isRecipient = call.args[0]._id === recipient._id;\n      const isJoin = call.args[1] === 'group-member-join';\n      return isRecipient && isJoin;\n    });\n    expect(recipientCall.args[0]._id).to.equal(recipient._id);\n    expect(recipientCall.args[1]).to.equal('group-member-join');\n    expect(recipientCall.args[2]).to.eql([{\n      name: 'LEADER',\n      content: user.profile.name\n    }, {\n      name: 'GROUP_NAME',\n      content: group.name\n    }, {\n      name: 'PREVIOUS_SUBSCRIPTION_TYPE',\n      content: EMAIL_TEMPLATE_SUBSCRIPTION_TYPE_NORMAL\n    }]); // confirm that the other email sent is not a cancel-subscription email:\n\n    const leaderCall = sender.sendTxn.getCalls().find(call => {\n      const isLeader = call.args[0]._id === group.leader;\n      const isSubscriptionBegin = call.args[1] === 'group-subscription-begins';\n      return isLeader && isSubscriptionBegin;\n    });\n    expect(leaderCall.args[0]._id).to.equal(group.leader);\n    expect(leaderCall.args[1]).to.equal('group-subscription-begins');\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"sends one email to subscribed member of group, stating subscription is cancelled (Amazon)","suites":["Purchasing a group plan for group"],"updatePoint":{"line":233,"column":95,"index":9663},"line":233,"code":"  it('sends one email to subscribed member of group, stating subscription is cancelled (Amazon)', async () => {\n    sinon.stub(amzLib, 'getBillingAgreementDetails').resolves({\n      BillingAgreementDetails: {\n        BillingAgreementStatus: {\n          State: 'Closed'\n        }\n      }\n    });\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.planId = 'basic_earned';\n    plan.paymentMethod = amzLib.constants.PAYMENT_METHOD;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    expect(sender.sendTxn).to.be.calledThrice;\n    const recipientCall = sender.sendTxn.getCalls().find(call => {\n      const isRecipient = call.args[0]._id === recipient._id;\n      const isJoin = call.args[1] === 'group-member-join';\n      return isRecipient && isJoin;\n    });\n    expect(recipientCall.args[0]._id).to.equal(recipient._id);\n    expect(recipientCall.args[1]).to.equal('group-member-join');\n    expect(recipientCall.args[2]).to.eql([{\n      name: 'LEADER',\n      content: user.profile.name\n    }, {\n      name: 'GROUP_NAME',\n      content: group.name\n    }, {\n      name: 'PREVIOUS_SUBSCRIPTION_TYPE',\n      content: EMAIL_TEMPLATE_SUBSCRIPTION_TYPE_NORMAL\n    }]); // confirm that the other email sent is not a cancel-subscription email:\n\n    const leaderCall = sender.sendTxn.getCalls().find(call => {\n      const isLeader = call.args[0]._id === group.leader;\n      const isSubscriptionBegin = call.args[1] === 'group-subscription-begins';\n      return isLeader && isSubscriptionBegin;\n    });\n    expect(leaderCall.args[0]._id).to.equal(group.leader);\n    expect(leaderCall.args[1]).to.equal('group-subscription-begins');\n    amzLib.getBillingAgreementDetails.restore();\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"sends one email to subscribed member of group, stating subscription is cancelled (PayPal)","suites":["Purchasing a group plan for group"],"updatePoint":{"line":278,"column":95,"index":11495},"line":278,"code":"  it('sends one email to subscribed member of group, stating subscription is cancelled (PayPal)', async () => {\n    sinon.stub(paypalPayments, 'paypalBillingAgreementCancel').resolves({});\n    sinon.stub(paypalPayments, 'paypalBillingAgreementGet').resolves({\n      agreement_details: {\n        // eslint-disable-line camelcase\n        next_billing_date: moment().add(3, 'months').toDate(),\n        // eslint-disable-line camelcase\n        cycles_completed: 1 // eslint-disable-line camelcase\n\n      }\n    });\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.planId = 'basic_earned';\n    plan.paymentMethod = paypalPayments.constants.PAYMENT_METHOD;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    expect(sender.sendTxn).to.be.calledThrice;\n    const recipientCall = sender.sendTxn.getCalls().find(call => {\n      const isRecipient = call.args[0]._id === recipient._id;\n      const isJoin = call.args[1] === 'group-member-join';\n      return isRecipient && isJoin;\n    });\n    expect(recipientCall.args[0]._id).to.equal(recipient._id);\n    expect(recipientCall.args[1]).to.equal('group-member-join');\n    expect(recipientCall.args[2]).to.eql([{\n      name: 'LEADER',\n      content: user.profile.name\n    }, {\n      name: 'GROUP_NAME',\n      content: group.name\n    }, {\n      name: 'PREVIOUS_SUBSCRIPTION_TYPE',\n      content: EMAIL_TEMPLATE_SUBSCRIPTION_TYPE_NORMAL\n    }]); // confirm that the other email sent is not a cancel-subscription email:\n\n    const leaderCall = sender.sendTxn.getCalls().find(call => {\n      const isLeader = call.args[0]._id === group.leader;\n      const isSubscriptionBegin = call.args[1] === 'group-subscription-begins';\n      return isLeader && isSubscriptionBegin;\n    });\n    expect(leaderCall.args[0]._id).to.equal(group.leader);\n    expect(leaderCall.args[1]).to.equal('group-subscription-begins');\n    paypalPayments.paypalBillingAgreementGet.restore();\n    paypalPayments.paypalBillingAgreementCancel.restore();\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"sends appropriate emails when subscribed member of group must manually cancel recurring Android subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":327,"column":114,"index":13635},"line":327,"code":"  it('sends appropriate emails when subscribed member of group must manually cancel recurring Android subscription', async () => {\n    const TECH_ASSISTANCE_EMAIL = nconf.get('EMAILS_TECH_ASSISTANCE_EMAIL');\n    plan.customerId = 'random';\n    plan.paymentMethod = api.constants.GOOGLE_PAYMENT_METHOD;\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    expect(sender.sendTxn).to.have.callCount(4);\n    const adminUserSubscriptionDetails = sender.sendTxn.args.find(sendTxnArgs => {\n      const emailType = sendTxnArgs[1];\n      return emailType === 'admin-user-subscription-details';\n    });\n    expect(adminUserSubscriptionDetails).to.exist;\n    expect(adminUserSubscriptionDetails[0].email).to.equal(TECH_ASSISTANCE_EMAIL);\n    const groupMemberJoinOne = sender.sendTxn.args.find(sendTxnArgs => {\n      const emailType = sendTxnArgs[1];\n      const emailRecipient = sendTxnArgs[0];\n      return emailType === 'group-member-join' && emailRecipient._id === recipient._id;\n    });\n    expect(groupMemberJoinOne).to.exist;\n    expect(groupMemberJoinOne[0]._id).to.equal(recipient._id);\n    expect(groupMemberJoinOne[2]).to.eql([{\n      name: 'LEADER',\n      content: groupLeaderName\n    }, {\n      name: 'GROUP_NAME',\n      content: groupName\n    }, {\n      name: 'PREVIOUS_SUBSCRIPTION_TYPE',\n      content: EMAIL_TEMPLATE_SUBSCRIPTION_TYPE_GOOGLE\n    }]);\n    const groupMemberJoinTwo = sender.sendTxn.args.find(sendTxnArgs => {\n      const emailType = sendTxnArgs[1];\n      const emailRecipient = sendTxnArgs[0];\n      return emailType === 'group-member-join' && emailRecipient._id === group.leader;\n    });\n    expect(groupMemberJoinTwo).to.exist;\n    expect(groupMemberJoinTwo[0]._id).to.equal(group.leader);\n    const groupSubscriptionBegins = sender.sendTxn.args.find(sendTxnArgs => {\n      const emailType = sendTxnArgs[1];\n      return emailType === 'group-subscription-begins';\n    });\n    expect(groupSubscriptionBegins).to.exist;\n    expect(groupSubscriptionBegins[0]._id).to.equal(group.leader);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"sends appropriate emails when subscribed member of group must manually cancel recurring iOS subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":376,"column":110,"index":15845},"line":376,"code":"  it('sends appropriate emails when subscribed member of group must manually cancel recurring iOS subscription', async () => {\n    const TECH_ASSISTANCE_EMAIL = nconf.get('EMAILS_TECH_ASSISTANCE_EMAIL');\n    plan.customerId = 'random';\n    plan.paymentMethod = api.constants.IOS_PAYMENT_METHOD;\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    expect(sender.sendTxn).to.have.callCount(4);\n    const adminUserSubscriptionDetails = sender.sendTxn.args.find(sendTxnArgs => {\n      const emailType = sendTxnArgs[1];\n      return emailType === 'admin-user-subscription-details';\n    });\n    expect(adminUserSubscriptionDetails).to.exist;\n    expect(adminUserSubscriptionDetails[0].email).to.equal(TECH_ASSISTANCE_EMAIL);\n    const groupMemberJoinOne = sender.sendTxn.args.find(sendTxnArgs => {\n      const emailType = sendTxnArgs[1];\n      const emailRecipient = sendTxnArgs[0];\n      return emailType === 'group-member-join' && emailRecipient._id === recipient._id;\n    });\n    expect(groupMemberJoinOne).to.exist;\n    expect(groupMemberJoinOne[0]._id).to.equal(recipient._id);\n    expect(groupMemberJoinOne[2]).to.eql([{\n      name: 'LEADER',\n      content: groupLeaderName\n    }, {\n      name: 'GROUP_NAME',\n      content: groupName\n    }, {\n      name: 'PREVIOUS_SUBSCRIPTION_TYPE',\n      content: EMAIL_TEMPLATE_SUBSCRIPTION_TYPE_IOS\n    }]);\n    const groupMemberJoinTwo = sender.sendTxn.args.find(sendTxnArgs => {\n      const emailType = sendTxnArgs[1];\n      const emailRecipient = sendTxnArgs[0];\n      return emailType === 'group-member-join' && emailRecipient._id === group.leader;\n    });\n    expect(groupMemberJoinTwo).to.exist;\n    expect(groupMemberJoinTwo[0]._id).to.equal(group.leader);\n    const groupSubscriptionBegins = sender.sendTxn.args.find(sendTxnArgs => {\n      const emailType = sendTxnArgs[1];\n      return emailType === 'group-subscription-begins';\n    });\n    expect(groupSubscriptionBegins).to.exist;\n    expect(groupSubscriptionBegins[0]._id).to.equal(group.leader);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing gift subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":425,"column":60,"index":17999},"line":425,"code":"  it('adds months to members with existing gift subscription', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    plan.planId = 'basic_earned';\n    plan.paymentMethod = 'paymentMethod';\n    data.gift = {\n      member: recipient,\n      subscription: {\n        key: 'basic_earned',\n        months: 1\n      }\n    };\n    await api.createSubscription(data);\n    await recipient.save();\n    data.gift = undefined;\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('group_plan_auto');\n    expect(updatedUser.purchased.plan.customerId).to.eql('group-plan');\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql('Group Plan');\n    expect(updatedUser.purchased.plan.extraMonths).to.within(1, 3);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing multi-month gift subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":455,"column":72,"index":19288},"line":455,"code":"  it('adds months to members with existing multi-month gift subscription', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    data.gift = {\n      member: recipient,\n      subscription: {\n        key: 'basic_3mo',\n        months: 3\n      }\n    };\n    await api.createSubscription(data);\n    await recipient.save();\n    data.gift = undefined;\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('group_plan_auto');\n    expect(updatedUser.purchased.plan.customerId).to.eql('group-plan');\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql('Group Plan');\n    expect(updatedUser.purchased.plan.extraMonths).to.within(3, 5);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing recurring subscription (Stripe)","suites":["Purchasing a group plan for group"],"updatePoint":{"line":483,"column":74,"index":20500},"line":483,"code":"  it('adds months to members with existing recurring subscription (Stripe)', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    plan.paymentMethod = stripePayments.constants.PAYMENT_METHOD;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.extraMonths).to.within(2, 3);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing recurring subscription (Amazon)","suites":["Purchasing a group plan for group"],"updatePoint":{"line":496,"column":74,"index":21078},"line":496,"code":"  it('adds months to members with existing recurring subscription (Amazon)', async () => {\n    sinon.stub(amzLib, 'getBillingAgreementDetails').resolves({\n      BillingAgreementDetails: {\n        BillingAgreementStatus: {\n          State: 'Closed'\n        }\n      }\n    });\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.planId = 'basic_earned';\n    plan.paymentMethod = amzLib.constants.PAYMENT_METHOD;\n    plan.lastBillingDate = moment().add(3, 'months');\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.extraMonths).to.within(3, 5);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing recurring subscription (Paypal)","suites":["Purchasing a group plan for group"],"updatePoint":{"line":517,"column":74,"index":21888},"line":517,"code":"  it('adds months to members with existing recurring subscription (Paypal)', async () => {\n    sinon.stub(paypalPayments, 'paypalBillingAgreementCancel').resolves({});\n    sinon.stub(paypalPayments, 'paypalBillingAgreementGet').resolves({\n      agreement_details: {\n        // eslint-disable-line camelcase\n        next_billing_date: moment().add(3, 'months').toDate(),\n        // eslint-disable-line camelcase\n        cycles_completed: 1 // eslint-disable-line camelcase\n\n      }\n    });\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.planId = 'basic_earned';\n    plan.paymentMethod = paypalPayments.constants.PAYMENT_METHOD;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.extraMonths).to.within(2, 3);\n    paypalPayments.paypalBillingAgreementGet.restore();\n    paypalPayments.paypalBillingAgreementCancel.restore();\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing recurring subscription (Android)","suites":["Purchasing a group plan for group"],"updatePoint":{"line":542,"column":75,"index":22983},"line":542,"code":"  it('adds months to members with existing recurring subscription (Android)');","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing recurring subscription (iOS)","suites":["Purchasing a group plan for group"],"updatePoint":{"line":543,"column":71,"index":23058},"line":543,"code":"  it('adds months to members with existing recurring subscription (iOS)');","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members who already cancelled but not yet terminated recurring subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":544,"column":96,"index":23158},"line":544,"code":"  it('adds months to members who already cancelled but not yet terminated recurring subscription', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    plan.paymentMethod = stripePayments.constants.PAYMENT_METHOD;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await recipient.cancelSubscription();\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.extraMonths).to.within(2, 3);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members who already cancelled but not yet terminated group plan subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":558,"column":97,"index":23801},"line":558,"code":"  it('adds months to members who already cancelled but not yet terminated group plan subscription', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    plan.paymentMethod = api.constants.GROUP_PLAN_PAYMENT_METHOD;\n    plan.extraMonths = 2.94;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await recipient.cancelSubscription();\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.extraMonths).to.within(3, 4);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"resets date terminated if user has old subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":573,"column":57,"index":24433},"line":573,"code":"  it('resets date terminated if user has old subscription', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    plan.paymentMethod = stripePayments.constants.PAYMENT_METHOD;\n    plan.dateTerminated = moment().subtract(1, 'days').toDate();\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.dateTerminated).to.not.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing recurring subscription and includes existing extraMonths","suites":["Purchasing a group plan for group"],"updatePoint":{"line":587,"column":99,"index":25101},"line":587,"code":"  it('adds months to members with existing recurring subscription and includes existing extraMonths', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    plan.paymentMethod = stripePayments.constants.PAYMENT_METHOD;\n    plan.extraMonths = 5;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.extraMonths).to.within(7, 9);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"adds months to members with existing recurring subscription and ignores existing negative extraMonths","suites":["Purchasing a group plan for group"],"updatePoint":{"line":601,"column":107,"index":25738},"line":601,"code":"  it('adds months to members with existing recurring subscription and ignores existing negative extraMonths', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    plan.paymentMethod = stripePayments.constants.PAYMENT_METHOD;\n    plan.extraMonths = -5;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.extraMonths).to.within(2, 3);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"does not override gemsBought, mysteryItems, dateCreated, and consective fields","suites":["Purchasing a group plan for group"],"updatePoint":{"line":615,"column":84,"index":26353},"line":615,"code":"  it('does not override gemsBought, mysteryItems, dateCreated, and consective fields', async () => {\n    const planCreatedDate = moment().toDate();\n    const mysteryItem = {\n      title: 'item'\n    };\n    const mysteryItems = [mysteryItem];\n    const consecutive = {\n      trinkets: 3,\n      gemCapExtra: 20,\n      offset: 1,\n      count: 13\n    };\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    plan.gemsBought = 3;\n    plan.dateCreated = planCreatedDate;\n    plan.mysteryItems = mysteryItems;\n    plan.consecutive = consecutive;\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.gemsBought).to.equal(3);\n    expect(updatedUser.purchased.plan.mysteryItems[0]).to.eql(mysteryItem);\n    expect(updatedUser.purchased.plan.consecutive.count).to.equal(consecutive.count);\n    expect(updatedUser.purchased.plan.consecutive.offset).to.equal(consecutive.offset);\n    expect(updatedUser.purchased.plan.consecutive.gemCapExtra).to.equal(consecutive.gemCapExtra);\n    expect(updatedUser.purchased.plan.consecutive.trinkets).to.equal(consecutive.trinkets);\n    expect(updatedUser.purchased.plan.dateCreated).to.eql(planCreatedDate);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"does not modify a user with a group subscription when they join another group","suites":["Purchasing a group plan for group"],"updatePoint":{"line":648,"column":83,"index":27772},"line":648,"code":"  it('does not modify a user with a group subscription when they join another group', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    let updatedUser = await User.findById(recipient._id).exec();\n    const firstDateCreated = updatedUser.purchased.plan.dateCreated;\n    const extraMonthsBeforeSecond = updatedUser.purchased.plan.extraMonths;\n    const group2 = generateGroup({\n      name: 'test group2',\n      type: 'guild',\n      privacy: 'private',\n      leader: user._id\n    });\n    data.groupId = group2._id;\n    await group2.save();\n    recipient.guilds.push(group2._id);\n    await recipient.save();\n    user.guilds.push(group2._id);\n    await user.save();\n    await api.createSubscription(data);\n    updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('group_plan_auto');\n    expect(updatedUser.purchased.plan.customerId).to.eql('group-plan');\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql('Group Plan');\n    expect(updatedUser.purchased.plan.extraMonths).to.eql(extraMonthsBeforeSecond);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.eql(firstDateCreated);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"does not remove a user who is in two groups plans and leaves one","suites":["Purchasing a group plan for group"],"updatePoint":{"line":684,"column":70,"index":29416},"line":684,"code":"  it('does not remove a user who is in two groups plans and leaves one', async () => {\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    plan.key = 'basic_earned';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    let updatedUser = await User.findById(recipient._id).exec();\n    const firstDateCreated = updatedUser.purchased.plan.dateCreated;\n    const extraMonthsBeforeSecond = updatedUser.purchased.plan.extraMonths;\n    const group2 = generateGroup({\n      name: 'test group2',\n      type: 'guild',\n      privacy: 'private',\n      leader: user._id\n    });\n    data.groupId = group2._id;\n    await group2.save();\n    recipient.guilds.push(group2._id);\n    await recipient.save();\n    user.guilds.push(group2._id);\n    await user.save();\n    await api.createSubscription(data);\n    const updatedGroup = await Group.findById(group._id).exec();\n    updatedGroup.memberCount = 2;\n    await updatedGroup.save();\n    await updatedGroup.leave(recipient);\n    updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('group_plan_auto');\n    expect(updatedUser.purchased.plan.customerId).to.eql('group-plan');\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql('Group Plan');\n    expect(updatedUser.purchased.plan.extraMonths).to.eql(extraMonthsBeforeSecond);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.eql(firstDateCreated);\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"does not modify a user with an unlimited subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":724,"column":59,"index":31220},"line":724,"code":"  it('does not modify a user with an unlimited subscription', async () => {\n    plan.key = 'basic_earned';\n    plan.customerId = api.constants.UNLIMITED_CUSTOMER_ID;\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('basic_3mo');\n    expect(updatedUser.purchased.plan.customerId).to.eql(api.constants.UNLIMITED_CUSTOMER_ID);\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql('paymentMethod');\n    expect(updatedUser.purchased.plan.extraMonths).to.eql(0);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"does not modify a user with an Android subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":745,"column":57,"index":32324},"line":745,"code":"  it('does not modify a user with an Android subscription', async () => {\n    plan.customerId = 'random';\n    plan.paymentMethod = api.constants.GOOGLE_PAYMENT_METHOD;\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('basic_3mo');\n    expect(updatedUser.purchased.plan.customerId).to.eql('random');\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql(api.constants.GOOGLE_PAYMENT_METHOD);\n    expect(updatedUser.purchased.plan.extraMonths).to.eql(0);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"does not modify a user with an iOS subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":766,"column":53,"index":33421},"line":766,"code":"  it('does not modify a user with an iOS subscription', async () => {\n    plan.customerId = 'random';\n    plan.paymentMethod = api.constants.IOS_PAYMENT_METHOD;\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('basic_3mo');\n    expect(updatedUser.purchased.plan.customerId).to.eql('random');\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql(api.constants.IOS_PAYMENT_METHOD);\n    expect(updatedUser.purchased.plan.extraMonths).to.eql(0);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"updates a user with a cancelled but active group subscription","suites":["Purchasing a group plan for group"],"updatePoint":{"line":787,"column":67,"index":34526},"line":787,"code":"  it('updates a user with a cancelled but active group subscription', async () => {\n    plan.key = 'basic_earned';\n    plan.customerId = api.constants.GROUP_PLAN_CUSTOMER_ID;\n    plan.dateTerminated = moment().add(1, 'months');\n    const recipient = new User();\n    recipient.profile.name = 'recipient';\n    recipient.purchased.plan = plan;\n    recipient.guilds.push(group._id);\n    await recipient.save();\n    data.groupId = group._id;\n    await api.createSubscription(data);\n    const updatedUser = await User.findById(recipient._id).exec();\n    expect(updatedUser.purchased.plan.planId).to.eql('group_plan_auto');\n    expect(updatedUser.purchased.plan.customerId).to.eql(api.constants.GROUP_PLAN_CUSTOMER_ID);\n    expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n    expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n    expect(updatedUser.purchased.plan.paymentMethod).to.eql('Group Plan');\n    expect(updatedUser.purchased.plan.extraMonths).to.within(0, 2);\n    expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n    expect(updatedUser.purchased.plan.lastBillingDate).to.not.exist;\n    expect(updatedUser.purchased.plan.dateCreated).to.exist;\n  });","file":"api/unit/libs/payments/group-plans/group-payments-create.test.js","skipped":false,"dir":"test"},{"name":"awards the Royal Purple Jackalope pet","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":80,"column":47,"index":2455},"line":80,"code":"      it('awards the Royal Purple Jackalope pet', async () => {\n        await api.createSubscription(data);\n        expect(recipient.items.pets['Jackalope-RoyalPurple']).to.eql(5);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds extra months to an existing subscription","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":84,"column":55,"index":2654},"line":84,"code":"      it('adds extra months to an existing subscription', async () => {\n        recipient.purchased.plan = plan;\n        expect(recipient.purchased.plan.extraMonths).to.eql(0);\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.extraMonths).to.eql(3);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not set negative extraMonths if plan has past dateTerminated date","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":90,"column":80,"index":2974},"line":90,"code":"      it('does not set negative extraMonths if plan has past dateTerminated date', async () => {\n        const dateTerminated = moment().subtract(2, 'months').toDate();\n        recipient.purchased.plan.dateTerminated = dateTerminated;\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.extraMonths).to.eql(0);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not reset Gold-to-Gems cap on an existing subscription","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":96,"column":69,"index":3316},"line":96,"code":"      it('does not reset Gold-to-Gems cap on an existing subscription', async () => {\n        recipient.purchased.plan = plan;\n        recipient.purchased.plan.gemsBought = 12;\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.gemsBought).to.eql(12);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds to date terminated for an existing plan with a future terminated date","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":102,"column":84,"index":3626},"line":102,"code":"      it('adds to date terminated for an existing plan with a future terminated date', async () => {\n        const dateTerminated = moment().add(1, 'months').toDate();\n        recipient.purchased.plan = plan;\n        recipient.purchased.plan.dateTerminated = dateTerminated;\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.dateTerminated).to.eql(moment(dateTerminated).add(3, 'months').toDate());\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"replaces date terminated for an account with a past terminated date","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":109,"column":77,"index":4062},"line":109,"code":"      it('replaces date terminated for an account with a past terminated date', async () => {\n        const dateTerminated = moment().subtract(1, 'months').toDate();\n        recipient.purchased.plan.dateTerminated = dateTerminated;\n        await api.createSubscription(data);\n        expect(moment(recipient.purchased.plan.dateTerminated).format('YYYY-MM-DD')).to.eql(moment().add(3, 'months').format('YYYY-MM-DD'));\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sets a dateTerminated date for a user without an existing subscription","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":115,"column":80,"index":4492},"line":115,"code":"      it('sets a dateTerminated date for a user without an existing subscription', async () => {\n        expect(recipient.purchased.plan.dateTerminated).to.not.exist;\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.dateTerminated).to.exist;\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sets plan.dateUpdated if it did not previously exist","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":120,"column":62,"index":4761},"line":120,"code":"      it('sets plan.dateUpdated if it did not previously exist', async () => {\n        expect(recipient.purchased.plan.dateUpdated).to.not.exist;\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.dateUpdated).to.exist;\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sets plan.dateUpdated if it did exist but the user has cancelled","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":125,"column":74,"index":5036},"line":125,"code":"      it('sets plan.dateUpdated if it did exist but the user has cancelled', async () => {\n        recipient.purchased.plan.dateUpdated = moment().subtract(1, 'days').toDate();\n        recipient.purchased.plan.dateTerminated = moment().subtract(1, 'days').toDate();\n        recipient.purchased.plan.customerId = 'testing';\n        await api.createSubscription(data);\n        expect(moment(recipient.purchased.plan.dateUpdated).date()).to.eql(moment().date());\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sets plan.dateUpdated if it did exist but the user has a corrupt plan","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":132,"column":79,"index":5511},"line":132,"code":"      it('sets plan.dateUpdated if it did exist but the user has a corrupt plan', async () => {\n        recipient.purchased.plan.dateUpdated = moment().subtract(1, 'days').toDate();\n        await api.createSubscription(data);\n        expect(moment(recipient.purchased.plan.dateUpdated).date()).to.eql(moment().date());\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sets plan.dateCreated if it did not previously exist","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":137,"column":62,"index":5823},"line":137,"code":"      it('sets plan.dateCreated if it did not previously exist', async () => {\n        expect(recipient.purchased.plan.dateCreated).to.not.exist;\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.dateCreated).to.exist;\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not change plan.customerId if it already exists","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":142,"column":62,"index":6086},"line":142,"code":"      it('does not change plan.customerId if it already exists', async () => {\n        recipient.purchased.plan = plan;\n        data.customerId = 'purchaserCustomerId';\n        expect(recipient.purchased.plan.customerId).to.eql('customer-id');\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.customerId).to.eql('customer-id');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sets plan.customerId to \"Gift\" if it does not already exist","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":149,"column":69,"index":6466},"line":149,"code":"      it('sets plan.customerId to \"Gift\" if it does not already exist', async () => {\n        expect(recipient.purchased.plan.customerId).to.not.exist;\n        await api.createSubscription(data);\n        expect(recipient.purchased.plan.customerId).to.eql('Gift');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"increases the buyer's transaction count","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":154,"column":50,"index":6721},"line":154,"code":"      it('increases the buyer\\'s transaction count', async () => {\n        expect(user.purchased.txnCount).to.eql(0);\n        await api.createSubscription(data);\n        expect(user.purchased.txnCount).to.eql(1);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends an email about the gift","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":159,"column":39,"index":6933},"line":159,"code":"      it('sends an email about the gift', async () => {\n        await api.createSubscription(data);\n        expect(sender.sendTxn).to.be.calledWith(recipient, 'gifted-subscription', [{\n          name: 'GIFTER',\n          content: 'sender'\n        }, {\n          name: 'X_MONTHS_SUBSCRIPTION',\n          content: 3\n        }]);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a push notification about the gift","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":169,"column":50,"index":7281},"line":169,"code":"      it('sends a push notification about the gift', async () => {\n        await api.createSubscription(data);\n        expect(notifications.sendNotification).to.be.calledOnce;\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"tracks subscription purchase as gift","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift"],"updatePoint":{"line":173,"column":46,"index":7463},"line":173,"code":"      it('tracks subscription purchase as gift', async () => {\n        await api.createSubscription(data);\n        expect(analytics.mockAnalyticsService.trackPurchase).to.be.calledOnce;\n        expect(analytics.mockAnalyticsService.trackPurchase).to.be.calledWith({\n          uuid: user._id,\n          groupId: undefined,\n          itemPurchased: 'Subscription',\n          sku: 'payment method-subscription',\n          purchaseType: 'subscribe',\n          paymentMethod: data.paymentMethod,\n          quantity: 1,\n          gift: true,\n          purchaseValue: 15,\n          firstPurchase: true,\n          headers: {\n            'x-client': 'habitica-web',\n            'user-agent': ''\n          }\n        });\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a private message about the gift","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift","No Active Promotion"],"updatePoint":{"line":200,"column":50,"index":8430},"line":200,"code":"        it('sends a private message about the gift', async () => {\n          await api.createSubscription(data);\n          const msg = '`Hello recipient, sender has sent you 3 months of subscription!`';\n          expect(user.sendMessage).to.be.calledOnce;\n          expect(user.sendMessage).to.be.calledWith(recipient, {\n            receiverMsg: msg,\n            senderMsg: msg,\n            save: false\n          });\n        });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"creates a gift subscription for purchaser and recipient if none exist","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift","Active Promotion"],"updatePoint":{"line":220,"column":81,"index":9227},"line":220,"code":"        it('creates a gift subscription for purchaser and recipient if none exist', async () => {\n          await api.createSubscription(data);\n          expect(user.items.pets['Jackalope-RoyalPurple']).to.eql(5);\n          expect(user.purchased.plan.customerId).to.eql('Gift');\n          expect(user.purchased.plan.dateTerminated).to.exist;\n          expect(user.purchased.plan.dateUpdated).to.exist;\n          expect(user.purchased.plan.dateCreated).to.exist;\n          expect(recipient.items.pets['Jackalope-RoyalPurple']).to.eql(5);\n          expect(recipient.purchased.plan.customerId).to.eql('Gift');\n          expect(recipient.purchased.plan.dateTerminated).to.exist;\n          expect(recipient.purchased.plan.dateUpdated).to.exist;\n          expect(recipient.purchased.plan.dateCreated).to.exist;\n        });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds extraMonths to existing subscription for purchaser and creates a gift subscription for recipient without sub","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift","Active Promotion"],"updatePoint":{"line":233,"column":125,"index":10088},"line":233,"code":"        it('adds extraMonths to existing subscription for purchaser and creates a gift subscription for recipient without sub', async () => {\n          user.purchased.plan = plan;\n          expect(user.purchased.plan.extraMonths).to.eql(0);\n          await api.createSubscription(data);\n          expect(user.purchased.plan.extraMonths).to.eql(3);\n          expect(recipient.items.pets['Jackalope-RoyalPurple']).to.eql(5);\n          expect(recipient.purchased.plan.customerId).to.eql('Gift');\n          expect(recipient.purchased.plan.dateTerminated).to.exist;\n          expect(recipient.purchased.plan.dateUpdated).to.exist;\n          expect(recipient.purchased.plan.dateCreated).to.exist;\n        });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds extraMonths to existing subscription for recipient and creates a gift subscription for purchaser without sub","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift","Active Promotion"],"updatePoint":{"line":244,"column":125,"index":10791},"line":244,"code":"        it('adds extraMonths to existing subscription for recipient and creates a gift subscription for purchaser without sub', async () => {\n          recipient.purchased.plan = plan;\n          expect(recipient.purchased.plan.extraMonths).to.eql(0);\n          await api.createSubscription(data);\n          expect(recipient.purchased.plan.extraMonths).to.eql(3);\n          expect(user.items.pets['Jackalope-RoyalPurple']).to.eql(5);\n          expect(user.purchased.plan.customerId).to.eql('Gift');\n          expect(user.purchased.plan.dateTerminated).to.exist;\n          expect(user.purchased.plan.dateUpdated).to.exist;\n          expect(user.purchased.plan.dateCreated).to.exist;\n        });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds extraMonths to existing subscriptions for purchaser and recipient","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift","Active Promotion"],"updatePoint":{"line":255,"column":82,"index":11441},"line":255,"code":"        it('adds extraMonths to existing subscriptions for purchaser and recipient', async () => {\n          user.purchased.plan = plan;\n          recipient.purchased.plan = plan;\n          expect(user.purchased.plan.extraMonths).to.eql(0);\n          expect(recipient.purchased.plan.extraMonths).to.eql(0);\n          await api.createSubscription(data);\n          expect(user.purchased.plan.extraMonths).to.eql(3);\n          expect(recipient.purchased.plan.extraMonths).to.eql(3);\n        });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a private message about the promotion","suites":["payments/index","#createSubscription","Purchasing a subscription as a gift","Active Promotion"],"updatePoint":{"line":264,"column":55,"index":11906},"line":264,"code":"        it('sends a private message about the promotion', async () => {\n          await api.createSubscription(data);\n          const msg = '`Hello sender, you received 3 months of subscription as part of our holiday gift-giving promotion!`';\n          expect(user.sendMessage).to.be.calledTwice;\n          expect(user.sendMessage).to.be.calledWith(user, {\n            receiverMsg: msg,\n            save: false\n          });\n        });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"creates a subscription","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":276,"column":32,"index":12396},"line":276,"code":"      it('creates a subscription', async () => {\n        expect(user.purchased.plan.planId).to.not.exist;\n        await api.createSubscription(data);\n        expect(user.purchased.plan.planId).to.eql('basic_3mo');\n        expect(user.purchased.plan.customerId).to.eql('customer-id');\n        expect(user.purchased.plan.dateUpdated).to.exist;\n        expect(user.purchased.plan.gemsBought).to.eql(0);\n        expect(user.purchased.plan.paymentMethod).to.eql('Payment Method');\n        expect(user.purchased.plan.extraMonths).to.eql(0);\n        expect(user.purchased.plan.dateTerminated).to.eql(null);\n        expect(user.purchased.plan.lastBillingDate).to.not.exist;\n        expect(user.purchased.plan.dateCreated).to.exist;\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"awards the Royal Purple Jackalope pet","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":289,"column":47,"index":13145},"line":289,"code":"      it('awards the Royal Purple Jackalope pet', async () => {\n        await api.createSubscription(data);\n        expect(user.items.pets['Jackalope-RoyalPurple']).to.eql(5);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sets extraMonths if plan has dateTerminated date","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":293,"column":58,"index":13342},"line":293,"code":"      it('sets extraMonths if plan has dateTerminated date', async () => {\n        user.purchased.plan = plan;\n        user.purchased.plan.dateTerminated = moment(new Date()).add(2, 'months');\n        expect(user.purchased.plan.extraMonths).to.eql(0);\n        await api.createSubscription(data);\n        expect(user.purchased.plan.extraMonths).to.within(1.9, 2);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not set negative extraMonths if plan has past dateTerminated date","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":300,"column":80,"index":13737},"line":300,"code":"      it('does not set negative extraMonths if plan has past dateTerminated date', async () => {\n        user.purchased.plan = plan;\n        user.purchased.plan.dateTerminated = moment(new Date()).subtract(2, 'months');\n        expect(user.purchased.plan.extraMonths).to.eql(0);\n        await api.createSubscription(data);\n        expect(user.purchased.plan.extraMonths).to.eql(0);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not reset Gold-to-Gems cap on additional subscription","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":307,"column":68,"index":14117},"line":307,"code":"      it('does not reset Gold-to-Gems cap on additional subscription', async () => {\n        user.purchased.plan = plan;\n        user.purchased.plan.gemsBought = 10;\n        await api.createSubscription(data);\n        expect(user.purchased.plan.gemsBought).to.eql(10);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sets lastBillingDate if payment method is \"Amazon Payments\"","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":313,"column":69,"index":14397},"line":313,"code":"      it('sets lastBillingDate if payment method is \"Amazon Payments\"', async () => {\n        data.paymentMethod = 'Amazon Payments';\n        await api.createSubscription(data);\n        expect(user.purchased.plan.lastBillingDate).to.exist;\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"increases the user's transaction count","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":318,"column":49,"index":14627},"line":318,"code":"      it('increases the user\\'s transaction count', async () => {\n        expect(user.purchased.txnCount).to.eql(0);\n        await api.createSubscription(data);\n        expect(user.purchased.txnCount).to.eql(1);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a transaction email","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":323,"column":35,"index":14835},"line":323,"code":"      it('sends a transaction email', async () => {\n        await api.createSubscription(data);\n        expect(sender.sendTxn).to.be.calledOnce;\n        expect(sender.sendTxn).to.be.calledWith(data.user, 'subscription-begins');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"tracks subscription purchase","suites":["payments/index","#createSubscription","Purchasing a subscription for self"],"updatePoint":{"line":328,"column":38,"index":15076},"line":328,"code":"      it('tracks subscription purchase', async () => {\n        await api.createSubscription(data);\n        expect(analytics.mockAnalyticsService.trackPurchase).to.be.calledOnce;\n        expect(analytics.mockAnalyticsService.trackPurchase).to.be.calledWith({\n          uuid: user._id,\n          groupId: undefined,\n          itemPurchased: 'Subscription',\n          sku: 'payment method-subscription',\n          purchaseType: 'subscribe',\n          paymentMethod: data.paymentMethod,\n          quantity: 1,\n          gift: false,\n          purchaseValue: 15,\n          firstPurchase: true,\n          headers: {\n            'x-client': 'habitica-web',\n            'user-agent': ''\n          }\n        });\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds block months to plan.consecutive.offset","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":350,"column":54,"index":15861},"line":350,"code":"      it('adds block months to plan.consecutive.offset', async () => {\n        await api.createSubscription(data);\n        expect(user.purchased.plan.consecutive.offset).to.eql(3);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not add to plans.consecutive.offset if 1 month subscription","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":354,"column":74,"index":16072},"line":354,"code":"      it('does not add to plans.consecutive.offset if 1 month subscription', async () => {\n        await api.createSubscription(data);\n        expect(user.purchased.plan.extraMonths).to.eql(0);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds 5 to plan.consecutive.gemCapExtra for 3 month block","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":358,"column":66,"index":16268},"line":358,"code":"      it('adds 5 to plan.consecutive.gemCapExtra for 3 month block', async () => {\n        await api.createSubscription(data);\n        expect(user.purchased.plan.consecutive.gemCapExtra).to.eql(5);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds 10 to plan.consecutive.gemCapExtra for 6 month block","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":362,"column":67,"index":16477},"line":362,"code":"      it('adds 10 to plan.consecutive.gemCapExtra for 6 month block', async () => {\n        data.sub.key = 'basic_6mo';\n        await api.createSubscription(data);\n        expect(user.purchased.plan.consecutive.gemCapExtra).to.eql(10);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds 20 to plan.consecutive.gemCapExtra for 12 month block","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":367,"column":68,"index":16724},"line":367,"code":"      it('adds 20 to plan.consecutive.gemCapExtra for 12 month block', async () => {\n        data.sub.key = 'basic_12mo';\n        await api.createSubscription(data);\n        expect(user.purchased.plan.consecutive.gemCapExtra).to.eql(20);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not raise plan.consecutive.gemCapExtra higher than 25","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":372,"column":68,"index":16972},"line":372,"code":"      it('does not raise plan.consecutive.gemCapExtra higher than 25', async () => {\n        data.sub.key = 'basic_12mo';\n        await api.createSubscription(data);\n        await api.createSubscription(data);\n        expect(user.purchased.plan.consecutive.gemCapExtra).to.eql(25);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds a plan.consecutive.trinkets for 3 month block","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":378,"column":60,"index":17256},"line":378,"code":"      it('adds a plan.consecutive.trinkets for 3 month block', async () => {\n        await api.createSubscription(data);\n        expect(user.purchased.plan.consecutive.trinkets).to.eql(1);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds 2 plan.consecutive.trinkets for 6 month block","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":382,"column":60,"index":17455},"line":382,"code":"      it('adds 2 plan.consecutive.trinkets for 6 month block', async () => {\n        data.sub.key = 'basic_6mo';\n        await api.createSubscription(data);\n        expect(user.purchased.plan.consecutive.trinkets).to.eql(2);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds 4 plan.consecutive.trinkets for 12 month block","suites":["payments/index","#createSubscription","Block subscription perks"],"updatePoint":{"line":387,"column":61,"index":17691},"line":387,"code":"      it('adds 4 plan.consecutive.trinkets for 12 month block', async () => {\n        data.sub.key = 'basic_12mo';\n        await api.createSubscription(data);\n        expect(user.purchased.plan.consecutive.trinkets).to.eql(4);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"awards mystery items when within the timeframe for a mystery item","suites":["payments/index","#createSubscription","Mystery Items"],"updatePoint":{"line":407,"column":75,"index":18360},"line":407,"code":"      it('awards mystery items when within the timeframe for a mystery item', async () => {\n        data = {\n          paymentMethod: 'PaymentMethod',\n          user,\n          sub: {\n            key: 'basic_3mo'\n          }\n        };\n        const oldNotificationsCount = user.notifications.length;\n        await api.createSubscription(data);\n        expect(user.notifications.find(n => n.type === 'NEW_MYSTERY_ITEMS')).to.not.be.undefined;\n        expect(user.purchased.plan.mysteryItems).to.have.a.lengthOf(2);\n        expect(user.purchased.plan.mysteryItems).to.include('armor_mystery_201605');\n        expect(user.purchased.plan.mysteryItems).to.include('head_mystery_201605');\n        expect(user.notifications.length).to.equal(oldNotificationsCount + 1);\n        expect(user.notifications[0].type).to.equal('NEW_MYSTERY_ITEMS');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not award mystery item when user already owns the item","suites":["payments/index","#createSubscription","Mystery Items"],"updatePoint":{"line":424,"column":69,"index":19201},"line":424,"code":"      it('does not award mystery item when user already owns the item', async () => {\n        user.items.gear.owned[mayMysteryItem] = true;\n        data = {\n          paymentMethod: 'PaymentMethod',\n          user,\n          sub: {\n            key: 'basic_3mo'\n          }\n        };\n        await api.createSubscription(data);\n        expect(user.purchased.plan.mysteryItems).to.have.a.lengthOf(1);\n        expect(user.purchased.plan.mysteryItems).to.include('head_mystery_201605');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not award mystery item when user already has the item in the mystery box","suites":["payments/index","#createSubscription","Mystery Items"],"updatePoint":{"line":437,"column":87,"index":19713},"line":437,"code":"      it('does not award mystery item when user already has the item in the mystery box', async () => {\n        user.purchased.plan.mysteryItems = [mayMysteryItem];\n        sandbox.spy(user.purchased.plan.mysteryItems, 'push');\n        data = {\n          paymentMethod: 'PaymentMethod',\n          user,\n          sub: {\n            key: 'basic_3mo'\n          }\n        };\n        await api.createSubscription(data);\n        expect(user.purchased.plan.mysteryItems.push).to.be.calledOnce;\n        expect(user.purchased.plan.mysteryItems.push).to.be.calledWith('head_mystery_201605');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds a month termination date by default","suites":["payments/index","#cancelSubscription","Canceling a subscription for self"],"updatePoint":{"line":460,"column":50,"index":20450},"line":460,"code":"      it('adds a month termination date by default', async () => {\n        await api.cancelSubscription(data);\n        const now = new Date();\n        const daysTillTermination = moment(user.purchased.plan.dateTerminated).diff(now, 'days');\n        expect(daysTillTermination).to.be.within(29, 30); // 1 month +/- 1 days\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds extraMonths to dateTerminated value","suites":["payments/index","#cancelSubscription","Canceling a subscription for self"],"updatePoint":{"line":466,"column":50,"index":20781},"line":466,"code":"      it('adds extraMonths to dateTerminated value', async () => {\n        user.purchased.plan.extraMonths = 2;\n        await api.cancelSubscription(data);\n        const now = new Date();\n        const daysTillTermination = moment(user.purchased.plan.dateTerminated).diff(now, 'days');\n        expect(daysTillTermination).to.be.within(89, 90); // 3 months +/- 1 days\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"handles extra month fractions","suites":["payments/index","#cancelSubscription","Canceling a subscription for self"],"updatePoint":{"line":473,"column":39,"index":21147},"line":473,"code":"      it('handles extra month fractions', async () => {\n        user.purchased.plan.extraMonths = 0.3;\n        await api.cancelSubscription(data);\n        const now = new Date();\n        const daysTillTermination = moment(user.purchased.plan.dateTerminated).diff(now, 'days');\n        expect(daysTillTermination).to.be.within(38, 39); // should be about 1 month + 1/3 month\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"terminates at next billing date if it exists","suites":["payments/index","#cancelSubscription","Canceling a subscription for self"],"updatePoint":{"line":480,"column":54,"index":21546},"line":480,"code":"      it('terminates at next billing date if it exists', async () => {\n        data.nextBill = moment().add({\n          days: 15\n        });\n        await api.cancelSubscription(data);\n        const now = new Date();\n        const daysTillTermination = moment(user.purchased.plan.dateTerminated).diff(now, 'days');\n        expect(daysTillTermination).to.be.within(13, 15);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"terminates at next billing date even if dateUpdated is prior to now","suites":["payments/index","#cancelSubscription","Canceling a subscription for self"],"updatePoint":{"line":489,"column":77,"index":21952},"line":489,"code":"      it('terminates at next billing date even if dateUpdated is prior to now', async () => {\n        data.nextBill = moment().add({\n          days: 15\n        });\n        data.user.purchased.plan.dateUpdated = moment().subtract({\n          days: 10\n        });\n        await api.cancelSubscription(data);\n        const now = new Date();\n        const daysTillTermination = moment(user.purchased.plan.dateTerminated).diff(now, 'days');\n        expect(daysTillTermination).to.be.within(13, 15);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"resets plan.extraMonths","suites":["payments/index","#cancelSubscription","Canceling a subscription for self"],"updatePoint":{"line":501,"column":33,"index":22412},"line":501,"code":"      it('resets plan.extraMonths', async () => {\n        user.purchased.plan.extraMonths = 5;\n        await api.cancelSubscription(data);\n        expect(user.purchased.plan.extraMonths).to.eql(0);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends an email","suites":["payments/index","#cancelSubscription","Canceling a subscription for self"],"updatePoint":{"line":506,"column":24,"index":22611},"line":506,"code":"      it('sends an email', async () => {\n        await api.cancelSubscription(data);\n        expect(sender.sendTxn).to.be.calledOnce;\n        expect(sender.sendTxn).to.be.calledWith(user, 'cancel-subscription');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a donation email","suites":["payments/index","#buyGems","Self Purchase"],"updatePoint":{"line":526,"column":32,"index":23170},"line":526,"code":"      it('sends a donation email', async () => {\n        await api.buyGems(data);\n        expect(sender.sendTxn).to.be.calledOnce;\n        expect(sender.sendTxn).to.be.calledWith(data.user, 'donation');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"does not apply a discount","suites":["payments/index","#buyGems","No Active Promotion"],"updatePoint":{"line":539,"column":35,"index":23617},"line":539,"code":"      it('does not apply a discount', async () => {\n        const balanceBefore = user.balance;\n        await api.buyGems(data);\n        const balanceAfter = user.balance;\n        const balanceDiff = balanceAfter - balanceBefore;\n        expect(balanceDiff * 4).to.eql(21);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"applies a discount","suites":["payments/index","#buyGems","Active Promotion"],"updatePoint":{"line":556,"column":28,"index":24192},"line":556,"code":"      it('applies a discount', async () => {\n        const balanceBefore = user.balance;\n        await api.buyGems(data);\n        const balanceAfter = user.balance;\n        const balanceDiff = balanceAfter - balanceBefore;\n        expect(balanceDiff * 4).to.eql(30);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"calculates balance from gem amount if gift","suites":["payments/index","#buyGems","Gift"],"updatePoint":{"line":576,"column":52,"index":24777},"line":576,"code":"      it('calculates balance from gem amount if gift', async () => {\n        expect(recipient.balance).to.eql(0);\n        await api.buyGems(data);\n        expect(recipient.balance).to.eql(1);\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a gifted-gems email","suites":["payments/index","#buyGems","Gift"],"updatePoint":{"line":581,"column":35,"index":24962},"line":581,"code":"      it('sends a gifted-gems email', async () => {\n        await api.buyGems(data);\n        expect(sender.sendTxn).to.be.calledOnce;\n        expect(sender.sendTxn).to.be.calledWith(data.gift.member, 'gifted-gems');\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a message from purchaser to recipient","suites":["payments/index","#buyGems","Gift"],"updatePoint":{"line":586,"column":53,"index":25206},"line":586,"code":"      it('sends a message from purchaser to recipient', async () => {\n        await api.buyGems(data);\n        const msg = '`Hello recipient, sender has sent you 4 gems!`';\n        expect(user.sendMessage).to.be.calledWith(recipient, {\n          receiverMsg: msg,\n          senderMsg: msg,\n          save: false\n        });\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a message from purchaser to recipient with custom message","suites":["payments/index","#buyGems","Gift"],"updatePoint":{"line":595,"column":73,"index":25560},"line":595,"code":"      it('sends a message from purchaser to recipient with custom message', async () => {\n        data.gift.message = 'giftmessage';\n        await api.buyGems(data);\n        const msg = `\\`Hello recipient, sender has sent you 4 gems!\\` ${data.gift.message}`;\n        expect(user.sendMessage).to.be.calledWith(recipient, {\n          receiverMsg: msg,\n          senderMsg: msg,\n          save: false\n        });\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends a push notification if user did not gift to self","suites":["payments/index","#buyGems","Gift"],"updatePoint":{"line":605,"column":64,"index":25971},"line":605,"code":"      it('sends a push notification if user did not gift to self', async () => {\n        await api.buyGems(data);\n        expect(notifications.sendNotification).to.be.calledOnce;\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"sends gem donation message in each participant's language","suites":["payments/index","#buyGems","Gift"],"updatePoint":{"line":609,"column":68,"index":26164},"line":609,"code":"      it('sends gem donation message in each participant\\'s language', async () => {\n        // TODO using english for both users because other languages are not loaded\n        // for api.buyGems\n        await recipient.update({\n          'preferences.language': 'en'\n        });\n        await user.update({\n          'preferences.language': 'en'\n        });\n        await api.buyGems(data);\n        const [recipientsMessageContent, sendersMessageContent] = ['en', 'en'].map(lang => {\n          const messageContent = t('giftedGemsFull', {\n            username: recipient.profile.name,\n            sender: user.profile.name,\n            gemAmount: data.gift.gems.amount\n          }, lang);\n          return `\\`${messageContent}\\``;\n        });\n        expect(user.sendMessage).to.be.calledWith(recipient, {\n          receiverMsg: recipientsMessageContent,\n          senderMsg: sendersMessageContent,\n          save: false\n        });\n      });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"adds a group subscription to a new user","suites":["payments/index","addSubToGroupUser"],"updatePoint":{"line":636,"column":47,"index":27141},"line":636,"code":"    it('adds a group subscription to a new user', async () => {\n      expect(group.purchased.plan.planId).to.not.exist;\n      data.groupId = group._id;\n      await api.addSubToGroupUser(user, group);\n      const updatedUser = await User.findById(user._id).exec();\n      expect(updatedUser.purchased.plan.planId).to.eql('group_plan_auto');\n      expect(updatedUser.purchased.plan.customerId).to.eql('group-plan');\n      expect(updatedUser.purchased.plan.dateUpdated).to.exist;\n      expect(updatedUser.purchased.plan.gemsBought).to.eql(0);\n      expect(updatedUser.purchased.plan.paymentMethod).to.eql('Group Plan');\n      expect(updatedUser.purchased.plan.extraMonths).to.eql(0);\n      expect(updatedUser.purchased.plan.dateTerminated).to.eql(null);\n      expect(updatedUser.purchased.plan.lastBillingDate).to.not.exist;\n      expect(updatedUser.purchased.plan.dateCreated).to.exist;\n    });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"awards the Royal Purple Jackalope pet","suites":["payments/index","addSubToGroupUser"],"updatePoint":{"line":651,"column":45,"index":28031},"line":651,"code":"    it('awards the Royal Purple Jackalope pet', async () => {\n      await api.addSubToGroupUser(user, group);\n      const updatedUser = await User.findById(user._id).exec();\n      expect(updatedUser.items.pets['Jackalope-RoyalPurple']).to.eql(5);\n    });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"saves previously unused Mystery Items and Hourglasses for an expired subscription","suites":["payments/index","addSubToGroupUser"],"updatePoint":{"line":656,"column":89,"index":28330},"line":656,"code":"    it('saves previously unused Mystery Items and Hourglasses for an expired subscription', async () => {\n      const planExpirationDate = new Date();\n      planExpirationDate.setDate(planExpirationDate.getDate() - 2);\n      const mysteryItem = 'item';\n      const mysteryItems = [mysteryItem];\n      const consecutive = {\n        trinkets: 3\n      }; // set expired plan with unused items\n\n      plan.mysteryItems = mysteryItems;\n      plan.consecutive = consecutive;\n      plan.dateCreated = planExpirationDate;\n      plan.dateTerminated = planExpirationDate;\n      plan.customerId = null;\n      user.purchased.plan = plan;\n      await user.save();\n      await api.addSubToGroupUser(user, group);\n      const updatedUser = await User.findById(user._id).exec();\n      expect(updatedUser.purchased.plan.mysteryItems[0]).to.eql(mysteryItem);\n      expect(updatedUser.purchased.plan.consecutive.trinkets).to.equal(consecutive.trinkets);\n    });","file":"api/unit/libs/payments/payments.test.js","skipped":false,"dir":"test"},{"name":"purchases gems","suites":["paypal - checkout success"],"updatePoint":{"line":30,"column":20,"index":1199},"line":30,"code":"  it('purchases gems', async () => {\n    await paypalPayments.checkoutSuccess({\n      user,\n      gift,\n      paymentId,\n      customerId,\n      gemsBlock: gemsBlockKey\n    });\n    expect(paypalPaymentExecuteStub).to.be.calledOnce;\n    expect(paypalPaymentExecuteStub).to.be.calledWith(paymentId, {\n      payer_id: customerId\n    });\n    expect(paymentBuyGemsStub).to.be.calledOnce;\n    expect(paymentBuyGemsStub).to.be.calledWith({\n      user,\n      customerId,\n      paymentMethod: 'Paypal',\n      gemsBlock\n    });\n  });","file":"api/unit/libs/payments/paypal/checkout-success.test.js","skipped":false,"dir":"test"},{"name":"gifts gems","suites":["paypal - checkout success"],"updatePoint":{"line":50,"column":16,"index":1719},"line":50,"code":"  it('gifts gems', async () => {\n    const receivingUser = new User();\n    await receivingUser.save();\n    gift = {\n      type: 'gems',\n      gems: {\n        amount: 16,\n        uuid: receivingUser._id\n      }\n    };\n    await paypalPayments.checkoutSuccess({\n      user,\n      gift,\n      paymentId,\n      customerId\n    });\n    expect(paypalPaymentExecuteStub).to.be.calledOnce;\n    expect(paypalPaymentExecuteStub).to.be.calledWith(paymentId, {\n      payer_id: customerId\n    });\n    expect(paymentBuyGemsStub).to.be.calledOnce;\n    expect(paymentBuyGemsStub).to.be.calledWith({\n      user,\n      customerId,\n      paymentMethod: 'PayPal (Gift)',\n      gift\n    });\n  });","file":"api/unit/libs/payments/paypal/checkout-success.test.js","skipped":false,"dir":"test"},{"name":"gifts subscription","suites":["paypal - checkout success"],"updatePoint":{"line":78,"column":24,"index":2402},"line":78,"code":"  it('gifts subscription', async () => {\n    const receivingUser = new User();\n    await receivingUser.save();\n    gift = {\n      type: 'subscription',\n      subscription: {\n        key: subKey,\n        uuid: receivingUser._id\n      }\n    };\n    await paypalPayments.checkoutSuccess({\n      user,\n      gift,\n      paymentId,\n      customerId\n    });\n    expect(paypalPaymentExecuteStub).to.be.calledOnce;\n    expect(paypalPaymentExecuteStub).to.be.calledWith(paymentId, {\n      payer_id: customerId\n    });\n    expect(paymentsCreateSubscritionStub).to.be.calledOnce;\n    expect(paymentsCreateSubscritionStub).to.be.calledWith({\n      user,\n      customerId,\n      paymentMethod: 'PayPal (Gift)',\n      gift\n    });\n  });","file":"api/unit/libs/payments/paypal/checkout-success.test.js","skipped":false,"dir":"test"},{"name":"creates a link for gem purchases","suites":["paypal - checkout"],"updatePoint":{"line":60,"column":38,"index":1688},"line":60,"code":"  it('creates a link for gem purchases', async () => {\n    const link = await paypalPayments.checkout({\n      user: new User(),\n      gemsBlock: gemsBlockKey\n    });\n    expect(gems.validateGiftMessage).to.not.be.called;\n    expect(paypalPaymentCreateStub).to.be.calledOnce;\n    expect(paypalPaymentCreateStub).to.be.calledWith(getPaypalCreateOptions('Habitica Gems', 4.99));\n    expect(link).to.eql(approvalHerf);\n  });","file":"api/unit/libs/payments/paypal/checkout.test.js","skipped":false,"dir":"test"},{"name":"should error if gem amount is too low","suites":["paypal - checkout"],"updatePoint":{"line":70,"column":43,"index":2114},"line":70,"code":"  it('should error if gem amount is too low', async () => {\n    const receivingUser = new User();\n    receivingUser.save();\n    const gift = {\n      type: 'gems',\n      gems: {\n        amount: 0,\n        uuid: receivingUser._id\n      }\n    };\n    await expect(paypalPayments.checkout({\n      gift\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 400,\n      message: 'Amount must be at least 1.',\n      name: 'BadRequest'\n    });\n  });","file":"api/unit/libs/payments/paypal/checkout.test.js","skipped":false,"dir":"test"},{"name":"should error if the user cannot get gems","suites":["paypal - checkout"],"updatePoint":{"line":88,"column":46,"index":2566},"line":88,"code":"  it('should error if the user cannot get gems', async () => {\n    const user = new User();\n    sinon.stub(user, 'canGetGems').resolves(false);\n    await expect(paypalPayments.checkout({\n      user,\n      gemsBlock: gemsBlockKey\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      message: i18n.t('groupPolicyCannotGetGems'),\n      name: 'NotAuthorized'\n    });\n  });","file":"api/unit/libs/payments/paypal/checkout.test.js","skipped":false,"dir":"test"},{"name":"should error if the gems block is not valid","suites":["paypal - checkout"],"updatePoint":{"line":100,"column":49,"index":2959},"line":100,"code":"  it('should error if the gems block is not valid', async () => {\n    const user = new User();\n    await expect(paypalPayments.checkout({\n      user,\n      gemsBlock: 'invalid'\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 400,\n      message: apiError('invalidGemsBlock'),\n      name: 'BadRequest'\n    });\n  });","file":"api/unit/libs/payments/paypal/checkout.test.js","skipped":false,"dir":"test"},{"name":"creates a link for gifting gems","suites":["paypal - checkout"],"updatePoint":{"line":111,"column":37,"index":3276},"line":111,"code":"  it('creates a link for gifting gems', async () => {\n    const user = new User();\n    const receivingUser = new User();\n    await receivingUser.save();\n    const gift = {\n      type: 'gems',\n      uuid: receivingUser._id,\n      gems: {\n        amount: 16\n      }\n    };\n    const link = await paypalPayments.checkout({\n      user,\n      gift\n    });\n    expect(gems.validateGiftMessage).to.be.calledOnce;\n    expect(gems.validateGiftMessage).to.be.calledWith(gift, user);\n    expect(paypalPaymentCreateStub).to.be.calledOnce;\n    expect(paypalPaymentCreateStub).to.be.calledWith(getPaypalCreateOptions('Habitica Gems (Gift)', '4.00'));\n    expect(link).to.eql(approvalHerf);\n  });","file":"api/unit/libs/payments/paypal/checkout.test.js","skipped":false,"dir":"test"},{"name":"creates a link for gifting a subscription","suites":["paypal - checkout"],"updatePoint":{"line":132,"column":47,"index":3968},"line":132,"code":"  it('creates a link for gifting a subscription', async () => {\n    const user = new User();\n    const receivingUser = new User();\n    receivingUser.save();\n    const gift = {\n      type: 'subscription',\n      subscription: {\n        key: subKey,\n        uuid: receivingUser._id\n      }\n    };\n    const link = await paypalPayments.checkout({\n      user,\n      gift\n    });\n    expect(gems.validateGiftMessage).to.be.calledOnce;\n    expect(gems.validateGiftMessage).to.be.calledWith(gift, user);\n    expect(paypalPaymentCreateStub).to.be.calledOnce;\n    expect(paypalPaymentCreateStub).to.be.calledWith(getPaypalCreateOptions('mo. Habitica Subscription (Gift)', '15.00'));\n    expect(link).to.eql(approvalHerf);\n  });","file":"api/unit/libs/payments/paypal/checkout.test.js","skipped":false,"dir":"test"},{"name":"should cancel a user subscription","suites":["paypal - ipn"],"updatePoint":{"line":42,"column":39,"index":1587},"line":42,"code":"  it('should cancel a user subscription', async () => {\n    await paypalPayments.ipn({\n      txn_type,\n      recurring_payment_id: userPaymentId\n    });\n    expect(ipnVerifyAsyncStub).to.be.calledOnce;\n    expect(ipnVerifyAsyncStub).to.be.calledWith({\n      txn_type,\n      recurring_payment_id: userPaymentId\n    });\n    expect(paymentCancelSubscriptionSpy).to.be.calledOnce;\n    expect(paymentCancelSubscriptionSpy.args[0][0].user._id).to.eql(user._id);\n    expect(paymentCancelSubscriptionSpy.args[0][0].paymentMethod).to.eql('Paypal');\n  });","file":"api/unit/libs/payments/paypal/ipn.test.js","skipped":false,"dir":"test"},{"name":"should cancel a group subscription","suites":["paypal - ipn"],"updatePoint":{"line":56,"column":40,"index":2134},"line":56,"code":"  it('should cancel a group subscription', async () => {\n    await paypalPayments.ipn({\n      txn_type,\n      recurring_payment_id: groupPaymentId\n    });\n    expect(ipnVerifyAsyncStub).to.be.calledOnce;\n    expect(ipnVerifyAsyncStub).to.be.calledWith({\n      txn_type,\n      recurring_payment_id: groupPaymentId\n    });\n    expect(paymentCancelSubscriptionSpy).to.be.calledOnce;\n    expect(paymentCancelSubscriptionSpy).to.be.calledWith({\n      groupId: group._id,\n      paymentMethod: 'Paypal'\n    });\n  });","file":"api/unit/libs/payments/paypal/ipn.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if we are missing a subscription","suites":["paypal - subscribeCancel"],"updatePoint":{"line":55,"column":60,"index":2103},"line":55,"code":"  it('should throw an error if we are missing a subscription', async () => {\n    user.purchased.plan.customerId = undefined;\n    await expect(paypalPayments.subscribeCancel({\n      user\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      name: 'NotAuthorized',\n      message: i18n.t('missingSubscription')\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe-cancel.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if group is not found","suites":["paypal - subscribeCancel"],"updatePoint":{"line":65,"column":49,"index":2434},"line":65,"code":"  it('should throw an error if group is not found', async () => {\n    await expect(paypalPayments.subscribeCancel({\n      user,\n      groupId: 'fake-id'\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 404,\n      name: 'NotFound',\n      message: i18n.t('groupNotFound')\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe-cancel.test.js","skipped":false,"dir":"test"},{"name":"should throw an error if user is not group leader","suites":["paypal - subscribeCancel"],"updatePoint":{"line":75,"column":55,"index":2738},"line":75,"code":"  it('should throw an error if user is not group leader', async () => {\n    const nonLeader = await createNonLeaderGroupMember(group);\n    await expect(paypalPayments.subscribeCancel({\n      user: nonLeader,\n      groupId: group._id\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      name: 'NotAuthorized',\n      message: i18n.t('onlyGroupLeaderCanManageSubscription')\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe-cancel.test.js","skipped":false,"dir":"test"},{"name":"should cancel a user subscription","suites":["paypal - subscribeCancel"],"updatePoint":{"line":86,"column":39,"index":3128},"line":86,"code":"  it('should cancel a user subscription', async () => {\n    await paypalPayments.subscribeCancel({\n      user\n    });\n    expect(paypalBillingAgreementGetStub).to.be.calledOnce;\n    expect(paypalBillingAgreementGetStub).to.be.calledWith(customerId);\n    expect(paypalBillingAgreementCancelStub).to.be.calledOnce;\n    expect(paypalBillingAgreementCancelStub).to.be.calledWith(customerId, {\n      note: i18n.t('cancelingSubscription')\n    });\n    expect(paymentCancelSubscriptionSpy).to.be.calledOnce;\n    expect(paymentCancelSubscriptionSpy).to.be.calledWith({\n      user,\n      groupId,\n      paymentMethod: 'Paypal',\n      nextBill: nextBillingDate,\n      cancellationReason: undefined\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe-cancel.test.js","skipped":false,"dir":"test"},{"name":"should cancel a group subscription","suites":["paypal - subscribeCancel"],"updatePoint":{"line":105,"column":40,"index":3830},"line":105,"code":"  it('should cancel a group subscription', async () => {\n    await paypalPayments.subscribeCancel({\n      user,\n      groupId: group._id\n    });\n    expect(paypalBillingAgreementGetStub).to.be.calledOnce;\n    expect(paypalBillingAgreementGetStub).to.be.calledWith(groupCustomerId);\n    expect(paypalBillingAgreementCancelStub).to.be.calledOnce;\n    expect(paypalBillingAgreementCancelStub).to.be.calledWith(groupCustomerId, {\n      note: i18n.t('cancelingSubscription')\n    });\n    expect(paymentCancelSubscriptionSpy).to.be.calledOnce;\n    expect(paymentCancelSubscriptionSpy).to.be.calledWith({\n      user,\n      groupId: group._id,\n      paymentMethod: 'Paypal',\n      nextBill: nextBillingDate,\n      cancellationReason: undefined\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe-cancel.test.js","skipped":false,"dir":"test"},{"name":"creates a user subscription","suites":["paypal - subscribeSuccess"],"updatePoint":{"line":39,"column":33,"index":1371},"line":39,"code":"  it('creates a user subscription', async () => {\n    await paypalPayments.subscribeSuccess({\n      user,\n      block,\n      groupId,\n      token,\n      headers\n    });\n    expect(paypalBillingAgreementExecuteStub).to.be.calledOnce;\n    expect(paypalBillingAgreementExecuteStub).to.be.calledWith(token, {});\n    expect(paymentsCreateSubscritionStub).to.be.calledOnce;\n    expect(paymentsCreateSubscritionStub).to.be.calledWith({\n      user,\n      groupId,\n      customerId,\n      paymentMethod: 'Paypal',\n      sub: block,\n      headers\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe-success.test.js","skipped":false,"dir":"test"},{"name":"create a group subscription","suites":["paypal - subscribeSuccess"],"updatePoint":{"line":59,"column":33,"index":1922},"line":59,"code":"  it('create a group subscription', async () => {\n    groupId = group._id;\n    await paypalPayments.subscribeSuccess({\n      user,\n      block,\n      groupId,\n      token,\n      headers\n    });\n    expect(paypalBillingAgreementExecuteStub).to.be.calledOnce;\n    expect(paypalBillingAgreementExecuteStub).to.be.calledWith(token, {});\n    expect(paymentsCreateSubscritionStub).to.be.calledOnce;\n    expect(paymentsCreateSubscritionStub).to.be.calledWith({\n      user,\n      groupId,\n      customerId,\n      paymentMethod: 'Paypal',\n      sub: block,\n      headers\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe-success.test.js","skipped":false,"dir":"test"},{"name":"should throw an error when coupon code is missing","suites":["paypal - subscribe"],"updatePoint":{"line":30,"column":55,"index":962},"line":30,"code":"  it('should throw an error when coupon code is missing', async () => {\n    sub.discount = 40;\n    await expect(paypalPayments.subscribe({\n      sub,\n      coupon\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 400,\n      name: 'BadRequest',\n      message: i18n.t('couponCodeRequired')\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe.test.js","skipped":false,"dir":"test"},{"name":"should throw an error when coupon code is invalid","suites":["paypal - subscribe"],"updatePoint":{"line":41,"column":55,"index":1277},"line":41,"code":"  it('should throw an error when coupon code is invalid', async () => {\n    sub.discount = 40;\n    sub.key = 'google_6mo';\n    coupon = 'example-coupon';\n    const couponModel = new Coupon();\n    couponModel.event = 'google_6mo';\n    await couponModel.save();\n    sinon.stub(cc, 'validate').returns('invalid');\n    await expect(paypalPayments.subscribe({\n      sub,\n      coupon\n    })).to.eventually.be.rejected.and.to.eql({\n      httpCode: 401,\n      name: 'NotAuthorized',\n      message: i18n.t('invalidCoupon')\n    });\n    cc.validate.restore();\n  });","file":"api/unit/libs/payments/paypal/subscribe.test.js","skipped":false,"dir":"test"},{"name":"subscribes with paypal with a coupon","suites":["paypal - subscribe"],"updatePoint":{"line":59,"column":42,"index":1820},"line":59,"code":"  it('subscribes with paypal with a coupon', async () => {\n    sub.discount = 40;\n    sub.key = 'google_6mo';\n    coupon = 'example-coupon';\n    const couponModel = new Coupon();\n    couponModel.event = 'google_6mo';\n    const updatedCouponModel = await couponModel.save();\n    sinon.stub(cc, 'validate').returns(updatedCouponModel._id);\n    const link = await paypalPayments.subscribe({\n      sub,\n      coupon\n    });\n    expect(link).to.eql(approvalHerf);\n    expect(paypalBillingAgreementCreateStub).to.be.calledOnce;\n    const billingPlanTitle = `Habitica Subscription ($${sub.price} every ${sub.months} months, recurring)`;\n    expect(paypalBillingAgreementCreateStub).to.be.calledWith({\n      name: billingPlanTitle,\n      description: billingPlanTitle,\n      start_date: moment().add({\n        minutes: 5\n      }).format(),\n      plan: {\n        id: sub.paypalKey\n      },\n      payer: {\n        payment_method: 'Paypal'\n      }\n    });\n    cc.validate.restore();\n  });","file":"api/unit/libs/payments/paypal/subscribe.test.js","skipped":false,"dir":"test"},{"name":"creates a link for a subscription","suites":["paypal - subscribe"],"updatePoint":{"line":89,"column":39,"index":2795},"line":89,"code":"  it('creates a link for a subscription', async () => {\n    delete sub.discount;\n    const link = await paypalPayments.subscribe({\n      sub,\n      coupon\n    });\n    expect(link).to.eql(approvalHerf);\n    expect(paypalBillingAgreementCreateStub).to.be.calledOnce;\n    const billingPlanTitle = `Habitica Subscription ($${sub.price} every ${sub.months} months, recurring)`;\n    expect(paypalBillingAgreementCreateStub).to.be.calledWith({\n      name: billingPlanTitle,\n      description: billingPlanTitle,\n      start_date: moment().add({\n        minutes: 5\n      }).format(),\n      plan: {\n        id: sub.paypalKey\n      },\n      payer: {\n        payment_method: 'Paypal'\n      }\n    });\n  });","file":"api/unit/libs/payments/paypal/subscribe.test.js","skipped":false,"dir":"test"},{"name":"should extend date to the exact amount of days left before the next bill will occur","suites":["stripe - #calculateSubscriptionTerminationDate"],"updatePoint":{"line":15,"column":89,"index":609},"line":15,"code":"  it('should extend date to the exact amount of days left before the next bill will occur', () => {\n    nextBill = moment().add(5, 'days');\n    const expectedTerminationDate = moment().add(5, 'days');\n    const terminationDate = calculateSubscriptionTerminationDate(nextBill, plan, groupPlanId);\n    expect(expectedTerminationDate.diff(terminationDate, 'days')).to.eql(0);\n  });","file":"api/unit/libs/payments/stripe/calculateSubscriptionTerminationDate.test.js","skipped":false,"dir":"test"},{"name":"if nextBill is null, add 30 days to termination date","suites":["stripe - #calculateSubscriptionTerminationDate"],"updatePoint":{"line":21,"column":58,"index":957},"line":21,"code":"  it('if nextBill is null, add 30 days to termination date', () => {\n    nextBill = null;\n    const expectedTerminationDate = moment().add(30, 'days');\n    const terminationDate = calculateSubscriptionTerminationDate(nextBill, plan, groupPlanId);\n    expect(expectedTerminationDate.diff(terminationDate, 'days')).to.eql(0);\n  });","file":"api/unit/libs/payments/stripe/calculateSubscriptionTerminationDate.test.js","skipped":false,"dir":"test"},{"name":"if nextBill is null and it's a group plan, add 2 days instead of 30","suites":["stripe - #calculateSubscriptionTerminationDate"],"updatePoint":{"line":27,"column":74,"index":1303},"line":27,"code":"  it('if nextBill is null and it\\'s a group plan, add 2 days instead of 30', () => {\n    nextBill = null;\n    plan.customerId = api.constants.GROUP_PLAN_CUSTOMER_ID;\n    const expectedTerminationDate = moment().add(2, 'days');\n    const terminationDate = calculateSubscriptionTerminationDate(nextBill, plan, groupPlanId);\n    expect(expectedTerminationDate.diff(terminationDate, 'days')).to.eql(0);\n  });","file":"api/unit/libs/payments/stripe/calculateSubscriptionTerminationDate.test.js","skipped":false,"dir":"test"},{"name":"should add 30.5 days for each extraMonth","suites":["stripe - #calculateSubscriptionTerminationDate"],"updatePoint":{"line":34,"column":46,"index":1680},"line":34,"code":"  it('should add 30.5 days for each extraMonth', () => {\n    plan.extraMonths = 4;\n    const expectedTerminationDate = moment().add(30.5 * 4, 'days');\n    const terminationDate = calculateSubscriptionTerminationDate(nextBill, plan, groupPlanId);\n    expect(expectedTerminationDate.diff(terminationDate, 'days')).to.eql(0);\n  });","file":"api/unit/libs/payments/stripe/calculateSubscriptionTerminationDate.test.js","skipped":false,"dir":"test"},{"name":"should round up if total days gained by extraMonth is a decimal number","suites":["stripe - #calculateSubscriptionTerminationDate"],"updatePoint":{"line":40,"column":76,"index":2039},"line":40,"code":"  it('should round up if total days gained by extraMonth is a decimal number', () => {\n    plan.extraMonths = 5;\n    const expectedTerminationDate = moment().add(Math.ceil(30.5 * 5), 'days');\n    const terminationDate = calculateSubscriptionTerminationDate(nextBill, plan, groupPlanId);\n    expect(expectedTerminationDate.diff(terminationDate, 'days')).to.eql(0);\n  });","file":"api/unit/libs/payments/stripe/calculateSubscriptionTerminationDate.test.js","skipped":false,"dir":"test"},{"name":"behaves like extraMonths is 0 if it's set to a negative number","suites":["stripe - #calculateSubscriptionTerminationDate"],"updatePoint":{"line":46,"column":69,"index":2402},"line":46,"code":"  it('behaves like extraMonths is 0 if it\\'s set to a negative number', () => {\n    plan.extraMonths = -5;\n    const expectedTerminationDate = moment();\n    const terminationDate = calculateSubscriptionTerminationDate(nextBill, plan, groupPlanId);\n    expect(expectedTerminationDate.diff(terminationDate, 'days')).to.eql(0);\n  });","file":"api/unit/libs/payments/stripe/calculateSubscriptionTerminationDate.test.js","skipped":false,"dir":"test"},{"name":"returns current terminated date if it exists and is later than newly calculated date","suites":["stripe - #calculateSubscriptionTerminationDate"],"updatePoint":{"line":52,"column":90,"index":2754},"line":52,"code":"  it('returns current terminated date if it exists and is later than newly calculated date', () => {\n    const expectedTerminationDate = moment().add({\n      months: 5\n    }).toDate();\n    plan.dateTerminated = expectedTerminationDate;\n    const terminationDate = calculateSubscriptionTerminationDate(nextBill, plan, groupPlanId);\n    expect(terminationDate).to.equal(expectedTerminationDate);\n  });","file":"api/unit/libs/payments/stripe/calculateSubscriptionTerminationDate.test.js","skipped":false,"dir":"test"},{"name":"returns the calculated termination date if the plan does not have one","suites":["stripe - #calculateSubscriptionTerminationDate"],"updatePoint":{"line":60,"column":75,"index":3139},"line":60,"code":"  it('returns the calculated termination date if the plan does not have one', () => {\n    nextBill = moment().add(5, 'days');\n    const expectedTerminationDate = moment().add(5, 'days');\n    const terminationDate = calculateSubscriptionTerminationDate(nextBill, plan, groupPlanId);\n    expect(expectedTerminationDate.diff(terminationDate, 'days')).to.eql(0);\n  });","file":"api/unit/libs/payments/stripe/calculateSubscriptionTerminationDate.test.js","skipped":false,"dir":"test"},{"name":"gems","suites":["Stripe - Checkout","createCheckoutSession"],"updatePoint":{"line":29,"column":12,"index":1356},"line":29,"code":"    it('gems', async () => {\n      const amount = 999;\n      const gemsBlockKey = '21gems';\n      sandbox.stub(oneTimePayments, 'getOneTimePaymentInfo').returns({\n        amount,\n        gemsBlock: common.content.gems[gemsBlockKey]\n      });\n      const res = await createCheckoutSession({\n        user,\n        gemsBlock: gemsBlockKey\n      }, stripe);\n      expect(res).to.equal(sessionId);\n      const metadata = {\n        type: 'gems',\n        userId: user._id,\n        gift: undefined,\n        sub: undefined,\n        gemsBlock: gemsBlockKey\n      };\n      expect(gems.validateGiftMessage).to.not.be.called;\n      expect(oneTimePayments.getOneTimePaymentInfo).to.be.calledOnce;\n      expect(oneTimePayments.getOneTimePaymentInfo).to.be.calledWith(gemsBlockKey, undefined, user);\n      expect(stripe.checkout.sessions.create).to.be.calledOnce;\n      expect(stripe.checkout.sessions.create).to.be.calledWith({\n        payment_method_types: ['card'],\n        metadata,\n        line_items: [{\n          price_data: {\n            product_data: {\n              name: common.i18n.t('nGems', {\n                nGems: 21\n              })\n            },\n            unit_amount: amount,\n            currency: 'usd'\n          },\n          quantity: 1\n        }],\n        mode: 'payment',\n        ...redirectUrls\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"gems gift","suites":["Stripe - Checkout","createCheckoutSession"],"updatePoint":{"line":71,"column":17,"index":2685},"line":71,"code":"    it('gems gift', async () => {\n      const receivingUser = new User();\n      await receivingUser.save();\n      const gift = {\n        type: 'gems',\n        uuid: receivingUser._id,\n        gems: {\n          amount: 4\n        }\n      };\n      const amount = 100;\n      sandbox.stub(oneTimePayments, 'getOneTimePaymentInfo').returns({\n        amount,\n        gemsBlock: null\n      });\n      const res = await createCheckoutSession({\n        user,\n        gift\n      }, stripe);\n      expect(res).to.equal(sessionId);\n      const metadata = {\n        type: 'gift-gems',\n        userId: user._id,\n        gift: JSON.stringify(gift),\n        sub: undefined,\n        gemsBlock: undefined\n      };\n      expect(gems.validateGiftMessage).to.be.calledOnce;\n      expect(gems.validateGiftMessage).to.be.calledWith(gift, user);\n      expect(oneTimePayments.getOneTimePaymentInfo).to.be.calledOnce;\n      expect(oneTimePayments.getOneTimePaymentInfo).to.be.calledWith(undefined, gift, user);\n      expect(stripe.checkout.sessions.create).to.be.calledOnce;\n      expect(stripe.checkout.sessions.create).to.be.calledWith({\n        payment_method_types: ['card'],\n        metadata,\n        line_items: [{\n          price_data: {\n            product_data: {\n              name: common.i18n.t('nGemsGift', {\n                nGems: 4\n              })\n            },\n            unit_amount: amount,\n            currency: 'usd'\n          },\n          quantity: 1\n        }],\n        mode: 'payment',\n        ...redirectUrls\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"subscription gift","suites":["Stripe - Checkout","createCheckoutSession"],"updatePoint":{"line":122,"column":25,"index":4219},"line":122,"code":"    it('subscription gift', async () => {\n      const receivingUser = new User();\n      await receivingUser.save();\n      const subKey = 'basic_3mo';\n      const gift = {\n        type: 'subscription',\n        uuid: receivingUser._id,\n        subscription: {\n          key: subKey\n        }\n      };\n      const amount = 1500;\n      sandbox.stub(oneTimePayments, 'getOneTimePaymentInfo').returns({\n        amount,\n        gemsBlock: null,\n        subscription: common.content.subscriptionBlocks[subKey]\n      });\n      const res = await createCheckoutSession({\n        user,\n        gift\n      }, stripe);\n      expect(res).to.equal(sessionId);\n      const metadata = {\n        type: 'gift-sub',\n        userId: user._id,\n        gift: JSON.stringify(gift),\n        sub: undefined,\n        gemsBlock: undefined\n      };\n      expect(oneTimePayments.getOneTimePaymentInfo).to.be.calledOnce;\n      expect(oneTimePayments.getOneTimePaymentInfo).to.be.calledWith(undefined, gift, user);\n      expect(stripe.checkout.sessions.create).to.be.calledOnce;\n      expect(stripe.checkout.sessions.create).to.be.calledWith({\n        payment_method_types: ['card'],\n        metadata,\n        line_items: [{\n          price_data: {\n            product_data: {\n              name: common.i18n.t('nMonthsSubscriptionGift', {\n                nMonths: 3\n              })\n            },\n            unit_amount: amount,\n            currency: 'usd'\n          },\n          quantity: 1\n        }],\n        mode: 'payment',\n        ...redirectUrls\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"subscription","suites":["Stripe - Checkout","createCheckoutSession"],"updatePoint":{"line":173,"column":20,"index":5755},"line":173,"code":"    it('subscription', async () => {\n      const subKey = 'basic_3mo';\n      const coupon = null;\n      sandbox.stub(subscriptions, 'checkSubData').returns(undefined);\n      const sub = common.content.subscriptionBlocks[subKey];\n      const res = await createCheckoutSession({\n        user,\n        sub,\n        coupon\n      }, stripe);\n      expect(res).to.equal(sessionId);\n      const metadata = {\n        type: 'subscription',\n        userId: user._id,\n        gift: undefined,\n        sub: JSON.stringify(sub)\n      };\n      expect(subscriptions.checkSubData).to.be.calledOnce;\n      expect(subscriptions.checkSubData).to.be.calledWith(sub, false, coupon);\n      expect(stripe.checkout.sessions.create).to.be.calledOnce;\n      expect(stripe.checkout.sessions.create).to.be.calledWith({\n        payment_method_types: ['card'],\n        metadata,\n        line_items: [{\n          price: sub.key,\n          quantity: 1 // @TODO proper copy\n\n        }],\n        mode: 'subscription',\n        ...redirectUrls\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if group does not exists","suites":["Stripe - Checkout","createCheckoutSession"],"updatePoint":{"line":205,"column":39,"index":6800},"line":205,"code":"    it('throws if group does not exists', async () => {\n      const groupId = 'invalid';\n      sandbox.stub(Group.prototype, 'getMemberCount').resolves(4);\n      const subKey = 'group_monthly';\n      const coupon = null;\n      const sub = common.content.subscriptionBlocks[subKey];\n      await expect(createCheckoutSession({\n        user,\n        sub,\n        coupon,\n        groupId\n      }, stripe)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 404,\n        name: 'NotFound',\n        message: i18n.t('groupNotFound')\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"group plan","suites":["Stripe - Checkout","createCheckoutSession"],"updatePoint":{"line":222,"column":18,"index":7328},"line":222,"code":"    it('group plan', async () => {\n      const group = generateGroup({\n        name: 'test group',\n        type: 'guild',\n        privacy: 'public',\n        leader: user._id\n      });\n      const groupId = group._id;\n      await group.save();\n      sandbox.stub(Group.prototype, 'getMemberCount').resolves(4); // Add user to group\n\n      user.guilds.push(groupId);\n      await user.save();\n      const subKey = 'group_monthly';\n      const coupon = null;\n      sandbox.stub(subscriptions, 'checkSubData').returns(undefined);\n      const sub = common.content.subscriptionBlocks[subKey];\n      const res = await createCheckoutSession({\n        user,\n        sub,\n        coupon,\n        groupId\n      }, stripe);\n      expect(res).to.equal(sessionId);\n      const metadata = {\n        type: 'subscription',\n        userId: user._id,\n        gift: undefined,\n        sub: JSON.stringify(sub),\n        groupId\n      };\n      expect(Group.prototype.getMemberCount).to.be.calledOnce;\n      expect(subscriptions.checkSubData).to.be.calledOnce;\n      expect(subscriptions.checkSubData).to.be.calledWith(sub, true, coupon);\n      expect(stripe.checkout.sessions.create).to.be.calledOnce;\n      expect(stripe.checkout.sessions.create).to.be.calledWith({\n        payment_method_types: ['card'],\n        metadata,\n        line_items: [{\n          price: sub.key,\n          quantity: 6 // @TODO proper copy\n\n        }],\n        mode: 'subscription',\n        ...redirectUrls\n      });\n    }); // no gift, sub or gem payment","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if type is invalid","suites":["Stripe - Checkout","createCheckoutSession"],"updatePoint":{"line":270,"column":33,"index":8854},"line":270,"code":"    it('throws if type is invalid', async () => {\n      await expect(createCheckoutSession({\n        user\n      }, stripe)).to.eventually.be.rejected;\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if no valid data is supplied","suites":["Stripe - Checkout","createEditCardCheckoutSession"],"updatePoint":{"line":292,"column":43,"index":9556},"line":292,"code":"    it('throws if no valid data is supplied', async () => {\n      await expect(createEditCardCheckoutSession({}, stripe)).to.eventually.be.rejected;\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if customer does not exists","suites":["Stripe - Checkout","createEditCardCheckoutSession"],"updatePoint":{"line":295,"column":42,"index":9712},"line":295,"code":"    it('throws if customer does not exists', async () => {\n      await expect(createEditCardCheckoutSession({\n        user\n      }, stripe)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: i18n.t('missingSubscription')\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if subscription does not exists","suites":["Stripe - Checkout","createEditCardCheckoutSession"],"updatePoint":{"line":304,"column":46,"index":10015},"line":304,"code":"    it('throws if subscription does not exists', async () => {\n      user.purchased.plan.customerId = customerId;\n      subscriptionsListStub.resolves({\n        data: []\n      });\n      await expect(createEditCardCheckoutSession({\n        user\n      }, stripe)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: i18n.t('missingSubscription')\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"change card for user subscription","suites":["Stripe - Checkout","createEditCardCheckoutSession"],"updatePoint":{"line":317,"column":41,"index":10430},"line":317,"code":"    it('change card for user subscription', async () => {\n      user.purchased.plan.customerId = customerId;\n      const metadata = {\n        userId: user._id,\n        type: 'edit-card-user'\n      };\n      const res = await createEditCardCheckoutSession({\n        user\n      }, stripe);\n      expect(res).to.equal(sessionId);\n      expect(subscriptionsListStub).to.be.calledOnce;\n      expect(subscriptionsListStub).to.be.calledWith({\n        customer: customerId\n      });\n      expect(stripe.checkout.sessions.create).to.be.calledOnce;\n      expect(stripe.checkout.sessions.create).to.be.calledWith({\n        mode: 'setup',\n        payment_method_types: ['card'],\n        metadata,\n        customer: customerId,\n        setup_intent_data: {\n          metadata: {\n            customer_id: customerId,\n            subscription_id: subscriptionId\n          }\n        },\n        ...redirectUrls\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if group does not exists","suites":["Stripe - Checkout","createEditCardCheckoutSession"],"updatePoint":{"line":346,"column":39,"index":11339},"line":346,"code":"    it('throws if group does not exists', async () => {\n      const groupId = 'invalid';\n      await expect(createEditCardCheckoutSession({\n        user,\n        groupId\n      }, stripe)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 404,\n        name: 'NotFound',\n        message: i18n.t('groupNotFound')\n      });\n    });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if user is not allowed to change group plan","suites":["Stripe - Checkout","createEditCardCheckoutSession","with group"],"updatePoint":{"line":370,"column":60,"index":12019},"line":370,"code":"      it('throws if user is not allowed to change group plan', async () => {\n        const anotherUser = new User();\n        anotherUser.guilds.push(groupId);\n        await anotherUser.save();\n        await expect(createEditCardCheckoutSession({\n          user: anotherUser,\n          groupId\n        }, stripe)).to.eventually.be.rejected.and.to.eql({\n          httpCode: 401,\n          name: 'NotAuthorized',\n          message: i18n.t('onlyGroupLeaderCanManageSubscription')\n        });\n      });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if customer does not exists (group)","suites":["Stripe - Checkout","createEditCardCheckoutSession","with group"],"updatePoint":{"line":383,"column":52,"index":12509},"line":383,"code":"      it('throws if customer does not exists (group)', async () => {\n        await expect(createEditCardCheckoutSession({\n          user,\n          groupId\n        }, stripe)).to.eventually.be.rejected.and.to.eql({\n          httpCode: 401,\n          name: 'NotAuthorized',\n          message: i18n.t('missingSubscription')\n        });\n      });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"throws if subscription does not exists (group)","suites":["Stripe - Checkout","createEditCardCheckoutSession","with group"],"updatePoint":{"line":393,"column":56,"index":12857},"line":393,"code":"      it('throws if subscription does not exists (group)', async () => {\n        group.purchased.plan.customerId = customerId;\n        subscriptionsListStub.resolves({\n          data: []\n        });\n        await expect(createEditCardCheckoutSession({\n          user,\n          groupId\n        }, stripe)).to.eventually.be.rejected.and.to.eql({\n          httpCode: 401,\n          name: 'NotAuthorized',\n          message: i18n.t('missingSubscription')\n        });\n      });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"change card for group plans - leader","suites":["Stripe - Checkout","createEditCardCheckoutSession","with group"],"updatePoint":{"line":407,"column":46,"index":13321},"line":407,"code":"      it('change card for group plans - leader', async () => {\n        group.purchased.plan.customerId = customerId;\n        await group.save();\n        const metadata = {\n          userId: user._id,\n          type: 'edit-card-group',\n          groupId\n        };\n        const res = await createEditCardCheckoutSession({\n          user,\n          groupId\n        }, stripe);\n        expect(res).to.equal(sessionId);\n        expect(subscriptionsListStub).to.be.calledOnce;\n        expect(subscriptionsListStub).to.be.calledWith({\n          customer: customerId\n        });\n        expect(stripe.checkout.sessions.create).to.be.calledOnce;\n        expect(stripe.checkout.sessions.create).to.be.calledWith({\n          mode: 'setup',\n          payment_method_types: ['card'],\n          metadata,\n          customer: customerId,\n          setup_intent_data: {\n            metadata: {\n              customer_id: customerId,\n              subscription_id: subscriptionId\n            }\n          },\n          ...redirectUrls\n        });\n      });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"change card for group plans - plan owner","suites":["Stripe - Checkout","createEditCardCheckoutSession","with group"],"updatePoint":{"line":439,"column":50,"index":14365},"line":439,"code":"      it('change card for group plans - plan owner', async () => {\n        const anotherUser = new User();\n        anotherUser.guilds.push(groupId);\n        await anotherUser.save();\n        group.purchased.plan.customerId = customerId;\n        group.purchased.plan.owner = anotherUser._id;\n        await group.save();\n        const metadata = {\n          userId: anotherUser._id,\n          type: 'edit-card-group',\n          groupId\n        };\n        const res = await createEditCardCheckoutSession({\n          user: anotherUser,\n          groupId\n        }, stripe);\n        expect(res).to.equal(sessionId);\n        expect(subscriptionsListStub).to.be.calledOnce;\n        expect(subscriptionsListStub).to.be.calledWith({\n          customer: customerId\n        });\n        expect(stripe.checkout.sessions.create).to.be.calledOnce;\n        expect(stripe.checkout.sessions.create).to.be.calledWith({\n          mode: 'setup',\n          payment_method_types: ['card'],\n          metadata,\n          customer: customerId,\n          setup_intent_data: {\n            metadata: {\n              customer_id: customerId,\n              subscription_id: subscriptionId\n            }\n          },\n          ...redirectUrls\n        });\n      });","file":"api/unit/libs/payments/stripe/checkout.test.js","skipped":false,"dir":"test"},{"name":"returns the gemsBlock and amount","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gemsBlock"],"updatePoint":{"line":18,"column":42,"index":830},"line":18,"code":"      it('returns the gemsBlock and amount', async () => {\n        const {\n          gemsBlock,\n          amount,\n          subscription\n        } = await getOneTimePaymentInfo('21gems', null, user);\n        expect(gemsBlock).to.equal(common.content.gems['21gems']);\n        expect(amount).to.equal(gemsBlock.price);\n        expect(amount).to.equal(499);\n        expect(subscription).to.be.null;\n        expect(subscriptions.checkSubData).to.not.be.called;\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the gemsBlock does not exist","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gemsBlock"],"updatePoint":{"line":30,"column":48,"index":1303},"line":30,"code":"      it('throws if the gemsBlock does not exist', async () => {\n        await expect(getOneTimePaymentInfo('not existant', null, user)).to.eventually.be.rejected.and.to.eql({\n          httpCode: 400,\n          name: 'BadRequest',\n          message: apiError('invalidGemsBlock')\n        });\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the user cannot receive gems","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gemsBlock"],"updatePoint":{"line":37,"column":48,"index":1604},"line":37,"code":"      it('throws if the user cannot receive gems', async () => {\n        sandbox.stub(user, 'canGetGems').resolves(false);\n        await expect(getOneTimePaymentInfo('21gems', null, user)).to.eventually.be.rejected.and.to.eql({\n          httpCode: 401,\n          name: 'NotAuthorized',\n          message: i18n.t('groupPolicyCannotGetGems')\n        });\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the receiver does not exist","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gift"],"updatePoint":{"line":47,"column":47,"index":2002},"line":47,"code":"      it('throws if the receiver does not exist', async () => {\n        const gift = {\n          type: 'gems',\n          uuid: 'invalid',\n          gems: {\n            amount: 3\n          }\n        };\n        await expect(getOneTimePaymentInfo(null, gift, user)).to.eventually.be.rejected.and.to.eql({\n          httpCode: 404,\n          name: 'NotFound',\n          message: i18n.t('userWithIDNotFound', {\n            userId: 'invalid'\n          })\n        });\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the user cannot receive gems","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gift"],"updatePoint":{"line":63,"column":48,"index":2473},"line":63,"code":"      it('throws if the user cannot receive gems', async () => {\n        const receivingUser = new User();\n        await receivingUser.save();\n        sandbox.stub(User.prototype, 'canGetGems').resolves(false);\n        const gift = {\n          type: 'gems',\n          uuid: receivingUser._id,\n          gems: {\n            amount: 2\n          }\n        };\n        await expect(getOneTimePaymentInfo(null, gift, user)).to.eventually.be.rejected.and.to.eql({\n          httpCode: 401,\n          name: 'NotAuthorized',\n          message: i18n.t('groupPolicyCannotGetGems')\n        });\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the amount of gems is <= 0","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gift"],"updatePoint":{"line":80,"column":46,"index":3062},"line":80,"code":"      it('throws if the amount of gems is <= 0', async () => {\n        const receivingUser = new User();\n        await receivingUser.save();\n        const gift = {\n          type: 'gems',\n          uuid: receivingUser._id,\n          gems: {\n            amount: 0\n          }\n        };\n        await expect(getOneTimePaymentInfo(null, gift, user)).to.eventually.be.rejected.and.to.eql({\n          httpCode: 400,\n          name: 'BadRequest',\n          message: i18n.t('badAmountOfGemsToPurchase')\n        });\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the subscription block does not exist","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gift"],"updatePoint":{"line":96,"column":57,"index":3592},"line":96,"code":"      it('throws if the subscription block does not exist', async () => {\n        const receivingUser = new User();\n        await receivingUser.save();\n        const gift = {\n          type: 'subscription',\n          uuid: receivingUser._id,\n          subscription: {\n            key: 'invalid'\n          }\n        };\n        await expect(getOneTimePaymentInfo(null, gift, user)).to.eventually.throw;\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"returns the amount (gems)","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gift"],"updatePoint":{"line":108,"column":35,"index":3981},"line":108,"code":"      it('returns the amount (gems)', async () => {\n        const receivingUser = new User();\n        await receivingUser.save();\n        const gift = {\n          type: 'gems',\n          uuid: receivingUser._id,\n          gems: {\n            amount: 4\n          }\n        };\n        expect(subscriptions.checkSubData).to.not.be.called;\n        const {\n          gemsBlock,\n          amount,\n          subscription\n        } = await getOneTimePaymentInfo(null, gift, user);\n        expect(gemsBlock).to.equal(null);\n        expect(amount).to.equal('100');\n        expect(subscription).to.be.null;\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"returns the amount (subscription)","suites":["Stripe - One Time Payments","getOneTimePaymentInfo","gift"],"updatePoint":{"line":128,"column":43,"index":4595},"line":128,"code":"      it('returns the amount (subscription)', async () => {\n        const receivingUser = new User();\n        await receivingUser.save();\n        const gift = {\n          type: 'subscription',\n          uuid: receivingUser._id,\n          subscription: {\n            key: 'basic_3mo'\n          }\n        };\n        const sub = common.content.subscriptionBlocks['basic_3mo']; // eslint-disable-line dot-notation\n\n        const {\n          gemsBlock,\n          amount,\n          subscription\n        } = await getOneTimePaymentInfo(null, gift, user);\n        expect(subscriptions.checkSubData).to.be.calledOnce;\n        expect(subscriptions.checkSubData).to.be.calledWith(sub, false, null);\n        expect(gemsBlock).to.equal(null);\n        expect(amount).to.equal('1500');\n        expect(Number(amount)).to.equal(sub.price * 100);\n        expect(subscription).to.equal(sub);\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the user does not exist","suites":["Stripe - One Time Payments","applyGemPayment"],"updatePoint":{"line":171,"column":41,"index":6024},"line":171,"code":"    it('throws if the user does not exist', async () => {\n      const metadata = {\n        userId: 'invalid'\n      };\n      const session = {\n        metadata,\n        customer: customerId\n      };\n      await expect(applyGemPayment(session)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 404,\n        name: 'NotFound',\n        message: i18n.t('userWithIDNotFound', {\n          userId: metadata.userId\n        })\n      });\n    });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the receiving user does not exist","suites":["Stripe - One Time Payments","applyGemPayment"],"updatePoint":{"line":187,"column":51,"index":6476},"line":187,"code":"    it('throws if the receiving user does not exist', async () => {\n      const metadata = {\n        userId: 'invalid'\n      };\n      const session = {\n        metadata,\n        customer: customerId\n      };\n      await expect(applyGemPayment(session)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 404,\n        name: 'NotFound',\n        message: i18n.t('userWithIDNotFound', {\n          userId: metadata.userId\n        })\n      });\n    });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"throws if the gems block does not exist","suites":["Stripe - One Time Payments","applyGemPayment"],"updatePoint":{"line":203,"column":47,"index":6924},"line":203,"code":"    it('throws if the gems block does not exist', async () => {\n      const gift = {\n        type: 'gems',\n        uuid: 'invalid',\n        gems: {\n          amount: 16\n        }\n      };\n      const metadata = {\n        userId: user._id,\n        gift: JSON.stringify(gift)\n      };\n      const session = {\n        metadata,\n        customer: customerId\n      };\n      await expect(applyGemPayment(session)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 404,\n        name: 'NotFound',\n        message: i18n.t('userWithIDNotFound', {\n          userId: 'invalid'\n        })\n      });\n    });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"buys gems","suites":["Stripe - One Time Payments","applyGemPayment","with existing user"],"updatePoint":{"line":235,"column":19,"index":7781},"line":235,"code":"      it('buys gems', async () => {\n        const metadata = {\n          userId: user._id,\n          gemsBlock: '21gems'\n        };\n        const session = {\n          metadata,\n          customer: customerId\n        };\n        await applyGemPayment(session);\n        expect(paymentBuyGemsStub).to.be.calledOnce;\n        expect(paymentBuyGemsStub).to.be.calledWith({\n          user,\n          customerId,\n          paymentMethod: 'Stripe',\n          gift: undefined,\n          gemsBlock: common.content.gems['21gems']\n        });\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"gift gems","suites":["Stripe - One Time Payments","applyGemPayment","with existing user"],"updatePoint":{"line":254,"column":19,"index":8321},"line":254,"code":"      it('gift gems', async () => {\n        const receivingUser = new User();\n        const execStub = sandbox.stub().resolves(receivingUser);\n        userFindByIdStub.withArgs(receivingUser._id).returns({\n          exec: execStub\n        });\n        const gift = {\n          type: 'gems',\n          uuid: receivingUser._id,\n          gems: {\n            amount: 16\n          }\n        };\n        sandbox.stub(JSON, 'parse').returns(gift);\n        const metadata = {\n          userId: user._id,\n          gift: JSON.stringify(gift)\n        };\n        const session = {\n          metadata,\n          customer: customerId\n        };\n        await applyGemPayment(session);\n        expect(paymentBuyGemsStub).to.be.calledOnce;\n        expect(paymentBuyGemsStub).to.be.calledWith({\n          user,\n          customerId,\n          paymentMethod: 'Gift',\n          gift,\n          gemsBlock: undefined\n        });\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"gift sub","suites":["Stripe - One Time Payments","applyGemPayment","with existing user"],"updatePoint":{"line":286,"column":18,"index":9238},"line":286,"code":"      it('gift sub', async () => {\n        const receivingUser = new User();\n        const execStub = sandbox.stub().resolves(receivingUser);\n        userFindByIdStub.withArgs(receivingUser._id).returns({\n          exec: execStub\n        });\n        const gift = {\n          type: 'subscription',\n          uuid: receivingUser._id,\n          subscription: {\n            key: subKey\n          }\n        };\n        sandbox.stub(JSON, 'parse').returns(gift);\n        const metadata = {\n          userId: user._id,\n          gift: JSON.stringify(gift)\n        };\n        const session = {\n          metadata,\n          customer: customerId\n        };\n        await applyGemPayment(session);\n        expect(paymentsCreateSubSpy).to.be.calledOnce;\n        expect(paymentsCreateSubSpy).to.be.calledWith({\n          user,\n          customerId,\n          paymentMethod: 'Gift',\n          gift,\n          gemsBlock: undefined\n        });\n      });","file":"api/unit/libs/payments/stripe/oneTimePayments.test.js","skipped":false,"dir":"test"},{"name":"does not throw if the subscription can be used","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":15,"column":54,"index":854},"line":15,"code":"    it('does not throw if the subscription can be used', async () => {\n      const sub = common.content.subscriptionBlocks['basic_3mo']; // eslint-disable-line dot-notation\n\n      const res = await checkSubData(sub);\n      expect(res).to.equal(undefined);\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws if the subscription does not exists","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":21,"column":50,"index":1114},"line":21,"code":"    it('throws if the subscription does not exists', async () => {\n      await expect(checkSubData()).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('missingSubscriptionCode')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws if the subscription can't be used","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":28,"column":49,"index":1374},"line":28,"code":"    it('throws if the subscription can\\'t be used', async () => {\n      const sub = common.content.subscriptionBlocks['group_plan_auto']; // eslint-disable-line dot-notation\n\n      await expect(checkSubData(sub, true)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('missingSubscriptionCode')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws if the subscription targets a group and an user is making the request","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":37,"column":84,"index":1787},"line":37,"code":"    it('throws if the subscription targets a group and an user is making the request', async () => {\n      const sub = common.content.subscriptionBlocks['group_monthly']; // eslint-disable-line dot-notation\n\n      await expect(checkSubData(sub, false)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('missingSubscriptionCode')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws if the subscription targets an user and a group is making the request","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":46,"column":84,"index":2199},"line":46,"code":"    it('throws if the subscription targets an user and a group is making the request', async () => {\n      const sub = common.content.subscriptionBlocks['basic_3mo']; // eslint-disable-line dot-notation\n\n      await expect(checkSubData(sub, true)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('missingSubscriptionCode')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws if the coupon is required but not passed","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":55,"column":55,"index":2577},"line":55,"code":"    it('throws if the coupon is required but not passed', async () => {\n      const sub = common.content.subscriptionBlocks['google_6mo']; // eslint-disable-line dot-notation\n\n      await expect(checkSubData(sub, false)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('couponCodeRequired')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws if the coupon is required but does not exist","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":64,"column":59,"index":2956},"line":64,"code":"    it('throws if the coupon is required but does not exist', async () => {\n      const coupon = 'not-valid';\n      const sub = common.content.subscriptionBlocks['google_6mo']; // eslint-disable-line dot-notation\n\n      await expect(checkSubData(sub, false, coupon)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('invalidCoupon')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws if the coupon is required but is invalid","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":74,"column":55,"index":3368},"line":74,"code":"    it('throws if the coupon is required but is invalid', async () => {\n      const couponModel = new Coupon();\n      couponModel.event = 'google_6mo';\n      await couponModel.save();\n      sandbox.stub(cc, 'validate').returns('invalid');\n      const sub = common.content.subscriptionBlocks['google_6mo']; // eslint-disable-line dot-notation\n\n      await expect(checkSubData(sub, false, couponModel._id)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: i18n.t('invalidCoupon')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"works if the coupon is required and valid","suites":["Stripe - Subscriptions","checkSubData"],"updatePoint":{"line":87,"column":49,"index":3916},"line":87,"code":"    it('works if the coupon is required and valid', async () => {\n      const couponModel = new Coupon();\n      couponModel.event = 'google_6mo';\n      await couponModel.save();\n      sandbox.stub(cc, 'validate').returns(couponModel._id);\n      const sub = common.content.subscriptionBlocks['google_6mo']; // eslint-disable-line dot-notation\n\n      await checkSubData(sub, false, couponModel._id);\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"subscribes a user","suites":["Stripe - Subscriptions","applySubscription"],"updatePoint":{"line":133,"column":25,"index":5363},"line":133,"code":"    it('subscribes a user', async () => {\n      await applySubscription({\n        customer: customerId,\n        subscription: subscriptionId,\n        metadata: {\n          sub: JSON.stringify(sub),\n          userId: user._id,\n          groupId: null\n        },\n        user\n      });\n      expect(stripePaymentsCreateSubSpy).to.be.calledOnce;\n      expect(stripePaymentsCreateSubSpy).to.be.calledWith({\n        user,\n        customerId,\n        subscriptionId,\n        paymentMethod: 'Stripe',\n        sub: sinon.match({ ...sub\n        }),\n        groupId: null\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"subscribes a group","suites":["Stripe - Subscriptions","applySubscription"],"updatePoint":{"line":155,"column":26,"index":5944},"line":155,"code":"    it('subscribes a group', async () => {\n      sub = common.content.subscriptionBlocks['group_monthly']; // eslint-disable-line dot-notation\n\n      await applySubscription({\n        customer: customerId,\n        subscription: subscriptionId,\n        metadata: {\n          sub: JSON.stringify(sub),\n          userId: user._id,\n          groupId\n        },\n        user\n      });\n      expect(stripePaymentsCreateSubSpy).to.be.calledOnce;\n      expect(stripePaymentsCreateSubSpy).to.be.calledWith({\n        user,\n        customerId,\n        subscriptionId,\n        paymentMethod: 'Stripe',\n        sub: sinon.match({ ...sub\n        }),\n        groupId\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"subscribes a group with multiple users","suites":["Stripe - Subscriptions","applySubscription"],"updatePoint":{"line":179,"column":46,"index":6634},"line":179,"code":"    it('subscribes a group with multiple users', async () => {\n      const user2 = new User();\n      user2.guilds.push(groupId);\n      await user2.save();\n      const execStub2 = sandbox.stub().resolves(user);\n      userFindByIdStub.withArgs(user2._id).returns({\n        exec: execStub2\n      });\n      group.memberCount = 2;\n      await group.save();\n      sub = common.content.subscriptionBlocks['group_monthly']; // eslint-disable-line dot-notation\n\n      await applySubscription({\n        customer: customerId,\n        subscription: subscriptionId,\n        metadata: {\n          sub: JSON.stringify(sub),\n          userId: user._id,\n          groupId\n        },\n        user\n      });\n      expect(stripePaymentsCreateSubSpy).to.be.calledOnce;\n      expect(stripePaymentsCreateSubSpy).to.be.calledWith({\n        user,\n        customerId,\n        subscriptionId,\n        paymentMethod: 'Stripe',\n        sub: sinon.match({ ...sub\n        }),\n        groupId\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"updates the plan quantity based on the number of group members","suites":["Stripe - Subscriptions","handlePaymentMethodChange"],"updatePoint":{"line":215,"column":70,"index":7732},"line":215,"code":"    it('updates the plan quantity based on the number of group members', async () => {\n      const stripeIntentRetrieveStub = sandbox.stub(stripe.setupIntents, 'retrieve').resolves({\n        payment_method: 1,\n        metadata: {\n          subscription_id: 2\n        }\n      });\n      const stripeSubUpdateStub = sandbox.stub(stripe.subscriptions, 'update');\n      await handlePaymentMethodChange({}, stripe);\n      expect(stripeIntentRetrieveStub).to.be.calledOnce;\n      expect(stripeSubUpdateStub).to.be.calledOnce;\n      expect(stripeSubUpdateStub).to.be.calledWith(2, {\n        default_payment_method: 1\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"updates the plan quantity based on the number of group members","suites":["Stripe - Subscriptions","chargeForAdditionalGroupMember"],"updatePoint":{"line":252,"column":70,"index":9096},"line":252,"code":"    it('updates the plan quantity based on the number of group members', async () => {\n      group.memberCount = 4;\n      const newQuantity = group.memberCount + plan.quantity - 1;\n      await chargeForAdditionalGroupMember(group, stripe);\n      expect(stripeUpdateSubStub).to.be.calledWithMatch(group.purchased.plan.subscriptionId, sinon.match({\n        plan: group.purchased.plan.planId,\n        quantity: newQuantity\n      }));\n      expect(group.purchased.plan.quantity).to.equal(newQuantity);\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws an error if there is no customer id","suites":["Stripe - Subscriptions","cancelSubscription"],"updatePoint":{"line":286,"column":50,"index":10294},"line":286,"code":"    it('throws an error if there is no customer id', async () => {\n      user.purchased.plan.customerId = undefined;\n      await expect(stripePayments.cancelSubscription({\n        user,\n        groupId: undefined\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: i18n.t('missingSubscription')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the group is not found","suites":["Stripe - Subscriptions","cancelSubscription"],"updatePoint":{"line":297,"column":49,"index":10674},"line":297,"code":"    it('throws an error if the group is not found', async () => {\n      await expect(stripePayments.cancelSubscription({\n        user,\n        groupId: 'fake-group'\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 404,\n        name: 'NotFound',\n        message: i18n.t('groupNotFound')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws an error if user is not the group leader","suites":["Stripe - Subscriptions","cancelSubscription"],"updatePoint":{"line":307,"column":55,"index":11002},"line":307,"code":"    it('throws an error if user is not the group leader', async () => {\n      const nonLeader = new User();\n      nonLeader.guilds.push(groupId);\n      await nonLeader.save();\n      await expect(stripePayments.cancelSubscription({\n        user: nonLeader,\n        groupId\n      })).to.eventually.be.rejected.and.to.eql({\n        httpCode: 401,\n        name: 'NotAuthorized',\n        message: i18n.t('onlyGroupLeaderCanManageSubscription')\n      });\n    });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"cancels a user subscription","suites":["Stripe - Subscriptions","cancelSubscription","success"],"updatePoint":{"line":346,"column":37,"index":12398},"line":346,"code":"      it('cancels a user subscription', async () => {\n        await stripePayments.cancelSubscription({\n          user,\n          groupId: undefined\n        }, stripe);\n        expect(stripeDeleteCustomerStub).to.be.calledOnce;\n        expect(stripeDeleteCustomerStub).to.be.calledWith(user.purchased.plan.customerId);\n        expect(stripeRetrieveStub).to.be.calledOnce;\n        expect(stripeRetrieveStub).to.be.calledWith(user.purchased.plan.customerId);\n        expect(paymentsCancelSubStub).to.be.calledOnce;\n        expect(paymentsCancelSubStub).to.be.calledWith({\n          user,\n          groupId: undefined,\n          nextBill: currentPeriodEndTimeStamp * 1000,\n          // timestamp in seconds\n          paymentMethod: 'Stripe',\n          cancellationReason: undefined\n        });\n      });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"cancels a group subscription","suites":["Stripe - Subscriptions","cancelSubscription","success"],"updatePoint":{"line":365,"column":38,"index":13200},"line":365,"code":"      it('cancels a group subscription', async () => {\n        await stripePayments.cancelSubscription({\n          user,\n          groupId\n        }, stripe);\n        expect(stripeDeleteCustomerStub).to.be.calledOnce;\n        expect(stripeDeleteCustomerStub).to.be.calledWith(group.purchased.plan.customerId);\n        expect(stripeRetrieveStub).to.be.calledOnce;\n        expect(stripeRetrieveStub).to.be.calledWith(user.purchased.plan.customerId);\n        expect(paymentsCancelSubStub).to.be.calledOnce;\n        expect(paymentsCancelSubStub).to.be.calledWith({\n          user,\n          groupId,\n          nextBill: currentPeriodEndTimeStamp * 1000,\n          // timestamp in seconds\n          paymentMethod: 'Stripe',\n          cancellationReason: undefined\n        });\n      });","file":"api/unit/libs/payments/stripe/subscriptions.test.js","skipped":false,"dir":"test"},{"name":"throws if the event can't be validated","suites":["Stripe - Webhooks","all events"],"updatePoint":{"line":32,"column":47,"index":1359},"line":32,"code":"    it('throws if the event can\\'t be validated', async () => {\n      const err = new Error('fail');\n      constructEventStub.throws(err);\n      await expect(stripePayments.handleWebhooks({\n        body: event,\n        headers\n      }, stripe)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: `Webhook Error: ${err.message}`\n      });\n      expect(logger.error).to.have.been.calledOnce;\n      const calledWith = logger.error.getCall(0).args;\n      expect(calledWith[0].message).to.equal('Error verifying Stripe webhook');\n      expect(calledWith[1]).to.eql({\n        err\n      });\n    });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"logs an error if an unsupported webhook event is passed","suites":["Stripe - Webhooks","all events"],"updatePoint":{"line":50,"column":63,"index":2023},"line":50,"code":"    it('logs an error if an unsupported webhook event is passed', async () => {\n      event.type = 'account.updated';\n      await expect(stripePayments.handleWebhooks({\n        body,\n        headers\n      }, stripe)).to.eventually.be.rejected.and.to.eql({\n        httpCode: 400,\n        name: 'BadRequest',\n        message: `Missing handler for Stripe webhook ${event.type}`\n      });\n      expect(logger.error).to.have.been.calledOnce;\n      const calledWith = logger.error.getCall(0).args;\n      expect(calledWith[0].message).to.equal('Error handling Stripe webhook');\n      expect(calledWith[1].event).to.eql(event);\n      expect(calledWith[1].err.message).to.eql(`Missing handler for Stripe webhook ${event.type}`);\n    });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"retrieves and validates the event from Stripe","suites":["Stripe - Webhooks","all events"],"updatePoint":{"line":66,"column":53,"index":2741},"line":66,"code":"    it('retrieves and validates the event from Stripe', async () => {\n      await stripePayments.handleWebhooks({\n        body,\n        headers\n      }, stripe);\n      expect(stripe.webhooks.constructEvent).to.have.been.calledOnce;\n      expect(stripe.webhooks.constructEvent).to.have.been.calledWith(body, undefined, endpointSecret);\n    });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not do anything if event.request is not null (subscription cancelled manually)","suites":["Stripe - Webhooks","customer.subscription.deleted"],"updatePoint":{"line":90,"column":91,"index":3629},"line":90,"code":"    it('does not do anything if event.request is not null (subscription cancelled manually)', async () => {\n      constructEventStub.returns({\n        id: 123,\n        type: eventType,\n        request: {\n          id: 123\n        }\n      });\n      await stripePayments.handleWebhooks({\n        body,\n        headers\n      }, stripe);\n      expect(stripe.webhooks.constructEvent).to.have.been.calledOnce;\n      expect(stripe.customers.del).to.not.have.been.called;\n      expect(payments.cancelSubscription).to.not.have.been.called;\n    });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the user is not found","suites":["Stripe - Webhooks","customer.subscription.deleted","user subscription"],"updatePoint":{"line":107,"column":50,"index":4169},"line":107,"code":"      it('throws an error if the user is not found', async () => {\n        const customerId = 456;\n        constructEventStub.returns({\n          id: 123,\n          type: eventType,\n          data: {\n            object: {\n              plan: {\n                id: 'basic_earned'\n              },\n              customer: customerId\n            }\n          },\n          request: {\n            id: null\n          }\n        });\n        await expect(stripePayments.handleWebhooks({\n          body,\n          headers\n        }, stripe)).to.eventually.be.rejectedWith({\n          message: i18n.t('userNotFound'),\n          httpCode: 404,\n          name: 'NotFound'\n        });\n        expect(stripe.customers.del).to.not.have.been.called;\n        expect(payments.cancelSubscription).to.not.have.been.called;\n      });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"deletes the customer on Stripe and calls payments.cancelSubscription","suites":["Stripe - Webhooks","customer.subscription.deleted","user subscription"],"updatePoint":{"line":135,"column":78,"index":5008},"line":135,"code":"      it('deletes the customer on Stripe and calls payments.cancelSubscription', async () => {\n        const customerId = '456';\n        const subscriber = new User();\n        subscriber.purchased.plan.customerId = customerId;\n        subscriber.purchased.plan.paymentMethod = 'Stripe';\n        await subscriber.save();\n        constructEventStub.returns({\n          id: 123,\n          type: eventType,\n          data: {\n            object: {\n              plan: {\n                id: 'basic_earned'\n              },\n              customer: customerId\n            }\n          },\n          request: {\n            id: null\n          }\n        });\n        await stripePayments.handleWebhooks({\n          body,\n          headers\n        }, stripe);\n        expect(stripe.customers.del).to.have.been.calledOnce;\n        expect(stripe.customers.del).to.have.been.calledWith(customerId);\n        expect(payments.cancelSubscription).to.have.been.calledOnce;\n        const cancelSubscriptionOpts = payments.cancelSubscription.lastCall.args[0];\n        expect(cancelSubscriptionOpts.user._id).to.equal(subscriber._id);\n        expect(cancelSubscriptionOpts.paymentMethod).to.equal('Stripe');\n        expect(Math.round(moment(cancelSubscriptionOpts.nextBill).diff(new Date(), 'days', true))).to.equal(3);\n        expect(cancelSubscriptionOpts.groupId).to.be.undefined;\n      });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the group is not found","suites":["Stripe - Webhooks","customer.subscription.deleted","group plan subscription"],"updatePoint":{"line":171,"column":51,"index":6405},"line":171,"code":"      it('throws an error if the group is not found', async () => {\n        const customerId = 456;\n        constructEventStub.returns({\n          id: 123,\n          type: eventType,\n          data: {\n            object: {\n              plan: {\n                id: 'group_monthly'\n              },\n              customer: customerId\n            }\n          },\n          request: {\n            id: null\n          }\n        });\n        await expect(stripePayments.handleWebhooks({\n          body,\n          headers\n        }, stripe)).to.eventually.be.rejectedWith({\n          message: i18n.t('groupNotFound'),\n          httpCode: 404,\n          name: 'NotFound'\n        });\n        expect(stripe.customers.del).to.not.have.been.called;\n        expect(payments.cancelSubscription).to.not.have.been.called;\n      });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the group leader is not found","suites":["Stripe - Webhooks","customer.subscription.deleted","group plan subscription"],"updatePoint":{"line":199,"column":58,"index":7226},"line":199,"code":"      it('throws an error if the group leader is not found', async () => {\n        const customerId = 456;\n        const subscriber = generateGroup({\n          name: 'test group',\n          type: 'guild',\n          privacy: 'public',\n          leader: uuid()\n        });\n        subscriber.purchased.plan.customerId = customerId;\n        subscriber.purchased.plan.paymentMethod = 'Stripe';\n        await subscriber.save();\n        constructEventStub.returns({\n          id: 123,\n          type: eventType,\n          data: {\n            object: {\n              plan: {\n                id: 'group_monthly'\n              },\n              customer: customerId\n            }\n          },\n          request: {\n            id: null\n          }\n        });\n        await expect(stripePayments.handleWebhooks({\n          body,\n          headers\n        }, stripe)).to.eventually.be.rejectedWith({\n          message: i18n.t('userNotFound'),\n          httpCode: 404,\n          name: 'NotFound'\n        });\n        expect(stripe.customers.del).to.not.have.been.called;\n        expect(payments.cancelSubscription).to.not.have.been.called;\n      });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"deletes the customer on Stripe and calls payments.cancelSubscription","suites":["Stripe - Webhooks","customer.subscription.deleted","group plan subscription"],"updatePoint":{"line":236,"column":78,"index":8382},"line":236,"code":"      it('deletes the customer on Stripe and calls payments.cancelSubscription', async () => {\n        const customerId = '456';\n        const leader = new User();\n        await leader.save();\n        const subscriber = generateGroup({\n          name: 'test group',\n          type: 'guild',\n          privacy: 'public',\n          leader: leader._id\n        });\n        subscriber.purchased.plan.customerId = customerId;\n        subscriber.purchased.plan.paymentMethod = 'Stripe';\n        await subscriber.save();\n        constructEventStub.returns({\n          id: 123,\n          type: eventType,\n          data: {\n            object: {\n              plan: {\n                id: 'group_monthly'\n              },\n              customer: customerId\n            }\n          },\n          request: {\n            id: null\n          }\n        });\n        await stripePayments.handleWebhooks({\n          body,\n          headers\n        }, stripe);\n        expect(stripe.customers.del).to.have.been.calledOnce;\n        expect(stripe.customers.del).to.have.been.calledWith(customerId);\n        expect(payments.cancelSubscription).to.have.been.calledOnce;\n        const cancelSubscriptionOpts = payments.cancelSubscription.lastCall.args[0];\n        expect(cancelSubscriptionOpts.user._id).to.equal(leader._id);\n        expect(cancelSubscriptionOpts.paymentMethod).to.equal('Stripe');\n        expect(Math.round(moment(cancelSubscriptionOpts.nextBill).diff(new Date(), 'days', true))).to.equal(3);\n        expect(cancelSubscriptionOpts.groupId).to.equal(subscriber._id);\n      });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"handles changing an user sub","suites":["Stripe - Webhooks","checkout.session.completed"],"updatePoint":{"line":298,"column":36,"index":10583},"line":298,"code":"    it('handles changing an user sub', async () => {\n      session.metadata.type = 'edit-card-user';\n      await stripePayments.handleWebhooks({\n        body,\n        headers\n      }, stripe);\n      expect(stripe.webhooks.constructEvent).to.have.been.calledOnce;\n      expect(subscriptions.handlePaymentMethodChange).to.have.been.calledOnce;\n      expect(subscriptions.handlePaymentMethodChange).to.have.been.calledWith(session);\n    });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"handles changing a group sub","suites":["Stripe - Webhooks","checkout.session.completed"],"updatePoint":{"line":308,"column":36,"index":11021},"line":308,"code":"    it('handles changing a group sub', async () => {\n      session.metadata.type = 'edit-card-group';\n      await stripePayments.handleWebhooks({\n        body,\n        headers\n      }, stripe);\n      expect(stripe.webhooks.constructEvent).to.have.been.calledOnce;\n      expect(subscriptions.handlePaymentMethodChange).to.have.been.calledOnce;\n      expect(subscriptions.handlePaymentMethodChange).to.have.been.calledWith(session);\n    });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"applies a subscription","suites":["Stripe - Webhooks","checkout.session.completed"],"updatePoint":{"line":318,"column":30,"index":11454},"line":318,"code":"    it('applies a subscription', async () => {\n      session.metadata.type = 'subscription';\n      await stripePayments.handleWebhooks({\n        body,\n        headers\n      }, stripe);\n      expect(stripe.webhooks.constructEvent).to.have.been.calledOnce;\n      expect(subscriptions.applySubscription).to.have.been.calledOnce;\n      expect(subscriptions.applySubscription).to.have.been.calledWith(session);\n    });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"handles a one time payment","suites":["Stripe - Webhooks","checkout.session.completed"],"updatePoint":{"line":328,"column":34,"index":11872},"line":328,"code":"    it('handles a one time payment', async () => {\n      session.metadata.type = 'something else';\n      await stripePayments.handleWebhooks({\n        body,\n        headers\n      }, stripe);\n      expect(stripe.webhooks.constructEvent).to.have.been.calledOnce;\n      expect(oneTimePayments.applyGemPayment).to.have.been.calledOnce;\n      expect(oneTimePayments.applyGemPayment).to.have.been.calledWith(session);\n    });","file":"api/unit/libs/payments/stripe/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not modify history if all entries are more recent than cutoff (free users)","suites":["preenHistory"],"updatePoint":{"line":16,"column":85,"index":632},"line":16,"code":"  it('does not modify history if all entries are more recent than cutoff (free users)', () => {\n    const h = generateHistory(60);\n    expect(preenHistory(_.cloneDeep(h), false, 0)).to.eql(h);\n  });","file":"api/unit/libs/preening.test.js","skipped":false,"dir":"test"},{"name":"does not modify history if all entries are more recent than cutoff (subscribers)","suites":["preenHistory"],"updatePoint":{"line":20,"column":86,"index":832},"line":20,"code":"  it('does not modify history if all entries are more recent than cutoff (subscribers)', () => {\n    const h = generateHistory(365);\n    expect(preenHistory(_.cloneDeep(h), true, 0)).to.eql(h);\n  });","file":"api/unit/libs/preening.test.js","skipped":false,"dir":"test"},{"name":"does aggregate data in monthly entries before cutoff (free users)","suites":["preenHistory"],"updatePoint":{"line":24,"column":71,"index":1017},"line":24,"code":"  it('does aggregate data in monthly entries before cutoff (free users)', () => {\n    const h = generateHistory(81); // Jumps to July\n\n    const preened = preenHistory(_.cloneDeep(h), false, 0);\n    expect(preened.length).to.eql(62); // Keeps 60 days + 2 entries per august and july\n  });","file":"api/unit/libs/preening.test.js","skipped":false,"dir":"test"},{"name":"does aggregate data in monthly entries before cutoff (subscribers)","suites":["preenHistory"],"updatePoint":{"line":30,"column":72,"index":1307},"line":30,"code":"  it('does aggregate data in monthly entries before cutoff (subscribers)', () => {\n    const h = generateHistory(396); // Jumps to September 2012\n\n    const preened = preenHistory(_.cloneDeep(h), true, 0);\n    expect(preened.length).to.eql(367); // Keeps 365 days + 2 entries per october and september\n  });","file":"api/unit/libs/preening.test.js","skipped":false,"dir":"test"},{"name":"does aggregate data in monthly and yearly entries before cutoff (free users)","suites":["preenHistory"],"updatePoint":{"line":36,"column":82,"index":1625},"line":36,"code":"  it('does aggregate data in monthly and yearly entries before cutoff (free users)', () => {\n    const h = generateHistory(731); // Jumps to October 21 2012\n\n    const preened = preenHistory(_.cloneDeep(h), false, 0); // Keeps 60 days + 11 montly entries and 2 yearly entry for 2011 and 2012\n\n    expect(preened.length).to.eql(73);\n  });","file":"api/unit/libs/preening.test.js","skipped":false,"dir":"test"},{"name":"does aggregate data in monthly and yearly entries before cutoff (subscribers)","suites":["preenHistory"],"updatePoint":{"line":43,"column":83,"index":1964},"line":43,"code":"  it('does aggregate data in monthly and yearly entries before cutoff (subscribers)', () => {\n    const h = generateHistory(1031); // Jumps to October 21 2012\n\n    const preened = preenHistory(_.cloneDeep(h), true, 0); // Keeps 365 days + 13 montly entries and 2 yearly entries for 2011 and 2010\n\n    expect(preened.length).to.eql(380);\n  });","file":"api/unit/libs/preening.test.js","skipped":false,"dir":"test"},{"name":"correctly aggregates values","suites":["preenHistory"],"updatePoint":{"line":50,"column":33,"index":2257},"line":50,"code":"  it('correctly aggregates values', () => {\n    const h = generateHistory(63); // Compress last 3 days\n\n    const preened = preenHistory(_.cloneDeep(h), false, 0);\n    expect(preened[0].value).to.eql((61 + 62 + 63) / 3);\n  });","file":"api/unit/libs/preening.test.js","skipped":false,"dir":"test"},{"name":"sets up nconf","suites":["setupNconf"],"updatePoint":{"line":13,"column":19,"index":388},"line":13,"code":"  it('sets up nconf', () => {\n    setupNconf();\n    expect(nconf.argv).to.be.calledOnce;\n    expect(nconf.env).to.be.calledOnce;\n    expect(nconf.file).to.be.calledOnce;\n    const regexString = `\\\\${path.sep}config.json$`;\n    expect(nconf.file).to.be.calledWithMatch('user', new RegExp(regexString));\n  });","file":"api/unit/libs/setupNconf.test.js","skipped":false,"dir":"test"},{"name":"sets IS_PROD variable","suites":["setupNconf"],"updatePoint":{"line":21,"column":27,"index":704},"line":21,"code":"  it('sets IS_PROD variable', () => {\n    setupNconf();\n    expect(nconf.get('IS_PROD')).to.exist;\n  });","file":"api/unit/libs/setupNconf.test.js","skipped":false,"dir":"test"},{"name":"sets IS_DEV variable","suites":["setupNconf"],"updatePoint":{"line":25,"column":26,"index":808},"line":25,"code":"  it('sets IS_DEV variable', () => {\n    setupNconf();\n    expect(nconf.get('IS_DEV')).to.exist;\n  });","file":"api/unit/libs/setupNconf.test.js","skipped":false,"dir":"test"},{"name":"allows a custom config.json file to be passed in","suites":["setupNconf"],"updatePoint":{"line":29,"column":54,"index":939},"line":29,"code":"  it('allows a custom config.json file to be passed in', () => {\n    setupNconf('customfile.json');\n    expect(nconf.file).to.be.calledOnce;\n    expect(nconf.file).to.be.calledWithMatch('user', 'customfile.json');\n  });","file":"api/unit/libs/setupNconf.test.js","skipped":false,"dir":"test"},{"name":"check all banned words are matched","suites":["stringUtils","getMatchesByWordArray"],"updatePoint":{"line":5,"column":42,"index":275},"line":5,"code":"    it('check all banned words are matched', async () => {\n      const message = bannedWords.join(',').replace(/\\\\/g, '');\n      const matches = getMatchesByWordArray(message, bannedWords);\n      expect(matches.length).to.equal(bannedWords.length);\n    });","file":"api/unit/libs/stringUtils.test.js","skipped":false,"dir":"test"},{"name":"doesn't flag names with accented characters","suites":["stringUtils","getMatchesByWordArray"],"updatePoint":{"line":10,"column":52,"index":542},"line":10,"code":"    it('doesn\\'t flag names with accented characters', () => {\n      const name = 'TESTPLACEHOLDERSWEARWORDHEREé';\n      const matches = getMatchesByWordArray(name, bannedWords);\n      expect(matches.length).to.equal(0);\n    });","file":"api/unit/libs/stringUtils.test.js","skipped":false,"dir":"test"},{"name":"creates a new WebhookSender object","suites":["webhooks","WebhookSender"],"updatePoint":{"line":60,"column":42,"index":1706},"line":60,"code":"    it('creates a new WebhookSender object', () => {\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      expect(sendWebhook.type).to.equal('custom');\n      expect(sendWebhook).to.respondTo('send');\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"provides default function for data transformation","suites":["webhooks","WebhookSender"],"updatePoint":{"line":67,"column":57,"index":1960},"line":67,"code":"    it('provides default function for data transformation', () => {\n      sandbox.spy(WebhookSender, 'defaultTransformData');\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'custom'\n      }];\n      sendWebhook.send(user, body);\n      expect(WebhookSender.defaultTransformData).to.be.calledOnce;\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch('http://custom-url.com', {\n        json: body\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"adds default data (user and webhookType) to the body","suites":["webhooks","WebhookSender"],"updatePoint":{"line":88,"column":60,"index":2619},"line":88,"code":"    it('adds default data (user and webhookType) to the body', () => {\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      sandbox.spy(sendWebhook, 'attachDefaultData');\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'custom'\n      }];\n      sendWebhook.send(user, body);\n      expect(sendWebhook.attachDefaultData).to.be.calledOnce;\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch('http://custom-url.com', {\n        json: body\n      });\n      expect(body).to.eql({\n        foo: 'bar',\n        user: {\n          _id: user._id\n        },\n        webhookType: 'custom'\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"can pass in a data transformation function","suites":["webhooks","WebhookSender"],"updatePoint":{"line":116,"column":50,"index":3397},"line":116,"code":"    it('can pass in a data transformation function', () => {\n      sandbox.spy(WebhookSender, 'defaultTransformData');\n      const sendWebhook = new WebhookSender({\n        type: 'custom',\n\n        transformData(data) {\n          const dataToSend = {\n            baz: 'biz',\n            ...data\n          };\n          return dataToSend;\n        }\n\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'custom'\n      }];\n      sendWebhook.send(user, body);\n      expect(WebhookSender.defaultTransformData).to.not.be.called;\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch('http://custom-url.com', {\n        json: {\n          foo: 'bar',\n          baz: 'biz'\n        }\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"provides a default filter function","suites":["webhooks","WebhookSender"],"updatePoint":{"line":149,"column":42,"index":4248},"line":149,"code":"    it('provides a default filter function', () => {\n      sandbox.spy(WebhookSender, 'defaultWebhookFilter');\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'custom'\n      }];\n      sendWebhook.send(user, body);\n      expect(WebhookSender.defaultWebhookFilter).to.be.calledOnce;\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"can pass in a webhook filter function","suites":["webhooks","WebhookSender"],"updatePoint":{"line":166,"column":45,"index":4750},"line":166,"code":"    it('can pass in a webhook filter function', () => {\n      sandbox.spy(WebhookSender, 'defaultWebhookFilter');\n      const sendWebhook = new WebhookSender({\n        type: 'custom',\n\n        webhookFilter(hook) {\n          return hook.url !== 'http://custom-url.com';\n        }\n\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'custom'\n      }];\n      sendWebhook.send(user, body);\n      expect(WebhookSender.defaultWebhookFilter).to.not.be.called;\n      expect(got.post).to.not.be.called;\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"can pass in a webhook filter function that filters on data","suites":["webhooks","WebhookSender"],"updatePoint":{"line":189,"column":66,"index":5412},"line":189,"code":"    it('can pass in a webhook filter function that filters on data', () => {\n      sandbox.spy(WebhookSender, 'defaultWebhookFilter');\n      const sendWebhook = new WebhookSender({\n        type: 'custom',\n\n        webhookFilter(hook, data) {\n          return hook.options.foo === data.foo;\n        }\n\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'custom',\n        options: {\n          foo: 'bar'\n        }\n      }, {\n        id: 'other-custom-webhook',\n        url: 'http://other-custom-url.com',\n        enabled: true,\n        type: 'custom',\n        options: {\n          foo: 'foo'\n        }\n      }];\n      sendWebhook.send(user, body);\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch('http://custom-url.com');\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"ignores disabled webhooks","suites":["webhooks","WebhookSender"],"updatePoint":{"line":223,"column":33,"index":6283},"line":223,"code":"    it('ignores disabled webhooks', () => {\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: false,\n        type: 'custom'\n      }];\n      sendWebhook.send(user, body);\n      expect(got.post).to.not.be.called;\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"ignores webhooks with invalid urls","suites":["webhooks","WebhookSender"],"updatePoint":{"line":239,"column":42,"index":6699},"line":239,"code":"    it('ignores webhooks with invalid urls', () => {\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'httxp://custom-url!!!',\n        enabled: true,\n        type: 'custom'\n      }];\n      sendWebhook.send(user, body);\n      expect(got.post).to.not.be.called;\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"ignores webhooks of other types","suites":["webhooks","WebhookSender"],"updatePoint":{"line":255,"column":39,"index":7111},"line":255,"code":"    it('ignores webhooks of other types', () => {\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'custom'\n      }, {\n        id: 'other-webhook',\n        url: 'http://other-url.com',\n        enabled: true,\n        type: 'other'\n      }];\n      sendWebhook.send(user, body);\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch('http://custom-url.com', {\n        json: body\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends every type of activity to global webhooks","suites":["webhooks","WebhookSender"],"updatePoint":{"line":279,"column":55,"index":7762},"line":279,"code":"    it('sends every type of activity to global webhooks', () => {\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'global-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'globalActivity'\n      }];\n      sendWebhook.send(user, body);\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch('http://custom-url.com', {\n        json: body\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends multiple webhooks of the same type","suites":["webhooks","WebhookSender"],"updatePoint":{"line":298,"column":48,"index":8292},"line":298,"code":"    it('sends multiple webhooks of the same type', () => {\n      const sendWebhook = new WebhookSender({\n        type: 'custom'\n      });\n      const body = {\n        foo: 'bar'\n      };\n      user.webhooks = [{\n        id: 'custom-webhook',\n        url: 'http://custom-url.com',\n        enabled: true,\n        type: 'custom'\n      }, {\n        id: 'other-custom-webhook',\n        url: 'http://other-url.com',\n        enabled: true,\n        type: 'custom'\n      }];\n      sendWebhook.send(user, body);\n      expect(got.post).to.be.calledTwice;\n      expect(got.post).to.be.calledWithMatch('http://custom-url.com', {\n        json: body\n      });\n      expect(got.post).to.be.calledWithMatch('http://other-url.com', {\n        json: body\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not increase failures counter if request is successfull","suites":["webhooks","WebhookSender","failures"],"updatePoint":{"line":342,"column":70,"index":9622},"line":342,"code":"      it('does not increase failures counter if request is successfull', async () => {\n        sandbox.restore();\n        sandbox.stub(got, 'post').returns(Promise.resolve());\n        const body = {};\n        sendWebhook.send(user, body);\n        expect(got.post).to.be.calledOnce;\n        expect(got.post).to.be.calledWithMatch('http://custom-url.com', {\n          json: body\n        });\n        await sleep(0.1);\n        user = await User.findById(user._id).exec();\n        expect(user.webhooks[0].failures).to.equal(0);\n        expect(user.webhooks[0].lastFailureAt).to.equal(undefined);\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"records failures","suites":["webhooks","WebhookSender","failures"],"updatePoint":{"line":356,"column":26,"index":10179},"line":356,"code":"      it('records failures', async () => {\n        sinon.stub(logger, 'error');\n        const body = {};\n        sendWebhook.send(user, body);\n        expect(got.post).to.be.calledOnce;\n        expect(got.post).to.be.calledWithMatch('http://custom-url.com', {\n          json: body\n        });\n        await sleep(0.1);\n        user = await User.findById(user._id).exec();\n        expect(user.webhooks[0].failures).to.equal(1);\n        expect(Date.now() - user.webhooks[0].lastFailureAt.getTime() < 10000).to.be.true;\n        expect(logger.error).to.be.calledOnce;\n        logger.error.restore();\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"disables a webhook after 10 failures","suites":["webhooks","WebhookSender","failures"],"updatePoint":{"line":371,"column":46,"index":10805},"line":371,"code":"      it('disables a webhook after 10 failures', async () => {\n        const times = 10;\n\n        for (let i = 0; i < times; i += 1) {\n          sendWebhook.send(user, {});\n          await sleep(0.1); // eslint-disable-line no-await-in-loop\n\n          user = await User.findById(user._id).exec(); // eslint-disable-line no-await-in-loop\n        }\n\n        expect(got.post).to.be.callCount(10);\n        expect(got.post).to.be.calledWithMatch('http://custom-url.com');\n        await sleep(0.1);\n        user = await User.findById(user._id).exec();\n        expect(user.webhooks[0].enabled).to.equal(false);\n        expect(user.webhooks[0].failures).to.equal(0);\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"resets failures after a month ","suites":["webhooks","WebhookSender","failures"],"updatePoint":{"line":388,"column":40,"index":11468},"line":388,"code":"      it('resets failures after a month ', async () => {\n        const oneMonthAgo = moment().subtract(1, 'months').subtract(1, 'days').toDate();\n        user.webhooks[0].lastFailureAt = oneMonthAgo;\n        user.webhooks[0].failures = 9;\n        await user.save();\n        sendWebhook.send(user, []);\n        expect(got.post).to.be.calledOnce;\n        expect(got.post).to.be.calledWithMatch('http://custom-url.com');\n        await sleep(0.1);\n        user = await User.findById(user._id).exec();\n        expect(user.webhooks[0].failures).to.equal(1); // Check that the stored date is whitin 10s from now\n\n        expect(Date.now() - user.webhooks[0].lastFailureAt.getTime() < 10000).to.be.true;\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends task and stats data","suites":["webhooks","taskScoredWebhook"],"updatePoint":{"line":439,"column":33,"index":12880},"line":439,"code":"    it('sends task and stats data', () => {\n      taskScoredWebhook.send(user, data);\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch(webhooks[0].url, {\n        json: {\n          type: 'scored',\n          webhookType: 'taskActivity',\n          user: {\n            _id: user._id,\n            _tmp: {\n              foo: 'bar'\n            },\n            stats: {\n              lvl: 5,\n              int: 10,\n              str: 5,\n              exp: 423,\n              toNextLevel: 40,\n              maxHealth: 50,\n              maxMP: 103\n            }\n          },\n          task: {\n            text: 'text'\n          },\n          direction: 'up',\n          delta: 176\n        }\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends task and stats data to globalActivity webhookd","suites":["webhooks","taskScoredWebhook"],"updatePoint":{"line":469,"column":60,"index":13640},"line":469,"code":"    it('sends task and stats data to globalActivity webhookd', () => {\n      user.webhooks = [{\n        id: 'globalActivity',\n        url: 'http://global-activity.com',\n        enabled: true,\n        type: 'globalActivity'\n      }];\n      taskScoredWebhook.send(user, data);\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch('http://global-activity.com', {\n        json: {\n          type: 'scored',\n          webhookType: 'taskActivity',\n          user: {\n            _id: user._id,\n            _tmp: {\n              foo: 'bar'\n            },\n            stats: {\n              lvl: 5,\n              int: 10,\n              str: 5,\n              exp: 423,\n              toNextLevel: 40,\n              maxHealth: 50,\n              maxMP: 103\n            }\n          },\n          task: {\n            text: 'text'\n          },\n          direction: 'up',\n          delta: 176\n        }\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not send task scored data if scored option is not true","suites":["webhooks","taskScoredWebhook"],"updatePoint":{"line":505,"column":67,"index":14582},"line":505,"code":"    it('does not send task scored data if scored option is not true', () => {\n      webhooks[0].options.scored = false;\n      taskScoredWebhook.send(user, data);\n      expect(got.post).to.not.be.called;\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends  tasks","suites":["webhooks","taskActivityWebhook"],"updatePoint":{"line":521,"column":29,"index":14977},"line":521,"code":"      it(`sends ${type} tasks`, () => {\n        data.type = type;\n        taskActivityWebhook.send(user, data);\n        expect(got.post).to.be.calledOnce;\n        expect(got.post).to.be.calledWithMatch(webhooks[0].url, {\n          json: {\n            type,\n            webhookType: 'taskActivity',\n            user: {\n              _id: user._id\n            },\n            task: data.task\n          }\n        });\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not send task  data if  option is not true","suites":["webhooks","taskActivityWebhook"],"updatePoint":{"line":536,"column":71,"index":15442},"line":536,"code":"      it(`does not send task ${type} data if ${type} option is not true`, () => {\n        data.type = type;\n        webhooks[0].options[type] = false;\n        taskActivityWebhook.send(user, data);\n        expect(got.post).to.not.be.called;\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends 'checklistScored' tasks","suites":["webhooks","taskActivityWebhook","checklistScored"],"updatePoint":{"line":554,"column":41,"index":15889},"line":554,"code":"      it('sends \\'checklistScored\\' tasks', () => {\n        data.type = 'checklistScored';\n        taskActivityWebhook.send(user, data);\n        expect(got.post).to.be.calledOnce;\n        expect(got.post).to.be.calledWithMatch(webhooks[0].url, {\n          json: {\n            webhookType: 'taskActivity',\n            user: {\n              _id: user._id\n            },\n            type: data.type,\n            task: data.task,\n            item: data.item\n          }\n        });\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not send task 'checklistScored' data if 'checklistScored' option is not true","suites":["webhooks","taskActivityWebhook","checklistScored"],"updatePoint":{"line":570,"column":95,"index":16431},"line":570,"code":"      it('does not send task \\'checklistScored\\' data if \\'checklistScored\\' option is not true', () => {\n        data.type = 'checklistScored';\n        webhooks[0].options.checklistScored = false;\n        taskActivityWebhook.send(user, data);\n        expect(got.post).to.not.be.called;\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends  webhooks","suites":["webhooks","userActivityWebhook"],"updatePoint":{"line":586,"column":32,"index":16879},"line":586,"code":"      it(`sends ${type} webhooks`, () => {\n        data.type = type;\n        userActivityWebhook.send(user, data);\n        expect(got.post).to.be.calledOnce;\n        expect(got.post).to.be.calledWithMatch(webhooks[2].url, {\n          json: {\n            type,\n            webhookType: 'userActivity',\n            user: {\n              _id: user._id\n            },\n            something: true\n          }\n        });\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not send webhook  data if  option is not true","suites":["webhooks","userActivityWebhook"],"updatePoint":{"line":601,"column":74,"index":17347},"line":601,"code":"      it(`does not send webhook ${type} data if ${type} option is not true`, () => {\n        data.type = type;\n        webhooks[2].options[type] = false;\n        userActivityWebhook.send(user, data);\n        expect(got.post).to.not.be.called;\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends  webhooks","suites":["webhooks","questActivityWebhook"],"updatePoint":{"line":626,"column":32,"index":17973},"line":626,"code":"      it(`sends ${type} webhooks`, () => {\n        data.type = type;\n        questActivityWebhook.send(user, data);\n        expect(got.post).to.be.calledOnce;\n        expect(got.post).to.be.calledWithMatch(webhooks[1].url, {\n          json: {\n            type,\n            webhookType: 'questActivity',\n            user: {\n              _id: user._id\n            },\n            group: {\n              id: 'group-id',\n              name: 'some group'\n            },\n            quest: {\n              key: 'some-key'\n            }\n          }\n        });\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not send webhook  data if  option is not true","suites":["webhooks","questActivityWebhook"],"updatePoint":{"line":647,"column":74,"index":18579},"line":647,"code":"      it(`does not send webhook ${type} data if ${type} option is not true`, () => {\n        data.type = type;\n        webhooks[1].options[type] = false;\n        userActivityWebhook.send(user, data);\n        expect(got.post).to.not.be.called;\n      });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"sends chat data","suites":["webhooks","groupChatReceivedWebhook"],"updatePoint":{"line":656,"column":23,"index":18842},"line":656,"code":"    it('sends chat data', () => {\n      const data = {\n        group: {\n          id: 'group-id',\n          name: 'some group',\n          otherData: 'foo'\n        },\n        chat: {\n          id: 'some-id',\n          text: 'message'\n        }\n      };\n      groupChatReceivedWebhook.send(user, data);\n      expect(got.post).to.be.calledOnce;\n      expect(got.post).to.be.calledWithMatch(webhooks[webhooks.length - 1].url, {\n        json: {\n          webhookType: 'groupChatReceived',\n          user: {\n            _id: user._id\n          },\n          group: {\n            id: 'group-id',\n            name: 'some group'\n          },\n          chat: {\n            id: 'some-id',\n            text: 'message'\n          }\n        }\n      });\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"does not send chat data for group if not selected","suites":["webhooks","groupChatReceivedWebhook"],"updatePoint":{"line":687,"column":57,"index":19621},"line":687,"code":"    it('does not send chat data for group if not selected', () => {\n      const data = {\n        group: {\n          id: 'not-group-id',\n          name: 'some group',\n          otherData: 'foo'\n        },\n        chat: {\n          id: 'some-id',\n          text: 'message'\n        }\n      };\n      groupChatReceivedWebhook.send(user, data);\n      expect(got.post).to.not.be.called;\n    });","file":"api/unit/libs/webhooks.test.js","skipped":false,"dir":"test"},{"name":"maps the newMessages field to have id as a value in a list.","suites":["xml marshaller marshalls user data"],"updatePoint":{"line":15,"column":65,"index":380},"line":15,"code":"  it('maps the newMessages field to have id as a value in a list.', () => {\n    const userData = userDataWith({\n      newMessages: {\n        '283171a5-422c-4991-bc78-95b1b5b51629': {\n          name: 'The Language Hackers',\n          value: true\n        },\n        '283171a6-422c-4991-bc78-95b1b5b51629': {\n          name: 'The Bug Hackers',\n          value: false\n        }\n      }\n    });\n    const xml = xmlMarshaller.marshallUserData(userData);\n    expect(xml).to.equal(`<user>\n    <inbox/>\n    <newMessages>\n        <id>283171a5-422c-4991-bc78-95b1b5b51629</id>\n        <name>The Language Hackers</name>\n        <value>true</value>\n    </newMessages>\n    <newMessages>\n        <id>283171a6-422c-4991-bc78-95b1b5b51629</id>\n        <name>The Bug Hackers</name>\n        <value>false</value>\n    </newMessages>\n</user>`);\n  });","file":"api/unit/libs/xmlMarshaller.test.js","skipped":false,"dir":"test"},{"name":"attaches analytics object to res","suites":["analytics middleware"],"updatePoint":{"line":16,"column":38,"index":588},"line":16,"code":"  it('attaches analytics object to res', () => {\n    const attachAnalytics = requireAgain(pathToAnalyticsMiddleware).default;\n    attachAnalytics(req, res, next);\n    expect(res.analytics).to.exist;\n  });","file":"api/unit/middlewares/analytics.test.js","skipped":false,"dir":"test"},{"name":"attaches stubbed methods for non-prod environments","suites":["analytics middleware"],"updatePoint":{"line":21,"column":56,"index":811},"line":21,"code":"  it('attaches stubbed methods for non-prod environments', () => {\n    sandbox.stub(nconf, 'get').withArgs('IS_PROD').returns(false);\n    const attachAnalytics = requireAgain(pathToAnalyticsMiddleware).default;\n    attachAnalytics(req, res, next);\n    expect(res.analytics.track).to.eql(analyticsService.mockAnalyticsService.track);\n    expect(res.analytics.trackPurchase).to.eql(analyticsService.mockAnalyticsService.trackPurchase);\n  });","file":"api/unit/middlewares/analytics.test.js","skipped":false,"dir":"test"},{"name":"attaches real methods for prod environments","suites":["analytics middleware"],"updatePoint":{"line":28,"column":49,"index":1244},"line":28,"code":"  it('attaches real methods for prod environments', () => {\n    sandbox.stub(nconf, 'get').withArgs('IS_PROD').returns(true);\n    const attachAnalytics = requireAgain(pathToAnalyticsMiddleware).default;\n    attachAnalytics(req, res, next);\n    expect(res.analytics.track).to.eql(analyticsService.track);\n    expect(res.analytics.trackPurchase).to.eql(analyticsService.trackPurchase);\n  });","file":"api/unit/middlewares/analytics.test.js","skipped":false,"dir":"test"},{"name":"allows to specify a list of user field that we do not want to load","suites":["auth middleware","auth with headers"],"updatePoint":{"line":13,"column":74,"index":491},"line":13,"code":"    it('allows to specify a list of user field that we do not want to load', done => {\n      const authWithHeaders = authWithHeadersFactory({\n        userFieldsToExclude: ['items']\n      });\n      req.headers['x-api-user'] = user._id;\n      req.headers['x-api-key'] = user.apiToken;\n      authWithHeaders(req, res, err => {\n        if (err) return done(err);\n        const userToJSON = res.locals.user.toJSON();\n        expect(userToJSON.items).to.not.exist;\n        expect(userToJSON.auth).to.exist;\n        return done();\n      });\n    });","file":"api/unit/middlewares/auth.test.js","skipped":false,"dir":"test"},{"name":"makes sure some fields are always included","suites":["auth middleware","auth with headers"],"updatePoint":{"line":27,"column":50,"index":1009},"line":27,"code":"    it('makes sure some fields are always included', done => {\n      const authWithHeaders = authWithHeadersFactory({\n        userFieldsToExclude: ['items', 'auth.timestamps', 'preferences', 'notifications', '_id', 'flags', 'auth' // these are always loaded\n        ]\n      });\n      req.headers['x-api-user'] = user._id;\n      req.headers['x-api-key'] = user.apiToken;\n      authWithHeaders(req, res, err => {\n        if (err) return done(err);\n        const userToJSON = res.locals.user.toJSON();\n        expect(userToJSON.items).to.not.exist;\n        expect(userToJSON.auth.timestamps).to.exist;\n        expect(userToJSON.auth).to.exist;\n        expect(userToJSON.notifications).to.exist;\n        expect(userToJSON.preferences).to.exist;\n        expect(userToJSON._id).to.exist;\n        expect(userToJSON.flags).to.exist;\n        return done();\n      });\n    });","file":"api/unit/middlewares/auth.test.js","skipped":false,"dir":"test"},{"name":"sets the correct headers","suites":["cache middlewares","disableCache"],"updatePoint":{"line":13,"column":32,"index":412},"line":13,"code":"    it('sets the correct headers', () => {\n      disableCache(req, res, next);\n      expect(res.set).to.have.been.calledWith('Cache-Control', 'no-store');\n      expect(next).to.have.been.calledOnce;\n    });","file":"api/unit/middlewares/cache.test.js","skipped":false,"dir":"test"},{"name":"removes the etag header","suites":["cache middlewares","disableCache"],"updatePoint":{"line":18,"column":32,"index":619},"line":18,"code":"    xit('removes the etag header', () => {// @TODO how to stub onHeaders\n    });","skipped":true,"file":"api/unit/middlewares/cache.test.js","dir":"test"},{"name":"sets the correct headers","suites":["cors middleware"],"updatePoint":{"line":13,"column":30,"index":396},"line":13,"code":"  it('sets the correct headers', () => {\n    cors(req, res, next);\n    expect(res.set).to.have.been.calledWith({\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'OPTIONS,GET,POST,PUT,HEAD,DELETE',\n      'Access-Control-Allow-Headers': 'Authorization,Content-Type,Accept,Content-Encoding,X-Requested-With,x-api-user,x-api-key,x-client',\n      'Access-Control-Expose-Headers': 'X-RateLimit-Limit,X-RateLimit-Remaining,X-RateLimit-Reset,Retry-After'\n    });\n    expect(res.sendStatus).to.not.have.been.called;\n    expect(next).to.have.been.calledOnce;\n  });","file":"api/unit/middlewares/cors.test.js","skipped":false,"dir":"test"},{"name":"responds immediately if method is OPTIONS","suites":["cors middleware"],"updatePoint":{"line":24,"column":47,"index":1000},"line":24,"code":"  it('responds immediately if method is OPTIONS', () => {\n    req.method = 'OPTIONS';\n    cors(req, res, next);\n    expect(res.set).to.have.been.calledWith({\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'OPTIONS,GET,POST,PUT,HEAD,DELETE',\n      'Access-Control-Allow-Headers': 'Authorization,Content-Type,Accept,Content-Encoding,X-Requested-With,x-api-user,x-api-key,x-client',\n      'Access-Control-Expose-Headers': 'X-RateLimit-Limit,X-RateLimit-Remaining,X-RateLimit-Reset,Retry-After'\n    });\n    expect(res.sendStatus).to.have.been.calledWith(200);\n    expect(next).to.not.have.been.called;\n  });","file":"api/unit/middlewares/cors.test.js","skipped":false,"dir":"test"},{"name":"returns not authorized when user is not an admin","suites":["ensure access middlewares","ensure admin"],"updatePoint":{"line":17,"column":56,"index":716},"line":17,"code":"    it('returns not authorized when user is not an admin', () => {\n      res.locals = {\n        user: {\n          contributor: {\n            admin: false\n          }\n        }\n      };\n      ensureAdmin(req, res, next);\n      const calledWith = next.getCall(0).args;\n      expect(calledWith[0].message).to.equal(i18n.t('noAdminAccess'));\n      expect(calledWith[0] instanceof NotAuthorized).to.equal(true);\n    });","file":"api/unit/middlewares/ensureAccessRight.test.js","skipped":false,"dir":"test"},{"name":"passes when user is an admin","suites":["ensure access middlewares","ensure admin"],"updatePoint":{"line":30,"column":36,"index":1111},"line":30,"code":"    it('passes when user is an admin', () => {\n      res.locals = {\n        user: {\n          contributor: {\n            admin: true\n          }\n        }\n      };\n      ensureAdmin(req, res, next);\n      expect(next).to.be.calledOnce;\n      expect(next.args[0]).to.be.empty;\n    });","file":"api/unit/middlewares/ensureAccessRight.test.js","skipped":false,"dir":"test"},{"name":"returns not authorized when user is not a newsPoster","suites":["ensure access middlewares","ensure newsPoster"],"updatePoint":{"line":44,"column":60,"index":1464},"line":44,"code":"    it('returns not authorized when user is not a newsPoster', () => {\n      res.locals = {\n        user: {\n          contributor: {\n            newsPoster: false\n          }\n        }\n      };\n      ensureNewsPoster(req, res, next);\n      const calledWith = next.getCall(0).args;\n      expect(calledWith[0].message).to.equal(apiError('noNewsPosterAccess'));\n      expect(calledWith[0] instanceof NotAuthorized).to.equal(true);\n    });","file":"api/unit/middlewares/ensureAccessRight.test.js","skipped":false,"dir":"test"},{"name":"passes when user is a newsPoster","suites":["ensure access middlewares","ensure newsPoster"],"updatePoint":{"line":57,"column":40,"index":1880},"line":57,"code":"    it('passes when user is a newsPoster', () => {\n      res.locals = {\n        user: {\n          contributor: {\n            newsPoster: true\n          }\n        }\n      };\n      ensureNewsPoster(req, res, next);\n      expect(next).to.be.calledOnce;\n      expect(next.args[0]).to.be.empty;\n    });","file":"api/unit/middlewares/ensureAccessRight.test.js","skipped":false,"dir":"test"},{"name":"returns not authorized when user is not a sudo user","suites":["ensure access middlewares","ensure sudo"],"updatePoint":{"line":71,"column":59,"index":2236},"line":71,"code":"    it('returns not authorized when user is not a sudo user', () => {\n      res.locals = {\n        user: {\n          contributor: {\n            sudo: false\n          }\n        }\n      };\n      ensureSudo(req, res, next);\n      const calledWith = next.getCall(0).args;\n      expect(calledWith[0].message).to.equal(apiError('noSudoAccess'));\n      expect(calledWith[0] instanceof NotAuthorized).to.equal(true);\n    });","file":"api/unit/middlewares/ensureAccessRight.test.js","skipped":false,"dir":"test"},{"name":"passes when user is a sudo user","suites":["ensure access middlewares","ensure sudo"],"updatePoint":{"line":84,"column":39,"index":2633},"line":84,"code":"    it('passes when user is a sudo user', () => {\n      res.locals = {\n        user: {\n          contributor: {\n            sudo: true\n          }\n        }\n      };\n      ensureSudo(req, res, next);\n      expect(next).to.be.calledOnce;\n      expect(next.args[0]).to.be.empty;\n    });","file":"api/unit/middlewares/ensureAccessRight.test.js","skipped":false,"dir":"test"},{"name":"sends internal server error if error is not a CustomError and is not identified","suites":["errorHandler"],"updatePoint":{"line":20,"column":85,"index":905},"line":20,"code":"  it('sends internal server error if error is not a CustomError and is not identified', () => {\n    const error = new Error();\n    errorHandler(error, req, res, next);\n    expect(res.status).to.be.calledOnce;\n    expect(res.json).to.be.calledOnce;\n    expect(res.status).to.be.calledWith(500);\n    expect(res.json).to.be.calledWith({\n      success: false,\n      error: 'InternalServerError',\n      message: 'An unexpected error occurred.'\n    });\n  });","file":"api/unit/middlewares/errorHandler.test.js","skipped":false,"dir":"test"},{"name":"identifies errors with statusCode property and format them correctly","suites":["errorHandler"],"updatePoint":{"line":32,"column":74,"index":1347},"line":32,"code":"  it('identifies errors with statusCode property and format them correctly', () => {\n    const error = new Error('Error message');\n    error.statusCode = 400;\n    errorHandler(error, req, res, next);\n    expect(res.status).to.be.calledOnce;\n    expect(res.json).to.be.calledOnce;\n    expect(res.status).to.be.calledWith(400);\n    expect(res.json).to.be.calledWith({\n      success: false,\n      error: 'Error',\n      message: 'Error message'\n    });\n  });","file":"api/unit/middlewares/errorHandler.test.js","skipped":false,"dir":"test"},{"name":"doesn't leak info about 500 errors","suites":["errorHandler"],"updatePoint":{"line":45,"column":41,"index":1769},"line":45,"code":"  it('doesn\\'t leak info about 500 errors', () => {\n    const error = new Error('Some secret error message');\n    error.statusCode = 500;\n    errorHandler(error, req, res, next);\n    expect(res.status).to.be.calledOnce;\n    expect(res.json).to.be.calledOnce;\n    expect(res.status).to.be.calledWith(500);\n    expect(res.json).to.be.calledWith({\n      success: false,\n      error: 'InternalServerError',\n      message: 'An unexpected error occurred.'\n    });\n  });","file":"api/unit/middlewares/errorHandler.test.js","skipped":false,"dir":"test"},{"name":"sends CustomError","suites":["errorHandler"],"updatePoint":{"line":58,"column":23,"index":2215},"line":58,"code":"  it('sends CustomError', () => {\n    const error = new BadRequest();\n    errorHandler(error, req, res, next);\n    expect(res.status).to.be.calledOnce;\n    expect(res.json).to.be.calledOnce;\n    expect(res.status).to.be.calledWith(400);\n    expect(res.json).to.be.calledWith({\n      success: false,\n      error: 'BadRequest',\n      message: 'Bad request.'\n    });\n  });","file":"api/unit/middlewares/errorHandler.test.js","skipped":false,"dir":"test"},{"name":"handle http-errors errors","suites":["errorHandler"],"updatePoint":{"line":70,"column":31,"index":2593},"line":70,"code":"  it('handle http-errors errors', () => {\n    const error = new Error('custom message');\n    error.statusCode = 422;\n    errorHandler(error, req, res, next);\n    expect(res.status).to.be.calledOnce;\n    expect(res.json).to.be.calledOnce;\n    expect(res.status).to.be.calledWith(error.statusCode);\n    expect(res.json).to.be.calledWith({\n      success: false,\n      error: error.name,\n      message: error.message\n    });\n  });","file":"api/unit/middlewares/errorHandler.test.js","skipped":false,"dir":"test"},{"name":"handle express-validator errors","suites":["errorHandler"],"updatePoint":{"line":83,"column":37,"index":3026},"line":83,"code":"  it('handle express-validator errors', () => {\n    const error = [{\n      param: 'param',\n      msg: 'invalid param',\n      value: 123\n    }];\n    errorHandler(error, req, res, next);\n    expect(res.status).to.be.calledOnce;\n    expect(res.json).to.be.calledOnce;\n    expect(res.status).to.be.calledWith(400);\n    expect(res.json).to.be.calledWith({\n      success: false,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.',\n      errors: [{\n        param: error[0].param,\n        value: error[0].value,\n        message: error[0].msg\n      }]\n    });\n  });","file":"api/unit/middlewares/errorHandler.test.js","skipped":false,"dir":"test"},{"name":"handle Mongoose Validation errors","suites":["errorHandler"],"updatePoint":{"line":104,"column":39,"index":3606},"line":104,"code":"  it('handle Mongoose Validation errors', () => {\n    const error = new Error('User validation failed');\n    error.name = 'ValidationError';\n    error.errors = {\n      'auth.local.email': {\n        path: 'auth.local.email',\n        message: 'Invalid email.',\n        value: 'not an email'\n      }\n    };\n    errorHandler(error, req, res, next);\n    expect(res.status).to.be.calledOnce;\n    expect(res.json).to.be.calledOnce;\n    expect(res.status).to.be.calledWith(400);\n    expect(res.json).to.be.calledWith({\n      success: false,\n      error: 'BadRequest',\n      message: 'User validation failed',\n      errors: [{\n        path: 'auth.local.email',\n        message: 'Invalid email.',\n        value: 'not an email'\n      }]\n    });\n  });","file":"api/unit/middlewares/errorHandler.test.js","skipped":false,"dir":"test"},{"name":"logs error","suites":["errorHandler"],"updatePoint":{"line":129,"column":16,"index":4323},"line":129,"code":"  it('logs error', () => {\n    const error = new BadRequest();\n    errorHandler(error, req, res, next);\n    expect(logger.error).to.be.calledOnce;\n    expect(logger.error).to.be.calledWithExactly(error, {\n      method: req.method,\n      originalUrl: req.originalUrl,\n      headers: req.headers,\n      body: req.body,\n      query: req.query,\n      httpCode: 400,\n      isHandledError: true\n    });\n  });","file":"api/unit/middlewares/errorHandler.test.js","skipped":false,"dir":"test"},{"name":"is disabled when the env var is not defined","suites":["ipBlocker middleware"],"updatePoint":{"line":30,"column":49,"index":1040},"line":30,"code":"  it('is disabled when the env var is not defined', () => {\n    sandbox.stub(nconf, 'get').withArgs('BLOCKED_IPS').returns(undefined);\n    const attachIpBlocker = requireAgain(pathToIpBlocker).default;\n    attachIpBlocker(req, res, next);\n    checkErrorNotThrown(next);\n  });","file":"api/unit/middlewares/ipBlocker.test.js","skipped":false,"dir":"test"},{"name":"is disabled when the env var is an empty string","suites":["ipBlocker middleware"],"updatePoint":{"line":36,"column":53,"index":1320},"line":36,"code":"  it('is disabled when the env var is an empty string', () => {\n    sandbox.stub(nconf, 'get').withArgs('BLOCKED_IPS').returns('');\n    const attachIpBlocker = requireAgain(pathToIpBlocker).default;\n    attachIpBlocker(req, res, next);\n    checkErrorNotThrown(next);\n  });","file":"api/unit/middlewares/ipBlocker.test.js","skipped":false,"dir":"test"},{"name":"is disabled when the env var contains comma separated empty strings","suites":["ipBlocker middleware"],"updatePoint":{"line":42,"column":73,"index":1613},"line":42,"code":"  it('is disabled when the env var contains comma separated empty strings', () => {\n    sandbox.stub(nconf, 'get').withArgs('BLOCKED_IPS').returns(' , , ');\n    const attachIpBlocker = requireAgain(pathToIpBlocker).default;\n    attachIpBlocker(req, res, next);\n    checkErrorNotThrown(next);\n  });","file":"api/unit/middlewares/ipBlocker.test.js","skipped":false,"dir":"test"},{"name":"does not throw when the ip does not match","suites":["ipBlocker middleware"],"updatePoint":{"line":48,"column":47,"index":1885},"line":48,"code":"  it('does not throw when the ip does not match', () => {\n    req.ip = '192.168.1.1';\n    sandbox.stub(nconf, 'get').withArgs('BLOCKED_IPS').returns('192.168.1.2');\n    const attachIpBlocker = requireAgain(pathToIpBlocker).default;\n    attachIpBlocker(req, res, next);\n    checkErrorNotThrown(next);\n  });","file":"api/unit/middlewares/ipBlocker.test.js","skipped":false,"dir":"test"},{"name":"throws when the ip is blocked","suites":["ipBlocker middleware"],"updatePoint":{"line":55,"column":35,"index":2179},"line":55,"code":"  it('throws when the ip is blocked', () => {\n    req.ip = '192.168.1.1';\n    sandbox.stub(nconf, 'get').withArgs('BLOCKED_IPS').returns('192.168.1.1');\n    const attachIpBlocker = requireAgain(pathToIpBlocker).default;\n    attachIpBlocker(req, res, next);\n    checkErrorThrown(next);\n  });","file":"api/unit/middlewares/ipBlocker.test.js","skipped":false,"dir":"test"},{"name":"attaches t method to res","suites":["language middleware","res.t"],"updatePoint":{"line":26,"column":32,"index":888},"line":26,"code":"    it('attaches t method to res', () => {\n      attachTranslateFunction(req, res, next);\n      expect(res.t).to.exist;\n    });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses the language specified in req.language","suites":["language middleware","res.t"],"updatePoint":{"line":30,"column":51,"index":1035},"line":30,"code":"    it('uses the language specified in req.language', () => {\n      req.language = 'de';\n      attachTranslateFunction(req, res, next);\n      res.t(1, 2);\n      expect(i18n.t).to.be.calledOnce;\n      expect(i18n.t).to.be.calledWith(1, 2);\n    });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses the language in the query parameter if avalaible","suites":["language middleware","getUserLanguage","query parameter"],"updatePoint":{"line":57,"column":63,"index":1810},"line":57,"code":"      it('uses the language in the query parameter if avalaible', () => {\n        req.query = {\n          lang: 'es'\n        };\n        getUserLanguage(req, res, next);\n        expect(req.language).to.equal('es');\n        checkResT(res);\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"falls back to english if the query parameter language does not exists","suites":["language middleware","getUserLanguage","query parameter"],"updatePoint":{"line":65,"column":79,"index":2074},"line":65,"code":"      it('falls back to english if the query parameter language does not exists', () => {\n        req.query = {\n          lang: 'bla'\n        };\n        getUserLanguage(req, res, next);\n        expect(req.language).to.equal('en');\n        checkResT(res);\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses query even if the request includes a user and session","suites":["language middleware","getUserLanguage","query parameter"],"updatePoint":{"line":73,"column":68,"index":2328},"line":73,"code":"      it('uses query even if the request includes a user and session', () => {\n        req.query = {\n          lang: 'es'\n        };\n        res.locals = {\n          user: {\n            preferences: {\n              language: 'it'\n            }\n          }\n        };\n        req.session = {\n          userId: 123\n        };\n        getUserLanguage(req, res, next);\n        expect(req.language).to.equal('es');\n        checkResT(res);\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses the user preferred language if avalaible","suites":["language middleware","getUserLanguage","authorized request"],"updatePoint":{"line":93,"column":55,"index":2809},"line":93,"code":"      it('uses the user preferred language if avalaible', () => {\n        res.locals = {\n          user: {\n            preferences: {\n              language: 'it'\n            }\n          }\n        };\n        getUserLanguage(req, res, next);\n        expect(req.language).to.equal('it');\n        checkResT(res);\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"falls back to english if the user preferred language is not avalaible","suites":["language middleware","getUserLanguage","authorized request"],"updatePoint":{"line":105,"column":79,"index":3153},"line":105,"code":"      it('falls back to english if the user preferred language is not avalaible', done => {\n        res.locals = {\n          user: {\n            preferences: {\n              language: 'bla'\n            }\n          }\n        };\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('en');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses the user preferred language even if a session is included in request","suites":["language middleware","getUserLanguage","authorized request"],"updatePoint":{"line":119,"column":83,"index":3539},"line":119,"code":"      it('uses the user preferred language even if a session is included in request', () => {\n        res.locals = {\n          user: {\n            preferences: {\n              language: 'it'\n            }\n          }\n        };\n        req.session = {\n          userId: 123\n        };\n        getUserLanguage(req, res, next);\n        expect(req.language).to.equal('it');\n        checkResT(res);\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses the user preferred language if avalaible","suites":["language middleware","getUserLanguage","request with session"],"updatePoint":{"line":136,"column":55,"index":3968},"line":136,"code":"      it('uses the user preferred language if avalaible', done => {\n        sandbox.stub(User, 'findOne').returns({\n          lean() {\n            return this;\n          },\n\n          exec() {\n            return Promise.resolve({\n              preferences: {\n                language: 'it'\n              }\n            });\n          }\n\n        });\n        req.session = {\n          userId: 123\n        };\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('it');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses browser specificed language","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":162,"column":42,"index":4562},"line":162,"code":"      it('uses browser specificed language', done => {\n        req.headers['accept-language'] = 'pt';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('pt');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses first language in series if browser specifies multiple","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":170,"column":69,"index":4846},"line":170,"code":"      it('uses first language in series if browser specifies multiple', done => {\n        req.headers['accept-language'] = 'he, pt, it';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('he');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"skips invalid lanaguages and uses first language in series if browser specifies multiple","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":178,"column":98,"index":5167},"line":178,"code":"      it('skips invalid lanaguages and uses first language in series if browser specifies multiple', done => {\n        req.headers['accept-language'] = 'blah, he, pt, it';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('he');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses normal version of language if specialized locale is passed in","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":186,"column":76,"index":5472},"line":186,"code":"      it('uses normal version of language if specialized locale is passed in', done => {\n        req.headers['accept-language'] = 'fr-CA';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('fr');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses normal version of language if specialized locale is passed in","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":194,"column":76,"index":5766},"line":194,"code":"      it('uses normal version of language if specialized locale is passed in', done => {\n        req.headers['accept-language'] = 'fr-CA';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('fr');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses es if es is passed in","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":202,"column":36,"index":6020},"line":202,"code":"      it('uses es if es is passed in', done => {\n        req.headers['accept-language'] = 'es';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('es');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses es_419 if applicable es-languages are passed in","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":210,"column":62,"index":6297},"line":210,"code":"      it('uses es_419 if applicable es-languages are passed in', done => {\n        req.headers['accept-language'] = 'es-mx';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('es_419');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses es_419 if multiple es languages are passed in","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":218,"column":60,"index":6579},"line":218,"code":"      it('uses es_419 if multiple es languages are passed in', done => {\n        req.headers['accept-language'] = 'es-GT, es-MX, es-CR';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('es_419');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"zh","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":226,"column":12,"index":6827},"line":226,"code":"      it('zh', done => {\n        req.headers['accept-language'] = 'zh-TW';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('zh_TW');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses english if browser specified language is not compatible","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":234,"column":70,"index":7118},"line":234,"code":"      it('uses english if browser specified language is not compatible', done => {\n        req.headers['accept-language'] = 'blah';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('en');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses english if browser does not specify","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":242,"column":50,"index":7385},"line":242,"code":"      it('uses english if browser does not specify', done => {\n        req.headers['accept-language'] = '';\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('en');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"uses english if browser does not supply an accept-language header","suites":["language middleware","getUserLanguage","browser fallback"],"updatePoint":{"line":250,"column":75,"index":7673},"line":250,"code":"      it('uses english if browser does not supply an accept-language header', done => {\n        delete req.headers['accept-language'];\n        getUserLanguage(req, res, () => {\n          expect(req.language).to.equal('en');\n          checkResT(res);\n          done();\n        });\n      });","file":"api/unit/middlewares/language.test.js","skipped":false,"dir":"test"},{"name":"does not return 503 error when maintenance mode is off","suites":["maintenance mode middleware"],"updatePoint":{"line":13,"column":60,"index":482},"line":13,"code":"  it('does not return 503 error when maintenance mode is off', () => {\n    req = generateReq();\n    sandbox.stub(nconf, 'get').withArgs('MAINTENANCE_MODE').returns('false');\n    const attachMaintenanceMode = requireAgain(pathToMaintenanceModeMiddleware).default;\n    attachMaintenanceMode(req, res, next);\n    expect(next).to.have.been.calledOnce;\n    expect(res.status).to.not.have.been.called;\n  });","file":"api/unit/middlewares/maintenanceMode.test.js","skipped":false,"dir":"test"},{"name":"returns 503 error when maintenance mode is on","suites":["maintenance mode middleware"],"updatePoint":{"line":21,"column":51,"index":875},"line":21,"code":"  it('returns 503 error when maintenance mode is on', () => {\n    req = generateReq();\n    sandbox.stub(nconf, 'get').withArgs('MAINTENANCE_MODE').returns('true');\n    const attachMaintenanceMode = requireAgain(pathToMaintenanceModeMiddleware).default;\n    attachMaintenanceMode(req, res, next);\n    expect(next).to.not.have.been.called;\n    expect(res.status).to.have.been.calledOnce;\n    expect(res.status).to.have.been.calledWith(503);\n  });","file":"api/unit/middlewares/maintenanceMode.test.js","skipped":false,"dir":"test"},{"name":"renders maintenance page when request type is HTML","suites":["maintenance mode middleware"],"updatePoint":{"line":30,"column":56,"index":1325},"line":30,"code":"  it('renders maintenance page when request type is HTML', () => {\n    req = generateReq({\n      headers: {\n        accept: 'text/html'\n      }\n    });\n    sandbox.stub(nconf, 'get').withArgs('MAINTENANCE_MODE').returns('true');\n    const attachMaintenanceMode = requireAgain(pathToMaintenanceModeMiddleware).default;\n    attachMaintenanceMode(req, res, next);\n    expect(res.render).to.have.been.calledOnce;\n  });","file":"api/unit/middlewares/maintenanceMode.test.js","skipped":false,"dir":"test"},{"name":"sends error message when request type is JSON","suites":["maintenance mode middleware"],"updatePoint":{"line":41,"column":51,"index":1735},"line":41,"code":"  it('sends error message when request type is JSON', () => {\n    req = generateReq({\n      headers: {\n        accept: 'application/json'\n      }\n    });\n    sandbox.stub(nconf, 'get').withArgs('MAINTENANCE_MODE').returns('true');\n    const attachMaintenanceMode = requireAgain(pathToMaintenanceModeMiddleware).default;\n    attachMaintenanceMode(req, res, next);\n    expect(res.send).to.have.been.calledOnce;\n  });","file":"api/unit/middlewares/maintenanceMode.test.js","skipped":false,"dir":"test"},{"name":"is disabled when the env var is not defined","suites":["rateLimiter middleware"],"updatePoint":{"line":25,"column":49,"index":955},"line":25,"code":"  it('is disabled when the env var is not defined', () => {\n    nconfGetStub.withArgs('RATE_LIMITER_ENABLED').returns(undefined);\n    const attachRateLimiter = requireAgain(pathToRateLimiter).default;\n    attachRateLimiter(req, res, next);\n    expect(next).to.have.been.calledOnce;\n    const calledWith = next.getCall(0).args;\n    expect(typeof calledWith[0] === 'undefined').to.equal(true);\n    expect(res.set).to.not.have.been.called;\n  });","file":"api/unit/middlewares/rateLimiter.test.js","skipped":false,"dir":"test"},{"name":"is disabled when the env var is an not \"true\"","suites":["rateLimiter middleware"],"updatePoint":{"line":34,"column":51,"index":1400},"line":34,"code":"  it('is disabled when the env var is an not \"true\"', () => {\n    nconfGetStub.withArgs('RATE_LIMITER_ENABLED').returns('false');\n    const attachRateLimiter = requireAgain(pathToRateLimiter).default;\n    attachRateLimiter(req, res, next);\n    expect(next).to.have.been.calledOnce;\n    const calledWith = next.getCall(0).args;\n    expect(typeof calledWith[0] === 'undefined').to.equal(true);\n    expect(res.set).to.not.have.been.called;\n  });","file":"api/unit/middlewares/rateLimiter.test.js","skipped":false,"dir":"test"},{"name":"does not throw when there are available points","suites":["rateLimiter middleware"],"updatePoint":{"line":43,"column":52,"index":1844},"line":43,"code":"  it('does not throw when there are available points', async () => {\n    nconfGetStub.withArgs('RATE_LIMITER_ENABLED').returns('true');\n    const attachRateLimiter = requireAgain(pathToRateLimiter).default;\n    await attachRateLimiter(req, res, next);\n    expect(next).to.have.been.calledOnce;\n    const calledWith = next.getCall(0).args;\n    expect(typeof calledWith[0] === 'undefined').to.equal(true);\n    expect(res.set).to.have.been.calledOnce;\n    expect(res.set).to.have.been.calledWithMatch({\n      'X-RateLimit-Limit': 30,\n      'X-RateLimit-Remaining': 29,\n      'X-RateLimit-Reset': sinon.match(Date)\n    });\n  });","file":"api/unit/middlewares/rateLimiter.test.js","skipped":false,"dir":"test"},{"name":"does not throw when an unknown error is thrown by the rate limiter","suites":["rateLimiter middleware"],"updatePoint":{"line":57,"column":72,"index":2489},"line":57,"code":"  it('does not throw when an unknown error is thrown by the rate limiter', async () => {\n    nconfGetStub.withArgs('RATE_LIMITER_ENABLED').returns('true');\n    sandbox.stub(logger, 'error');\n    sandbox.stub(RateLimiterMemory.prototype, 'consume').returns(Promise.reject(new Error('Unknown error.')));\n    const attachRateLimiter = requireAgain(pathToRateLimiter).default;\n    await attachRateLimiter(req, res, next);\n    expect(next).to.have.been.calledOnce;\n    const calledWith = next.getCall(0).args;\n    expect(typeof calledWith[0] === 'undefined').to.equal(true);\n    expect(res.set).to.not.have.been.called;\n    expect(logger.error).to.be.calledOnce;\n    expect(logger.error).to.have.been.calledWithMatch(Error, 'Rate Limiter Error');\n  });","file":"api/unit/middlewares/rateLimiter.test.js","skipped":false,"dir":"test"},{"name":"throws when there are no available points remaining","suites":["rateLimiter middleware"],"updatePoint":{"line":70,"column":57,"index":3222},"line":70,"code":"  it('throws when there are no available points remaining', async () => {\n    nconfGetStub.withArgs('RATE_LIMITER_ENABLED').returns('true');\n    const attachRateLimiter = requireAgain(pathToRateLimiter).default; // call for 31 times\n\n    for (let i = 0; i < 31; i += 1) {\n      await attachRateLimiter(req, res, next); // eslint-disable-line no-await-in-loop\n    }\n\n    expect(next).to.have.been.callCount(31);\n    const calledWith = next.getCall(30).args;\n    expect(calledWith[0].message).to.equal(apiError('clientRateLimited'));\n    expect(calledWith[0] instanceof TooManyRequests).to.equal(true);\n    expect(res.set).to.have.been.callCount(31);\n    expect(res.set).to.have.been.calledWithMatch({\n      'Retry-After': sinon.match(Number),\n      'X-RateLimit-Limit': 30,\n      'X-RateLimit-Remaining': 0,\n      'X-RateLimit-Reset': sinon.match(Date)\n    });\n  });","file":"api/unit/middlewares/rateLimiter.test.js","skipped":false,"dir":"test"},{"name":"uses the user id if supplied or the ip address","suites":["rateLimiter middleware"],"updatePoint":{"line":90,"column":52,"index":4083},"line":90,"code":"  it('uses the user id if supplied or the ip address', async () => {\n    nconfGetStub.withArgs('RATE_LIMITER_ENABLED').returns('true');\n    const attachRateLimiter = requireAgain(pathToRateLimiter).default;\n    req.ip = 1;\n    await attachRateLimiter(req, res, next);\n    req.headers['x-api-user'] = 'user-1';\n    await attachRateLimiter(req, res, next);\n    await attachRateLimiter(req, res, next); // user id an ip are counted as separate sources\n\n    expect(res.set).to.have.been.calledWithMatch({\n      'X-RateLimit-Limit': 30,\n      'X-RateLimit-Remaining': 28,\n      // 2 calls with user id\n      'X-RateLimit-Reset': sinon.match(Date)\n    });\n    req.headers['x-api-user'] = undefined;\n    await attachRateLimiter(req, res, next);\n    await attachRateLimiter(req, res, next);\n    expect(res.set).to.have.been.calledWithMatch({\n      'X-RateLimit-Limit': 30,\n      'X-RateLimit-Remaining': 27,\n      // 3 calls with only ip\n      'X-RateLimit-Reset': sinon.match(Date)\n    });\n  });","file":"api/unit/middlewares/rateLimiter.test.js","skipped":false,"dir":"test"},{"name":"adds tasks to challenge and challenge members","suites":["Challenge Model",""],"updatePoint":{"line":91,"column":55,"index":2273},"line":91,"code":"      it('adds tasks to challenge and challenge members', async () => {\n        await challenge.addTasks([task]);\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedLeadersTasks, updatedLeadersTask => updatedLeadersTask.type === taskValue.type && updatedLeadersTask.text === taskValue.text);\n        expect(syncedTask).to.exist;\n        expect(syncedTask.notes).to.eql(task.notes);\n        expect(syncedTask.tags[0]).to.eql(challenge._id);\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"adds a challenge to a user","suites":["Challenge Model",""],"updatePoint":{"line":106,"column":36,"index":2940},"line":106,"code":"      it('adds a challenge to a user', async () => {\n        const newMember = new User({\n          guilds: [guild._id]\n        });\n        await newMember.save();\n        const addedSuccessfully = await challenge.addToUser(newMember);\n        const updatedNewMember = await User.findById(newMember._id);\n        expect(addedSuccessfully).to.eql(true);\n        expect(updatedNewMember.challenges).to.contain(challenge._id);\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"does not add a challenge to a user that already in the challenge","suites":["Challenge Model",""],"updatePoint":{"line":116,"column":74,"index":3412},"line":116,"code":"      it('does not add a challenge to a user that already in the challenge', async () => {\n        const newMember = new User({\n          guilds: [guild._id],\n          challenges: [challenge._id]\n        });\n        await newMember.save();\n        const addedSuccessfully = await challenge.addToUser(newMember);\n        const updatedNewMember = await User.findById(newMember._id);\n        expect(addedSuccessfully).to.eql(false);\n        expect(updatedNewMember.challenges).to.contain(challenge._id);\n        expect(updatedNewMember.challenges.length).to.eql(1);\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"syncs challenge tasks to a user","suites":["Challenge Model",""],"updatePoint":{"line":128,"column":41,"index":3953},"line":128,"code":"      it('syncs challenge tasks to a user', async () => {\n        await challenge.addTasks([task]);\n        const newMember = new User({\n          guilds: [guild._id]\n        });\n        await newMember.save();\n        await challenge.syncTasksToUser(newMember);\n        const updatedNewMember = await User.findById(newMember._id);\n        const updatedNewMemberTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedNewMember.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedNewMemberTasks, updatedNewMemberTask => updatedNewMemberTask.type === taskValue.type && updatedNewMemberTask.text === taskValue.text);\n        expect(updatedNewMember.tags[7].id).to.equal(challenge._id);\n        expect(updatedNewMember.tags[7].name).to.equal(challenge.shortName);\n        expect(syncedTask).to.exist;\n        expect(syncedTask.attribute).to.eql('str');\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"should add challenge tag back to user upon syncing challenge tasks to a user with challenge tag removed","suites":["Challenge Model",""],"updatePoint":{"line":147,"column":113,"index":4940},"line":147,"code":"      it('should add challenge tag back to user upon syncing challenge tasks to a user with challenge tag removed', async () => {\n        await challenge.addTasks([task]);\n        const newMember = new User({\n          guilds: [guild._id]\n        });\n        await newMember.save();\n        await challenge.syncTasksToUser(newMember);\n        let updatedNewMember = await User.findById(newMember._id).exec();\n        const updatedNewMemberId = updatedNewMember._id;\n        updatedNewMember.tags = [];\n        await updatedNewMember.save();\n        const taskValue2 = tasks2ToTest[taskType];\n        const task2 = new Tasks[`${taskType}`](Tasks.Task.sanitize(taskValue2));\n        task2.challenge.id = challenge._id;\n        await challenge.addTasks([task2]);\n        await challenge.syncTasksToUser(updatedNewMember);\n        updatedNewMember = await User.findById(updatedNewMemberId).exec();\n        expect(updatedNewMember.tags.length).to.equal(1);\n        expect(updatedNewMember.tags[0].id).to.equal(challenge._id);\n        expect(updatedNewMember.tags[0].name).to.equal(challenge.shortName);\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"should not add a duplicate challenge tag to user upon syncing challenge tasks to a user with existing challenge tag","suites":["Challenge Model",""],"updatePoint":{"line":168,"column":125,"index":6060},"line":168,"code":"      it('should not add a duplicate challenge tag to user upon syncing challenge tasks to a user with existing challenge tag', async () => {\n        await challenge.addTasks([task]);\n        const newMember = new User({\n          guilds: [guild._id]\n        });\n        await newMember.save();\n        await challenge.syncTasksToUser(newMember);\n        let updatedNewMember = await User.findById(newMember._id).exec();\n        const updatedNewMemberId = updatedNewMember._id;\n        const taskValue2 = tasks2ToTest[taskType];\n        const task2 = new Tasks[`${taskType}`](Tasks.Task.sanitize(taskValue2));\n        task2.challenge.id = challenge._id;\n        await challenge.addTasks([task2]);\n        await challenge.syncTasksToUser(updatedNewMember);\n        updatedNewMember = await User.findById(updatedNewMemberId);\n        expect(updatedNewMember.tags.length).to.equal(8);\n        expect(updatedNewMember.tags[7].id).to.equal(challenge._id);\n        expect(updatedNewMember.tags[7].name).to.equal(challenge.shortName);\n        expect(updatedNewMember.tags.filter(tag => tag.id === challenge._id).length).to.equal(1);\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"syncs challenge tasks to a user with the existing task","suites":["Challenge Model",""],"updatePoint":{"line":188,"column":64,"index":7135},"line":188,"code":"      it('syncs challenge tasks to a user with the existing task', async () => {\n        await challenge.addTasks([task]);\n        let updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        let updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        let syncedTask = find(updatedLeadersTasks, updatedLeadersTask => updatedLeadersTask.challenge.taskId === task._id);\n        const createdAtBefore = syncedTask.createdAt;\n        const attributeBefore = syncedTask.attribute;\n        const newTitle = 'newName';\n        task.text = newTitle;\n        task.attribute = 'int';\n        await task.save();\n        await challenge.syncTasksToUser(leader);\n        updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        syncedTask = find(updatedLeadersTasks, updatedLeadersTask => updatedLeadersTask.challenge.taskId === task._id);\n        const createdAtAfter = syncedTask.createdAt;\n        const attributeAfter = syncedTask.attribute;\n        expect(createdAtBefore).to.eql(createdAtAfter);\n        expect(attributeBefore).to.eql(attributeAfter);\n        expect(syncedTask.text).to.eql(newTitle);\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"updates tasks to challenge and challenge members","suites":["Challenge Model",""],"updatePoint":{"line":221,"column":58,"index":8536},"line":221,"code":"      it('updates tasks to challenge and challenge members', async () => {\n        const updatedTaskName = 'Updated Test Habit';\n        await challenge.addTasks([task]);\n        const req = {\n          body: {\n            text: updatedTaskName\n          }\n        };\n        Tasks.Task.sanitize(req.body);\n\n        _.assign(task, common.ops.updateTask(task.toObject(), req)[0]);\n\n        await challenge.updateTask(task);\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedUserTask = await Tasks.Task.findById(updatedLeader.tasksOrder[`${taskType}s`][0]);\n        expect(updatedUserTask.text).to.equal(updatedTaskName);\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"removes a tasks to challenge and challenge members","suites":["Challenge Model",""],"updatePoint":{"line":240,"column":60,"index":9228},"line":240,"code":"      it('removes a tasks to challenge and challenge members', async () => {\n        await challenge.addTasks([task]);\n        await challenge.removeTask(task);\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedUserTask = await Tasks.Task.findOne({\n          _id: updatedLeader.tasksOrder[`${taskType}s`][0]\n        }).exec();\n        expect(updatedUserTask.challenge.broken).to.equal('TASK_DELETED');\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"unlinks and deletes challenge tasks for a user when remove-all is specified","suites":["Challenge Model",""],"updatePoint":{"line":251,"column":85,"index":9725},"line":251,"code":"      it('unlinks and deletes challenge tasks for a user when remove-all is specified', async () => {\n        await challenge.addTasks([task]);\n        await challenge.unlinkTasks(leader, 'remove-all');\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedLeadersTasks, updatedLeadersTask => updatedLeadersTask.type === taskValue.type && updatedLeadersTask.text === taskValue.text);\n        expect(syncedTask).to.not.exist;\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"unlinks and keeps challenge tasks for a user when keep-all is specified","suites":["Challenge Model",""],"updatePoint":{"line":265,"column":81,"index":10389},"line":265,"code":"      it('unlinks and keeps challenge tasks for a user when keep-all is specified', async () => {\n        await challenge.addTasks([task]);\n        await challenge.unlinkTasks(leader, 'keep-all');\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedLeadersTasks, updatedLeadersTask => updatedLeadersTask.type === taskValue.type && updatedLeadersTask.text === taskValue.text);\n        expect(syncedTask).to.exist;\n        expect(syncedTask.challenge._id).to.be.undefined;\n      });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"updates habit specific field to challenge and challenge members","suites":["Challenge Model","type specific updates"],"updatePoint":{"line":283,"column":71,"index":11152},"line":283,"code":"    it('updates habit specific field to challenge and challenge members', async () => {\n      task = new Tasks.habit(Tasks.Task.sanitize(tasksToTest.habit)); // eslint-disable-line new-cap\n\n      task.challenge.id = challenge._id;\n      await task.save();\n      await challenge.addTasks([task]);\n      task.up = true;\n      task.down = false;\n      await challenge.updateTask(task);\n      const updatedLeader = await User.findOne({\n        _id: leader._id\n      });\n      const updatedUserTask = await Tasks.Task.findById(updatedLeader.tasksOrder.habits[0]);\n      expect(updatedUserTask.up).to.equal(true);\n      expect(updatedUserTask.down).to.equal(false);\n    });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"updates todo specific field to challenge and challenge members","suites":["Challenge Model","type specific updates"],"updatePoint":{"line":299,"column":70,"index":11819},"line":299,"code":"    it('updates todo specific field to challenge and challenge members', async () => {\n      task = new Tasks.todo(Tasks.Task.sanitize(tasksToTest.todo)); // eslint-disable-line new-cap\n\n      task.challenge.id = challenge._id;\n      await task.save();\n      await challenge.addTasks([task]);\n      task.date = new Date();\n      await challenge.updateTask(task);\n      const updatedLeader = await User.findOne({\n        _id: leader._id\n      });\n      const updatedUserTask = await Tasks.Task.findById(updatedLeader.tasksOrder.todos[0]);\n      expect(updatedUserTask.date).to.exist;\n    });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"does not update checklists on the user task","suites":["Challenge Model","type specific updates"],"updatePoint":{"line":313,"column":51,"index":12391},"line":313,"code":"    it('does not update checklists on the user task', async () => {\n      task = new Tasks.todo(Tasks.Task.sanitize(tasksToTest.todo)); // eslint-disable-line new-cap\n\n      task.challenge.id = challenge._id;\n      await task.save();\n      await challenge.addTasks([task]);\n      task.checklist.push({\n        text: 'a new checklist'\n      });\n      await challenge.updateTask(task);\n      const updatedLeader = await User.findOne({\n        _id: leader._id\n      });\n      const updatedUserTask = await Tasks.Task.findById(updatedLeader.tasksOrder.todos[0]);\n      expect(updatedUserTask.checklist.toObject()).to.deep.equal([]);\n    });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"updates daily specific field to challenge and challenge members","suites":["Challenge Model","type specific updates"],"updatePoint":{"line":329,"column":71,"index":13048},"line":329,"code":"    it('updates daily specific field to challenge and challenge members', async () => {\n      task = new Tasks.daily(Tasks.Task.sanitize(tasksToTest.daily)); // eslint-disable-line new-cap\n\n      task.challenge.id = challenge._id;\n      await task.save();\n      await challenge.addTasks([task]);\n      task.everyX = 2;\n      await challenge.updateTask(task);\n      const updatedLeader = await User.findOne({\n        _id: leader._id\n      });\n      const updatedUserTask = await Tasks.Task.findById(updatedLeader.tasksOrder.dailys[0]);\n      expect(updatedUserTask.everyX).to.eql(2);\n    });","file":"api/unit/models/challenge.test.js","skipped":false,"dir":"test"},{"name":"syncs an assigned task to a user","suites":["Group Task Methods",""],"updatePoint":{"line":71,"column":42,"index":1858},"line":71,"code":"      it('syncs an assigned task to a user', async () => {\n        await guild.syncTask(task, leader);\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const tagIndex = findIndex(updatedLeader.tags, {\n          id: guild._id\n        });\n        const newTag = updatedLeader.tags[tagIndex];\n        expect(newTag.id).to.equal(guild._id);\n        expect(newTag.name).to.equal(guild.name);\n        expect(newTag.group).to.equal(guild._id);\n      });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"create tags for a user when task is synced","suites":["Group Task Methods",""],"updatePoint":{"line":84,"column":52,"index":2363},"line":84,"code":"      it('create tags for a user when task is synced', async () => {\n        await guild.syncTask(task, leader);\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n        expect(task.group.assignedUsers).to.contain(leader._id);\n        expect(syncedTask).to.exist;\n      });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"syncs updated info for assigned task to a user","suites":["Group Task Methods",""],"updatePoint":{"line":98,"column":56,"index":2910},"line":98,"code":"      it('syncs updated info for assigned task to a user', async () => {\n        await guild.syncTask(task, leader);\n        const updatedTaskName = 'Update Task name';\n        task.text = updatedTaskName;\n        await guild.syncTask(task, leader);\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n        expect(task.group.assignedUsers).to.contain(leader._id);\n        expect(syncedTask).to.exist;\n        expect(syncedTask.text).to.equal(task.text);\n      });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"syncs checklist items to an assigned user","suites":["Group Task Methods",""],"updatePoint":{"line":116,"column":51,"index":3638},"line":116,"code":"      it('syncs checklist items to an assigned user', async () => {\n        await guild.syncTask(task, leader);\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n        if (task.type !== 'daily' && task.type !== 'todo') return;\n        expect(syncedTask.checklist.length).to.equal(task.checklist.length);\n        expect(syncedTask.checklist[0].text).to.equal(task.checklist[0].text);\n      });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"syncs updated info for assigned task to all users","suites":["Group Task Methods","","syncs updated info"],"updatePoint":{"line":141,"column":61,"index":4638},"line":141,"code":"        it('syncs updated info for assigned task to all users', async () => {\n          const updatedTaskName = 'Update Task name';\n          task.text = updatedTaskName;\n          task.group.approval.required = true;\n          await guild.updateTask(task);\n          const updatedLeader = await User.findOne({\n            _id: leader._id\n          });\n          const updatedLeadersTasks = await Tasks.Task.find({\n            _id: {\n              $in: updatedLeader.tasksOrder[`${taskType}s`]\n            }\n          });\n          const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n          const updatedMember = await User.findOne({\n            _id: newMember._id\n          });\n          const updatedMemberTasks = await Tasks.Task.find({\n            _id: {\n              $in: updatedMember.tasksOrder[`${taskType}s`]\n            }\n          });\n          const syncedMemberTask = find(updatedMemberTasks, findLinkedTask);\n          expect(task.group.assignedUsers).to.contain(leader._id);\n          expect(syncedTask).to.exist;\n          expect(syncedTask.text).to.equal(task.text);\n          expect(syncedTask.group.approval.required).to.equal(true);\n          expect(task.group.assignedUsers).to.contain(newMember._id);\n          expect(syncedMemberTask).to.exist;\n          expect(syncedMemberTask.text).to.equal(task.text);\n          expect(syncedMemberTask.group.approval.required).to.equal(true);\n        });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"syncs a new checklist item to all assigned users","suites":["Group Task Methods","","syncs updated info"],"updatePoint":{"line":173,"column":60,"index":6067},"line":173,"code":"        it('syncs a new checklist item to all assigned users', async () => {\n          if (task.type !== 'daily' && task.type !== 'todo') return;\n          const newCheckListItem = {\n            text: 'Checklist Item 1',\n            completed: false\n          };\n          task.checklist.push(newCheckListItem);\n          await guild.updateTask(task, {\n            newCheckListItem\n          });\n          const updatedLeader = await User.findOne({\n            _id: leader._id\n          });\n          const updatedLeadersTasks = await Tasks.Task.find({\n            _id: {\n              $in: updatedLeader.tasksOrder[`${taskType}s`]\n            }\n          });\n          const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n          const updatedMember = await User.findOne({\n            _id: newMember._id\n          });\n          const updatedMemberTasks = await Tasks.Task.find({\n            _id: {\n              $in: updatedMember.tasksOrder[`${taskType}s`]\n            }\n          });\n          const syncedMemberTask = find(updatedMemberTasks, findLinkedTask);\n          expect(syncedTask.checklist.length).to.equal(task.checklist.length);\n          expect(syncedTask.checklist[1].text).to.equal(task.checklist[1].text);\n          expect(syncedMemberTask.checklist.length).to.equal(task.checklist.length);\n          expect(syncedMemberTask.checklist[1].text).to.equal(task.checklist[1].text);\n        });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"syncs updated info for checklist in assigned task to all users when flag is passed","suites":["Group Task Methods","","syncs updated info"],"updatePoint":{"line":206,"column":94,"index":7520},"line":206,"code":"        it('syncs updated info for checklist in assigned task to all users when flag is passed', async () => {\n          if (task.type !== 'daily' && task.type !== 'todo') return;\n          const updateCheckListText = 'Updated checklist item';\n\n          if (task.checklist) {\n            task.checklist[0].text = updateCheckListText;\n          }\n\n          await guild.updateTask(task, {\n            updateCheckListItems: [task.checklist[0]]\n          });\n          const updatedLeader = await User.findOne({\n            _id: leader._id\n          });\n          const updatedLeadersTasks = await Tasks.Task.find({\n            _id: {\n              $in: updatedLeader.tasksOrder[`${taskType}s`]\n            }\n          });\n          const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n          const updatedMember = await User.findOne({\n            _id: newMember._id\n          });\n          const updatedMemberTasks = await Tasks.Task.find({\n            _id: {\n              $in: updatedMember.tasksOrder[`${taskType}s`]\n            }\n          });\n          const syncedMemberTask = find(updatedMemberTasks, findLinkedTask);\n          expect(syncedTask.checklist.length).to.equal(task.checklist.length);\n          expect(syncedTask.checklist[0].text).to.equal(updateCheckListText);\n          expect(syncedMemberTask.checklist.length).to.equal(task.checklist.length);\n          expect(syncedMemberTask.checklist[0].text).to.equal(updateCheckListText);\n        });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"removes a checklist item in assigned task to all users when flag is passed with checklist id","suites":["Group Task Methods","","syncs updated info"],"updatePoint":{"line":240,"column":104,"index":9004},"line":240,"code":"        it('removes a checklist item in assigned task to all users when flag is passed with checklist id', async () => {\n          if (task.type !== 'daily' && task.type !== 'todo') return;\n          await guild.updateTask(task, {\n            removedCheckListItemId: task.checklist[0].id\n          });\n          const updatedLeader = await User.findOne({\n            _id: leader._id\n          });\n          const updatedLeadersTasks = await Tasks.Task.find({\n            _id: {\n              $in: updatedLeader.tasksOrder[`${taskType}s`]\n            }\n          });\n          const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n          const updatedMember = await User.findOne({\n            _id: newMember._id\n          });\n          const updatedMemberTasks = await Tasks.Task.find({\n            _id: {\n              $in: updatedMember.tasksOrder[`${taskType}s`]\n            }\n          });\n          const syncedMemberTask = find(updatedMemberTasks, findLinkedTask);\n          expect(syncedTask.checklist.length).to.equal(0);\n          expect(syncedMemberTask.checklist.length).to.equal(0);\n        });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"removes assigned tasks when master task is deleted","suites":["Group Task Methods","","syncs updated info"],"updatePoint":{"line":267,"column":60,"index":10087},"line":267,"code":"      it('removes assigned tasks when master task is deleted', async () => {\n        await guild.syncTask(task, leader);\n        await guild.removeTask(task);\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedLeadersTasks = await Tasks.Task.find({\n          userId: leader._id,\n          type: taskType\n        });\n        const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n        expect(updatedLeader.tasksOrder[`${taskType}s`]).to.not.include(task._id);\n        expect(syncedTask).to.not.exist;\n      });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"unlinks and deletes group tasks for a user when remove-all is specified","suites":["Group Task Methods","","syncs updated info"],"updatePoint":{"line":281,"column":81,"index":10687},"line":281,"code":"      it('unlinks and deletes group tasks for a user when remove-all is specified', async () => {\n        await guild.syncTask(task, leader);\n        await guild.unlinkTask(task, leader, 'remove-all');\n        const updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        const updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n        expect(task.group.assignedUsers).to.not.contain(leader._id);\n        expect(syncedTask).to.not.exist;\n      });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"unlinks and keeps group tasks for a user when keep-all is specified","suites":["Group Task Methods","","syncs updated info"],"updatePoint":{"line":296,"column":77,"index":11323},"line":296,"code":"      it('unlinks and keeps group tasks for a user when keep-all is specified', async () => {\n        await guild.syncTask(task, leader);\n        let updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        let updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const syncedTask = find(updatedLeadersTasks, findLinkedTask);\n        await guild.unlinkTask(task, leader, 'keep-all');\n        updatedLeader = await User.findOne({\n          _id: leader._id\n        });\n        updatedLeadersTasks = await Tasks.Task.find({\n          _id: {\n            $in: updatedLeader.tasksOrder[`${taskType}s`]\n          }\n        });\n        const updatedSyncedTask = find(updatedLeadersTasks, updatedLeadersTask => updatedLeadersTask._id === syncedTask._id);\n        expect(task.group.assignedUsers).to.not.contain(leader._id);\n        expect(updatedSyncedTask).to.exist;\n        expect(updatedSyncedTask.group._id).to.be.undefined;\n      });","file":"api/unit/models/group_tasks.test.js","skipped":false,"dir":"test"},{"name":"returns early if user is not in a party","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":121,"column":51,"index":3516},"line":121,"code":"        it('returns early if user is not in a party', async () => {\n          const userWithoutParty = new User();\n          await userWithoutParty.save();\n          await Group.processQuestProgress(userWithoutParty, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party._processBossQuest).to.not.be.called;\n          expect(party._processCollectionQuest).to.not.be.called;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns early if party is not on quest","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":131,"column":50,"index":3962},"line":131,"code":"        it('returns early if party is not on quest', async () => {\n          party.quest.active = false;\n          await party.save();\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party._processBossQuest).to.not.be.called;\n          expect(party._processCollectionQuest).to.not.be.called;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns early if user is not on quest","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":141,"column":49,"index":4390},"line":141,"code":"        it('returns early if user is not on quest', async () => {\n          await Group.processQuestProgress(nonParticipatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party._processBossQuest).to.not.be.called;\n          expect(party._processCollectionQuest).to.not.be.called;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns early if user has made no progress","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":149,"column":54,"index":4758},"line":149,"code":"        it('returns early if user has made no progress', async () => {\n          await Group.processQuestProgress(participatingMember, null);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party._processBossQuest).to.not.be.called;\n          expect(party._processCollectionQuest).to.not.be.called;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns early if quest does not exist","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":157,"column":49,"index":5114},"line":157,"code":"        it('returns early if quest does not exist', async () => {\n          party.quest.key = 'foobar';\n          await party.save();\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party._processBossQuest).to.not.be.called;\n          expect(party._processCollectionQuest).to.not.be.called;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"calls _processBossQuest if quest is a boss quest","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":167,"column":60,"index":5553},"line":167,"code":"        it('calls _processBossQuest if quest is a boss quest', async () => {\n          party.quest.key = 'whale';\n          await party.startQuest(questLeader);\n          await party.save();\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(Group.prototype._processBossQuest).to.be.calledOnce;\n          expect(party._processCollectionQuest).to.not.be.called;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"calls _processCollectionQuest if quest is a collection quest","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":178,"column":72,"index":6060},"line":178,"code":"        it('calls _processCollectionQuest if quest is a collection quest', async () => {\n          party.quest.key = 'evilsanta2';\n          await party.startQuest(questLeader);\n          await party.save();\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party._processBossQuest).to.not.be.called;\n          expect(Group.prototype._processCollectionQuest).to.be.calledOnce;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not call _processBossQuest when user is resting in the inn","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":189,"column":75,"index":6575},"line":189,"code":"        it('does not call _processBossQuest when user is resting in the inn', async () => {\n          party.quest.key = 'whale';\n          await party.startQuest(questLeader);\n          await party.save();\n          await Group.processQuestProgress(sleepingParticipatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party._processBossQuest).to.not.be.called;\n          expect(party._processCollectionQuest).to.not.be.called;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not call _processCollectionQuest when user is resting in the inn","suites":["Group Model","Static Methods","processQuestProgress","early returns"],"updatePoint":{"line":200,"column":81,"index":7089},"line":200,"code":"        it('does not call _processCollectionQuest when user is resting in the inn', async () => {\n          party.quest.key = 'evilsanta2';\n          await party.startQuest(questLeader);\n          await party.save();\n          await Group.processQuestProgress(sleepingParticipatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party._processBossQuest).to.not.be.called;\n          expect(party._processCollectionQuest).to.not.be.called;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"applies user's progress to quest boss hp","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests"],"updatePoint":{"line":221,"column":53,"index":7928},"line":221,"code":"        it('applies user\\'s progress to quest boss hp', async () => {\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party.quest.progress.hp).to.eql(495);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends a chat message about progress","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests"],"updatePoint":{"line":228,"column":47,"index":8215},"line":228,"code":"        it('sends a chat message about progress', async () => {\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(Group.prototype.sendChat).to.be.calledOnce;\n          expect(Group.prototype.sendChat).to.be.calledWith({\n            message: '`Participating Member attacks Wailing Whale for 5.0 damage. Wailing Whale attacks party for 7.5 damage.`',\n            info: {\n              bossDamage: '7.5',\n              quest: 'whale',\n              type: 'boss_damage',\n              user: 'Participating Member',\n              userDamage: '5.0'\n            }\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"applies damage only to participating members of party","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests"],"updatePoint":{"line":245,"column":65,"index":8939},"line":245,"code":"        it('applies damage only to participating members of party', async () => {\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          const [updatedLeader, updatedParticipatingMember, updatedSleepingParticipatingMember, updatedNonParticipatingMember, updatedUndecidedMember] = await Promise.all([User.findById(questLeader._id), User.findById(participatingMember._id), User.findById(sleepingParticipatingMember._id), User.findById(nonParticipatingMember._id), User.findById(undecidedMember._id)]);\n          expect(updatedLeader.stats.hp).to.eql(42.5);\n          expect(updatedParticipatingMember.stats.hp).to.eql(42.5);\n          expect(updatedSleepingParticipatingMember.stats.hp).to.eql(42.5);\n          expect(updatedNonParticipatingMember.stats.hp).to.eql(50);\n          expect(updatedUndecidedMember.stats.hp).to.eql(50);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"applies damage only to participating members of party even under buggy conditions","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests"],"updatePoint":{"line":257,"column":93,"index":9920},"line":257,"code":"        it('applies damage only to participating members of party even under buggy conditions', async () => {\n          // stops unfair damage from mbugs like https://github.com/HabitRPG/habitica/issues/7653\n          party.quest.members = {\n            [questLeader._id]: true,\n            [participatingMember._id]: true,\n            [sleepingParticipatingMember._id]: true,\n            [nonParticipatingMember._id]: false,\n            [undecidedMember._id]: null\n          };\n          await party.save();\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          const [updatedLeader, updatedParticipatingMember, updatedSleepingParticipatingMember, updatedNonParticipatingMember, updatedUndecidedMember] = await Promise.all([User.findById(questLeader._id), User.findById(participatingMember._id), User.findById(sleepingParticipatingMember._id), User.findById(nonParticipatingMember._id), User.findById(undecidedMember._id)]);\n          expect(updatedLeader.stats.hp).to.eql(42.5);\n          expect(updatedParticipatingMember.stats.hp).to.eql(42.5);\n          expect(updatedSleepingParticipatingMember.stats.hp).to.eql(42.5);\n          expect(updatedNonParticipatingMember.stats.hp).to.eql(50);\n          expect(updatedUndecidedMember.stats.hp).to.eql(50);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends message about victory","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests"],"updatePoint":{"line":278,"column":39,"index":11246},"line":278,"code":"        it('sends message about victory', async () => {\n          progress.up = 999;\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(Group.prototype.sendChat).to.be.calledTwice;\n          expect(Group.prototype.sendChat).to.be.calledWith({\n            message: '`You defeated Wailing Whale! Questing party members receive the rewards of victory.`',\n            info: {\n              quest: 'whale',\n              type: 'boss_defeated'\n            }\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"calls finishQuest when boss has <= 0 hp","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests"],"updatePoint":{"line":293,"column":51,"index":11858},"line":293,"code":"        it('calls finishQuest when boss has <= 0 hp', async () => {\n          const quest = questScrolls[party.quest.key];\n          const finishQuest = sandbox.spy(Group.prototype, 'finishQuest');\n          progress.up = 999;\n          await Group.processQuestProgress(participatingMember, progress);\n          expect(finishQuest).to.be.calledOnce;\n          expect(finishQuest).to.be.calledWith(quest);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"applies down progress to boss rage","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests","with healing Rage"],"updatePoint":{"line":308,"column":48,"index":12532},"line":308,"code":"          it('applies down progress to boss rage', async () => {\n            await Group.processQuestProgress(participatingMember, progress);\n            party = await Group.findOne({\n              _id: party._id\n            });\n            expect(party.quest.progress.rage).to.eql(10);\n          });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"activates rage when progress.down triggers rage bar","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests","with healing Rage"],"updatePoint":{"line":315,"column":65,"index":12850},"line":315,"code":"          it('activates rage when progress.down triggers rage bar', async () => {\n            const quest = questScrolls[party.quest.key];\n            progress.down = -999;\n            party.quest.progress.hp = 300;\n            await party.save();\n            await Group.processQuestProgress(participatingMember, progress);\n            party = await Group.findOne({\n              _id: party._id\n            });\n            expect(Group.prototype.sendChat).to.be.calledWith({\n              message: quest.boss.rage.effect('en'),\n              info: {\n                quest: 'trex_undead',\n                type: 'boss_rage'\n              }\n            });\n            expect(party.quest.progress.hp).to.eql(383.5);\n            expect(party.quest.progress.rage).to.eql(0);\n          });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"rage sets boss hp to max hp if raging would have caused hp to be higher than the max","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests","with healing Rage"],"updatePoint":{"line":334,"column":98,"index":13668},"line":334,"code":"          it('rage sets boss hp to max hp if raging would have caused hp to be higher than the max', async () => {\n            progress.down = -999;\n            party.quest.progress.hp = 490;\n            await Group.processQuestProgress(participatingMember, progress);\n            party = await Group.findOne({\n              _id: party._id\n            });\n            expect(party.quest.progress.hp).to.eql(500);\n          });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"applies down progress to boss rage","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests","with Mana drain Rage"],"updatePoint":{"line":351,"column":48,"index":14327},"line":351,"code":"          it('applies down progress to boss rage', async () => {\n            progress.down = -2;\n            await Group.processQuestProgress(participatingMember, progress);\n            party = await Group.findOne({\n              _id: party._id\n            });\n            expect(party.quest.progress.rage).to.eql(8);\n            const drainedUser = await User.findById(participatingMember._id);\n            expect(drainedUser.stats.mp).to.eql(10);\n          });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"activates rage when progress.down triggers rage bar","suites":["Group Model","Static Methods","processQuestProgress","Boss Quests","with Mana drain Rage"],"updatePoint":{"line":361,"column":65,"index":14807},"line":361,"code":"          it('activates rage when progress.down triggers rage bar', async () => {\n            const quest = questScrolls[party.quest.key];\n            progress.down = -999;\n            await party.save();\n            await Group.processQuestProgress(participatingMember, progress);\n            party = await Group.findOne({\n              _id: party._id\n            });\n            expect(Group.prototype.sendChat).to.be.calledWith({\n              message: quest.boss.rage.effect('en'),\n              info: {\n                quest: 'lostMasterclasser4',\n                type: 'boss_rage'\n              }\n            });\n            expect(party.quest.progress.rage).to.eql(0);\n            const drainedUser = await User.findById(participatingMember._id);\n            expect(drainedUser.stats.mp).to.eql(0);\n          });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"applies user's progress to found quest items","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests"],"updatePoint":{"line":391,"column":57,"index":15985},"line":391,"code":"        it('applies user\\'s progress to found quest items', async () => {\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(party.quest.progress.collect.soapBars).to.eq(5);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends a chat message about progress","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests"],"updatePoint":{"line":398,"column":47,"index":16283},"line":398,"code":"        it('sends a chat message about progress', async () => {\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(Group.prototype.sendChat).to.be.calledOnce;\n          expect(Group.prototype.sendChat).to.be.calledWith({\n            message: '`Participating Member found 5 Bars of Soap.`',\n            info: {\n              items: {\n                soapBars: 5\n              },\n              quest: 'atom1',\n              type: 'user_found_items',\n              user: 'Participating Member'\n            }\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends a chat message if no progress is made","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests"],"updatePoint":{"line":416,"column":55,"index":16944},"line":416,"code":"        it('sends a chat message if no progress is made', async () => {\n          progress.collectedItems = 0;\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(Group.prototype.sendChat).to.be.calledOnce;\n          expect(Group.prototype.sendChat).to.be.calledWith({\n            message: '`Participating Member found 0 Bars of Soap.`',\n            info: {\n              items: {\n                soapBars: 0\n              },\n              quest: 'atom1',\n              type: 'user_found_items',\n              user: 'Participating Member'\n            }\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends a chat message if no progress is made","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests","collection quests with multiple item types"],"updatePoint":{"line":436,"column":57,"index":17717},"line":436,"code":"          it('sends a chat message if no progress is made', async () => {\n            progress.collectedItems = 0;\n            party.quest.key = 'dilatoryDistress1';\n            party.quest.active = false;\n            await party.startQuest(questLeader);\n            Group.prototype.sendChat.resetHistory();\n            await party.save();\n            await Group.processQuestProgress(participatingMember, progress);\n            party = await Group.findOne({\n              _id: party._id\n            });\n            expect(Group.prototype.sendChat).to.be.calledOnce;\n            expect(Group.prototype.sendChat).to.be.calledWith({\n              message: '`Participating Member found 0 Fire Coral, 0 Blue Fins.`',\n              info: {\n                items: {\n                  blueFins: 0,\n                  fireCoral: 0\n                },\n                quest: 'dilatoryDistress1',\n                type: 'user_found_items',\n                user: 'Participating Member'\n              }\n            });\n          });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"handles correctly","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests","collection quests with multiple item types"],"updatePoint":{"line":461,"column":31,"index":18709},"line":461,"code":"          it('handles correctly', async () => {\n            progress.collectedItems = 10;\n            party.quest.key = 'evilsanta2';\n            party.quest.active = false;\n            await party.startQuest(questLeader);\n            Group.prototype.sendChat.resetHistory();\n            await party.save();\n            await Group.processQuestProgress(participatingMember, progress);\n            party = await Group.findOne({\n              _id: party._id\n            });\n            expect(Group.prototype.sendChat).to.be.calledOnce;\n            expect(Group.prototype.sendChat).to.be.calledWithMatch({\n              message: sinon.match(/`Participating Member found/).and(sinon.match(/\\d* (Tracks|Broken Twigs)/)),\n              info: {\n                quest: 'evilsanta2',\n                type: 'user_found_items',\n                user: 'Participating Member'\n              }\n            });\n          });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"cannot collect excess items","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests","collection quests with multiple item types"],"updatePoint":{"line":482,"column":41,"index":19628},"line":482,"code":"          it('cannot collect excess items', async () => {\n            // Make sure the quest progress isn't erased\n            sandbox.stub(Group.prototype, 'finishQuest').returns(Promise.resolve());\n            progress.collectedItems = 500;\n            party.quest.key = 'evilsanta2';\n            party.quest.active = false;\n            await party.startQuest(questLeader);\n            await party.save();\n            await Group.processQuestProgress(participatingMember, progress);\n            party = await Group.findOne({\n              _id: party._id\n            });\n            expect(party.quest.progress.collect.tracks).to.eql(questScrolls.evilsanta2.collect.tracks.count);\n            expect(party.quest.progress.collect.branches).to.eql(questScrolls.evilsanta2.collect.branches.count);\n          });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not drop items when an item type becomes full","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests","collection quests with multiple item types"],"updatePoint":{"line":498,"column":62,"index":20471},"line":498,"code":"        it('does not drop items when an item type becomes full', async () => {\n          progress.collectedItems = 20;\n          party.quest.key = 'dilatoryDistress1';\n          party.quest.active = false;\n          await party.startQuest(questLeader);\n          party.quest.progress.collect.fireCoral = 19;\n          await party.save();\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          }); // There is a very small chance (~1 in 500K) that blueFins will\n          // be 19 or 20 due to randomness and not any bug. In these cases, this\n          // test doesn't actually verify anything, but it's rare enough that it\n          // shouldn't be a problem, and to make it deterministic would require\n          // stubbing out methods in implementation-specific ways.\n\n          expect(party.quest.progress.collect.fireCoral).to.be.within(19, 20);\n          expect(party.quest.progress.collect.blueFins).to.be.within(19, 20);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends message about victory","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests","collection quests with multiple item types"],"updatePoint":{"line":517,"column":39,"index":21485},"line":517,"code":"        it('sends message about victory', async () => {\n          progress.collectedItems = 500;\n          await Group.processQuestProgress(participatingMember, progress);\n          party = await Group.findOne({\n            _id: party._id\n          });\n          expect(Group.prototype.sendChat).to.be.calledTwice;\n          expect(Group.prototype.sendChat).to.be.calledWith({\n            message: '`All items found! Party has received their rewards.`',\n            info: {\n              type: 'all_items_found'\n            }\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"calls finishQuest when all items are found","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests","collection quests with multiple item types"],"updatePoint":{"line":531,"column":54,"index":22052},"line":531,"code":"        it('calls finishQuest when all items are found', async () => {\n          const quest = questScrolls[party.quest.key];\n          const finishQuest = sandbox.spy(Group.prototype, 'finishQuest');\n          progress.collectedItems = 999;\n          await Group.processQuestProgress(participatingMember, progress);\n          expect(finishQuest).to.be.calledOnce;\n          expect(finishQuest).to.be.calledWith(quest);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"gives out rewards when quest finishes","suites":["Group Model","Static Methods","processQuestProgress","Collection Quests","collection quests with multiple item types"],"updatePoint":{"line":539,"column":49,"index":22479},"line":539,"code":"        it('gives out rewards when quest finishes', async () => {\n          progress.collectedItems = 999;\n          await Group.processQuestProgress(participatingMember, progress);\n          const [updatedLeader, updatedParticipatingMember, updatedSleepingParticipatingMember] = await Promise.all([User.findById(questLeader._id), User.findById(participatingMember._id), User.findById(sleepingParticipatingMember._id)]);\n          expect(updatedLeader.achievements.quests[party.quest.key]).to.eql(1);\n          expect(updatedLeader.stats.exp).to.be.greaterThan(0);\n          expect(updatedLeader.stats.gp).to.be.greaterThan(0);\n          expect(updatedParticipatingMember.achievements.quests[party.quest.key]).to.eql(1);\n          expect(updatedParticipatingMember.stats.exp).to.be.greaterThan(0);\n          expect(updatedParticipatingMember.stats.gp).to.be.greaterThan(0);\n          expect(updatedSleepingParticipatingMember.achievements.quests[party.quest.key]).to.eql(1);\n          expect(updatedSleepingParticipatingMember.stats.exp).to.be.greaterThan(0);\n          expect(updatedSleepingParticipatingMember.stats.gp).to.be.greaterThan(0);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if no uuids or emails are passed in","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":562,"column":61,"index":23813},"line":562,"code":"      it('throws an error if no uuids or emails are passed in', async () => {\n        await expect(Group.validateInvitations({}, res)).to.eventually.be.rejected.and.eql({\n          httpCode: 400,\n          message: 'Bad request.',\n          name: 'BadRequest'\n        });\n        expect(res.t).to.be.calledOnce;\n        expect(res.t).to.be.calledWith('canOnlyInviteEmailUuid');\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if only uuids are passed in, but they are not an array","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":571,"column":80,"index":24220},"line":571,"code":"      it('throws an error if only uuids are passed in, but they are not an array', async () => {\n        await expect(Group.validateInvitations({\n          uuids: 'user-id'\n        }, res)).to.eventually.be.rejected.and.eql({\n          httpCode: 400,\n          message: 'Bad request.',\n          name: 'BadRequest'\n        });\n        expect(res.t).to.be.calledOnce;\n        expect(res.t).to.be.calledWith('uuidsMustBeAnArray');\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if only emails are passed in, but they are not an array","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":582,"column":81,"index":24660},"line":582,"code":"      it('throws an error if only emails are passed in, but they are not an array', async () => {\n        await expect(Group.validateInvitations({\n          emails: 'user@example.com'\n        }, res)).to.eventually.be.rejected.and.eql({\n          httpCode: 400,\n          message: 'Bad request.',\n          name: 'BadRequest'\n        });\n        expect(res.t).to.be.calledOnce;\n        expect(res.t).to.be.calledWith('emailsMustBeAnArray');\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if emails are not passed in, and uuid array is empty","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":593,"column":78,"index":25108},"line":593,"code":"      it('throws an error if emails are not passed in, and uuid array is empty', async () => {\n        await expect(Group.validateInvitations({\n          uuids: []\n        }, res)).to.eventually.be.rejected.and.eql({\n          httpCode: 400,\n          message: 'Bad request.',\n          name: 'BadRequest'\n        });\n        expect(res.t).to.be.calledOnce;\n        expect(res.t).to.be.calledWith('inviteMustNotBeEmpty');\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if uuids are not passed in, and email array is empty","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":604,"column":78,"index":25540},"line":604,"code":"      it('throws an error if uuids are not passed in, and email array is empty', async () => {\n        await expect(Group.validateInvitations({\n          emails: []\n        }, res)).to.eventually.be.rejected.and.eql({\n          httpCode: 400,\n          message: 'Bad request.',\n          name: 'BadRequest'\n        });\n        expect(res.t).to.be.calledOnce;\n        expect(res.t).to.be.calledWith('inviteMustNotBeEmpty');\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if uuids and emails are passed in as empty arrays","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":615,"column":75,"index":25970},"line":615,"code":"      it('throws an error if uuids and emails are passed in as empty arrays', async () => {\n        await expect(Group.validateInvitations({\n          emails: [],\n          uuids: []\n        }, res)).to.eventually.be.rejected.and.eql({\n          httpCode: 400,\n          message: 'Bad request.',\n          name: 'BadRequest'\n        });\n        expect(res.t).to.be.calledOnce;\n        expect(res.t).to.be.calledWith('inviteMustNotBeEmpty');\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if total invites exceed max invite constant","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":627,"column":69,"index":26415},"line":627,"code":"      it('throws an error if total invites exceed max invite constant', async () => {\n        const uuids = [];\n        const emails = [];\n\n        for (let i = 0; i < INVITES_LIMIT / 2; i += 1) {\n          uuids.push(`user-id-${i}`);\n          emails.push(`user-${i}@example.com`);\n        }\n\n        uuids.push('one-more-uuid'); // to put it over the limit\n\n        await expect(Group.validateInvitations({\n          uuids,\n          emails\n        }, res)).to.eventually.be.rejected.and.eql({\n          httpCode: 400,\n          message: 'Bad request.',\n          name: 'BadRequest'\n        });\n        expect(res.t).to.be.calledOnce;\n        expect(res.t).to.be.calledWith('canOnlyInviteMaxInvites', {\n          maxInvites: INVITES_LIMIT\n        });\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not throw error if number of invites matches max invite limit","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":651,"column":76,"index":27185},"line":651,"code":"      it('does not throw error if number of invites matches max invite limit', async () => {\n        const uuids = [];\n        const emails = [];\n\n        for (let i = 0; i < INVITES_LIMIT / 2; i += 1) {\n          uuids.push(`user-id-${i}`);\n          emails.push(`user-${i}@example.com`);\n        }\n\n        await Group.validateInvitations({\n          uuids,\n          emails\n        }, res);\n        expect(res.t).to.not.be.called;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not throw an error if only user ids are passed in","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":666,"column":64,"index":27617},"line":666,"code":"      it('does not throw an error if only user ids are passed in', async () => {\n        await Group.validateInvitations({\n          uuids: ['user-id', 'user-id2']\n        }, res);\n        expect(res.t).to.not.be.called;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not throw an error if only emails are passed in","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":672,"column":62,"index":27846},"line":672,"code":"      it('does not throw an error if only emails are passed in', async () => {\n        await Group.validateInvitations({\n          emails: ['user1@example.com', 'user2@example.com']\n        }, res);\n        expect(res.t).to.not.be.called;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not throw an error if both uuids and emails are passed in","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":678,"column":72,"index":28105},"line":678,"code":"      it('does not throw an error if both uuids and emails are passed in', async () => {\n        await Group.validateInvitations({\n          uuids: ['user-id', 'user-id2'],\n          emails: ['user1@example.com', 'user2@example.com']\n        }, res);\n        expect(res.t).to.not.be.called;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not throw an error if uuids are passed in and emails are an empty array","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":685,"column":86,"index":28420},"line":685,"code":"      it('does not throw an error if uuids are passed in and emails are an empty array', async () => {\n        await Group.validateInvitations({\n          uuids: ['user-id', 'user-id2'],\n          emails: []\n        }, res);\n        expect(res.t).to.not.be.called;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not throw an error if emails are passed in and uuids are an empty array","suites":["Group Model","Static Methods","validateInvitations"],"updatePoint":{"line":692,"column":86,"index":28695},"line":692,"code":"      it('does not throw an error if emails are passed in and uuids are an empty array', async () => {\n        await Group.validateInvitations({\n          uuids: [],\n          emails: ['user1@example.com', 'user2@example.com']\n        }, res);\n        expect(res.t).to.not.be.called;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate quest_start","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":701,"column":31,"index":28990},"line":701,"code":"      it('translate quest_start', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'quest_start',\n            quest: 'basilist'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate boss_damage","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":712,"column":31,"index":29345},"line":712,"code":"      it('translate boss_damage', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'boss_damage',\n            user: questLeader.profile.name,\n            quest: 'basilist',\n            userDamage: 15.3,\n            bossDamage: 3.7\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate boss_dont_attack","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":726,"column":36,"index":29808},"line":726,"code":"      it('translate boss_dont_attack', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'boss_dont_attack',\n            user: questLeader.profile.name,\n            quest: 'basilist',\n            userDamage: 15.3\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate boss_rage","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":739,"column":29,"index":30240},"line":739,"code":"      it('translate boss_rage', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'boss_rage',\n            quest: 'lostMasterclasser3'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate boss_defeated","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":750,"column":33,"index":30605},"line":750,"code":"      it('translate boss_defeated', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'boss_defeated',\n            quest: 'lostMasterclasser3'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate user_found_items","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":761,"column":36,"index":30977},"line":761,"code":"      it('translate user_found_items', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'user_found_items',\n            user: questLeader.profile.name,\n            quest: 'lostMasterclasser1',\n            items: {\n              ancientTome: 3,\n              forbiddenTome: 2,\n              hiddenTome: 1\n            }\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate all_items_found","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":778,"column":35,"index":31521},"line":778,"code":"      it('translate all_items_found', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'all_items_found'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate spell_cast_party","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":788,"column":36,"index":31854},"line":788,"code":"      it('translate spell_cast_party', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'spell_cast_party',\n            user: questLeader.profile.name,\n            class: 'wizard',\n            spell: 'earth'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate spell_cast_user","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":801,"column":35,"index":32288},"line":801,"code":"      it('translate spell_cast_user', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'spell_cast_user',\n            user: questLeader.profile.name,\n            class: 'special',\n            spell: 'snowball',\n            target: participatingMember.profile.name\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate quest_cancel","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":815,"column":32,"index":32776},"line":815,"code":"      it('translate quest_cancel', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'quest_cancel',\n            user: questLeader.profile.name,\n            quest: 'basilist'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate quest_abort","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":827,"column":31,"index":33176},"line":827,"code":"      it('translate quest_abort', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'quest_abort',\n            user: questLeader.profile.name,\n            quest: 'basilist'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate tavern_quest_completed","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":839,"column":42,"index":33586},"line":839,"code":"      it('translate tavern_quest_completed', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'tavern_quest_completed',\n            quest: 'stressbeast'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate tavern_boss_rage_tired","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":850,"column":42,"index":33966},"line":850,"code":"      it('translate tavern_boss_rage_tired', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'tavern_boss_rage_tired',\n            quest: 'stressbeast'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate tavern_boss_rage","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":861,"column":36,"index":34340},"line":861,"code":"      it('translate tavern_boss_rage', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'tavern_boss_rage',\n            quest: 'dysheartener',\n            scene: 'market'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate tavern_boss_desperation","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":873,"column":43,"index":34745},"line":873,"code":"      it('translate tavern_boss_desperation', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'tavern_boss_desperation',\n            quest: 'stressbeast'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"translate claim_task","suites":["Group Model","Static Methods","translateSystemMessages"],"updatePoint":{"line":884,"column":30,"index":35114},"line":884,"code":"      it('translate claim_task', async () => {\n        questLeader.preferences.language = 'en';\n        party.chat = [{\n          info: {\n            type: 'claim_task',\n            user: questLeader.profile.name,\n            task: 'Feed the pet'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        translationCheck(toJSON.chat[0].text);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"shows messages with 1 flag to non-admins","suites":["Group Model","Static Methods","toJSONCleanChat"],"updatePoint":{"line":898,"column":50,"index":35582},"line":898,"code":"      it('shows messages with 1 flag to non-admins', async () => {\n        party.chat = [{\n          flagCount: 1,\n          info: {\n            type: 'quest_start',\n            quest: 'basilist'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        expect(toJSON.chat.length).to.equal(1);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"shows messages with >= 2 flag to admins","suites":["Group Model","Static Methods","toJSONCleanChat"],"updatePoint":{"line":909,"column":49,"index":35931},"line":909,"code":"      it('shows messages with >= 2 flag to admins', async () => {\n        party.chat = [{\n          flagCount: 3,\n          info: {\n            type: 'quest_start',\n            quest: 'basilist'\n          }\n        }];\n        const admin = new User({\n          'contributor.admin': true\n        });\n        const toJSON = await Group.toJSONCleanChat(party, admin);\n        expect(toJSON.chat.length).to.equal(1);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"doesn't show flagged messages to non-admins","suites":["Group Model","Static Methods","toJSONCleanChat"],"updatePoint":{"line":923,"column":54,"index":36360},"line":923,"code":"      it('doesn\\'t show flagged messages to non-admins', async () => {\n        party.chat = [{\n          flagCount: 3,\n          info: {\n            type: 'quest_start',\n            quest: 'basilist'\n          }\n        }];\n        const toJSON = await Group.toJSONCleanChat(party, questLeader);\n        expect(toJSON.chat.length).to.equal(0);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns an array of members whose quest status set to true","suites":["Group Model","Instance Methods","#getParticipatingQuestMembers"],"updatePoint":{"line":938,"column":68,"index":36834},"line":938,"code":"      it('returns an array of members whose quest status set to true', () => {\n        party.quest.members = {\n          [participatingMember._id]: true,\n          [sleepingParticipatingMember._id]: true,\n          [questLeader._id]: true,\n          [nonParticipatingMember._id]: false,\n          [undecidedMember._id]: null\n        };\n        expect(party.getParticipatingQuestMembers()).to.eql([participatingMember._id, sleepingParticipatingMember._id, questLeader._id]);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"group that is not the tavern returns false, while tavern returns true","suites":["Group Model","Instance Methods","#checkChatSpam"],"updatePoint":{"line":976,"column":79,"index":37956},"line":976,"code":"      it('group that is not the tavern returns false, while tavern returns true', async () => {\n        for (let i = 0; i < SPAM_MESSAGE_LIMIT; i += 1) {\n          party.chat.push(generateTestMessage());\n        }\n\n        expect(party.checkChatSpam(testUser)).to.eql(false);\n\n        for (let i = 0; i < SPAM_MESSAGE_LIMIT; i += 1) {\n          tavern.chat.push(generateTestMessage());\n        }\n\n        expect(tavern.checkChatSpam(testUser)).to.eql(true);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"high enough contributor returns false","suites":["Group Model","Instance Methods","#checkChatSpam"],"updatePoint":{"line":989,"column":47,"index":38392},"line":989,"code":"      it('high enough contributor returns false', async () => {\n        const highContributor = testUser;\n        highContributor.contributor = {\n          level: SPAM_MIN_EXEMPT_CONTRIB_LEVEL\n        };\n\n        for (let i = 0; i < SPAM_MESSAGE_LIMIT; i += 1) {\n          tavern.chat.push(generateTestMessage());\n        }\n\n        expect(tavern.checkChatSpam(highContributor)).to.eql(false);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"chat with no messages returns false","suites":["Group Model","Instance Methods","#checkChatSpam"],"updatePoint":{"line":1001,"column":45,"index":38794},"line":1001,"code":"      it('chat with no messages returns false', async () => {\n        expect(tavern.chat.length).to.eql(0);\n        expect(tavern.checkChatSpam(testUser)).to.eql(false);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"user has not reached limit but another one has returns false","suites":["Group Model","Instance Methods","#checkChatSpam"],"updatePoint":{"line":1005,"column":70,"index":38999},"line":1005,"code":"      it('user has not reached limit but another one has returns false', async () => {\n        const otherUserID = '2';\n\n        for (let i = 0; i < SPAM_MESSAGE_LIMIT; i += 1) {\n          tavern.chat.push(generateTestMessage({\n            uuid: otherUserID\n          }));\n        }\n\n        expect(tavern.checkChatSpam(testUser)).to.eql(false);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"user messages is less than the limit returns false","suites":["Group Model","Instance Methods","#checkChatSpam"],"updatePoint":{"line":1016,"column":60,"index":39345},"line":1016,"code":"      it('user messages is less than the limit returns false', async () => {\n        for (let i = 0; i < SPAM_MESSAGE_LIMIT - 1; i += 1) {\n          tavern.chat.push(generateTestMessage());\n        }\n\n        expect(tavern.checkChatSpam(testUser)).to.eql(false);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"user has reached the message limit outside of window returns false","suites":["Group Model","Instance Methods","#checkChatSpam"],"updatePoint":{"line":1023,"column":76,"index":39634},"line":1023,"code":"      it('user has reached the message limit outside of window returns false', async () => {\n        for (let i = 0; i < SPAM_MESSAGE_LIMIT - 1; i += 1) {\n          tavern.chat.push(generateTestMessage());\n        }\n\n        const earlierTimestamp = testTime - SPAM_WINDOW_LENGTH - 1;\n        tavern.chat.push(generateTestMessage({\n          timestamp: earlierTimestamp\n        }));\n        expect(tavern.checkChatSpam(testUser)).to.eql(false);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"user has posted too many messages in limit returns true","suites":["Group Model","Instance Methods","#checkChatSpam"],"updatePoint":{"line":1034,"column":65,"index":40078},"line":1034,"code":"      it('user has posted too many messages in limit returns true', async () => {\n        for (let i = 0; i < SPAM_MESSAGE_LIMIT; i += 1) {\n          tavern.chat.push(generateTestMessage());\n        }\n\n        expect(tavern.checkChatSpam(testUser)).to.eql(true);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"removes user from group quest","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1043,"column":39,"index":40369},"line":1043,"code":"      it('removes user from group quest', async () => {\n        party.quest.members = {\n          [participatingMember._id]: true,\n          [sleepingParticipatingMember._id]: true,\n          [questLeader._id]: true,\n          [nonParticipatingMember._id]: false,\n          [undecidedMember._id]: null\n        };\n        party.memberCount = 5;\n        await party.save();\n        await party.leave(participatingMember);\n        party = await Group.findOne({\n          _id: party._id\n        });\n        expect(party.quest.members).to.eql({\n          [questLeader._id]: true,\n          [sleepingParticipatingMember._id]: true,\n          [nonParticipatingMember._id]: false,\n          [undecidedMember._id]: null\n        });\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"unlink group tag","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1064,"column":26,"index":41089},"line":1064,"code":"      it('unlink group tag', async () => {\n        participatingMember.tags.push({\n          name: party.name,\n          id: party._id,\n          group: party._id\n        });\n        await participatingMember.save();\n        await party.leave(participatingMember);\n        participatingMember = await User.findOne({\n          _id: participatingMember._id\n        });\n        const groupTag = participatingMember.tags.find(tag => tag.id === party._id);\n        expect(groupTag).to.not.be.undefined;\n        expect(groupTag.group).to.be.undefined;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"deletes a private party when the last member leaves","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1079,"column":61,"index":41680},"line":1079,"code":"      it('deletes a private party when the last member leaves', async () => {\n        await party.leave(participatingMember);\n        await party.leave(sleepingParticipatingMember);\n        await party.leave(questLeader);\n        await party.leave(nonParticipatingMember);\n        await party.leave(undecidedMember);\n        party = await Group.findOne({\n          _id: party._id\n        });\n        expect(party).to.not.exist;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not delete a private group when the last member leaves and a subscription is active","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1090,"column":98,"index":42155},"line":1090,"code":"      it('does not delete a private group when the last member leaves and a subscription is active', async () => {\n        party.memberCount = 1;\n        party.purchased.plan.customerId = '110002222333';\n        await expect(party.leave(participatingMember)).to.eventually.be.rejected.and.to.eql({\n          name: 'NotAuthorized',\n          httpCode: 401,\n          message: shared.i18n.t('cannotDeleteActiveGroup')\n        });\n        party = await Group.findOne({\n          _id: party._id\n        });\n        expect(party).to.exist;\n        expect(party.memberCount).to.eql(1);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not allow a leader to leave a group with an active subscription","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1104,"column":78,"index":42725},"line":1104,"code":"      it('does not allow a leader to leave a group with an active subscription', async () => {\n        party.memberCount = 2;\n        party.purchased.plan.customerId = '110002222333';\n        await expect(party.leave(questLeader)).to.eventually.be.rejected.and.to.eql({\n          name: 'NotAuthorized',\n          httpCode: 401,\n          message: shared.i18n.t('leaderCannotLeaveGroupWithActiveGroup')\n        });\n        party = await Group.findOne({\n          _id: party._id\n        });\n        expect(party).to.exist;\n        expect(party.memberCount).to.eql(1);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"deletes a private group when the last member leaves and a subscription is cancelled","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1118,"column":93,"index":43316},"line":1118,"code":"      it('deletes a private group when the last member leaves and a subscription is cancelled', async () => {\n        const guild = new Group({\n          name: 'test guild',\n          type: 'guild',\n          memberCount: 1\n        });\n        const leader = new User({\n          guilds: [guild._id]\n        });\n        guild.leader = leader._id;\n        await Promise.all([guild.save(), leader.save()]);\n        guild.purchased.plan.customerId = '110002222333';\n        guild.purchased.plan.dateTerminated = new Date();\n        await guild.leave(leader);\n        party = await Group.findOne({\n          _id: guild._id\n        });\n        expect(party).to.not.exist;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not delete a public group when the last member leaves","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1137,"column":68,"index":43968},"line":1137,"code":"      it('does not delete a public group when the last member leaves', async () => {\n        party.privacy = 'public';\n        await party.leave(participatingMember);\n        await party.leave(sleepingParticipatingMember);\n        await party.leave(questLeader);\n        await party.leave(nonParticipatingMember);\n        await party.leave(undecidedMember);\n        party = await Group.findOne({\n          _id: party._id\n        });\n        expect(party).to.exist;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not delete a private party when the member count reaches zero if there are still members","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1149,"column":103,"index":44478},"line":1149,"code":"      it('does not delete a private party when the member count reaches zero if there are still members', async () => {\n        party.memberCount = 1;\n        await party.leave(participatingMember);\n        party = await Group.findOne({\n          _id: party._id\n        });\n        expect(party).to.exist;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"deletes a private guild when the last member leaves","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1157,"column":61,"index":44752},"line":1157,"code":"      it('deletes a private guild when the last member leaves', async () => {\n        let guild = new Group({\n          name: 'test guild',\n          type: 'guild',\n          memberCount: 1\n        });\n        const leader = new User({\n          guilds: [guild._id]\n        });\n        guild.leader = leader._id;\n        await Promise.all([guild.save(), leader.save()]);\n        await guild.leave(leader);\n        guild = await Group.findOne({\n          _id: guild._id\n        });\n        expect(guild).to.not.exist;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not delete a private guild when the member count reaches zero if there are still members","suites":["Group Model","Instance Methods","#leaveGroup"],"updatePoint":{"line":1174,"column":103,"index":45321},"line":1174,"code":"      it('does not delete a private guild when the member count reaches zero if there are still members', async () => {\n        let guild = new Group({\n          name: 'test guild',\n          type: 'guild',\n          memberCount: 1\n        });\n        const leader = new User({\n          guilds: [guild._id]\n        });\n        const member = new User({\n          guilds: [guild._id]\n        });\n        guild.leader = leader._id;\n        await Promise.all([guild.save(), leader.save(), member.save()]);\n        await guild.leave(member);\n        guild = await Group.findOne({\n          _id: guild._id\n        });\n        expect(guild).to.exist;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"formats message","suites":["Group Model","Instance Methods","#sendChat"],"updatePoint":{"line":1199,"column":25,"index":46013},"line":1199,"code":"      it('formats message', () => {\n        const chatMessage = party.sendChat({\n          message: 'a _new_ message with *markdown*',\n          user: {\n            _id: 'user-id',\n            profile: {\n              name: 'user name'\n            },\n            contributor: {\n              toObject() {\n                return 'contributor object';\n              }\n\n            },\n            backer: {\n              toObject() {\n                return 'backer object';\n              }\n\n            }\n          }\n        });\n        const chat = chatMessage;\n        expect(chat.text).to.eql('a _new_ message with *markdown*');\n        expect(chat.unformattedText).to.eql('a new message with markdown');\n        expect(validator.isUUID(chat.id)).to.eql(true);\n        expect(chat.timestamp).to.be.a('date');\n        expect(chat.likes).to.eql({});\n        expect(chat.flags).to.eql({});\n        expect(chat.flagCount).to.eql(0);\n        expect(chat.uuid).to.eql('user-id');\n        expect(chat.contributor).to.eql('contributor object');\n        expect(chat.backer).to.eql('backer object');\n        expect(chat.user).to.eql('user name');\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"formats message as system if no user is passed in","suites":["Group Model","Instance Methods","#sendChat"],"updatePoint":{"line":1234,"column":59,"index":47194},"line":1234,"code":"      it('formats message as system if no user is passed in', () => {\n        const chat = party.sendChat({\n          message: 'a system message'\n        });\n        expect(chat.text).to.eql('a system message');\n        expect(validator.isUUID(chat.id)).to.eql(true);\n        expect(chat.timestamp).to.be.a('date');\n        expect(chat.likes).to.eql({});\n        expect(chat.flags).to.eql({});\n        expect(chat.flagCount).to.eql(0);\n        expect(chat.uuid).to.eql('system');\n        expect(chat.contributor).to.not.exist;\n        expect(chat.backer).to.not.exist;\n        expect(chat.user).to.not.exist;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"updates users about new messages in party","suites":["Group Model","Instance Methods","#sendChat"],"updatePoint":{"line":1249,"column":51,"index":47805},"line":1249,"code":"      it('updates users about new messages in party', () => {\n        party.sendChat({\n          message: 'message'\n        });\n        expect(User.update).to.be.calledOnce;\n        expect(User.update).to.be.calledWithMatch({\n          'party._id': party._id,\n          _id: {\n            $ne: ''\n          }\n        });\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"updates users about new messages in group","suites":["Group Model","Instance Methods","#sendChat"],"updatePoint":{"line":1261,"column":51,"index":48136},"line":1261,"code":"      it('updates users about new messages in group', () => {\n        const group = new Group({\n          type: 'guild'\n        });\n        group.sendChat({\n          message: 'message'\n        });\n        expect(User.update).to.be.calledOnce;\n        expect(User.update).to.be.calledWithMatch({\n          guilds: group._id,\n          _id: {\n            $ne: ''\n          }\n        });\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not send update to user that sent the message","suites":["Group Model","Instance Methods","#sendChat"],"updatePoint":{"line":1276,"column":60,"index":48541},"line":1276,"code":"      it('does not send update to user that sent the message', () => {\n        party.sendChat({\n          message: 'message',\n          user: {\n            _id: 'user-id',\n            profile: {\n              name: 'user'\n            }\n          }\n        });\n        expect(User.update).to.be.calledOnce;\n        expect(User.update).to.be.calledWithMatch({\n          'party._id': party._id,\n          _id: {\n            $ne: 'user-id'\n          }\n        });\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"skips sending new message notification for guilds with > 5000 members","suites":["Group Model","Instance Methods","#sendChat"],"updatePoint":{"line":1294,"column":79,"index":49030},"line":1294,"code":"      it('skips sending new message notification for guilds with > 5000 members', () => {\n        party.memberCount = 5001;\n        party.sendChat({\n          message: 'message'\n        });\n        expect(User.update).to.not.be.called;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"skips sending messages to the tavern","suites":["Group Model","Instance Methods","#sendChat"],"updatePoint":{"line":1301,"column":46,"index":49243},"line":1301,"code":"      it('skips sending messages to the tavern', () => {\n        party._id = TAVERN_ID;\n        party.sendChat({\n          message: 'message'\n        });\n        expect(User.update).to.not.be.called;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if group is not a party","suites":["Group Model","Instance Methods","#startQuest","Failure Conditions"],"updatePoint":{"line":1311,"column":51,"index":49546},"line":1311,"code":"        it('throws an error if group is not a party', async () => {\n          const guild = new Group({\n            type: 'guild'\n          });\n          await expect(guild.startQuest(participatingMember)).to.eventually.be.rejected;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if party is not on a quest","suites":["Group Model","Instance Methods","#startQuest","Failure Conditions"],"updatePoint":{"line":1317,"column":54,"index":49794},"line":1317,"code":"        it('throws an error if party is not on a quest', async () => {\n          await expect(party.startQuest(participatingMember)).to.eventually.be.rejected;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"throws an error if quest is already active","suites":["Group Model","Instance Methods","#startQuest","Failure Conditions"],"updatePoint":{"line":1320,"column":54,"index":49966},"line":1320,"code":"        it('throws an error if quest is already active', async () => {\n          party.quest.key = 'whale';\n          party.quest.active = true;\n          await expect(party.startQuest(participatingMember)).to.eventually.be.rejected;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"activates quest","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1339,"column":27,"index":50663},"line":1339,"code":"        it('activates quest', () => {\n          party.startQuest(participatingMember);\n          expect(party.quest.active).to.eql(true);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sets up boss quest","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1343,"column":30,"index":50816},"line":1343,"code":"        it('sets up boss quest', () => {\n          const bossQuest = questScrolls.whale;\n          party.quest.key = bossQuest.key;\n          party.startQuest(participatingMember);\n          expect(party.quest.progress.hp).to.eql(bossQuest.boss.hp);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sets up rage meter for rage boss quest","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1349,"column":50,"index":51098},"line":1349,"code":"        it('sets up rage meter for rage boss quest', () => {\n          const rageBossQuest = questScrolls.trex_undead;\n          party.quest.key = rageBossQuest.key;\n          party.startQuest(participatingMember);\n          expect(party.quest.progress.rage).to.eql(0);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sets up collection quest","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1355,"column":36,"index":51366},"line":1355,"code":"        it('sets up collection quest', () => {\n          const collectionQuest = questScrolls.vice2;\n          party.quest.key = collectionQuest.key;\n          party.startQuest(participatingMember);\n          expect(party.quest.progress.collect).to.eql({\n            lightCrystal: 0\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sets up collection quest with multiple items","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1363,"column":56,"index":51695},"line":1363,"code":"        it('sets up collection quest with multiple items', () => {\n          const collectionQuest = questScrolls.evilsanta2;\n          party.quest.key = collectionQuest.key;\n          party.startQuest(participatingMember);\n          expect(party.quest.progress.collect).to.eql({\n            tracks: 0,\n            branches: 0\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"prunes non-participating members from quest members object","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1372,"column":70,"index":52062},"line":1372,"code":"        it('prunes non-participating members from quest members object', () => {\n          party.startQuest(participatingMember);\n          const expectedQuestMembers = {};\n          expectedQuestMembers[questLeader._id] = true;\n          expectedQuestMembers[participatingMember._id] = true;\n          expectedQuestMembers[sleepingParticipatingMember._id] = true;\n          expect(party.quest.members).to.eql(expectedQuestMembers);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"applies updates to user object directly if user is participating (without resetting progress, except progress.down)","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1380,"column":127,"index":52564},"line":1380,"code":"        it('applies updates to user object directly if user is participating (without resetting progress, except progress.down)', async () => {\n          await party.startQuest(participatingMember);\n          expect(participatingMember.party.quest.key).to.eql('whale');\n          expect(participatingMember.party.quest.progress.up).to.eql(10);\n          expect(participatingMember.party.quest.progress.down).to.eql(0);\n          expect(participatingMember.party.quest.progress.collectedItems).to.eql(5);\n          expect(participatingMember.party.quest.completed).to.eql(null);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"applies updates to other participating members (without resetting progress, except progress.down)","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1388,"column":109,"index":53136},"line":1388,"code":"        it('applies updates to other participating members (without resetting progress, except progress.down)', async () => {\n          await party.startQuest(nonParticipatingMember);\n          questLeader = await User.findById(questLeader._id);\n          participatingMember = await User.findById(participatingMember._id);\n          sleepingParticipatingMember = await User.findById(sleepingParticipatingMember._id);\n          expect(participatingMember.party.quest.key).to.eql('whale');\n          expect(participatingMember.party.quest.progress.up).to.eql(10);\n          expect(participatingMember.party.quest.progress.down).to.eql(0);\n          expect(participatingMember.party.quest.progress.collectedItems).to.eql(5);\n          expect(participatingMember.party.quest.completed).to.eql(null);\n          expect(sleepingParticipatingMember.party.quest.key).to.eql('whale');\n          expect(sleepingParticipatingMember.party.quest.progress.up).to.eql(10);\n          expect(sleepingParticipatingMember.party.quest.progress.down).to.eql(0);\n          expect(sleepingParticipatingMember.party.quest.progress.collectedItems).to.eql(5);\n          expect(sleepingParticipatingMember.party.quest.completed).to.eql(null);\n          expect(questLeader.party.quest.key).to.eql('whale');\n          expect(questLeader.party.quest.progress.up).to.eql(10);\n          expect(questLeader.party.quest.progress.down).to.eql(0);\n          expect(questLeader.party.quest.progress.collectedItems).to.eql(5);\n          expect(questLeader.party.quest.completed).to.eql(null);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not apply updates to nonparticipating members","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1409,"column":62,"index":54656},"line":1409,"code":"        it('does not apply updates to nonparticipating members', async () => {\n          await party.startQuest(participatingMember);\n          nonParticipatingMember = await User.findById(nonParticipatingMember._id);\n          undecidedMember = await User.findById(undecidedMember._id);\n          expect(nonParticipatingMember.party.quest.key).to.not.eql('whale');\n          expect(nonParticipatingMember.party.quest.progress.up).to.eql(10);\n          expect(nonParticipatingMember.party.quest.progress.down).to.eql(8);\n          expect(nonParticipatingMember.party.quest.progress.collectedItems).to.eql(5);\n          expect(undecidedMember.party.quest.key).to.not.eql('whale');\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends email to participating members that quest has started","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1419,"column":71,"index":55357},"line":1419,"code":"        it('sends email to participating members that quest has started', async () => {\n          participatingMember.preferences.emailNotifications.questStarted = true;\n          sleepingParticipatingMember.preferences.emailNotifications.questStarted = true;\n          questLeader.preferences.emailNotifications.questStarted = true;\n          await Promise.all([participatingMember.save(), sleepingParticipatingMember.save(), questLeader.save()]);\n          await party.startQuest(nonParticipatingMember);\n          await sleep(0.5);\n          expect(email.sendTxn).to.be.calledOnce;\n\n          const memberIds = _.map(email.sendTxn.args[0][0], '_id');\n\n          const typeOfEmail = email.sendTxn.args[0][1];\n          expect(memberIds).to.have.a.lengthOf(3);\n          expect(memberIds).to.include(participatingMember._id);\n          expect(memberIds).to.include(sleepingParticipatingMember._id);\n          expect(memberIds).to.include(questLeader._id);\n          expect(typeOfEmail).to.eql('quest-started');\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends webhook to participating members that quest has started","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1437,"column":73,"index":56383},"line":1437,"code":"        it('sends webhook to participating members that quest has started', async () => {\n          // should receive webhook\n          participatingMember.webhooks = [{\n            type: 'questActivity',\n            url: 'http://someurl.com',\n            options: {\n              questStarted: true\n            }\n          }];\n          sleepingParticipatingMember.webhooks = [{\n            type: 'questActivity',\n            url: 'http://someurl.com',\n            options: {\n              questStarted: true\n            }\n          }];\n          questLeader.webhooks = [{\n            type: 'questActivity',\n            url: 'http://someurl.com',\n            options: {\n              questStarted: true\n            }\n          }];\n          await Promise.all([participatingMember.save(), sleepingParticipatingMember.save(), questLeader.save()]);\n          await party.startQuest(nonParticipatingMember);\n          await sleep(0.5);\n          expect(questActivityWebhook.send).to.be.calledThrice; // for 3 participating members\n\n          const args = questActivityWebhook.send.args[0];\n          const {\n            webhooks\n          } = args[0];\n          const webhookOwner = args[0]._id;\n          const options = args[1];\n          expect(webhooks).to.have.a.lengthOf(1);\n\n          if (webhookOwner === questLeader._id) {\n            expect(webhooks[0].id).to.eql(questLeader.webhooks[0].id);\n          } else if (webhookOwner === sleepingParticipatingMember._id) {\n            expect(webhooks[0].id).to.eql(sleepingParticipatingMember.webhooks[0].id);\n          } else {\n            expect(webhooks[0].id).to.eql(participatingMember.webhooks[0].id);\n          }\n\n          expect(webhooks[0].type).to.eql('questActivity');\n          expect(options.group).to.eql(party);\n          expect(options.quest.key).to.eql('whale');\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends email only to members who have not opted out","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1485,"column":62,"index":58215},"line":1485,"code":"        it('sends email only to members who have not opted out', async () => {\n          participatingMember.preferences.emailNotifications.questStarted = false;\n          sleepingParticipatingMember.preferences.emailNotifications.questStarted = false;\n          questLeader.preferences.emailNotifications.questStarted = true;\n          await Promise.all([participatingMember.save(), sleepingParticipatingMember.save(), questLeader.save()]);\n          await party.startQuest(nonParticipatingMember);\n          await sleep(0.5);\n          expect(email.sendTxn).to.be.calledOnce;\n\n          const memberIds = _.map(email.sendTxn.args[0][0], '_id');\n\n          expect(memberIds).to.have.a.lengthOf(1);\n          expect(memberIds).to.not.include(participatingMember._id);\n          expect(memberIds).to.not.include(sleepingParticipatingMember._id);\n          expect(memberIds).to.include(questLeader._id);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not send email to initiating member","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1501,"column":52,"index":59119},"line":1501,"code":"        it('does not send email to initiating member', async () => {\n          participatingMember.preferences.emailNotifications.questStarted = true;\n          sleepingParticipatingMember.preferences.emailNotifications.questStarted = true;\n          questLeader.preferences.emailNotifications.questStarted = true;\n          await Promise.all([participatingMember.save(), sleepingParticipatingMember.save(), questLeader.save()]);\n          await party.startQuest(participatingMember);\n          await sleep(0.5);\n          expect(email.sendTxn).to.be.calledOnce;\n\n          const memberIds = _.map(email.sendTxn.args[0][0], '_id');\n\n          expect(memberIds).to.have.a.lengthOf(2);\n          expect(memberIds).to.not.include(participatingMember._id);\n          expect(memberIds).to.include(sleepingParticipatingMember._id);\n          expect(memberIds).to.include(questLeader._id);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"updates participting members (not including user)","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1517,"column":61,"index":60023},"line":1517,"code":"        it('updates participting members (not including user)', async () => {\n          sandbox.spy(User, 'update');\n          await party.startQuest(nonParticipatingMember);\n          const members = [questLeader._id, participatingMember._id, sleepingParticipatingMember._id];\n          expect(User.update).to.be.calledWith({\n            _id: {\n              $in: members\n            }\n          }, {\n            $set: {\n              'party.quest.key': 'whale',\n              'party.quest.progress.down': 0,\n              'party.quest.completed': null\n            }\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"updates non-user quest leader and decrements quest scroll","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1533,"column":69,"index":60625},"line":1533,"code":"        it('updates non-user quest leader and decrements quest scroll', async () => {\n          sandbox.spy(User, 'update');\n          await party.startQuest(participatingMember);\n          expect(User.update).to.be.calledWith({\n            _id: questLeader._id\n          }, {\n            $inc: {\n              'items.quests.whale': -1\n            }\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"modifies the participating initiating user directly","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1544,"column":63,"index":60995},"line":1544,"code":"        it('modifies the participating initiating user directly', async () => {\n          await party.startQuest(participatingMember);\n          const userQuest = participatingMember.party.quest;\n          expect(userQuest.key).to.eql('whale');\n          expect(userQuest.progress.up).to.eql(10);\n          expect(userQuest.progress.down).to.eql(0);\n          expect(userQuest.progress.collectedItems).to.eql(5);\n          expect(userQuest.completed).to.eql(null);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"does not modify user if not participating","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1553,"column":53,"index":61462},"line":1553,"code":"        it('does not modify user if not participating', async () => {\n          await party.startQuest(nonParticipatingMember);\n          expect(nonParticipatingMember.party.quest.key).to.not.eql('whale');\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"removes the quest directly if initiating user is the quest leader","suites":["Group Model","Instance Methods","#startQuest","Successes"],"updatePoint":{"line":1557,"column":77,"index":61704},"line":1557,"code":"        it('removes the quest directly if initiating user is the quest leader', async () => {\n          await party.startQuest(questLeader);\n          expect(questLeader.items.quests.whale).to.eql(0);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"doesn't retry successful operations","suites":["Group Model","Instance Methods","#finishQuest","user update retry failures"],"updatePoint":{"line":1587,"column":48,"index":62684},"line":1587,"code":"        it('doesn\\'t retry successful operations', async () => {\n          sandbox.stub(User, 'update').returns(successfulMock);\n          await party.finishQuest(quest);\n          expect(User.update).to.be.calledThrice;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"stops retrying when a successful update has occurred","suites":["Group Model","Instance Methods","#finishQuest","user update retry failures"],"updatePoint":{"line":1592,"column":64,"index":62933},"line":1592,"code":"        it('stops retrying when a successful update has occurred', async () => {\n          const updateStub = sandbox.stub(User, 'update');\n          updateStub.onCall(0).returns(failedMock);\n          updateStub.returns(successfulMock);\n          await party.finishQuest(quest);\n          expect(User.update.callCount).to.equal(4);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"retries failed updates at most five times per user","suites":["Group Model","Instance Methods","#finishQuest","user update retry failures"],"updatePoint":{"line":1599,"column":62,"index":63276},"line":1599,"code":"        it('retries failed updates at most five times per user', async () => {\n          sandbox.stub(User, 'update').returns(failedMock);\n          await expect(party.finishQuest(quest)).to.eventually.be.rejected;\n          expect(User.update.callCount).to.eql(15); // for 3 users\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"gives out achievements","suites":["Group Model","Instance Methods","#finishQuest","user update retry failures"],"updatePoint":{"line":1605,"column":32,"index":63550},"line":1605,"code":"      it('gives out achievements', async () => {\n        await party.finishQuest(quest);\n        const [updatedLeader, updatedParticipatingMember, updatedSleepingParticipatingMember] = await Promise.all([User.findById(questLeader._id), User.findById(participatingMember._id), User.findById(sleepingParticipatingMember._id)]);\n        expect(updatedLeader.achievements.quests[quest.key]).to.eql(1);\n        expect(updatedParticipatingMember.achievements.quests[quest.key]).to.eql(1);\n        expect(updatedSleepingParticipatingMember.achievements.quests[quest.key]).to.eql(1);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"gives out super awesome Masterclasser achievement to the deserving","suites":["Group Model","Instance Methods","#finishQuest","user update retry failures"],"updatePoint":{"line":1612,"column":76,"index":64180},"line":1612,"code":"      it('gives out super awesome Masterclasser achievement to the deserving', async () => {\n        quest = questScrolls.lostMasterclasser4;\n        party.quest.key = quest.key;\n        questLeader.achievements.quests = {\n          mayhemMistiflying1: 1,\n          mayhemMistiflying2: 1,\n          mayhemMistiflying3: 1,\n          stoikalmCalamity1: 1,\n          stoikalmCalamity2: 1,\n          stoikalmCalamity3: 1,\n          taskwoodsTerror1: 1,\n          taskwoodsTerror2: 1,\n          taskwoodsTerror3: 1,\n          dilatoryDistress1: 1,\n          dilatoryDistress2: 1,\n          dilatoryDistress3: 1,\n          lostMasterclasser1: 1,\n          lostMasterclasser2: 1,\n          lostMasterclasser3: 1\n        };\n        await questLeader.save();\n        await party.finishQuest(quest);\n        const [updatedLeader, updatedParticipatingMember, updatedSleepingParticipatingMember] = await Promise.all([User.findById(questLeader._id).exec(), User.findById(participatingMember._id).exec(), User.findById(sleepingParticipatingMember._id).exec()]);\n        expect(updatedLeader.achievements.lostMasterclasser).to.eql(true);\n        expect(updatedParticipatingMember.achievements.lostMasterclasser).to.not.eql(true);\n        expect(updatedSleepingParticipatingMember.achievements.lostMasterclasser).to.not.eql(true);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"gives out super awesome Masterclasser achievement when quests done out of order","suites":["Group Model","Instance Methods","#finishQuest","user update retry failures"],"updatePoint":{"line":1639,"column":89,"index":65518},"line":1639,"code":"      it('gives out super awesome Masterclasser achievement when quests done out of order', async () => {\n        quest = questScrolls.lostMasterclasser1;\n        party.quest.key = quest.key;\n        questLeader.achievements.quests = {\n          mayhemMistiflying1: 1,\n          mayhemMistiflying2: 1,\n          mayhemMistiflying3: 1,\n          stoikalmCalamity1: 1,\n          stoikalmCalamity2: 1,\n          stoikalmCalamity3: 1,\n          taskwoodsTerror1: 1,\n          taskwoodsTerror2: 1,\n          taskwoodsTerror3: 1,\n          dilatoryDistress1: 1,\n          dilatoryDistress2: 1,\n          dilatoryDistress3: 1,\n          lostMasterclasser2: 1,\n          lostMasterclasser3: 1,\n          lostMasterclasser4: 1\n        };\n        await questLeader.save();\n        await party.finishQuest(quest);\n        await sleep(0.5);\n        const [updatedLeader, updatedParticipatingMember, updatedSleepingParticipatingMember] = await Promise.all([User.findById(questLeader._id).exec(), User.findById(participatingMember._id).exec(), User.findById(sleepingParticipatingMember._id).exec()]);\n        expect(updatedLeader.achievements.lostMasterclasser).to.eql(true);\n        expect(updatedParticipatingMember.achievements.lostMasterclasser).to.not.eql(true);\n        expect(updatedSleepingParticipatingMember.achievements.lostMasterclasser).to.not.eql(true);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"gives out other pet-related quest achievements","suites":["Group Model","Instance Methods","#finishQuest","user update retry failures"],"updatePoint":{"line":1667,"column":56,"index":66849},"line":1667,"code":"      it('gives out other pet-related quest achievements', async () => {\n        quest = questScrolls.rock;\n        party.quest.key = quest.key;\n        questLeader.achievements.quests = {\n          mayhemMistiflying1: 1,\n          yarn: 1,\n          mayhemMistiflying2: 1,\n          egg: 1,\n          mayhemMistiflying3: 1,\n          slime: 2\n        };\n        await questLeader.save();\n        await party.finishQuest(quest);\n        const [updatedLeader, updatedParticipatingMember, updatedSleepingParticipatingMember] = await Promise.all([User.findById(questLeader._id).exec(), User.findById(participatingMember._id).exec(), User.findById(sleepingParticipatingMember._id).exec()]);\n        expect(updatedLeader.achievements.mindOverMatter).to.eql(true);\n        expect(updatedParticipatingMember.achievements.mindOverMatter).to.not.eql(true);\n        expect(updatedSleepingParticipatingMember.achievements.mindOverMatter).to.not.eql(true);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"gives xp and gold","suites":["Group Model","Instance Methods","#finishQuest","user update retry failures"],"updatePoint":{"line":1685,"column":27,"index":67775},"line":1685,"code":"      it('gives xp and gold', async () => {\n        await party.finishQuest(quest);\n        const [updatedLeader, updatedParticipatingMember, updatedSleepingParticipatingMember] = await Promise.all([User.findById(questLeader._id), User.findById(participatingMember._id), User.findById(sleepingParticipatingMember._id)]);\n        expect(updatedLeader.stats.exp).to.eql(quest.drop.exp);\n        expect(updatedLeader.stats.gp).to.eql(quest.drop.gp);\n        expect(updatedParticipatingMember.stats.exp).to.eql(quest.drop.exp);\n        expect(updatedParticipatingMember.stats.gp).to.eql(quest.drop.gp);\n        expect(updatedSleepingParticipatingMember.stats.exp).to.eql(quest.drop.exp);\n        expect(updatedSleepingParticipatingMember.stats.gp).to.eql(quest.drop.gp);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"awards gear","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1696,"column":23,"index":68579},"line":1696,"code":"        it('awards gear', async () => {\n          const gearQuest = questScrolls.vice3;\n          await party.finishQuest(gearQuest);\n          const updatedParticipatingMember = await User.findById(participatingMember._id);\n          expect(updatedParticipatingMember.items.gear.owned.weapon_special_2).to.eql(true);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"awards eggs","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1702,"column":23,"index":68909},"line":1702,"code":"        it('awards eggs', async () => {\n          const eggQuest = questScrolls.vice3;\n          await party.finishQuest(eggQuest);\n          const updatedParticipatingMember = await User.findById(participatingMember._id);\n          expect(updatedParticipatingMember.items.eggs.Dragon).to.eql(2);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"awards food","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1708,"column":23,"index":69218},"line":1708,"code":"        it('awards food', async () => {\n          const foodQuest = questScrolls.moonstone3;\n          await party.finishQuest(foodQuest);\n          const updatedParticipatingMember = await User.findById(participatingMember._id);\n          expect(updatedParticipatingMember.items.food.RottenMeat).to.eql(5);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"awards hatching potions","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1714,"column":35,"index":69550},"line":1714,"code":"        it('awards hatching potions', async () => {\n          const hatchingPotionQuest = questScrolls.vice3;\n          await party.finishQuest(hatchingPotionQuest);\n          const updatedParticipatingMember = await User.findById(participatingMember._id);\n          expect(updatedParticipatingMember.items.hatchingPotions.Shade).to.eql(2);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"awards quest scrolls to owner","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1720,"column":41,"index":69909},"line":1720,"code":"        it('awards quest scrolls to owner', async () => {\n          const questAwardQuest = questScrolls.vice2;\n          await party.finishQuest(questAwardQuest);\n          const updatedLeader = await User.findById(questLeader._id);\n          expect(updatedLeader.items.quests.vice3).to.eql(1);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"awards non quest leader rewards to quest leader","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1726,"column":59,"index":70235},"line":1726,"code":"        it('awards non quest leader rewards to quest leader', async () => {\n          const gearQuest = questScrolls.vice3;\n          await party.finishQuest(gearQuest);\n          const updatedLeader = await User.findById(questLeader._id);\n          expect(updatedLeader.items.gear.owned.weapon_special_2).to.eql(true);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"doesn't award quest owner rewards to all participants","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1732,"column":66,"index":70574},"line":1732,"code":"        it('doesn\\'t award quest owner rewards to all participants', async () => {\n          const questAwardQuest = questScrolls.vice2;\n          await party.finishQuest(questAwardQuest);\n          const updatedParticipatingMember = await User.findById(participatingMember._id);\n          expect(updatedParticipatingMember.items.quests.vice3).to.not.exist;\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"awards pets","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1738,"column":23,"index":70901},"line":1738,"code":"        it('awards pets', async () => {\n          const petQuest = questScrolls.evilsanta2;\n          await party.finishQuest(petQuest);\n          const updatedParticipatingMember = await User.findById(participatingMember._id);\n          expect(updatedParticipatingMember.items.pets['BearCub-Polar']).to.eql(5);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"awards mounts","suites":["Group Model","Instance Methods","#finishQuest","drops"],"updatePoint":{"line":1744,"column":25,"index":71227},"line":1744,"code":"        it('awards mounts', async () => {\n          const mountQuest = questScrolls.evilsanta;\n          await party.finishQuest(mountQuest);\n          const updatedParticipatingMember = await User.findById(participatingMember._id);\n          expect(updatedParticipatingMember.items.mounts['BearCub-Polar']).to.eql(true);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"updates participating members with rewards","suites":["Group Model","Instance Methods","#finishQuest","Party quests"],"updatePoint":{"line":1752,"column":54,"index":71638},"line":1752,"code":"        it('updates participating members with rewards', async () => {\n          sandbox.spy(User, 'update');\n          await party.finishQuest(quest);\n          expect(User.update).to.be.calledThrice;\n          expect(User.update).to.be.calledWithMatch({\n            _id: questLeader._id\n          });\n          expect(User.update).to.be.calledWithMatch({\n            _id: participatingMember._id\n          });\n          expect(User.update).to.be.calledWithMatch({\n            _id: sleepingParticipatingMember._id\n          });\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"updates participating members quest object to a clean state (except for progress)","suites":["Group Model","Instance Methods","#finishQuest","Party quests"],"updatePoint":{"line":1766,"column":93,"index":72218},"line":1766,"code":"        it('updates participating members quest object to a clean state (except for progress)', async () => {\n          await party.finishQuest(quest);\n          questLeader = await User.findById(questLeader._id);\n          participatingMember = await User.findById(participatingMember._id);\n          expect(questLeader.party.quest.completed).to.eql('armadillo');\n          expect(questLeader.party.quest.progress.up).to.eql(10);\n          expect(questLeader.party.quest.progress.down).to.eql(8);\n          expect(questLeader.party.quest.progress.collectedItems).to.eql(5);\n          expect(questLeader.party.quest.RSVPNeeded).to.eql(false);\n          expect(participatingMember.party.quest.completed).to.eql('armadillo');\n          expect(participatingMember.party.quest.progress.up).to.eql(10);\n          expect(participatingMember.party.quest.progress.down).to.eql(8);\n          expect(participatingMember.party.quest.progress.collectedItems).to.eql(5);\n          expect(participatingMember.party.quest.RSVPNeeded).to.eql(false);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends webhook to participating members that quest has finished","suites":["Group Model","Instance Methods","#finishQuest","Party quests"],"updatePoint":{"line":1782,"column":72,"index":73253},"line":1782,"code":"      it('sends webhook to participating members that quest has finished', async () => {\n        // should receive webhook\n        participatingMember.webhooks = [{\n          type: 'questActivity',\n          url: 'http://someurl.com',\n          options: {\n            questFinished: true\n          }\n        }];\n        questLeader.webhooks = [{\n          type: 'questActivity',\n          url: 'http://someurl.com',\n          options: {\n            questStarted: true // will not receive the webhook\n\n          }\n        }];\n        await Promise.all([participatingMember.save(), sleepingParticipatingMember.save(), questLeader.save()]);\n        await party.finishQuest(quest);\n        await sleep(0.5);\n        expect(questActivityWebhook.send).to.be.calledOnce;\n        const args = questActivityWebhook.send.args[0];\n        const {\n          webhooks\n        } = args[0];\n        const options = args[1];\n        expect(webhooks).to.have.a.lengthOf(1);\n        expect(webhooks[0].id).to.eql(participatingMember.webhooks[0].id);\n        expect(webhooks[0].type).to.eql('questActivity');\n        expect(options.group).to.eql(party);\n        expect(options.quest.key).to.eql(quest.key);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"updates all users with rewards","suites":["Group Model","Instance Methods","#finishQuest","World quests in Tavern"],"updatePoint":{"line":1821,"column":42,"index":74659},"line":1821,"code":"        it('updates all users with rewards', async () => {\n          sandbox.spy(User, 'update');\n          await party.finishQuest(tavernQuest);\n          expect(User.update).to.be.calledOnce;\n          expect(User.update).to.be.calledWithMatch({});\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sets quest completed to the world quest key","suites":["Group Model","Instance Methods","#finishQuest","World quests in Tavern"],"updatePoint":{"line":1827,"column":55,"index":74935},"line":1827,"code":"        it('sets quest completed to the world quest key', async () => {\n          await party.finishQuest(tavernQuest);\n          const updatedLeader = await User.findById(questLeader._id);\n          expect(updatedLeader.party.quest.completed).to.eql(tavernQuest.key);\n        });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"looks for users in specified guild with webhooks","suites":["Group Model","Instance Methods","sendGroupChatReceivedWebhooks"],"updatePoint":{"line":1838,"column":58,"index":75382},"line":1838,"code":"      it('looks for users in specified guild with webhooks', () => {\n        sandbox.spy(User, 'find');\n        const guild = new Group({\n          type: 'guild'\n        });\n        guild.sendGroupChatReceivedWebhooks({});\n        expect(User.find).to.be.calledWith({\n          webhooks: {\n            $elemMatch: {\n              type: 'groupChatReceived',\n              'options.groupId': guild._id\n            }\n          },\n          guilds: guild._id\n        });\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"looks for users in specified party with webhooks","suites":["Group Model","Instance Methods","sendGroupChatReceivedWebhooks"],"updatePoint":{"line":1854,"column":58,"index":75859},"line":1854,"code":"      it('looks for users in specified party with webhooks', () => {\n        sandbox.spy(User, 'find');\n        party.sendGroupChatReceivedWebhooks({});\n        expect(User.find).to.be.calledWith({\n          webhooks: {\n            $elemMatch: {\n              type: 'groupChatReceived',\n              'options.groupId': party._id\n            }\n          },\n          'party._id': party._id\n        });\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends webhooks for users with webhooks","suites":["Group Model","Instance Methods","sendGroupChatReceivedWebhooks"],"updatePoint":{"line":1867,"column":48,"index":76261},"line":1867,"code":"      it('sends webhooks for users with webhooks', async () => {\n        const guild = new Group({\n          name: 'some guild',\n          type: 'guild'\n        });\n        const chat = {\n          message: 'text'\n        };\n        const memberWithWebhook = new User({\n          guilds: [guild._id],\n          webhooks: [{\n            type: 'groupChatReceived',\n            url: 'http://someurl.com',\n            options: {\n              groupId: guild._id\n            }\n          }]\n        });\n        const memberWithoutWebhook = new User({\n          guilds: [guild._id]\n        });\n        const nonMemberWithWebhooks = new User({\n          webhooks: [{\n            type: 'groupChatReceived',\n            url: 'http://a-different-url.com',\n            options: {\n              groupId: generateUUID()\n            }\n          }]\n        });\n        await Promise.all([memberWithWebhook.save(), memberWithoutWebhook.save(), nonMemberWithWebhooks.save()]);\n        guild.leader = memberWithWebhook._id;\n        await guild.save();\n        guild.sendGroupChatReceivedWebhooks(chat);\n        await sleep();\n        expect(groupChatReceivedWebhook.send).to.be.calledOnce;\n        const args = groupChatReceivedWebhook.send.args[0];\n        const {\n          webhooks\n        } = args[0];\n        const options = args[1];\n        expect(webhooks).to.have.a.lengthOf(1);\n        expect(webhooks[0].id).to.eql(memberWithWebhook.webhooks[0].id);\n        expect(options.group).to.eql(guild);\n        expect(options.chat).to.eql(chat);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends webhooks for users with webhooks triggered by system messages","suites":["Group Model","Instance Methods","sendGroupChatReceivedWebhooks"],"updatePoint":{"line":1913,"column":77,"index":77829},"line":1913,"code":"      it('sends webhooks for users with webhooks triggered by system messages', async () => {\n        const guild = new Group({\n          name: 'some guild',\n          type: 'guild'\n        });\n        const memberWithWebhook = new User({\n          guilds: [guild._id],\n          webhooks: [{\n            type: 'groupChatReceived',\n            url: 'http://someurl.com',\n            options: {\n              groupId: guild._id\n            }\n          }]\n        });\n        const memberWithoutWebhook = new User({\n          guilds: [guild._id]\n        });\n        const nonMemberWithWebhooks = new User({\n          webhooks: [{\n            type: 'groupChatReceived',\n            url: 'http://a-different-url.com',\n            options: {\n              groupId: generateUUID()\n            }\n          }]\n        });\n        await Promise.all([memberWithWebhook.save(), memberWithoutWebhook.save(), nonMemberWithWebhooks.save()]);\n        guild.leader = memberWithWebhook._id;\n        await guild.save();\n        const groupMessage = guild.sendChat({\n          message: 'Test message.'\n        });\n        await groupMessage.save();\n        await sleep();\n        expect(groupChatReceivedWebhook.send).to.be.calledOnce;\n        const args = groupChatReceivedWebhook.send.args[0];\n        const {\n          webhooks\n        } = args[0];\n        const options = args[1];\n        expect(webhooks).to.have.a.lengthOf(1);\n        expect(webhooks[0].id).to.eql(memberWithWebhook.webhooks[0].id);\n        expect(options.group).to.eql(guild);\n        expect(options.chat).to.eql(groupMessage);\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"sends webhooks for each user with webhooks in group","suites":["Group Model","Instance Methods","sendGroupChatReceivedWebhooks"],"updatePoint":{"line":1959,"column":61,"index":79406},"line":1959,"code":"      it('sends webhooks for each user with webhooks in group', async () => {\n        const guild = new Group({\n          name: 'some guild',\n          type: 'guild'\n        });\n        const chat = {\n          message: 'text'\n        };\n        const memberWithWebhook = new User({\n          guilds: [guild._id],\n          webhooks: [{\n            type: 'groupChatReceived',\n            url: 'http://someurl.com',\n            options: {\n              groupId: guild._id\n            }\n          }]\n        });\n        const memberWithWebhook2 = new User({\n          guilds: [guild._id],\n          webhooks: [{\n            type: 'groupChatReceived',\n            url: 'http://another-member.com',\n            options: {\n              groupId: guild._id\n            }\n          }]\n        });\n        const memberWithWebhook3 = new User({\n          guilds: [guild._id],\n          webhooks: [{\n            type: 'groupChatReceived',\n            url: 'http://a-third-member.com',\n            options: {\n              groupId: guild._id\n            }\n          }]\n        });\n        await Promise.all([memberWithWebhook.save(), memberWithWebhook2.save(), memberWithWebhook3.save()]);\n        guild.leader = memberWithWebhook._id;\n        await guild.save();\n        guild.sendGroupChatReceivedWebhooks(chat);\n        await sleep();\n        expect(groupChatReceivedWebhook.send).to.be.calledThrice;\n        const {\n          args\n        } = groupChatReceivedWebhook.send;\n        expect(args.find(arg => arg[0].webhooks[0].id === memberWithWebhook.webhooks[0].id)).to.be.exist;\n        expect(args.find(arg => arg[0].webhooks[0].id === memberWithWebhook2.webhooks[0].id)).to.be.exist;\n        expect(args.find(arg => arg[0].webhooks[0].id === memberWithWebhook3.webhooks[0].id)).to.be.exist;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns false if group does not have customer id","suites":["Group Model","Instance Methods","hasActiveGroupPlan"],"updatePoint":{"line":2012,"column":58,"index":81250},"line":2012,"code":"      it('returns false if group does not have customer id', () => {\n        expect(party.hasActiveGroupPlan()).to.be.undefined;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns true if group does not have plan.dateTerminated","suites":["Group Model","Instance Methods","hasActiveGroupPlan"],"updatePoint":{"line":2015,"column":65,"index":81396},"line":2015,"code":"      it('returns true if group does not have plan.dateTerminated', () => {\n        party.purchased.plan.customerId = 'test-id';\n        expect(party.hasActiveGroupPlan()).to.be.true;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns true if group if plan.dateTerminated is after today","suites":["Group Model","Instance Methods","hasActiveGroupPlan"],"updatePoint":{"line":2019,"column":69,"index":81594},"line":2019,"code":"      it('returns true if group if plan.dateTerminated is after today', () => {\n        party.purchased.plan.customerId = 'test-id';\n        party.purchased.plan.dateTerminated = moment().add(1, 'days').toDate();\n        expect(party.hasActiveGroupPlan()).to.be.true;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns false if group if plan.dateTerminated is before today","suites":["Group Model","Instance Methods","hasActiveGroupPlan"],"updatePoint":{"line":2024,"column":71,"index":81874},"line":2024,"code":"      it('returns false if group if plan.dateTerminated is before today', () => {\n        party.purchased.plan.customerId = 'test-id';\n        party.purchased.plan.dateTerminated = moment().subtract(1, 'days').toDate();\n        expect(party.hasActiveGroupPlan()).to.be.false;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns false if group does not have customer id","suites":["Group Model","Instance Methods","hasNotCancelled"],"updatePoint":{"line":2031,"column":58,"index":82194},"line":2031,"code":"      it('returns false if group does not have customer id', () => {\n        expect(party.hasNotCancelled()).to.be.false;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns true if group does not have plan.dateTerminated","suites":["Group Model","Instance Methods","hasNotCancelled"],"updatePoint":{"line":2034,"column":65,"index":82333},"line":2034,"code":"      it('returns true if group does not have plan.dateTerminated', () => {\n        party.purchased.plan.customerId = 'test-id';\n        expect(party.hasNotCancelled()).to.be.true;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns false if group if plan.dateTerminated is after today","suites":["Group Model","Instance Methods","hasNotCancelled"],"updatePoint":{"line":2038,"column":70,"index":82529},"line":2038,"code":"      it('returns false if group if plan.dateTerminated is after today', () => {\n        party.purchased.plan.customerId = 'test-id';\n        party.purchased.plan.dateTerminated = moment().add(1, 'days').toDate();\n        expect(party.hasNotCancelled()).to.be.false;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns false if group if plan.dateTerminated is before today","suites":["Group Model","Instance Methods","hasNotCancelled"],"updatePoint":{"line":2043,"column":71,"index":82807},"line":2043,"code":"      it('returns false if group if plan.dateTerminated is before today', () => {\n        party.purchased.plan.customerId = 'test-id';\n        party.purchased.plan.dateTerminated = moment().subtract(1, 'days').toDate();\n        expect(party.hasNotCancelled()).to.be.false;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns false if group does not have customer id","suites":["Group Model","Instance Methods","hasCancelled"],"updatePoint":{"line":2050,"column":58,"index":83121},"line":2050,"code":"      it('returns false if group does not have customer id', () => {\n        expect(party.hasCancelled()).to.be.false;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns false if group does not have plan.dateTerminated","suites":["Group Model","Instance Methods","hasCancelled"],"updatePoint":{"line":2053,"column":66,"index":83258},"line":2053,"code":"      it('returns false if group does not have plan.dateTerminated', () => {\n        party.purchased.plan.customerId = 'test-id';\n        expect(party.hasCancelled()).to.be.false;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns true if group if plan.dateTerminated is after today","suites":["Group Model","Instance Methods","hasCancelled"],"updatePoint":{"line":2057,"column":69,"index":83451},"line":2057,"code":"      it('returns true if group if plan.dateTerminated is after today', () => {\n        party.purchased.plan.customerId = 'test-id';\n        party.purchased.plan.dateTerminated = moment().add(1, 'days').toDate();\n        expect(party.hasCancelled()).to.be.true;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"returns false if group if plan.dateTerminated is before today","suites":["Group Model","Instance Methods","hasCancelled"],"updatePoint":{"line":2062,"column":71,"index":83725},"line":2062,"code":"      it('returns false if group if plan.dateTerminated is before today', () => {\n        party.purchased.plan.customerId = 'test-id';\n        party.purchased.plan.dateTerminated = moment().subtract(1, 'days').toDate();\n        expect(party.hasCancelled()).to.be.false;\n      });","file":"api/unit/models/group.test.js","skipped":false,"dir":"test"},{"name":"trims messages to the max length","suites":["Message Model","sanitizeText"],"updatePoint":{"line":5,"column":40,"index":265},"line":5,"code":"    it('trims messages to the max length', () => {\n      const veryLongMessage = `\n      123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789.\n      THIS PART WON'T BE IN THE MESSAGE (over 3000)\n      `;\n      expect(veryLongMessage.length > MAX_MESSAGE_LENGTH).to.equal(true);\n      const sanitizedText = sanitizeText(veryLongMessage);\n      expect(sanitizedText).to.not.contain('MESSAGE');\n      expect(sanitizedText.length).to.equal(MAX_MESSAGE_LENGTH);\n    });","file":"api/unit/models/message.test.js","skipped":false,"dir":"test"},{"name":"converts an array of push devices to a safe version","suites":["PushDevice Model","cleanupCorruptData"],"updatePoint":{"line":4,"column":59,"index":221},"line":4,"code":"    it('converts an array of push devices to a safe version', () => {\n      const pushDevices = [null, // invalid, not an object\n      {\n        regId: '123'\n      }, // invalid, no type\n      {\n        type: 'android'\n      }, // invalid, no regId\n      new PushDevice({\n        type: 'android',\n        regId: '1234'\n      }) // valid\n      ];\n      const safePushDevices = PushDevice.cleanupCorruptData(pushDevices);\n      expect(safePushDevices.length).to.equal(1);\n      expect(safePushDevices[0].type).to.equal('android');\n      expect(safePushDevices[0].regId).to.equal('1234');\n    });","file":"api/unit/models/pushDevice.test.js","skipped":false,"dir":"test"},{"name":"removes duplicates","suites":["PushDevice Model","cleanupCorruptData"],"updatePoint":{"line":22,"column":26,"index":782},"line":22,"code":"    it('removes duplicates', () => {\n      const pushDevices = [new PushDevice({\n        type: 'android',\n        regId: '1234'\n      }), new PushDevice({\n        type: 'android',\n        regId: '1234'\n      }), new PushDevice({\n        type: 'iphone',\n        regId: '1234'\n      }), // not duplicate\n      new PushDevice({\n        type: 'android',\n        regId: '12345'\n      }) // not duplicate\n      ];\n      const safePushDevices = PushDevice.cleanupCorruptData(pushDevices);\n      expect(safePushDevices.length).to.equal(3);\n      expect(safePushDevices[0].type).to.equal('android');\n      expect(safePushDevices[0].regId).to.equal('1234');\n    });","file":"api/unit/models/pushDevice.test.js","skipped":false,"dir":"test"},{"name":"converts an array of tags to a safe version","suites":["Tag Model","cleanupCorruptData"],"updatePoint":{"line":4,"column":51,"index":192},"line":4,"code":"    it('converts an array of tags to a safe version', () => {\n      const tags = [null, // invalid, not an object\n      {\n        name: '123'\n      }, // invalid, no id\n      {\n        id: '123'\n      }, // invalid, no name\n      new Tag({\n        name: 'ABC',\n        id: 123\n      }) // valid\n      ];\n      const safetags = Tag.cleanupCorruptData(tags);\n      expect(safetags.length).to.equal(1);\n      expect(safetags[0].name).to.equal('ABC');\n      expect(safetags[0].id).to.equal('123');\n    });","file":"api/unit/models/tag.test.js","skipped":false,"dir":"test"},{"name":"preens challenge tasks history when scored","suites":["Task Model",""],"updatePoint":{"line":53,"column":52,"index":1567},"line":53,"code":"      it('preens challenge tasks history when scored', async () => {\n        const historyLengthBeforePreen = task.history.length;\n        await task.scoreChallengeTask(1.2);\n        const updatedTask = await Tasks.Task.findOne({\n          _id: task._id\n        });\n        expect(historyLengthBeforePreen).to.be.greaterThan(updatedTask.history.length);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"throws an error if task identifier is not passed in","suites":["Task Model","Static Methods","findByIdOrAlias"],"updatePoint":{"line":79,"column":61,"index":2427},"line":79,"code":"      it('throws an error if task identifier is not passed in', async () => {\n        try {\n          await Tasks.Task.findByIdOrAlias(null, user._id);\n          throw new Error('No exception when Id is None');\n        } catch (err) {\n          expect(err).to.exist;\n          expect(err).to.be.an.instanceOf(Error);\n          expect(err.message).to.eql('Task identifier is a required argument');\n        }\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"throws an error if user identifier is not passed in","suites":["Task Model","Static Methods","findByIdOrAlias"],"updatePoint":{"line":89,"column":61,"index":2844},"line":89,"code":"      it('throws an error if user identifier is not passed in', async () => {\n        try {\n          await Tasks.Task.findByIdOrAlias(taskWithAlias._id);\n          throw new Error('No exception when user_id is undefined');\n        } catch (err) {\n          expect(err).to.exist;\n          expect(err).to.be.an.instanceOf(Error);\n          expect(err.message).to.eql('User identifier is a required argument');\n        }\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"returns task by id","suites":["Task Model","Static Methods","findByIdOrAlias"],"updatePoint":{"line":99,"column":28,"index":3241},"line":99,"code":"      it('returns task by id', async () => {\n        const foundTodo = await Tasks.Task.findByIdOrAlias(taskWithAlias._id, user._id);\n        expect(foundTodo.text).to.eql(taskWithAlias.text);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"returns task by alias","suites":["Task Model","Static Methods","findByIdOrAlias"],"updatePoint":{"line":103,"column":31,"index":3447},"line":103,"code":"      it('returns task by alias', async () => {\n        const foundTodo = await Tasks.Task.findByIdOrAlias(taskWithAlias.alias, user._id);\n        expect(foundTodo.text).to.eql(taskWithAlias.text);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"scopes alias lookup to user","suites":["Task Model","Static Methods","findByIdOrAlias"],"updatePoint":{"line":107,"column":37,"index":3661},"line":107,"code":"      it('scopes alias lookup to user', async () => {\n        await Tasks.Task.findByIdOrAlias(taskWithAlias.alias, user._id);\n        expect(Tasks.Task.findOne).to.be.calledOnce;\n        expect(Tasks.Task.findOne).to.be.calledWithMatch({\n          alias: taskWithAlias.alias,\n          userId: user._id\n        });\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"returns null if task cannot be found","suites":["Task Model","Static Methods","findByIdOrAlias"],"updatePoint":{"line":115,"column":46,"index":3996},"line":115,"code":"      it('returns null if task cannot be found', async () => {\n        const foundTask = await Tasks.Task.findByIdOrAlias('not-found', user._id);\n        expect(foundTask).to.eql(null);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"accepts additional query parameters","suites":["Task Model","Static Methods","findByIdOrAlias"],"updatePoint":{"line":119,"column":45,"index":4191},"line":119,"code":"      it('accepts additional query parameters', async () => {\n        await Tasks.Task.findByIdOrAlias(taskWithAlias.alias, user._id, {\n          foo: 'bar'\n        });\n        expect(Tasks.Task.findOne).to.be.calledOnce;\n        expect(Tasks.Task.findOne).to.be.calledWithMatch({\n          foo: 'bar',\n          alias: taskWithAlias.alias,\n          userId: user._id\n        });\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"throws an error if task identifiers is not passed in","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":154,"column":62,"index":5289},"line":154,"code":"      it('throws an error if task identifiers is not passed in', async () => {\n        try {\n          await Tasks.Task.findMultipleByIdOrAlias(null, user._id);\n          throw new Error('No exception when Id is None');\n        } catch (err) {\n          expect(err).to.exist;\n          expect(err).to.be.an.instanceOf(Error);\n          expect(err.message).to.eql('Task identifiers is a required array argument');\n        }\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"throws an error if task identifiers is not an array","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":164,"column":61,"index":5721},"line":164,"code":"      it('throws an error if task identifiers is not an array', async () => {\n        try {\n          await Tasks.Task.findMultipleByIdOrAlias('string', user._id);\n          throw new Error('No exception when Id is None');\n        } catch (err) {\n          expect(err).to.exist;\n          expect(err).to.be.an.instanceOf(Error);\n          expect(err.message).to.eql('Task identifiers is a required array argument');\n        }\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"throws an error if user identifier is not passed in","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":174,"column":61,"index":6157},"line":174,"code":"      it('throws an error if user identifier is not passed in', async () => {\n        try {\n          await Tasks.Task.findMultipleByIdOrAlias([taskWithAlias._id]);\n          throw new Error('No exception when user_id is undefined');\n        } catch (err) {\n          expect(err).to.exist;\n          expect(err).to.be.an.instanceOf(Error);\n          expect(err.message).to.eql('User identifier is a required argument');\n        }\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"returns task by id","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":184,"column":28,"index":6564},"line":184,"code":"      it('returns task by id', async () => {\n        const foundTasks = await Tasks.Task.findMultipleByIdOrAlias([taskWithAlias._id], user._id);\n        expect(foundTasks[0].text).to.eql(taskWithAlias.text);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"returns task by alias","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":188,"column":31,"index":6785},"line":188,"code":"      it('returns task by alias', async () => {\n        const foundTasks = await Tasks.Task.findMultipleByIdOrAlias([taskWithAlias.alias], user._id);\n        expect(foundTasks[0].text).to.eql(taskWithAlias.text);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"returns multiple tasks","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":192,"column":32,"index":7009},"line":192,"code":"      it('returns multiple tasks', async () => {\n        const foundTasks = await Tasks.Task.findMultipleByIdOrAlias([taskWithAlias.alias, secondTask._id], user._id);\n        expect(foundTasks.length).to.eql(2);\n        expect(foundTasks[0]._id).to.eql(taskWithAlias._id);\n        expect(foundTasks[1]._id).to.eql(secondTask._id);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"returns a task only once if searched by both id and alias","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":198,"column":67,"index":7385},"line":198,"code":"      it('returns a task only once if searched by both id and alias', async () => {\n        const foundTasks = await Tasks.Task.findMultipleByIdOrAlias([taskWithAlias.alias, taskWithAlias._id], user._id);\n        expect(foundTasks.length).to.eql(1);\n        expect(foundTasks[0].text).to.eql(taskWithAlias.text);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"scopes alias lookup to user","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":203,"column":37,"index":7678},"line":203,"code":"      it('scopes alias lookup to user', async () => {\n        await Tasks.Task.findMultipleByIdOrAlias([taskWithAlias.alias], user._id);\n        expect(Tasks.Task.find).to.be.calledOnce;\n        expect(Tasks.Task.find).to.be.calledWithMatch({\n          $or: [{\n            _id: {\n              $in: []\n            }\n          }, {\n            alias: {\n              $in: [taskWithAlias.alias]\n            }\n          }],\n          userId: user._id\n        });\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"returns empty array if tasks cannot be found","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":219,"column":54,"index":8165},"line":219,"code":"      it('returns empty array if tasks cannot be found', async () => {\n        const foundTasks = await Tasks.Task.findMultipleByIdOrAlias(['not-found'], user._id);\n        expect(foundTasks).to.eql([]);\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"accepts additional query parameters","suites":["Task Model","Static Methods","findMultipleByIdOrAlias"],"updatePoint":{"line":223,"column":45,"index":8370},"line":223,"code":"      it('accepts additional query parameters', async () => {\n        await Tasks.Task.findMultipleByIdOrAlias([taskWithAlias.alias], user._id, {\n          foo: 'bar'\n        });\n        expect(Tasks.Task.find).to.be.calledOnce;\n        expect(Tasks.Task.find).to.be.calledWithMatch({\n          $or: [{\n            _id: {\n              $in: []\n            }\n          }, {\n            alias: {\n              $in: [taskWithAlias.alias]\n            }\n          }],\n          userId: user._id,\n          foo: 'bar'\n        });\n      });","file":"api/unit/models/task.test.js","skipped":false,"dir":"test"},{"name":"keeps user._tmp when calling .toJSON","suites":["User Model",".toJSON()"],"updatePoint":{"line":8,"column":44,"index":412},"line":8,"code":"    it('keeps user._tmp when calling .toJSON', () => {\n      const user = new User({\n        auth: {\n          local: {\n            username: 'username',\n            lowerCaseUsername: 'username',\n            email: 'email@email.email',\n            salt: 'salt',\n            hashed_password: 'hashed_password' // eslint-disable-line camelcase\n\n          }\n        }\n      });\n      user._tmp = {\n        ok: true\n      };\n      user._nonTmp = {\n        ok: true\n      };\n      expect(user._tmp).to.eql({\n        ok: true\n      });\n      expect(user._nonTmp).to.eql({\n        ok: true\n      });\n      const toObject = user.toObject();\n      const toJSON = user.toJSON();\n      expect(toObject).to.not.have.keys('_tmp');\n      expect(toObject).to.not.have.keys('_nonTmp');\n      expect(toJSON).to.have.any.key('_tmp');\n      expect(toJSON._tmp).to.eql({\n        ok: true\n      });\n      expect(toJSON).to.not.have.keys('_nonTmp');\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"can add computed stats to a JSONified user object","suites":["User Model",".toJSON()"],"updatePoint":{"line":43,"column":57,"index":1362},"line":43,"code":"    it('can add computed stats to a JSONified user object', () => {\n      const user = new User();\n      const userToJSON = user.toJSON();\n      expect(userToJSON.stats.maxMP).to.not.exist;\n      expect(userToJSON.stats.maxHealth).to.not.exist;\n      expect(userToJSON.stats.toNextLevel).to.not.exist;\n      User.addComputedStatsToJSONObj(userToJSON.stats, userToJSON);\n      expect(userToJSON.stats.maxMP).to.exist;\n      expect(userToJSON.stats.maxHealth).to.equal(common.maxHealth);\n      expect(userToJSON.stats.toNextLevel).to.equal(common.tnl(user.stats.lvl));\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"can transform user object without mongoose helpers","suites":["User Model",".toJSON()"],"updatePoint":{"line":54,"column":58,"index":1938},"line":54,"code":"    it('can transform user object without mongoose helpers', async () => {\n      const user = new User();\n      await user.save();\n      const userToJSON = await User.findById(user._id).lean().exec();\n      expect(userToJSON.stats.maxMP).to.not.exist;\n      expect(userToJSON.stats.maxHealth).to.not.exist;\n      expect(userToJSON.stats.toNextLevel).to.not.exist;\n      expect(userToJSON.id).to.not.exist;\n      User.transformJSONUser(userToJSON);\n      expect(userToJSON.id).to.equal(userToJSON._id);\n      expect(userToJSON.stats.maxMP).to.not.exist;\n      expect(userToJSON.stats.maxHealth).to.not.exist;\n      expect(userToJSON.stats.toNextLevel).to.not.exist;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"can transform user object without mongoose helpers (including computed stats)","suites":["User Model",".toJSON()"],"updatePoint":{"line":68,"column":85,"index":2638},"line":68,"code":"    it('can transform user object without mongoose helpers (including computed stats)', async () => {\n      const user = new User();\n      await user.save();\n      const userToJSON = await User.findById(user._id).lean().exec();\n      expect(userToJSON.stats.maxMP).to.not.exist;\n      expect(userToJSON.stats.maxHealth).to.not.exist;\n      expect(userToJSON.stats.toNextLevel).to.not.exist;\n      User.transformJSONUser(userToJSON, true);\n      expect(userToJSON.id).to.equal(userToJSON._id);\n      expect(userToJSON.stats.maxMP).to.exist;\n      expect(userToJSON.stats.maxHealth).to.equal(common.maxHealth);\n      expect(userToJSON.stats.toNextLevel).to.equal(common.tnl(user.stats.lvl));\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"can add an achievement","suites":["User Model","achievements"],"updatePoint":{"line":83,"column":30,"index":3321},"line":83,"code":"    it('can add an achievement', () => {\n      const user = new User();\n      const originalUserToJSON = user.toJSON({\n        minimize: false\n      });\n      expect(originalUserToJSON.achievements.createdTask).to.not.eql(true);\n      const notificationsN = originalUserToJSON.notifications.length;\n      user.addAchievement('createdTask');\n      const userToJSON = user.toJSON();\n      expect(user.notifications.length).to.equal(notificationsN + 1);\n      expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n      expect(userToJSON.notifications[0].type).to.equal('ACHIEVEMENT');\n      expect(userToJSON.notifications[0].data).to.eql({\n        achievement: 'createdTask'\n      });\n      expect(userToJSON.notifications[0].seen).to.eql(false);\n      expect(userToJSON.achievements.createdTask).to.eql(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the achievement is not valid","suites":["User Model","achievements"],"updatePoint":{"line":101,"column":55,"index":4196},"line":101,"code":"    it('throws an error if the achievement is not valid', () => {\n      const user = new User();\n      expect(() => user.addAchievement('notAnAchievement')).to.throw;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the achievement is not valid","suites":["User Model","achievements","static push method"],"updatePoint":{"line":106,"column":57,"index":4415},"line":106,"code":"      it('throws an error if the achievement is not valid', async () => {\n        const user = new User();\n        await user.save();\n        await expect(User.addAchievementUpdate({\n          _id: user._id\n        }, 'notAnAchievement')).to.eventually.be.rejected;\n        expect(() => user.addAchievement('notAnAchievement')).to.throw;\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"adds an achievement for a single member via static method","suites":["User Model","achievements","static push method"],"updatePoint":{"line":114,"column":67,"index":4773},"line":114,"code":"      it('adds an achievement for a single member via static method', async () => {\n        let user = new User();\n        await user.save();\n        const originalUserToJSON = user.toJSON({\n          minimize: false\n        });\n        expect(originalUserToJSON.achievements.createdTask).to.not.eql(true);\n        const notificationsN = originalUserToJSON.notifications.length;\n        await User.addAchievementUpdate({\n          _id: user._id\n        }, 'createdTask');\n        user = await User.findOne({\n          _id: user._id\n        }).exec();\n        const userToJSON = user.toJSON();\n        expect(user.notifications.length).to.equal(notificationsN + 1);\n        expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n        expect(userToJSON.notifications[0].type).to.equal('ACHIEVEMENT');\n        expect(userToJSON.notifications[0].data).to.eql({\n          achievement: 'createdTask'\n        });\n        expect(userToJSON.notifications[0].seen).to.eql(false);\n        expect(userToJSON.achievements.createdTask).to.eql(true);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"adds an achievement for all given users via static method","suites":["User Model","achievements","static push method"],"updatePoint":{"line":138,"column":67,"index":5853},"line":138,"code":"      it('adds an achievement for all given users via static method', async () => {\n        let user = new User();\n        const otherUser = new User();\n        await Promise.all([user.save(), otherUser.save()]);\n        await User.addAchievementUpdate({\n          _id: {\n            $in: [user._id, otherUser._id]\n          }\n        }, 'createdTask');\n        user = await User.findOne({\n          _id: user._id\n        }).exec();\n        let userToJSON = user.toJSON();\n        expect(user.notifications.length).to.equal(1);\n        expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n        expect(userToJSON.notifications[0].type).to.equal('ACHIEVEMENT');\n        expect(userToJSON.notifications[0].data).to.eql({\n          achievement: 'createdTask'\n        });\n        expect(userToJSON.notifications[0].seen).to.eql(false);\n        expect(userToJSON.achievements.createdTask).to.eql(true);\n        user = await User.findOne({\n          _id: otherUser._id\n        }).exec();\n        userToJSON = user.toJSON();\n        expect(user.notifications.length).to.equal(1);\n        expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n        expect(userToJSON.notifications[0].type).to.equal('ACHIEVEMENT');\n        expect(userToJSON.notifications[0].data).to.eql({\n          achievement: 'createdTask'\n        });\n        expect(userToJSON.notifications[0].seen).to.eql(false);\n        expect(userToJSON.achievements.createdTask).to.eql(true);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"removes invalid tags when loading the user","suites":["User Model","post init"],"updatePoint":{"line":175,"column":50,"index":7404},"line":175,"code":"    it('removes invalid tags when loading the user', async () => {\n      let user = new User();\n      await user.save();\n      await user.update({\n        $set: {\n          tags: [null, // invalid, not an object\n          // { name: '123' }, // invalid, no id - generated automatically\n          {\n            id: '123'\n          }, // invalid, no name\n          {\n            name: 'ABC',\n            id: '1234'\n          } // valid\n          ]\n        }\n      }).exec();\n      user = await User.findById(user._id).exec();\n      const userToJSON = user.toJSON();\n      expect(userToJSON.tags.length).to.equal(1);\n      expect(userToJSON.tags[0]).to.have.all.keys(['id', 'name']);\n      expect(userToJSON.tags[0].id).to.equal('1234');\n      expect(userToJSON.tags[0].name).to.equal('ABC');\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"removes invalid push devices when loading the user","suites":["User Model","post init"],"updatePoint":{"line":199,"column":58,"index":8210},"line":199,"code":"    it('removes invalid push devices when loading the user', async () => {\n      let user = new User();\n      await user.save();\n      await user.update({\n        $set: {\n          pushDevices: [null, // invalid, not an object\n          {\n            regId: '123'\n          }, // invalid, no type\n          {\n            type: 'android'\n          }, // invalid, no regId\n          {\n            type: 'android',\n            regId: '1234'\n          } // valid\n          ]\n        }\n      }).exec();\n      user = await User.findById(user._id).exec();\n      const userToJSON = user.toJSON();\n      expect(userToJSON.pushDevices.length).to.equal(1);\n      expect(userToJSON.pushDevices[0]).to.have.all.keys(['regId', 'type', 'createdAt', 'updatedAt']);\n      expect(userToJSON.pushDevices[0].type).to.equal('android');\n      expect(userToJSON.pushDevices[0].regId).to.equal('1234');\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"removes duplicate push devices when loading the user","suites":["User Model","post init"],"updatePoint":{"line":225,"column":60,"index":9099},"line":225,"code":"    it('removes duplicate push devices when loading the user', async () => {\n      let user = new User();\n      await user.save();\n      await user.update({\n        $set: {\n          pushDevices: [{\n            type: 'android',\n            regId: '1234'\n          }, {\n            type: 'android',\n            regId: '1234'\n          }]\n        }\n      }).exec();\n      user = await User.findById(user._id).exec();\n      const userToJSON = user.toJSON();\n      expect(userToJSON.pushDevices.length).to.equal(1);\n      expect(userToJSON.pushDevices[0]).to.have.all.keys(['regId', 'type', 'createdAt', 'updatedAt']);\n      expect(userToJSON.pushDevices[0].type).to.equal('android');\n      expect(userToJSON.pushDevices[0].regId).to.equal('1234');\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"removes invalid notifications when loading the user","suites":["User Model","post init"],"updatePoint":{"line":246,"column":59,"index":9851},"line":246,"code":"    it('removes invalid notifications when loading the user', async () => {\n      let user = new User();\n      await user.save();\n      await user.update({\n        $set: {\n          notifications: [null, // invalid, not an object\n          {\n            seen: true\n          }, // invalid, no type or id\n          {\n            id: 123\n          }, // invalid, no type\n          // invalid, no id, not included here because the id would be added automatically\n          // {type: 'ABC'},\n          {\n            type: 'ABC',\n            id: '123'\n          } // valid\n          ]\n        }\n      }).exec();\n      user = await User.findById(user._id).exec();\n      const userToJSON = user.toJSON();\n      expect(userToJSON.notifications.length).to.equal(1);\n      expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n      expect(userToJSON.notifications[0].type).to.equal('ABC');\n      expect(userToJSON.notifications[0].id).to.equal('123');\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"removes multiple NEW_CHAT_MESSAGE for the same group","suites":["User Model","post init"],"updatePoint":{"line":274,"column":60,"index":10835},"line":274,"code":"    it('removes multiple NEW_CHAT_MESSAGE for the same group', async () => {\n      let user = new User();\n      await user.save();\n      await user.update({\n        $set: {\n          notifications: [{\n            type: 'NEW_CHAT_MESSAGE',\n            id: 123,\n            data: {\n              group: {\n                id: 12345\n              }\n            }\n          }, {\n            type: 'NEW_CHAT_MESSAGE',\n            id: 1234,\n            data: {\n              group: {\n                id: 12345\n              }\n            }\n          }, {\n            type: 'NEW_CHAT_MESSAGE',\n            id: 123,\n            data: {\n              group: {\n                id: 123456\n              }\n            }\n          }, // not duplicate, different group\n          {\n            type: 'NEW_CHAT_MESSAGE_DIFF',\n            id: 123,\n            data: {\n              group: {\n                id: 12345\n              }\n            }\n          } // not duplicate, different type\n          ]\n        }\n      }).exec();\n      user = await User.findById(user._id).exec();\n      const userToJSON = user.toJSON();\n      expect(userToJSON.notifications.length).to.equal(3);\n      expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n      expect(userToJSON.notifications[0].type).to.equal('NEW_CHAT_MESSAGE');\n      expect(userToJSON.notifications[0].id).to.equal('123');\n      expect(userToJSON.notifications[0].data).to.deep.equal({\n        group: {\n          id: 12345\n        }\n      });\n      expect(userToJSON.notifications[0].seen).to.equal(false);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"can add notifications without data","suites":["User Model","notifications"],"updatePoint":{"line":331,"column":42,"index":12444},"line":331,"code":"    it('can add notifications without data', () => {\n      const user = new User();\n      user.addNotification('CRON');\n      const userToJSON = user.toJSON();\n      expect(user.notifications.length).to.equal(1);\n      expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n      expect(userToJSON.notifications[0].type).to.equal('CRON');\n      expect(userToJSON.notifications[0].data).to.eql({});\n      expect(userToJSON.notifications[0].seen).to.eql(false);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"can add notifications with data and already marked as seen","suites":["User Model","notifications"],"updatePoint":{"line":341,"column":66,"index":12967},"line":341,"code":"    it('can add notifications with data and already marked as seen', () => {\n      const user = new User();\n      user.addNotification('CRON', {\n        field: 1\n      }, true);\n      const userToJSON = user.toJSON();\n      expect(user.notifications.length).to.equal(1);\n      expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n      expect(userToJSON.notifications[0].type).to.equal('CRON');\n      expect(userToJSON.notifications[0].data).to.eql({\n        field: 1\n      });\n      expect(userToJSON.notifications[0].seen).to.eql(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"adds notifications for a single member via static method","suites":["User Model","notifications","static push method"],"updatePoint":{"line":356,"column":66,"index":13589},"line":356,"code":"      it('adds notifications for a single member via static method', async () => {\n        let user = new User();\n        await user.save();\n        await User.pushNotification({\n          _id: user._id\n        }, 'CRON');\n        user = await User.findOne({\n          _id: user._id\n        }).exec();\n        const userToJSON = user.toJSON();\n        expect(user.notifications.length).to.equal(1);\n        expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n        expect(userToJSON.notifications[0].type).to.equal('CRON');\n        expect(userToJSON.notifications[0].data).to.eql({});\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"validates notifications via static method","suites":["User Model","notifications","static push method"],"updatePoint":{"line":371,"column":51,"index":14205},"line":371,"code":"      it('validates notifications via static method', async () => {\n        const user = new User();\n        await user.save();\n        expect(User.pushNotification({\n          _id: user._id\n        }, 'BAD_TYPE')).to.eventually.be.rejected;\n        expect(User.pushNotification({\n          _id: user._id\n        }, 'CRON', null, 'INVALID_SEEN')).to.eventually.be.rejected;\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"adds notifications without data for all given users via static method","suites":["User Model","notifications","static push method"],"updatePoint":{"line":381,"column":79,"index":14617},"line":381,"code":"      it('adds notifications without data for all given users via static method', async () => {\n        let user = new User();\n        const otherUser = new User();\n        await Promise.all([user.save(), otherUser.save()]);\n        await User.pushNotification({\n          _id: {\n            $in: [user._id, otherUser._id]\n          }\n        }, 'CRON');\n        user = await User.findOne({\n          _id: user._id\n        }).exec();\n        let userToJSON = user.toJSON();\n        expect(user.notifications.length).to.equal(1);\n        expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n        expect(userToJSON.notifications[0].type).to.equal('CRON');\n        expect(userToJSON.notifications[0].data).to.eql({});\n        expect(userToJSON.notifications[0].seen).to.eql(false);\n        user = await User.findOne({\n          _id: otherUser._id\n        }).exec();\n        userToJSON = user.toJSON();\n        expect(user.notifications.length).to.equal(1);\n        expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n        expect(userToJSON.notifications[0].type).to.equal('CRON');\n        expect(userToJSON.notifications[0].data).to.eql({});\n        expect(userToJSON.notifications[0].seen).to.eql(false);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"adds notifications with data and seen status for all given users via static method","suites":["User Model","notifications","static push method"],"updatePoint":{"line":409,"column":92,"index":15916},"line":409,"code":"      it('adds notifications with data and seen status for all given users via static method', async () => {\n        let user = new User();\n        const otherUser = new User();\n        await Promise.all([user.save(), otherUser.save()]);\n        await User.pushNotification({\n          _id: {\n            $in: [user._id, otherUser._id]\n          }\n        }, 'CRON', {\n          field: 1\n        }, true);\n        user = await User.findOne({\n          _id: user._id\n        }).exec();\n        let userToJSON = user.toJSON();\n        expect(user.notifications.length).to.equal(1);\n        expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n        expect(userToJSON.notifications[0].type).to.equal('CRON');\n        expect(userToJSON.notifications[0].data).to.eql({\n          field: 1\n        });\n        expect(userToJSON.notifications[0].seen).to.eql(true);\n        user = await User.findOne({\n          _id: otherUser._id\n        }).exec();\n        userToJSON = user.toJSON();\n        expect(user.notifications.length).to.equal(1);\n        expect(userToJSON.notifications[0]).to.have.all.keys(['data', 'id', 'type', 'seen']);\n        expect(userToJSON.notifications[0].type).to.equal('CRON');\n        expect(userToJSON.notifications[0].data).to.eql({\n          field: 1\n        });\n        expect(userToJSON.notifications[0].seen).to.eql(true);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user does not have customer id","suites":["User Model","isSubscribed"],"updatePoint":{"line":450,"column":55,"index":17388},"line":450,"code":"    it('returns false if user does not have customer id', () => {\n      expect(user.isSubscribed()).to.be.undefined;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user does not have plan.dateTerminated","suites":["User Model","isSubscribed"],"updatePoint":{"line":453,"column":62,"index":17520},"line":453,"code":"    it('returns true if user does not have plan.dateTerminated', () => {\n      user.purchased.plan.customerId = 'test-id';\n      expect(user.isSubscribed()).to.be.true;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user if plan.dateTerminated is after today","suites":["User Model","isSubscribed"],"updatePoint":{"line":457,"column":66,"index":17701},"line":457,"code":"    it('returns true if user if plan.dateTerminated is after today', () => {\n      user.purchased.plan.customerId = 'test-id';\n      user.purchased.plan.dateTerminated = moment().add(1, 'days').toDate();\n      expect(user.isSubscribed()).to.be.true;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user if plan.dateTerminated is before today","suites":["User Model","isSubscribed"],"updatePoint":{"line":462,"column":68,"index":17961},"line":462,"code":"    it('returns false if user if plan.dateTerminated is before today', () => {\n      user.purchased.plan.customerId = 'test-id';\n      user.purchased.plan.dateTerminated = moment().subtract(1, 'days').toDate();\n      expect(user.isSubscribed()).to.be.false;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user is not subscribed","suites":["User Model","canGetGems"],"updatePoint":{"line":481,"column":46,"index":18497},"line":481,"code":"    it('returns true if user is not subscribed', async () => {\n      expect(await user.canGetGems()).to.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user is not subscribed with a group plan","suites":["User Model","canGetGems"],"updatePoint":{"line":484,"column":64,"index":18640},"line":484,"code":"    it('returns true if user is not subscribed with a group plan', async () => {\n      user.purchased.plan.customerId = 123;\n      expect(await user.canGetGems()).to.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user is subscribed with a group plan","suites":["User Model","canGetGems"],"updatePoint":{"line":488,"column":60,"index":18823},"line":488,"code":"    it('returns true if user is subscribed with a group plan', async () => {\n      user.purchased.plan.customerId = 'group-plan';\n      expect(await user.canGetGems()).to.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user is part of a group","suites":["User Model","canGetGems"],"updatePoint":{"line":492,"column":47,"index":19002},"line":492,"code":"    it('returns true if user is part of a group', async () => {\n      user.guilds.push(group._id);\n      expect(await user.canGetGems()).to.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user is part of a group with a subscription","suites":["User Model","canGetGems"],"updatePoint":{"line":496,"column":67,"index":19183},"line":496,"code":"    it('returns true if user is part of a group with a subscription', async () => {\n      user.guilds.push(group._id);\n      user.purchased.plan.customerId = 'group-plan';\n      group.purchased.plan.customerId = 123;\n      await group.save();\n      expect(await user.canGetGems()).to.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if leader is part of a group with a subscription and canGetGems: false","suites":["User Model","canGetGems"],"updatePoint":{"line":503,"column":91,"index":19512},"line":503,"code":"    it('returns true if leader is part of a group with a subscription and canGetGems: false', async () => {\n      user.guilds.push(group._id);\n      user.purchased.plan.customerId = 'group-plan';\n      group.purchased.plan.customerId = 123;\n      group.leader = user._id;\n      group.leaderOnly.getGems = true;\n      await group.save();\n      expect(await user.canGetGems()).to.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user is part of a group with no subscription but canGetGems: false","suites":["User Model","canGetGems"],"updatePoint":{"line":512,"column":90,"index":19910},"line":512,"code":"    it('returns true if user is part of a group with no subscription but canGetGems: false', async () => {\n      user.guilds.push(group._id);\n      user.purchased.plan.customerId = 'group-plan';\n      group.leaderOnly.getGems = true;\n      await group.save();\n      expect(await user.canGetGems()).to.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user is part of a group with a subscription and canGetGems: false","suites":["User Model","canGetGems"],"updatePoint":{"line":519,"column":90,"index":20232},"line":519,"code":"    it('returns false if user is part of a group with a subscription and canGetGems: false', async () => {\n      user.guilds.push(group._id);\n      user.purchased.plan.customerId = 'group-plan';\n      group.purchased.plan.customerId = 123;\n      group.leaderOnly.getGems = true;\n      await group.save();\n      expect(await user.canGetGems()).to.equal(false);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user does not have customer id","suites":["User Model","hasNotCancelled"],"updatePoint":{"line":533,"column":55,"index":20678},"line":533,"code":"    it('returns false if user does not have customer id', () => {\n      expect(user.hasNotCancelled()).to.be.false;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user does not have plan.dateTerminated","suites":["User Model","hasNotCancelled"],"updatePoint":{"line":536,"column":62,"index":20809},"line":536,"code":"    it('returns true if user does not have plan.dateTerminated', () => {\n      user.purchased.plan.customerId = 'test-id';\n      expect(user.hasNotCancelled()).to.be.true;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user if plan.dateTerminated is after today","suites":["User Model","hasNotCancelled"],"updatePoint":{"line":540,"column":67,"index":20994},"line":540,"code":"    it('returns false if user if plan.dateTerminated is after today', () => {\n      user.purchased.plan.customerId = 'test-id';\n      user.purchased.plan.dateTerminated = moment().add(1, 'days').toDate();\n      expect(user.hasNotCancelled()).to.be.false;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user if plan.dateTerminated is before today","suites":["User Model","hasNotCancelled"],"updatePoint":{"line":545,"column":68,"index":21258},"line":545,"code":"    it('returns false if user if plan.dateTerminated is before today', () => {\n      user.purchased.plan.customerId = 'test-id';\n      user.purchased.plan.dateTerminated = moment().subtract(1, 'days').toDate();\n      expect(user.hasNotCancelled()).to.be.false;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user does not have customer id","suites":["User Model","hasCancelled"],"updatePoint":{"line":556,"column":55,"index":21624},"line":556,"code":"    it('returns false if user does not have customer id', () => {\n      expect(user.hasCancelled()).to.be.false;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user does not have plan.dateTerminated","suites":["User Model","hasCancelled"],"updatePoint":{"line":559,"column":63,"index":21753},"line":559,"code":"    it('returns false if user does not have plan.dateTerminated', () => {\n      user.purchased.plan.customerId = 'test-id';\n      expect(user.hasCancelled()).to.be.false;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns true if user if plan.dateTerminated is after today","suites":["User Model","hasCancelled"],"updatePoint":{"line":563,"column":66,"index":21935},"line":563,"code":"    it('returns true if user if plan.dateTerminated is after today', () => {\n      user.purchased.plan.customerId = 'test-id';\n      user.purchased.plan.dateTerminated = moment().add(1, 'days').toDate();\n      expect(user.hasCancelled()).to.be.true;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"returns false if user if plan.dateTerminated is before today","suites":["User Model","hasCancelled"],"updatePoint":{"line":568,"column":68,"index":22195},"line":568,"code":"    it('returns false if user if plan.dateTerminated is before today', () => {\n      user.purchased.plan.customerId = 'test-id';\n      user.purchased.plan.dateTerminated = moment().subtract(1, 'days').toDate();\n      expect(user.hasCancelled()).to.be.false;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"marks the last news post as read for new users","suites":["User Model","pre-save hook"],"updatePoint":{"line":575,"column":54,"index":22488},"line":575,"code":"    it('marks the last news post as read for new users', async () => {\n      const lastNewsPost = {\n        _id: '1'\n      };\n      sandbox.stub(NewsPost, 'lastNewsPost').returns(lastNewsPost);\n      let user = new User();\n      expect(user.isNew).to.equal(true);\n      user = await user.save();\n      expect(user.checkNewStuff()).to.equal(false);\n      expect(user.toJSON().flags.newStuff).to.equal(false);\n      expect(user.flags.lastNewStuffRead).to.equal(lastNewsPost._id);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"does not mark the last news post as read for existing users","suites":["User Model","pre-save hook"],"updatePoint":{"line":587,"column":67,"index":22987},"line":587,"code":"    it('does not mark the last news post as read for existing users', async () => {\n      const lastNewsPost = {\n        _id: '1'\n      };\n      const lastNewsPostStub = sandbox.stub(NewsPost, 'lastNewsPost');\n      lastNewsPostStub.returns(lastNewsPost);\n      let user = new User();\n      user = await user.save();\n      expect(user.isNew).to.equal(false);\n      user.profile.name = 'new name';\n      lastNewsPostStub.returns({\n        _id: '2'\n      });\n      user = await user.save();\n      expect(user.flags.lastNewStuffRead).to.equal(lastNewsPost._id); // not _id: 2\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"does not try to award achievements when achievements or items not selected in query","suites":["User Model","pre-save hook"],"updatePoint":{"line":603,"column":91,"index":23592},"line":603,"code":"    it('does not try to award achievements when achievements or items not selected in query', async () => {\n      let user = new User();\n      user = await user.save(); // necessary for user.isSelected to work correctly\n      // Create conditions for the Beast Master achievement to be awarded\n\n      user.achievements.beastMasterCount = 3; // verify that it was not awarded initially\n\n      expect(user.achievements.beastMaster).to.not.equal(true);\n      user = await user.save(); // verify that it's been awarded\n\n      expect(user.achievements.beastMaster).to.equal(true);\n      expect(user.notifications.find(notification => notification.type === 'ACHIEVEMENT_BEAST_MASTER')).to.exist; // reset the user\n\n      user.achievements.beastMasterCount = 0;\n      user.achievements.beastMaster = false;\n      user = await user.save(); // verify it's been removed\n\n      expect(user.achievements.beastMaster).to.equal(false); // fetch the user without selecting the 'items' field\n\n      user = await User.findById(user._id).select('-items').exec();\n      expect(user.isSelected('items')).to.equal(false); // create the conditions for the beast master achievement\n      // but this time it should not be awarded\n\n      user.achievements.beastMasterCount = 3;\n      user = await user.save();\n      expect(user.achievements.beastMaster).to.equal(false); // reset\n\n      user.achievements.beastMasterCount = 0;\n      user = await user.save(); // this time with achievements not selected\n\n      user = await User.findById(user._id).select('-achievements').exec();\n      expect(user.isSelected('achievements')).to.equal(false);\n      user.achievements.beastMasterCount = 3;\n      user = await user.save();\n      expect(user.achievements.beastMaster).to.not.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"adds achievements to notification list","suites":["User Model","pre-save hook"],"updatePoint":{"line":639,"column":46,"index":25315},"line":639,"code":"    it('adds achievements to notification list', async () => {\n      let user = new User();\n      user = await user.save(); // necessary for user.isSelected to work correctly\n      // Create conditions for achievements to be awarded\n\n      user.achievements.beastMasterCount = 3;\n      user.achievements.mountMasterCount = 3;\n      user.achievements.triadBingoCount = 3; // verify that it was not awarded initially\n\n      expect(user.achievements.beastMaster).to.not.equal(true); // verify that it was not awarded initially\n\n      expect(user.achievements.mountMaster).to.not.equal(true); // verify that it was not awarded initially\n\n      expect(user.achievements.triadBingo).to.not.equal(true);\n      user = await user.save(); // verify that it's been awarded\n\n      expect(user.notifications.find(notification => notification.type === 'ACHIEVEMENT_BEAST_MASTER')).to.exist;\n      expect(user.notifications.find(notification => notification.type === 'ACHIEVEMENT_MOUNT_MASTER')).to.exist;\n      expect(user.notifications.find(notification => notification.type === 'ACHIEVEMENT_TRIAD_BINGO')).to.exist;\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"doesn't add a notification if there are no points to allocate","suites":["User Model","pre-save hook","manage unallocated stats points notifications"],"updatePoint":{"line":660,"column":72,"index":26522},"line":660,"code":"      it('doesn\\'t add a notification if there are no points to allocate', async () => {\n        let user = new User();\n        user.flags.classSelected = true;\n        user.preferences.disableClasses = false;\n        user.stats.class = 'warrior';\n        user = await user.save(); // necessary for user.isSelected to work correctly\n\n        const oldNotificationsCount = user.notifications.length;\n        user.stats.points = 0;\n        user = await user.save();\n        expect(user.notifications.length).to.equal(oldNotificationsCount);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"removes a notification if there are no more points to allocate","suites":["User Model","pre-save hook","manage unallocated stats points notifications"],"updatePoint":{"line":672,"column":72,"index":27071},"line":672,"code":"      it('removes a notification if there are no more points to allocate', async () => {\n        let user = new User();\n        user.flags.classSelected = true;\n        user.preferences.disableClasses = false;\n        user.stats.class = 'warrior';\n        user.stats.points = 9;\n        user = await user.save(); // necessary for user.isSelected to work correctly\n\n        expect(user.notifications[0].type).to.equal('UNALLOCATED_STATS_POINTS');\n        const oldNotificationsCount = user.notifications.length;\n        user.stats.points = 0;\n        user = await user.save();\n        expect(user.notifications.length).to.equal(oldNotificationsCount - 1);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"adds a notification if there are points to allocate","suites":["User Model","pre-save hook","manage unallocated stats points notifications"],"updatePoint":{"line":686,"column":61,"index":27725},"line":686,"code":"      it('adds a notification if there are points to allocate', async () => {\n        let user = new User();\n        user.flags.classSelected = true;\n        user.preferences.disableClasses = false;\n        user.stats.class = 'warrior';\n        user = await user.save(); // necessary for user.isSelected to work correctly\n\n        const oldNotificationsCount = user.notifications.length;\n        user.stats.points = 9;\n        user = await user.save();\n        expect(user.notifications.length).to.equal(oldNotificationsCount + 1);\n        expect(user.notifications[0].type).to.equal('UNALLOCATED_STATS_POINTS');\n        expect(user.notifications[0].data.points).to.equal(9);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"adds a notification if the points to allocate have changed","suites":["User Model","pre-save hook","manage unallocated stats points notifications"],"updatePoint":{"line":700,"column":68,"index":28418},"line":700,"code":"      it('adds a notification if the points to allocate have changed', async () => {\n        let user = new User();\n        user.stats.points = 9;\n        user.flags.classSelected = true;\n        user.preferences.disableClasses = false;\n        user.stats.class = 'warrior';\n        user = await user.save(); // necessary for user.isSelected to work correctly\n\n        const oldNotificationsCount = user.notifications.length;\n        const oldNotificationsUUID = user.notifications[0].id;\n        expect(user.notifications[0].type).to.equal('UNALLOCATED_STATS_POINTS');\n        expect(user.notifications[0].data.points).to.equal(9);\n        user.stats.points = 11;\n        user = await user.save();\n        expect(user.notifications.length).to.equal(oldNotificationsCount);\n        expect(user.notifications[0].type).to.equal('UNALLOCATED_STATS_POINTS');\n        expect(user.notifications[0].data.points).to.equal(11);\n        expect(user.notifications[0].id).to.not.equal(oldNotificationsUUID);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"does not add a notification if the user has disabled classes","suites":["User Model","pre-save hook","manage unallocated stats points notifications"],"updatePoint":{"line":719,"column":70,"index":29426},"line":719,"code":"      it('does not add a notification if the user has disabled classes', async () => {\n        let user = new User();\n        user.stats.points = 9;\n        user.flags.classSelected = true;\n        user.preferences.disableClasses = true;\n        user.stats.class = 'warrior';\n        user = await user.save(); // necessary for user.isSelected to work correctly\n\n        const oldNotificationsCount = user.notifications.length;\n        user.stats.points = 9;\n        user = await user.save();\n        expect(user.notifications.length).to.equal(oldNotificationsCount);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"does not add a notification if the user has not selected a class","suites":["User Model","pre-save hook","manage unallocated stats points notifications"],"updatePoint":{"line":732,"column":74,"index":30007},"line":732,"code":"      it('does not add a notification if the user has not selected a class', async () => {\n        let user = new User();\n        user.stats.points = 9;\n        user.flags.classSelected = false;\n        user.stats.class = 'warrior';\n        user = await user.save(); // necessary for user.isSelected to work correctly\n\n        const oldNotificationsCount = user.notifications.length;\n        user.stats.points = 9;\n        user = await user.save();\n        expect(user.notifications.length).to.equal(oldNotificationsCount);\n      });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"correctly calculates days missed since lastCron","suites":["User Model","daysUserHasMissed"],"updatePoint":{"line":752,"column":55,"index":30712},"line":752,"code":"    it('correctly calculates days missed since lastCron', () => {\n      const now = moment();\n      user.lastCron = moment(now).subtract(5, 'days');\n      const {\n        daysMissed\n      } = user.daysUserHasMissed(now);\n      expect(daysMissed).to.eql(5);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"correctly handles a cron that did not complete","suites":["User Model","daysUserHasMissed"],"updatePoint":{"line":760,"column":54,"index":30976},"line":760,"code":"    it('correctly handles a cron that did not complete', () => {\n      const now = moment();\n      user.lastCron = moment(now).subtract(2, 'days');\n      user.auth.timestamps.loggedIn = moment(now).subtract(5, 'days');\n      const {\n        daysMissed\n      } = user.daysUserHasMissed(now);\n      expect(daysMissed).to.eql(5);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"uses timezone from preferences to calculate days missed","suites":["User Model","daysUserHasMissed"],"updatePoint":{"line":769,"column":63,"index":31320},"line":769,"code":"    it('uses timezone from preferences to calculate days missed', () => {\n      const now = moment('2017-07-08 01:00:00Z');\n      user.lastCron = moment('2017-07-04 13:00:00Z');\n      user.preferences.timezoneOffset = 120;\n      const {\n        daysMissed\n      } = user.daysUserHasMissed(now);\n      expect(daysMissed).to.eql(3);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"uses timezone at last cron to calculate days missed","suites":["User Model","daysUserHasMissed"],"updatePoint":{"line":778,"column":59,"index":31655},"line":778,"code":"    it('uses timezone at last cron to calculate days missed', () => {\n      const now = moment('2017-09-08 13:00:00Z');\n      user.lastCron = moment('2017-09-06 01:00:00+02:00');\n      user.preferences.timezoneOffset = 0;\n      user.preferences.timezoneOffsetAtLastCron = -120;\n      const {\n        daysMissed\n      } = user.daysUserHasMissed(now);\n      expect(daysMissed).to.eql(2);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"respects new timezone that drags time into same day","suites":["User Model","daysUserHasMissed"],"updatePoint":{"line":788,"column":59,"index":32049},"line":788,"code":"    it('respects new timezone that drags time into same day', () => {\n      user.lastCron = moment('2017-12-05T00:00:00.000-06:00');\n      user.preferences.timezoneOffset = 360;\n      const today = moment('2017-12-06T00:00:00.000-06:00');\n      const requestWithMinus7Timezone = {\n        header: () => 420\n      };\n      const {\n        daysMissed\n      } = user.daysUserHasMissed(today, requestWithMinus7Timezone);\n      expect(user.preferences.timezoneOffset).to.eql(420);\n      expect(daysMissed).to.eql(0);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"should not cron early when going back a timezone with a custom day start","suites":["User Model","daysUserHasMissed"],"updatePoint":{"line":801,"column":80,"index":32590},"line":801,"code":"    it('should not cron early when going back a timezone with a custom day start', () => {\n      const yesterday = moment('2017-12-05T02:00:00.000-08:00');\n      const timezoneOffset = 480;\n      user.lastCron = yesterday;\n      user.preferences.timezoneOffset = timezoneOffset;\n      user.preferences.dayStart = 2;\n      const today = moment('2017-12-06T02:00:00.000-08:00');\n      const req = {};\n\n      req.header = () => timezoneOffset + 60;\n\n      const {\n        daysMissed\n      } = user.daysUserHasMissed(today, req);\n      expect(daysMissed).to.eql(0);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"isNewsPoster","suites":["User Model","daysUserHasMissed"],"updatePoint":{"line":818,"column":18,"index":33104},"line":818,"code":"  it('isNewsPoster', async () => {\n    const user = new User();\n    await user.save();\n    expect(user.isNewsPoster()).to.equal(false);\n    user.contributor.newsPoster = true;\n    expect(user.isNewsPoster()).to.equal(true);\n  });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"no last news post","suites":["User Model","checkNewStuff"],"updatePoint":{"line":833,"column":25,"index":33502},"line":833,"code":"    it('no last news post', () => {\n      sandbox.stub(NewsPost, 'lastNewsPost').returns(null);\n      expect(user.checkNewStuff()).to.equal(false);\n      expect(user.toJSON().flags.newStuff).to.equal(false);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"last news post read","suites":["User Model","checkNewStuff"],"updatePoint":{"line":838,"column":27,"index":33720},"line":838,"code":"    it('last news post read', () => {\n      sandbox.stub(NewsPost, 'lastNewsPost').returns({\n        _id: '123'\n      });\n      user.flags.lastNewStuffRead = '123';\n      expect(user.checkNewStuff()).to.equal(false);\n      expect(user.toJSON().flags.newStuff).to.equal(false);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"last news post not read","suites":["User Model","checkNewStuff"],"updatePoint":{"line":846,"column":31,"index":34009},"line":846,"code":"    it('last news post not read', () => {\n      sandbox.stub(NewsPost, 'lastNewsPost').returns({\n        _id: '123'\n      });\n      user.flags.lastNewStuffRead = '124';\n      expect(user.checkNewStuff()).to.equal(true);\n      expect(user.toJSON().flags.newStuff).to.equal(true);\n    });","file":"api/unit/models/user.test.js","skipped":false,"dir":"test"},{"name":"converts an array of notifications to a safe version","suites":["UserNotification Model","cleanupCorruptData"],"updatePoint":{"line":4,"column":60,"index":240},"line":4,"code":"    it('converts an array of notifications to a safe version', () => {\n      const notifications = [null, // invalid, not an object\n      {\n        seen: true\n      }, // invalid, no type or id\n      {\n        id: 123\n      }, // invalid, no type\n      {\n        type: 'ABC'\n      }, // invalid, no id\n      new UserNotification({\n        type: 'ABC',\n        id: 123\n      }) // valid\n      ];\n      const safeNotifications = UserNotification.cleanupCorruptData(notifications);\n      expect(safeNotifications.length).to.equal(1);\n      expect(safeNotifications[0].data).to.deep.equal({});\n      expect(safeNotifications[0].seen).to.equal(false);\n      expect(safeNotifications[0].type).to.equal('ABC');\n      expect(safeNotifications[0].id).to.equal('123');\n    });","file":"api/unit/models/userNotification.test.js","skipped":false,"dir":"test"},{"name":"removes multiple NEW_CHAT_MESSAGE for the same group","suites":["UserNotification Model","cleanupCorruptData"],"updatePoint":{"line":27,"column":60,"index":1007},"line":27,"code":"    it('removes multiple NEW_CHAT_MESSAGE for the same group', () => {\n      const notifications = [new UserNotification({\n        type: 'NEW_CHAT_MESSAGE',\n        id: 123,\n        data: {\n          group: {\n            id: 12345\n          }\n        }\n      }), new UserNotification({\n        type: 'NEW_CHAT_MESSAGE',\n        id: 1234,\n        data: {\n          group: {\n            id: 12345\n          }\n        }\n      }), new UserNotification({\n        type: 'NEW_CHAT_MESSAGE',\n        id: 123,\n        data: {\n          group: {\n            id: 123456\n          }\n        }\n      }), // not duplicate, different group\n      new UserNotification({\n        type: 'NEW_CHAT_MESSAGE_DIFF',\n        id: 123,\n        data: {\n          group: {\n            id: 12345\n          }\n        }\n      }) // not duplicate, different type\n      ];\n      const safeNotifications = UserNotification.cleanupCorruptData(notifications);\n      expect(safeNotifications.length).to.equal(3);\n      expect(safeNotifications[0].data).to.deep.equal({\n        group: {\n          id: 12345\n        }\n      });\n      expect(safeNotifications[0].seen).to.equal(false);\n      expect(safeNotifications[0].type).to.equal('NEW_CHAT_MESSAGE');\n      expect(safeNotifications[0].id).to.equal('123');\n    });","file":"api/unit/models/userNotification.test.js","skipped":false,"dir":"test"},{"name":"it provides default values for options","suites":["Webhook Model","Instance Methods","#formatOptions","type is taskActivity"],"updatePoint":{"line":29,"column":50,"index":930},"line":29,"code":"        it('it provides default values for options', () => {\n          delete config.options;\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options).to.eql({\n            checklistScored: false,\n            created: false,\n            updated: false,\n            deleted: false,\n            scored: true\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"provides missing task options","suites":["Webhook Model","Instance Methods","#formatOptions","type is taskActivity"],"updatePoint":{"line":41,"column":41,"index":1299},"line":41,"code":"        it('provides missing task options', () => {\n          delete config.options.created;\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options).to.eql({\n            checklistScored: true,\n            created: false,\n            updated: true,\n            deleted: true,\n            scored: true\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"discards additional options","suites":["Webhook Model","Instance Methods","#formatOptions","type is taskActivity"],"updatePoint":{"line":53,"column":39,"index":1671},"line":53,"code":"        it('discards additional options', () => {\n          config.options.foo = 'another option';\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options.foo).to.not.exist;\n          expect(wh.options).to.eql({\n            checklistScored: true,\n            created: true,\n            updated: true,\n            deleted: true,\n            scored: true\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"validates that  is a boolean","suites":["Webhook Model","Instance Methods","#formatOptions","type is taskActivity"],"updatePoint":{"line":67,"column":51,"index":2200},"line":67,"code":"          it(`validates that ${option} is a boolean`, done => {\n            config.options[option] = 'not a boolean';\n\n            try {\n              const wh = new Webhook(config);\n              wh.formatOptions(res);\n            } catch (err) {\n              expect(err).to.be.an.instanceOf(BadRequest);\n              expect(res.t).to.be.calledOnce;\n              expect(res.t).to.be.calledWith('webhookBooleanOption', {\n                option\n              });\n              done();\n            }\n          });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"it provides default values for options","suites":["Webhook Model","Instance Methods","#formatOptions","type is userActivity"],"updatePoint":{"line":97,"column":50,"index":3089},"line":97,"code":"        it('it provides default values for options', () => {\n          delete config.options;\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options).to.eql({\n            petHatched: false,\n            mountRaised: false,\n            leveledUp: false\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"provides missing user options","suites":["Webhook Model","Instance Methods","#formatOptions","type is userActivity"],"updatePoint":{"line":107,"column":41,"index":3405},"line":107,"code":"        it('provides missing user options', () => {\n          delete config.options.petHatched;\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options).to.eql({\n            petHatched: false,\n            mountRaised: true,\n            leveledUp: true\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"discards additional options","suites":["Webhook Model","Instance Methods","#formatOptions","type is userActivity"],"updatePoint":{"line":117,"column":39,"index":3728},"line":117,"code":"        it('discards additional options', () => {\n          config.options.foo = 'another option';\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options.foo).to.not.exist;\n          expect(wh.options).to.eql({\n            petHatched: true,\n            mountRaised: true,\n            leveledUp: true\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"validates that  is a boolean","suites":["Webhook Model","Instance Methods","#formatOptions","type is userActivity"],"updatePoint":{"line":129,"column":51,"index":4184},"line":129,"code":"          it(`validates that ${option} is a boolean`, done => {\n            config.options[option] = 'not a boolean';\n\n            try {\n              const wh = new Webhook(config);\n              wh.formatOptions(res);\n            } catch (err) {\n              expect(err).to.be.an.instanceOf(BadRequest);\n              expect(res.t).to.be.calledOnce;\n              expect(res.t).to.be.calledWith('webhookBooleanOption', {\n                option\n              });\n              done();\n            }\n          });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"it provides default values for options","suites":["Webhook Model","Instance Methods","#formatOptions","type is questActivity"],"updatePoint":{"line":159,"column":50,"index":5082},"line":159,"code":"        it('it provides default values for options', () => {\n          delete config.options;\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options).to.eql({\n            questStarted: false,\n            questFinished: false,\n            questInvited: false\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"provides missing user options","suites":["Webhook Model","Instance Methods","#formatOptions","type is questActivity"],"updatePoint":{"line":169,"column":41,"index":5405},"line":169,"code":"        it('provides missing user options', () => {\n          delete config.options.questStarted;\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options).to.eql({\n            questStarted: false,\n            questFinished: true,\n            questInvited: true\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"discards additional options","suites":["Webhook Model","Instance Methods","#formatOptions","type is questActivity"],"updatePoint":{"line":179,"column":39,"index":5737},"line":179,"code":"        it('discards additional options', () => {\n          config.options.foo = 'another option';\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options.foo).to.not.exist;\n          expect(wh.options).to.eql({\n            questStarted: true,\n            questFinished: true,\n            questInvited: true\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"validates that  is a boolean","suites":["Webhook Model","Instance Methods","#formatOptions","type is questActivity"],"updatePoint":{"line":191,"column":51,"index":6192},"line":191,"code":"          it(`validates that ${option} is a boolean`, done => {\n            config.options[option] = 'not a boolean';\n\n            try {\n              const wh = new Webhook(config);\n              wh.formatOptions(res);\n            } catch (err) {\n              expect(err).to.be.an.instanceOf(BadRequest);\n              expect(res.t).to.be.calledOnce;\n              expect(res.t).to.be.calledWith('webhookBooleanOption', {\n                option\n              });\n              done();\n            }\n          });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"creates options","suites":["Webhook Model","Instance Methods","#formatOptions","type is groupChatReceived"],"updatePoint":{"line":219,"column":27,"index":7011},"line":219,"code":"        it('creates options', () => {\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options).to.eql(config.options);\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"discards additional objects","suites":["Webhook Model","Instance Methods","#formatOptions","type is groupChatReceived"],"updatePoint":{"line":224,"column":39,"index":7201},"line":224,"code":"        it('discards additional objects', () => {\n          config.options.foo = 'another thing';\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options.foo).to.not.exist;\n          expect(wh.options).to.eql({\n            groupId: config.options.groupId\n          });\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"requires groupId option to be a uuid","suites":["Webhook Model","Instance Methods","#formatOptions","type is groupChatReceived"],"updatePoint":{"line":233,"column":48,"index":7538},"line":233,"code":"        it('requires groupId option to be a uuid', done => {\n          config.options.groupId = 'not a uuid';\n\n          try {\n            const wh = new Webhook(config);\n            wh.formatOptions(res);\n          } catch (err) {\n            expect(err).to.be.an.instanceOf(BadRequest);\n            expect(err.message).to.eql(apiError('groupIdRequired'));\n            done();\n          }\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"discards additional objects","suites":["Webhook Model","Instance Methods","#formatOptions","type is globalActivity"],"updatePoint":{"line":255,"column":39,"index":8190},"line":255,"code":"        it('discards additional objects', () => {\n          config.options.foo = 'another thing';\n          const wh = new Webhook(config);\n          wh.formatOptions(res);\n          expect(wh.options.foo).to.not.exist;\n          expect(wh.options).to.eql({});\n        });","file":"api/unit/models/webhook.test.js","skipped":false,"dir":"test"},{"name":"calls res.analytics","suites":["POST /analytics/track/:eventName"],"updatePoint":{"line":4,"column":25,"index":266},"line":4,"code":"  it('calls res.analytics', async () => {\n    const user = await generateUser();\n    sandbox.spy(analytics, 'track');\n    const requestWithHeaders = requester(user, {\n      'x-client': 'habitica-web'\n    });\n    await requestWithHeaders.post('/analytics/track/eventName', {\n      data: 'example'\n    }, {\n      'x-client': 'habitica-web'\n    });\n    expect(analytics.track).to.be.calledOnce;\n    expect(analytics.track).to.be.calledWith('eventName', sandbox.match({\n      data: 'example'\n    }));\n    sandbox.restore();\n  });","file":"api/v3/integration/analytics/POST-analytics_track_eventName.test.js","skipped":false,"dir":"test"},{"name":"returns error when challengeId is not a valid UUID","suites":["DELETE /challenges/:challengeId"],"updatePoint":{"line":4,"column":56,"index":305},"line":4,"code":"  it('returns error when challengeId is not a valid UUID', async () => {\n    const user = await generateUser();\n    await expect(user.del('/challenges/test')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/DELETE-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns error when challengeId is not for a valid challenge","suites":["DELETE /challenges/:challengeId"],"updatePoint":{"line":12,"column":65,"index":604},"line":12,"code":"  it('returns error when challengeId is not for a valid challenge', async () => {\n    const user = await generateUser();\n    await expect(user.del(`/challenges/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/DELETE-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user doesn't have permissions to delete the challenge","suites":["DELETE /challenges/:challengeId","Deleting a valid challenge"],"updatePoint":{"line":37,"column":84,"index":1551},"line":37,"code":"    it('returns an error when user doesn\\'t have permissions to delete the challenge', async () => {\n      const user = await generateUser();\n      await expect(user.del(`/challenges/${challenge._id}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlyLeaderDeleteChal')\n      });\n    });","file":"api/v3/integration/challenges/DELETE-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"deletes challenge","suites":["DELETE /challenges/:challengeId","Deleting a valid challenge"],"updatePoint":{"line":45,"column":25,"index":1843},"line":45,"code":"    it('deletes challenge', async () => {\n      await groupLeader.del(`/challenges/${challenge._id}`);\n      await sleep(0.5);\n      await expect(checkExistence('challenges', challenge._id)).to.eventually.equal(false);\n    });","file":"api/v3/integration/challenges/DELETE-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"refunds gems to group leader","suites":["DELETE /challenges/:challengeId","Deleting a valid challenge"],"updatePoint":{"line":50,"column":36,"index":2081},"line":50,"code":"    it('refunds gems to group leader', async () => {\n      const oldBalance = (await groupLeader.sync()).balance;\n      await groupLeader.del(`/challenges/${challenge._id}`);\n      await sleep(0.5);\n      await expect(groupLeader.sync()).to.eventually.have.property('balance', oldBalance + challenge.prize / 4);\n    });","file":"api/v3/integration/challenges/DELETE-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"sets broken and doesn't set winner flags for user's challenge tasks","suites":["DELETE /challenges/:challengeId","Deleting a valid challenge"],"updatePoint":{"line":56,"column":77,"index":2442},"line":56,"code":"    it('sets broken and doesn\\'t set winner flags for user\\'s challenge tasks', async () => {\n      await groupLeader.del(`/challenges/${challenge._id}`);\n      await sleep(0.5);\n      const tasks = await groupLeader.get('/tasks/user');\n\n      const testTask = _.find(tasks, task => task.text === taskText);\n\n      expect(testTask.challenge.broken).to.eql('CHALLENGE_DELETED');\n      expect(testTask.challenge.winner).to.be.null;\n    });","file":"api/v3/integration/challenges/DELETE-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"fails if challenge doesn't exists","suites":["GET /challenges/:challengeId/export/csv"],"updatePoint":{"line":34,"column":40,"index":1230},"line":34,"code":"  it('fails if challenge doesn\\'t exists', async () => {\n    user = await generateUser();\n    user.get('/user');\n    await expect(user.get(`/challenges/${generateUUID()}/export/csv`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_export_csv.test.js","skipped":false,"dir":"test"},{"name":"fails if user doesn't have access to the challenge","suites":["GET /challenges/:challengeId/export/csv"],"updatePoint":{"line":43,"column":57,"index":1561},"line":43,"code":"  it('fails if user doesn\\'t have access to the challenge', async () => {\n    user = await generateUser();\n    user.get('/user');\n    await expect(user.get(`/challenges/${challenge._id}/export/csv`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_export_csv.test.js","skipped":false,"dir":"test"},{"name":"should return a valid CSV file with export data","suites":["GET /challenges/:challengeId/export/csv"],"updatePoint":{"line":52,"column":53,"index":1887},"line":52,"code":"  it('should return a valid CSV file with export data', async () => {\n    const res = await members[0].get(`/challenges/${challenge._id}/export/csv`);\n\n    const sortedMembers = _.sortBy([members[0], members[1], members[2], groupLeader], '_id');\n\n    const splitRes = res.split('\\n');\n    expect(splitRes[0]).to.equal('UUID,Display Name,Username,Task,Value,Notes,Streak,Task,Value,Notes,Streak');\n    expect(splitRes[1]).to.equal(`${sortedMembers[0]._id},${sortedMembers[0].profile.name},${sortedMembers[0].auth.local.username},habit:Task 1,0,,0,todo:Task 2,0,,0`);\n    expect(splitRes[2]).to.equal(`${sortedMembers[1]._id},${sortedMembers[1].profile.name},${sortedMembers[1].auth.local.username},habit:Task 1,0,,0,todo:Task 2,0,,0`);\n    expect(splitRes[3]).to.equal(`${sortedMembers[2]._id},${sortedMembers[2].profile.name},${sortedMembers[2].auth.local.username},habit:Task 1,0,,0,todo:Task 2,0,,0`);\n    expect(splitRes[4]).to.equal(`${sortedMembers[3]._id},${sortedMembers[3].profile.name},${sortedMembers[3].auth.local.username},habit:Task 1,0,,0,todo:Task 2,0,,0`);\n    expect(splitRes[5]).to.equal('');\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_export_csv.test.js","skipped":false,"dir":"test"},{"name":"should successfully return when it contains erroneous residue user data","suites":["GET /challenges/:challengeId/export/csv"],"updatePoint":{"line":65,"column":77,"index":3028},"line":65,"code":"  it('should successfully return when it contains erroneous residue user data', async () => {\n    await members[0].update({\n      challenges: []\n    });\n    const res = await members[1].get(`/challenges/${challenge._id}/export/csv`);\n\n    const sortedMembers = _.sortBy([members[1], members[2], groupLeader], '_id');\n\n    const splitRes = res.split('\\n');\n    expect(splitRes[0]).to.equal('UUID,Display Name,Username,Task,Value,Notes,Streak,Task,Value,Notes,Streak');\n    expect(splitRes[1]).to.equal(`${sortedMembers[0]._id},${sortedMembers[0].profile.name},${sortedMembers[0].auth.local.username},habit:Task 1,0,,0,todo:Task 2,0,,0`);\n    expect(splitRes[2]).to.equal(`${sortedMembers[1]._id},${sortedMembers[1].profile.name},${sortedMembers[1].auth.local.username},habit:Task 1,0,,0,todo:Task 2,0,,0`);\n    expect(splitRes[3]).to.equal(`${sortedMembers[2]._id},${sortedMembers[2].profile.name},${sortedMembers[2].auth.local.username},habit:Task 1,0,,0,todo:Task 2,0,,0`);\n    expect(splitRes[4]).to.equal('');\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_export_csv.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.memberId to be an UUID","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":8,"column":49,"index":359},"line":8,"code":"  it('validates req.params.memberId to be an UUID', async () => {\n    await expect(user.get(`/challenges/invalidUUID/members/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.memberId to be an UUID","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":15,"column":49,"index":636},"line":15,"code":"  it('validates req.params.memberId to be an UUID', async () => {\n    await expect(user.get(`/challenges/${generateUUID()}/members/invalidUUID`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"fails if member doesn't exists","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":22,"column":37,"index":901},"line":22,"code":"  it('fails if member doesn\\'t exists', async () => {\n    const userId = generateUUID();\n    await expect(user.get(`/challenges/${generateUUID()}/members/${userId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId\n      })\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"fails if challenge doesn't exists","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":32,"column":40,"index":1228},"line":32,"code":"  it('fails if challenge doesn\\'t exists', async () => {\n    const member = await generateUser();\n    await expect(user.get(`/challenges/${generateUUID()}/members/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"fails if user doesn't have access to the challenge","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":40,"column":57,"index":1555},"line":40,"code":"  it('fails if user doesn\\'t have access to the challenge', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const anotherUser = await generateUser();\n    const member = await generateUser();\n    await expect(anotherUser.get(`/challenges/${challenge._id}/members/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"fails if member is not part of the challenge","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":55,"column":50,"index":2147},"line":55,"code":"  it('fails if member is not part of the challenge', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const member = await generateUser();\n    await expect(user.get(`/challenges/${challenge._id}/members/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeMemberNotFound')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"works with challenges belonging to a public guild","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":69,"column":55,"index":2697},"line":69,"code":"  it('works with challenges belonging to a public guild', async () => {\n    const groupLeader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(groupLeader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(groupLeader, group);\n    await groupLeader.post(`/challenges/${challenge._id}/join`);\n    const taskText = 'Test Text';\n    await groupLeader.post(`/tasks/challenge/${challenge._id}`, [{\n      type: 'habit',\n      text: taskText\n    }]);\n    const memberProgress = await user.get(`/challenges/${challenge._id}/members/${groupLeader._id}`);\n    expect(memberProgress).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile', 'tasks']);\n    expect(memberProgress.profile).to.have.all.keys(['name']);\n    expect(memberProgress.tasks.length).to.equal(1);\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"returns the member tasks for the challenges","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":90,"column":49,"index":3572},"line":90,"code":"  it('returns the member tasks for the challenges', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    await user.post(`/tasks/challenge/${challenge._id}`, [{\n      type: 'habit',\n      text: 'Test Text'\n    }]);\n    const memberProgress = await user.get(`/challenges/${challenge._id}/members/${user._id}`);\n    const chalTasks = await user.get(`/tasks/challenge/${challenge._id}`);\n    expect(memberProgress.tasks.length).to.equal(chalTasks.length);\n    expect(memberProgress.tasks[0].challenge.id).to.equal(challenge._id);\n    expect(memberProgress.tasks[0].challenge.taskId).to.equal(chalTasks[0]._id);\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"returns the tasks without the tags and checklist","suites":["GET /challenges/:challengeId/members/:memberId"],"updatePoint":{"line":107,"column":54,"index":4376},"line":107,"code":"  it('returns the tasks without the tags and checklist', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const taskText = 'Test Text';\n    await user.post(`/tasks/challenge/${challenge._id}`, [{\n      type: 'todo',\n      text: taskText,\n      checklist: [{\n        _id: 123,\n        text: 'test'\n      }]\n    }]);\n    const memberProgress = await user.get(`/challenges/${challenge._id}/members/${user._id}`);\n    expect(memberProgress.tasks[0]).to.not.have.any.keys(['tags', 'checklist']);\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members_memberId.test.js","skipped":false,"dir":"test"},{"name":"validates optional req.query.lastId to be an UUID","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":10,"column":55,"index":403},"line":10,"code":"  it('validates optional req.query.lastId to be an UUID', async () => {\n    await expect(user.get(`/challenges/${generateUUID()}/members?lastId=invalidUUID`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"fails if challenge doesn't exist","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":17,"column":39,"index":677},"line":17,"code":"  it('fails if challenge doesn\\'t exist', async () => {\n    await expect(user.get(`/challenges/${generateUUID()}/members`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"fails if user isn't in the private group and isn't challenge leader","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":24,"column":75,"index":967},"line":24,"code":"  it('fails if user isn\\'t in the private group and isn\\'t challenge leader', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      privacy: 'private'\n    });\n    const challenge = await generateChallenge(user, group);\n    const anotherUser = await generateUser();\n    await expect(anotherUser.get(`/challenges/${challenge._id}/members`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"works if user isn't in the private group but is challenge leader","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":37,"column":71,"index":1465},"line":37,"code":"  it('works if user isn\\'t in the private group but is challenge leader', async () => {\n    const populatedGroup = await createAndPopulateGroup({\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 1\n    });\n    const {\n      groupLeader\n    } = populatedGroup;\n    const challengeLeader = populatedGroup.members[0];\n    const challenge = await generateChallenge(challengeLeader, populatedGroup.group);\n    await groupLeader.post(`/challenges/${challenge._id}/join`);\n    await challengeLeader.post('/groups/party/leave');\n    await challengeLeader.sync();\n    expect(challengeLeader.party._id).to.be.undefined; // check that leaving worked\n\n    const res = await challengeLeader.get(`/challenges/${challenge._id}/members`);\n    expect(res[0]).to.eql({\n      _id: groupLeader._id,\n      id: groupLeader._id,\n      profile: {\n        name: groupLeader.profile.name\n      },\n      auth: {\n        local: {\n          username: groupLeader.auth.local.username\n        }\n      },\n      flags: {\n        verifiedUsername: true\n      }\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"works with challenges belonging to public guild","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":72,"column":53,"index":2534},"line":72,"code":"  it('works with challenges belonging to public guild', async () => {\n    const leader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(leader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(leader, group);\n    await leader.post(`/challenges/${challenge._id}/join`);\n    const res = await user.get(`/challenges/${challenge._id}/members`);\n    expect(res[0]).to.eql({\n      _id: leader._id,\n      id: leader._id,\n      profile: {\n        name: leader.profile.name\n      },\n      auth: {\n        local: {\n          username: leader.auth.local.username\n        }\n      },\n      flags: {\n        verifiedUsername: true\n      }\n    });\n    expect(res[0]).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n    expect(res[0].profile).to.have.all.keys(['name']);\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"populates only some fields","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":102,"column":32,"index":3404},"line":102,"code":"  it('populates only some fields', async () => {\n    const anotherUser = await generateUser({\n      balance: 3\n    });\n    const group = await generateGroup(anotherUser, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(anotherUser, group);\n    await anotherUser.post(`/challenges/${challenge._id}/join`);\n    const res = await user.get(`/challenges/${challenge._id}/members`);\n    expect(res[0]).to.eql({\n      _id: anotherUser._id,\n      id: anotherUser._id,\n      profile: {\n        name: anotherUser.profile.name\n      },\n      auth: {\n        local: {\n          username: anotherUser.auth.local.username\n        }\n      },\n      flags: {\n        verifiedUsername: true\n      }\n    });\n    expect(res[0]).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n    expect(res[0].profile).to.have.all.keys(['name']);\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"returns only first 30 members if req.query.limit is undefined","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":132,"column":67,"index":4349},"line":132,"code":"  it('returns only first 30 members if req.query.limit is undefined', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 31; i += 1) {\n      usersToGenerate.push(generateUser({\n        challenges: [challenge._id]\n      }));\n    }\n\n    await Promise.all(usersToGenerate);\n    const res = await user.get(`/challenges/${challenge._id}/members`);\n    expect(res.length).to.equal(30);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is over 60","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":155,"column":52,"index":5135},"line":155,"code":"  it('returns an error if req.query.limit is over 60', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      privacy: 'private'\n    });\n    const challenge = await generateChallenge(user, group);\n    const anotherUser = await generateUser();\n    await expect(anotherUser.get(`/challenges/${challenge._id}/members?limit=61`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is under 1","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":168,"column":52,"index":5624},"line":168,"code":"  it('returns an error if req.query.limit is under 1', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      privacy: 'private'\n    });\n    const challenge = await generateChallenge(user, group);\n    const anotherUser = await generateUser();\n    await expect(anotherUser.get(`/challenges/${challenge._id}/members?limit=-13`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is not an integer","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":181,"column":59,"index":6121},"line":181,"code":"  it('returns an error if req.query.limit is not an integer', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      privacy: 'private'\n    });\n    const challenge = await generateChallenge(user, group);\n    const anotherUser = await generateUser();\n    await expect(anotherUser.get(`/challenges/${challenge._id}/members?limit=true`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"returns up to 60 members when req.query.limit is specified","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":194,"column":64,"index":6624},"line":194,"code":"  it('returns up to 60 members when req.query.limit is specified', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 62; i += 1) {\n      usersToGenerate.push(generateUser({\n        challenges: [challenge._id]\n      }));\n    }\n\n    await Promise.all(usersToGenerate);\n    let res = await user.get(`/challenges/${challenge._id}/members?limit=57`);\n    expect(res.length).to.equal(57);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n    res = await user.get(`/challenges/${challenge._id}/members?limit=60&lastId=${res[res.length - 1]._id}`);\n    expect(res.length).to.equal(6);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n  }).timeout(30000);","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"supports using req.query.lastId to get more members","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":223,"column":57,"index":7757},"line":223,"code":"  it('supports using req.query.lastId to get more members', async function test() {\n    this.timeout(30000); // @TODO: times out after 8 seconds\n\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 57; i += 1) {\n      usersToGenerate.push(generateUser({\n        challenges: [challenge._id]\n      }));\n    } // Group has 59 members (1 is the leader)\n\n\n    const generatedUsers = await Promise.all(usersToGenerate);\n    const expectedIds = [user._id].concat(generatedUsers.map(generatedUser => generatedUser._id));\n    const res = await user.get(`/challenges/${challenge._id}/members`);\n    expect(res.length).to.equal(30);\n    const res2 = await user.get(`/challenges/${challenge._id}/members?lastId=${res[res.length - 1]._id}`);\n    expect(res2.length).to.equal(28);\n    const resIds = res.concat(res2).map(member => member._id);\n    expect(resIds).to.eql(expectedIds.sort());\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"supports using req.query.includeTasks in order to add challenge-related tasks of all members","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":250,"column":98,"index":8906},"line":250,"code":"  it('supports using req.query.includeTasks in order to add challenge-related tasks of all members', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 8; i += 1) {\n      usersToGenerate.push(generateUser({\n        challenges: [challenge._id]\n      }));\n    }\n\n    await Promise.all(usersToGenerate);\n    await user.post(`/tasks/challenge/${challenge._id}`, [{\n      type: 'habit',\n      text: 'Some task'\n    }]);\n    await user.post(`/tasks/challenge/${challenge._id}`, [{\n      type: 'daily',\n      text: 'Some different task'\n    }]);\n    const res = await user.get(`/challenges/${challenge._id}/members?includeTasks=true`);\n    expect(res.length).to.equal(9);\n    res.forEach(member => {\n      expect(member).to.have.property('tasks');\n      expect(member.tasks).to.be.an('array');\n      expect(member.tasks).to.have.lengthOf(2);\n      member.tasks.forEach(task => {\n        expect(task).to.include.all.keys(['type', 'value', 'priority', 'text', '_id', 'userId']);\n        expect(task).to.not.have.any.keys(['tags', 'checklist']);\n        expect(task.challenge.id).to.be.equal(challenge._id);\n        expect(task.userId).to.be.equal(member._id);\n      });\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"supports using req.query.search to get search members","suites":["GET /challenges/:challengeId/members"],"updatePoint":{"line":288,"column":59,"index":10282},"line":288,"code":"  it('supports using req.query.search to get search members', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const challenge = await generateChallenge(user, group);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 3; i += 1) {\n      usersToGenerate.push(generateUser({\n        challenges: [challenge._id],\n        'auth.local.username': `${i}username`\n      }));\n    }\n\n    const generatedUsers = await Promise.all(usersToGenerate);\n    const usernames = generatedUsers.map(generatedUser => generatedUser.auth.local.username);\n    const firstUsername = usernames[0];\n    const nameToSearch = firstUsername.substring(0, 4);\n    const response = await user.get(`/challenges/${challenge._id}/members?search=${nameToSearch}`);\n    expect(response[0].auth.local.username).to.eql(firstUsername);\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId_members.test.js","skipped":false,"dir":"test"},{"name":"fails if challenge doesn't exists","suites":["GET /challenges/:challengeId"],"updatePoint":{"line":4,"column":40,"index":263},"line":4,"code":"  it('fails if challenge doesn\\'t exists', async () => {\n    const user = await generateUser();\n    await expect(user.get(`/challenges/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/GET-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"should return challenge data","suites":["GET /challenges/:challengeId","public guild"],"updatePoint":{"line":30,"column":36,"index":1091},"line":30,"code":"    it('should return challenge data', async () => {\n      await challenge.sync();\n      const chal = await user.get(`/challenges/${challenge._id}`);\n      expect(chal.memberCount).to.equal(challenge.memberCount);\n      expect(chal.name).to.equal(challenge.name);\n      expect(chal._id).to.equal(challenge._id);\n      expect(chal.leader).to.eql({\n        _id: groupLeader._id,\n        id: groupLeader._id,\n        profile: {\n          name: groupLeader.profile.name\n        },\n        auth: {\n          local: {\n            username: groupLeader.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n      expect(chal.group).to.eql({\n        _id: group._id,\n        categories: [],\n        id: group.id,\n        name: group.name,\n        summary: group.name,\n        type: group.type,\n        privacy: group.privacy,\n        leader: groupLeader.id\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"fails if user isn't in the guild and isn't challenge leader","suites":["GET /challenges/:challengeId","private guild"],"updatePoint":{"line":89,"column":69,"index":2831},"line":89,"code":"    it('fails if user isn\\'t in the guild and isn\\'t challenge leader', async () => {\n      await expect(nonMember.get(`/challenges/${challenge._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('challengeNotFound')\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns challenge data for any user in the guild","suites":["GET /challenges/:challengeId","private guild"],"updatePoint":{"line":96,"column":56,"index":3110},"line":96,"code":"    it('returns challenge data for any user in the guild', async () => {\n      const chal = await otherMember.get(`/challenges/${challenge._id}`);\n      expect(chal.name).to.equal(challenge.name);\n      expect(chal._id).to.equal(challenge._id);\n      expect(chal.leader).to.eql({\n        _id: challengeLeader._id,\n        id: challengeLeader._id,\n        profile: {\n          name: challengeLeader.profile.name\n        },\n        auth: {\n          local: {\n            username: challengeLeader.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n      expect(chal.group).to.eql({\n        _id: group._id,\n        categories: [],\n        id: group.id,\n        name: group.name,\n        summary: group.name,\n        type: group.type,\n        privacy: group.privacy,\n        leader: groupLeader.id\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns challenge data if challenge leader isn't in the guild or challenge","suites":["GET /challenges/:challengeId","private guild"],"updatePoint":{"line":126,"column":83,"index":4011},"line":126,"code":"    it('returns challenge data if challenge leader isn\\'t in the guild or challenge', async () => {\n      await challengeLeader.post(`/groups/${group._id}/leave`);\n      await challengeLeader.sync();\n      expect(challengeLeader.guilds).to.be.empty; // check that leaving worked\n\n      const chal = await challengeLeader.get(`/challenges/${challenge._id}`);\n      expect(chal.name).to.equal(challenge.name);\n      expect(chal._id).to.equal(challenge._id);\n      expect(chal.leader).to.eql({\n        _id: challengeLeader._id,\n        id: challengeLeader._id,\n        profile: {\n          name: challengeLeader.profile.name\n        },\n        auth: {\n          local: {\n            username: challengeLeader.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"fails if user isn't in the party and isn't challenge leader","suites":["GET /challenges/:challengeId","party"],"updatePoint":{"line":177,"column":69,"index":5598},"line":177,"code":"    it('fails if user isn\\'t in the party and isn\\'t challenge leader', async () => {\n      await expect(nonMember.get(`/challenges/${challenge._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('challengeNotFound')\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns challenge data for any user in the party","suites":["GET /challenges/:challengeId","party"],"updatePoint":{"line":184,"column":56,"index":5877},"line":184,"code":"    it('returns challenge data for any user in the party', async () => {\n      const chal = await otherMember.get(`/challenges/${challenge._id}`);\n      expect(chal.name).to.equal(challenge.name);\n      expect(chal._id).to.equal(challenge._id);\n      expect(chal.leader).to.eql({\n        _id: challengeLeader._id,\n        id: challengeLeader._id,\n        profile: {\n          name: challengeLeader.profile.name\n        },\n        auth: {\n          local: {\n            username: challengeLeader.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n      expect(chal.group).to.eql({\n        _id: group._id,\n        id: group._id,\n        categories: [],\n        name: group.name,\n        summary: group.name,\n        type: group.type,\n        privacy: group.privacy,\n        leader: groupLeader.id\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns challenge data if challenge leader isn't in the party or challenge","suites":["GET /challenges/:challengeId","party"],"updatePoint":{"line":214,"column":83,"index":6779},"line":214,"code":"    it('returns challenge data if challenge leader isn\\'t in the party or challenge', async () => {\n      await challengeLeader.post('/groups/party/leave');\n      await challengeLeader.sync();\n      expect(challengeLeader.party._id).to.be.undefined; // check that leaving worked\n\n      const chal = await challengeLeader.get(`/challenges/${challenge._id}`);\n      expect(chal.name).to.equal(challenge.name);\n      expect(chal._id).to.equal(challenge._id);\n      expect(chal.leader).to.eql({\n        _id: challengeLeader._id,\n        id: challengeLeader._id,\n        profile: {\n          name: challengeLeader.profile.name\n        },\n        auth: {\n          local: {\n            username: challengeLeader.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"should return group challenges for non member with populated leader","suites":["GET challenges/groups/:groupId","Public Guild"],"updatePoint":{"line":29,"column":75,"index":1036},"line":29,"code":"    it('should return group challenges for non member with populated leader', async () => {\n      const challenges = await nonMember.get(`/challenges/groups/${publicGuild._id}`);\n\n      const foundChallenge1 = _.find(challenges, {\n        _id: challenge._id\n      });\n\n      expect(foundChallenge1).to.exist;\n      expect(foundChallenge1.leader).to.eql({\n        _id: publicGuild.leader._id,\n        id: publicGuild.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n\n      const foundChallenge2 = _.find(challenges, {\n        _id: challenge2._id\n      });\n\n      expect(foundChallenge2).to.exist;\n      expect(foundChallenge2.leader).to.eql({\n        _id: publicGuild.leader._id,\n        id: publicGuild.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return group challenges for member with populated leader","suites":["GET challenges/groups/:groupId","Public Guild"],"updatePoint":{"line":74,"column":71,"index":2196},"line":74,"code":"    it('should return group challenges for member with populated leader', async () => {\n      const challenges = await user.get(`/challenges/groups/${publicGuild._id}`);\n\n      const foundChallenge1 = _.find(challenges, {\n        _id: challenge._id\n      });\n\n      expect(foundChallenge1).to.exist;\n      expect(foundChallenge1.leader).to.eql({\n        _id: publicGuild.leader._id,\n        id: publicGuild.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n\n      const foundChallenge2 = _.find(challenges, {\n        _id: challenge2._id\n      });\n\n      expect(foundChallenge2).to.exist;\n      expect(foundChallenge2.leader).to.eql({\n        _id: publicGuild.leader._id,\n        id: publicGuild.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return newest challenges first","suites":["GET challenges/groups/:groupId","Public Guild"],"updatePoint":{"line":119,"column":45,"index":3325},"line":119,"code":"    it('should return newest challenges first', async () => {\n      let challenges = await user.get(`/challenges/groups/${publicGuild._id}`);\n\n      let foundChallengeIndex = _.findIndex(challenges, {\n        _id: challenge2._id\n      });\n\n      expect(foundChallengeIndex).to.eql(0);\n      const newChallenge = await generateChallenge(user, publicGuild);\n      await user.post(`/challenges/${newChallenge._id}/join`);\n      challenges = await user.get(`/challenges/groups/${publicGuild._id}`);\n      foundChallengeIndex = _.findIndex(challenges, {\n        _id: newChallenge._id\n      });\n      expect(foundChallengeIndex).to.eql(0);\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should prevent non-member from seeing challenges","suites":["GET challenges/groups/:groupId","Private Guild"],"updatePoint":{"line":161,"column":56,"index":4698},"line":161,"code":"    it('should prevent non-member from seeing challenges', async () => {\n      await expect(nonMember.get(`/challenges/groups/${privateGuild._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return group challenges for member with populated leader","suites":["GET challenges/groups/:groupId","Private Guild"],"updatePoint":{"line":168,"column":71,"index":4998},"line":168,"code":"    it('should return group challenges for member with populated leader', async () => {\n      const challenges = await user.get(`/challenges/groups/${privateGuild._id}`);\n\n      const foundChallenge1 = _.find(challenges, {\n        _id: challenge._id\n      });\n\n      expect(foundChallenge1).to.exist;\n      expect(foundChallenge1.leader).to.eql({\n        _id: privateGuild.leader._id,\n        id: privateGuild.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n\n      const foundChallenge2 = _.find(challenges, {\n        _id: challenge2._id\n      });\n\n      expect(foundChallenge2).to.exist;\n      expect(foundChallenge2.leader).to.eql({\n        _id: privateGuild.leader._id,\n        id: privateGuild.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return official challenges first","suites":["GET challenges/groups/:groupId","official challenge is present"],"updatePoint":{"line":254,"column":47,"index":7327},"line":254,"code":"    it('should return official challenges first', async () => {\n      const challenges = await user.get(`/challenges/groups/${publicGuild._id}`);\n\n      const foundChallengeIndex = _.findIndex(challenges, {\n        _id: officialChallenge._id\n      });\n\n      expect(foundChallengeIndex).to.eql(0);\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return newest challenges first, after official ones","suites":["GET challenges/groups/:groupId","official challenge is present"],"updatePoint":{"line":263,"column":66,"index":7652},"line":263,"code":"    it('should return newest challenges first, after official ones', async () => {\n      let challenges = await user.get(`/challenges/groups/${publicGuild._id}`);\n      unofficialChallenges.forEach((chal, index) => {\n        const foundChallengeIndex = _.findIndex(challenges, {\n          _id: chal._id\n        });\n\n        expect(foundChallengeIndex).to.eql(10 - index);\n      });\n      const newChallenge = await generateChallenge(user, publicGuild);\n      await user.post(`/challenges/${newChallenge._id}/join`);\n      challenges = await user.get(`/challenges/groups/${publicGuild._id}`);\n\n      const foundChallengeIndex = _.findIndex(challenges, {\n        _id: newChallenge._id\n      });\n\n      expect(foundChallengeIndex).to.eql(1);\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should prevent non-member from seeing challenges","suites":["GET challenges/groups/:groupId","Party"],"updatePoint":{"line":307,"column":56,"index":9050},"line":307,"code":"    it('should prevent non-member from seeing challenges', async () => {\n      await expect(nonMember.get(`/challenges/groups/${party._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return group challenges for member with populated leader","suites":["GET challenges/groups/:groupId","Party"],"updatePoint":{"line":314,"column":71,"index":9343},"line":314,"code":"    it('should return group challenges for member with populated leader', async () => {\n      const challenges = await user.get(`/challenges/groups/${party._id}`);\n\n      const foundChallenge1 = _.find(challenges, {\n        _id: challenge._id\n      });\n\n      expect(foundChallenge1).to.exist;\n      expect(foundChallenge1.leader).to.eql({\n        _id: party.leader._id,\n        id: party.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n\n      const foundChallenge2 = _.find(challenges, {\n        _id: challenge2._id\n      });\n\n      expect(foundChallenge2).to.exist;\n      expect(foundChallenge2.leader).to.eql({\n        _id: party.leader._id,\n        id: party.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return group challenges for member using ID \"party\"","suites":["GET challenges/groups/:groupId","Party"],"updatePoint":{"line":359,"column":66,"index":10463},"line":359,"code":"    it('should return group challenges for member using ID \"party\"', async () => {\n      const challenges = await user.get('/challenges/groups/party');\n\n      const foundChallenge1 = _.find(challenges, {\n        _id: challenge._id\n      });\n\n      expect(foundChallenge1).to.exist;\n      expect(foundChallenge1.leader).to.eql({\n        _id: party.leader._id,\n        id: party.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n\n      const foundChallenge2 = _.find(challenges, {\n        _id: challenge2._id\n      });\n\n      expect(foundChallenge2).to.exist;\n      expect(foundChallenge2.leader).to.eql({\n        _id: party.leader._id,\n        id: party.leader._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return tavern challenges with populated leader","suites":["GET challenges/groups/:groupId","Tavern"],"updatePoint":{"line":425,"column":61,"index":12146},"line":425,"code":"    it('should return tavern challenges with populated leader', async () => {\n      const challenges = await user.get(`/challenges/groups/${TAVERN_ID}`);\n\n      const foundChallenge1 = _.find(challenges, {\n        _id: challenge._id\n      });\n\n      expect(foundChallenge1).to.exist;\n      expect(foundChallenge1.leader).to.eql({\n        _id: user._id,\n        id: user._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n\n      const foundChallenge2 = _.find(challenges, {\n        _id: challenge2._id\n      });\n\n      expect(foundChallenge2).to.exist;\n      expect(foundChallenge2.leader).to.eql({\n        _id: user._id,\n        id: user._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return tavern challenges using ID \"habitrpg","suites":["GET challenges/groups/:groupId","Tavern"],"updatePoint":{"line":470,"column":58,"index":13226},"line":470,"code":"    it('should return tavern challenges using ID \"habitrpg', async () => {\n      const challenges = await user.get('/challenges/groups/habitrpg');\n\n      const foundChallenge1 = _.find(challenges, {\n        _id: challenge._id\n      });\n\n      expect(foundChallenge1).to.exist;\n      expect(foundChallenge1.leader).to.eql({\n        _id: user._id,\n        id: user._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n\n      const foundChallenge2 = _.find(challenges, {\n        _id: challenge2._id\n      });\n\n      expect(foundChallenge2).to.exist;\n      expect(foundChallenge2.leader).to.eql({\n        _id: user._id,\n        id: user._id,\n        profile: {\n          name: user.profile.name\n        },\n        auth: {\n          local: {\n            username: user.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n    });","file":"api/v3/integration/challenges/GET-challenges_group_groupid.test.js","skipped":false,"dir":"test"},{"name":"should return challenges user has joined","suites":["GET challenges/user","no official challenges","all challenges"],"updatePoint":{"line":60,"column":50,"index":1680},"line":60,"code":"      it('should return challenges user has joined', async () => {\n        const challenges = await nonMember.get('/challenges/user?page=0');\n\n        const foundChallenge = _.find(challenges, {\n          _id: challenge._id\n        });\n\n        expect(foundChallenge).to.exist;\n        expect(foundChallenge.leader).to.eql(userData);\n        expect(foundChallenge.group).to.eql(groupData);\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should not return challenges a non-member has not joined","suites":["GET challenges/user","no official challenges","all challenges"],"updatePoint":{"line":71,"column":66,"index":2096},"line":71,"code":"      it('should not return challenges a non-member has not joined', async () => {\n        const challenges = await nonMember.get('/challenges/user?page=0');\n\n        const foundChallenge2 = _.find(challenges, {\n          _id: challenge2._id\n        });\n\n        expect(foundChallenge2).to.not.exist;\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should return challenges user has created","suites":["GET challenges/user","no official challenges","all challenges"],"updatePoint":{"line":80,"column":51,"index":2392},"line":80,"code":"      it('should return challenges user has created', async () => {\n        const challenges = await user.get('/challenges/user?page=0');\n\n        const foundChallenge1 = _.find(challenges, {\n          _id: challenge._id\n        });\n\n        expect(foundChallenge1).to.exist;\n        expect(foundChallenge1.leader).to.eql(userData);\n        expect(foundChallenge1.group).to.eql(groupData);\n\n        const foundChallenge2 = _.find(challenges, {\n          _id: challenge2._id\n        });\n\n        expect(foundChallenge2).to.exist;\n        expect(foundChallenge2.leader).to.eql(userData);\n        expect(foundChallenge2.group).to.eql(groupData);\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should return challenges in user's group","suites":["GET challenges/user","no official challenges","all challenges"],"updatePoint":{"line":99,"column":51,"index":3045},"line":99,"code":"      it('should return challenges in user\\'s group', async () => {\n        const challenges = await member.get('/challenges/user?page=0');\n\n        const foundChallenge1 = _.find(challenges, {\n          _id: challenge._id\n        });\n\n        expect(foundChallenge1).to.exist;\n        expect(foundChallenge1.leader).to.eql(userData);\n        expect(foundChallenge1.group).to.eql(groupData);\n\n        const foundChallenge2 = _.find(challenges, {\n          _id: challenge2._id\n        });\n\n        expect(foundChallenge2).to.exist;\n        expect(foundChallenge2.leader).to.eql(userData);\n        expect(foundChallenge2.group).to.eql(groupData);\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should return newest challenges first","suites":["GET challenges/user","no official challenges","all challenges"],"updatePoint":{"line":118,"column":47,"index":3696},"line":118,"code":"      it('should return newest challenges first', async () => {\n        let challenges = await user.get('/challenges/user?page=0');\n\n        let foundChallengeIndex = _.findIndex(challenges, {\n          _id: challenge2._id\n        });\n\n        expect(foundChallengeIndex).to.eql(0);\n        const newChallenge = await generateChallenge(user, publicGuild);\n        await user.post(`/challenges/${newChallenge._id}/join`);\n        challenges = await user.get('/challenges/user?page=0');\n        foundChallengeIndex = _.findIndex(challenges, {\n          _id: newChallenge._id\n        });\n        expect(foundChallengeIndex).to.eql(0);\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should not return challenges user doesn't have access to","suites":["GET challenges/user","no official challenges","all challenges"],"updatePoint":{"line":134,"column":67,"index":4358},"line":134,"code":"      it('should not return challenges user doesn\\'t have access to', async () => {\n        const {\n          group,\n          groupLeader\n        } = await createAndPopulateGroup({\n          groupDetails: {\n            name: 'TestPrivateGuild',\n            summary: 'summary for TestPrivateGuild',\n            type: 'guild',\n            privacy: 'private'\n          }\n        });\n        const privateChallenge = await generateChallenge(groupLeader, group);\n        await groupLeader.post(`/challenges/${privateChallenge._id}/join`);\n        const challenges = await nonMember.get('/challenges/user?page=0');\n\n        const foundChallenge = _.find(challenges, {\n          _id: privateChallenge._id\n        });\n\n        expect(foundChallenge).to.not.exist;\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should not return challenges user doesn't have access to, even with query parameters","suites":["GET challenges/user","no official challenges","all challenges"],"updatePoint":{"line":156,"column":95,"index":5153},"line":156,"code":"      it('should not return challenges user doesn\\'t have access to, even with query parameters', async () => {\n        const {\n          group,\n          groupLeader\n        } = await createAndPopulateGroup({\n          groupDetails: {\n            name: 'TestPrivateGuild',\n            summary: 'summary for TestPrivateGuild',\n            type: 'guild',\n            privacy: 'private'\n          }\n        });\n        const privateChallenge = await generateChallenge(groupLeader, group, {\n          categories: [{\n            name: 'academics',\n            slug: 'academics'\n          }]\n        });\n        await groupLeader.post(`/challenges/${privateChallenge._id}/join`);\n        const challenges = await nonMember.get('/challenges/user?page=0&categories=academics&owned=not_owned');\n\n        const foundChallenge = _.find(challenges, {\n          _id: privateChallenge._id\n        });\n\n        expect(foundChallenge).to.not.exist;\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should return challenges user has joined","suites":["GET challenges/user","no official challenges","my challenges"],"updatePoint":{"line":185,"column":50,"index":6097},"line":185,"code":"      it('should return challenges user has joined', async () => {\n        const challenges = await nonMember.get(`/challenges/user?page=0&member=${true}`);\n\n        const foundChallenge = _.find(challenges, {\n          _id: challenge._id\n        });\n\n        expect(foundChallenge).to.exist;\n        expect(foundChallenge.leader).to.eql(userData);\n        expect(foundChallenge.group).to.eql(groupData);\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should return challenges user has created","suites":["GET challenges/user","no official challenges","my challenges"],"updatePoint":{"line":196,"column":51,"index":6513},"line":196,"code":"      it('should return challenges user has created', async () => {\n        const challenges = await user.get(`/challenges/user?page=0&member=${true}`);\n\n        const foundChallenge1 = _.find(challenges, {\n          _id: challenge._id\n        });\n\n        expect(foundChallenge1).to.exist;\n        expect(foundChallenge1.leader).to.eql(userData);\n        expect(foundChallenge1.group).to.eql(groupData);\n\n        const foundChallenge2 = _.find(challenges, {\n          _id: challenge2._id\n        });\n\n        expect(foundChallenge2).to.exist;\n        expect(foundChallenge2.leader).to.eql(userData);\n        expect(foundChallenge2.group).to.eql(groupData);\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should return challenges user has created if filter by owned","suites":["GET challenges/user","no official challenges","my challenges"],"updatePoint":{"line":215,"column":70,"index":7200},"line":215,"code":"      it('should return challenges user has created if filter by owned', async () => {\n        const challenges = await user.get(`/challenges/user?member=${true}&owned=owned&page=0`);\n\n        const foundChallenge1 = _.find(challenges, {\n          _id: challenge._id\n        });\n\n        expect(foundChallenge1).to.exist;\n        expect(foundChallenge1.leader).to.eql(userData);\n        expect(foundChallenge1.group).to.eql(groupData);\n\n        const foundChallenge2 = _.find(challenges, {\n          _id: challenge2._id\n        });\n\n        expect(foundChallenge2).to.exist;\n        expect(foundChallenge2.leader).to.eql(userData);\n        expect(foundChallenge2.group).to.eql(groupData);\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should not return challenges user has created if filter by not owned","suites":["GET challenges/user","no official challenges","my challenges"],"updatePoint":{"line":234,"column":78,"index":7907},"line":234,"code":"      it('should not return challenges user has created if filter by not owned', async () => {\n        const challenges = await user.get(`/challenges/user?page=0&owned=not_owned&member=${true}`);\n\n        const foundChallenge1 = _.find(challenges, {\n          _id: challenge._id\n        });\n\n        expect(foundChallenge1).to.not.exist;\n\n        const foundChallenge2 = _.find(challenges, {\n          _id: challenge2._id\n        });\n\n        expect(foundChallenge2).to.not.exist;\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should not return challenges in user groups","suites":["GET challenges/user","no official challenges","my challenges"],"updatePoint":{"line":249,"column":53,"index":8373},"line":249,"code":"      it('should not return challenges in user groups', async () => {\n        const challenges = await member.get(`/challenges/user?page=0&member=${true}`);\n\n        const foundChallenge1 = _.find(challenges, {\n          _id: challenge._id\n        });\n\n        expect(foundChallenge1).to.not.exist;\n\n        const foundChallenge2 = _.find(challenges, {\n          _id: challenge2._id\n        });\n\n        expect(foundChallenge2).to.not.exist;\n      });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should return official challenges first","suites":["GET challenges/user","official challenge is present"],"updatePoint":{"line":307,"column":47,"index":10064},"line":307,"code":"    it('should return official challenges first', async () => {\n      const challenges = await user.get('/challenges/user?page=0');\n\n      const foundChallengeIndex = _.findIndex(challenges, {\n        _id: officialChallenge._id\n      });\n\n      expect(foundChallengeIndex).to.eql(0);\n    });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"should return newest challenges first, after official ones","suites":["GET challenges/user","official challenge is present"],"updatePoint":{"line":316,"column":66,"index":10375},"line":316,"code":"    it('should return newest challenges first, after official ones', async () => {\n      let challenges = await user.get('/challenges/user?page=0');\n      unofficialChallenges.forEach((chal, index) => {\n        const foundChallengeIndex = _.findIndex(challenges, {\n          _id: chal._id\n        });\n\n        if (index === 0) {\n          expect(foundChallengeIndex).to.eql(-1);\n        } else {\n          expect(foundChallengeIndex).to.eql(10 - index);\n        }\n      });\n      const newChallenge = await generateChallenge(user, publicGuild);\n      await user.post(`/challenges/${newChallenge._id}/join`);\n      challenges = await user.get('/challenges/user?page=0');\n\n      const foundChallengeIndex = _.findIndex(challenges, {\n        _id: newChallenge._id\n      });\n\n      expect(foundChallengeIndex).to.eql(1);\n    });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"returns public guilds filtered by category","suites":["GET challenges/user","filters and paging"],"updatePoint":{"line":375,"column":50,"index":12039},"line":375,"code":"    it('returns public guilds filtered by category', async () => {\n      const categoryChallenge = await generateChallenge(user, guild, {\n        categories\n      });\n      await user.post(`/challenges/${categoryChallenge._id}/join`);\n      const challenges = await user.get(`/challenges/user?page=0&categories=${categories[0].slug}`);\n      expect(challenges[0]._id).to.eql(categoryChallenge._id);\n      expect(challenges.length).to.eql(1);\n    });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"paginates challenges","suites":["GET challenges/user","filters and paging"],"updatePoint":{"line":384,"column":28,"index":12467},"line":384,"code":"    it('paginates challenges', async () => {\n      const challenges = await user.get('/challenges/user?page=0');\n      const challengesPaged = await user.get('/challenges/user?page=1&owned=owned');\n      expect(challenges.length).to.eql(10);\n      expect(challengesPaged.length).to.eql(2);\n    });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"filters by owned","suites":["GET challenges/user","filters and paging"],"updatePoint":{"line":390,"column":24,"index":12761},"line":390,"code":"    it('filters by owned', async () => {\n      const challenges = await member.get('/challenges/user?page=0&owned=owned');\n      expect(challenges.length).to.eql(0);\n    });","file":"api/v3/integration/challenges/GET-challenges_user.test.js","skipped":false,"dir":"test"},{"name":"clones a challenge","suites":["POST /challenges/:challengeId/clone"],"updatePoint":{"line":3,"column":24,"index":167},"line":3,"code":"  it('clones a challenge', async () => {\n    const user = await generateUser({\n      balance: 10\n    });\n    const group = await generateGroup(user);\n    const name = 'Test Challenge';\n    const shortName = 'TC Label';\n    const description = 'Test Description';\n    const prize = 1;\n    const challenge = await user.post('/challenges', {\n      group: group._id,\n      name,\n      shortName,\n      description,\n      prize\n    });\n    const challengeTask = await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    });\n    const cloneChallengeResponse = await user.post(`/challenges/${challenge._id}/clone`, {\n      group: group._id,\n      name: `${name} cloned`,\n      shortName,\n      description,\n      prize\n    });\n    expect(cloneChallengeResponse.clonedTasks[0].text).to.eql(challengeTask.text);\n    expect(cloneChallengeResponse.clonedTasks[0]._id).to.not.eql(challengeTask._id);\n    expect(cloneChallengeResponse.clonedTasks[0].challenge.id).to.eql(cloneChallengeResponse.clonedChallenge._id);\n  });","file":"api/v3/integration/challenges/POST_challenges_id_clone.test.js","skipped":false,"dir":"test"},{"name":"returns error when challengeId is not a valid UUID","suites":["POST /challenges/:challengeId/join"],"updatePoint":{"line":4,"column":56,"index":285},"line":4,"code":"  it('returns error when challengeId is not a valid UUID', async () => {\n    const user = await generateUser({\n      balance: 1\n    });\n    await expect(user.post('/challenges/test/join')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"returns error when challengeId is not for a valid challenge","suites":["POST /challenges/:challengeId/join"],"updatePoint":{"line":14,"column":65,"index":614},"line":14,"code":"  it('returns error when challengeId is not for a valid challenge', async () => {\n    const user = await generateUser({\n      balance: 1\n    });\n    await expect(user.post(`/challenges/${generateUUID()}/join`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user isn't in the private group and isn't challenge leader","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":40,"column":90,"index":1541},"line":40,"code":"    it('returns an error when user isn\\'t in the private group and isn\\'t challenge leader', async () => {\n      const unauthorizedUser = await generateUser();\n      await expect(unauthorizedUser.post(`/challenges/${challenge._id}/join`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('challengeNotFound')\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"succeeds when user isn't in the private group but is challenge leader","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":48,"column":78,"index":1908},"line":48,"code":"    it('succeeds when user isn\\'t in the private group but is challenge leader', async () => {\n      await groupLeader.post(`/challenges/${challenge._id}/leave`);\n      await groupLeader.post(`/groups/${group._id}/leave`);\n      await groupLeader.sync();\n      expect(groupLeader.guilds).to.be.empty; // check that leaving worked\n\n      const res = await groupLeader.post(`/challenges/${challenge._id}/join`);\n      expect(res.name).to.equal(challenge.name);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"returns challenge data","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":57,"column":30,"index":2327},"line":57,"code":"    it('returns challenge data', async () => {\n      const res = await authorizedUser.post(`/challenges/${challenge._id}/join`);\n      expect(res.group).to.eql({\n        _id: group._id,\n        privacy: group.privacy,\n        name: group.name,\n        type: group.type\n      });\n      expect(res.leader).to.eql({\n        _id: groupLeader._id,\n        id: groupLeader._id,\n        profile: {\n          name: groupLeader.profile.name\n        },\n        auth: {\n          local: {\n            username: groupLeader.auth.local.username\n          }\n        },\n        flags: {\n          verifiedUsername: true\n        }\n      });\n      expect(res.name).to.equal(challenge.name);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"adds challenge to user challenges","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":82,"column":41,"index":3020},"line":82,"code":"    it('adds challenge to user challenges', async () => {\n      await authorizedUser.post(`/challenges/${challenge._id}/join`);\n      await authorizedUser.sync();\n      expect(authorizedUser).to.have.property('challenges').to.include(challenge._id);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"returns error when user has already joined the challenge","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":87,"column":64,"index":3301},"line":87,"code":"    it('returns error when user has already joined the challenge', async () => {\n      await authorizedUser.post(`/challenges/${challenge._id}/join`);\n      await expect(authorizedUser.post(`/challenges/${challenge._id}/join`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('userAlreadyInChallenge')\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"increases memberCount of challenge","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":95,"column":42,"index":3657},"line":95,"code":"    it('increases memberCount of challenge', async () => {\n      await challenge.sync();\n      const oldMemberCount = challenge.memberCount;\n      await authorizedUser.post(`/challenges/${challenge._id}/join`);\n      await challenge.sync();\n      expect(challenge).to.have.property('memberCount', oldMemberCount + 1);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"syncs challenge tasks to joining user","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":102,"column":45,"index":3986},"line":102,"code":"    it('syncs challenge tasks to joining user', async () => {\n      const taskText = 'A challenge task text';\n      await groupLeader.post(`/tasks/challenge/${challenge._id}`, [{\n        type: 'daily',\n        text: taskText\n      }]);\n      await authorizedUser.post(`/challenges/${challenge._id}/join`);\n      const tasks = await authorizedUser.get('/tasks/user');\n      const syncedTask = tasks.find(task => task.text === taskText);\n      expect(syncedTask.text).to.eql(taskText);\n      expect(syncedTask.isDue).to.exist;\n      expect(syncedTask.nextDue).to.exist;\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"adds challenge tag to user tags","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":115,"column":39,"index":4556},"line":115,"code":"    it('adds challenge tag to user tags', async () => {\n      const userTagsLength = (await authorizedUser.get('/tags')).length;\n      await authorizedUser.post(`/challenges/${challenge._id}/join`);\n      await expect(authorizedUser.get('/tags')).to.eventually.have.length(userTagsLength + 1);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"awards achievement if this is user's first challenge","suites":["POST /challenges/:challengeId/join","Joining a valid challenge"],"updatePoint":{"line":120,"column":61,"index":4880},"line":120,"code":"    it('awards achievement if this is user\\'s first challenge', async () => {\n      await authorizedUser.post(`/challenges/${challenge._id}/join`);\n      await authorizedUser.sync();\n      expect(authorizedUser.achievements.joinedChallenge).to.be.true;\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_join.test.js","skipped":false,"dir":"test"},{"name":"returns error when challengeId is not a valid UUID","suites":["POST /challenges/:challengeId/leave"],"updatePoint":{"line":4,"column":56,"index":286},"line":4,"code":"  it('returns error when challengeId is not a valid UUID', async () => {\n    const user = await generateUser();\n    await expect(user.post('/challenges/test/leave')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges_challengeId_leave.test.js","skipped":false,"dir":"test"},{"name":"returns error when challengeId is not for a valid challenge","suites":["POST /challenges/:challengeId/leave"],"updatePoint":{"line":12,"column":65,"index":592},"line":12,"code":"  it('returns error when challengeId is not for a valid challenge', async () => {\n    const user = await generateUser();\n    await expect(user.post(`/challenges/${generateUUID()}/leave`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges_challengeId_leave.test.js","skipped":false,"dir":"test"},{"name":"lets user leave when not a member of the challenge group","suites":["POST /challenges/:challengeId/leave","Leaving a valid challenge"],"updatePoint":{"line":54,"column":64,"index":2212},"line":54,"code":"    it('lets user leave when not a member of the challenge group', async () => {\n      await expect(notInGroupLeavingUser.post(`/challenges/${challenge._id}/leave`)).to.eventually.be.ok;\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_leave.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user isn't a member of the challenge","suites":["POST /challenges/:challengeId/leave","Leaving a valid challenge"],"updatePoint":{"line":57,"column":67,"index":2410},"line":57,"code":"    it('returns an error when user isn\\'t a member of the challenge', async () => {\n      await expect(notInChallengeUser.post(`/challenges/${challenge._id}/leave`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('challengeMemberNotFound')\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_leave.test.js","skipped":false,"dir":"test"},{"name":"removes challenge from user challenges","suites":["POST /challenges/:challengeId/leave","Leaving a valid challenge"],"updatePoint":{"line":64,"column":46,"index":2706},"line":64,"code":"    it('removes challenge from user challenges', async () => {\n      await leavingUser.post(`/challenges/${challenge._id}/leave`);\n      await leavingUser.sync();\n      expect(leavingUser).to.have.property('challenges').to.not.include(challenge._id);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_leave.test.js","skipped":false,"dir":"test"},{"name":"decreases memberCount of challenge","suites":["POST /challenges/:challengeId/leave","Leaving a valid challenge"],"updatePoint":{"line":69,"column":42,"index":2961},"line":69,"code":"    it('decreases memberCount of challenge', async () => {\n      const oldMemberCount = challenge.memberCount;\n      await leavingUser.post(`/challenges/${challenge._id}/leave`);\n      await challenge.sync();\n      expect(challenge).to.have.property('memberCount', oldMemberCount - 1);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_leave.test.js","skipped":false,"dir":"test"},{"name":"unlinks challenge tasks from leaving user when remove-all is passed","suites":["POST /challenges/:challengeId/leave","Leaving a valid challenge"],"updatePoint":{"line":75,"column":75,"index":3288},"line":75,"code":"    it('unlinks challenge tasks from leaving user when remove-all is passed', async () => {\n      await leavingUser.post(`/challenges/${challenge._id}/leave`, {\n        keep: 'remove-all'\n      });\n      const tasks = await leavingUser.get('/tasks/user');\n      const tasksTexts = tasks.map(task => task.text);\n      expect(tasksTexts).to.not.include(taskText);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_leave.test.js","skipped":false,"dir":"test"},{"name":"doesn't unlink challenge tasks from leaving user when remove-all isn't passed","suites":["POST /challenges/:challengeId/leave","Leaving a valid challenge"],"updatePoint":{"line":83,"column":87,"index":3670},"line":83,"code":"    it('doesn\\'t unlink challenge tasks from leaving user when remove-all isn\\'t passed', async () => {\n      await leavingUser.post(`/challenges/${challenge._id}/leave`, {\n        keep: 'test'\n      });\n      const tasks = await leavingUser.get('/tasks/user');\n\n      const testTask = _.find(tasks, task => task.text === taskText);\n\n      expect(testTask).to.not.be.undefined;\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_leave.test.js","skipped":false,"dir":"test"},{"name":"returns error when challengeId is not a valid UUID","suites":["POST /challenges/:challengeId/winner/:winnerId"],"updatePoint":{"line":4,"column":56,"index":320},"line":4,"code":"  it('returns error when challengeId is not a valid UUID', async () => {\n    const user = await generateUser();\n    await expect(user.post(`/challenges/test/selectWinner/${user._id}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"returns error when winnerId is not a valid UUID","suites":["POST /challenges/:challengeId/winner/:winnerId"],"updatePoint":{"line":12,"column":53,"index":633},"line":12,"code":"  it('returns error when winnerId is not a valid UUID', async () => {\n    const user = await generateUser();\n    await expect(user.post(`/challenges/${generateUUID()}/selectWinner/test`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"returns error when challengeId is not for a valid challenge","suites":["POST /challenges/:challengeId/winner/:winnerId"],"updatePoint":{"line":20,"column":65,"index":964},"line":20,"code":"  it('returns error when challengeId is not for a valid challenge', async () => {\n    const user = await generateUser();\n    await expect(user.post(`/challenges/${generateUUID()}/selectWinner/${user._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user doesn't have permissions to select winner","suites":["POST /challenges/:challengeId/winner/:winnerId","Selecting winner for a valid challenge"],"updatePoint":{"line":53,"column":77,"index":2178},"line":53,"code":"    it('returns an error when user doesn\\'t have permissions to select winner', async () => {\n      await expect(winningUser.post(`/challenges/${challenge._id}/selectWinner/${winningUser._id}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlyLeaderDeleteChal')\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"returns an error when winning user isn't part of the challenge","suites":["POST /challenges/:challengeId/winner/:winnerId","Selecting winner for a valid challenge"],"updatePoint":{"line":60,"column":71,"index":2515},"line":60,"code":"    it('returns an error when winning user isn\\'t part of the challenge', async () => {\n      const notInChallengeUser = await generateUser();\n      await expect(groupLeader.post(`/challenges/${challenge._id}/selectWinner/${notInChallengeUser._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('winnerNotFound', {\n          userId: notInChallengeUser._id\n        })\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"deletes challenge after winner is selected","suites":["POST /challenges/:challengeId/winner/:winnerId","Selecting winner for a valid challenge"],"updatePoint":{"line":70,"column":50,"index":2936},"line":70,"code":"    it('deletes challenge after winner is selected', async () => {\n      await groupLeader.post(`/challenges/${challenge._id}/selectWinner/${winningUser._id}`);\n      await sleep(0.5);\n      await expect(checkExistence('challenges', challenge._id)).to.eventually.equal(false);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"adds challenge to winner's achievements","suites":["POST /challenges/:challengeId/winner/:winnerId","Selecting winner for a valid challenge"],"updatePoint":{"line":75,"column":48,"index":3219},"line":75,"code":"    it('adds challenge to winner\\'s achievements', async () => {\n      await groupLeader.post(`/challenges/${challenge._id}/selectWinner/${winningUser._id}`);\n      await sleep(0.5);\n      await expect(winningUser.sync()).to.eventually.have.nested.property('achievements.challenges').to.include(challenge.name); // 2 because winningUser just joined the challenge, which now awards an achievement\n\n      expect(winningUser.notifications.length).to.equal(2);\n      const notif = winningUser.notifications[1];\n      expect(notif.type).to.equal('WON_CHALLENGE');\n      expect(notif.data).to.eql({\n        id: challenge._id,\n        name: challenge.name,\n        prize: challenge.prize,\n        leader: challenge.leader\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"gives winner gems as reward","suites":["POST /challenges/:challengeId/winner/:winnerId","Selecting winner for a valid challenge"],"updatePoint":{"line":90,"column":35,"index":3939},"line":90,"code":"    it('gives winner gems as reward', async () => {\n      const oldBalance = winningUser.balance;\n      await groupLeader.post(`/challenges/${challenge._id}/selectWinner/${winningUser._id}`);\n      await sleep(0.5);\n      await expect(winningUser.sync()).to.eventually.have.property('balance', oldBalance + challenge.prize / 4);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"doesn't gives winner gems if group policy prevents it","suites":["POST /challenges/:challengeId/winner/:winnerId","Selecting winner for a valid challenge"],"updatePoint":{"line":96,"column":62,"index":4303},"line":96,"code":"    it('doesn\\'t gives winner gems if group policy prevents it', async () => {\n      const oldBalance = winningUser.balance;\n      const oldLeaderBalance = (await groupLeader.sync()).balance;\n      await winningUser.update({\n        'purchased.plan.customerId': 'group-plan'\n      });\n      await group.update({\n        'leaderOnly.getGems': true,\n        'purchased.plan.customerId': 123\n      });\n      await groupLeader.post(`/challenges/${challenge._id}/selectWinner/${winningUser._id}`);\n      await sleep(0.5);\n      await expect(winningUser.sync()).to.eventually.have.property('balance', oldBalance);\n      await expect(groupLeader.sync()).to.eventually.have.property('balance', oldLeaderBalance + challenge.prize / 4);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"doesn't refund gems to group leader","suites":["POST /challenges/:challengeId/winner/:winnerId","Selecting winner for a valid challenge"],"updatePoint":{"line":111,"column":44,"index":5020},"line":111,"code":"    it('doesn\\'t refund gems to group leader', async () => {\n      const oldBalance = (await groupLeader.sync()).balance;\n      await groupLeader.post(`/challenges/${challenge._id}/selectWinner/${winningUser._id}`);\n      await sleep(0.5);\n      await expect(groupLeader.sync()).to.eventually.have.property('balance', oldBalance);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"sets broken and winner flags for user's challenge tasks","suites":["POST /challenges/:challengeId/winner/:winnerId","Selecting winner for a valid challenge"],"updatePoint":{"line":117,"column":64,"index":5379},"line":117,"code":"    it('sets broken and winner flags for user\\'s challenge tasks', async () => {\n      await groupLeader.post(`/challenges/${challenge._id}/selectWinner/${winningUser._id}`);\n      await sleep(0.5);\n      const tasks = await winningUser.get('/tasks/user');\n\n      const testTask = _.find(tasks, task => task.text === taskText);\n\n      const updatedUser = await winningUser.sync();\n      const challengeTag = updatedUser.tags.find(tags => tags.id === challenge._id);\n      expect(testTask.challenge.broken).to.eql('CHALLENGE_CLOSED');\n      expect(testTask.challenge.winner).to.eql(winningUser.profile.name);\n      expect(challengeTag.challenge).to.eql(false);\n    });","file":"api/v3/integration/challenges/POST-challenges_challengeId_winner_winnerId.test.js","skipped":false,"dir":"test"},{"name":"returns error when group is empty","suites":["POST /challenges"],"updatePoint":{"line":4,"column":39,"index":231},"line":4,"code":"  it('returns error when group is empty', async () => {\n    const user = await generateUser();\n    await expect(user.post('/challenges')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"returns error when groupId is not for a valid group","suites":["POST /challenges"],"updatePoint":{"line":12,"column":57,"index":518},"line":12,"code":"  it('returns error when groupId is not for a valid group', async () => {\n    const user = await generateUser();\n    await expect(user.post('/challenges', {\n      group: generateUUID()\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"returns error when creating a challenge in the tavern with no prize","suites":["POST /challenges"],"updatePoint":{"line":22,"column":73,"index":853},"line":22,"code":"  it('returns error when creating a challenge in the tavern with no prize', async () => {\n    const user = await generateUser();\n    await expect(user.post('/challenges', {\n      group: 'habitrpg',\n      prize: 0\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('tavChalsMinPrize')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"returns error when creating a challenge in a public guild and you are not a member of it","suites":["POST /challenges"],"updatePoint":{"line":33,"column":94,"index":1229},"line":33,"code":"  it('returns error when creating a challenge in a public guild and you are not a member of it', async () => {\n    const user = await generateUser();\n    const {\n      group\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        type: 'guild',\n        privacy: 'public'\n      }\n    });\n    await expect(user.post('/challenges', {\n      group: group._id,\n      prize: 4\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('mustBeGroupMember')\n    });\n  });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"returns an error when non-leader member creates a challenge in leaderOnly group","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":73,"column":87,"index":2361},"line":73,"code":"    it('returns an error when non-leader member creates a challenge in leaderOnly group', async () => {\n      await expect(groupMember.post('/challenges', {\n        group: group._id\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlyGroupLeaderChal')\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"allows non-leader member to create a challenge","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":82,"column":54,"index":2667},"line":82,"code":"    it('allows non-leader member to create a challenge', async () => {\n      const populatedGroup = await createAndPopulateGroup({\n        members: 1\n      });\n      group = populatedGroup.group;\n      groupMember = populatedGroup.members[0]; // eslint-disable-line prefer-destructuring\n\n      const chal = await groupMember.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label'\n      });\n      expect(chal.leader).to.eql({\n        _id: groupMember._id,\n        profile: {\n          name: groupMember.profile.name\n        }\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"doesn't take gems from user or group when challenge has no prize","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":101,"column":73,"index":3284},"line":101,"code":"    it('doesn\\'t take gems from user or group when challenge has no prize', async () => {\n      const oldUserBalance = groupLeader.balance;\n      const oldGroupBalance = group.balance;\n      await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label',\n        prize: 0\n      });\n      await expect(groupLeader.sync()).to.eventually.have.property('balance', oldUserBalance);\n      await expect(group.sync()).to.eventually.have.property('balance', oldGroupBalance);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"returns error when user and group can't pay prize","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":113,"column":58,"index":3809},"line":113,"code":"    it('returns error when user and group can\\'t pay prize', async () => {\n      await expect(groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label',\n        prize: 20\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('cantAfford')\n      });\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"takes prize out of group if it has sufficient funds","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":125,"column":59,"index":4193},"line":125,"code":"    it('takes prize out of group if it has sufficient funds', async () => {\n      const oldUserBalance = groupLeader.balance;\n      const oldGroupBalance = group.balance;\n      const prize = 4;\n      await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label',\n        prize\n      });\n      await expect(group.sync()).to.eventually.have.property('balance', oldGroupBalance - prize / 4);\n      await expect(groupLeader.sync()).to.eventually.have.property('balance', oldUserBalance);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"takes prize out of both group and user if group doesn't have enough","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":138,"column":76,"index":4768},"line":138,"code":"    it('takes prize out of both group and user if group doesn\\'t have enough', async () => {\n      const oldUserBalance = groupLeader.balance;\n      const prize = 8;\n      await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label',\n        prize\n      });\n      await expect(group.sync()).to.eventually.have.property('balance', 0);\n      await expect(groupLeader.sync()).to.eventually.have.property('balance', oldUserBalance - (prize / 4 - 1));\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"takes prize out of user if group has no balance","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":150,"column":55,"index":5269},"line":150,"code":"    it('takes prize out of user if group has no balance', async () => {\n      const oldUserBalance = groupLeader.balance;\n      const prize = 8;\n      await group.update({\n        balance: 0\n      });\n      await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label',\n        prize\n      });\n      await expect(group.sync()).to.eventually.have.property('balance', 0);\n      await expect(groupLeader.sync()).to.eventually.have.property('balance', oldUserBalance - prize / 4);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"increases challenge count of group","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":165,"column":42,"index":5807},"line":165,"code":"    it('increases challenge count of group', async () => {\n      const oldChallengeCount = group.challengeCount;\n      await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label'\n      });\n      await expect(group.sync()).to.eventually.have.property('challengeCount', oldChallengeCount + 1);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"sets challenge as official if created by admin and official flag is set","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":174,"column":79,"index":6212},"line":174,"code":"    it('sets challenge as official if created by admin and official flag is set', async () => {\n      await groupLeader.update({\n        contributor: {\n          admin: true\n        }\n      });\n      const challenge = await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label',\n        official: true\n      });\n      expect(challenge.official).to.eql(true);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"doesn't set challenge as official if official flag is set by non-admin","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":188,"column":79,"index":6647},"line":188,"code":"    it('doesn\\'t set challenge as official if official flag is set by non-admin', async () => {\n      const challenge = await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label',\n        official: true\n      });\n      expect(challenge.official).to.eql(false);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"returns an error when challenge validation fails; doesn's save user or group","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":197,"column":85,"index":6991},"line":197,"code":"    it('returns an error when challenge validation fails; doesn\\'s save user or group', async () => {\n      const oldChallengeCount = group.challengeCount;\n      const oldUserBalance = groupLeader.balance;\n      const oldGroupBalance = group.balance;\n      await expect(groupLeader.post('/challenges', {\n        group: group._id,\n        prize: 8\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'Challenge validation failed'\n      });\n      group = await group.sync();\n      groupLeader = await groupLeader.sync();\n      expect(group.challengeCount).to.eql(oldChallengeCount);\n      expect(group.balance).to.eql(oldGroupBalance);\n      expect(groupLeader.balance).to.eql(oldUserBalance);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"sets all properties of the challenge as passed","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":215,"column":54,"index":7719},"line":215,"code":"    it('sets all properties of the challenge as passed', async () => {\n      const name = 'Test Challenge';\n      const shortName = 'TC Label';\n      const description = 'Test Description';\n      const prize = 4;\n      const challenge = await groupLeader.post('/challenges', {\n        group: group._id,\n        name,\n        shortName,\n        description,\n        prize\n      });\n      expect(challenge.leader).to.eql({\n        _id: groupLeader._id,\n        profile: {\n          name: groupLeader.profile.name\n        }\n      });\n      expect(challenge.name).to.eql(name);\n      expect(challenge.shortName).to.eql(shortName);\n      expect(challenge.description).to.eql(description);\n      expect(challenge.official).to.eql(false);\n      expect(challenge.group).to.eql({\n        _id: group._id,\n        privacy: group.privacy,\n        name: group.name,\n        type: group.type\n      });\n      expect(challenge.memberCount).to.eql(0);\n      expect(challenge.prize).to.eql(prize);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"does not add challenge to creator's challenges","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":246,"column":55,"index":8708},"line":246,"code":"    it('does not add challenge to creator\\'s challenges', async () => {\n      await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label'\n      });\n      await groupLeader.sync();\n      expect(groupLeader.challenges.length).to.equal(0);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"does not award joinedChallenge achievement for creating a challenge","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":255,"column":75,"index":9041},"line":255,"code":"    it('does not award joinedChallenge achievement for creating a challenge', async () => {\n      await groupLeader.post('/challenges', {\n        group: group._id,\n        name: 'Test Challenge',\n        shortName: 'TC Label'\n      });\n      groupLeader = await groupLeader.sync();\n      expect(groupLeader.achievements.joinedChallenge).to.not.be.true;\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"sets summary to challenges name when not supplied","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":264,"column":57,"index":9384},"line":264,"code":"    it('sets summary to challenges name when not supplied', async () => {\n      const name = 'Test Challenge';\n      const challenge = await groupLeader.post('/challenges', {\n        group: group._id,\n        name,\n        shortName: 'TC Label'\n      });\n      const updatedChallenge = await groupLeader.get(`/challenges/${challenge._id}`);\n      expect(updatedChallenge.summary).to.eql(name);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"sets summary to challenges","suites":["POST /challenges","Creating a challenge for a valid group"],"updatePoint":{"line":274,"column":34,"index":9763},"line":274,"code":"    it('sets summary to challenges', async () => {\n      const name = 'Test Challenge';\n      const summary = 'Test Summary Challenge';\n      const challenge = await groupLeader.post('/challenges', {\n        group: group._id,\n        name,\n        shortName: 'TC Label',\n        summary\n      });\n      const updatedChallenge = await groupLeader.get(`/challenges/${challenge._id}`);\n      expect(updatedChallenge.summary).to.eql(summary);\n    });","file":"api/v3/integration/challenges/POST-challenges.test.js","skipped":false,"dir":"test"},{"name":"fails if the user can't view the challenge","suites":["PUT /challenges/:challengeId"],"updatePoint":{"line":30,"column":49,"index":909},"line":30,"code":"  it('fails if the user can\\'t view the challenge', async () => {\n    await expect(nonMember.put(`/challenges/${challenge._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/challenges/PUT-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"should only allow the leader or an admin to update the challenge","suites":["PUT /challenges/:challengeId"],"updatePoint":{"line":37,"column":70,"index":1190},"line":37,"code":"  it('should only allow the leader or an admin to update the challenge', async () => {\n    await expect(member.put(`/challenges/${challenge._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyLeaderUpdateChal')\n    });\n  });","file":"api/v3/integration/challenges/PUT-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"only updates allowed fields","suites":["PUT /challenges/:challengeId"],"updatePoint":{"line":44,"column":33,"index":1439},"line":44,"code":"  it('only updates allowed fields', async () => {\n    const res = await user.put(`/challenges/${challenge._id}`, {\n      // ignored\n      prize: 33,\n      group: 'blabla',\n      memberCount: 33,\n      tasksOrder: 'new order',\n      official: true,\n      shortName: 'new short name',\n      leader: member._id,\n      // applied\n      name: 'New Challenge Name',\n      description: 'New challenge description.'\n    });\n    expect(res.prize).to.equal(0);\n    expect(res.group).to.eql({\n      _id: privateGuild._id,\n      privacy: privateGuild.privacy,\n      name: privateGuild.name,\n      type: privateGuild.type\n    });\n    expect(res.memberCount).to.equal(2);\n    expect(res.tasksOrder).not.to.equal('new order');\n    expect(res.official).to.equal(false);\n    expect(res.leader).to.eql({\n      _id: user._id,\n      id: user._id,\n      profile: {\n        name: user.profile.name\n      },\n      auth: {\n        local: {\n          username: user.auth.local.username\n        }\n      },\n      flags: {\n        verifiedUsername: true\n      }\n    });\n    expect(res.name).to.equal('New Challenge Name');\n    expect(res.description).to.equal('New challenge description.');\n  });","file":"api/v3/integration/challenges/PUT-challenges_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns an error is message does not exist","suites":["DELETE /groups/:groupId/chat/:chatId","Chat errors"],"updatePoint":{"line":31,"column":50,"index":901},"line":31,"code":"    it('returns an error is message does not exist', async () => {\n      const fakeChatId = generateUUID();\n      await expect(user.del(`/groups/${groupWithChat._id}/chat/${fakeChatId}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageGroupChatNotFound')\n      });\n    });","file":"api/v3/integration/chat/DELETE-chat_id.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user does not have permission to delete","suites":["DELETE /groups/:groupId/chat/:chatId","Chat errors"],"updatePoint":{"line":39,"column":69,"index":1255},"line":39,"code":"    it('returns an error when user does not have permission to delete', async () => {\n      await expect(userThatDidNotCreateChat.del(`/groups/${groupWithChat._id}/chat/${message.id}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlyCreatorOrAdminCanDeleteChat')\n      });\n    });","file":"api/v3/integration/chat/DELETE-chat_id.test.js","skipped":false,"dir":"test"},{"name":"allows creator to delete a their message","suites":["DELETE /groups/:groupId/chat/:chatId","Chat success"],"updatePoint":{"line":55,"column":48,"index":1839},"line":55,"code":"    it('allows creator to delete a their message', async () => {\n      await user.del(`/groups/${groupWithChat._id}/chat/${nextMessage.id}`);\n      const returnedMessages = await user.get(`/groups/${groupWithChat._id}/chat/`);\n      const messageFromUser = returnedMessages.find(returnedMessage => returnedMessage.id === nextMessage.id);\n      expect(returnedMessages).is.an('array');\n      expect(messageFromUser).to.not.exist;\n    });","file":"api/v3/integration/chat/DELETE-chat_id.test.js","skipped":false,"dir":"test"},{"name":"allows admin to delete another user's message","suites":["DELETE /groups/:groupId/chat/:chatId","Chat success"],"updatePoint":{"line":62,"column":54,"index":2282},"line":62,"code":"    it('allows admin to delete another user\\'s message', async () => {\n      await admin.del(`/groups/${groupWithChat._id}/chat/${nextMessage.id}`);\n      const returnedMessages = await user.get(`/groups/${groupWithChat._id}/chat/`);\n      const messageFromUser = returnedMessages.find(returnedMessage => returnedMessage.id === nextMessage.id);\n      expect(returnedMessages).is.an('array');\n      expect(messageFromUser).to.not.exist;\n    });","file":"api/v3/integration/chat/DELETE-chat_id.test.js","skipped":false,"dir":"test"},{"name":"returns empty when previous message parameter is passed and the last message was deleted","suites":["DELETE /groups/:groupId/chat/:chatId","Chat success"],"updatePoint":{"line":69,"column":96,"index":2768},"line":69,"code":"    it('returns empty when previous message parameter is passed and the last message was deleted', async () => {\n      await expect(user.del(`/groups/${groupWithChat._id}/chat/${nextMessage.id}?previousMsg=${nextMessage.id}`)).to.eventually.be.empty;\n    });","file":"api/v3/integration/chat/DELETE-chat_id.test.js","skipped":false,"dir":"test"},{"name":"returns the update chat when previous message parameter is passed and the chat is updated","suites":["DELETE /groups/:groupId/chat/:chatId","Chat success"],"updatePoint":{"line":72,"column":97,"index":3028},"line":72,"code":"    it('returns the update chat when previous message parameter is passed and the chat is updated', async () => {\n      const updatedChat = await user.del(`/groups/${groupWithChat._id}/chat/${nextMessage.id}?previousMsg=${message.id}`);\n      expect(updatedChat[0].id).to.eql(message.id);\n    });","file":"api/v3/integration/chat/DELETE-chat_id.test.js","skipped":false,"dir":"test"},{"name":"returns Guild chat","suites":["GET /groups/:groupId/chat","public Guild"],"updatePoint":{"line":29,"column":26,"index":724},"line":29,"code":"    it('returns Guild chat', async () => {\n      const chat = await user.get(`/groups/${group._id}/chat`);\n      expect(chat[0].id).to.eql(group.chat[0].id);\n      expect(chat[1].id).to.eql(group.chat[1].id);\n    });","file":"api/v3/integration/chat/GET-chat.test.js","skipped":false,"dir":"test"},{"name":"returns error if user is not member of requested private group","suites":["GET /groups/:groupId/chat","private Guild"],"updatePoint":{"line":49,"column":70,"index":1336},"line":49,"code":"    it('returns error if user is not member of requested private group', async () => {\n      await expect(user.get(`/groups/${group._id}/chat`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/chat/GET-chat.test.js","skipped":false,"dir":"test"},{"name":"clears new messages for a guild","suites":["POST /groups/:id/chat/seen","Guild"],"updatePoint":{"line":29,"column":39,"index":835},"line":29,"code":"    it('clears new messages for a guild', async () => {\n      await sleep(1);\n      await guildMember.sync();\n      const initialNotifications = guildMember.notifications.length;\n      await guildMember.post(`/groups/${guild._id}/chat/seen`);\n      await sleep(1);\n      const guildThatHasSeenChat = await guildMember.get('/user');\n      expect(guildThatHasSeenChat.notifications.length).to.equal(initialNotifications - 1);\n      expect(guildThatHasSeenChat.newMessages).to.be.empty;\n    });","file":"api/v3/integration/chat/POST-chat_seen.test.js","skipped":false,"dir":"test"},{"name":"clears new messages for a party","suites":["POST /groups/:id/chat/seen","Party"],"updatePoint":{"line":66,"column":39,"index":1994},"line":66,"code":"    it('clears new messages for a party', async () => {\n      await sleep(1);\n      await partyMember.sync();\n      const initialNotifications = partyMember.notifications.length;\n      await partyMember.post(`/groups/${party._id}/chat/seen`);\n      await sleep(1);\n      const partyMemberThatHasSeenChat = await partyMember.get('/user');\n      expect(partyMemberThatHasSeenChat.notifications.length).to.equal(initialNotifications - 1);\n      expect(partyMemberThatHasSeenChat.newMessages).to.be.empty;\n    });","file":"api/v3/integration/chat/POST-chat_seen.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when chat message is not found","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":40,"column":53,"index":1290},"line":40,"code":"  it('Returns an error when chat message is not found', async () => {\n    await expect(user.post(`/groups/${group._id}/chat/incorrectMessage/flag`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageGroupChatNotFound')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"Allows players to flag their own message","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":47,"column":46,"index":1569},"line":47,"code":"  it('Allows players to flag their own message', async () => {\n    const message = await user.post(`/groups/${group._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    await expect(user.post(`/groups/${group._id}/chat/${message.message.id}/flag`)).to.eventually.be.ok;\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"Flags a chat and sends normal message to moderator Slack when user is not new","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":53,"column":83,"index":1883},"line":53,"code":"  it('Flags a chat and sends normal message to moderator Slack when user is not new', async () => {\n    const {\n      message\n    } = await anotherUser.post(`/groups/${group._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    const flagResult = await user.post(`/groups/${group._id}/chat/${message.id}/flag`);\n    expect(flagResult.flags[user._id]).to.equal(true);\n    expect(flagResult.flagCount).to.equal(1);\n    const groupWithFlags = await admin.get(`/groups/${group._id}`);\n    const messageToCheck = find(groupWithFlags.chat, {\n      id: message.id\n    });\n    expect(messageToCheck.flags[user._id]).to.equal(true); // Slack message to mods\n\n    const timestamp = `${moment(message.timestamp).utc().format('YYYY-MM-DD HH:mm')} UTC`;\n    /* eslint-disable camelcase */\n\n    expect(IncomingWebhook.prototype.send).to.be.calledWith({\n      text: `${user.profile.name} (${user.id}; language: en) flagged a group message`,\n      attachments: [{\n        fallback: 'Flag Message',\n        color: 'danger',\n        author_name: `@${anotherUser.auth.local.username} ${anotherUser.profile.name} (${anotherUser.auth.local.email}; ${anotherUser._id})\\n${timestamp}`,\n        title: 'Flag in Test Guild',\n        title_link: `${BASE_URL}/groups/guild/${group._id}`,\n        text: TEST_MESSAGE,\n        footer: `<https://habitrpg.github.io/flag-o-rama/?groupId=${group._id}&chatId=${message.id}|Flag this message.>`,\n        mrkdwn_in: ['text']\n      }]\n    });\n    /* eslint-ensable camelcase */\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"Does not increment message flag count and sends different message to moderator Slack when user is new","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":86,"column":107,"index":3404},"line":86,"code":"  it('Does not increment message flag count and sends different message to moderator Slack when user is new', async () => {\n    const automatedComment = `The post's flag count has not been increased because the flagger's account is less than ${USER_AGE_FOR_FLAGGING} days old.`;\n    const {\n      message\n    } = await newUser.post(`/groups/${group._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    const flagResult = await newUser.post(`/groups/${group._id}/chat/${message.id}/flag`);\n    expect(flagResult.flags[newUser._id]).to.equal(true);\n    expect(flagResult.flagCount).to.equal(0);\n    const groupWithFlags = await admin.get(`/groups/${group._id}`);\n    const messageToCheck = find(groupWithFlags.chat, {\n      id: message.id\n    });\n    expect(messageToCheck.flags[newUser._id]).to.equal(true); // Slack message to mods\n\n    const timestamp = `${moment(message.timestamp).utc().format('YYYY-MM-DD HH:mm')} UTC`;\n    /* eslint-disable camelcase */\n\n    expect(IncomingWebhook.prototype.send).to.be.calledWith({\n      text: `${newUser.profile.name} (${newUser.id}; language: en) flagged a group message`,\n      attachments: [{\n        fallback: 'Flag Message',\n        color: 'danger',\n        author_name: `@${newUser.auth.local.username} ${newUser.profile.name} (${newUser.auth.local.email}; ${newUser._id})\\n${timestamp}`,\n        title: 'Flag in Test Guild',\n        title_link: `${BASE_URL}/groups/guild/${group._id}`,\n        text: TEST_MESSAGE,\n        footer: `<https://habitrpg.github.io/flag-o-rama/?groupId=${group._id}&chatId=${message.id}|Flag this message.> ${automatedComment}`,\n        mrkdwn_in: ['text']\n      }]\n    });\n    /* eslint-ensable camelcase */\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"Flags a chat when the author's account was deleted","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":120,"column":57,"index":5045},"line":120,"code":"  it('Flags a chat when the author\\'s account was deleted', async () => {\n    const deletedUser = await generateUser();\n    const {\n      message\n    } = await deletedUser.post(`/groups/${group._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    await deletedUser.del('/user', {\n      password: 'password'\n    });\n    const flagResult = await user.post(`/groups/${group._id}/chat/${message.id}/flag`);\n    expect(flagResult.flags[user._id]).to.equal(true);\n    expect(flagResult.flagCount).to.equal(1);\n    const groupWithFlags = await admin.get(`/groups/${group._id}`);\n    const messageToCheck = find(groupWithFlags.chat, {\n      id: message.id\n    });\n    expect(messageToCheck.flags[user._id]).to.equal(true);\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"Flags a chat with a higher flag acount when an admin flags the message","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":139,"column":76,"index":5786},"line":139,"code":"  it('Flags a chat with a higher flag acount when an admin flags the message', async () => {\n    const {\n      message\n    } = await user.post(`/groups/${group._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    const flagResult = await admin.post(`/groups/${group._id}/chat/${message.id}/flag`);\n    expect(flagResult.flags[admin._id]).to.equal(true);\n    expect(flagResult.flagCount).to.equal(5);\n    const groupWithFlags = await admin.get(`/groups/${group._id}`);\n    const messageToCheck = find(groupWithFlags.chat, {\n      id: message.id\n    });\n    expect(messageToCheck.flags[admin._id]).to.equal(true);\n    expect(messageToCheck.flagCount).to.equal(5);\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"allows admin to flag a message in a private group","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":155,"column":55,"index":6434},"line":155,"code":"  it('allows admin to flag a message in a private group', async () => {\n    const privateGroup = await user.post('/groups', {\n      name: 'Test party',\n      type: 'party',\n      privacy: 'private'\n    });\n    await user.post(`/groups/${privateGroup._id}/invite`, {\n      uuids: [anotherUser._id]\n    });\n    await anotherUser.post(`/groups/${privateGroup._id}/join`);\n    const {\n      message\n    } = await user.post(`/groups/${privateGroup._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    const flagResult = await admin.post(`/groups/${privateGroup._id}/chat/${message.id}/flag`);\n    expect(flagResult.flags[admin._id]).to.equal(true);\n    expect(flagResult.flagCount).to.equal(5);\n    const groupWithFlags = await anotherUser.get(`/groups/${privateGroup._id}`);\n    const messageToCheck = find(groupWithFlags.chat, {\n      id: message.id\n    });\n    expect(messageToCheck).to.not.exist;\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"does not allow non member to flag message in private group","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":179,"column":64,"index":7346},"line":179,"code":"  it('does not allow non member to flag message in private group', async () => {\n    const privateGroup = await user.post('/groups', {\n      name: 'Test party',\n      type: 'party',\n      privacy: 'private'\n    });\n    const {\n      message\n    } = await user.post(`/groups/${privateGroup._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    await expect(anotherUser.post(`/groups/${privateGroup._id}/chat/${message.id}/flag`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when user tries to flag a message that they already flagged","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":196,"column":82,"index":7919},"line":196,"code":"  it('Returns an error when user tries to flag a message that they already flagged', async () => {\n    const {\n      message\n    } = await anotherUser.post(`/groups/${group._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    await user.post(`/groups/${group._id}/chat/${message.id}/flag`);\n    await expect(user.post(`/groups/${group._id}/chat/${message.id}/flag`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageGroupChatFlagAlreadyReported')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"shows a hidden message to the original poster","suites":["POST /chat/:chatId/flag"],"updatePoint":{"line":209,"column":51,"index":8404},"line":209,"code":"  it('shows a hidden message to the original poster', async () => {\n    const {\n      message\n    } = await user.post(`/groups/${group._id}/chat`, {\n      message: TEST_MESSAGE\n    });\n    await admin.post(`/groups/${group._id}/chat/${message.id}/flag`);\n    const groupWithFlags = await user.get(`/groups/${group._id}`);\n    const messageToCheck = find(groupWithFlags.chat, {\n      id: message.id\n    });\n    expect(messageToCheck).to.exist;\n    const auGroupWithFlags = await anotherUser.get(`/groups/${group._id}`);\n    const auMessageToCheck = find(auGroupWithFlags.chat, {\n      id: message.id\n    });\n    expect(auMessageToCheck).to.not.exist;\n  });","file":"api/v3/integration/chat/POST-chat.flag.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when chat message is not found","suites":["POST /chat/:chatId/like"],"updatePoint":{"line":25,"column":53,"index":700},"line":25,"code":"  it('Returns an error when chat message is not found', async () => {\n    await expect(user.post(`/groups/${groupWithChat._id}/chat/incorrectMessage/like`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageGroupChatNotFound')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.like.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when user tries to like their own message","suites":["POST /chat/:chatId/like"],"updatePoint":{"line":32,"column":64,"index":1005},"line":32,"code":"  it('Returns an error when user tries to like their own message', async () => {\n    const message = await user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: testMessage\n    });\n    await expect(user.post(`/groups/${groupWithChat._id}/chat/${message.message.id}/like`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageGroupChatLikeOwnMessage')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.like.test.js","skipped":false,"dir":"test"},{"name":"Likes a chat","suites":["POST /chat/:chatId/like"],"updatePoint":{"line":42,"column":18,"index":1385},"line":42,"code":"  it('Likes a chat', async () => {\n    const message = await anotherUser.post(`/groups/${groupWithChat._id}/chat`, {\n      message: testMessage\n    });\n    const likeResult = await user.post(`/groups/${groupWithChat._id}/chat/${message.message.id}/like`);\n    expect(likeResult.likes[user._id]).to.equal(true);\n    const groupWithChatLikes = await user.get(`/groups/${groupWithChat._id}`);\n    const messageToCheck = find(groupWithChatLikes.chat, {\n      id: message.message.id\n    });\n    expect(messageToCheck.likes[user._id]).to.equal(true);\n  });","file":"api/v3/integration/chat/POST-chat.like.test.js","skipped":false,"dir":"test"},{"name":"Unlikes a chat","suites":["POST /chat/:chatId/like"],"updatePoint":{"line":54,"column":20,"index":1938},"line":54,"code":"  it('Unlikes a chat', async () => {\n    const message = await anotherUser.post(`/groups/${groupWithChat._id}/chat`, {\n      message: testMessage\n    });\n    const likeResult = await user.post(`/groups/${groupWithChat._id}/chat/${message.message.id}/like`);\n    expect(likeResult.likes[user._id]).to.equal(true);\n    const unlikeResult = await user.post(`/groups/${groupWithChat._id}/chat/${message.message.id}/like`);\n    expect(unlikeResult.likes[user._id]).to.equal(false);\n    const groupWithoutChatLikes = await user.get(`/groups/${groupWithChat._id}`);\n    const messageToCheck = find(groupWithoutChatLikes.chat, {\n      id: message.message.id\n    });\n    expect(messageToCheck.likes[user._id]).to.equal(false);\n  });","file":"api/v3/integration/chat/POST-chat.like.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when no message is provided","suites":["POST /chat"],"updatePoint":{"line":45,"column":50,"index":1751},"line":45,"code":"  it('Returns an error when no message is provided', async () => {\n    await expect(user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: ''\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when an empty message is provided","suites":["POST /chat"],"updatePoint":{"line":54,"column":56,"index":2047},"line":54,"code":"  it('Returns an error when an empty message is provided', async () => {\n    await expect(user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: '    '\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when an message containing only newlines is provided","suites":["POST /chat"],"updatePoint":{"line":63,"column":75,"index":2366},"line":63,"code":"  it('Returns an error when an message containing only newlines is provided', async () => {\n    await expect(user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: '\\n\\n'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when group is not found","suites":["POST /chat"],"updatePoint":{"line":72,"column":46,"index":2656},"line":72,"code":"  it('Returns an error when group is not found', async () => {\n    await expect(user.post('/groups/invalidID/chat', {\n      message: testMessage\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"returns an error when chat privileges are revoked when sending a message to a public guild","suites":["POST /chat","mute user"],"updatePoint":{"line":87,"column":98,"index":3116},"line":87,"code":"    it('returns an error when chat privileges are revoked when sending a message to a public guild', async () => {\n      const userWithChatRevoked = await member.update({\n        'flags.chatRevoked': true\n      });\n      await expect(userWithChatRevoked.post(`/groups/${groupWithChat._id}/chat`, {\n        message: testMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('chatPrivilegesRevoked')\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not error when chat privileges are revoked when sending a message to a private guild","suites":["POST /chat","mute user"],"updatePoint":{"line":99,"column":97,"index":3601},"line":99,"code":"    it('does not error when chat privileges are revoked when sending a message to a private guild', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'Private Guild',\n          type: 'guild',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const privateGuildMemberWithChatsRevoked = members[0];\n      await privateGuildMemberWithChatsRevoked.update({\n        'flags.chatRevoked': true\n      });\n      const message = await privateGuildMemberWithChatsRevoked.post(`/groups/${group._id}/chat`, {\n        message: testMessage\n      });\n      expect(message.message.id).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not error when chat privileges are revoked when sending a message to a party","suites":["POST /chat","mute user"],"updatePoint":{"line":120,"column":89,"index":4294},"line":120,"code":"    it('does not error when chat privileges are revoked when sending a message to a party', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'Party',\n          type: 'party',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const privatePartyMemberWithChatsRevoked = members[0];\n      await privatePartyMemberWithChatsRevoked.update({\n        'flags.chatRevoked': true\n      });\n      const message = await privatePartyMemberWithChatsRevoked.post(`/groups/${group._id}/chat`, {\n        message: testMessage\n      });\n      expect(message.message.id).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"creates a chat with flagCount already set and notifies mods when sending a message to a public guild","suites":["POST /chat","shadow-mute user"],"updatePoint":{"line":153,"column":108,"index":5319},"line":153,"code":"    it('creates a chat with flagCount already set and notifies mods when sending a message to a public guild', async () => {\n      const userWithChatShadowMuted = await member.update({\n        'flags.chatShadowMuted': true\n      });\n      const message = await userWithChatShadowMuted.post(`/groups/${groupWithChat._id}/chat`, {\n        message: testMessage\n      });\n      expect(message.message.id).to.exist;\n      expect(message.message.flagCount).to.eql(CHAT_FLAG_FROM_SHADOW_MUTE); // Email sent to mods\n\n      await sleep(0.5);\n      expect(email.sendTxn).to.be.calledOnce;\n      expect(email.sendTxn.args[0][1]).to.eql('shadow-muted-post-report-to-mods'); // Slack message to mods\n\n      expect(IncomingWebhook.prototype.send).to.be.calledOnce;\n      /* eslint-disable camelcase */\n\n      expect(IncomingWebhook.prototype.send).to.be.calledWith({\n        text: `@${member.auth.local.username} / ${member.profile.name} posted while shadow-muted`,\n        attachments: [{\n          fallback: 'Shadow-Muted Message',\n          color: 'danger',\n          author_name: `@${member.auth.local.username} ${member.profile.name} (${member.auth.local.email}; ${member._id})`,\n          title: 'Shadow-Muted Post in Test Guild',\n          title_link: `${BASE_URL}/groups/guild/${groupWithChat.id}`,\n          text: testMessage,\n          mrkdwn_in: ['text']\n        }]\n      });\n      /* eslint-enable camelcase */\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"creates a chat with zero flagCount when sending a message to a private guild","suites":["POST /chat","shadow-mute user"],"updatePoint":{"line":184,"column":84,"index":6713},"line":184,"code":"    it('creates a chat with zero flagCount when sending a message to a private guild', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'Private Guild',\n          type: 'guild',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const userWithChatShadowMuted = members[0];\n      await userWithChatShadowMuted.update({\n        'flags.chatShadowMuted': true\n      });\n      const message = await userWithChatShadowMuted.post(`/groups/${group._id}/chat`, {\n        message: testMessage\n      });\n      expect(message.message.id).to.exist;\n      expect(message.message.flagCount).to.eql(0);\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"creates a chat with zero flagCount when sending a message to a party","suites":["POST /chat","shadow-mute user"],"updatePoint":{"line":206,"column":76,"index":7415},"line":206,"code":"    it('creates a chat with zero flagCount when sending a message to a party', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'Party',\n          type: 'party',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const userWithChatShadowMuted = members[0];\n      await userWithChatShadowMuted.update({\n        'flags.chatShadowMuted': true\n      });\n      const message = await userWithChatShadowMuted.post(`/groups/${group._id}/chat`, {\n        message: testMessage\n      });\n      expect(message.message.id).to.exist;\n      expect(message.message.flagCount).to.eql(0);\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"creates a chat with zero flagCount when non-shadow-muted user sends a message to a public guild","suites":["POST /chat","shadow-mute user"],"updatePoint":{"line":228,"column":103,"index":8136},"line":228,"code":"    it('creates a chat with zero flagCount when non-shadow-muted user sends a message to a public guild', async () => {\n      const message = await member.post(`/groups/${groupWithChat._id}/chat`, {\n        message: testMessage\n      });\n      expect(message.message.id).to.exist;\n      expect(message.message.flagCount).to.eql(0);\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"returns an error when chat message contains a banned word in tavern","suites":["POST /chat","banned word"],"updatePoint":{"line":237,"column":75,"index":8487},"line":237,"code":"    it('returns an error when chat message contains a banned word in tavern', async () => {\n      await expect(user.post('/groups/habitrpg/chat', {\n        message: testBannedWordMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: bannedWordErrorMessage\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"returns an error when chat message contains a banned word in a public guild","suites":["POST /chat","banned word"],"updatePoint":{"line":246,"column":83,"index":8834},"line":246,"code":"    it('returns an error when chat message contains a banned word in a public guild', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'public guild',\n          type: 'guild',\n          privacy: 'public'\n        },\n        members: 1\n      });\n      await expect(members[0].post(`/groups/${group._id}/chat`, {\n        message: testBannedWordMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: bannedWordErrorMessage\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"errors when word is part of a phrase","suites":["POST /chat","banned word"],"updatePoint":{"line":266,"column":44,"index":9387},"line":266,"code":"    it('errors when word is part of a phrase', async () => {\n      const wordInPhrase = `phrase ${testBannedWordMessage} end`;\n      await expect(user.post('/groups/habitrpg/chat', {\n        message: wordInPhrase\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: bannedWordErrorMessage\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"errors when word is surrounded by non alphabet characters","suites":["POST /chat","banned word"],"updatePoint":{"line":276,"column":65,"index":9773},"line":276,"code":"    it('errors when word is surrounded by non alphabet characters', async () => {\n      const wordInPhrase = `_!${testBannedWordMessage}@_`;\n      await expect(user.post('/groups/habitrpg/chat', {\n        message: wordInPhrase\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: bannedWordErrorMessage\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"errors when word is typed in mixed case","suites":["POST /chat","banned word"],"updatePoint":{"line":286,"column":47,"index":10134},"line":286,"code":"    it('errors when word is typed in mixed case', async () => {\n      const substrLength = Math.floor(testBannedWordMessage.length / 2);\n      const chatMessage = testBannedWordMessage.substring(0, substrLength).toLowerCase() + testBannedWordMessage.substring(substrLength).toUpperCase();\n      await expect(user.post('/groups/habitrpg/chat', {\n        message: chatMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('bannedWordUsed', {\n          swearWordsUsed: chatMessage\n        })\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"checks error message has all the banned words used, regardless of case","suites":["POST /chat","banned word"],"updatePoint":{"line":299,"column":78,"index":10739},"line":299,"code":"    it('checks error message has all the banned words used, regardless of case', async () => {\n      const testBannedWords = [testBannedWordMessage.toUpperCase(), testBannedWordMessage1.toLowerCase()];\n      const chatMessage = `Mixing ${testBannedWords[0]} and ${testBannedWords[1]} is bad for you.`;\n      await expect(user.post('/groups/habitrpg/chat', {\n        message: chatMessage\n      })).to.eventually.be.rejected.and.have.property('message').that.includes(testBannedWords.join(', '));\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not error when bad word is suffix of a word","suites":["POST /chat","banned word"],"updatePoint":{"line":306,"column":56,"index":11220},"line":306,"code":"    it('does not error when bad word is suffix of a word', async () => {\n      const wordAsSuffix = `prefix${testBannedWordMessage}`;\n      const message = await user.post('/groups/habitrpg/chat', {\n        message: wordAsSuffix\n      });\n      expect(message.message.id).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not error when bad word is prefix of a word","suites":["POST /chat","banned word"],"updatePoint":{"line":313,"column":56,"index":11510},"line":313,"code":"    it('does not error when bad word is prefix of a word', async () => {\n      const wordAsPrefix = `${testBannedWordMessage}suffix`;\n      const message = await user.post('/groups/habitrpg/chat', {\n        message: wordAsPrefix\n      });\n      expect(message.message.id).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not error when sending a chat message containing a banned word to a party","suites":["POST /chat","banned word"],"updatePoint":{"line":320,"column":86,"index":11830},"line":320,"code":"    it('does not error when sending a chat message containing a banned word to a party', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'Party',\n          type: 'party',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const message = await members[0].post(`/groups/${group._id}/chat`, {\n        message: testBannedWordMessage\n      });\n      expect(message.message.id).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not error when sending a chat message containing a banned word to a public guild in which banned words are allowed","suites":["POST /chat","banned word"],"updatePoint":{"line":337,"column":127,"index":12378},"line":337,"code":"    it('does not error when sending a chat message containing a banned word to a public guild in which banned words are allowed', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'public guild',\n          type: 'guild',\n          privacy: 'public'\n        },\n        members: 1\n      }); // Update the bannedWordsAllowed property for the group\n\n      group.update({\n        bannedWordsAllowed: true\n      });\n      const message = await members[0].post(`/groups/${group._id}/chat`, {\n        message: testBannedWordMessage\n      });\n      expect(message.message.id).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not error when sending a chat message containing a banned word to a private guild","suites":["POST /chat","banned word"],"updatePoint":{"line":358,"column":94,"index":13020},"line":358,"code":"    it('does not error when sending a chat message containing a banned word to a private guild', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'private guild',\n          type: 'guild',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const message = await members[0].post(`/groups/${group._id}/chat`, {\n        message: testBannedWordMessage\n      });\n      expect(message.message.id).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"errors and revokes privileges when chat message contains a banned slur","suites":["POST /chat","banned slur"],"updatePoint":{"line":387,"column":78,"index":13836},"line":387,"code":"    it('errors and revokes privileges when chat message contains a banned slur', async () => {\n      await expect(user.post(`/groups/${groupWithChat._id}/chat`, {\n        message: testSlurMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('bannedSlurUsed')\n      }); // Email sent to mods\n\n      await sleep(0.5);\n      expect(email.sendTxn).to.be.calledOnce;\n      expect(email.sendTxn.args[0][1]).to.eql('slur-report-to-mods'); // Slack message to mods\n\n      expect(IncomingWebhook.prototype.send).to.be.calledOnce;\n      /* eslint-disable camelcase */\n\n      expect(IncomingWebhook.prototype.send).to.be.calledWith({\n        text: `${user.profile.name} (${user.id}) tried to post a slur`,\n        attachments: [{\n          fallback: 'Slur Message',\n          color: 'danger',\n          author_name: `@${user.auth.local.username} ${user.profile.name} (${user.auth.local.email}; ${user._id})`,\n          title: 'Slur in Test Guild',\n          title_link: `${BASE_URL}/groups/guild/${groupWithChat.id}`,\n          text: testSlurMessage,\n          mrkdwn_in: ['text']\n        }]\n      });\n      /* eslint-enable camelcase */\n      // Chat privileges are revoked\n\n      await expect(user.post(`/groups/${groupWithChat._id}/chat`, {\n        message: testMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('chatPrivilegesRevoked')\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not allow slurs in private groups","suites":["POST /chat","banned slur"],"updatePoint":{"line":426,"column":46,"index":15293},"line":426,"code":"    it('does not allow slurs in private groups', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'Party',\n          type: 'party',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      await expect(members[0].post(`/groups/${group._id}/chat`, {\n        message: testSlurMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('bannedSlurUsed')\n      }); // Email sent to mods\n\n      await sleep(0.5);\n      expect(email.sendTxn).to.be.calledThrice;\n      expect(email.sendTxn.args[2][1]).to.eql('slur-report-to-mods'); // Slack message to mods\n\n      expect(IncomingWebhook.prototype.send).to.be.calledOnce;\n      /* eslint-disable camelcase */\n\n      expect(IncomingWebhook.prototype.send).to.be.calledWith({\n        text: `${members[0].profile.name} (${members[0].id}) tried to post a slur`,\n        attachments: [{\n          fallback: 'Slur Message',\n          color: 'danger',\n          author_name: `@${members[0].auth.local.username} ${members[0].profile.name} (${members[0].auth.local.email}; ${members[0]._id})`,\n          title: 'Slur in Party - (private party)',\n          title_link: undefined,\n          text: testSlurMessage,\n          mrkdwn_in: ['text']\n        }]\n      });\n      /* eslint-enable camelcase */\n      // Chat privileges are revoked\n\n      await expect(members[0].post(`/groups/${groupWithChat._id}/chat`, {\n        message: testMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('chatPrivilegesRevoked')\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"errors when slur is typed in mixed case","suites":["POST /chat","banned slur"],"updatePoint":{"line":476,"column":47,"index":16998},"line":476,"code":"    it('errors when slur is typed in mixed case', async () => {\n      const substrLength = Math.floor(testSlurMessage1.length / 2);\n      const chatMessage = testSlurMessage1.substring(0, substrLength).toLowerCase() + testSlurMessage1.substring(substrLength).toUpperCase();\n      await expect(user.post('/groups/habitrpg/chat', {\n        message: chatMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('bannedSlurUsed')\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"creates a chat","suites":["POST /chat","banned slur"],"updatePoint":{"line":488,"column":20,"index":17485},"line":488,"code":"  it('creates a chat', async () => {\n    const newMessage = await user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: testMessage\n    });\n    const groupMessages = await user.get(`/groups/${groupWithChat._id}/chat`);\n    expect(newMessage.message.id).to.exist;\n    expect(groupMessages[0].id).to.exist;\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"creates a chat with mentions","suites":["POST /chat","banned slur"],"updatePoint":{"line":496,"column":34,"index":17820},"line":496,"code":"  it('creates a chat with mentions', async () => {\n    const messageWithMentions = `hi @${member.auth.local.username}`;\n    const newMessage = await user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: messageWithMentions\n    });\n    const groupMessages = await user.get(`/groups/${groupWithChat._id}/chat`);\n    expect(newMessage.message.id).to.exist;\n    expect(newMessage.message.text).to.include(`[@${member.auth.local.username}](/profile/${member._id})`);\n    expect(groupMessages[0].id).to.exist;\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"creates a chat with a max length of 3000 chars","suites":["POST /chat","banned slur"],"updatePoint":{"line":506,"column":52,"index":18358},"line":506,"code":"  it('creates a chat with a max length of 3000 chars', async () => {\n    const veryLongMessage = `\n    123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789.\n    THIS PART WON'T BE IN THE MESSAGE (over 3000)\n    `;\n    expect(veryLongMessage.length > MAX_MESSAGE_LENGTH).to.equal(true);\n    const newMessage = await user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: veryLongMessage\n    });\n    const groupMessages = await user.get(`/groups/${groupWithChat._id}/chat`);\n    expect(newMessage.message.id).to.exist;\n    expect(groupMessages[0].id).to.exist;\n    expect(newMessage.message.text.length).to.eql(MAX_MESSAGE_LENGTH);\n    expect(newMessage.message.text).to.not.contain('MESSAGE');\n    expect(groupMessages[0].text.length).to.eql(MAX_MESSAGE_LENGTH);\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"chat message with mentions - mention link should not count towards 3000 chars limit","suites":["POST /chat","banned slur"],"updatePoint":{"line":522,"column":89,"index":22119},"line":522,"code":"  it('chat message with mentions - mention link should not count towards 3000 chars limit', async () => {\n    const memberUsername = 'memberUsername';\n    await member.update({\n      'auth.local.username': memberUsername\n    });\n    const messageWithMentions = `hi @${memberUsername} 123456789\n     123456789 123456789 123456789 123456789 123456789 123456789 89 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 12345678 END.`;\n    expect(messageWithMentions.length).to.equal(MAX_MESSAGE_LENGTH);\n    const newMessage = await user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: messageWithMentions\n    });\n    const groupMessages = await user.get(`/groups/${groupWithChat._id}/chat`);\n    const mentionLink = `[@${memberUsername}](/profile/${member._id})`;\n    expect(newMessage.message.text).to.include(mentionLink);\n    expect(newMessage.message.text).to.include(' END.');\n    expect(newMessage.message.text.length).to.eql(messageWithMentions.length - `@${memberUsername}`.length + mentionLink.length);\n    expect(groupMessages[0].text.length).to.eql(newMessage.message.text.length);\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"creates a chat with user styles","suites":["POST /chat","banned slur"],"updatePoint":{"line":540,"column":37,"index":26011},"line":540,"code":"  it('creates a chat with user styles', async () => {\n    const mount = 'test-mount';\n    const pet = 'test-pet';\n    const style = 'test-style';\n    const userWithStyle = await generateUser({\n      'items.currentMount': mount,\n      'items.currentPet': pet,\n      'preferences.style': style\n    });\n    await userWithStyle.sync();\n    const message = await userWithStyle.post(`/groups/${groupWithChat._id}/chat`, {\n      message: testMessage\n    });\n    expect(message.message.id).to.exist;\n    expect(message.message.userStyles.items.currentMount).to.eql(userWithStyle.items.currentMount);\n    expect(message.message.userStyles.items.currentPet).to.eql(userWithStyle.items.currentPet);\n    expect(message.message.userStyles.preferences.style).to.eql(userWithStyle.preferences.style);\n    expect(message.message.userStyles.preferences.hair).to.eql(userWithStyle.preferences.hair);\n    expect(message.message.userStyles.preferences.skin).to.eql(userWithStyle.preferences.skin);\n    expect(message.message.userStyles.preferences.shirt).to.eql(userWithStyle.preferences.shirt);\n    expect(message.message.userStyles.preferences.chair).to.eql(userWithStyle.preferences.chair);\n    expect(message.message.userStyles.preferences.background).to.eql(userWithStyle.preferences.background);\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"adds backer info to chat","suites":["POST /chat","banned slur"],"updatePoint":{"line":563,"column":30,"index":27292},"line":563,"code":"  it('adds backer info to chat', async () => {\n    const backerInfo = {\n      npc: 'Town Crier',\n      tier: 800,\n      tokensApplied: true\n    };\n    const backer = await generateUser({\n      backer: backerInfo\n    });\n    const message = await backer.post(`/groups/${groupWithChat._id}/chat`, {\n      message: testMessage\n    });\n    const messageBackerInfo = message.message.backer;\n    expect(messageBackerInfo.npc).to.equal(backerInfo.npc);\n    expect(messageBackerInfo.tier).to.equal(backerInfo.tier);\n    expect(messageBackerInfo.tokensApplied).to.equal(backerInfo.tokensApplied);\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"sends group chat received webhooks","suites":["POST /chat","banned slur"],"updatePoint":{"line":580,"column":40,"index":27896},"line":580,"code":"  it('sends group chat received webhooks', async () => {\n    const userUuid = generateUUID();\n    const memberUuid = generateUUID();\n    await server.start();\n    await user.post('/user/webhook', {\n      url: `http://localhost:${server.port}/webhooks/${userUuid}`,\n      type: 'groupChatReceived',\n      enabled: true,\n      options: {\n        groupId: groupWithChat.id\n      }\n    });\n    await member.post('/user/webhook', {\n      url: `http://localhost:${server.port}/webhooks/${memberUuid}`,\n      type: 'groupChatReceived',\n      enabled: true,\n      options: {\n        groupId: groupWithChat.id\n      }\n    });\n    const message = await user.post(`/groups/${groupWithChat._id}/chat`, {\n      message: testMessage\n    });\n    await sleep();\n    await server.close();\n    const userBody = server.getWebhookData(userUuid);\n    const memberBody = server.getWebhookData(memberUuid);\n    [userBody, memberBody].forEach(body => {\n      expect(body.group.id).to.eql(groupWithChat._id);\n      expect(body.group.name).to.eql(groupWithChat.name);\n      expect(body.chat).to.eql(message.message);\n    });\n  });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"notifies other users of new messages for a guild","suites":["POST /chat","chat notifications"],"updatePoint":{"line":620,"column":56,"index":29171},"line":620,"code":"    it('notifies other users of new messages for a guild', async () => {\n      const message = await user.post(`/groups/${groupWithChat._id}/chat`, {\n        message: testMessage\n      });\n      const memberWithNotification = await member.get('/user');\n      expect(message.message.id).to.exist;\n      expect(memberWithNotification.newMessages[`${groupWithChat._id}`]).to.exist;\n      expect(memberWithNotification.notifications.find(n => n.type === 'NEW_CHAT_MESSAGE' && n.data.group.id === groupWithChat._id)).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"notifies other users of new messages for a party","suites":["POST /chat","chat notifications"],"updatePoint":{"line":629,"column":56,"index":29701},"line":629,"code":"    it('notifies other users of new messages for a party', async () => {\n      const {\n        group,\n        groupLeader,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          name: 'Test Party',\n          type: 'party',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const message = await groupLeader.post(`/groups/${group._id}/chat`, {\n        message: testMessage\n      });\n      const memberWithNotification = await members[0].get('/user');\n      expect(message.message.id).to.exist;\n      expect(memberWithNotification.newMessages[`${group._id}`]).to.exist;\n      expect(memberWithNotification.notifications.find(n => n.type === 'NEW_CHAT_MESSAGE' && n.data.group.id === group._id)).to.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"does not notify other users of a new message that is already hidden from shadow-muting","suites":["POST /chat","chat notifications"],"updatePoint":{"line":650,"column":94,"index":30511},"line":650,"code":"    it('does not notify other users of a new message that is already hidden from shadow-muting', async () => {\n      await user.update({\n        'flags.chatShadowMuted': true\n      });\n      const message = await user.post(`/groups/${groupWithChat._id}/chat`, {\n        message: testMessage\n      });\n      const memberWithNotification = await member.get('/user');\n      await user.update({\n        'flags.chatShadowMuted': false\n      });\n      expect(message.message.id).to.exist;\n      expect(memberWithNotification.newMessages[`${groupWithChat._id}`]).to.not.exist;\n      expect(memberWithNotification.notifications.find(n => n.type === 'NEW_CHAT_MESSAGE' && n.data.group.id === groupWithChat._id)).to.not.exist;\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when the user has been posting too many messages","suites":["POST /chat","Spam prevention"],"updatePoint":{"line":667,"column":73,"index":31258},"line":667,"code":"    it('Returns an error when the user has been posting too many messages', async () => {\n      // Post as many messages are needed to reach the spam limit\n      for (let i = 0; i < SPAM_MESSAGE_LIMIT; i += 1) {\n        const result = await additionalMember.post(`/groups/${TAVERN_ID}/chat`, {\n          message: testMessage\n        }); // eslint-disable-line no-await-in-loop\n\n        expect(result.message.id).to.exist;\n      }\n\n      await expect(additionalMember.post(`/groups/${TAVERN_ID}/chat`, {\n        message: testMessage\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageGroupChatSpam')\n      });\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"contributor should not receive spam alert","suites":["POST /chat","Spam prevention"],"updatePoint":{"line":685,"column":49,"index":31924},"line":685,"code":"    it('contributor should not receive spam alert', async () => {\n      const userSocialite = await member.update({\n        'contributor.level': SPAM_MIN_EXEMPT_CONTRIB_LEVEL\n      }); // Post 1 more message than the spam limit to ensure they do not reach the limit\n\n      for (let i = 0; i < SPAM_MESSAGE_LIMIT + 1; i += 1) {\n        const result = await userSocialite.post(`/groups/${TAVERN_ID}/chat`, {\n          message: testMessage\n        }); // eslint-disable-line no-await-in-loop\n\n        expect(result.message.id).to.exist;\n      }\n    });","file":"api/v3/integration/chat/POST-chat.test.js","skipped":false,"dir":"test"},{"name":"returns error when non-admin attempts to clear flags","suites":["POST /groups/:id/chat/:id/clearflags","Single Message"],"updatePoint":{"line":37,"column":60,"index":1175},"line":37,"code":"    it('returns error when non-admin attempts to clear flags', async () => expect(nonAdmin.post(`/groups/${groupWithChat._id}/chat/${message.id}/clearflags`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageGroupChatAdminClearFlagCount')\n    }));","file":"api/v3/integration/chat/POST-groups_id_chat_id_clear_flags.test.js","skipped":false,"dir":"test"},{"name":"returns error if message does not exist","suites":["POST /groups/:id/chat/:id/clearflags","Single Message"],"updatePoint":{"line":42,"column":47,"index":1469},"line":42,"code":"    it('returns error if message does not exist', async () => {\n      const fakeMessageID = generateUUID();\n      await expect(admin.post(`/groups/${groupWithChat._id}/chat/${fakeMessageID}/clearflags`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageGroupChatNotFound')\n      });\n    });","file":"api/v3/integration/chat/POST-groups_id_chat_id_clear_flags.test.js","skipped":false,"dir":"test"},{"name":"clears flags and leaves old flags on the flag object","suites":["POST /groups/:id/chat/:id/clearflags","Single Message"],"updatePoint":{"line":50,"column":60,"index":1833},"line":50,"code":"    it('clears flags and leaves old flags on the flag object', async () => {\n      await admin.post(`/groups/${groupWithChat._id}/chat/${message.id}/clearflags`);\n      const messages = await admin.get(`/groups/${groupWithChat._id}/chat`);\n      expect(messages[0].flagCount).to.eql(0);\n      expect(messages[0].flags).to.have.property(admin._id, true);\n    });","file":"api/v3/integration/chat/POST-groups_id_chat_id_clear_flags.test.js","skipped":false,"dir":"test"},{"name":"clears flags in a private group","suites":["POST /groups/:id/chat/:id/clearflags","Single Message"],"updatePoint":{"line":56,"column":39,"index":2174},"line":56,"code":"    it('clears flags in a private group', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      let privateMessage = await members[0].post(`/groups/${group._id}/chat`, {\n        message: 'Some message'\n      });\n      privateMessage = privateMessage.message;\n      await admin.post(`/groups/${group._id}/chat/${privateMessage.id}/flag`); // first test that the flag was actually successful\n\n      let messages = await members[0].get(`/groups/${group._id}/chat`);\n      expect(messages[0].flagCount).to.eql(5);\n      await admin.post(`/groups/${group._id}/chat/${privateMessage.id}/clearflags`);\n      messages = await members[0].get(`/groups/${group._id}/chat`);\n      expect(messages[0].flagCount).to.eql(0);\n    });","file":"api/v3/integration/chat/POST-groups_id_chat_id_clear_flags.test.js","skipped":false,"dir":"test"},{"name":"can't flag a system message","suites":["POST /groups/:id/chat/:id/clearflags","Single Message"],"updatePoint":{"line":79,"column":36,"index":3059},"line":79,"code":"    it('can\\'t flag a system message', async () => {\n      const {\n        group,\n        members\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const member = members[0]; // make member that can use skills\n\n      await member.update({\n        'stats.lvl': 100,\n        'stats.mp': 400,\n        'stats.class': 'wizard'\n      });\n      await member.post('/user/class/cast/mpheal');\n      const [skillMsg] = await member.get(`/groups/${group.id}/chat`);\n      await expect(member.post(`/groups/${group._id}/chat/${skillMsg.id}/flag`)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('messageCannotFlagSystemMessages', {\n          communityManagerEmail: config.EMAILS_COMMUNITY_MANAGER_EMAIL\n        })\n      }); // let messages = await members[0].get(`/groups/${group._id}/chat`);\n      // expect(messages[0].id).to.eql(skillMsg.id);\n      // expect(messages[0].flagCount).to.eql(0);\n    });","file":"api/v3/integration/chat/POST-groups_id_chat_id_clear_flags.test.js","skipped":false,"dir":"test"},{"name":"changes only the message that is flagged","suites":["POST /groups/:id/chat/:id/clearflags","admin user, group with multiple messages"],"updatePoint":{"line":131,"column":48,"index":4994},"line":131,"code":"    it('changes only the message that is flagged', async () => {\n      await admin.post(`/groups/${groupWithChat._id}/chat/${message.id}/clearflags`);\n      const messages = await admin.get(`/groups/${groupWithChat._id}/chat`);\n      expect(messages).to.have.lengthOf(4);\n      const messageThatWasUnflagged = messages[3];\n      const messageWith1Flag = messages[2];\n      const messageWith2Flag = messages[1];\n      const messageWithoutFlags = messages[0];\n      expect(messageThatWasUnflagged.flagCount).to.eql(0);\n      expect(messageThatWasUnflagged.flags).to.have.property(admin._id, true);\n      expect(messageWith1Flag.flagCount).to.eql(5);\n      expect(messageWith1Flag.flags).to.have.property(admin._id, true);\n      expect(messageWith2Flag.flagCount).to.eql(6);\n      expect(messageWith2Flag.flags).to.have.property(admin._id, true);\n      expect(messageWith2Flag.flags).to.have.property(nonAdmin._id, true);\n      expect(messageWithoutFlags.flagCount).to.eql(0);\n      expect(messageWithoutFlags.flags).to.eql({});\n    });","file":"api/v3/integration/chat/POST-groups_id_chat_id_clear_flags.test.js","skipped":false,"dir":"test"},{"name":"returns content (and does not require authentication)","suites":["GET /content"],"updatePoint":{"line":4,"column":59,"index":239},"line":4,"code":"  it('returns content (and does not require authentication)', async () => {\n    const res = await requester().get('/content');\n    expect(res).to.have.nested.property('backgrounds.backgrounds062014.beach');\n    expect(res.backgrounds.backgrounds062014.beach.text).to.equal(t('backgroundBeachText'));\n  });","file":"api/v3/integration/content/GET-content.test.js","skipped":false,"dir":"test"},{"name":"returns content not in English","suites":["GET /content"],"updatePoint":{"line":9,"column":36,"index":522},"line":9,"code":"  it('returns content not in English', async () => {\n    const res = await requester().get('/content?language=de');\n    expect(res).to.have.nested.property('backgrounds.backgrounds062014.beach');\n    expect(res.backgrounds.backgrounds062014.beach.text).to.equal(i18n.t('backgroundBeachText', 'de'));\n  });","file":"api/v3/integration/content/GET-content.test.js","skipped":false,"dir":"test"},{"name":"falls back to English if the desired language is not found","suites":["GET /content"],"updatePoint":{"line":14,"column":64,"index":856},"line":14,"code":"  it('falls back to English if the desired language is not found', async () => {\n    const res = await requester().get('/content?language=wrong');\n    expect(res).to.have.nested.property('backgrounds.backgrounds062014.beach');\n    expect(res.backgrounds.backgrounds062014.beach.text).to.equal(t('backgroundBeachText'));\n  });","file":"api/v3/integration/content/GET-content.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user has no sudo permission","suites":["GET /coupons/"],"updatePoint":{"line":11,"column":53,"index":380},"line":11,"code":"  it('returns an error if user has no sudo permission', async () => {\n    await user.get('/user'); // needed so the request after this will authenticate with the correct cookie session\n\n    await expect(user.get('/coupons')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: apiError('noSudoAccess')\n    });\n  });","file":"api/v3/integration/coupons/GET-coupons.test.js","skipped":false,"dir":"test"},{"name":"should return the coupons in CSV format ordered by creation date","suites":["GET /coupons/"],"updatePoint":{"line":20,"column":70,"index":759},"line":20,"code":"  it('should return the coupons in CSV format ordered by creation date', async () => {\n    await user.update({\n      'contributor.sudo': true\n    });\n    const coupons = await user.post('/coupons/generate/wondercon?count=11');\n    const res = await user.get('/coupons');\n    const splitRes = res.split('\\n');\n    expect(splitRes.length).to.equal(13);\n    expect(splitRes[0]).to.equal('code,event,date,user');\n    expect(splitRes[6].split(',')[1]).to.equal(coupons[5].event);\n  });","file":"api/v3/integration/coupons/GET-coupons.test.js","skipped":false,"dir":"test"},{"name":"returns an error if code is missing","suites":["POST /coupons/enter/:code"],"updatePoint":{"line":14,"column":41,"index":419},"line":14,"code":"  it('returns an error if code is missing', async () => {\n    await expect(user.post('/coupons/enter')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_enter_code.test.js","skipped":false,"dir":"test"},{"name":"returns an error if code is invalid","suites":["POST /coupons/enter/:code"],"updatePoint":{"line":21,"column":41,"index":643},"line":21,"code":"  it('returns an error if code is invalid', async () => {\n    await expect(user.post('/coupons/enter/notValid')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidCoupon')\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_enter_code.test.js","skipped":false,"dir":"test"},{"name":"returns an error if coupon has been used","suites":["POST /coupons/enter/:code"],"updatePoint":{"line":28,"column":46,"index":889},"line":28,"code":"  it('returns an error if coupon has been used', async () => {\n    const [coupon] = await sudoUser.post('/coupons/generate/wondercon?count=1');\n    await user.post(`/coupons/enter/${coupon._id}`); // use coupon\n\n    await expect(user.post(`/coupons/enter/${coupon._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('couponUsed')\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_enter_code.test.js","skipped":false,"dir":"test"},{"name":"should apply the coupon to the user","suites":["POST /coupons/enter/:code"],"updatePoint":{"line":38,"column":41,"index":1284},"line":38,"code":"  it('should apply the coupon to the user', async () => {\n    const [coupon] = await sudoUser.post('/coupons/generate/wondercon?count=1');\n    const userRes = await user.post(`/coupons/enter/${coupon._id}`);\n    expect(userRes._id).to.equal(user._id);\n    expect(userRes.items.gear.owned.eyewear_special_wondercon_red).to.be.true;\n    expect(userRes.items.gear.owned.eyewear_special_wondercon_black).to.be.true;\n    expect(userRes.items.gear.owned.back_special_wondercon_black).to.be.true;\n    expect(userRes.items.gear.owned.back_special_wondercon_red).to.be.true;\n    expect(userRes.items.gear.owned.body_special_wondercon_red).to.be.true;\n    expect(userRes.items.gear.owned.body_special_wondercon_black).to.be.true;\n    expect(userRes.items.gear.owned.body_special_wondercon_gold).to.be.true;\n    expect(userRes.extra).to.eql({\n      signupEvent: 'wondercon'\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_enter_code.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user has no sudo permission","suites":["POST /coupons/generate/:event"],"updatePoint":{"line":14,"column":53,"index":488},"line":14,"code":"  it('returns an error if user has no sudo permission', async () => {\n    await user.update({\n      'contributor.sudo': false\n    });\n    await expect(user.post('/coupons/generate/aaa')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: apiError('noSudoAccess')\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_generate_event.test.js","skipped":false,"dir":"test"},{"name":"returns an error if event is invalid","suites":["POST /coupons/generate/:event"],"updatePoint":{"line":24,"column":42,"index":801},"line":24,"code":"  it('returns an error if event is invalid', async () => {\n    await expect(user.post('/coupons/generate/notValid?count=1')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Coupon validation failed'\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_generate_event.test.js","skipped":false,"dir":"test"},{"name":"returns an error if count is missing","suites":["POST /coupons/generate/:event"],"updatePoint":{"line":31,"column":42,"index":1062},"line":31,"code":"  it('returns an error if count is missing', async () => {\n    await expect(user.post('/coupons/generate/notValid')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_generate_event.test.js","skipped":false,"dir":"test"},{"name":"should generate coupons","suites":["POST /coupons/generate/:event"],"updatePoint":{"line":38,"column":29,"index":1297},"line":38,"code":"  it('should generate coupons', async () => {\n    await user.update({\n      'contributor.sudo': true\n    });\n    const coupons = await user.post('/coupons/generate/wondercon?count=2');\n    expect(coupons.length).to.equal(2);\n    expect(coupons[0].event).to.equal('wondercon');\n    expect(couponCode.validate(coupons[1]._id)).to.not.equal(''); // '' means invalid\n  });","file":"api/v3/integration/coupons/POST-coupons_generate_event.test.js","skipped":false,"dir":"test"},{"name":"returns an error if code is missing","suites":["POST /coupons/validate/:code"],"updatePoint":{"line":7,"column":41,"index":275},"line":7,"code":"  it('returns an error if code is missing', async () => {\n    await expect(api.post('/coupons/validate')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_validate_code.test.js","skipped":false,"dir":"test"},{"name":"returns true if coupon code is valid","suites":["POST /coupons/validate/:code"],"updatePoint":{"line":14,"column":42,"index":502},"line":14,"code":"  it('returns true if coupon code is valid', async () => {\n    const sudoUser = await generateUser({\n      'contributor.sudo': true\n    });\n    const [coupon] = await sudoUser.post('/coupons/generate/wondercon?count=1');\n    const res = await api.post(`/coupons/validate/${coupon._id}`);\n    expect(res).to.eql({\n      valid: true\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_validate_code.test.js","skipped":false,"dir":"test"},{"name":"returns false if coupon code is valid","suites":["POST /coupons/validate/:code"],"updatePoint":{"line":24,"column":43,"index":848},"line":24,"code":"  it('returns false if coupon code is valid', async () => {\n    const res = await api.post('/coupons/validate/notValid');\n    expect(res).to.eql({\n      valid: false\n    });\n  });","file":"api/v3/integration/coupons/POST-coupons_validate_code.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.memberId","suites":[],"updatePoint":{"line":8,"column":35,"index":295},"line":8,"code":"  it('validates req.params.memberId', async () => {\n    await expect(user.get('/export/avatar-:memberId.html')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/dataexport/GET-export_avatar-memberId.html.test.js","skipped":false,"dir":"test"},{"name":"handles non-existing members","suites":[],"updatePoint":{"line":15,"column":34,"index":537},"line":15,"code":"  it('handles non-existing members', async () => {\n    const dummyId = generateUUID();\n    await expect(user.get(`/export/avatar-${dummyId}.html`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: dummyId\n      })\n    });\n  });","file":"api/v3/integration/dataexport/GET-export_avatar-memberId.html.test.js","skipped":false,"dir":"test"},{"name":"returns an html page","suites":[],"updatePoint":{"line":25,"column":26,"index":843},"line":25,"code":"  it('returns an html page', async () => {\n    const res = await user.get(`/export/avatar-${user._id}.html`);\n    expect(res.substring(0, 100).indexOf('<!DOCTYPE html>')).to.equal(0);\n  });","file":"api/v3/integration/dataexport/GET-export_avatar-memberId.html.test.js","skipped":false,"dir":"test"},{"name":"should return a valid CSV file with tasks history data","suites":["GET /export/history.csv"],"updatePoint":{"line":6,"column":61,"index":330},"line":6,"code":"  xit('should return a valid CSV file with tasks history data', async () => {\n    const user = await generateUser();\n    let tasks = await user.post('/tasks/user', [{\n      type: 'daily',\n      text: 'daily 1'\n    }, {\n      type: 'habit',\n      text: 'habit 1'\n    }, {\n      type: 'habit',\n      text: 'habit 2'\n    }, {\n      type: 'todo',\n      text: 'todo 1'\n    }]); // to handle occasional inconsistency in task creation order\n\n    tasks.sort((a, b) => a.text.localeCompare(b.text)); // score all the tasks twice\n\n    await user.post(`/tasks/${tasks[0]._id}/score/up`);\n    await user.post(`/tasks/${tasks[1]._id}/score/up`);\n    await user.post(`/tasks/${tasks[2]._id}/score/up`);\n    await user.post(`/tasks/${tasks[3]._id}/score/up`);\n    await user.post(`/tasks/${tasks[0]._id}/score/up`);\n    await user.post(`/tasks/${tasks[1]._id}/score/up`);\n    await user.post(`/tasks/${tasks[2]._id}/score/up`);\n    await user.post(`/tasks/${tasks[3]._id}/score/up`); // adding an history entry to daily 1 manually because cron didn't run yet\n\n    await updateDocument('tasks', tasks[0], {\n      history: [{\n        value: 3.2,\n        date: Number(new Date())\n      }]\n    }); // get updated tasks\n\n    tasks = await Promise.all(tasks.map(task => user.get(`/tasks/${task._id}`)));\n    const res = await user.get('/export/history.csv');\n    const splitRes = res.split('\\n');\n    expect(splitRes[0]).to.equal('Task Name,Task ID,Task Type,Date,Value');\n    expect(splitRes[1]).to.equal(`daily 1,${tasks[0]._id},daily,${moment(tasks[0].history[0].date).format('YYYY-MM-DD HH:mm:ss')},${tasks[0].history[0].value}`);\n    expect(splitRes[2]).to.equal(`habit 1,${tasks[1]._id},habit,${moment(tasks[1].history[0].date).format('YYYY-MM-DD HH:mm:ss')},${tasks[1].history[0].value}`);\n    expect(splitRes[3]).to.equal(`habit 1,${tasks[1]._id},habit,${moment(tasks[1].history[1].date).format('YYYY-MM-DD HH:mm:ss')},${tasks[1].history[1].value}`);\n    expect(splitRes[4]).to.equal(`habit 2,${tasks[2]._id},habit,${moment(tasks[2].history[0].date).format('YYYY-MM-DD HH:mm:ss')},${tasks[2].history[0].value}`);\n    expect(splitRes[5]).to.equal(`habit 2,${tasks[2]._id},habit,${moment(tasks[2].history[1].date).format('YYYY-MM-DD HH:mm:ss')},${tasks[2].history[1].value}`);\n    expect(splitRes[6]).to.equal('');\n  });","skipped":true,"file":"api/v3/integration/dataexport/GET-export_history.csv.test.js","dir":"test"},{"name":"returns an html page","suites":["GET /export/inbox.html"],"updatePoint":{"line":25,"column":26,"index":789},"line":25,"code":"  it('returns an html page', async () => {\n    const res = await user.get('/export/inbox.html');\n    expect(res.substring(0, 100).indexOf('<!DOCTYPE html>')).to.equal(0);\n  });","file":"api/v3/integration/dataexport/GET-export_inbox.html.test.js","skipped":false,"dir":"test"},{"name":"renders the markdown messages as html","suites":["GET /export/inbox.html"],"updatePoint":{"line":29,"column":43,"index":983},"line":29,"code":"  it('renders the markdown messages as html', async () => {\n    const res = await user.get('/export/inbox.html');\n    expect(res).to.include('img class=\"habitica-emoji\"');\n    expect(res).to.include('<h1>Hello!</h1>');\n    expect(res).to.include('<li>list 1</li>');\n  });","file":"api/v3/integration/dataexport/GET-export_inbox.html.test.js","skipped":false,"dir":"test"},{"name":"sorts messages from newest to oldest","suites":["GET /export/inbox.html"],"updatePoint":{"line":35,"column":42,"index":1254},"line":35,"code":"  it('sorts messages from newest to oldest', async () => {\n    const res = await user.get('/export/inbox.html');\n    const emojiPosition = res.indexOf('img class=\"habitica-emoji\"');\n    const headingPosition = res.indexOf('<h1>Hello!</h1>');\n    const listPosition = res.indexOf('<li>list 1</li>');\n    expect(emojiPosition).to.be.greaterThan(headingPosition);\n    expect(headingPosition).to.be.greaterThan(listPosition);\n    expect(listPosition).to.be.greaterThan(-1); // make sure it exists at all\n  });","file":"api/v3/integration/dataexport/GET-export_inbox.html.test.js","skipped":false,"dir":"test"},{"name":"should return a valid JSON file with user data","suites":["GET /export/userdata.json"],"updatePoint":{"line":3,"column":52,"index":170},"line":3,"code":"  it('should return a valid JSON file with user data', async () => {\n    const user = await generateUser();\n    const tasks = await user.post('/tasks/user', [{\n      type: 'habit',\n      text: 'habit 1'\n    }, {\n      type: 'daily',\n      text: 'daily 1'\n    }, {\n      type: 'reward',\n      text: 'reward 1'\n    }, {\n      type: 'todo',\n      text: 'todo 1'\n    }]);\n    const res = await user.get('/export/userdata.json');\n    expect(res._id).to.equal(user._id);\n    expect(res).to.contain.all.keys(['tasks', 'flags', 'tasksOrder', 'auth']);\n    expect(res.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(res.tasks).to.have.all.keys(['dailys', 'habits', 'todos', 'rewards']);\n    expect(res.tasks.habits.length).to.equal(1);\n    expect(res.tasks.habits[0]._id).to.equal(tasks[0]._id);\n    expect(res.tasks.dailys.length).to.equal(1);\n    expect(res.tasks.dailys[0]._id).to.equal(tasks[1]._id);\n    expect(res.tasks.rewards.length).to.equal(1);\n    expect(res.tasks.rewards[0]._id).to.equal(tasks[2]._id);\n    expect(res.tasks.todos.length).to.equal(2);\n    expect(res.tasks.todos[1]._id).to.equal(tasks[3]._id);\n  });","file":"api/v3/integration/dataexport/GET-export_userdata.json.test.js","skipped":false,"dir":"test"},{"name":"should return a valid XML file with user data","suites":["GET /export/userdata.xml"],"updatePoint":{"line":6,"column":51,"index":296},"line":6,"code":"  it('should return a valid XML file with user data', async () => {\n    const user = await generateUser();\n    const tasks = await user.post('/tasks/user', [{\n      type: 'habit',\n      text: 'habit 1'\n    }, {\n      type: 'daily',\n      text: 'daily 1'\n    }, {\n      type: 'reward',\n      text: 'reward 1'\n    }, {\n      type: 'todo',\n      text: 'todo 1'\n    }, // due to how the xml parser works an array is returned only if there's more than one children\n    // so we create two tasks for each type\n    {\n      type: 'habit',\n      text: 'habit 2'\n    }, {\n      type: 'daily',\n      text: 'daily 2'\n    }, {\n      type: 'reward',\n      text: 'reward 2'\n    }, {\n      type: 'todo',\n      text: 'todo 2'\n    }]); // add pinnedItem\n\n    await user.get('/user/toggle-pinned-item/marketGear/gear.flat.shield_rogue_5'); // add a private message\n\n    const receiver = await generateUser();\n    user.post('/members/send-private-message', {\n      message: 'Your first message, hi!',\n      toUserId: receiver._id\n    });\n    const response = await user.get('/export/userdata.xml');\n    const {\n      user: res\n    } = await parseStringAsync(response, {\n      explicitArray: false\n    });\n    expect(res._id).to.equal(user._id);\n    expect(res).to.contain.all.keys(['tasks', 'flags', 'tasksOrder', 'auth']);\n    expect(res.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(res.tasks).to.have.all.keys(['dailys', 'habits', 'todos', 'rewards']);\n    expect(res.tasks.habits.length).to.equal(2);\n\n    const habitIds = _.map(res.tasks.habits, '_id');\n\n    expect(habitIds).to.have.deep.members([tasks[0]._id, tasks[4]._id]);\n    expect(res.tasks.dailys.length).to.equal(2);\n\n    const dailyIds = _.map(res.tasks.dailys, '_id');\n\n    expect(dailyIds).to.have.deep.members([tasks[1]._id, tasks[5]._id]);\n    expect(res.tasks.rewards.length).to.equal(2);\n\n    const rewardIds = _.map(res.tasks.rewards, '_id');\n\n    expect(rewardIds).to.have.deep.members([tasks[2]._id, tasks[6]._id]);\n    expect(res.tasks.todos.length).to.equal(3);\n\n    const todoIds = _.map(res.tasks.todos, '_id');\n\n    expect(todoIds).to.deep.include.members([tasks[3]._id, tasks[7]._id]);\n  });","file":"api/v3/integration/dataexport/GET-export_userdata.xml.test.js","skipped":false,"dir":"test"},{"name":"adds Hourglass to the current user","suites":["POST /debug/add-hourglass"],"updatePoint":{"line":11,"column":40,"index":342},"line":11,"code":"  it('adds Hourglass to the current user', async () => {\n    await userToGetHourGlass.post('/debug/add-hourglass');\n    const userWithHourGlass = await userToGetHourGlass.get('/user');\n    expect(userWithHourGlass.purchased.plan.consecutive.trinkets).to.equal(1);\n  });","file":"api/v3/integration/debug/POST-debug_addHourglass.test.js","skipped":false,"dir":"test"},{"name":"returns error when not in production mode","suites":["POST /debug/add-hourglass"],"updatePoint":{"line":16,"column":47,"index":619},"line":16,"code":"  it('returns error when not in production mode', async () => {\n    nconf.set('IS_PROD', true);\n    await expect(userToGetHourGlass.post('/debug/add-hourglass')).eventually.be.rejected.and.to.deep.equal({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/debug/POST-debug_addHourglass.test.js","skipped":false,"dir":"test"},{"name":"adds ten gems to the current user","suites":["POST /debug/add-ten-gems"],"updatePoint":{"line":11,"column":39,"index":338},"line":11,"code":"  it('adds ten gems to the current user', async () => {\n    await userToGainTenGems.post('/debug/add-ten-gems');\n    const userWithTenGems = await userToGainTenGems.get('/user');\n    expect(userWithTenGems.balance).to.equal(2.5);\n  });","file":"api/v3/integration/debug/POST-debug_addTenGems.test.js","skipped":false,"dir":"test"},{"name":"returns error when not in production mode","suites":["POST /debug/add-ten-gems"],"updatePoint":{"line":16,"column":47,"index":582},"line":16,"code":"  it('returns error when not in production mode', async () => {\n    nconf.set('IS_PROD', true);\n    await expect(userToGainTenGems.post('/debug/add-ten-gems')).eventually.be.rejected.and.to.deep.equal({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/debug/POST-debug_addTenGems.test.js","skipped":false,"dir":"test"},{"name":"makes user an admine","suites":["POST /debug/make-admin (pended for v3 prod testing)"],"updatePoint":{"line":11,"column":26,"index":330},"line":11,"code":"  it('makes user an admine', async () => {\n    await user.post('/debug/make-admin');\n    await user.sync();\n    expect(user.contributor.admin).to.eql(true);\n  });","file":"api/v3/integration/debug/POST-debug_make-admin.test.js","skipped":false,"dir":"test"},{"name":"returns error when not in production mode","suites":["POST /debug/make-admin (pended for v3 prod testing)"],"updatePoint":{"line":16,"column":47,"index":514},"line":16,"code":"  it('returns error when not in production mode', async () => {\n    nconf.set('IS_PROD', true);\n    await expect(user.post('/debug/make-admin')).eventually.be.rejected.and.to.deep.equal({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/debug/POST-debug_make-admin.test.js","skipped":false,"dir":"test"},{"name":"sets equipment","suites":["POST /debug/modify-inventory"],"updatePoint":{"line":43,"column":20,"index":821},"line":43,"code":"  it('sets equipment', async () => {\n    const gear = {\n      weapon_healer_2: true,\n      weapon_wizard_1: true,\n      weapon_special_critical: true\n    };\n    await user.post('/debug/modify-inventory', {\n      gear\n    });\n    await user.sync();\n    expect(user.items.gear.owned).to.eql(gear);\n  });","file":"api/v3/integration/debug/POST-debug_modify-inventory.test.js","skipped":false,"dir":"test"},{"name":"sets special spells","suites":["POST /debug/modify-inventory"],"updatePoint":{"line":55,"column":25,"index":1128},"line":55,"code":"  it('sets special spells', async () => {\n    const special = {\n      shinySeed: 3\n    };\n    await user.post('/debug/modify-inventory', {\n      special\n    });\n    await user.sync();\n    expect(user.items.special).to.eql(special);\n  });","file":"api/v3/integration/debug/POST-debug_modify-inventory.test.js","skipped":false,"dir":"test"},{"name":"sets mounts","suites":["POST /debug/modify-inventory"],"updatePoint":{"line":65,"column":17,"index":1358},"line":65,"code":"  it('sets mounts', async () => {\n    const mounts = {\n      'Orca-Base': true,\n      'Mammoth-Base': true\n    };\n    await user.post('/debug/modify-inventory', {\n      mounts\n    });\n    await user.sync();\n    expect(user.items.mounts).to.eql(mounts);\n  });","file":"api/v3/integration/debug/POST-debug_modify-inventory.test.js","skipped":false,"dir":"test"},{"name":"sets eggs","suites":["POST /debug/modify-inventory"],"updatePoint":{"line":76,"column":15,"index":1615},"line":76,"code":"  it('sets eggs', async () => {\n    const eggs = {\n      Gryphon: 3,\n      Hedgehog: 7\n    };\n    await user.post('/debug/modify-inventory', {\n      eggs\n    });\n    await user.sync();\n    expect(user.items.eggs).to.eql(eggs);\n  });","file":"api/v3/integration/debug/POST-debug_modify-inventory.test.js","skipped":false,"dir":"test"},{"name":"sets hatching potions","suites":["POST /debug/modify-inventory"],"updatePoint":{"line":87,"column":27,"index":1860},"line":87,"code":"  it('sets hatching potions', async () => {\n    const hatchingPotions = {\n      White: 7,\n      Spooky: 2\n    };\n    await user.post('/debug/modify-inventory', {\n      hatchingPotions\n    });\n    await user.sync();\n    expect(user.items.hatchingPotions).to.eql(hatchingPotions);\n  });","file":"api/v3/integration/debug/POST-debug_modify-inventory.test.js","skipped":false,"dir":"test"},{"name":"sets food","suites":["POST /debug/modify-inventory"],"updatePoint":{"line":98,"column":15,"index":2133},"line":98,"code":"  it('sets food', async () => {\n    const food = {\n      Meat: 5,\n      Candy_Red: 7\n    };\n    await user.post('/debug/modify-inventory', {\n      food\n    });\n    await user.sync();\n    expect(user.items.food).to.eql(food);\n  });","file":"api/v3/integration/debug/POST-debug_modify-inventory.test.js","skipped":false,"dir":"test"},{"name":"sets quests","suites":["POST /debug/modify-inventory"],"updatePoint":{"line":109,"column":17,"index":2366},"line":109,"code":"  it('sets quests', async () => {\n    const quests = {\n      whale: 5,\n      cheetah: 10\n    };\n    await user.post('/debug/modify-inventory', {\n      quests\n    });\n    await user.sync();\n    expect(user.items.quests).to.eql(quests);\n  });","file":"api/v3/integration/debug/POST-debug_modify-inventory.test.js","skipped":false,"dir":"test"},{"name":"returns error when not in production mode","suites":["POST /debug/modify-inventory"],"updatePoint":{"line":120,"column":47,"index":2637},"line":120,"code":"  it('returns error when not in production mode', async () => {\n    nconf.set('IS_PROD', true);\n    await expect(user.post('/debug/modify-inventory')).eventually.be.rejected.and.to.deep.equal({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/debug/POST-debug_modify-inventory.test.js","skipped":false,"dir":"test"},{"name":"errors if user is not on a quest","suites":["POST /debug/quest-progress"],"updatePoint":{"line":11,"column":38,"index":321},"line":11,"code":"  it('errors if user is not on a quest', async () => {\n    await expect(user.post('/debug/quest-progress')).to.eventually.be.rejected.and.to.deep.equal({\n      code: 400,\n      error: 'BadRequest',\n      message: 'User is not on a valid quest.'\n    });\n  });","file":"api/v3/integration/debug/POST-debug_quest-progress.test.js","skipped":false,"dir":"test"},{"name":"increases boss quest progress by 1000","suites":["POST /debug/quest-progress"],"updatePoint":{"line":18,"column":43,"index":585},"line":18,"code":"  it('increases boss quest progress by 1000', async () => {\n    await user.update({\n      'party.quest.key': 'whale'\n    });\n    await user.post('/debug/quest-progress');\n    await user.sync();\n    expect(user.party.quest.progress.up).to.eql(1000);\n  });","file":"api/v3/integration/debug/POST-debug_quest-progress.test.js","skipped":false,"dir":"test"},{"name":"increases collection quest progress by 300 items","suites":["POST /debug/quest-progress"],"updatePoint":{"line":26,"column":54,"index":851},"line":26,"code":"  it('increases collection quest progress by 300 items', async () => {\n    await user.update({\n      'party.quest.key': 'evilsanta2'\n    });\n    await user.post('/debug/quest-progress');\n    await user.sync();\n    expect(user.party.quest.progress.collectedItems).to.eql(300);\n  });","file":"api/v3/integration/debug/POST-debug_quest-progress.test.js","skipped":false,"dir":"test"},{"name":"returns error when not in production mode","suites":["POST /debug/quest-progress"],"updatePoint":{"line":34,"column":47,"index":1126},"line":34,"code":"  it('returns error when not in production mode', async () => {\n    nconf.set('IS_PROD', true);\n    await expect(user.post('/debug/quest-progress')).eventually.be.rejected.and.to.deep.equal({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/debug/POST-debug_quest-progress.test.js","skipped":false,"dir":"test"},{"name":"sets last cron","suites":["POST /debug/set-cron"],"updatePoint":{"line":11,"column":20,"index":293},"line":11,"code":"  it('sets last cron', async () => {\n    const newCron = new Date(2015, 11, 20);\n    await user.post('/debug/set-cron', {\n      lastCron: newCron\n    });\n    await user.sync();\n    expect(user.lastCron).to.eql(newCron);\n  });","file":"api/v3/integration/debug/POST-debug_set-cron.test.js","skipped":false,"dir":"test"},{"name":"returns error when not in production mode","suites":["POST /debug/set-cron"],"updatePoint":{"line":19,"column":47,"index":546},"line":19,"code":"  it('returns error when not in production mode', async () => {\n    nconf.set('IS_PROD', true);\n    await expect(user.post('/debug/set-cron')).eventually.be.rejected.and.to.deep.equal({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/debug/POST-debug_set-cron.test.js","skipped":false,"dir":"test"},{"name":"return error when code is not provided","suites":["GET /email/unsubscribe"],"updatePoint":{"line":10,"column":44,"index":410},"line":10,"code":"  it('return error when code is not provided', async () => {\n    await expect(user.get('/email/unsubscribe')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/emails/GET-email-unsubscribe.test.js","skipped":false,"dir":"test"},{"name":"return error when user is not found","suites":["GET /email/unsubscribe"],"updatePoint":{"line":17,"column":41,"index":656},"line":17,"code":"  it('return error when user is not found', async () => {\n    const code = encrypt(JSON.stringify({\n      _id: generateUUID()\n    }));\n    await expect(user.get(`/email/unsubscribe?code=${code}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userNotFound')\n    });\n  });","file":"api/v3/integration/emails/GET-email-unsubscribe.test.js","skipped":false,"dir":"test"},{"name":"unsubscribes a user from email notifications","suites":["GET /email/unsubscribe"],"updatePoint":{"line":27,"column":50,"index":987},"line":27,"code":"  it('unsubscribes a user from email notifications', async () => {\n    const code = encrypt(JSON.stringify({\n      _id: user._id,\n      email: user.email\n    }));\n    await user.get(`/email/unsubscribe?code=${code}`);\n    const unsubscribedUser = await user.get('/user');\n    expect(unsubscribedUser.preferences.emailNotifications.unsubscribeFromAll).to.be.true;\n  });","file":"api/v3/integration/emails/GET-email-unsubscribe.test.js","skipped":false,"dir":"test"},{"name":"unsubscribes an email from notifications","suites":["GET /email/unsubscribe"],"updatePoint":{"line":36,"column":46,"index":1352},"line":36,"code":"  it('unsubscribes an email from notifications', async () => {\n    const code = encrypt(JSON.stringify({\n      email: testEmail\n    }));\n    const unsubscribedMessage = await user.get(`/email/unsubscribe?code=${code}`);\n    expect(unsubscribedMessage).to.equal('<h1>Unsubscribed successfully!</h1> You won\\'t receive any other email from Habitica.');\n  });","file":"api/v3/integration/emails/GET-email-unsubscribe.test.js","skipped":false,"dir":"test"},{"name":"returns okay when email is already unsubscribed","suites":["GET /email/unsubscribe"],"updatePoint":{"line":43,"column":53,"index":1716},"line":43,"code":"  it('returns okay when email is already unsubscribed', async () => {\n    const code = encrypt(JSON.stringify({\n      email: testEmail\n    }));\n    const unsubscribedMessage = await user.get(`/email/unsubscribe?code=${code}`);\n    expect(unsubscribedMessage).to.equal('<h1>Unsubscribed successfully!</h1> You won\\'t receive any other email from Habitica.');\n  });","file":"api/v3/integration/emails/GET-email-unsubscribe.test.js","skipped":false,"dir":"test"},{"name":"returns group plans for the user","suites":["GET /group-plans"],"updatePoint":{"line":21,"column":38,"index":510},"line":21,"code":"  it('returns group plans for the user', async () => {\n    const groupPlans = await user.get('/group-plans');\n    expect(groupPlans[0]._id).to.eql(groupPlan._id);\n  });","file":"api/v3/integration/groups/GET-group-plans.test.js","skipped":false,"dir":"test"},{"name":"validates optional req.query.lastId to be an UUID","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":8,"column":55,"index":328},"line":8,"code":"  it('validates optional req.query.lastId to be an UUID', async () => {\n    await expect(user.get('/groups/groupId/invites?lastId=invalidUUID')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"fails if group doesn't exists","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":15,"column":36,"index":585},"line":15,"code":"  it('fails if group doesn\\'t exists', async () => {\n    await expect(user.get(`/groups/${generateUUID()}/invites`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"fails if user doesn't have access to the group","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":22,"column":53,"index":845},"line":22,"code":"  it('fails if user doesn\\'t have access to the group', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const anotherUser = await generateUser();\n    await expect(anotherUser.get(`/groups/${group._id}/invites`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"works when passing party as req.params.groupId","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":34,"column":52,"index":1254},"line":34,"code":"  it('works when passing party as req.params.groupId', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const invited = await generateUser();\n    await user.post(`/groups/${group._id}/invite`, {\n      uuids: [invited._id]\n    });\n    const res = await user.get('/groups/party/invites');\n    expect(res).to.be.an('array');\n    expect(res.length).to.equal(1);\n    expect(res[0]).to.eql({\n      _id: invited._id,\n      id: invited._id,\n      profile: {\n        name: invited.profile.name\n      },\n      auth: {\n        local: {\n          username: invited.auth.local.username\n        }\n      },\n      flags: {\n        verifiedUsername: true\n      }\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"populates only some fields","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":62,"column":32,"index":1965},"line":62,"code":"  it('populates only some fields', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const invited = await generateUser();\n    await user.post(`/groups/${group._id}/invite`, {\n      uuids: [invited._id]\n    });\n    const res = await user.get('/groups/party/invites');\n    expect(res[0]).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n    expect(res[0].profile).to.have.all.keys(['name']);\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"returns only first 30 invites by default (req.query.limit not specified)","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":75,"column":78,"index":2490},"line":75,"code":"  it('returns only first 30 invites by default (req.query.limit not specified)', async () => {\n    const leader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(leader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    const invitesToGenerate = [];\n\n    for (let i = 0; i < 31; i += 1) {\n      invitesToGenerate.push(generateUser());\n    }\n\n    const generatedInvites = await Promise.all(invitesToGenerate);\n    await leader.post(`/groups/${group._id}/invite`, {\n      uuids: generatedInvites.map(invite => invite._id)\n    });\n    const res = await leader.get(`/groups/${group._id}/invites`);\n    expect(res.length).to.equal(30);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n  }).timeout(10000);","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is over 60","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":101,"column":52,"index":3364},"line":101,"code":"  it('returns an error if req.query.limit is over 60', async () => {\n    const leader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(leader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    await expect(leader.get(`/groups/${group._id}/invites?limit=61`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is under 1","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":116,"column":52,"index":3828},"line":116,"code":"  it('returns an error if req.query.limit is under 1', async () => {\n    const leader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(leader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    await expect(leader.get(`/groups/${group._id}/invites?limit=-1`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is not an integer","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":131,"column":59,"index":4299},"line":131,"code":"  it('returns an error if req.query.limit is not an integer', async () => {\n    const leader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(leader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    await expect(leader.get(`/groups/${group._id}/invites?limit=1.3`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"returns up to 60 invites when req.query.limit is specified","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":146,"column":64,"index":4776},"line":146,"code":"  it('returns up to 60 invites when req.query.limit is specified', async () => {\n    const leader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(leader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    const invitesToGenerate = [];\n\n    for (let i = 0; i < 31; i += 1) {\n      invitesToGenerate.push(generateUser());\n    }\n\n    const generatedInvites = await Promise.all(invitesToGenerate);\n    await leader.post(`/groups/${group._id}/invite`, {\n      uuids: generatedInvites.map(invite => invite._id)\n    });\n    let res = await leader.get(`/groups/${group._id}/invites?limit=14`);\n    expect(res.length).to.equal(14);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n    res = await leader.get(`/groups/${group._id}/invites?limit=31`);\n    expect(res.length).to.equal(31);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n  }).timeout(30000);","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"supports using req.query.lastId to get more invites","suites":["GET /groups/:groupId/invites"],"updatePoint":{"line":178,"column":57,"index":5943},"line":178,"code":"  it('supports using req.query.lastId to get more invites', async function test() {\n    this.timeout(30000); // @TODO: times out after 8 seconds\n\n    const leader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(leader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    const invitesToGenerate = [];\n\n    for (let i = 0; i < 32; i += 1) {\n      invitesToGenerate.push(generateUser());\n    }\n\n    const generatedInvites = await Promise.all(invitesToGenerate); // Group has 32 invites\n\n    const expectedIds = generatedInvites.map(generatedInvite => generatedInvite._id);\n    await user.post(`/groups/${group._id}/invite`, {\n      uuids: expectedIds\n    });\n    const res = await user.get(`/groups/${group._id}/invites`);\n    expect(res.length).to.equal(30);\n    const res2 = await user.get(`/groups/${group._id}/invites?lastId=${res[res.length - 1]._id}`);\n    expect(res2.length).to.equal(2);\n    const resIds = res.concat(res2).map(invite => invite._id);\n    expect(resIds).to.eql(expectedIds.sort());\n  });","file":"api/v3/integration/groups/GET-groups_groupId_invites.test.js","skipped":false,"dir":"test"},{"name":"validates optional req.query.lastId to be an UUID","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":21,"column":55,"index":577},"line":21,"code":"  it('validates optional req.query.lastId to be an UUID', async () => {\n    await expect(user.get('/groups/groupId/members?lastId=invalidUUID')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"fails if group doesn't exists","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":28,"column":36,"index":834},"line":28,"code":"  it('fails if group doesn\\'t exists', async () => {\n    await expect(user.get(`/groups/${generateUUID()}/members`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"fails if user doesn't have access to the group","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":35,"column":53,"index":1094},"line":35,"code":"  it('fails if user doesn\\'t have access to the group', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const anotherUser = await generateUser();\n    await expect(anotherUser.get(`/groups/${group._id}/members`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"works when passing party as req.params.groupId","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":47,"column":52,"index":1503},"line":47,"code":"  it('works when passing party as req.params.groupId', async () => {\n    await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const res = await user.get('/groups/party/members');\n    expect(res).to.be.an('array');\n    expect(res.length).to.equal(1);\n    expect(res[0]).to.eql({\n      _id: user._id,\n      id: user._id,\n      profile: {\n        name: user.profile.name\n      },\n      auth: {\n        local: {\n          username: user.auth.local.username\n        }\n      },\n      flags: {\n        verifiedUsername: true\n      }\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"populates only some fields","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":71,"column":32,"index":2058},"line":71,"code":"  it('populates only some fields', async () => {\n    await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const res = await user.get('/groups/party/members');\n    expect(res[0]).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n    expect(res[0].profile).to.have.all.keys(['name']);\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"req.query.includeAllPublicFields === true works with guilds","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":80,"column":65,"index":2426},"line":80,"code":"  it('req.query.includeAllPublicFields === true works with guilds', async () => {\n    const group = await generateGroup(user, {\n      type: 'guild',\n      name: generateUUID()\n    });\n    const [memberRes] = await user.get(`/groups/${group._id}/members?includeAllPublicFields=true`);\n    expect(memberRes).to.have.all.keys([// works as: object has all and only these keys\n    '_id', 'id', 'preferences', 'profile', 'stats', 'achievements', 'party', 'backer', 'contributor', 'auth', 'items', 'inbox', 'loginIncentives', 'flags']);\n    expect(Object.keys(memberRes.auth)).to.eql(['local', 'timestamps']);\n    expect(Object.keys(memberRes.preferences).sort()).to.eql(['size', 'hair', 'skin', 'shirt', 'chair', 'costume', 'sleep', 'background', 'tasks', 'disableClasses'].sort());\n    expect(memberRes.stats.maxMP).to.exist;\n    expect(memberRes.stats.maxHealth).to.equal(common.maxHealth);\n    expect(memberRes.stats.toNextLevel).to.equal(common.tnl(memberRes.stats.lvl));\n    expect(memberRes.inbox.optOut).to.exist;\n    expect(memberRes.inbox.messages).to.not.exist;\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"populates all public fields if req.query.includeAllPublicFields === true and it is a party","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":96,"column":96,"index":3529},"line":96,"code":"  it('populates all public fields if req.query.includeAllPublicFields === true and it is a party', async () => {\n    await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const [memberRes] = await user.get('/groups/party/members?includeAllPublicFields=true');\n    expect(memberRes).to.have.all.keys([// works as: object has all and only these keys\n    '_id', 'id', 'preferences', 'profile', 'stats', 'achievements', 'party', 'backer', 'contributor', 'auth', 'items', 'inbox', 'loginIncentives', 'flags']);\n    expect(Object.keys(memberRes.auth)).to.eql(['local', 'timestamps']);\n    expect(Object.keys(memberRes.preferences).sort()).to.eql(['size', 'hair', 'skin', 'shirt', 'chair', 'costume', 'sleep', 'background', 'tasks', 'disableClasses'].sort());\n    expect(memberRes.stats.maxMP).to.exist;\n    expect(memberRes.stats.maxHealth).to.equal(common.maxHealth);\n    expect(memberRes.stats.toNextLevel).to.equal(common.tnl(memberRes.stats.lvl));\n    expect(memberRes.inbox.optOut).to.exist;\n    expect(memberRes.inbox.messages).to.not.exist;\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"returns only first 30 members by default (req.query.limit not specified)","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":112,"column":78,"index":4593},"line":112,"code":"  it('returns only first 30 members by default (req.query.limit not specified)', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 31; i += 1) {\n      usersToGenerate.push(generateUser({\n        party: {\n          _id: group._id\n        }\n      }));\n    }\n\n    await Promise.all(usersToGenerate);\n    const res = await user.get('/groups/party/members');\n    expect(res.length).to.equal(30);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is over 60","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":135,"column":52,"index":5262},"line":135,"code":"  it('returns an error if req.query.limit is over 60', async () => {\n    await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    await expect(user.get('/groups/party/members?limit=61')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is under 1","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":146,"column":52,"index":5611},"line":146,"code":"  it('returns an error if req.query.limit is under 1', async () => {\n    await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    await expect(user.get('/groups/party/members?limit=0')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.query.limit is not an integer","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":157,"column":59,"index":5966},"line":157,"code":"  it('returns an error if req.query.limit is not an integer', async () => {\n    await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    await expect(user.get('/groups/party/members?limit=1.1')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"returns up to 60 members when req.query.limit is specified","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":168,"column":64,"index":6328},"line":168,"code":"  it('returns up to 60 members when req.query.limit is specified', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 62; i += 1) {\n      usersToGenerate.push(generateUser({\n        party: {\n          _id: group._id\n        }\n      }));\n    }\n\n    await Promise.all(usersToGenerate);\n    let res = await user.get('/groups/party/members?limit=60');\n    expect(res.length).to.equal(60);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n    res = await user.get(`/groups/party/members?limit=60&lastId=${res[res.length - 1]._id}`);\n    expect(res.length).to.equal(3);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n  }).timeout(30000);","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"returns only first 30 members even when ?includeAllMembers=true","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":197,"column":69,"index":7341},"line":197,"code":"  it('returns only first 30 members even when ?includeAllMembers=true', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 31; i += 1) {\n      usersToGenerate.push(generateUser({\n        party: {\n          _id: group._id\n        }\n      }));\n    }\n\n    await Promise.all(usersToGenerate);\n    const res = await user.get('/groups/party/members?includeAllMembers=true');\n    expect(res.length).to.equal(30);\n    res.forEach(member => {\n      expect(member).to.have.all.keys(['_id', 'auth', 'flags', 'id', 'profile']);\n      expect(member.profile).to.have.all.keys(['name']);\n    });\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"supports using req.query.lastId to get more members","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":220,"column":57,"index":8038},"line":220,"code":"  it('supports using req.query.lastId to get more members', async function test() {\n    this.timeout(30000); // @TODO: times out after 8 seconds\n\n    const leader = await generateUser({\n      balance: 4\n    });\n    const group = await generateGroup(leader, {\n      type: 'guild',\n      privacy: 'public',\n      name: generateUUID()\n    });\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 57; i += 1) {\n      usersToGenerate.push(generateUser({\n        guilds: [group._id]\n      }));\n    } // Group has 59 members (1 is the leader)\n\n\n    const generatedUsers = await Promise.all(usersToGenerate);\n    const expectedIds = [leader._id].concat(generatedUsers.map(generatedUser => generatedUser._id));\n    const res = await user.get(`/groups/${group._id}/members`);\n    expect(res.length).to.equal(30);\n    const res2 = await user.get(`/groups/${group._id}/members?lastId=${res[res.length - 1]._id}`);\n    expect(res2.length).to.equal(28);\n    const resIds = res.concat(res2).map(member => member._id);\n    expect(resIds).to.eql(expectedIds.sort());\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"searches members","suites":["GET /groups/:groupId/members"],"updatePoint":{"line":249,"column":22,"index":9063},"line":249,"code":"  it('searches members', async () => {\n    const group = await generateGroup(user, {\n      type: 'party',\n      name: generateUUID()\n    });\n    const usersToGenerate = [];\n\n    for (let i = 0; i < 2; i += 1) {\n      usersToGenerate.push(generateUser({\n        party: {\n          _id: group._id\n        }\n      }));\n    }\n\n    const usersCreated = await Promise.all(usersToGenerate);\n    const userToSearch = usersCreated[0].profile.name;\n    const res = await user.get(`/groups/party/members?search=${userToSearch}`);\n    expect(res.length).to.equal(1);\n    expect(res[0].profile.name).to.equal(userToSearch);\n  });","file":"api/v3/integration/groups/GET-groups_groupId_members.test.js","skipped":false,"dir":"test"},{"name":"returns the group object","suites":["GET /groups/:id","Member of a "],"updatePoint":{"line":33,"column":34,"index":1000},"line":33,"code":"      it('returns the group object', async () => {\n        const group = await member.get(`/groups/${createdGroup._id}`);\n        expect(group._id).to.eql(createdGroup._id);\n        expect(group.name).to.eql(createdGroup.name);\n        expect(group.type).to.eql(createdGroup.type);\n        expect(group.privacy).to.eql(createdGroup.privacy);\n      });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"transforms leader id to leader object","suites":["GET /groups/:id","Member of a "],"updatePoint":{"line":40,"column":47,"index":1365},"line":40,"code":"      it('transforms leader id to leader object', async () => {\n        const group = await member.get(`/groups/${createdGroup._id}`);\n        expect(group.leader._id).to.eql(leader._id);\n        expect(group.leader.profile.name).to.eql(leader.profile.name);\n      });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"returns the group object for a non-member","suites":["GET /groups/:id","Non-member of a public guild"],"updatePoint":{"line":62,"column":49,"index":2054},"line":62,"code":"    it('returns the group object for a non-member', async () => {\n      const group = await nonMember.get(`/groups/${createdGroup._id}`);\n      expect(group._id).to.eql(createdGroup._id);\n      expect(group.name).to.eql(createdGroup.name);\n      expect(group.type).to.eql(createdGroup.type);\n      expect(group.privacy).to.eql(createdGroup.privacy);\n    });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"does not return the group object for a non-member","suites":["GET /groups/:id","Non-member of a private guild"],"updatePoint":{"line":85,"column":57,"index":2832},"line":85,"code":"    it('does not return the group object for a non-member', async () => {\n      await expect(nonMember.get(`/groups/${createdGroup._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"does not return the group object for a non-member","suites":["GET /groups/:id","Non-member of a party"],"updatePoint":{"line":108,"column":57,"index":3511},"line":108,"code":"    it('does not return the group object for a non-member', async () => {\n      await expect(nonMember.get(`/groups/${createdGroup._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"returns the user's party if an id of \"party\" is passed in","suites":["GET /groups/:id","Member of a party"],"updatePoint":{"line":131,"column":66,"index":4233},"line":131,"code":"    it('returns the user\\'s party if an id of \"party\" is passed in', async () => {\n      const group = await member.get('/groups/party');\n      expect(group._id).to.eql(createdGroup._id);\n      expect(group.name).to.eql(createdGroup.name);\n      expect(group.type).to.eql(createdGroup.type);\n      expect(group.privacy).to.eql(createdGroup.privacy);\n    });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"returns error if group does not exist","suites":["GET /groups/:id","Non-existent group"],"updatePoint":{"line":144,"column":45,"index":4702},"line":144,"code":"    it('returns error if group does not exist', async () => {\n      await expect(user.get('/groups/group-that-does-not-exist')).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"removes non-existent guild from user's guild list","suites":["GET /groups/:id","Non-existent group"],"updatePoint":{"line":151,"column":58,"index":4979},"line":151,"code":"    it('removes non-existent guild from user\\'s guild list', async () => {\n      const guildId = generateUUID();\n      await user.update({\n        guilds: [guildId, generateUUID()]\n      });\n      await expect(user.get(`/groups/${guildId}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n      await user.sync();\n      expect(user.guilds).to.have.a.lengthOf(1);\n      expect(user.guilds).to.not.include(guildId);\n    });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"removes non-existent party from user's party object","suites":["GET /groups/:id","Non-existent group"],"updatePoint":{"line":165,"column":60,"index":5484},"line":165,"code":"    it('removes non-existent party from user\\'s party object', async () => {\n      const partyId = generateUUID();\n      await user.update({\n        party: {\n          _id: partyId\n        }\n      });\n      await expect(user.get(`/groups/${partyId}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n      await user.sync();\n      expect(user.party).to.eql({});\n    });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"does not include messages with a flag count of 2 or greater","suites":["GET /groups/:id","Flagged messages","non-admin"],"updatePoint":{"line":238,"column":69,"index":7196},"line":238,"code":"      it('does not include messages with a flag count of 2 or greater', async () => {\n        const fetchedGroup = await nonAdmin.get(`/groups/${group._id}`);\n        expect(fetchedGroup.chat).to.have.lengthOf(3);\n        expect(fetchedGroup.chat[0].id).to.eql(chat1.id);\n        expect(fetchedGroup.chat[1].id).to.eql(chat2.id);\n        expect(fetchedGroup.chat[2].id).to.eql(chat3.id);\n      });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"does not include user ids in flags object","suites":["GET /groups/:id","Flagged messages","non-admin"],"updatePoint":{"line":245,"column":51,"index":7576},"line":245,"code":"      it('does not include user ids in flags object', async () => {\n        const fetchedGroup = await nonAdmin.get(`/groups/${group._id}`);\n        const chatWithOneFlag = fetchedGroup.chat[2];\n        expect(chatWithOneFlag.id).to.eql(chat3.id);\n        expect(chat3.flags).to.eql({\n          'user-id': true\n        });\n        expect(chatWithOneFlag.flags).to.eql({});\n      });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"includes all messages","suites":["GET /groups/:id","Flagged messages","admin"],"updatePoint":{"line":262,"column":31,"index":8119},"line":262,"code":"      it('includes all messages', async () => {\n        const fetchedGroup = await admin.get(`/groups/${group._id}`);\n        expect(fetchedGroup.chat).to.have.lengthOf(5);\n        expect(fetchedGroup.chat[0].id).to.eql(chat1.id);\n        expect(fetchedGroup.chat[1].id).to.eql(chat2.id);\n        expect(fetchedGroup.chat[2].id).to.eql(chat3.id);\n        expect(fetchedGroup.chat[3].id).to.eql(chat4.id);\n        expect(fetchedGroup.chat[4].id).to.eql(chat5.id);\n      });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"includes user ids in flags object","suites":["GET /groups/:id","Flagged messages","admin"],"updatePoint":{"line":271,"column":43,"index":8604},"line":271,"code":"      it('includes user ids in flags object', async () => {\n        const fetchedGroup = await admin.get(`/groups/${group._id}`);\n        const chatWithOneFlag = fetchedGroup.chat[2];\n        expect(chatWithOneFlag.id).to.eql(chat3.id);\n        expect(chat3.flags).to.eql({\n          'user-id': true\n        });\n        expect(chatWithOneFlag.flags).to.eql(chat3.flags);\n      });","file":"api/v3/integration/groups/GET-groups_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when no query passed in","suites":["GET /groups"],"updatePoint":{"line":75,"column":43,"index":2418},"line":75,"code":"  it('returns error when no query passed in', async () => {\n    await expect(user.get('/groups')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns error when an invalid ?type query is passed","suites":["GET /groups"],"updatePoint":{"line":82,"column":57,"index":2669},"line":82,"code":"  it('returns error when an invalid ?type query is passed', async () => {\n    await expect(user.get('/groups?type=invalid')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('groupTypesRequired')\n    });\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns only the tavern when tavern passed in as query","suites":["GET /groups"],"updatePoint":{"line":89,"column":60,"index":2930},"line":89,"code":"  it('returns only the tavern when tavern passed in as query', async () => {\n    await expect(user.get('/groups?type=tavern')).to.eventually.have.a.lengthOf(1).and.to.have.nested.property('[0]').and.to.have.property('_id', TAVERN_ID);\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns only the user's party when party passed in as query","suites":["GET /groups"],"updatePoint":{"line":92,"column":66,"index":3177},"line":92,"code":"  it('returns only the user\\'s party when party passed in as query', async () => {\n    await expect(user.get('/groups?type=party')).to.eventually.have.a.lengthOf(1).and.to.have.nested.property('[0]');\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns all public guilds when publicGuilds passed in as query","suites":["GET /groups"],"updatePoint":{"line":95,"column":68,"index":3386},"line":95,"code":"  it('returns all public guilds when publicGuilds passed in as query', async () => {\n    await expect(user.get('/groups?type=publicGuilds')).to.eventually.have.a.lengthOf(NUMBER_OF_PUBLIC_GUILDS);\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns public guilds filtered by category","suites":["GET /groups","filters"],"updatePoint":{"line":99,"column":50,"index":3601},"line":99,"code":"    it('returns public guilds filtered by category', async () => {\n      const guilds = await user.get(`/groups?type=publicGuilds&categories=${categories[0].slug}`);\n      expect(guilds[0]._id).to.equal(publicGuildNotMember._id);\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns private guilds filtered by category","suites":["GET /groups","filters"],"updatePoint":{"line":103,"column":51,"index":3840},"line":103,"code":"    it('returns private guilds filtered by category', async () => {\n      const guilds = await user.get(`/groups?type=privateGuilds&categories=${categories[0].slug}`);\n      expect(guilds[0]._id).to.equal(privateGuildUserIsMemberOf._id);\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"filters public guilds by size","suites":["GET /groups","filters"],"updatePoint":{"line":107,"column":37,"index":4072},"line":107,"code":"    it('filters public guilds by size', async () => {\n      await generateGroup(user, {\n        name: 'guild1',\n        type: 'guild',\n        privacy: 'public',\n        memberCount: 1\n      }); // @TODO: anyway to set higher memberCount in tests right now?\n\n      const guilds = await user.get('/groups?type=publicGuilds&minMemberCount=3');\n      expect(guilds.length).to.equal(0);\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"filters private guilds by size","suites":["GET /groups","filters"],"updatePoint":{"line":118,"column":38,"index":4464},"line":118,"code":"    it('filters private guilds by size', async () => {\n      await generateGroup(user, {\n        name: 'guild1',\n        type: 'guild',\n        privacy: 'private',\n        memberCount: 1\n      }); // @TODO: anyway to set higher memberCount in tests right now?\n\n      const guilds = await user.get('/groups?type=privateGuilds&minMemberCount=3');\n      expect(guilds.length).to.equal(0);\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"filters public guilds by leader role","suites":["GET /groups","filters"],"updatePoint":{"line":129,"column":44,"index":4864},"line":129,"code":"    it('filters public guilds by leader role', async () => {\n      const guilds = await user.get('/groups?type=publicGuilds&leader=true');\n      expect(guilds.length).to.equal(NUMBER_OF_PUBLIC_GUILDS_USER_IS_LEADER);\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"filters public guilds by member role","suites":["GET /groups","filters"],"updatePoint":{"line":133,"column":44,"index":5089},"line":133,"code":"    it('filters public guilds by member role', async () => {\n      const guilds = await userInGuild.get('/groups?type=publicGuilds&member=true');\n      expect(guilds.length).to.equal(1);\n      expect(guilds[0].name).to.have.string('is member');\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"filters public guilds by single-word search term","suites":["GET /groups","filters"],"updatePoint":{"line":138,"column":56,"index":5354},"line":138,"code":"    it('filters public guilds by single-word search term', async () => {\n      const guilds = await user.get('/groups?type=publicGuilds&search=kom');\n      expect(guilds.length).to.equal(1);\n      expect(guilds[0].summary).to.have.string('ohayou kombonwa');\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"filters public guilds by single-word search term left and right-padded by spaces","suites":["GET /groups","filters"],"updatePoint":{"line":143,"column":88,"index":5652},"line":143,"code":"    it('filters public guilds by single-word search term left and right-padded by spaces', async () => {\n      const guilds = await user.get('/groups?type=publicGuilds&search=++++ohayou+kombonwa+++++');\n      expect(guilds.length).to.equal(1);\n      expect(guilds[0].summary).to.have.string('ohayou kombonwa');\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"filters public guilds by two-words search term separated by multiple spaces","suites":["GET /groups","filters"],"updatePoint":{"line":148,"column":83,"index":5966},"line":148,"code":"    it('filters public guilds by two-words search term separated by multiple spaces', async () => {\n      const guilds = await user.get('/groups?type=publicGuilds&search=kinnosuke+++++hon');\n      expect(guilds.length).to.equal(1);\n      expect(guilds[0].description).to.have.string('Kinnosuke');\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"req.query.paginate must be a boolean string","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":155,"column":51,"index":6292},"line":155,"code":"    it('req.query.paginate must be a boolean string', async () => {\n      await expect(user.get('/groups?paginate=aString&type=publicGuilds')).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'Invalid request parameters.'\n      });\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"req.query.paginate can only be true when req.query.type includes publicGuilds","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":162,"column":85,"index":6618},"line":162,"code":"    it('req.query.paginate can only be true when req.query.type includes publicGuilds', async () => {\n      await expect(user.get('/groups?paginate=true&type=notPublicGuilds')).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: apiError('guildsOnlyPaginate')\n      });\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"req.query.page can't be negative","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":169,"column":41,"index":6901},"line":169,"code":"    it('req.query.page can\\'t be negative', async () => {\n      await expect(user.get('/groups?paginate=true&page=-1&type=publicGuilds')).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'Invalid request parameters.'\n      });\n    });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns 30 guilds per page ordered by number of members","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":176,"column":63,"index":7210},"line":176,"code":"    it('returns 30 guilds per page ordered by number of members', async () => {\n      await user.update({\n        balance: 9000\n      });\n      const groups = await Promise.all(_.times(60, i => generateGroup(user, {\n        name: `public guild ${i} - is member`,\n        type: 'guild',\n        privacy: 'public'\n      }))); // update group number 32 and not the first to make sure sorting works\n\n      await groups[32].update({\n        name: 'guild with most members',\n        memberCount: 199\n      });\n      await groups[33].update({\n        name: 'guild with less members',\n        memberCount: -100\n      });\n      const page0 = await expect(user.get('/groups?type=publicGuilds&paginate=true')).to.eventually.have.a.lengthOf(GUILD_PER_PAGE);\n      expect(page0[0].name).to.equal('guild with most members');\n      await expect(user.get('/groups?type=publicGuilds&paginate=true&page=1')).to.eventually.have.a.lengthOf(GUILD_PER_PAGE);\n      const page2 = await expect(user.get('/groups?type=publicGuilds&paginate=true&page=2')) // 1 created now, 4 by other tests, -1 for no more tavern.\n      .to.eventually.have.a.lengthOf(1 + 4 - 1);\n      expect(page2[3].name).to.equal('guild with less members');\n    }).timeout(10000);","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"makes sure that the tavern doesn't show up when guilds is passed as a query","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":202,"column":82,"index":8461},"line":202,"code":"  it('makes sure that the tavern doesn\\'t show up when guilds is passed as a query', async () => {\n    const guilds = await user.get('/groups?type=guilds');\n    expect(guilds.find(g => g.id === TAVERN_ID)).to.be.undefined;\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"makes sure that the tavern doesn't show up when publicGuilds is passed as a query","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":206,"column":88,"index":8696},"line":206,"code":"  it('makes sure that the tavern doesn\\'t show up when publicGuilds is passed as a query', async () => {\n    const guilds = await user.get('/groups?type=publicGuilds');\n    expect(guilds.find(g => g.id === TAVERN_ID)).to.be.undefined;\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns all the user's guilds when guilds passed in as query","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":210,"column":67,"index":8916},"line":210,"code":"  it('returns all the user\\'s guilds when guilds passed in as query', async () => {\n    await expect(user.get('/groups?type=guilds')).to.eventually.have.a.lengthOf(NUMBER_OF_PUBLIC_GUILDS_USER_IS_MEMBER + NUMBER_OF_USERS_PRIVATE_GUILDS);\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns all private guilds user is a part of when privateGuilds passed in as query","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":213,"column":88,"index":9181},"line":213,"code":"  it('returns all private guilds user is a part of when privateGuilds passed in as query', async () => {\n    await expect(user.get('/groups?type=privateGuilds')).to.eventually.have.a.lengthOf(NUMBER_OF_USERS_PRIVATE_GUILDS);\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns a list of groups user has access to","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":216,"column":49,"index":9373},"line":216,"code":"  it('returns a list of groups user has access to', async () => {\n    await expect(user.get('/groups?type=privateGuilds,publicGuilds,party,tavern')).to.eventually.have.lengthOf(NUMBER_OF_GROUPS_USER_CAN_VIEW - 1); // -1 for no Tavern.\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns a list of groups user has access to","suites":["GET /groups","public guilds pagination"],"updatePoint":{"line":219,"column":49,"index":9614},"line":219,"code":"  it('returns a list of groups user has access to', async () => {\n    const group = await generateGroup(user, {\n      name: 'c++ coders',\n      type: 'guild',\n      privacy: 'public'\n    }); // search for 'c++ coders'\n\n    await expect(user.get('/groups?type=publicGuilds&paginate=true&page=0&search=c%2B%2B+coders')).to.eventually.have.lengthOf(1).and.to.have.nested.property('[0]').and.to.have.property('_id', group._id);\n  });","file":"api/v3/integration/groups/GET-groups.test.js","skipped":false,"dir":"test"},{"name":"returns an error when a non group leader tries to add member","suites":["POST /group/:groupId/remove-manager"],"updatePoint":{"line":34,"column":66,"index":954},"line":34,"code":"  it('returns an error when a non group leader tries to add member', async () => {\n    await expect(nonLeader.post(`/groups/${groupToUpdate._id}/remove-manager`, {\n      managerId: nonLeader._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageGroupOnlyLeaderCanUpdate')\n    });\n  });","file":"api/v3/integration/groups/POST-group_remove_manager.test.js","skipped":false,"dir":"test"},{"name":"returns an error when manager does not exist","suites":["POST /group/:groupId/remove-manager"],"updatePoint":{"line":43,"column":50,"index":1290},"line":43,"code":"  it('returns an error when manager does not exist', async () => {\n    await expect(leader.post(`/groups/${groupToUpdate._id}/remove-manager`, {\n      managerId: nonManager._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('userIsNotManager')\n    });\n  });","file":"api/v3/integration/groups/POST-group_remove_manager.test.js","skipped":false,"dir":"test"},{"name":"allows a leader to remove managers","suites":["POST /group/:groupId/remove-manager"],"updatePoint":{"line":52,"column":40,"index":1599},"line":52,"code":"  it('allows a leader to remove managers', async () => {\n    await leader.post(`/groups/${groupToUpdate._id}/add-manager`, {\n      managerId: nonLeader._id\n    });\n    const updatedGroup = await leader.post(`/groups/${groupToUpdate._id}/remove-manager`, {\n      managerId: nonLeader._id\n    });\n    expect(updatedGroup.managers[nonLeader._id]).to.not.exist;\n  });","file":"api/v3/integration/groups/POST-group_remove_manager.test.js","skipped":false,"dir":"test"},{"name":"removes group approval notifications from a manager that is removed","suites":["POST /group/:groupId/remove-manager"],"updatePoint":{"line":61,"column":73,"index":1996},"line":61,"code":"  it('removes group approval notifications from a manager that is removed', async () => {\n    await leader.post(`/groups/${groupToUpdate._id}/add-manager`, {\n      managerId: nonLeader._id\n    });\n    const task = await leader.post(`/tasks/group/${groupToUpdate._id}`, {\n      text: 'test todo',\n      type: 'todo',\n      requiresApproval: true\n    });\n    await nonLeader.post(`/tasks/${task._id}/assign/${nonManager._id}`);\n    const memberTasks = await nonManager.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await nonManager.post(`/tasks/${syncedTask._id}/score/up`);\n    const updatedGroup = await leader.post(`/groups/${groupToUpdate._id}/remove-manager`, {\n      managerId: nonLeader._id\n    });\n    await nonLeader.sync();\n    expect(nonLeader.notifications.length).to.equal(0);\n    expect(updatedGroup.managers[nonLeader._id]).to.not.exist;\n  });","file":"api/v3/integration/groups/POST-group_remove_manager.test.js","skipped":false,"dir":"test"},{"name":"returns error when groupId is not for a valid group","suites":["POST /group/:groupId/join"],"updatePoint":{"line":5,"column":57,"index":303},"line":5,"code":"  it('returns error when groupId is not for a valid group', async () => {\n    const joiningUser = await generateUser();\n    await expect(joiningUser.post(`/groups/${generateUUID()}/join`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"allows non-invited users to join public guilds","suites":["POST /group/:groupId/join","Joining a public guild"],"updatePoint":{"line":32,"column":54,"index":1064},"line":32,"code":"    it('allows non-invited users to join public guilds', async () => {\n      const res = await joiningUser.post(`/groups/${publicGuild._id}/join`);\n      await expect(joiningUser.get('/user')).to.eventually.have.property('guilds').to.include(publicGuild._id);\n      expect(res.leader._id).to.eql(user._id);\n      expect(res.leader.profile.name).to.eql(user.profile.name);\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user was already a member","suites":["POST /group/:groupId/join","Joining a public guild"],"updatePoint":{"line":38,"column":53,"index":1443},"line":38,"code":"    it('returns an error if user was already a member', async () => {\n      await joiningUser.post(`/groups/${publicGuild._id}/join`);\n      await expect(joiningUser.post(`/groups/${publicGuild._id}/join`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('youAreAlreadyInGroup')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"promotes joining member in a public empty guild to leader","suites":["POST /group/:groupId/join","Joining a public guild"],"updatePoint":{"line":46,"column":65,"index":1810},"line":46,"code":"    it('promotes joining member in a public empty guild to leader', async () => {\n      await user.post(`/groups/${publicGuild._id}/leave`);\n      await joiningUser.post(`/groups/${publicGuild._id}/join`);\n      await expect(joiningUser.get(`/groups/${publicGuild._id}`)).to.eventually.have.nested.property('leader._id', joiningUser._id);\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"increments memberCount when joining guilds","suites":["POST /group/:groupId/join","Joining a public guild"],"updatePoint":{"line":51,"column":50,"index":2142},"line":51,"code":"    it('increments memberCount when joining guilds', async () => {\n      const oldMemberCount = publicGuild.memberCount;\n      await joiningUser.post(`/groups/${publicGuild._id}/join`);\n      await expect(joiningUser.get(`/groups/${publicGuild._id}`)).to.eventually.have.property('memberCount', oldMemberCount + 1);\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"awards Joined Guild achievement","suites":["POST /group/:groupId/join","Joining a public guild"],"updatePoint":{"line":56,"column":39,"index":2455},"line":56,"code":"    it('awards Joined Guild achievement', async () => {\n      await joiningUser.post(`/groups/${publicGuild._id}/join`);\n      await expect(joiningUser.get('/user')).to.eventually.have.nested.property('achievements.joinedGuild', true);\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not invited to private guild","suites":["POST /group/:groupId/join","Joining a private guild"],"updatePoint":{"line":82,"column":63,"index":3241},"line":82,"code":"    it('returns error when user is not invited to private guild', async () => {\n      const userWithoutInvite = await generateUser();\n      await expect(userWithoutInvite.post(`/groups/${guild._id}/join`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageGroupRequiresInvite')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"allows invited user to join private guilds","suites":["POST /group/:groupId/join","Joining a private guild","User is invited"],"updatePoint":{"line":91,"column":52,"index":3629},"line":91,"code":"      it('allows invited user to join private guilds', async () => {\n        await invitedUser.post(`/groups/${guild._id}/join`);\n        await expect(invitedUser.get('/user')).to.eventually.have.property('guilds').to.include(guild._id);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"clears invitation from user when joining guilds","suites":["POST /group/:groupId/join","Joining a private guild","User is invited"],"updatePoint":{"line":95,"column":57,"index":3882},"line":95,"code":"      it('clears invitation from user when joining guilds', async () => {\n        await invitedUser.post(`/groups/${guild._id}/join`);\n        await expect(invitedUser.get('/user')).to.eventually.have.nested.property('invitations.guilds').to.not.include({\n          id: guild._id\n        });\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"increments memberCount when joining guilds","suites":["POST /group/:groupId/join","Joining a private guild","User is invited"],"updatePoint":{"line":101,"column":52,"index":4179},"line":101,"code":"      it('increments memberCount when joining guilds', async () => {\n        const oldMemberCount = guild.memberCount;\n        await invitedUser.post(`/groups/${guild._id}/join`);\n        await expect(invitedUser.get(`/groups/${guild._id}`)).to.eventually.have.property('memberCount', oldMemberCount + 1);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"does not give basilist quest to inviter when joining a guild","suites":["POST /group/:groupId/join","Joining a private guild","User is invited"],"updatePoint":{"line":106,"column":70,"index":4513},"line":106,"code":"      it('does not give basilist quest to inviter when joining a guild', async () => {\n        await invitedUser.post(`/groups/${guild._id}/join`);\n        await expect(user.get('/user')).to.eventually.not.have.nested.property('items.quests.basilist');\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"does not increment basilist quest count to inviter with basilist when joining a guild","suites":["POST /group/:groupId/join","Joining a private guild","User is invited"],"updatePoint":{"line":110,"column":95,"index":4801},"line":110,"code":"      it('does not increment basilist quest count to inviter with basilist when joining a guild', async () => {\n        await user.update({\n          'items.quests.basilist': 1\n        });\n        await invitedUser.post(`/groups/${guild._id}/join`);\n        await expect(user.get('/user')).to.eventually.have.nested.property('items.quests.basilist', 1);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"notifies inviting user that their invitation was accepted","suites":["POST /group/:groupId/join","Joining a private guild","User is invited"],"updatePoint":{"line":117,"column":67,"index":5137},"line":117,"code":"      it('notifies inviting user that their invitation was accepted', async () => {\n        await invitedUser.post(`/groups/${guild._id}/join`);\n        const inviter = await user.get('/user');\n        const expectedData = {\n          headerText: t('invitationAcceptedHeader'),\n          bodyText: t('invitationAcceptedBody', {\n            username: invitedUser.auth.local.username,\n            groupName: guild.name\n          })\n        };\n        expect(inviter.notifications[1].type).to.eql('GROUP_INVITE_ACCEPTED');\n        expect(inviter.notifications[1].data).to.eql(expectedData);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"awards Joined Guild achievement","suites":["POST /group/:groupId/join","Joining a private guild","User is invited"],"updatePoint":{"line":130,"column":41,"index":5709},"line":130,"code":"      it('awards Joined Guild achievement', async () => {\n        await invitedUser.post(`/groups/${guild._id}/join`);\n        await expect(invitedUser.get('/user')).to.eventually.have.nested.property('achievements.joinedGuild', true);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not invited to party","suites":["POST /group/:groupId/join","Joining a party"],"updatePoint":{"line":157,"column":55,"index":6477},"line":157,"code":"    it('returns error when user is not invited to party', async () => {\n      const userWithoutInvite = await generateUser();\n      await expect(userWithoutInvite.post(`/groups/${party._id}/join`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageGroupRequiresInvite')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"allows invited user to join party","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":166,"column":43,"index":6856},"line":166,"code":"      it('allows invited user to join party', async () => {\n        await invitedUser.post(`/groups/${party._id}/join`);\n        await expect(invitedUser.get('/user')).to.eventually.have.nested.property('party._id', party._id);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"Issue #12291: accepting a redundant party invite will let the user stay in the party","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":170,"column":94,"index":7145},"line":170,"code":"      it('Issue #12291: accepting a redundant party invite will let the user stay in the party', async () => {\n        await invitedUser.update({\n          'party._id': party._id\n        });\n        await expect(invitedUser.get('/user')).to.eventually.have.nested.property('party._id', party._id);\n        await invitedUser.post(`/groups/${party._id}/join`);\n        await expect(invitedUser.get('/user')).to.eventually.have.nested.property('party._id', party._id);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"notifies inviting user that their invitation was accepted","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":178,"column":67,"index":7594},"line":178,"code":"      it('notifies inviting user that their invitation was accepted', async () => {\n        await invitedUser.post(`/groups/${party._id}/join`);\n        const inviter = await user.get('/user');\n        const expectedData = {\n          headerText: t('invitationAcceptedHeader'),\n          bodyText: t('invitationAcceptedBody', {\n            username: invitedUser.auth.local.username,\n            groupName: party.name\n          })\n        };\n        expect(inviter.notifications[0].type).to.eql('GROUP_INVITE_ACCEPTED');\n        expect(inviter.notifications[0].data).to.eql(expectedData);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"clears invitation from user when joining party","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":191,"column":56,"index":8181},"line":191,"code":"      it('clears invitation from user when joining party', async () => {\n        await invitedUser.post(`/groups/${party._id}/join`);\n        await expect(invitedUser.get('/user')).to.eventually.not.have.nested.property('invitations.parties[0].id');\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"increments memberCount when joining party","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":195,"column":51,"index":8436},"line":195,"code":"      it('increments memberCount when joining party', async () => {\n        const oldMemberCount = party.memberCount;\n        await invitedUser.post(`/groups/${party._id}/join`);\n        await expect(invitedUser.get(`/groups/${party._id}`)).to.eventually.have.property('memberCount', oldMemberCount + 1);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"gives basilist quest item to the inviter when joining a party","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":200,"column":71,"index":8771},"line":200,"code":"      it('gives basilist quest item to the inviter when joining a party', async () => {\n        await invitedUser.post(`/groups/${party._id}/join`);\n        await expect(user.get('/user')).to.eventually.have.nested.property('items.quests.basilist', 1);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"increments basilist quest item count to inviter when joining a party","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":204,"column":78,"index":9041},"line":204,"code":"      it('increments basilist quest item count to inviter when joining a party', async () => {\n        await user.update({\n          'items.quests.basilist': 1\n        });\n        await invitedUser.post(`/groups/${party._id}/join`);\n        await expect(user.get('/user')).to.eventually.have.nested.property('items.quests.basilist', 2);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"deletes previous party where the user was the only member","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":211,"column":67,"index":9377},"line":211,"code":"      it('deletes previous party where the user was the only member', async () => {\n        const userToInvite = await generateUser();\n        const oldParty = await userToInvite.post('/groups', {\n          // add user to a party\n          name: 'Another Test Party',\n          type: 'party'\n        });\n        await expect(checkExistence('groups', oldParty._id)).to.eventually.equal(true);\n        await user.post(`/groups/${party._id}/invite`, {\n          uuids: [userToInvite._id]\n        });\n        await userToInvite.post(`/groups/${party._id}/join`);\n        await expect(user.get('/user')).to.eventually.have.nested.property('party._id', party._id);\n        await expect(checkExistence('groups', oldParty._id)).to.eventually.equal(false);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"does not allow user to leave a party if a quest was active and they were the only member","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":226,"column":98,"index":10166},"line":226,"code":"      it('does not allow user to leave a party if a quest was active and they were the only member', async () => {\n        const userToInvite = await generateUser();\n        const oldParty = await userToInvite.post('/groups', {\n          // add user to a party\n          name: 'Another Test Party',\n          type: 'party'\n        });\n        await userToInvite.update({\n          [`items.quests.${PET_QUEST}`]: 1\n        });\n        await userToInvite.post(`/groups/${oldParty._id}/quests/invite/${PET_QUEST}`);\n        await expect(checkExistence('groups', oldParty._id)).to.eventually.equal(true);\n        await user.post(`/groups/${party._id}/invite`, {\n          uuids: [userToInvite._id]\n        });\n        await expect(userToInvite.post(`/groups/${party._id}/join`)).to.eventually.be.rejected.and.eql({\n          code: 401,\n          error: 'NotAuthorized',\n          message: t('messageCannotLeaveWhileQuesting')\n        });\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"invites joining member to active quest","suites":["POST /group/:groupId/join","Joining a party","User is invited"],"updatePoint":{"line":247,"column":48,"index":11060},"line":247,"code":"      it('invites joining member to active quest', async () => {\n        await user.update({\n          [`items.quests.${PET_QUEST}`]: 1\n        });\n        await user.post(`/groups/${party._id}/quests/invite/${PET_QUEST}`);\n        await invitedUser.post(`/groups/${party._id}/join`);\n        await invitedUser.sync();\n        await party.sync();\n        expect(invitedUser).to.have.nested.property('party.quest.RSVPNeeded', true);\n        expect(invitedUser).to.have.nested.property('party.quest.key', party.quest.key);\n        expect(party.quest.members[invitedUser._id]).to.be.null;\n      });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"awards Party Up achievement to party of size 2","suites":["POST /group/:groupId/join","Party incentive achievements"],"updatePoint":{"line":277,"column":54,"index":12141},"line":277,"code":"    it('awards Party Up achievement to party of size 2', async () => {\n      await member.sync();\n      await leader.sync();\n      expect(member).to.have.nested.property('achievements.partyUp', true);\n      expect(member.notifications.find(notification => notification.type === 'ACHIEVEMENT_PARTY_UP')).to.exist;\n      expect(leader).to.have.nested.property('achievements.partyUp', true);\n      expect(leader.notifications.find(notification => notification.type === 'ACHIEVEMENT_PARTY_UP')).to.exist;\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"does not award Party On achievement to party of size 2","suites":["POST /group/:groupId/join","Party incentive achievements"],"updatePoint":{"line":285,"column":62,"index":12658},"line":285,"code":"    it('does not award Party On achievement to party of size 2', async () => {\n      await member.sync();\n      await leader.sync();\n      expect(member).to.not.have.nested.property('achievements.partyOn');\n      expect(leader).to.not.have.nested.property('achievements.partyOn');\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"awards Party On achievement to party of size 4","suites":["POST /group/:groupId/join","Party incentive achievements"],"updatePoint":{"line":291,"column":54,"index":12939},"line":291,"code":"    it('awards Party On achievement to party of size 4', async () => {\n      const addlMemberOne = await generateUser();\n      const addlMemberTwo = await generateUser();\n      await leader.post(`/groups/${party._id}/invite`, {\n        uuids: [addlMemberOne._id, addlMemberTwo._id]\n      });\n      await addlMemberOne.post(`/groups/${party._id}/join`);\n      await addlMemberTwo.post(`/groups/${party._id}/join`);\n      await member.sync();\n      await leader.sync();\n      expect(member).to.have.nested.property('achievements.partyOn', true);\n      expect(member.notifications.find(notification => notification.type === 'ACHIEVEMENT_PARTY_ON')).to.exist;\n      expect(leader).to.have.nested.property('achievements.partyOn', true);\n      expect(leader.notifications.find(notification => notification.type === 'ACHIEVEMENT_PARTY_ON')).to.exist;\n    });","file":"api/v3/integration/groups/POST-groups_groupId_join.test.js","skipped":false,"dir":"test"},{"name":"prevents non members from leaving","suites":["POST /groups/:groupId/leave","Leaving a "],"updatePoint":{"line":44,"column":43,"index":1452},"line":44,"code":"      it('prevents non members from leaving', async () => {\n        const user = await generateUser();\n        await expect(user.post(`/groups/${groupToLeave._id}/leave`)).to.eventually.be.rejected.and.eql({\n          code: 404,\n          error: 'NotFound',\n          message: t('groupNotFound')\n        });\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"lets user leave a ","suites":["POST /groups/:groupId/leave","Leaving a "],"updatePoint":{"line":52,"column":40,"index":1767},"line":52,"code":"      it(`lets user leave a ${groupType}`, async () => {\n        await member.post(`/groups/${groupToLeave._id}/leave`);\n        const userThatLeftGroup = await member.get('/user');\n        expect(userThatLeftGroup.guilds).to.be.empty;\n        expect(userThatLeftGroup.party._id).to.not.exist;\n        await groupToLeave.sync();\n        expect(groupToLeave.memberCount).to.equal(memberCount - 1);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"sets a new group leader when leader leaves a ","suites":["POST /groups/:groupId/leave","Leaving a "],"updatePoint":{"line":60,"column":67,"index":2201},"line":60,"code":"      it(`sets a new group leader when leader leaves a ${groupType}`, async () => {\n        await leader.post(`/groups/${groupToLeave._id}/leave`);\n        await groupToLeave.sync();\n        expect(groupToLeave.memberCount).to.equal(memberCount - 1);\n        expect(groupToLeave.leader).to.equal(member._id);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"removes new messages for that group from user","suites":["POST /groups/:groupId/leave","Leaving a "],"updatePoint":{"line":66,"column":55,"index":2508},"line":66,"code":"      it('removes new messages for that group from user', async () => {\n        await member.post(`/groups/${groupToLeave._id}/chat`, {\n          message: 'Some message'\n        });\n        await sleep(0.5);\n        await leader.sync();\n        expect(leader.notifications.find(n => n.type === 'NEW_CHAT_MESSAGE' && n.data.group.id === groupToLeave._id)).to.exist;\n        expect(leader.newMessages[groupToLeave._id]).to.not.be.empty;\n        await leader.post(`/groups/${groupToLeave._id}/leave`);\n        await leader.sync();\n        expect(leader.notifications.find(n => n.type === 'NEW_CHAT_MESSAGE' && n.data.group.id === groupToLeave._id)).to.not.exist;\n        expect(leader.newMessages[groupToLeave._id]).to.be.undefined;\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"removes all challenge tasks when keep parameter is set to remove","suites":["POST /groups/:groupId/leave","Leaving a ","with challenges"],"updatePoint":{"line":90,"column":76,"index":3680},"line":90,"code":"        it('removes all challenge tasks when keep parameter is set to remove', async () => {\n          await leader.post(`/groups/${groupToLeave._id}/leave?keep=remove-all`);\n          const userWithoutChallengeTasks = await leader.get('/user');\n          expect(userWithoutChallengeTasks.challenges).to.not.include(challenge._id);\n          expect(userWithoutChallengeTasks.tasksOrder.habits).to.be.empty;\n        });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"keeps all challenge tasks when keep parameter is not set","suites":["POST /groups/:groupId/leave","Leaving a ","with challenges"],"updatePoint":{"line":96,"column":68,"index":4091},"line":96,"code":"        it('keeps all challenge tasks when keep parameter is not set', async () => {\n          await leader.post(`/groups/${groupToLeave._id}/leave`);\n          const userWithChallengeTasks = await leader.get('/user'); // @TODO find elegant way to assert against the task existing\n\n          expect(userWithChallengeTasks.tasksOrder.habits).to.not.be.empty;\n        });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"keeps the user in the challenge when the keepChallenges parameter is set to remain-in-challenges","suites":["POST /groups/:groupId/leave","Leaving a ","with challenges"],"updatePoint":{"line":102,"column":108,"index":4501},"line":102,"code":"        it('keeps the user in the challenge when the keepChallenges parameter is set to remain-in-challenges', async () => {\n          await leader.post(`/groups/${groupToLeave._id}/leave`, {\n            keepChallenges: 'remain-in-challenges'\n          });\n          const userWithChallengeTasks = await leader.get('/user');\n          expect(userWithChallengeTasks.challenges).to.include(challenge._id);\n        });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"drops the user in the challenge when the keepChallenges parameter isn't set","suites":["POST /groups/:groupId/leave","Leaving a ","with challenges"],"updatePoint":{"line":109,"column":88,"index":4897},"line":109,"code":"        it('drops the user in the challenge when the keepChallenges parameter isn\\'t set', async () => {\n          await leader.post(`/groups/${groupToLeave._id}/leave`);\n          const userWithChallengeTasks = await leader.get('/user');\n          expect(userWithChallengeTasks.challenges).to.not.include(challenge._id);\n        });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"prevents quest leader from leaving a groupToLeave","suites":["POST /groups/:groupId/leave","Leaving a ","with challenges"],"updatePoint":{"line":115,"column":59,"index":5212},"line":115,"code":"      it('prevents quest leader from leaving a groupToLeave');","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"prevents a user from leaving during an active quest","suites":["POST /groups/:groupId/leave","Leaving a ","with challenges"],"updatePoint":{"line":116,"column":61,"index":5277},"line":116,"code":"      it('prevents a user from leaving during an active quest');","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"removes a group when the last member leaves","suites":["POST /groups/:groupId/leave","Leaving a group as the last member","private guild"],"updatePoint":{"line":144,"column":53,"index":6046},"line":144,"code":"      it('removes a group when the last member leaves', async () => {\n        await leader.post(`/groups/${privateGuild._id}/leave`);\n        await expect(checkExistence('groups', privateGuild._id)).to.eventually.equal(false);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"removes invitations when the last member leaves","suites":["POST /groups/:groupId/leave","Leaving a group as the last member","private guild"],"updatePoint":{"line":148,"column":57,"index":6287},"line":148,"code":"      it('removes invitations when the last member leaves', async () => {\n        await leader.post(`/groups/${privateGuild._id}/leave`);\n        const userWithoutInvitation = await invitedUser.get('/user');\n        expect(userWithoutInvitation.invitations.guilds).to.be.empty;\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"keeps the group when the last member leaves","suites":["POST /groups/:groupId/leave","Leaving a group as the last member","public guild"],"updatePoint":{"line":175,"column":53,"index":7144},"line":175,"code":"      it('keeps the group when the last member leaves', async () => {\n        await leader.post(`/groups/${publicGuild._id}/leave`);\n        await expect(checkExistence('groups', publicGuild._id)).to.eventually.equal(true);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"keeps the invitations when the last member leaves a public guild","suites":["POST /groups/:groupId/leave","Leaving a group as the last member","public guild"],"updatePoint":{"line":179,"column":74,"index":7399},"line":179,"code":"      it('keeps the invitations when the last member leaves a public guild', async () => {\n        await leader.post(`/groups/${publicGuild._id}/leave`);\n        const userWithoutInvitation = await invitedUser.get('/user');\n        expect(userWithoutInvitation.invitations.guilds).to.not.be.empty;\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"deletes non existent guild from user when user tries to leave","suites":["POST /groups/:groupId/leave","Leaving a group as the last member","public guild"],"updatePoint":{"line":184,"column":71,"index":7704},"line":184,"code":"      it('deletes non existent guild from user when user tries to leave', async () => {\n        const nonExistentGuildId = generateUUID();\n        const userWithNonExistentGuild = await generateUser({\n          guilds: [nonExistentGuildId]\n        });\n        expect(userWithNonExistentGuild.guilds).to.contain(nonExistentGuildId);\n        await expect(userWithNonExistentGuild.post(`/groups/${nonExistentGuildId}/leave`)).to.eventually.be.rejected;\n        await userWithNonExistentGuild.sync();\n        expect(userWithNonExistentGuild.guilds).to.not.contain(nonExistentGuildId);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"removes a group when the last member leaves a party","suites":["POST /groups/:groupId/leave","Leaving a group as the last member","party"],"updatePoint":{"line":215,"column":61,"index":8801},"line":215,"code":"      it('removes a group when the last member leaves a party', async () => {\n        await leader.post(`/groups/${party._id}/leave`);\n        await expect(checkExistence('party', party._id)).to.eventually.equal(false);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"removes invitations when the last member leaves a party","suites":["POST /groups/:groupId/leave","Leaving a group as the last member","party"],"updatePoint":{"line":219,"column":65,"index":9035},"line":219,"code":"      it('removes invitations when the last member leaves a party', async () => {\n        await leader.post(`/groups/${party._id}/leave`);\n        const userWithoutInvitation = await invitedUser.get('/user');\n        expect(userWithoutInvitation.invitations.parties[0]).to.be.undefined;\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"deletes non existent party from user when user tries to leave","suites":["POST /groups/:groupId/leave","Leaving a group as the last member","party"],"updatePoint":{"line":225,"column":69,"index":9344},"line":225,"code":"    it('deletes non existent party from user when user tries to leave', async () => {\n      const nonExistentPartyId = generateUUID();\n      const userWithNonExistentParty = await generateUser({\n        'party._id': nonExistentPartyId\n      });\n      expect(userWithNonExistentParty.party._id).to.eql(nonExistentPartyId);\n      await expect(userWithNonExistentParty.post(`/groups/${nonExistentPartyId}/leave`)).to.eventually.be.rejected;\n      await userWithNonExistentParty.sync();\n      expect(userWithNonExistentParty.party).to.eql({});\n    });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"cancels the free subscription","suites":["POST /groups/:groupId/leave","Leaving a group plan when the group is a "],"updatePoint":{"line":274,"column":39,"index":11038},"line":274,"code":"      it('cancels the free subscription', async () => {\n        expect(member.purchased.plan.planId).to.equal('group_plan_auto');\n        expect(member.purchased.plan.dateTerminated).to.not.exist; // Leave\n\n        await member.post(`/groups/${groupWithPlan._id}/leave`);\n        await member.sync();\n        expect(member.purchased.plan.dateTerminated).to.exist;\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"preserves the free subscription when leaving a any other group without a plan","suites":["POST /groups/:groupId/leave","Leaving a group plan when the group is a "],"updatePoint":{"line":282,"column":87,"index":11460},"line":282,"code":"      it('preserves the free subscription when leaving a any other group without a plan', async () => {\n        // Joining a guild without a group plan\n        const {\n          group: groupWithNoPlan\n        } = await createAndPopulateGroup({\n          groupDetails: {\n            name: 'Group Without Plan',\n            type: 'guild',\n            privacy: 'public'\n          }\n        });\n        await member.post(`/groups/${groupWithNoPlan._id}/join`);\n        await member.sync();\n        expect(member.purchased.plan.planId).to.equal('group_plan_auto');\n        expect(member.purchased.plan.dateTerminated).to.not.exist; // Leaving the guild without a group plan\n\n        await member.post(`/groups/${groupWithNoPlan._id}/leave`);\n        await member.sync();\n        expect(member.purchased.plan.dateTerminated).to.not.exist;\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"calculates dateTerminated and sets extraMonths to zero after user leaves the group","suites":["POST /groups/:groupId/leave","Leaving a group with extraMonths left plan when the group is a "],"updatePoint":{"line":326,"column":92,"index":13021},"line":326,"code":"      it('calculates dateTerminated and sets extraMonths to zero after user leaves the group', async () => {\n        const userBeforeLeave = await User.findById(member._id).exec();\n        await member.post(`/groups/${groupWithPlan._id}/leave`);\n        const userAfterLeave = await User.findById(member._id).exec();\n        const dateTerminatedBefore = userBeforeLeave.purchased.plan.dateTerminated;\n        const extraMonthsBefore = userBeforeLeave.purchased.plan.extraMonths;\n        const dateTerminatedAfter = userAfterLeave.purchased.plan.dateTerminated;\n        const extraMonthsAfter = userAfterLeave.purchased.plan.extraMonths;\n        const expectedTerminationDate = calculateSubscriptionTerminationDate(null, {\n          customerId: payments.constants.GROUP_PLAN_CUSTOMER_ID,\n          extraMonths\n        }, payments.constants.GROUP_PLAN_CUSTOMER_ID);\n        expect(extraMonthsBefore).to.gte(12);\n        expect(extraMonthsAfter).to.equal(0);\n        expect(dateTerminatedBefore).to.be.null;\n        expect(dateTerminatedAfter).to.exist;\n        expect(moment(dateTerminatedAfter).diff(expectedTerminationDate, 'days')).to.equal(0);\n      });","file":"api/v3/integration/groups/POST-groups_groupId_leave.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not invited","suites":["POST /group/:groupId/reject-invite","Rejecting a public guild invite"],"updatePoint":{"line":21,"column":46,"index":683},"line":21,"code":"    it('returns error when user is not invited', async () => {\n      const userWithoutInvite = await generateUser();\n      await expect(userWithoutInvite.post(`/groups/${publicGuild._id}/reject-invite`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageGroupRequiresInvite')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_groupId_reject.test.js","skipped":false,"dir":"test"},{"name":"clears invitation from user","suites":["POST /group/:groupId/reject-invite","Rejecting a public guild invite"],"updatePoint":{"line":29,"column":35,"index":1030},"line":29,"code":"    it('clears invitation from user', async () => {\n      await invitedUser.post(`/groups/${publicGuild._id}/reject-invite`);\n      await expect(invitedUser.get('/user')).to.eventually.have.nested.property('invitations.guilds').to.not.include({\n        id: publicGuild._id\n      });\n    });","file":"api/v3/integration/groups/POST-groups_groupId_reject.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not invited","suites":["POST /group/:groupId/reject-invite","Rejecting a private guild invite"],"updatePoint":{"line":54,"column":46,"index":1798},"line":54,"code":"    it('returns error when user is not invited', async () => {\n      const userWithoutInvite = await generateUser();\n      await expect(userWithoutInvite.post(`/groups/${guild._id}/reject-invite`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageGroupRequiresInvite')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_groupId_reject.test.js","skipped":false,"dir":"test"},{"name":"clears invitation from user","suites":["POST /group/:groupId/reject-invite","Rejecting a private guild invite"],"updatePoint":{"line":62,"column":35,"index":2139},"line":62,"code":"    it('clears invitation from user', async () => {\n      await invitedUser.post(`/groups/${guild._id}/reject-invite`);\n      await expect(invitedUser.get('/user')).to.eventually.have.nested.property('invitations.guilds').to.not.include({\n        id: guild._id\n      });\n    });","file":"api/v3/integration/groups/POST-groups_groupId_reject.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not invited","suites":["POST /group/:groupId/reject-invite","Rejecting a party invite"],"updatePoint":{"line":87,"column":46,"index":2877},"line":87,"code":"    it('returns error when user is not invited', async () => {\n      const userWithoutInvite = await generateUser();\n      await expect(userWithoutInvite.post(`/groups/${party._id}/reject-invite`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageGroupRequiresInvite')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_groupId_reject.test.js","skipped":false,"dir":"test"},{"name":"clears invitation from user","suites":["POST /group/:groupId/reject-invite","Rejecting a party invite"],"updatePoint":{"line":95,"column":35,"index":3218},"line":95,"code":"    it('clears invitation from user', async () => {\n      await invitedUser.post(`/groups/${party._id}/reject-invite`);\n      await expect(invitedUser.get('/user')).to.eventually.not.have.nested.property('invitations.parties[0].id');\n    });","file":"api/v3/integration/groups/POST-groups_groupId_reject.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user is not member of the group","suites":["POST /groups/:groupId/removeMember/:memberId","All Groups"],"updatePoint":{"line":38,"column":61,"index":1073},"line":38,"code":"    it('returns an error when user is not member of the group', async () => {\n      const nonMember = await generateUser();\n      expect(nonMember.post(`/groups/${guild._id}/removeMember/${member._id}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        type: 'NotAuthorized',\n        message: t('onlyLeaderCanRemoveMember')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user is a non-leader member of a group and not an admin","suites":["POST /groups/:groupId/removeMember/:memberId","All Groups"],"updatePoint":{"line":46,"column":85,"index":1453},"line":46,"code":"    it('returns an error when user is a non-leader member of a group and not an admin', async () => {\n      expect(member2.post(`/groups/${guild._id}/removeMember/${member._id}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        type: 'NotAuthorized',\n        message: t('onlyLeaderCanRemoveMember')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"does not allow leader to remove themselves","suites":["POST /groups/:groupId/removeMember/:memberId","All Groups"],"updatePoint":{"line":53,"column":50,"index":1750},"line":53,"code":"    it('does not allow leader to remove themselves', async () => {\n      expect(leader.post(`/groups/${guild._id}/removeMember/${leader._id}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        text: t('messageGroupCannotRemoveSelf')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"can remove other members","suites":["POST /groups/:groupId/removeMember/:memberId","Guilds"],"updatePoint":{"line":67,"column":32,"index":2154},"line":67,"code":"    it('can remove other members', async () => {\n      await leader.post(`/groups/${guild._id}/removeMember/${member._id}`);\n      const memberRemoved = await member.get('/user');\n      expect(memberRemoved.guilds.indexOf(guild._id)).eql(-1);\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"updates memberCount","suites":["POST /groups/:groupId/removeMember/:memberId","Guilds"],"updatePoint":{"line":72,"column":27,"index":2400},"line":72,"code":"    it('updates memberCount', async () => {\n      const oldMemberCount = guild.memberCount;\n      await leader.post(`/groups/${guild._id}/removeMember/${member._id}`);\n      await expect(leader.get(`/groups/${guild._id}`)).to.eventually.have.property('memberCount', oldMemberCount - 1);\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"can remove other invites","suites":["POST /groups/:groupId/removeMember/:memberId","Guilds"],"updatePoint":{"line":77,"column":32,"index":2700},"line":77,"code":"    it('can remove other invites', async () => {\n      await leader.post(`/groups/${guild._id}/removeMember/${invitedUser._id}`);\n      const invitedUserWithoutInvite = await invitedUser.get('/user');\n      expect(_.findIndex(invitedUserWithoutInvite.invitations.guilds, {\n        id: guild._id\n      })).eql(-1);\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"allows an admin to remove other members","suites":["POST /groups/:groupId/removeMember/:memberId","Guilds"],"updatePoint":{"line":84,"column":47,"index":3037},"line":84,"code":"    it('allows an admin to remove other members', async () => {\n      await adminUser.post(`/groups/${guild._id}/removeMember/${member._id}`);\n      const memberRemoved = await member.get('/user');\n      expect(memberRemoved.guilds.indexOf(guild._id)).eql(-1);\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"allows an admin to remove other invites","suites":["POST /groups/:groupId/removeMember/:memberId","Guilds"],"updatePoint":{"line":89,"column":47,"index":3306},"line":89,"code":"    it('allows an admin to remove other invites', async () => {\n      await adminUser.post(`/groups/${guild._id}/removeMember/${invitedUser._id}`);\n      const invitedUserWithoutInvite = await invitedUser.get('/user');\n      expect(_.findIndex(invitedUserWithoutInvite.invitations.guilds, {\n        id: guild._id\n      })).eql(-1);\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"does not allow an admin to remove a leader","suites":["POST /groups/:groupId/removeMember/:memberId","Guilds"],"updatePoint":{"line":96,"column":50,"index":3649},"line":96,"code":"    it('does not allow an admin to remove a leader', async () => {\n      expect(adminUser.post(`/groups/${guild._id}/removeMember/${leader._id}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        text: t('cannotRemoveCurrentLeader')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"sends email to user with rescinded invite","suites":["POST /groups/:groupId/removeMember/:memberId","Guilds"],"updatePoint":{"line":102,"column":49,"index":3913},"line":102,"code":"    it('sends email to user with rescinded invite', async () => {\n      await leader.post(`/groups/${guild._id}/removeMember/${invitedUser._id}`);\n      expect(email.sendTxn).to.be.calledOnce;\n      expect(email.sendTxn.args[0][0]._id).to.eql(invitedUser._id);\n      expect(email.sendTxn.args[0][1]).to.eql('guild-invite-rescinded');\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"sends email to removed user","suites":["POST /groups/:groupId/removeMember/:memberId","Guilds"],"updatePoint":{"line":108,"column":35,"index":4241},"line":108,"code":"    it('sends email to removed user', async () => {\n      await leader.post(`/groups/${guild._id}/removeMember/${member._id}`);\n      expect(email.sendTxn).to.be.calledOnce;\n      expect(email.sendTxn.args[0][0]._id).to.eql(member._id);\n      expect(email.sendTxn.args[0][1]).to.eql('kicked-from-guild');\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"can remove other members","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":149,"column":32,"index":5405},"line":149,"code":"    it('can remove other members', async () => {\n      await partyLeader.post(`/groups/${party._id}/removeMember/${partyMember._id}`);\n      const memberRemoved = await partyMember.get('/user');\n      expect(memberRemoved.party._id).eql(undefined);\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"updates memberCount","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":154,"column":27,"index":5657},"line":154,"code":"    it('updates memberCount', async () => {\n      const oldMemberCount = party.memberCount;\n      await partyLeader.post(`/groups/${party._id}/removeMember/${partyMember._id}`);\n      await expect(partyLeader.get(`/groups/${party._id}`)).to.eventually.have.property('memberCount', oldMemberCount - 1);\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"can remove other invites","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":159,"column":32,"index":5972},"line":159,"code":"    it('can remove other invites', async () => {\n      expect(partyInvitedUser.invitations.parties[0]).to.not.be.empty;\n      await partyLeader.post(`/groups/${party._id}/removeMember/${partyInvitedUser._id}`);\n      const invitedUserWithoutInvite = await partyInvitedUser.get('/user');\n      expect(invitedUserWithoutInvite.invitations.parties[0]).to.be.undefined;\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"removes new messages from a member who is removed","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":165,"column":57,"index":6371},"line":165,"code":"    it('removes new messages from a member who is removed', async () => {\n      await partyLeader.post(`/groups/${party._id}/chat`, {\n        message: 'Some message'\n      });\n      await sleep(0.5);\n      await removedMember.sync();\n      expect(removedMember.notifications.find(n => n.type === 'NEW_CHAT_MESSAGE' && n.data.group.id === party._id)).to.exist;\n      expect(removedMember.newMessages[party._id]).to.not.be.empty;\n      await partyLeader.post(`/groups/${party._id}/removeMember/${removedMember._id}`);\n      await removedMember.sync();\n      expect(removedMember.notifications.find(n => n.type === 'NEW_CHAT_MESSAGE' && n.data.group.id === party._id)).to.not.exist;\n      expect(removedMember.newMessages[party._id]).to.be.undefined;\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"removes user from quest when removing user from party after quest starts","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":178,"column":80,"index":7150},"line":178,"code":"    it('removes user from quest when removing user from party after quest starts', async () => {\n      const petQuest = 'whale';\n      await partyLeader.update({\n        [`items.quests.${petQuest}`]: 1\n      });\n      await partyLeader.post(`/groups/${party._id}/quests/invite/${petQuest}`);\n      await partyMember.post(`/groups/${party._id}/quests/accept`);\n      await party.sync();\n      expect(party.quest.members[partyLeader._id]).to.be.true;\n      expect(party.quest.members[partyMember._id]).to.be.true;\n      await partyLeader.post(`/groups/${party._id}/removeMember/${partyMember._id}`);\n      await party.sync();\n      expect(party.quest.members[partyLeader._id]).to.be.true;\n      expect(party.quest.members[partyMember._id]).to.not.exist;\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"removes user from quest when removing user from party before quest starts","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":193,"column":81,"index":7911},"line":193,"code":"    it('removes user from quest when removing user from party before quest starts', async () => {\n      const petQuest = 'whale';\n      await partyLeader.update({\n        [`items.quests.${petQuest}`]: 1\n      });\n      await partyInvitedUser.post(`/groups/${party._id}/join`);\n      await partyLeader.post(`/groups/${party._id}/quests/invite/${petQuest}`);\n      await partyMember.post(`/groups/${party._id}/quests/accept`);\n      await party.sync();\n      expect(party.quest.active).to.be.false;\n      expect(party.quest.members[partyLeader._id]).to.be.true;\n      expect(party.quest.members[partyMember._id]).to.be.true;\n      await partyLeader.post(`/groups/${party._id}/removeMember/${partyMember._id}`);\n      await party.sync();\n      expect(party.quest.members[partyLeader._id]).to.be.true;\n      expect(party.quest.members[partyMember._id]).to.not.exist;\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"prevents user from being removed if they are the quest owner","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":210,"column":68,"index":8769},"line":210,"code":"    it('prevents user from being removed if they are the quest owner', async () => {\n      const petQuest = 'whale';\n      await partyMember.update({\n        [`items.quests.${petQuest}`]: 1\n      });\n      await partyMember.post(`/groups/${party._id}/quests/invite/${petQuest}`);\n      await partyLeader.post(`/groups/${party._id}/quests/accept`);\n      await party.sync();\n      expect(party.quest.members[partyLeader._id]).to.be.true;\n      expect(party.quest.members[partyMember._id]).to.be.true;\n      await party.sync();\n      expect(leader.post(`/groups/${party._id}/removeMember/${partyMember._id}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        text: t('cannotRemoveQuestOwner')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"sends email to user with rescinded invite","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":226,"column":49,"index":9473},"line":226,"code":"    it('sends email to user with rescinded invite', async () => {\n      await partyLeader.post(`/groups/${party._id}/removeMember/${partyInvitedUser._id}`);\n      expect(email.sendTxn).to.be.calledOnce;\n      expect(email.sendTxn.args[0][0]._id).to.eql(partyInvitedUser._id);\n      expect(email.sendTxn.args[0][1]).to.eql('party-invite-rescinded');\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"sends email to removed user","suites":["POST /groups/:groupId/removeMember/:memberId","Party"],"updatePoint":{"line":232,"column":35,"index":9816},"line":232,"code":"    it('sends email to removed user', async () => {\n      await partyLeader.post(`/groups/${party._id}/removeMember/${partyMember._id}`);\n      expect(email.sendTxn).to.be.calledOnce;\n      expect(email.sendTxn.args[0][0]._id).to.eql(partyMember._id);\n      expect(email.sendTxn.args[0][1]).to.eql('kicked-from-party');\n    });","file":"api/v3/integration/groups/POST-groups_id_removeMember.test.js","skipped":false,"dir":"test"},{"name":"returns an error when invited user is not found","suites":["Post /groups/:groupId/invite","username invites"],"updatePoint":{"line":21,"column":55,"index":671},"line":21,"code":"    it('returns an error when invited user is not found', async () => {\n      const fakeID = 'fakeuserid';\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        usernames: [fakeID]\n      })).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('userWithUsernameNotFound', {\n          username: fakeID\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when inviting yourself to a group","suites":["Post /groups/:groupId/invite","username invites"],"updatePoint":{"line":33,"column":58,"index":1071},"line":33,"code":"    it('returns an error when inviting yourself to a group', async () => {\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        usernames: [inviter.auth.local.lowerCaseUsername]\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('cannotInviteSelfToGroup')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"invites a user to a group by username","suites":["Post /groups/:groupId/invite","username invites"],"updatePoint":{"line":42,"column":45,"index":1414},"line":42,"code":"    it('invites a user to a group by username', async () => {\n      const userToInvite = await generateUser();\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        usernames: [userToInvite.auth.local.lowerCaseUsername]\n      })).to.eventually.deep.equal([{\n        id: group._id,\n        name: groupName,\n        inviter: inviter._id,\n        publicGuild: false\n      }]);\n      await expect(userToInvite.get('/user')).to.eventually.have.nested.property('invitations.guilds[0].id', group._id);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"invites multiple users to a group by uuid","suites":["Post /groups/:groupId/invite","username invites"],"updatePoint":{"line":54,"column":49,"index":1940},"line":54,"code":"    it('invites multiple users to a group by uuid', async () => {\n      const userToInvite = await generateUser();\n      const userToInvite2 = await generateUser();\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        usernames: [userToInvite.auth.local.lowerCaseUsername, userToInvite2.auth.local.lowerCaseUsername]\n      })).to.eventually.deep.equal([{\n        id: group._id,\n        name: groupName,\n        inviter: inviter._id,\n        publicGuild: false\n      }, {\n        id: group._id,\n        name: groupName,\n        inviter: inviter._id,\n        publicGuild: false\n      }]);\n      await expect(userToInvite.get('/user')).to.eventually.have.nested.property('invitations.guilds[0].id', group._id);\n      await expect(userToInvite2.get('/user')).to.eventually.have.nested.property('invitations.guilds[0].id', group._id);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when inviter has no chat privileges","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":75,"column":60,"index":2853},"line":75,"code":"    it('returns an error when inviter has no chat privileges', async () => {\n      const inviterMuted = await inviter.update({\n        'flags.chatRevoked': true\n      });\n      const userToInvite = await generateUser();\n      await expect(inviterMuted.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('chatPrivilegesRevoked')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when invited user is not found","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":88,"column":55,"index":3331},"line":88,"code":"    it('returns an error when invited user is not found', async () => {\n      const fakeID = generateUUID();\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [fakeID]\n      })).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('userWithIDNotFound', {\n          userId: fakeID\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when inviting yourself to a group","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":100,"column":58,"index":3721},"line":100,"code":"    it('returns an error when inviting yourself to a group', async () => {\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [inviter._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('cannotInviteSelfToGroup')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when uuids is not an array","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":109,"column":51,"index":4041},"line":109,"code":"    it('returns an error when uuids is not an array', async () => {\n      const fakeID = generateUUID();\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: {\n          fakeID\n        }\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('uuidsMustBeAnArray')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when uuids and emails are empty","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":121,"column":56,"index":4413},"line":121,"code":"    it('returns an error when uuids and emails are empty', async () => {\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        emails: [],\n        uuids: []\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('inviteMustNotBeEmpty')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when uuids is empty and emails is not passed","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":131,"column":69,"index":4757},"line":131,"code":"    it('returns an error when uuids is empty and emails is not passed', async () => {\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: []\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('inviteMustNotBeEmpty')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when there are more than INVITES_LIMIT uuids","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":140,"column":69,"index":5081},"line":140,"code":"    it('returns an error when there are more than INVITES_LIMIT uuids', async () => {\n      const uuids = [];\n\n      for (let i = 0; i < 101; i += 1) {\n        uuids.push(generateUUID());\n      }\n\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('canOnlyInviteMaxInvites', {\n          maxInvites: INVITES_LIMIT\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns error when recipient has blocked the senders","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":157,"column":60,"index":5555},"line":157,"code":"    it('returns error when recipient has blocked the senders', async () => {\n      const inviterNoBlocks = await inviter.update({\n        'inbox.blocks': []\n      });\n      const userWithBlockedInviter = await generateUser({\n        'inbox.blocks': [inviter._id]\n      });\n      await expect(inviterNoBlocks.post(`/groups/${group._id}/invite`, {\n        uuids: [userWithBlockedInviter._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('notAuthorizedToSendMessageToThisUser')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"invites a user to a group by uuid","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":172,"column":41,"index":6100},"line":172,"code":"    it('invites a user to a group by uuid', async () => {\n      const userToInvite = await generateUser();\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.deep.equal([{\n        id: group._id,\n        name: groupName,\n        inviter: inviter._id,\n        publicGuild: false\n      }]);\n      await expect(userToInvite.get('/user')).to.eventually.have.nested.property('invitations.guilds[0].id', group._id);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"invites multiple users to a group by uuid","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":184,"column":49,"index":6597},"line":184,"code":"    it('invites multiple users to a group by uuid', async () => {\n      const userToInvite = await generateUser();\n      const userToInvite2 = await generateUser();\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id, userToInvite2._id]\n      })).to.eventually.deep.equal([{\n        id: group._id,\n        name: groupName,\n        inviter: inviter._id,\n        publicGuild: false\n      }, {\n        id: group._id,\n        name: groupName,\n        inviter: inviter._id,\n        publicGuild: false\n      }]);\n      await expect(userToInvite.get('/user')).to.eventually.have.nested.property('invitations.guilds[0].id', group._id);\n      await expect(userToInvite2.get('/user')).to.eventually.have.nested.property('invitations.guilds[0].id', group._id);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when inviting multiple users and a user is not found","suites":["Post /groups/:groupId/invite","user id invites"],"updatePoint":{"line":203,"column":77,"index":7429},"line":203,"code":"    it('returns an error when inviting multiple users and a user is not found', async () => {\n      const userToInvite = await generateUser();\n      const fakeID = generateUUID();\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id, fakeID]\n      })).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('userWithIDNotFound', {\n          userId: fakeID\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when inviter has no chat privileges","suites":["Post /groups/:groupId/invite","email invites"],"updatePoint":{"line":222,"column":60,"index":8015},"line":222,"code":"    it('returns an error when inviter has no chat privileges', async () => {\n      const inviterMuted = await inviter.update({\n        'flags.chatRevoked': true\n      });\n      await expect(inviterMuted.post(`/groups/${group._id}/invite`, {\n        emails: [testInvite],\n        inviter: 'inviter name'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('chatPrivilegesRevoked')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when invite is missing an email","suites":["Post /groups/:groupId/invite","email invites"],"updatePoint":{"line":235,"column":56,"index":8473},"line":235,"code":"    it('returns an error when invite is missing an email', async () => {\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        emails: [{\n          name: 'test'\n        }]\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('inviteMissingEmail')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when emails is not an array","suites":["Post /groups/:groupId/invite","email invites"],"updatePoint":{"line":246,"column":52,"index":8813},"line":246,"code":"    it('returns an error when emails is not an array', async () => {\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        emails: {\n          testInvite\n        }\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('emailsMustBeAnArray')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when emails is empty and uuids is not passed","suites":["Post /groups/:groupId/invite","email invites"],"updatePoint":{"line":257,"column":69,"index":9167},"line":257,"code":"    it('returns an error when emails is empty and uuids is not passed', async () => {\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        emails: []\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('inviteMustNotBeEmpty')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when there are more than INVITES_LIMIT emails","suites":["Post /groups/:groupId/invite","email invites"],"updatePoint":{"line":266,"column":70,"index":9493},"line":266,"code":"    it('returns an error when there are more than INVITES_LIMIT emails', async () => {\n      const emails = [];\n\n      for (let i = 0; i < 101; i += 1) {\n        emails.push(`${generateUUID()}@habitica.com`);\n      }\n\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        emails\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('canOnlyInviteMaxInvites', {\n          maxInvites: INVITES_LIMIT\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when a user has sent the max number of email invites","suites":["Post /groups/:groupId/invite","email invites"],"updatePoint":{"line":283,"column":77,"index":10005},"line":283,"code":"    it('returns an error when a user has sent the max number of email invites', async () => {\n      const inviterWithMax = await generateUser({\n        invitesSent: MAX_EMAIL_INVITES_BY_USER,\n        balance: 4\n      });\n      const tmpGroup = await inviterWithMax.post('/groups', {\n        name: groupName,\n        type: 'guild'\n      });\n      await expect(inviterWithMax.post(`/groups/${tmpGroup._id}/invite`, {\n        emails: [testInvite],\n        inviter: 'inviter name'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('inviteLimitReached', {\n          techAssistanceEmail: nconf.get('EMAILS_TECH_ASSISTANCE_EMAIL')\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"invites a user to a group by email","suites":["Post /groups/:groupId/invite","email invites"],"updatePoint":{"line":303,"column":42,"index":10689},"line":303,"code":"    it('invites a user to a group by email', async () => {\n      const res = await inviter.post(`/groups/${group._id}/invite`, {\n        emails: [testInvite],\n        inviter: 'inviter name'\n      });\n      const updatedUser = await inviter.sync();\n      expect(res).to.exist;\n      expect(updatedUser.invitesSent).to.eql(1);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"invites multiple users to a group by email","suites":["Post /groups/:groupId/invite","email invites"],"updatePoint":{"line":312,"column":50,"index":11031},"line":312,"code":"    it('invites multiple users to a group by email', async () => {\n      const res = await inviter.post(`/groups/${group._id}/invite`, {\n        emails: [testInvite, {\n          name: 'test2',\n          email: 'test2@habitica.com'\n        }]\n      });\n      const updatedUser = await inviter.sync();\n      expect(res).to.exist;\n      expect(updatedUser.invitesSent).to.eql(2);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when emails and uuids are not provided","suites":["Post /groups/:groupId/invite","user and email invites"],"updatePoint":{"line":325,"column":63,"index":11480},"line":325,"code":"    it('returns an error when emails and uuids are not provided', async () => {\n      await expect(inviter.post(`/groups/${group._id}/invite`)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('canOnlyInviteEmailUuid')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when there are more than INVITES_LIMIT uuids and emails","suites":["Post /groups/:groupId/invite","user and email invites"],"updatePoint":{"line":332,"column":80,"index":11788},"line":332,"code":"    it('returns an error when there are more than INVITES_LIMIT uuids and emails', async () => {\n      const emails = [];\n      const uuids = [];\n\n      for (let i = 0; i < 50; i += 1) {\n        emails.push(`${generateUUID()}@habitica.com`);\n      }\n\n      for (let i = 0; i < 51; i += 1) {\n        uuids.push(generateUUID());\n      }\n\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        emails,\n        uuids\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('canOnlyInviteMaxInvites', {\n          maxInvites: INVITES_LIMIT\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"invites users to a group by uuid and email","suites":["Post /groups/:groupId/invite","user and email invites"],"updatePoint":{"line":355,"column":50,"index":12396},"line":355,"code":"    it('invites users to a group by uuid and email', async () => {\n      const newUser = await generateUser();\n      const invite = await inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [newUser._id],\n        emails: [{\n          name: 'test',\n          email: 'test@habitica.com'\n        }]\n      });\n      const invitedUser = await newUser.get('/user');\n      expect(invitedUser.invitations.guilds[0].id).to.equal(group._id);\n      expect(invite).to.exist;\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"invites marks invite with cancelled plan","suites":["Post /groups/:groupId/invite","user and email invites"],"updatePoint":{"line":368,"column":48,"index":12874},"line":368,"code":"    it('invites marks invite with cancelled plan', async () => {\n      const cancelledPlanGroup = await generateGroup(inviter, {\n        type: 'guild',\n        name: generateUUID()\n      });\n      await cancelledPlanGroup.createCancelledSubscription();\n      const newUser = await generateUser();\n      const invite = await inviter.post(`/groups/${cancelledPlanGroup._id}/invite`, {\n        uuids: [newUser._id],\n        emails: [{\n          name: 'test',\n          email: 'test@habitica.com'\n        }]\n      });\n      const invitedUser = await newUser.get('/user');\n      expect(invitedUser.invitations.guilds[0].id).to.equal(cancelledPlanGroup._id);\n      expect(invitedUser.invitations.guilds[0].cancelledPlan).to.be.true;\n      expect(invite).to.exist;\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when inviter has no chat privileges","suites":["Post /groups/:groupId/invite","guild invites"],"updatePoint":{"line":389,"column":60,"index":13694},"line":389,"code":"    it('returns an error when inviter has no chat privileges', async () => {\n      const inviterMuted = await inviter.update({\n        'flags.chatRevoked': true\n      });\n      const userToInvite = await generateUser();\n      await expect(inviterMuted.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('chatPrivilegesRevoked')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when invited user is already invited to the group","suites":["Post /groups/:groupId/invite","guild invites"],"updatePoint":{"line":402,"column":74,"index":14191},"line":402,"code":"    it('returns an error when invited user is already invited to the group', async () => {\n      const userToInvite = await generateUser();\n      await inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id]\n      });\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('userAlreadyInvitedToGroup', {\n          userId: userToInvite._id,\n          username: userToInvite.profile.name\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when invited user is already in the group","suites":["Post /groups/:groupId/invite","guild invites"],"updatePoint":{"line":418,"column":66,"index":14782},"line":418,"code":"    it('returns an error when invited user is already in the group', async () => {\n      const userToInvite = await generateUser();\n      await inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id]\n      });\n      await userToInvite.post(`/groups/${group._id}/join`);\n      await expect(inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('userAlreadyInGroup', {\n          userId: userToInvite._id,\n          username: userToInvite.profile.name\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"allows 30+ members in a guild","suites":["Post /groups/:groupId/invite","guild invites"],"updatePoint":{"line":435,"column":37,"index":15397},"line":435,"code":"    it('allows 30+ members in a guild', async () => {\n      const invitesToGenerate = []; // Generate 30 users to invite (30 + leader = 31 members)\n\n      for (let i = 0; i < PARTY_LIMIT_MEMBERS; i += 1) {\n        invitesToGenerate.push(generateUser());\n      }\n\n      const generatedInvites = await Promise.all(invitesToGenerate); // Invite users\n\n      expect(await inviter.post(`/groups/${group._id}/invite`, {\n        uuids: generatedInvites.map(invite => invite._id)\n      })).to.be.an('array');\n    }).timeout(10000); // @TODO: Add this after we are able to mock the group plan route","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when a non-leader invites to a group plan","suites":["Post /groups/:groupId/invite","guild invites"],"updatePoint":{"line":449,"column":67,"index":16018},"line":449,"code":"    xit('returns an error when a non-leader invites to a group plan', async () => {\n      const userToInvite = await generateUser();\n      const nonGroupLeader = await generateUser();\n      await inviter.post(`/groups/${group._id}/invite`, {\n        uuids: [nonGroupLeader._id]\n      });\n      await nonGroupLeader.post(`/groups/${group._id}/join`);\n      await expect(nonGroupLeader.post(`/groups/${group._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlyGroupLeaderCanInviteToGroupPlan')\n      });\n    });","skipped":true,"file":"api/v3/integration/groups/POST-groups_invite.test.js","dir":"test"},{"name":"returns an error when inviter has no chat privileges","suites":["Post /groups/:groupId/invite","party invites"],"updatePoint":{"line":473,"column":60,"index":16840},"line":473,"code":"    it('returns an error when inviter has no chat privileges', async () => {\n      const inviterMuted = await inviter.update({\n        'flags.chatRevoked': true\n      });\n      const userToInvite = await generateUser();\n      await expect(inviterMuted.post(`/groups/${party._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('chatPrivilegesRevoked')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when invited user has a pending invitation to the party","suites":["Post /groups/:groupId/invite","party invites"],"updatePoint":{"line":486,"column":80,"index":17343},"line":486,"code":"    it('returns an error when invited user has a pending invitation to the party', async () => {\n      const userToInvite = await generateUser();\n      await inviter.post(`/groups/${party._id}/invite`, {\n        uuids: [userToInvite._id]\n      });\n      await expect(inviter.post(`/groups/${party._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('userAlreadyPendingInvitation', {\n          userId: userToInvite._id,\n          username: userToInvite.profile.name\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when invited user is already in a party of more than 1 member","suites":["Post /groups/:groupId/invite","party invites"],"updatePoint":{"line":502,"column":86,"index":17957},"line":502,"code":"    it('returns an error when invited user is already in a party of more than 1 member', async () => {\n      const userToInvite = await generateUser();\n      const userToInvite2 = await generateUser();\n      await inviter.post(`/groups/${party._id}/invite`, {\n        uuids: [userToInvite._id, userToInvite2._id]\n      });\n      await userToInvite.post(`/groups/${party._id}/join`);\n      await userToInvite2.post(`/groups/${party._id}/join`);\n      await expect(inviter.post(`/groups/${party._id}/invite`, {\n        uuids: [userToInvite._id]\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('userAlreadyInAParty', {\n          userId: userToInvite._id,\n          username: userToInvite.profile.name\n        })\n      });\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"allow inviting a user to a party if they are partying solo","suites":["Post /groups/:groupId/invite","party invites"],"updatePoint":{"line":521,"column":66,"index":18732},"line":521,"code":"    it('allow inviting a user to a party if they are partying solo', async () => {\n      const userToInvite = await generateUser();\n      await userToInvite.post('/groups', {\n        // add user to a party\n        name: 'Another Test Party',\n        type: 'party'\n      });\n      await inviter.post(`/groups/${party._id}/invite`, {\n        uuids: [userToInvite._id]\n      });\n      expect((await userToInvite.get('/user')).invitations.parties[0].id).to.equal(party._id);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"allow inviting a user to 2 different parties","suites":["Post /groups/:groupId/invite","party invites"],"updatePoint":{"line":533,"column":52,"index":19197},"line":533,"code":"    it('allow inviting a user to 2 different parties', async () => {\n      // Create another inviter\n      const inviter2 = await generateUser(); // Create user to invite\n\n      const userToInvite = await generateUser(); // Create second group\n\n      const party2 = await inviter2.post('/groups', {\n        name: 'Test Party 2',\n        type: 'party'\n      }); // Invite to first party\n\n      await inviter.post(`/groups/${party._id}/invite`, {\n        uuids: [userToInvite._id]\n      }); // Invite to second party\n\n      await inviter2.post(`/groups/${party2._id}/invite`, {\n        uuids: [userToInvite._id]\n      }); // Get updated user\n\n      const invitedUser = await userToInvite.get('/user');\n      expect(invitedUser.invitations.parties.length).to.equal(2);\n      expect(invitedUser.invitations.parties[0].id).to.equal(party._id);\n      expect(invitedUser.invitations.parties[1].id).to.equal(party2._id);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"allow inviting a user if party id is not associated with a real party","suites":["Post /groups/:groupId/invite","party invites"],"updatePoint":{"line":557,"column":77,"index":20143},"line":557,"code":"    it('allow inviting a user if party id is not associated with a real party', async () => {\n      const userToInvite = await generateUser({\n        party: {\n          _id: generateUUID()\n        }\n      });\n      await inviter.post(`/groups/${party._id}/invite`, {\n        uuids: [userToInvite._id]\n      });\n      expect((await userToInvite.get('/user')).invitations.parties[0].id).to.equal(party._id);\n    });","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"allows 30 members in a party","suites":["Post /groups/:groupId/invite","party invites"],"updatePoint":{"line":568,"column":36,"index":20516},"line":568,"code":"    it('allows 30 members in a party', async () => {\n      const invitesToGenerate = []; // Generate 29 users to invite (29 + leader = 30 members)\n\n      for (let i = 0; i < PARTY_LIMIT_MEMBERS - 1; i += 1) {\n        invitesToGenerate.push(generateUser());\n      }\n\n      const generatedInvites = await Promise.all(invitesToGenerate); // Invite users\n\n      expect(await inviter.post(`/groups/${party._id}/invite`, {\n        uuids: generatedInvites.map(invite => invite._id)\n      })).to.be.an('array');\n    }).timeout(10000);","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"does not allow 30+ members in a party","suites":["Post /groups/:groupId/invite","party invites"],"updatePoint":{"line":581,"column":45,"index":21052},"line":581,"code":"    it('does not allow 30+ members in a party', async () => {\n      const invitesToGenerate = []; // Generate 30 users to invite (30 + leader = 31 members)\n\n      for (let i = 0; i < PARTY_LIMIT_MEMBERS; i += 1) {\n        invitesToGenerate.push(generateUser());\n      }\n\n      const generatedInvites = await Promise.all(invitesToGenerate); // Invite users\n\n      await expect(inviter.post(`/groups/${party._id}/invite`, {\n        uuids: generatedInvites.map(invite => invite._id)\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('partyExceedsMembersLimit', {\n          maxMembersParty: PARTY_LIMIT_MEMBERS + 1\n        })\n      });\n    }).timeout(10000);","file":"api/v3/integration/groups/POST-groups_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when a non group leader tries to add member","suites":["POST /group/:groupId/add-manager","Guilds"],"updatePoint":{"line":29,"column":68,"index":862},"line":29,"code":"    it('returns an error when a non group leader tries to add member', async () => {\n      await expect(nonLeader.post(`/groups/${groupToUpdate._id}/add-manager`, {\n        managerId: nonLeader._id\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageGroupOnlyLeaderCanUpdate')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_manager.test.js","skipped":false,"dir":"test"},{"name":"returns an error when trying to promote a non member","suites":["POST /group/:groupId/add-manager","Guilds"],"updatePoint":{"line":38,"column":60,"index":1221},"line":38,"code":"    it('returns an error when trying to promote a non member', async () => {\n      await expect(leader.post(`/groups/${groupToUpdate._id}/add-manager`, {\n        managerId: nonMember._id\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('userMustBeMember')\n      });\n    });","file":"api/v3/integration/groups/POST-groups_manager.test.js","skipped":false,"dir":"test"},{"name":"allows a leader to add managers","suites":["POST /group/:groupId/add-manager","Guilds"],"updatePoint":{"line":47,"column":39,"index":1541},"line":47,"code":"    it('allows a leader to add managers', async () => {\n      const updatedGroup = await leader.post(`/groups/${groupToUpdate._id}/add-manager`, {\n        managerId: nonLeader._id\n      });\n      expect(updatedGroup.managers[nonLeader._id]).to.be.true;\n    });","file":"api/v3/integration/groups/POST-groups_manager.test.js","skipped":false,"dir":"test"},{"name":"allows leader of party to add managers","suites":["POST /group/:groupId/add-manager","Party"],"updatePoint":{"line":75,"column":46,"index":2324},"line":75,"code":"    it('allows leader of party to add managers', async () => {\n      const updatedGroup = await partyLeader.post(`/groups/${party._id}/add-manager`, {\n        managerId: partyNonLeader._id\n      });\n      expect(updatedGroup.managers[partyNonLeader._id]).to.be.true;\n    });","file":"api/v3/integration/groups/POST-groups_manager.test.js","skipped":false,"dir":"test"},{"name":"it returns validation error when type is not provided","suites":["POST /group","All Groups"],"updatePoint":{"line":10,"column":61,"index":316},"line":10,"code":"    it('it returns validation error when type is not provided', async () => {\n      await expect(user.post('/groups', {\n        name: 'Test Group Without Type'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'Group validation failed'\n      });\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"it returns validation error when type is not supported","suites":["POST /group","All Groups"],"updatePoint":{"line":19,"column":62,"index":632},"line":19,"code":"    it('it returns validation error when type is not supported', async () => {\n      await expect(user.post('/groups', {\n        name: 'Group with unsupported type',\n        type: 'foo'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'Group validation failed'\n      });\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"sets the group leader to the user who created the group","suites":["POST /group","All Groups"],"updatePoint":{"line":29,"column":63,"index":974},"line":29,"code":"    it('sets the group leader to the user who created the group', async () => {\n      const group = await user.post('/groups', {\n        name: 'Test Public Guild',\n        type: 'guild'\n      });\n      expect(group.leader).to.eql({\n        _id: user._id,\n        profile: {\n          name: user.profile.name\n        }\n      });\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"sets summary to groups name when not supplied","suites":["POST /group","All Groups"],"updatePoint":{"line":41,"column":53,"index":1300},"line":41,"code":"    it('sets summary to groups name when not supplied', async () => {\n      const name = 'Test Group';\n      const group = await user.post('/groups', {\n        name,\n        type: 'guild'\n      });\n      const updatedGroup = await user.get(`/groups/${group._id}`);\n      expect(updatedGroup.summary).to.eql(name);\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"sets summary to groups","suites":["POST /group","All Groups"],"updatePoint":{"line":50,"column":30,"index":1599},"line":50,"code":"    it('sets summary to groups', async () => {\n      const name = 'Test Group';\n      const summary = 'Test Summary';\n      const group = await user.post('/groups', {\n        name,\n        type: 'guild',\n        summary\n      });\n      const updatedGroup = await user.get(`/groups/${group._id}`);\n      expect(updatedGroup.summary).to.eql(summary);\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"returns an error when a user with insufficient funds attempts to create a guild","suites":["POST /group","Guilds"],"updatePoint":{"line":63,"column":87,"index":2047},"line":63,"code":"    it('returns an error when a user with insufficient funds attempts to create a guild', async () => {\n      await user.update({\n        balance: 0\n      });\n      await expect(user.post('/groups', {\n        name: 'Test Public Guild',\n        type: 'guild'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageInsufficientGems')\n      });\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"adds guild to user's list of guilds","suites":["POST /group","Guilds"],"updatePoint":{"line":76,"column":44,"index":2423},"line":76,"code":"    it('adds guild to user\\'s list of guilds', async () => {\n      const guild = await user.post('/groups', {\n        name: 'some guild',\n        type: 'guild',\n        privacy: 'public'\n      });\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.guilds).to.include(guild._id);\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"awards the Joined Guild achievement","suites":["POST /group","Guilds"],"updatePoint":{"line":85,"column":43,"index":2734},"line":85,"code":"    it('awards the Joined Guild achievement', async () => {\n      await user.post('/groups', {\n        name: 'some guild',\n        type: 'guild',\n        privacy: 'public'\n      });\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.achievements.joinedGuild).to.eql(true);\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"creates a group","suites":["POST /group","Guilds","public guild"],"updatePoint":{"line":95,"column":25,"index":3058},"line":95,"code":"      it('creates a group', async () => {\n        const groupName = 'Test Public Guild';\n        const groupType = 'guild';\n        const groupPrivacy = 'public';\n        const publicGuild = await user.post('/groups', {\n          name: groupName,\n          type: groupType,\n          privacy: groupPrivacy\n        });\n        expect(publicGuild._id).to.exist;\n        expect(publicGuild.name).to.equal(groupName);\n        expect(publicGuild.type).to.equal(groupType);\n        expect(publicGuild.memberCount).to.equal(1);\n        expect(publicGuild.privacy).to.equal(groupPrivacy);\n        expect(publicGuild.leader).to.eql({\n          _id: user._id,\n          profile: {\n            name: user.profile.name\n          }\n        });\n      });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"returns an error when a user with no chat privileges attempts to create a public guild","suites":["POST /group","Guilds","public guild"],"updatePoint":{"line":116,"column":96,"index":3870},"line":116,"code":"      it('returns an error when a user with no chat privileges attempts to create a public guild', async () => {\n        await user.update({\n          'flags.chatRevoked': true\n        });\n        await expect(user.post('/groups', {\n          name: 'Test Public Guild',\n          type: 'guild',\n          privacy: 'public'\n        })).to.eventually.be.rejected.and.eql({\n          code: 401,\n          error: 'NotAuthorized',\n          message: t('chatPrivilegesRevoked')\n        });\n      });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"creates a group","suites":["POST /group","Guilds","private guild"],"updatePoint":{"line":135,"column":25,"index":4455},"line":135,"code":"      it('creates a group', async () => {\n        const privateGuild = await user.post('/groups', {\n          name: groupName,\n          type: groupType,\n          privacy: groupPrivacy\n        });\n        expect(privateGuild._id).to.exist;\n        expect(privateGuild.name).to.equal(groupName);\n        expect(privateGuild.type).to.equal(groupType);\n        expect(privateGuild.memberCount).to.equal(1);\n        expect(privateGuild.privacy).to.equal(groupPrivacy);\n        expect(privateGuild.leader).to.eql({\n          _id: user._id,\n          profile: {\n            name: user.profile.name\n          }\n        });\n      });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"creates a private guild when the user has no chat privileges","suites":["POST /group","Guilds","private guild"],"updatePoint":{"line":153,"column":70,"index":5127},"line":153,"code":"      it('creates a private guild when the user has no chat privileges', async () => {\n        await user.update({\n          'flags.chatRevoked': true\n        });\n        const privateGuild = await user.post('/groups', {\n          name: groupName,\n          type: groupType,\n          privacy: groupPrivacy\n        });\n        expect(privateGuild._id).to.exist;\n      });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"deducts gems from user and adds them to guild bank","suites":["POST /group","Guilds","private guild"],"updatePoint":{"line":164,"column":60,"index":5489},"line":164,"code":"      it('deducts gems from user and adds them to guild bank', async () => {\n        const privateGuild = await user.post('/groups', {\n          name: groupName,\n          type: groupType,\n          privacy: groupPrivacy\n        });\n        expect(privateGuild.balance).to.eql(1);\n        const updatedUser = await user.get('/user');\n        expect(updatedUser.balance).to.eql(user.balance - 1);\n      });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"creates a party","suites":["POST /group","Parties"],"updatePoint":{"line":179,"column":23,"index":5968},"line":179,"code":"    it('creates a party', async () => {\n      const party = await user.post('/groups', {\n        name: partyName,\n        type: partyType\n      });\n      expect(party._id).to.exist;\n      expect(party.name).to.equal(partyName);\n      expect(party.type).to.equal(partyType);\n      expect(party.memberCount).to.equal(1);\n      expect(party.leader).to.eql({\n        _id: user._id,\n        profile: {\n          name: user.profile.name\n        }\n      });\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"creates a party when the user has no chat privileges","suites":["POST /group","Parties"],"updatePoint":{"line":195,"column":60,"index":6464},"line":195,"code":"    it('creates a party when the user has no chat privileges', async () => {\n      await user.update({\n        'flags.chatRevoked': true\n      });\n      const party = await user.post('/groups', {\n        name: partyName,\n        type: partyType\n      });\n      expect(party._id).to.exist;\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"does not require gems to create a party","suites":["POST /group","Parties"],"updatePoint":{"line":205,"column":47,"index":6748},"line":205,"code":"    it('does not require gems to create a party', async () => {\n      await user.update({\n        balance: 0\n      });\n      const party = await user.post('/groups', {\n        name: partyName,\n        type: partyType\n      });\n      expect(party._id).to.exist;\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.balance).to.eql(user.balance);\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"sets party id on user object","suites":["POST /group","Parties"],"updatePoint":{"line":217,"column":36,"index":7113},"line":217,"code":"    it('sets party id on user object', async () => {\n      const party = await user.post('/groups', {\n        name: partyName,\n        type: partyType\n      });\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.party._id).to.eql(party._id);\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"does not award Party Up achievement to solo partier","suites":["POST /group","Parties"],"updatePoint":{"line":225,"column":59,"index":7411},"line":225,"code":"    it('does not award Party Up achievement to solo partier', async () => {\n      await user.post('/groups', {\n        name: partyName,\n        type: partyType\n      });\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.achievements.partyUp).to.not.eql(true);\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"prevents user in a party from creating another party","suites":["POST /group","Parties"],"updatePoint":{"line":233,"column":60,"index":7706},"line":233,"code":"    it('prevents user in a party from creating another party', async () => {\n      await user.post('/groups', {\n        name: partyName,\n        type: partyType\n      });\n      await expect(user.post('/groups')).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageGroupAlreadyInParty')\n      });\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"prevents creating a public party","suites":["POST /group","Parties"],"updatePoint":{"line":244,"column":40,"index":8052},"line":244,"code":"    it('prevents creating a public party', async () => {\n      await expect(user.post('/groups', {\n        name: partyName,\n        type: partyType,\n        privacy: 'public'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('partyMustbePrivate')\n      });\n    });","file":"api/v3/integration/groups/POST-groups.test.js","skipped":false,"dir":"test"},{"name":"returns an error when a user that is not an admin or group leader tries to update","suites":["PUT /group"],"updatePoint":{"line":30,"column":87,"index":889},"line":30,"code":"  it('returns an error when a user that is not an admin or group leader tries to update', async () => {\n    await expect(nonLeader.put(`/groups/${groupToUpdate._id}`, {\n      name: groupUpdatedName\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageGroupOnlyLeaderCanUpdate')\n    });\n  });","file":"api/v3/integration/groups/PUT-groups.test.js","skipped":false,"dir":"test"},{"name":"updates a group","suites":["PUT /group"],"updatePoint":{"line":39,"column":21,"index":1178},"line":39,"code":"  it('updates a group', async () => {\n    const updatedGroup = await leader.put(`/groups/${groupToUpdate._id}`, {\n      name: groupUpdatedName\n    });\n    expect(updatedGroup.leader._id).to.eql(leader._id);\n    expect(updatedGroup.leader.profile.name).to.eql(leader.profile.name);\n    expect(updatedGroup.name).to.equal(groupUpdatedName);\n  });","file":"api/v3/integration/groups/PUT-groups.test.js","skipped":false,"dir":"test"},{"name":"updates a group categories","suites":["PUT /group"],"updatePoint":{"line":47,"column":32,"index":1534},"line":47,"code":"  it('updates a group categories', async () => {\n    const categories = [{\n      slug: 'newCat',\n      name: 'New Category'\n    }];\n    const updatedGroup = await leader.put(`/groups/${groupToUpdate._id}`, {\n      categories\n    });\n    expect(updatedGroup.categories[0].slug).to.eql(categories[0].slug);\n    expect(updatedGroup.categories[0].name).to.eql(categories[0].name);\n  });","file":"api/v3/integration/groups/PUT-groups.test.js","skipped":false,"dir":"test"},{"name":"allows an admin to update a guild","suites":["PUT /group"],"updatePoint":{"line":58,"column":39,"index":1924},"line":58,"code":"  it('allows an admin to update a guild', async () => {\n    const updatedGroup = await adminUser.put(`/groups/${groupToUpdate._id}`, {\n      name: groupUpdatedName\n    });\n    expect(updatedGroup.leader._id).to.eql(leader._id);\n    expect(updatedGroup.leader.profile.name).to.eql(leader.profile.name);\n    expect(updatedGroup.name).to.equal(groupUpdatedName);\n  });","file":"api/v3/integration/groups/PUT-groups.test.js","skipped":false,"dir":"test"},{"name":"allows a leader to change leaders","suites":["PUT /group"],"updatePoint":{"line":66,"column":39,"index":2290},"line":66,"code":"  it('allows a leader to change leaders', async () => {\n    const updatedGroup = await leader.put(`/groups/${groupToUpdate._id}`, {\n      name: groupUpdatedName,\n      leader: nonLeader._id\n    });\n    expect(updatedGroup.leader._id).to.eql(nonLeader._id);\n    expect(updatedGroup.leader.profile.name).to.eql(nonLeader.profile.name);\n    expect(updatedGroup.name).to.equal(groupUpdatedName);\n  });","file":"api/v3/integration/groups/PUT-groups.test.js","skipped":false,"dir":"test"},{"name":"allows for an admin to update the bannedWordsAllow property for an existing guild","suites":["PUT /group"],"updatePoint":{"line":75,"column":87,"index":2736},"line":75,"code":"  it('allows for an admin to update the bannedWordsAllow property for an existing guild', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        name: 'public guild',\n        type: 'guild',\n        privacy: 'public'\n      }\n    });\n    const updateGroupDetails = {\n      id: group._id,\n      name: 'public guild',\n      type: 'guild',\n      privacy: 'public',\n      bannedWordsAllowed: true\n    }; // Make guild leader into admin\n\n    await groupLeader.post('/debug/make-admin');\n    await groupLeader.sync(); // Update the bannedWordsAllowed property for the group\n\n    const response = await groupLeader.put(`/groups/${group._id}`, updateGroupDetails);\n    expect(groupLeader.contributor.admin).to.eql(true);\n    expect(response.bannedWordsAllowed).to.eql(true);\n  });","file":"api/v3/integration/groups/PUT-groups.test.js","skipped":false,"dir":"test"},{"name":"does not allow for a non-admin to update the bannedWordsAllow property for an existing guild","suites":["PUT /group"],"updatePoint":{"line":101,"column":98,"index":3589},"line":101,"code":"  it('does not allow for a non-admin to update the bannedWordsAllow property for an existing guild', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        name: 'public guild',\n        type: 'guild',\n        privacy: 'public'\n      }\n    });\n    const updateGroupDetails = {\n      id: group._id,\n      name: 'public guild',\n      type: 'guild',\n      privacy: 'public',\n      bannedWordsAllowed: true\n    }; // Update the bannedWordsAllowed property for the group\n\n    const response = await groupLeader.put(`/groups/${group._id}`, updateGroupDetails);\n    expect(groupLeader.contributor.admin).to.eql(undefined);\n    expect(response.bannedWordsAllowed).to.eql(undefined);\n  });","file":"api/v3/integration/groups/PUT-groups.test.js","skipped":false,"dir":"test"},{"name":"requires the caller to be an admin","suites":["GET /heroes/:heroId"],"updatePoint":{"line":12,"column":40,"index":341},"line":12,"code":"  it('requires the caller to be an admin', async () => {\n    const nonAdmin = await generateUser();\n    await expect(nonAdmin.get(`/hall/heroes/${user._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('noAdminAccess')\n    });\n  });","file":"api/v3/integration/hall/GET-hall_heroes_heroId.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.heroId","suites":["GET /heroes/:heroId"],"updatePoint":{"line":20,"column":33,"index":624},"line":20,"code":"  it('validates req.params.heroId', async () => {\n    await expect(user.get('/hall/heroes/invalidUUID')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: 'invalidUUID'\n      })\n    });\n  });","file":"api/v3/integration/hall/GET-hall_heroes_heroId.test.js","skipped":false,"dir":"test"},{"name":"handles non-existing heroes","suites":["GET /heroes/:heroId"],"updatePoint":{"line":29,"column":33,"index":901},"line":29,"code":"  it('handles non-existing heroes', async () => {\n    const dummyId = generateUUID();\n    await expect(user.get(`/hall/heroes/${dummyId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: dummyId\n      })\n    });\n  });","file":"api/v3/integration/hall/GET-hall_heroes_heroId.test.js","skipped":false,"dir":"test"},{"name":"returns only necessary hero data given user id","suites":["GET /heroes/:heroId"],"updatePoint":{"line":39,"column":52,"index":1226},"line":39,"code":"  it('returns only necessary hero data given user id', async () => {\n    const hero = await generateUser({\n      contributor: {\n        tier: 23\n      },\n      secret: {\n        text: 'Super Hero'\n      }\n    });\n    const heroRes = await user.get(`/hall/heroes/${hero._id}`);\n    expect(heroRes).to.have.all.keys([// works as: object has all and only these keys\n    '_id', 'id', 'balance', 'profile', 'purchased', 'contributor', 'auth', 'items', 'secret']);\n    expect(heroRes.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(heroRes.profile).to.have.all.keys(['name']);\n    expect(heroRes.secret.text).to.be.eq('Super Hero');\n  });","file":"api/v3/integration/hall/GET-hall_heroes_heroId.test.js","skipped":false,"dir":"test"},{"name":"returns only necessary hero data given username","suites":["GET /heroes/:heroId"],"updatePoint":{"line":55,"column":53,"index":1882},"line":55,"code":"  it('returns only necessary hero data given username', async () => {\n    const hero = await generateUser({\n      contributor: {\n        tier: 23\n      }\n    });\n    const heroRes = await user.get(`/hall/heroes/${hero.auth.local.username}`);\n    expect(heroRes).to.have.all.keys([// works as: object has all and only these keys\n    '_id', 'id', 'balance', 'profile', 'purchased', 'contributor', 'auth', 'items', 'secret']);\n    expect(heroRes.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(heroRes.profile).to.have.all.keys(['name']);\n  });","file":"api/v3/integration/hall/GET-hall_heroes_heroId.test.js","skipped":false,"dir":"test"},{"name":"returns correct hero using search with difference case","suites":["GET /heroes/:heroId"],"updatePoint":{"line":67,"column":60,"index":2453},"line":67,"code":"  it('returns correct hero using search with difference case', async () => {\n    await generateUser({}, {\n      username: 'TestUpperCaseName123'\n    });\n    const heroRes = await user.get('/hall/heroes/TestuPPerCasEName123');\n    expect(heroRes.auth.local.username).to.equal('TestUpperCaseName123');\n  });","file":"api/v3/integration/hall/GET-hall_heroes_heroId.test.js","skipped":false,"dir":"test"},{"name":"returns all heroes sorted by -contributor.level and with correct fields","suites":["GET /hall/heroes"],"updatePoint":{"line":3,"column":77,"index":203},"line":3,"code":"  it('returns all heroes sorted by -contributor.level and with correct fields', async () => {\n    await resetHabiticaDB();\n    const nonHero = await generateUser();\n    const hero1 = await generateUser({\n      contributor: {\n        level: 1\n      },\n      secret: {\n        text: 'Super-Hero'\n      }\n    });\n    const hero2 = await generateUser({\n      contributor: {\n        level: 3\n      }\n    });\n    const heroes = await nonHero.get('/hall/heroes');\n    expect(heroes.length).to.equal(2);\n    expect(heroes[0]._id).to.equal(hero2._id);\n    expect(heroes[1]._id).to.equal(hero1._id);\n    expect(heroes[0]).to.have.all.keys(['_id', 'contributor', 'backer', 'profile']); // should not contain the secret\n\n    expect(heroes[1]).to.have.all.keys(['_id', 'contributor', 'backer', 'profile']);\n    expect(heroes[0].profile).to.have.all.keys(['name']);\n    expect(heroes[1].profile).to.have.all.keys(['name']);\n    expect(heroes[0].profile.name).to.equal(hero2.profile.name);\n    expect(heroes[1].profile.name).to.equal(hero1.profile.name);\n    expect(heroes[1].secret).to.equal(undefined);\n  });","file":"api/v3/integration/hall/GET-hall_heroes.test.js","skipped":false,"dir":"test"},{"name":"fails if req.query.page is not numeric","suites":["GET /hall/patrons"],"updatePoint":{"line":9,"column":44,"index":326},"line":9,"code":"  it('fails if req.query.page is not numeric', async () => {\n    await expect(user.get('/hall/patrons?page=notNumber')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/hall/GET-hall_patrons.test.js","skipped":false,"dir":"test"},{"name":"returns all patrons sorted by -backer.tier and with correct fields","suites":["GET /hall/patrons"],"updatePoint":{"line":16,"column":72,"index":605},"line":16,"code":"  it('returns all patrons sorted by -backer.tier and with correct fields', async () => {\n    const patron1 = await generateUser({\n      backer: {\n        tier: 1\n      }\n    });\n    const patron2 = await generateUser({\n      backer: {\n        tier: 3\n      }\n    });\n    const patrons = await user.get('/hall/patrons');\n    expect(patrons.length).to.equal(2);\n    expect(patrons[0]._id).to.equal(patron2._id);\n    expect(patrons[1]._id).to.equal(patron1._id);\n    expect(patrons[0]).to.have.all.keys(['_id', 'contributor', 'backer', 'profile']);\n    expect(patrons[1]).to.have.all.keys(['_id', 'contributor', 'backer', 'profile']);\n    expect(patrons[0].profile).to.have.all.keys(['name']);\n    expect(patrons[1].profile).to.have.all.keys(['name']);\n    expect(patrons[0].profile.name).to.equal(patron2.profile.name);\n    expect(patrons[1].profile.name).to.equal(patron1.profile.name);\n  });","file":"api/v3/integration/hall/GET-hall_patrons.test.js","skipped":false,"dir":"test"},{"name":"returns only first 50 patrons per request, more if req.query.page is passed","suites":["GET /hall/patrons"],"updatePoint":{"line":38,"column":81,"index":1506},"line":38,"code":"  it('returns only first 50 patrons per request, more if req.query.page is passed', async () => {\n    await Promise.all(times(53, n => generateUser({\n      backer: {\n        tier: n\n      }\n    })));\n    const patrons = await user.get('/hall/patrons');\n    expect(patrons.length).to.equal(50);\n    const morePatrons = await user.get('/hall/patrons?page=1');\n    expect(morePatrons.length).to.equal(2);\n    expect(morePatrons[0].backer.tier).to.equal(2);\n    expect(morePatrons[1].backer.tier).to.equal(1);\n  }).timeout(10000);","file":"api/v3/integration/hall/GET-hall_patrons.test.js","skipped":false,"dir":"test"},{"name":"requires the caller to be an admin","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":13,"column":40,"index":457},"line":13,"code":"  it('requires the caller to be an admin', async () => {\n    const nonAdmin = await generateUser();\n    await expect(nonAdmin.put(`/hall/heroes/${user._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('noAdminAccess')\n    });\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.heroId","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":21,"column":33,"index":740},"line":21,"code":"  it('validates req.params.heroId', async () => {\n    await expect(user.put('/hall/heroes/invalidUUID')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"handles non-existing heroes","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":28,"column":33,"index":976},"line":28,"code":"  it('handles non-existing heroes', async () => {\n    const dummyId = generateUUID();\n    await expect(user.put(`/hall/heroes/${dummyId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: dummyId\n      })\n    });\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"change contributor level, balance, ads","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":38,"column":44,"index":1293},"line":38,"code":"  it('change contributor level, balance, ads', async () => {\n    const hero = await generateUser();\n    const prevBlockState = hero.auth.blocked;\n    const prevSleepState = hero.preferences.sleep;\n    const heroRes = await user.put(`/hall/heroes/${hero._id}`, {\n      balance: 3,\n      contributor: {\n        level: 1\n      },\n      purchased: {\n        ads: true\n      }\n    }); // test response\n    // works as: object has all and only these keys\n\n    expect(heroRes).to.have.all.keys(heroFields);\n    expect(heroRes.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(heroRes.profile).to.have.all.keys(['name']); // test response values\n\n    expect(heroRes.balance).to.equal(3 + 0.75); // 3+0.75 for first contrib level\n\n    expect(heroRes.contributor.level).to.equal(1);\n    expect(heroRes.purchased.ads).to.equal(true); // test hero values\n\n    await hero.sync();\n    expect(hero.balance).to.equal(3 + 0.75); // 3+0.75 for first contrib level\n\n    expect(hero.contributor.level).to.equal(1);\n    expect(hero.purchased.ads).to.equal(true);\n    expect(hero.auth.blocked).to.equal(prevBlockState);\n    expect(hero.preferences.sleep).to.equal(prevSleepState);\n    expect(hero.notifications.length).to.equal(1);\n    expect(hero.notifications[0].type).to.equal('NEW_CONTRIBUTOR_LEVEL');\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"block a user","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":72,"column":18,"index":2577},"line":72,"code":"  it('block a user', async () => {\n    const hero = await generateUser();\n    const heroRes = await user.put(`/hall/heroes/${hero._id}`, {\n      auth: {\n        blocked: true\n      },\n      preferences: {\n        sleep: true\n      }\n    }); // test response values\n\n    expect(heroRes.auth.blocked).to.equal(true); // test hero values\n\n    await hero.sync();\n    expect(hero.auth.blocked).to.equal(true);\n    expect(hero.preferences.sleep).to.equal(true);\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"unblock a user","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":89,"column":20,"index":3041},"line":89,"code":"  it('unblock a user', async () => {\n    const hero = await generateUser();\n    const prevSleepState = hero.preferences.sleep;\n    const heroRes = await user.put(`/hall/heroes/${hero._id}`, {\n      auth: {\n        blocked: false\n      }\n    }); // test response values\n\n    expect(heroRes.auth.blocked).to.equal(false); // test hero values\n\n    await hero.sync();\n    expect(hero.auth.blocked).to.equal(false);\n    expect(hero.preferences.sleep).to.equal(prevSleepState);\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"updates chatRevoked flag","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":104,"column":30,"index":3529},"line":104,"code":"  it('updates chatRevoked flag', async () => {\n    const hero = await generateUser();\n    await user.put(`/hall/heroes/${hero._id}`, {\n      flags: {\n        chatRevoked: true\n      }\n    });\n    await hero.sync();\n    expect(hero.flags.chatRevoked).to.eql(true);\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"updates chatShadowMuted flag","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":114,"column":34,"index":3803},"line":114,"code":"  it('updates chatShadowMuted flag', async () => {\n    const hero = await generateUser();\n    await user.put(`/hall/heroes/${hero._id}`, {\n      flags: {\n        chatShadowMuted: true\n      }\n    });\n    await hero.sync();\n    expect(hero.flags.chatShadowMuted).to.eql(true);\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"updates contributor level","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":124,"column":31,"index":4082},"line":124,"code":"  it('updates contributor level', async () => {\n    const hero = await generateUser({\n      contributor: {\n        level: 5\n      }\n    });\n    const heroRes = await user.put(`/hall/heroes/${hero._id}`, {\n      contributor: {\n        level: 6\n      }\n    }); // test response\n    // works as: object has all and only these keys\n\n    expect(heroRes).to.have.all.keys(heroFields);\n    expect(heroRes.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(heroRes.profile).to.have.all.keys(['name']); // test response values\n\n    expect(heroRes.balance).to.equal(1); // 0+1 for sixth contrib level\n\n    expect(heroRes.contributor.level).to.equal(6);\n    expect(heroRes.items.pets['Dragon-Hydra']).to.equal(5); // test hero values\n\n    await hero.sync();\n    expect(hero.balance).to.equal(1); // 0+1 for sixth contrib level\n\n    expect(hero.contributor.level).to.equal(6);\n    expect(hero.items.pets['Dragon-Hydra']).to.equal(5);\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"updates contributor data","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":152,"column":30,"index":5028},"line":152,"code":"  it('updates contributor data', async () => {\n    const hero = await generateUser({\n      contributor: {\n        level: 5\n      }\n    });\n    const heroRes = await user.put(`/hall/heroes/${hero._id}`, {\n      contributor: {\n        text: 'Astronaut'\n      }\n    }); // test response\n    // works as: object has all and only these keys\n\n    expect(heroRes).to.have.all.keys(heroFields);\n    expect(heroRes.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(heroRes.profile).to.have.all.keys(['name']); // test response values\n\n    expect(heroRes.contributor.level).to.equal(5); // doesn't modify previous values\n\n    expect(heroRes.contributor.text).to.equal('Astronaut'); // test hero values\n\n    await hero.sync();\n    expect(hero.contributor.level).to.equal(5); // doesn't modify previous values\n\n    expect(hero.contributor.text).to.equal('Astronaut');\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"updates contributor secret","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":178,"column":32,"index":5912},"line":178,"code":"  it('updates contributor secret', async () => {\n    const secretText = 'my super hero';\n    const hero = await generateUser({\n      contributor: {\n        level: 5\n      },\n      secret: {\n        text: 'supr hro typo'\n      }\n    });\n    const heroRes = await user.put(`/hall/heroes/${hero._id}`, {\n      contributor: {\n        text: 'Astronaut'\n      },\n      secret: {\n        text: secretText\n      }\n    }); // test response\n    // works as: object has all and only these keys\n\n    expect(heroRes).to.have.all.keys(heroFields);\n    expect(heroRes.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(heroRes.profile).to.have.all.keys(['name']); // test response values\n\n    expect(heroRes.contributor.level).to.equal(5); // doesn't modify previous values\n\n    expect(heroRes.contributor.text).to.equal('Astronaut');\n    expect(heroRes.secret.text).to.equal(secretText); // test hero values\n\n    await hero.sync();\n    expect(hero.contributor.level).to.equal(5); // doesn't modify previous values\n\n    expect(hero.contributor.text).to.equal('Astronaut');\n    expect(hero.secret.text).to.equal(secretText);\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"updates items","suites":["PUT /heroes/:heroId"],"updatePoint":{"line":213,"column":19,"index":7033},"line":213,"code":"  it('updates items', async () => {\n    const hero = await generateUser();\n    const heroRes = await user.put(`/hall/heroes/${hero._id}`, {\n      itemPath: 'items.special.snowball',\n      itemVal: 5\n    }); // test response\n    // works as: object has all and only these keys\n\n    expect(heroRes).to.have.all.keys(heroFields);\n    expect(heroRes.auth.local).not.to.have.keys(['salt', 'hashed_password']);\n    expect(heroRes.profile).to.have.all.keys(['name']); // test response values\n\n    expect(heroRes.items.special.snowball).to.equal(5); // test hero values\n\n    await hero.sync();\n    expect(hero.items.special.snowball).to.equal(5);\n  });","file":"api/v3/integration/hall/PUT-hall_heores_heroId.test.js","skipped":false,"dir":"test"},{"name":"returns the user inbox messages as an array of ordered messages (from most to least recent)","suites":["GET /inbox/messages"],"updatePoint":{"line":25,"column":97,"index":833},"line":25,"code":"  it('returns the user inbox messages as an array of ordered messages (from most to least recent)', async () => {\n    const messages = await user.get('/inbox/messages');\n    expect(messages.length).to.equal(4); // message to yourself\n\n    expect(messages[0].text).to.equal('fourth');\n    expect(messages[0].sent).to.equal(false);\n    expect(messages[0].uuid).to.equal(user._id);\n    expect(messages[1].text).to.equal('third');\n    expect(messages[2].text).to.equal('second');\n    expect(messages[3].text).to.equal('first');\n  });","file":"api/v3/integration/inbox/GET-inbox_messages.test.js","skipped":false,"dir":"test"},{"name":"returns four messages when using page-query ","suites":["GET /inbox/messages"],"updatePoint":{"line":36,"column":50,"index":1316},"line":36,"code":"  it('returns four messages when using page-query ', async () => {\n    const promises = [];\n\n    for (let i = 0; i < 10; i += 1) {\n      promises.push(user.post('/members/send-private-message', {\n        toUserId: user.id,\n        message: 'fourth'\n      }));\n    }\n\n    await Promise.all(promises);\n    const messages = await user.get('/inbox/messages?page=1');\n    expect(messages.length).to.equal(4);\n  });","file":"api/v3/integration/inbox/GET-inbox_messages.test.js","skipped":false,"dir":"test"},{"name":"returns only the messages of one conversation","suites":["GET /inbox/messages"],"updatePoint":{"line":50,"column":51,"index":1727},"line":50,"code":"  it('returns only the messages of one conversation', async () => {\n    const messages = await user.get(`/inbox/messages?conversation=${otherUser.id}`);\n    expect(messages.length).to.equal(3);\n  });","file":"api/v3/integration/inbox/GET-inbox_messages.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.memberId","suites":["GET /members/:memberId/achievements"],"updatePoint":{"line":8,"column":35,"index":296},"line":8,"code":"  it('validates req.params.memberId', async () => {\n    await expect(user.get('/members/invalidUUID/achievements')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/members/GET-achievements.test.js","skipped":false,"dir":"test"},{"name":"returns achievements based on given user","suites":["GET /members/:memberId/achievements"],"updatePoint":{"line":15,"column":46,"index":554},"line":15,"code":"  it('returns achievements based on given user', async () => {\n    const member = await generateUser({\n      contributor: {\n        level: 1\n      },\n      backer: {\n        tier: 3\n      }\n    });\n    const achievementsRes = await user.get(`/members/${member._id}/achievements`);\n    expect(achievementsRes.special.achievements.contributor.earned).to.equal(true);\n    expect(achievementsRes.special.achievements.contributor.value).to.equal(1);\n    expect(achievementsRes.special.achievements.kickstarter.earned).to.equal(true);\n    expect(achievementsRes.special.achievements.kickstarter.value).to.equal(3);\n  });","file":"api/v3/integration/members/GET-achievements.test.js","skipped":false,"dir":"test"},{"name":"handles non-existing members","suites":["GET /members/:memberId/achievements"],"updatePoint":{"line":30,"column":34,"index":1157},"line":30,"code":"  it('handles non-existing members', async () => {\n    const dummyId = generateUUID();\n    await expect(user.get(`/members/${dummyId}/achievements`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: dummyId\n      })\n    });\n  });","file":"api/v3/integration/members/GET-achievements.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.memberId","suites":["GET /members/:memberId"],"updatePoint":{"line":9,"column":35,"index":335},"line":9,"code":"  it('validates req.params.memberId', async () => {\n    await expect(user.get('/members/invalidUUID')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/members/GET-members_id.test.js","skipped":false,"dir":"test"},{"name":"returns a member public data only","suites":["GET /members/:memberId"],"updatePoint":{"line":16,"column":39,"index":573},"line":16,"code":"  it('returns a member public data only', async () => {\n    // make sure user has all the fields that can be returned by the getMember call\n    const member = await generateUser({\n      contributor: {\n        level: 1\n      },\n      backer: {\n        tier: 3\n      },\n      preferences: {\n        costume: false,\n        background: 'volcano'\n      },\n      secret: {\n        text: 'Clark Kent'\n      }\n    });\n    const memberRes = await user.get(`/members/${member._id}`);\n    expect(memberRes).to.have.all.keys([// works as: object has all and only these keys\n    '_id', 'id', 'preferences', 'profile', 'stats', 'achievements', 'party', 'backer', 'contributor', 'auth', 'items', 'inbox', 'loginIncentives', 'flags']);\n    expect(Object.keys(memberRes.auth)).to.eql(['local', 'timestamps']);\n    expect(Object.keys(memberRes.preferences).sort()).to.eql(['size', 'hair', 'skin', 'shirt', 'chair', 'costume', 'sleep', 'background', 'tasks', 'disableClasses'].sort());\n    expect(memberRes.stats.maxMP).to.exist;\n    expect(memberRes.stats.maxHealth).to.equal(common.maxHealth);\n    expect(memberRes.stats.toNextLevel).to.equal(common.tnl(memberRes.stats.lvl));\n    expect(memberRes.inbox.optOut).to.exist;\n    expect(memberRes.inbox.messages).to.not.exist;\n    expect(memberRes.secret).to.not.exist;\n  });","file":"api/v3/integration/members/GET-members_id.test.js","skipped":false,"dir":"test"},{"name":"does not return secret for the own account","suites":["GET /members/:memberId"],"updatePoint":{"line":45,"column":48,"index":1888},"line":45,"code":"  it('does not return secret for the own account', async () => {\n    // make sure user has all the fields that can be returned by the getMember call\n    const member = await generateUser({\n      contributor: {\n        level: 1\n      },\n      backer: {\n        tier: 3\n      },\n      preferences: {\n        costume: false,\n        background: 'volcano'\n      },\n      secret: {\n        text: 'Clark Kent'\n      }\n    });\n    const memberRes = await member.get(`/members/${member._id}`);\n    expect(memberRes).to.have.keys([// works as: object has all and only these keys\n    '_id', 'id', 'preferences', 'profile', 'stats', 'achievements', 'party', 'backer', 'contributor', 'auth', 'items', 'inbox', 'loginIncentives', 'flags']);\n    expect(memberRes.secret).to.not.exist;\n  });","file":"api/v3/integration/members/GET-members_id.test.js","skipped":false,"dir":"test"},{"name":"handles non-existing members","suites":["GET /members/:memberId"],"updatePoint":{"line":67,"column":34,"index":2651},"line":67,"code":"  it('handles non-existing members', async () => {\n    const dummyId = generateUUID();\n    await expect(user.get(`/members/${dummyId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: dummyId\n      })\n    });\n  });","file":"api/v3/integration/members/GET-members_id.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.memberId","suites":["GET /members/:toUserId/objections/:interaction"],"updatePoint":{"line":8,"column":35,"index":307},"line":8,"code":"  it('validates req.params.memberId', async () => {\n    await expect(user.get('/members/invalidUUID/objections/send-private-message')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/members/GET-objections_interaction.test.js","skipped":false,"dir":"test"},{"name":"handles non-existing members","suites":["GET /members/:toUserId/objections/:interaction"],"updatePoint":{"line":15,"column":34,"index":572},"line":15,"code":"  it('handles non-existing members', async () => {\n    const dummyId = generateUUID();\n    await expect(user.get(`/members/${dummyId}/objections/send-private-message`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: dummyId\n      })\n    });\n  });","file":"api/v3/integration/members/GET-objections_interaction.test.js","skipped":false,"dir":"test"},{"name":"handles non-existing interactions","suites":["GET /members/:toUserId/objections/:interaction"],"updatePoint":{"line":25,"column":39,"index":912},"line":25,"code":"  it('handles non-existing interactions', async () => {\n    const receiver = await generateUser();\n    await expect(user.get(`/members/${receiver._id}/objections/hug-a-whole-forest-of-trees`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/members/GET-objections_interaction.test.js","skipped":false,"dir":"test"},{"name":"returns an empty array if there are no objections","suites":["GET /members/:toUserId/objections/:interaction"],"updatePoint":{"line":33,"column":55,"index":1252},"line":33,"code":"  it('returns an empty array if there are no objections', async () => {\n    const receiver = await generateUser();\n    await expect(user.get(`/members/${receiver._id}/objections/send-private-message`)).to.eventually.be.fulfilled.and.eql([]);\n  });","file":"api/v3/integration/members/GET-objections_interaction.test.js","skipped":false,"dir":"test"},{"name":"returns an array of objections if any exist","suites":["GET /members/:toUserId/objections/:interaction"],"updatePoint":{"line":37,"column":49,"index":1494},"line":37,"code":"  it('returns an array of objections if any exist', async () => {\n    const receiver = await generateUser({\n      'inbox.blocks': [user._id]\n    });\n    await expect(user.get(`/members/${receiver._id}/objections/send-private-message`)).to.eventually.be.fulfilled.and.eql([t('notAuthorizedToSendMessageToThisUser')]);\n  });","file":"api/v3/integration/members/GET-objections_interaction.test.js","skipped":false,"dir":"test"},{"name":"returns error when message is not provided","suites":["POST /members/send-private-message"],"updatePoint":{"line":10,"column":48,"index":441},"line":10,"code":"  it('returns error when message is not provided', async () => {\n    await expect(userToSendMessage.post('/members/send-private-message')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"returns error when toUserId is not provided","suites":["POST /members/send-private-message"],"updatePoint":{"line":17,"column":49,"index":720},"line":17,"code":"  it('returns error when toUserId is not provided', async () => {\n    await expect(userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"returns error when to user is not found","suites":["POST /members/send-private-message"],"updatePoint":{"line":26,"column":45,"index":1033},"line":26,"code":"  it('returns error when to user is not found', async () => {\n    await expect(userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: generateUUID()\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userNotFound')\n    });\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"returns error when to user has blocked the sender","suites":["POST /members/send-private-message"],"updatePoint":{"line":36,"column":55,"index":1374},"line":36,"code":"  it('returns error when to user has blocked the sender', async () => {\n    const receiver = await generateUser({\n      'inbox.blocks': [userToSendMessage._id]\n    });\n    await expect(userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notAuthorizedToSendMessageToThisUser')\n    });\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"returns error when sender has blocked to user","suites":["POST /members/send-private-message"],"updatePoint":{"line":49,"column":51,"index":1834},"line":49,"code":"  it('returns error when sender has blocked to user', async () => {\n    const receiver = await generateUser();\n    const sender = await generateUser({\n      'inbox.blocks': [receiver._id]\n    });\n    await expect(sender.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('blockedToSendToThisUser')\n    });\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"returns error when to user has opted out of messaging","suites":["POST /members/send-private-message"],"updatePoint":{"line":63,"column":59,"index":2310},"line":63,"code":"  it('returns error when to user has opted out of messaging', async () => {\n    const receiver = await generateUser({\n      'inbox.optOut': true\n    });\n    await expect(userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notAuthorizedToSendMessageToThisUser')\n    });\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"returns an error when chat privileges are revoked","suites":["POST /members/send-private-message"],"updatePoint":{"line":76,"column":55,"index":2755},"line":76,"code":"  it('returns an error when chat privileges are revoked', async () => {\n    const userWithChatRevoked = await generateUser({\n      'flags.chatRevoked': true\n    });\n    const receiver = await generateUser();\n    await expect(userWithChatRevoked.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('chatPrivilegesRevoked')\n    });\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"sends a private message to a user","suites":["POST /members/send-private-message"],"updatePoint":{"line":90,"column":39,"index":3230},"line":90,"code":"  it('sends a private message to a user', async () => {\n    const receiver = await generateUser(); // const initialNotifications = receiver.notifications.length;\n\n    const response = await userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    });\n    const updatedReceiver = await receiver.get('/user');\n    const updatedSender = await userToSendMessage.get('/user');\n\n    const sendersMessageInReceiversInbox = _.find(updatedReceiver.inbox.messages, message => message.uuid === userToSendMessage._id && message.text === messageToSend && message.unformattedText === unformattedMessage);\n\n    const sendersMessageInSendersInbox = _.find(updatedSender.inbox.messages, message => message.uuid === receiver._id && message.text === messageToSend);\n\n    expect(response.message.text).to.deep.equal(sendersMessageInSendersInbox.text);\n    expect(response.message.uuid).to.deep.equal(sendersMessageInSendersInbox.uuid); // @TODO waiting for mobile support\n    // expect(updatedReceiver.notifications.length).to.equal(initialNotifications + 1);\n    // const notification = updatedReceiver.notifications[updatedReceiver.notifications.length - 1];\n    // expect(notification.type).to.equal('NEW_INBOX_MESSAGE');\n    // expect(notification.data.messageId).to.equal(sendersMessageInReceiversInbox.id);\n    // expect(notification.data.excerpt).to.equal(messageToSend);\n    // expect(notification.data.sender.id).to.equal(updatedSender._id);\n    // expect(notification.data.sender.name).to.equal(updatedSender.profile.name);\n\n    expect(sendersMessageInReceiversInbox).to.exist;\n    expect(sendersMessageInSendersInbox).to.exist;\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"sends a private message with mentions to a user","suites":["POST /members/send-private-message"],"updatePoint":{"line":117,"column":53,"index":4933},"line":117,"code":"  it('sends a private message with mentions to a user', async () => {\n    const receiver = await generateUser();\n    const response = await userToSendMessage.post('/members/send-private-message', {\n      message: `hi @${receiver.auth.local.username}`,\n      toUserId: receiver._id\n    });\n    expect(response.message.text).to.include(`[@${receiver.auth.local.username}](/profile/${receiver._id})`);\n  }); // @TODO waiting for mobile support","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"creates a notification with an excerpt if the message is too long","suites":["POST /members/send-private-message"],"updatePoint":{"line":126,"column":72,"index":5394},"line":126,"code":"  xit('creates a notification with an excerpt if the message is too long', async () => {\n    const receiver = await generateUser();\n    const longerMessageToSend = 'A very long message, that for sure exceeds the limit of 100 chars for the excerpt that we set to 100 chars';\n    const messageExcerpt = `${longerMessageToSend.substring(0, 100)}...`;\n    await userToSendMessage.post('/members/send-private-message', {\n      message: longerMessageToSend,\n      toUserId: receiver._id\n    });\n    const updatedReceiver = await receiver.get('/user');\n\n    const sendersMessageInReceiversInbox = _.find(updatedReceiver.inbox.messages, message => message.uuid === userToSendMessage._id && message.text === longerMessageToSend);\n\n    const notification = updatedReceiver.notifications[updatedReceiver.notifications.length - 1];\n    expect(notification.type).to.equal('NEW_INBOX_MESSAGE');\n    expect(notification.data.messageId).to.equal(sendersMessageInReceiversInbox.id);\n    expect(notification.data.excerpt).to.equal(messageExcerpt);\n  });","skipped":true,"file":"api/v3/integration/members/POST-send_private_message.test.js","dir":"test"},{"name":"allows admin to send when sender has blocked the admin","suites":["POST /members/send-private-message"],"updatePoint":{"line":143,"column":60,"index":6418},"line":143,"code":"  it('allows admin to send when sender has blocked the admin', async () => {\n    userToSendMessage = await generateUser({\n      'contributor.admin': 1\n    });\n    const receiver = await generateUser({\n      'inbox.blocks': [userToSendMessage._id]\n    });\n    await userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    });\n    const updatedReceiver = await receiver.get('/user');\n    const updatedSender = await userToSendMessage.get('/user');\n\n    const sendersMessageInReceiversInbox = _.find(updatedReceiver.inbox.messages, message => message.uuid === userToSendMessage._id && message.text === messageToSend);\n\n    const sendersMessageInSendersInbox = _.find(updatedSender.inbox.messages, message => message.uuid === receiver._id && message.text === messageToSend);\n\n    expect(sendersMessageInReceiversInbox).to.exist;\n    expect(sendersMessageInSendersInbox).to.exist;\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"allows admin to send when to user has opted out of messaging","suites":["POST /members/send-private-message"],"updatePoint":{"line":164,"column":66,"index":7371},"line":164,"code":"  it('allows admin to send when to user has opted out of messaging', async () => {\n    userToSendMessage = await generateUser({\n      'contributor.admin': 1\n    });\n    const receiver = await generateUser({\n      'inbox.optOut': true\n    });\n    await userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    });\n    const updatedReceiver = await receiver.get('/user');\n    const updatedSender = await userToSendMessage.get('/user');\n\n    const sendersMessageInReceiversInbox = _.find(updatedReceiver.inbox.messages, message => message.uuid === userToSendMessage._id && message.text === messageToSend);\n\n    const sendersMessageInSendersInbox = _.find(updatedSender.inbox.messages, message => message.uuid === receiver._id && message.text === messageToSend);\n\n    expect(sendersMessageInReceiversInbox).to.exist;\n    expect(sendersMessageInSendersInbox).to.exist;\n  });","file":"api/v3/integration/members/POST-send_private_message.test.js","skipped":false,"dir":"test"},{"name":"returns error when no parameters are provided","suites":["POST /members/transfer-gems"],"updatePoint":{"line":21,"column":51,"index":631},"line":21,"code":"  it('returns error when no parameters are provided', async () => {\n    await expect(userToSendMessage.post('/members/transfer-gems')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when toUserId is not provided","suites":["POST /members/transfer-gems"],"updatePoint":{"line":28,"column":49,"index":903},"line":28,"code":"  it('returns error when toUserId is not provided', async () => {\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when recipient is not found","suites":["POST /members/transfer-gems"],"updatePoint":{"line":38,"column":47,"index":1213},"line":38,"code":"  it('returns error when recipient is not found', async () => {\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount,\n      toUserId: generateUUID()\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userNotFound')\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when user attempts to send gems to themselves","suites":["POST /members/transfer-gems"],"updatePoint":{"line":49,"column":65,"index":1559},"line":49,"code":"  it('returns error when user attempts to send gems to themselves', async () => {\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount,\n      toUserId: userToSendMessage._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('cannotSendGemsToYourself')\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when recipient has blocked the sender","suites":["POST /members/transfer-gems"],"updatePoint":{"line":60,"column":57,"index":1921},"line":60,"code":"  it('returns error when recipient has blocked the sender', async () => {\n    const receiverWhoBlocksUser = await generateUser({\n      'inbox.blocks': [userToSendMessage._id]\n    });\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount,\n      toUserId: receiverWhoBlocksUser._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notAuthorizedToSendMessageToThisUser')\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when sender has blocked recipient","suites":["POST /members/transfer-gems"],"updatePoint":{"line":74,"column":53,"index":2404},"line":74,"code":"  it('returns error when sender has blocked recipient', async () => {\n    const sender = await generateUser({\n      'inbox.blocks': [receiver._id]\n    });\n    await expect(sender.post('/members/transfer-gems', {\n      message,\n      gemAmount,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('blockedToSendToThisUser')\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns an error when chat privileges are revoked","suites":["POST /members/transfer-gems"],"updatePoint":{"line":88,"column":55,"index":2828},"line":88,"code":"  it('returns an error when chat privileges are revoked', async () => {\n    const userWithChatRevoked = await generateUser({\n      'flags.chatRevoked': true\n    });\n    await expect(userWithChatRevoked.post('/members/transfer-gems', {\n      message,\n      gemAmount,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('chatPrivilegesRevoked')\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"works when only the recipient's chat privileges are revoked","suites":["POST /members/transfer-gems"],"updatePoint":{"line":102,"column":66,"index":3282},"line":102,"code":"  it('works when only the recipient\\'s chat privileges are revoked', async () => {\n    const receiverWithChatRevoked = await generateUser({\n      'flags.chatRevoked': true\n    });\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount,\n      toUserId: receiverWithChatRevoked._id\n    })).to.eventually.be.fulfilled;\n    const updatedReceiver = await receiverWithChatRevoked.get('/user');\n    const updatedSender = await userToSendMessage.get('/user');\n    expect(updatedReceiver.balance).to.equal(gemAmount / 4);\n    expect(updatedSender.balance).to.equal(0);\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when there is no gemAmount","suites":["POST /members/transfer-gems"],"updatePoint":{"line":116,"column":46,"index":3872},"line":116,"code":"  it('returns error when there is no gemAmount', async () => {\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when gemAmount is not an integer","suites":["POST /members/transfer-gems"],"updatePoint":{"line":126,"column":52,"index":4200},"line":126,"code":"  it('returns error when gemAmount is not an integer', async () => {\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount: 1.5,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when gemAmount is negative","suites":["POST /members/transfer-gems"],"updatePoint":{"line":137,"column":46,"index":4544},"line":137,"code":"  it('returns error when gemAmount is negative', async () => {\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount: -5,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('badAmountOfGemsToSend')\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns error when gemAmount is more than the sender's balance","suites":["POST /members/transfer-gems"],"updatePoint":{"line":148,"column":69,"index":4910},"line":148,"code":"  it('returns error when gemAmount is more than the sender\\'s balance', async () => {\n    await expect(userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount: gemAmount + 4,\n      toUserId: receiver._id\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('badAmountOfGemsToSend')\n    });\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"sends a private message about gems to a user","suites":["POST /members/transfer-gems"],"updatePoint":{"line":159,"column":50,"index":5268},"line":159,"code":"  it('sends a private message about gems to a user', async () => {\n    await userToSendMessage.post('/members/transfer-gems', {\n      message,\n      gemAmount,\n      toUserId: receiver._id\n    });\n    const updatedReceiver = await receiver.get('/user');\n    const updatedSender = await userToSendMessage.get('/user');\n    const sendersMessageInReceiversInbox = findMessage(updatedReceiver.inbox.messages, userToSendMessage._id);\n    const sendersMessageInSendersInbox = findMessage(updatedSender.inbox.messages, receiver._id);\n    let messageSentContent = t('privateMessageGiftGemsMessage', {\n      receiverName: receiver.profile.name,\n      senderName: userToSendMessage.profile.name,\n      gemAmount\n    });\n    messageSentContent = `\\`${messageSentContent}\\` `;\n    messageSentContent += message;\n    expect(sendersMessageInReceiversInbox).to.exist;\n    expect(sendersMessageInReceiversInbox.text).to.equal(messageSentContent);\n    expect(updatedReceiver.balance).to.equal(gemAmount / 4);\n    expect(sendersMessageInSendersInbox).to.exist;\n    expect(sendersMessageInSendersInbox.text).to.equal(messageSentContent);\n    expect(updatedSender.balance).to.equal(0);\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"does not require a message","suites":["POST /members/transfer-gems"],"updatePoint":{"line":183,"column":32,"index":6422},"line":183,"code":"  it('does not require a message', async () => {\n    await userToSendMessage.post('/members/transfer-gems', {\n      gemAmount,\n      toUserId: receiver._id\n    });\n    const updatedReceiver = await receiver.get('/user');\n    const updatedSender = await userToSendMessage.get('/user');\n    const sendersMessageInReceiversInbox = findMessage(updatedReceiver.inbox.messages, userToSendMessage._id);\n    const sendersMessageInSendersInbox = findMessage(updatedSender.inbox.messages, receiver._id);\n    let messageSentContent = t('privateMessageGiftGemsMessage', {\n      receiverName: receiver.profile.name,\n      senderName: userToSendMessage.profile.name,\n      gemAmount\n    });\n    messageSentContent = `\\`${messageSentContent}\\` `;\n    expect(sendersMessageInReceiversInbox).to.exist;\n    expect(sendersMessageInReceiversInbox.text).to.equal(messageSentContent);\n    expect(updatedReceiver.balance).to.equal(gemAmount / 4);\n    expect(sendersMessageInSendersInbox).to.exist;\n    expect(sendersMessageInSendersInbox.text).to.equal(messageSentContent);\n    expect(updatedSender.balance).to.equal(0);\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"sends transfer gems message in each participant's language","suites":["POST /members/transfer-gems"],"updatePoint":{"line":205,"column":65,"index":7559},"line":205,"code":"  it('sends transfer gems message in each participant\\'s language', async () => {\n    await receiver.update({\n      'preferences.language': 'es'\n    });\n    await userToSendMessage.update({\n      'preferences.language': 'cs'\n    });\n    await userToSendMessage.post('/members/transfer-gems', {\n      gemAmount,\n      toUserId: receiver._id\n    });\n    const updatedReceiver = await receiver.get('/user');\n    const updatedSender = await userToSendMessage.get('/user');\n    const sendersMessageInReceiversInbox = findMessage(updatedReceiver.inbox.messages, userToSendMessage._id);\n    const sendersMessageInSendersInbox = findMessage(updatedSender.inbox.messages, receiver._id);\n    const [receieversMessageContent, sendersMessageContent] = ['es', 'cs'].map(lang => {\n      const messageContent = t('privateMessageGiftGemsMessage', {\n        receiverName: receiver.profile.name,\n        senderName: userToSendMessage.profile.name,\n        gemAmount\n      }, lang);\n      return `\\`${messageContent}\\` `;\n    });\n    expect(sendersMessageInReceiversInbox).to.exist;\n    expect(sendersMessageInReceiversInbox.text).to.equal(receieversMessageContent);\n    expect(sendersMessageInSendersInbox).to.exist;\n    expect(sendersMessageInSendersInbox.text).to.equal(sendersMessageContent);\n    expect(updatedSender.balance).to.equal(0);\n  });","file":"api/v3/integration/members/POST-transfer_gems.test.js","skipped":false,"dir":"test"},{"name":"returns an error when model is not accessible or doesn't exist","suites":["GET /models/:model/paths"],"updatePoint":{"line":7,"column":69,"index":276},"line":7,"code":"  it('returns an error when model is not accessible or doesn\\'t exist', async () => {\n    await expect(user.get('/models/1234/paths')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/models/GET-model_paths.test.js","skipped":false,"dir":"test"},{"name":"returns the model paths for ","suites":["GET /models/:model/paths"],"updatePoint":{"line":16,"column":44,"index":637},"line":16,"code":"    it(`returns the model paths for ${model}`, async () => {\n      const res = await user.get(`/models/${model}/paths`);\n      if (model !== 'tag') expect(res._id).to.equal('String');\n      if (model === 'tag') expect(res.id).to.equal('String');\n      expect(res).to.not.have.keys('__v');\n    });","file":"api/v3/integration/models/GET-model_paths.test.js","skipped":false,"dir":"test"},{"name":"returns the latest news in html format, does not require authentication","suites":["GET /news"],"updatePoint":{"line":7,"column":77,"index":243},"line":7,"code":"  it('returns the latest news in html format, does not require authentication', async () => {\n    const res = await api.get('/news');\n    expect(res).to.be.a.string;\n  });","file":"api/v3/integration/news/GET-news.test.js","skipped":false,"dir":"test"},{"name":"marks new stuff as read and adds notification","suites":["POST /news/tell-me-later"],"updatePoint":{"line":14,"column":51,"index":465},"line":14,"code":"  it('marks new stuff as read and adds notification', async () => {\n    const initialNotifications = user.notifications.length;\n    await user.post('/news/tell-me-later');\n    await user.sync();\n    expect(user.flags.lastNewStuffRead).to.equal('1234'); // fetching the user because newStuff is a computed property\n\n    expect((await user.get('/user')).flags.newStuff).to.equal(false);\n    expect(user.notifications.length).to.equal(initialNotifications + 1);\n    const notification = user.notifications[user.notifications.length - 1];\n    expect(notification.type).to.equal('NEW_STUFF'); // should be marked as seen by default so it's not counted in the number of notifications\n\n    expect(notification.seen).to.equal(true);\n    expect(notification.data.title).to.be.a.string;\n  });","file":"api/v3/integration/news/POST-news_tell_me_later.test.js","skipped":false,"dir":"test"},{"name":"never adds two notifications","suites":["POST /news/tell-me-later"],"updatePoint":{"line":28,"column":34,"index":1231},"line":28,"code":"  it('never adds two notifications', async () => {\n    const initialNotifications = user.notifications.length;\n    await user.post('/news/tell-me-later');\n    await user.post('/news/tell-me-later');\n    await user.sync();\n    expect(user.notifications.length).to.equal(initialNotifications + 1);\n  });","file":"api/v3/integration/news/POST-news_tell_me_later.test.js","skipped":false,"dir":"test"},{"name":"returns a 404 error when the resource is not found","suites":["notFound Middleware"],"updatePoint":{"line":3,"column":56,"index":162},"line":3,"code":"  it('returns a 404 error when the resource is not found', async () => {\n    const request = requester().get('/api/v3/dummy-url');\n    await expect(request).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v3/integration/notFound.test.js","skipped":false,"dir":"test"},{"name":"errors when notification is not found","suites":["POST /notifications/see"],"updatePoint":{"line":8,"column":43,"index":292},"line":8,"code":"  it('errors when notification is not found', async () => {\n    const dummyId = generateUUID();\n    await expect(user.post('/notifications/see', {\n      notificationIds: [dummyId]\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotificationNotFound',\n      message: t('messageNotificationNotFound')\n    });\n  });","file":"api/v3/integration/notifications/POST_notifications_see.test.js","skipped":false,"dir":"test"},{"name":"mark multiple notifications as seen","suites":["POST /notifications/see"],"updatePoint":{"line":18,"column":41,"index":630},"line":18,"code":"  it('mark multiple notifications as seen', async () => {\n    expect(user.notifications.length).to.equal(0);\n    const id = generateUUID();\n    const id2 = generateUUID();\n    const id3 = generateUUID();\n    await user.update({\n      notifications: [{\n        id,\n        type: 'DROPS_ENABLED',\n        data: {},\n        seen: false\n      }, {\n        id: id2,\n        type: 'LOGIN_INCENTIVE',\n        data: {},\n        seen: false\n      }, {\n        id: id3,\n        type: 'CRON',\n        data: {},\n        seen: false\n      }]\n    });\n    await user.sync();\n    expect(user.notifications.length).to.equal(3);\n    const res = await user.post('/notifications/see', {\n      notificationIds: [id, id3]\n    });\n    expect(res).to.deep.equal([{\n      id,\n      type: 'DROPS_ENABLED',\n      data: {},\n      seen: true\n    }, {\n      id: id2,\n      type: 'LOGIN_INCENTIVE',\n      data: {},\n      seen: false\n    }, {\n      id: id3,\n      type: 'CRON',\n      data: {},\n      seen: true\n    }]);\n    await user.sync();\n    expect(user.notifications.length).to.equal(3);\n    expect(user.notifications[0].id).to.equal(id);\n    expect(user.notifications[0].seen).to.equal(true);\n    expect(user.notifications[1].id).to.equal(id2);\n    expect(user.notifications[1].seen).to.equal(false);\n    expect(user.notifications[2].id).to.equal(id3);\n    expect(user.notifications[2].seen).to.equal(true);\n  });","file":"api/v3/integration/notifications/POST_notifications_see.test.js","skipped":false,"dir":"test"},{"name":"errors when notification is not found","suites":["POST /notifications/:notificationId/read"],"updatePoint":{"line":8,"column":43,"index":309},"line":8,"code":"  it('errors when notification is not found', async () => {\n    const dummyId = generateUUID();\n    await expect(user.post(`/notifications/${dummyId}/read`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotificationNotFound',\n      message: t('messageNotificationNotFound')\n    });\n  });","file":"api/v3/integration/notifications/POST-notifications_notificationId_read.test.js","skipped":false,"dir":"test"},{"name":"removes a notification","suites":["POST /notifications/:notificationId/read"],"updatePoint":{"line":16,"column":28,"index":604},"line":16,"code":"  it('removes a notification', async () => {\n    expect(user.notifications.length).to.equal(0);\n    const id = generateUUID();\n    const id2 = generateUUID();\n    await user.update({\n      notifications: [{\n        id,\n        type: 'DROPS_ENABLED',\n        data: {}\n      }, {\n        id: id2,\n        type: 'LOGIN_INCENTIVE',\n        data: {}\n      }]\n    });\n    await user.sync();\n    expect(user.notifications.length).to.equal(2);\n    const res = await user.post(`/notifications/${id}/read`);\n    expect(res).to.deep.equal([{\n      id: id2,\n      type: 'LOGIN_INCENTIVE',\n      data: {},\n      seen: false\n    }]);\n    await user.sync();\n    expect(user.notifications.length).to.equal(1);\n    expect(user.notifications[0].id).to.equal(id2);\n  });","file":"api/v3/integration/notifications/POST-notifications_notificationId_read.test.js","skipped":false,"dir":"test"},{"name":"errors when notification is not found","suites":["POST /notifications/:notificationId/see"],"updatePoint":{"line":8,"column":43,"index":308},"line":8,"code":"  it('errors when notification is not found', async () => {\n    const dummyId = generateUUID();\n    await expect(user.post(`/notifications/${dummyId}/see`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotificationNotFound',\n      message: t('messageNotificationNotFound')\n    });\n  });","file":"api/v3/integration/notifications/POST-notifications_notificationId_see.test.js","skipped":false,"dir":"test"},{"name":"mark a notification as seen","suites":["POST /notifications/:notificationId/see"],"updatePoint":{"line":16,"column":33,"index":607},"line":16,"code":"  it('mark a notification as seen', async () => {\n    expect(user.notifications.length).to.equal(0);\n    const id = generateUUID();\n    const id2 = generateUUID();\n    await user.update({\n      notifications: [{\n        id,\n        type: 'DROPS_ENABLED',\n        data: {}\n      }, {\n        id: id2,\n        type: 'LOGIN_INCENTIVE',\n        data: {}\n      }]\n    });\n    const userObj = await user.get('/user'); // so we can check that defaults have been applied\n\n    expect(userObj.notifications.length).to.equal(2);\n    expect(userObj.notifications[0].seen).to.equal(false);\n    const res = await user.post(`/notifications/${id}/see`);\n    expect(res).to.deep.equal({\n      id,\n      type: 'DROPS_ENABLED',\n      data: {},\n      seen: true\n    });\n    await user.sync();\n    expect(user.notifications.length).to.equal(2);\n    expect(user.notifications[0].id).to.equal(id);\n    expect(user.notifications[0].seen).to.equal(true);\n  });","file":"api/v3/integration/notifications/POST-notifications_notificationId_see.test.js","skipped":false,"dir":"test"},{"name":"errors when notification is not found","suites":["POST /notifications/read"],"updatePoint":{"line":8,"column":43,"index":293},"line":8,"code":"  it('errors when notification is not found', async () => {\n    const dummyId = generateUUID();\n    await expect(user.post('/notifications/read', {\n      notificationIds: [dummyId]\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotificationNotFound',\n      message: t('messageNotificationNotFound')\n    });\n  });","file":"api/v3/integration/notifications/POST-notifications_read.test.js","skipped":false,"dir":"test"},{"name":"removes multiple notifications","suites":["POST /notifications/read"],"updatePoint":{"line":18,"column":36,"index":627},"line":18,"code":"  it('removes multiple notifications', async () => {\n    expect(user.notifications.length).to.equal(0);\n    const id = generateUUID();\n    const id2 = generateUUID();\n    const id3 = generateUUID();\n    await user.update({\n      notifications: [{\n        id,\n        type: 'DROPS_ENABLED',\n        data: {}\n      }, {\n        id: id2,\n        type: 'LOGIN_INCENTIVE',\n        data: {}\n      }, {\n        id: id3,\n        type: 'CRON',\n        data: {}\n      }]\n    });\n    await user.sync();\n    expect(user.notifications.length).to.equal(3);\n    const res = await user.post('/notifications/read', {\n      notificationIds: [id, id3]\n    });\n    expect(res).to.deep.equal([{\n      id: id2,\n      type: 'LOGIN_INCENTIVE',\n      data: {},\n      seen: false\n    }]);\n    await user.sync();\n    expect(user.notifications.length).to.equal(1);\n    expect(user.notifications[0].id).to.equal(id2);\n  });","file":"api/v3/integration/notifications/POST-notifications_read.test.js","skipped":false,"dir":"test"},{"name":"throws error when there users has no subscription","suites":["payments : amazon #subscribeCancel"],"updatePoint":{"line":11,"column":55,"index":479},"line":11,"code":"  it('throws error when there users has no subscription', async () => {\n    await expect(user.get(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('missingSubscription')\n    });\n  });","file":"api/v3/integration/payments/amazon/GET-payments_amazon_subscribe_cancel.test.js","skipped":false,"dir":"test"},{"name":"cancels a user subscription","suites":["payments : amazon #subscribeCancel","success"],"updatePoint":{"line":25,"column":35,"index":928},"line":25,"code":"    it('cancels a user subscription', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.get(endpoint);\n      expect(amazonSubscribeCancelStub).to.be.calledOnce;\n      expect(amazonSubscribeCancelStub.args[0][0].user._id).to.eql(user._id);\n      expect(amazonSubscribeCancelStub.args[0][0].groupId).to.eql(undefined);\n      expect(amazonSubscribeCancelStub.args[0][0].headers['x-api-key']).to.eql(user.apiToken);\n      expect(amazonSubscribeCancelStub.args[0][0].headers['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/amazon/GET-payments_amazon_subscribe_cancel.test.js","skipped":false,"dir":"test"},{"name":"cancels a group subscription","suites":["payments : amazon #subscribeCancel","success"],"updatePoint":{"line":40,"column":36,"index":1670},"line":40,"code":"    it('cancels a group subscription', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      group = await generateGroup(user, {\n        name: 'test group',\n        type: 'guild',\n        privacy: 'public',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date()\n      });\n      await user.get(`${endpoint}&groupId=${group._id}`);\n      expect(amazonSubscribeCancelStub).to.be.calledOnce;\n      expect(amazonSubscribeCancelStub.args[0][0].user._id).to.eql(user._id);\n      expect(amazonSubscribeCancelStub.args[0][0].groupId).to.eql(group._id);\n      expect(amazonSubscribeCancelStub.args[0][0].headers['x-api-key']).to.eql(user.apiToken);\n      expect(amazonSubscribeCancelStub.args[0][0].headers['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/amazon/GET-payments_amazon_subscribe_cancel.test.js","skipped":false,"dir":"test"},{"name":"verifies credentials","suites":["payments - amazon - #checkout"],"updatePoint":{"line":10,"column":26,"index":370},"line":10,"code":"  it('verifies credentials', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Missing req.body.orderReferenceId'\n    });\n  });","file":"api/v3/integration/payments/amazon/POST-payments_amazon_checkout.test.js","skipped":false,"dir":"test"},{"name":"makes a purchase with amazon checkout","suites":["payments - amazon - #checkout","success"],"updatePoint":{"line":24,"column":45,"index":817},"line":24,"code":"    it('makes a purchase with amazon checkout', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      const gift = {\n        type: 'gems',\n        gems: {\n          amount: 16,\n          uuid: user._id\n        }\n      };\n      const orderReferenceId = 'orderReferenceId-example';\n      await user.post(endpoint, {\n        gift,\n        orderReferenceId\n      });\n      expect(amazonCheckoutStub).to.be.calledOnce;\n      expect(amazonCheckoutStub.args[0][0].user._id).to.eql(user._id);\n      expect(amazonCheckoutStub.args[0][0].gift).to.eql(gift);\n      expect(amazonCheckoutStub.args[0][0].orderReferenceId).to.eql(orderReferenceId);\n      expect(amazonCheckoutStub.args[0][0].headers['x-api-key']).to.eql(user.apiToken);\n      expect(amazonCheckoutStub.args[0][0].headers['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/amazon/POST-payments_amazon_checkout.test.js","skipped":false,"dir":"test"},{"name":"verifies billingAgreementId","suites":["payments - amazon - #createOrderReferenceId"],"updatePoint":{"line":8,"column":33,"index":303},"line":8,"code":"  it('verifies billingAgreementId', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Missing req.body.billingAgreementId'\n    });\n  });","file":"api/v3/integration/payments/amazon/POST-payments_amazon_createOrderReferenceId.test.js","skipped":false,"dir":"test"},{"name":"verifies subscription code","suites":["payments - amazon - #subscribe"],"updatePoint":{"line":11,"column":32,"index":427},"line":11,"code":"  it('verifies subscription code', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('missingSubscriptionCode')\n    });\n  });","file":"api/v3/integration/payments/amazon/POST-payments_amazon_subscribe.test.js","skipped":false,"dir":"test"},{"name":"creates a user subscription","suites":["payments - amazon - #subscribe","success"],"updatePoint":{"line":28,"column":35,"index":973},"line":28,"code":"    it('creates a user subscription', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.post(endpoint, {\n        billingAgreementId,\n        subscription,\n        coupon\n      });\n      expect(subscribeWithAmazonStub).to.be.calledOnce;\n      expect(subscribeWithAmazonStub.args[0][0].billingAgreementId).to.eql(billingAgreementId);\n      expect(subscribeWithAmazonStub.args[0][0].sub).to.exist;\n      expect(subscribeWithAmazonStub.args[0][0].coupon).to.eql(coupon);\n      expect(subscribeWithAmazonStub.args[0][0].groupId).not.exist;\n      expect(subscribeWithAmazonStub.args[0][0].headers['x-api-key']).to.eql(user.apiToken);\n      expect(subscribeWithAmazonStub.args[0][0].headers['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/amazon/POST-payments_amazon_subscribe.test.js","skipped":false,"dir":"test"},{"name":"creates a group subscription","suites":["payments - amazon - #subscribe","success"],"updatePoint":{"line":49,"column":36,"index":1929},"line":49,"code":"    it('creates a group subscription', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      group = await generateGroup(user, {\n        name: 'test group',\n        type: 'guild',\n        privacy: 'public',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date()\n      });\n      await user.post(endpoint, {\n        billingAgreementId,\n        subscription,\n        coupon,\n        groupId: group._id\n      });\n      expect(subscribeWithAmazonStub).to.be.calledOnce;\n      expect(subscribeWithAmazonStub.args[0][0].billingAgreementId).to.eql(billingAgreementId);\n      expect(subscribeWithAmazonStub.args[0][0].sub).to.exist;\n      expect(subscribeWithAmazonStub.args[0][0].coupon).to.eql(coupon);\n      expect(subscribeWithAmazonStub.args[0][0].user._id).to.eql(user._id);\n      expect(subscribeWithAmazonStub.args[0][0].groupId).to.eql(group._id);\n      expect(subscribeWithAmazonStub.args[0][0].headers['x-api-key']).to.eql(user.apiToken);\n      expect(subscribeWithAmazonStub.args[0][0].headers['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/amazon/POST-payments_amazon_subscribe.test.js","skipped":false,"dir":"test"},{"name":"verifies access token","suites":["payments : amazon"],"updatePoint":{"line":8,"column":27,"index":266},"line":8,"code":"  it('verifies access token', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Missing req.body.access_token'\n    });\n  });","file":"api/v3/integration/payments/amazon/POST-payments_amazon_verifyAccessToken.test.js","skipped":false,"dir":"test"},{"name":"verifies sub key","suites":["payments : apple #norenewsubscribe"],"updatePoint":{"line":10,"column":22,"index":440},"line":10,"code":"  it('verifies sub key', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('missingSubscriptionCode')\n    });\n  });","file":"api/v3/integration/payments/apple/POST-payments_apple_norenewsubscribe.test.js","skipped":false,"dir":"test"},{"name":"verifies receipt existence","suites":["payments : apple #norenewsubscribe"],"updatePoint":{"line":17,"column":32,"index":665},"line":17,"code":"  it('verifies receipt existence', async () => {\n    await expect(user.post(endpoint, {\n      sku\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('missingReceipt')\n    });\n  });","file":"api/v3/integration/payments/apple/POST-payments_apple_norenewsubscribe.test.js","skipped":false,"dir":"test"},{"name":"makes a purchase","suites":["payments : apple #norenewsubscribe","success"],"updatePoint":{"line":34,"column":24,"index":1142},"line":34,"code":"    it('makes a purchase', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.post(endpoint, {\n        sku,\n        transaction: {\n          receipt: 'receipt'\n        },\n        gift: {\n          uuid: '1'\n        }\n      });\n      expect(subscribeStub).to.be.calledOnce;\n      expect(subscribeStub.args[0][0].user._id).to.eql(user._id);\n      expect(subscribeStub.args[0][0].sku).to.eql(sku);\n      expect(subscribeStub.args[0][0].receipt).to.eql('receipt');\n      expect(subscribeStub.args[0][0].headers['x-api-key']).to.eql(user.apiToken);\n      expect(subscribeStub.args[0][0].headers['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/apple/POST-payments_apple_norenewsubscribe.test.js","skipped":false,"dir":"test"},{"name":"verifies sub key","suites":["payments : apple #subscribe"],"updatePoint":{"line":9,"column":22,"index":362},"line":9,"code":"  it('verifies sub key', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('missingSubscriptionCode')\n    });\n  });","file":"api/v3/integration/payments/apple/POST-payments_apple_subscribe.test.js","skipped":false,"dir":"test"},{"name":"makes a purchase","suites":["payments : apple #subscribe","success"],"updatePoint":{"line":24,"column":24,"index":815},"line":24,"code":"    it('makes a purchase', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      const sku = 'com.habitrpg.ios.habitica.subscription.3month';\n      await user.post(endpoint, {\n        sku,\n        receipt: 'receipt'\n      });\n      expect(subscribeStub).to.be.calledOnce;\n      expect(subscribeStub.args[0][0]).to.eql(sku);\n      expect(subscribeStub.args[0][1]._id).to.eql(user._id);\n      expect(subscribeStub.args[0][2]).to.eql('receipt');\n      expect(subscribeStub.args[0][3]['x-api-key']).to.eql(user.apiToken);\n      expect(subscribeStub.args[0][3]['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/apple/POST-payments_apple_subscribe.test.js","skipped":false,"dir":"test"},{"name":"verifies sub key","suites":["payments : google #norenewsubscribe"],"updatePoint":{"line":10,"column":22,"index":451},"line":10,"code":"  it('verifies sub key', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('missingSubscriptionCode')\n    });\n  });","file":"api/v3/integration/payments/google/POST-payments_google_norenewsubscribe.test.js","skipped":false,"dir":"test"},{"name":"verifies receipt existence","suites":["payments : google #norenewsubscribe"],"updatePoint":{"line":17,"column":32,"index":676},"line":17,"code":"  it('verifies receipt existence', async () => {\n    await expect(user.post(endpoint, {\n      sku\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('missingReceipt')\n    });\n  });","file":"api/v3/integration/payments/google/POST-payments_google_norenewsubscribe.test.js","skipped":false,"dir":"test"},{"name":"makes a purchase","suites":["payments : google #norenewsubscribe","success"],"updatePoint":{"line":34,"column":24,"index":1155},"line":34,"code":"    it('makes a purchase', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.post(endpoint, {\n        sku,\n        transaction: {\n          receipt: 'receipt',\n          signature: 'signature'\n        }\n      });\n      expect(subscribeStub).to.be.calledOnce;\n      expect(subscribeStub.args[0][0].user._id).to.eql(user._id);\n      expect(subscribeStub.args[0][0].sku).to.eql(sku);\n      expect(subscribeStub.args[0][0].receipt).to.eql('receipt');\n      expect(subscribeStub.args[0][0].signature).to.eql('signature');\n      expect(subscribeStub.args[0][0].headers['x-api-key']).to.eql(user.apiToken);\n      expect(subscribeStub.args[0][0].headers['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/google/POST-payments_google_norenewsubscribe.test.js","skipped":false,"dir":"test"},{"name":"gifts a purchase","suites":["payments : google #norenewsubscribe","success"],"updatePoint":{"line":57,"column":24,"index":2072},"line":57,"code":"    it('gifts a purchase', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.post(endpoint, {\n        sku,\n        transaction: {\n          receipt: 'receipt',\n          signature: 'signature'\n        },\n        gift: {\n          uuid: '1'\n        }\n      });\n      expect(subscribeStub).to.be.calledOnce;\n      expect(subscribeStub.args[0][0].user._id).to.eql(user._id);\n      expect(subscribeStub.args[0][0].sku).to.eql(sku);\n      expect(subscribeStub.args[0][0].receipt).to.eql('receipt');\n      expect(subscribeStub.args[0][0].signature).to.eql('signature');\n      expect(subscribeStub.args[0][0].headers['x-api-key']).to.eql(user.apiToken);\n      expect(subscribeStub.args[0][0].headers['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/google/POST-payments_google_norenewsubscribe.test.js","skipped":false,"dir":"test"},{"name":"verifies sub key","suites":["payments : google #subscribe"],"updatePoint":{"line":9,"column":22,"index":369},"line":9,"code":"  it('verifies sub key', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('missingSubscriptionCode')\n    });\n  });","file":"api/v3/integration/payments/google/POST-payments_google_subscribe.test.js","skipped":false,"dir":"test"},{"name":"makes a purchase","suites":["payments : google #subscribe","success"],"updatePoint":{"line":24,"column":24,"index":824},"line":24,"code":"    it('makes a purchase', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      const sku = 'com.habitrpg.android.habitica.subscription.3month';\n      await user.post(endpoint, {\n        sku,\n        transaction: {\n          receipt: 'receipt',\n          signature: 'signature'\n        }\n      });\n      expect(subscribeStub).to.be.calledOnce;\n      expect(subscribeStub.args[0][0]).to.eql(sku);\n      expect(subscribeStub.args[0][1]._id).to.eql(user._id);\n      expect(subscribeStub.args[0][2]).to.eql('receipt');\n      expect(subscribeStub.args[0][3]).to.eql('signature');\n      expect(subscribeStub.args[0][4]['x-api-key']).to.eql(user.apiToken);\n      expect(subscribeStub.args[0][4]['x-api-user']).to.eql(user._id);\n    });","file":"api/v3/integration/payments/google/POST-payments_google_subscribe.test.js","skipped":false,"dir":"test"},{"name":"verifies paymentId","suites":["payments : paypal #checkoutSuccess"],"updatePoint":{"line":10,"column":24,"index":434},"line":10,"code":"  it('verifies paymentId', async () => {\n    await expect(user.get(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: apiError('missingPaymentId')\n    });\n  });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_checkout_success.test.js","skipped":false,"dir":"test"},{"name":"verifies customerId","suites":["payments : paypal #checkoutSuccess"],"updatePoint":{"line":17,"column":25,"index":651},"line":17,"code":"  it('verifies customerId', async () => {\n    await expect(user.get(`${endpoint}?paymentId=test-paymentid`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: apiError('missingCustomerId')\n    });\n  });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_checkout_success.test.js","skipped":false,"dir":"test"},{"name":"makes a purchase","suites":["payments : paypal #checkoutSuccess","success"],"updatePoint":{"line":32,"column":24,"index":1160},"line":32,"code":"    it('makes a purchase', async () => {\n      const paymentId = 'test-paymentid';\n      const customerId = 'test-customerId';\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.get(`${endpoint}?PayerID=${customerId}&paymentId=${paymentId}&noRedirect=true`);\n      expect(checkoutSuccessStub).to.be.calledOnce;\n      expect(checkoutSuccessStub.args[0][0].user._id).to.eql(user._id);\n      expect(checkoutSuccessStub.args[0][0].gift).to.eql(undefined);\n      expect(checkoutSuccessStub.args[0][0].paymentId).to.eql(paymentId);\n      expect(checkoutSuccessStub.args[0][0].customerId).to.eql(customerId);\n    });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_checkout_success.test.js","skipped":false,"dir":"test"},{"name":"creates a purchase link","suites":["payments : paypal #checkout","success"],"updatePoint":{"line":17,"column":31,"index":590},"line":17,"code":"    it('creates a purchase link', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.get(`${endpoint}?noRedirect=true`);\n      expect(checkoutStub).to.be.calledOnce;\n      expect(checkoutStub.args[0][0].gift).to.eql(undefined);\n    });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_checkout.test.js","skipped":false,"dir":"test"},{"name":"verifies credentials","suites":["payments : paypal #subscribeCancel"],"updatePoint":{"line":9,"column":26,"index":381},"line":9,"code":"  it('verifies credentials', async () => {\n    await expect(user.get(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('missingSubscription')\n    });\n  });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_subscribe_cancel.test.js","skipped":false,"dir":"test"},{"name":"cancels a subscription","suites":["payments : paypal #subscribeCancel","success"],"updatePoint":{"line":24,"column":30,"index":865},"line":24,"code":"    it('cancels a subscription', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.get(`${endpoint}?noRedirect=true`);\n      expect(subscribeCancelStub).to.be.calledOnce;\n      expect(subscribeCancelStub.args[0][0].user._id).to.eql(user._id);\n      expect(subscribeCancelStub.args[0][0].groupId).to.eql(undefined);\n    });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_subscribe_cancel.test.js","skipped":false,"dir":"test"},{"name":"verifies Paypal Block","suites":["payments : paypal #subscribeSuccess"],"updatePoint":{"line":10,"column":27,"index":439},"line":10,"code":"  it('verifies Paypal Block', async () => {\n    await expect(user.get(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: apiError('missingPaypalBlock')\n    });\n  });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_subscribe_success.test.js","skipped":false,"dir":"test"},{"name":"creates a subscription","suites":["payments : paypal #subscribeSuccess"],"updatePoint":{"line":25,"column":30,"index":930},"line":25,"code":"    it('creates a subscription', async () => {\n      const token = 'test-token';\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.get(`${endpoint}?token=${token}&noRedirect=true`);\n      expect(subscribeSuccessStub).to.be.calledOnce;\n      expect(subscribeSuccessStub.args[0][0].user._id).to.eql(user._id);\n      expect(subscribeSuccessStub.args[0][0].block).to.eql(undefined);\n      expect(subscribeSuccessStub.args[0][0].groupId).to.eql(undefined);\n      expect(subscribeSuccessStub.args[0][0].token).to.eql(token);\n      expect(subscribeSuccessStub.args[0][0].headers).to.exist;\n    });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_subscribe_success.test.js","skipped":false,"dir":"test"},{"name":"verifies sub key","suites":["payments : paypal #subscribe"],"updatePoint":{"line":11,"column":22,"index":474},"line":11,"code":"  it('verifies sub key', async () => {\n    await expect(user.get(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: apiError('missingSubKey')\n    });\n  });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_subscribe.test.js","skipped":false,"dir":"test"},{"name":"makes a purchase","suites":["payments : paypal #subscribe","success"],"updatePoint":{"line":26,"column":24,"index":926},"line":26,"code":"    it('makes a purchase', async () => {\n      const subKey = 'basic_3mo';\n      const sub = shared.content.subscriptionBlocks[subKey];\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.get(`${endpoint}?sub=${subKey}&noRedirect=true`);\n      expect(subscribeStub).to.be.calledOnce;\n      expect(subscribeStub.args[0][0].sub).to.eql(sub);\n      expect(subscribeStub.args[0][0].coupon).to.eql(undefined);\n    });","file":"api/v3/integration/payments/paypal/GET-payments_paypal_subscribe.test.js","skipped":false,"dir":"test"},{"name":"verifies credentials","suites":["payments - paypal - #ipn"],"updatePoint":{"line":9,"column":26,"index":342},"line":9,"code":"  it('verifies credentials', async () => {\n    const result = await user.post(endpoint);\n    expect(result).to.eql('OK');\n  });","file":"api/v3/integration/payments/paypal/POST-payments_paypal_ipn.test.js","skipped":false,"dir":"test"},{"name":"makes a purchase","suites":["payments - paypal - #ipn","success"],"updatePoint":{"line":21,"column":24,"index":682},"line":21,"code":"    it('makes a purchase', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.post(endpoint);\n      expect(ipnStub).to.be.calledOnce;\n    });","file":"api/v3/integration/payments/paypal/POST-payments_paypal_ipn.test.js","skipped":false,"dir":"test"},{"name":"verifies credentials","suites":["payments - stripe - #subscribeCancel"],"updatePoint":{"line":11,"column":26,"index":463},"line":11,"code":"  it('verifies credentials', async () => {\n    await expect(user.get(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('missingSubscription')\n    });\n  });","file":"api/v3/integration/payments/stripe/GET-payments_stripe_subscribe_cancel.test.js","skipped":false,"dir":"test"},{"name":"cancels a user subscription","suites":["payments - stripe - #subscribeCancel","success"],"updatePoint":{"line":25,"column":35,"index":937},"line":25,"code":"    it('cancels a user subscription', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      await user.get(`${endpoint}`);\n      expect(stripeCancelSubscriptionStub).to.be.calledOnce;\n      expect(stripeCancelSubscriptionStub.args[0][0].user._id).to.eql(user._id);\n      expect(stripeCancelSubscriptionStub.args[0][0].groupId).to.eql(undefined);\n    });","file":"api/v3/integration/payments/stripe/GET-payments_stripe_subscribe_cancel.test.js","skipped":false,"dir":"test"},{"name":"cancels a group subscription","suites":["payments - stripe - #subscribeCancel","success"],"updatePoint":{"line":38,"column":36,"index":1507},"line":38,"code":"    it('cancels a group subscription', async () => {\n      user = await generateUser({\n        'profile.name': 'sender',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date(),\n        balance: 2\n      });\n      group = await generateGroup(user, {\n        name: 'test group',\n        type: 'guild',\n        privacy: 'public',\n        'purchased.plan.customerId': 'customer-id',\n        'purchased.plan.planId': 'basic_3mo',\n        'purchased.plan.lastBillingDate': new Date()\n      });\n      await user.get(`${endpoint}&groupId=${group._id}`);\n      expect(stripeCancelSubscriptionStub).to.be.calledOnce;\n      expect(stripeCancelSubscriptionStub.args[0][0].user._id).to.eql(user._id);\n      expect(stripeCancelSubscriptionStub.args[0][0].groupId).to.eql(group._id);\n    });","file":"api/v3/integration/payments/stripe/GET-payments_stripe_subscribe_cancel.test.js","skipped":false,"dir":"test"},{"name":"works","suites":["payments - stripe - #createCheckoutSession"],"updatePoint":{"line":23,"column":11,"index":827},"line":23,"code":"  it('works', async () => {\n    const res = await user.post(endpoint, {\n      groupId,\n      gift,\n      sub: subKey,\n      gemsBlock,\n      coupon\n    });\n    expect(res.sessionId).to.equal(sessionId);\n    expect(stripeCreateCheckoutSessionStub).to.be.calledOnce;\n    expect(stripeCreateCheckoutSessionStub.args[0][0].user._id).to.eql(user._id);\n    expect(stripeCreateCheckoutSessionStub.args[0][0].groupId).to.eql(groupId);\n    expect(stripeCreateCheckoutSessionStub.args[0][0].gift).to.eql(gift);\n    expect(stripeCreateCheckoutSessionStub.args[0][0].sub).to.eql(common.content.subscriptionBlocks[subKey]);\n    expect(stripeCreateCheckoutSessionStub.args[0][0].gemsBlock).to.eql(gemsBlock);\n    expect(stripeCreateCheckoutSessionStub.args[0][0].coupon).to.eql(coupon);\n  });","file":"api/v3/integration/payments/stripe/POST-payments_stripe_checkout-session.test.js","skipped":false,"dir":"test"},{"name":"works","suites":["payments - stripe - #subscribeEdit"],"updatePoint":{"line":18,"column":11,"index":662},"line":18,"code":"  it('works', async () => {\n    const res = await user.post(endpoint, {\n      groupId\n    });\n    expect(res.sessionId).to.equal(sessionId);\n    expect(stripeEditSubscriptionStub).to.be.calledOnce;\n    expect(stripeEditSubscriptionStub.args[0][0].user._id).to.eql(user._id);\n    expect(stripeEditSubscriptionStub.args[0][0].groupId).to.eql(groupId);\n  });","file":"api/v3/integration/payments/stripe/POST-payments_stripe_subscribe_edit.test.js","skipped":false,"dir":"test"},{"name":"works","suites":["payments - stripe - #handleWebhooks"],"updatePoint":{"line":15,"column":11,"index":569},"line":15,"code":"  it('works', async () => {\n    const res = await user.post(endpoint, body);\n    expect(res).to.eql({});\n    expect(stripeHandleWebhooksStub).to.be.calledOnce;\n    expect(stripeHandleWebhooksStub.args[0][0].body).to.exist;\n    expect(stripeHandleWebhooksStub.args[0][0].headers).to.exist;\n  });","file":"api/v3/integration/payments/stripe/POST-payments_stripe_webhooks.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.memberId","suites":[],"updatePoint":{"line":10,"column":35,"index":358},"line":10,"code":"  it('validates req.params.memberId', async () => {\n    await expect(user.get('/qr-code/user/invalidUUID')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/qrcodes/GET-qrcodes_user.test.js","skipped":false,"dir":"test"},{"name":"redirects to profile page","suites":[],"updatePoint":{"line":17,"column":31,"index":593},"line":17,"code":"  it('redirects to profile page', async () => {\n    const url = `http://localhost:${API_TEST_SERVER_PORT}/qr-code/user/${user._id}`;\n    const response = await superagent.get(url).end((err, res) => {\n      expect(err).to.be(undefined);\n      return res;\n    });\n    expect(response.status).to.eql(200);\n    expect(response.request.url).to.eql(`http://localhost:${API_TEST_SERVER_PORT}/static/front/#?memberId=${user._id}`);\n  });","file":"api/v3/integration/qrcodes/GET-qrcodes_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is not found","suites":["POST /groups/:groupId/quests/abort","failure conditions"],"updatePoint":{"line":31,"column":48,"index":894},"line":31,"code":"    it('returns an error when group is not found', async () => {\n      await expect(partyMembers[0].post(`/groups/${generateUUID()}/quests/abort`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_abort.test.js","skipped":false,"dir":"test"},{"name":"returns an error for a group in which user is not a member","suites":["POST /groups/:groupId/quests/abort","failure conditions"],"updatePoint":{"line":38,"column":66,"index":1196},"line":38,"code":"    it('returns an error for a group in which user is not a member', async () => {\n      await expect(user.post(`/groups/${questingGroup._id}/quests/abort`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_abort.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is a guild","suites":["POST /groups/:groupId/quests/abort","failure conditions"],"updatePoint":{"line":45,"column":46,"index":1470},"line":45,"code":"    it('returns an error when group is a guild', async () => {\n      const {\n        group: guild,\n        groupLeader: guildLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'private'\n        }\n      });\n      await expect(guildLeader.post(`/groups/${guild._id}/quests/abort`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('guildQuestsNotSupported')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_abort.test.js","skipped":false,"dir":"test"},{"name":"returns an error when quest is not active","suites":["POST /groups/:groupId/quests/abort","failure conditions"],"updatePoint":{"line":61,"column":49,"index":1969},"line":61,"code":"    it('returns an error when quest is not active', async () => {\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/abort`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('noActiveQuestToAbort')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_abort.test.js","skipped":false,"dir":"test"},{"name":"returns an error when non quest leader attempts to abort","suites":["POST /groups/:groupId/quests/abort","failure conditions"],"updatePoint":{"line":68,"column":64,"index":2279},"line":68,"code":"    it('returns an error when non quest leader attempts to abort', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/abort`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlyLeaderAbortQuest')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_abort.test.js","skipped":false,"dir":"test"},{"name":"aborts a quest","suites":["POST /groups/:groupId/quests/abort","failure conditions"],"updatePoint":{"line":79,"column":20,"index":2800},"line":79,"code":"  it('aborts a quest', async () => {\n    await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n    await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n    await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n    const stub = sandbox.spy(Group.prototype, 'sendChat');\n    const res = await leader.post(`/groups/${questingGroup._id}/quests/abort`);\n    await Promise.all([leader.sync(), questingGroup.sync(), partyMembers[0].sync(), partyMembers[1].sync()]);\n    const cleanUserQuestObj = {\n      key: null,\n      progress: {\n        up: 0,\n        down: 0,\n        collect: {},\n        collectedItems: 0\n      },\n      completed: null,\n      RSVPNeeded: false\n    };\n    expect(leader.party.quest).to.eql(cleanUserQuestObj);\n    expect(partyMembers[0].party.quest).to.eql(cleanUserQuestObj);\n    expect(partyMembers[1].party.quest).to.eql(cleanUserQuestObj);\n    expect(leader.items.quests[PET_QUEST]).to.equal(1);\n    expect(questingGroup.quest).to.deep.equal(res);\n    expect(questingGroup.quest).to.eql({\n      key: null,\n      active: false,\n      leader: null,\n      progress: {\n        collect: {}\n      },\n      members: {}\n    });\n    expect(Group.prototype.sendChat).to.be.calledOnce;\n    expect(Group.prototype.sendChat).to.be.calledWithMatch({\n      message: sinon.match(/aborted the party quest Wail of the Whale.`/),\n      info: {\n        quest: 'whale',\n        type: 'quest_abort'\n      }\n    });\n    stub.restore();\n  });","file":"api/v3/integration/quests/POST-groups_groupid_quests_abort.test.js","skipped":false,"dir":"test"},{"name":"does not accept quest without an invite","suites":["POST /groups/:groupId/quests/accept","failure conditions"],"updatePoint":{"line":30,"column":47,"index":863},"line":30,"code":"    it('does not accept quest without an invite', async () => {\n      await expect(leader.post(`/groups/${questingGroup._id}/quests/accept`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('questInviteNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"does not accept quest for a group in which user is not a member","suites":["POST /groups/:groupId/quests/accept","failure conditions"],"updatePoint":{"line":37,"column":71,"index":1171},"line":37,"code":"    it('does not accept quest for a group in which user is not a member', async () => {\n      await expect(user.post(`/groups/${questingGroup._id}/quests/accept`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"does not accept quest for a guild","suites":["POST /groups/:groupId/quests/accept","failure conditions"],"updatePoint":{"line":44,"column":41,"index":1441},"line":44,"code":"    it('does not accept quest for a guild', async () => {\n      const {\n        group: guild,\n        groupLeader: guildLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'private'\n        }\n      });\n      await expect(guildLeader.post(`/groups/${guild._id}/quests/accept`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('guildQuestsNotSupported')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"does not accept invite twice","suites":["POST /groups/:groupId/quests/accept","failure conditions"],"updatePoint":{"line":60,"column":36,"index":1928},"line":60,"code":"    it('does not accept invite twice', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('questAlreadyAccepted')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"clears the invalid invite from the user when the request fails","suites":["POST /groups/:groupId/quests/accept","failure conditions"],"updatePoint":{"line":69,"column":70,"index":2411},"line":69,"code":"    it('clears the invalid invite from the user when the request fails', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('questAlreadyAccepted')\n      });\n      await partyMembers[0].sync();\n      expect(partyMembers[0].party.quest.RSVPNeeded).to.be.false;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"does not accept invite for a quest already underway","suites":["POST /groups/:groupId/quests/accept","failure conditions"],"updatePoint":{"line":80,"column":59,"index":2985},"line":80,"code":"    it('does not accept invite for a quest already underway', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`); // quest will start after everyone has accepted\n\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('questAlreadyStartedFriendly')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"joins a quest from an invitation","suites":["POST /groups/:groupId/quests/accept","successfully accepting a quest invitation"],"updatePoint":{"line":93,"column":40,"index":3646},"line":93,"code":"    it('joins a quest from an invitation', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await Promise.all([partyMembers[0].sync(), questingGroup.sync()]);\n      expect(leader.party.quest.RSVPNeeded).to.equal(false);\n      expect(questingGroup.quest.members[partyMembers[0]._id]).to.equal(true);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"does not begin the quest if pending invitations remain","suites":["POST /groups/:groupId/quests/accept","successfully accepting a quest invitation"],"updatePoint":{"line":100,"column":62,"index":4110},"line":100,"code":"    it('does not begin the quest if pending invitations remain', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await questingGroup.sync();\n      expect(questingGroup.quest.active).to.equal(false);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"begins the quest if accepting the last pending invite","suites":["POST /groups/:groupId/quests/accept","successfully accepting a quest invitation"],"updatePoint":{"line":106,"column":61,"index":4452},"line":106,"code":"    it('begins the quest if accepting the last pending invite', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`); // quest will start after everyone has accepted\n\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n      await questingGroup.sync();\n      expect(questingGroup.quest.active).to.equal(true);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"cleans up user quest data for non-quest members when last member accepts","suites":["POST /groups/:groupId/quests/accept","successfully accepting a quest invitation"],"updatePoint":{"line":114,"column":80,"index":4941},"line":114,"code":"    it('cleans up user quest data for non-quest members when last member accepts', async () => {\n      const rejectingMember = partyMembers[0];\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await rejectingMember.post(`/groups/${questingGroup._id}/quests/reject`); // quest will start after everyone has accepted\n\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n      await sleep(0.5);\n      await rejectingMember.sync();\n      expect(rejectingMember.party.quest.RSVPNeeded).to.eql(false);\n      expect(rejectingMember.party.quest.key).to.not.exist;\n      expect(rejectingMember.party.quest.completed).to.not.exist;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"begins the quest if accepting the last pending invite and verifies chat","suites":["POST /groups/:groupId/quests/accept","successfully accepting a quest invitation"],"updatePoint":{"line":126,"column":79,"index":5639},"line":126,"code":"    it('begins the quest if accepting the last pending invite and verifies chat', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`); // quest will start after everyone has accepted\n\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n      const groupChat = await Chat.find({\n        groupId: questingGroup._id\n      }).exec();\n      expect(groupChat[0].text).to.exist;\n      expect(groupChat[0]._meta).to.exist;\n      expect(groupChat[0]._meta).to.have.all.keys(['participatingMembers']);\n      const returnedGroup = await leader.get(`/groups/${questingGroup._id}`);\n      expect(returnedGroup.chat[0]._meta).to.be.undefined;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_accept.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is not found","suites":["POST /groups/:groupId/quests/cancel","failure conditions"],"updatePoint":{"line":31,"column":48,"index":895},"line":31,"code":"    it('returns an error when group is not found', async () => {\n      await expect(partyMembers[0].post(`/groups/${generateUUID()}/quests/cancel`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_cancel.test.js","skipped":false,"dir":"test"},{"name":"does not reject quest for a group in which user is not a member","suites":["POST /groups/:groupId/quests/cancel","failure conditions"],"updatePoint":{"line":38,"column":71,"index":1203},"line":38,"code":"    it('does not reject quest for a group in which user is not a member', async () => {\n      await expect(user.post(`/groups/${questingGroup._id}/quests/cancel`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_cancel.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is a guild","suites":["POST /groups/:groupId/quests/cancel","failure conditions"],"updatePoint":{"line":45,"column":46,"index":1478},"line":45,"code":"    it('returns an error when group is a guild', async () => {\n      const {\n        group: guild,\n        groupLeader: guildLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'private'\n        }\n      });\n      await expect(guildLeader.post(`/groups/${guild._id}/quests/cancel`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('guildQuestsNotSupported')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_cancel.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is not on a quest","suites":["POST /groups/:groupId/quests/cancel","failure conditions"],"updatePoint":{"line":61,"column":53,"index":1982},"line":61,"code":"    it('returns an error when group is not on a quest', async () => {\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/cancel`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('questInvitationDoesNotExist')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_cancel.test.js","skipped":false,"dir":"test"},{"name":"only the leader can cancel the quest","suites":["POST /groups/:groupId/quests/cancel","failure conditions"],"updatePoint":{"line":68,"column":44,"index":2280},"line":68,"code":"    it('only the leader can cancel the quest', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/cancel`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlyLeaderCancelQuest')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_cancel.test.js","skipped":false,"dir":"test"},{"name":"does not cancel a quest already underway","suites":["POST /groups/:groupId/quests/cancel","failure conditions"],"updatePoint":{"line":76,"column":48,"index":2665},"line":76,"code":"    it('does not cancel a quest already underway', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`); // quest will start after everyone has accepted\n\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(leader.post(`/groups/${questingGroup._id}/quests/cancel`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('cantCancelActiveQuest')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_cancel.test.js","skipped":false,"dir":"test"},{"name":"cancels a quest","suites":["POST /groups/:groupId/quests/cancel","failure conditions"],"updatePoint":{"line":88,"column":21,"index":3229},"line":88,"code":"  it('cancels a quest', async () => {\n    await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n    await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`); // partyMembers[1] hasn't accepted the invitation, because if he accepts, invitation phase ends.\n    // The cancel command can be done only in the invitation phase.\n\n    const stub = sandbox.spy(Group.prototype, 'sendChat');\n    const res = await leader.post(`/groups/${questingGroup._id}/quests/cancel`);\n    await Promise.all([leader.sync(), partyMembers[0].sync(), partyMembers[1].sync(), questingGroup.sync()]);\n    const clean = {\n      key: null,\n      progress: {\n        up: 0,\n        down: 0,\n        collect: {},\n        collectedItems: 0\n      },\n      completed: null,\n      RSVPNeeded: false\n    };\n    expect(leader.party.quest).to.eql(clean);\n    expect(partyMembers[1].party.quest).to.eql(clean);\n    expect(partyMembers[0].party.quest).to.eql(clean);\n    expect(res).to.eql(questingGroup.quest);\n    expect(questingGroup.quest).to.eql({\n      key: null,\n      active: false,\n      leader: null,\n      progress: {\n        collect: {}\n      },\n      members: {}\n    });\n    expect(Group.prototype.sendChat).to.be.calledOnce;\n    expect(Group.prototype.sendChat).to.be.calledWithMatch({\n      message: sinon.match(/cancelled the party quest Wail of the Whale.`/),\n      info: {\n        quest: 'whale',\n        type: 'quest_cancel',\n        user: sinon.match.any\n      }\n    });\n    stub.restore();\n  });","file":"api/v3/integration/quests/POST-groups_groupid_quests_cancel.test.js","skipped":false,"dir":"test"},{"name":"does not force start a quest for a group in which user is not a member","suites":["POST /groups/:groupId/quests/force-start","failure conditions"],"updatePoint":{"line":28,"column":78,"index":854},"line":28,"code":"    it('does not force start a quest for a group in which user is not a member', async () => {\n      const nonMember = await generateUser();\n      await expect(nonMember.post(`/groups/${questingGroup._id}/quests/force-start`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"does not force start quest for a guild","suites":["POST /groups/:groupId/quests/force-start","failure conditions"],"updatePoint":{"line":36,"column":46,"index":1185},"line":36,"code":"    it('does not force start quest for a guild', async () => {\n      const {\n        group: guild,\n        groupLeader: guildLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'private'\n        }\n      });\n      await expect(guildLeader.post(`/groups/${guild._id}/quests/force-start`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('guildQuestsNotSupported')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"does not force start for a party without a pending quest","suites":["POST /groups/:groupId/quests/force-start","failure conditions"],"updatePoint":{"line":52,"column":64,"index":1705},"line":52,"code":"    it('does not force start for a party without a pending quest', async () => {\n      await expect(leader.post(`/groups/${questingGroup._id}/quests/force-start`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('questNotPending')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"does not force start for a quest already underway","suites":["POST /groups/:groupId/quests/force-start","failure conditions"],"updatePoint":{"line":59,"column":57,"index":2000},"line":59,"code":"    it('does not force start for a quest already underway', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`); // quest will start after everyone has accepted\n\n      await partyMembers[2].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(leader.post(`/groups/${questingGroup._id}/quests/force-start`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('questAlreadyStarted')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"does not allow non-quest leader or non-group leader to force start a quest","suites":["POST /groups/:groupId/quests/force-start","failure conditions"],"updatePoint":{"line":71,"column":82,"index":2702},"line":71,"code":"    it('does not allow non-quest leader or non-group leader to force start a quest', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/force-start`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('questOrGroupLeaderOnlyStartQuest')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"allows quest leader to force start quest","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":81,"column":48,"index":3166},"line":81,"code":"    it('allows quest leader to force start quest', async () => {\n      const questLeader = partyMembers[0];\n      await questLeader.update({\n        [`items.quests.${PET_QUEST}`]: 1\n      });\n      await questLeader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await questLeader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      await questingGroup.sync();\n      expect(questingGroup.quest.active).to.eql(true);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"allows group leader to force start quest","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":91,"column":48,"index":3625},"line":91,"code":"    it('allows group leader to force start quest', async () => {\n      const questLeader = partyMembers[0];\n      await questLeader.update({\n        [`items.quests.${PET_QUEST}`]: 1\n      });\n      await questLeader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await leader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      await questingGroup.sync();\n      expect(questingGroup.quest.active).to.eql(true);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"sends back the quest object","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":101,"column":35,"index":4066},"line":101,"code":"    it('sends back the quest object', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      const quest = await leader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      expect(quest.active).to.eql(true);\n      expect(quest.key).to.eql(PET_QUEST);\n      expect(quest.members).to.eql({\n        [`${leader._id}`]: true\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"cleans up user quest data for non-quest members","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":110,"column":55,"index":4483},"line":110,"code":"    it('cleans up user quest data for non-quest members', async () => {\n      const partyMemberThatRejects = partyMembers[1];\n      const partyMemberThatIgnores = partyMembers[2];\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMemberThatRejects.post(`/groups/${questingGroup._id}/quests/reject`);\n      await leader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      await sleep(0.5);\n      await Promise.all([partyMemberThatRejects.sync(), partyMemberThatIgnores.sync()]);\n      expect(partyMemberThatRejects.party.quest.RSVPNeeded).to.eql(false);\n      expect(partyMemberThatRejects.party.quest.key).to.not.exist;\n      expect(partyMemberThatRejects.party.quest.completed).to.not.exist;\n      expect(partyMemberThatIgnores.party.quest.RSVPNeeded).to.eql(false);\n      expect(partyMemberThatIgnores.party.quest.key).to.not.exist;\n      expect(partyMemberThatIgnores.party.quest.completed).to.not.exist;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"removes users who have not accepted the quest from quest.members","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":126,"column":72,"index":5558},"line":126,"code":"    it('removes users who have not accepted the quest from quest.members', async () => {\n      const partyMemberThatRejects = partyMembers[1];\n      const partyMemberThatIgnores = partyMembers[2];\n      const partyMemberThatAccepts = partyMembers[0];\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMemberThatAccepts.post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMemberThatRejects.post(`/groups/${questingGroup._id}/quests/reject`);\n      await leader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      await sleep(0.5);\n      await questingGroup.sync();\n      expect(questingGroup.quest.members[partyMemberThatRejects._id]).to.not.exist;\n      expect(questingGroup.quest.members[partyMemberThatIgnores._id]).to.not.exist;\n      expect(questingGroup.quest.members[partyMemberThatAccepts._id]).to.exist;\n      expect(questingGroup.quest.members[leader._id]).to.exist;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"removes users who are not in the party from quest.members","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":141,"column":65,"index":6514},"line":141,"code":"    it('removes users who are not in the party from quest.members', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      const notInPartyUser = await generateUser();\n      await questingGroup.update({\n        [`quest.members.${notInPartyUser._id}`]: true\n      });\n      await questingGroup.sync();\n      expect(questingGroup.quest.members[notInPartyUser._id]).to.eql(true);\n      await leader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      await sleep(0.5);\n      await questingGroup.sync();\n      expect(questingGroup.quest.members[notInPartyUser._id]).to.not.exist;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"removes users who have been deleted from quest.members","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":154,"column":62,"index":7155},"line":154,"code":"    it('removes users who have been deleted from quest.members', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMembers[0].del('/user', {\n        password: 'password'\n      });\n      await leader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      await sleep(0.5);\n      await questingGroup.sync();\n      expect(questingGroup.quest.members[partyMembers[0]._id]).to.not.exist;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"removes users who don't have true value in quest.members from quest.members","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":165,"column":84,"index":7721},"line":165,"code":"    it('removes users who don\\'t have true value in quest.members from quest.members', async () => {\n      const partyMemberThatRejects = partyMembers[1];\n      const partyMemberThatIgnores = partyMembers[2];\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await questingGroup.update({\n        [`quest.members.${partyMemberThatRejects._id}`]: false,\n        [`quest.members.${partyMemberThatIgnores._id}`]: null\n      });\n      await leader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      await sleep(0.5);\n      await questingGroup.sync();\n      expect(questingGroup.quest.members[partyMemberThatRejects._id]).to.not.exist;\n      expect(questingGroup.quest.members[partyMemberThatIgnores._id]).to.not.exist;\n      expect(questingGroup.quest.members[partyMembers[0]._id]).to.exist;\n      expect(questingGroup.quest.members[leader._id]).to.exist;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"allows group leader to force start quest and verifies chat","suites":["POST /groups/:groupId/quests/force-start","successfully force starting a quest"],"updatePoint":{"line":182,"column":66,"index":8694},"line":182,"code":"    it('allows group leader to force start quest and verifies chat', async () => {\n      const questLeader = partyMembers[0];\n      await questLeader.update({\n        [`items.quests.${PET_QUEST}`]: 1\n      });\n      await questLeader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await leader.post(`/groups/${questingGroup._id}/quests/force-start`);\n      await questingGroup.sync();\n      const groupChat = await Chat.find({\n        groupId: questingGroup._id\n      }).exec();\n      expect(groupChat[0].text).to.exist;\n      expect(groupChat[0]._meta).to.exist;\n      expect(groupChat[0]._meta).to.have.all.keys(['participatingMembers']);\n      const returnedGroup = await leader.get(`/groups/${questingGroup._id}`);\n      expect(returnedGroup.chat[0]._meta).to.be.undefined;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_force-start.test.js","skipped":false,"dir":"test"},{"name":"does not issue invites with an invalid group ID","suites":["POST /groups/:groupId/quests/invite/:questKey","failure conditions"],"updatePoint":{"line":28,"column":55,"index":997},"line":28,"code":"    it('does not issue invites with an invalid group ID', async () => {\n      await expect(leader.post(`/groups/${generateUUID()}/quests/invite/${PET_QUEST}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"does not issue invites for a group in which user is not a member","suites":["POST /groups/:groupId/quests/invite/:questKey","failure conditions"],"updatePoint":{"line":35,"column":72,"index":1310},"line":35,"code":"    it('does not issue invites for a group in which user is not a member', async () => {\n      const {\n        group\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        },\n        members: 1\n      });\n      const alternateGroup = group;\n      await expect(leader.post(`/groups/${alternateGroup._id}/quests/invite/${PET_QUEST}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"does not issue invites for Guilds","suites":["POST /groups/:groupId/quests/invite/:questKey","failure conditions"],"updatePoint":{"line":52,"column":41,"index":1819},"line":52,"code":"    it('does not issue invites for Guilds', async () => {\n      const {\n        group\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'public'\n        },\n        members: 1\n      });\n      const alternateGroup = group;\n      await expect(leader.post(`/groups/${alternateGroup._id}/quests/invite/${PET_QUEST}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('guildQuestsNotSupported')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"does not issue invites with an invalid quest key","suites":["POST /groups/:groupId/quests/invite/:questKey","failure conditions"],"updatePoint":{"line":69,"column":56,"index":2357},"line":69,"code":"    it('does not issue invites with an invalid quest key', async () => {\n      const FAKE_QUEST = 'herkimer';\n      await expect(leader.post(`/groups/${questingGroup._id}/quests/invite/${FAKE_QUEST}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: apiError('questNotFound', {\n          key: FAKE_QUEST\n        })\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"does not issue invites for a quest the user does not own","suites":["POST /groups/:groupId/quests/invite/:questKey","failure conditions"],"updatePoint":{"line":79,"column":64,"index":2749},"line":79,"code":"    it('does not issue invites for a quest the user does not own', async () => {\n      await expect(leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('questNotOwned')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"does not issue invites if a quest is already underway","suites":["POST /groups/:groupId/quests/invite/:questKey","failure conditions"],"updatePoint":{"line":86,"column":61,"index":3059},"line":86,"code":"    it('does not issue invites if a quest is already underway', async () => {\n      const QUEST_IN_PROGRESS = 'atom1';\n      const leaderUpdate = {};\n      leaderUpdate[`items.quests.${PET_QUEST}`] = 1;\n      await leader.update(leaderUpdate);\n      await questingGroup.update({\n        'quest.key': QUEST_IN_PROGRESS\n      });\n      await expect(leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('questAlreadyUnderway')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"adds quest details to group object","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation"],"updatePoint":{"line":107,"column":42,"index":3880},"line":107,"code":"    it('adds quest details to group object', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await questingGroup.sync();\n      const {\n        quest\n      } = questingGroup;\n      expect(quest.key).to.eql(PET_QUEST);\n      expect(quest.active).to.eql(false);\n      expect(quest.leader).to.eql(leader._id);\n      expect(quest.members).to.have.property(leader._id, true);\n      expect(quest.members).to.have.property(member._id, null);\n      expect(quest).to.have.property('progress');\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"adds quest details to user objects","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation"],"updatePoint":{"line":120,"column":42,"index":4428},"line":120,"code":"    it('adds quest details to user objects', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await sleep(0.1); // member updates happen in the background\n\n      await Promise.all([leader.sync(), member.sync()]);\n      expect(leader.party.quest.key).to.eql(PET_QUEST);\n      expect(member.party.quest.key).to.eql(PET_QUEST);\n      expect(leader.party.quest.RSVPNeeded).to.eql(false);\n      expect(member.party.quest.RSVPNeeded).to.eql(true);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"sends back the quest object","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation"],"updatePoint":{"line":130,"column":35,"index":4926},"line":130,"code":"    it('sends back the quest object', async () => {\n      const inviteResponse = await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      expect(inviteResponse.key).to.eql(PET_QUEST);\n      expect(inviteResponse.active).to.eql(false);\n      expect(inviteResponse.leader).to.eql(leader._id);\n      expect(inviteResponse.members).to.have.property(leader._id, true);\n      expect(inviteResponse.members).to.have.property(member._id, null);\n      expect(inviteResponse).to.have.property('progress');\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"allows non-party-leader party members to send invites","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation"],"updatePoint":{"line":139,"column":61,"index":5483},"line":139,"code":"    it('allows non-party-leader party members to send invites', async () => {\n      const inviteResponse = await member.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await questingGroup.sync();\n      expect(inviteResponse.key).to.eql(PET_QUEST);\n      expect(questingGroup.quest.key).to.eql(PET_QUEST);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"starts quest automatically if user is in a solo party","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation"],"updatePoint":{"line":145,"column":61,"index":5819},"line":145,"code":"    it('starts quest automatically if user is in a solo party', async () => {\n      const leaderDetails = {\n        balance: 10\n      };\n      leaderDetails[`items.quests.${PET_QUEST}`] = 1;\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        },\n        leaderDetails\n      });\n      await groupLeader.post(`/groups/${group._id}/quests/invite/${PET_QUEST}`);\n      await group.sync();\n      expect(group.quest.active).to.eql(true);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"starts quest automatically if user is in a solo party and verifies chat","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation"],"updatePoint":{"line":164,"column":79,"index":6401},"line":164,"code":"    it('starts quest automatically if user is in a solo party and verifies chat', async () => {\n      const leaderDetails = {\n        balance: 10\n      };\n      leaderDetails[`items.quests.${PET_QUEST}`] = 1;\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        },\n        leaderDetails\n      });\n      await groupLeader.post(`/groups/${group._id}/quests/invite/${PET_QUEST}`);\n      const groupChat = await Chat.find({\n        groupId: group._id\n      }).exec();\n      expect(groupChat[0].text).to.exist;\n      expect(groupChat[0]._meta).to.exist;\n      expect(groupChat[0]._meta).to.have.all.keys(['participatingMembers']);\n      const returnedGroup = await groupLeader.get(`/groups/${group._id}`);\n      expect(returnedGroup.chat[0]._meta).to.be.undefined;\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"successfully issues a quest invitation when quest level is higher than user level","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation"],"updatePoint":{"line":189,"column":89,"index":7302},"line":189,"code":"    it('successfully issues a quest invitation when quest level is higher than user level', async () => {\n      const LEVELED_QUEST = 'atom1';\n      const LEVELED_QUEST_REQ = questScrolls[LEVELED_QUEST].lvl;\n      const leaderUpdate = {};\n      leaderUpdate[`items.quests.${LEVELED_QUEST}`] = 1;\n      leaderUpdate['stats.lvl'] = LEVELED_QUEST_REQ - 1;\n      await leader.update(leaderUpdate);\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${LEVELED_QUEST}`);\n    });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"sends quest invited webhook","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation","sending quest activity webhooks"],"updatePoint":{"line":205,"column":37,"index":7928},"line":205,"code":"      it('sends quest invited webhook', async () => {\n        const uuid = generateUUID();\n        await member.post('/user/webhook', {\n          url: `http://localhost:${server.port}/webhooks/${uuid}`,\n          type: 'questActivity',\n          enabled: true,\n          options: {\n            questInvited: true\n          }\n        });\n        await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n        await sleep();\n        const body = server.getWebhookData(uuid);\n        expect(body.type).to.eql('questInvited');\n        expect(body.group.id).to.eql(questingGroup.id);\n        expect(body.group.name).to.eql(questingGroup.name);\n        expect(body.quest.key).to.eql(PET_QUEST);\n      });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"sends quest invited webhook to the inviter too","suites":["POST /groups/:groupId/quests/invite/:questKey","successfully issuing a quest invitation","sending quest activity webhooks"],"updatePoint":{"line":223,"column":56,"index":8669},"line":223,"code":"      it('sends quest invited webhook to the inviter too', async () => {\n        const uuid = generateUUID();\n        await leader.post('/user/webhook', {\n          url: `http://localhost:${server.port}/webhooks/${uuid}`,\n          type: 'questActivity',\n          enabled: true,\n          options: {\n            questInvited: true\n          }\n        });\n        await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n        await sleep();\n        const body = server.getWebhookData(uuid);\n        expect(body.type).to.eql('questInvited');\n        expect(body.group.id).to.eql(questingGroup.id);\n        expect(body.group.name).to.eql(questingGroup.name);\n        expect(body.quest.key).to.eql(PET_QUEST);\n        expect(body.quest.questOwner).to.eql(questingGroup.leader._id);\n      });","file":"api/v3/integration/quests/POST-groups_groupId_quests_invite.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is not found","suites":["POST /groups/:groupId/quests/leave","failure conditions"],"updatePoint":{"line":30,"column":48,"index":817},"line":30,"code":"    it('returns an error when group is not found', async () => {\n      await expect(partyMembers[0].post(`/groups/${generateUUID()}/quests/leave`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_leave.test.js","skipped":false,"dir":"test"},{"name":"returns an error for a group in which user is not a member","suites":["POST /groups/:groupId/quests/leave","failure conditions"],"updatePoint":{"line":37,"column":66,"index":1119},"line":37,"code":"    it('returns an error for a group in which user is not a member', async () => {\n      await expect(user.post(`/groups/${questingGroup._id}/quests/leave`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_leave.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is a guild","suites":["POST /groups/:groupId/quests/leave","failure conditions"],"updatePoint":{"line":44,"column":46,"index":1393},"line":44,"code":"    it('returns an error when group is a guild', async () => {\n      const {\n        group: guild,\n        groupLeader: guildLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'private'\n        }\n      });\n      await expect(guildLeader.post(`/groups/${guild._id}/quests/leave`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('guildQuestsNotSupported')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_leave.test.js","skipped":false,"dir":"test"},{"name":"returns an error when quest leader attempts to leave","suites":["POST /groups/:groupId/quests/leave","failure conditions"],"updatePoint":{"line":60,"column":60,"index":1903},"line":60,"code":"    it('returns an error when quest leader attempts to leave', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(leader.post(`/groups/${questingGroup._id}/quests/leave`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('questLeaderCannotLeaveQuest')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_leave.test.js","skipped":false,"dir":"test"},{"name":"returns an error when non quest member attempts to leave","suites":["POST /groups/:groupId/quests/leave","failure conditions"],"updatePoint":{"line":70,"column":64,"index":2460},"line":70,"code":"    it('returns an error when non quest member attempts to leave', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/reject`);\n      await expect(partyMembers[1].post(`/groups/${questingGroup._id}/quests/leave`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('notPartOfQuest')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_leave.test.js","skipped":false,"dir":"test"},{"name":"leaves an active quest","suites":["POST /groups/:groupId/quests/leave","failure conditions"],"updatePoint":{"line":100,"column":28,"index":3569},"line":100,"code":"  it('leaves an active quest', async () => {\n    await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n    await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n    await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n    await questingGroup.sync();\n    expect(questingGroup.quest.active).to.eql(true);\n    await letPartyMemberLeaveAndCheckChanges(partyMembers[0]);\n  });","file":"api/v3/integration/quests/POST-groups_groupid_quests_leave.test.js","skipped":false,"dir":"test"},{"name":"leaves an inactive quest ","suites":["POST /groups/:groupId/quests/leave","failure conditions"],"updatePoint":{"line":108,"column":31,"index":4009},"line":108,"code":"  it('leaves an inactive quest ', async () => {\n    await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n    await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n    await questingGroup.sync();\n    expect(questingGroup.quest.active).to.eql(false);\n    await letPartyMemberLeaveAndCheckChanges(partyMembers[0]);\n  });","file":"api/v3/integration/quests/POST-groups_groupid_quests_leave.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is not found","suites":["POST /groups/:groupId/quests/reject","failure conditions"],"updatePoint":{"line":31,"column":48,"index":907},"line":31,"code":"    it('returns an error when group is not found', async () => {\n      await expect(partyMembers[0].post(`/groups/${generateUUID()}/quests/reject`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"does not accept quest for a group in which user is not a member","suites":["POST /groups/:groupId/quests/reject","failure conditions"],"updatePoint":{"line":38,"column":71,"index":1215},"line":38,"code":"    it('does not accept quest for a group in which user is not a member', async () => {\n      await expect(user.post(`/groups/${questingGroup._id}/quests/accept`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('groupNotFound')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is a guild","suites":["POST /groups/:groupId/quests/reject","failure conditions"],"updatePoint":{"line":45,"column":46,"index":1490},"line":45,"code":"    it('returns an error when group is a guild', async () => {\n      const {\n        group: guild,\n        groupLeader: guildLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'private'\n        }\n      });\n      await expect(guildLeader.post(`/groups/${guild._id}/quests/reject`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('guildQuestsNotSupported')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"returns an error when group is not on a quest","suites":["POST /groups/:groupId/quests/reject","failure conditions"],"updatePoint":{"line":61,"column":53,"index":1994},"line":61,"code":"    it('returns an error when group is not on a quest', async () => {\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/reject`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('questInvitationDoesNotExist')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"return an error when a user rejects an invite twice","suites":["POST /groups/:groupId/quests/reject","failure conditions"],"updatePoint":{"line":68,"column":59,"index":2307},"line":68,"code":"    it('return an error when a user rejects an invite twice', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/reject`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/reject`)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('questAlreadyRejected')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"clears the user rsvp needed if the request fails because the request is invalid","suites":["POST /groups/:groupId/quests/reject","failure conditions"],"updatePoint":{"line":77,"column":87,"index":2807},"line":77,"code":"    it('clears the user rsvp needed if the request fails because the request is invalid', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/reject`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/reject`)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('questAlreadyRejected')\n      });\n      await partyMembers[0].sync();\n      expect(partyMembers[0].party.quest.RSVPNeeded).to.be.false;\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"return an error when a user rejects an invite already accepted","suites":["POST /groups/:groupId/quests/reject","failure conditions"],"updatePoint":{"line":88,"column":70,"index":3392},"line":88,"code":"    it('return an error when a user rejects an invite already accepted', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/reject`)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('questAlreadyAccepted')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"does not reject invite for a quest already underway","suites":["POST /groups/:groupId/quests/reject","failure conditions"],"updatePoint":{"line":97,"column":59,"index":3864},"line":97,"code":"    it('does not reject invite for a quest already underway', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`); // quest will start after everyone has accepted\n\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/accept`);\n      await expect(partyMembers[0].post(`/groups/${questingGroup._id}/quests/reject`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('questAlreadyStartedFriendly')\n      });\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"rejects a quest invitation","suites":["POST /groups/:groupId/quests/reject","successfully quest rejection"],"updatePoint":{"line":121,"column":34,"index":4715},"line":121,"code":"    it('rejects a quest invitation', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      const res = await partyMembers[0].post(`/groups/${questingGroup._id}/quests/reject`);\n      await partyMembers[0].sync();\n      await questingGroup.sync();\n      expect(partyMembers[0].party.quest).to.eql(cleanUserQuestObj);\n      expect(questingGroup.quest.members[partyMembers[0]._id]).to.be.false;\n      expect(questingGroup.quest.active).to.be.false;\n      expect(res).to.eql(questingGroup.quest);\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"starts the quest when the last user reject","suites":["POST /groups/:groupId/quests/reject","successfully quest rejection"],"updatePoint":{"line":131,"column":50,"index":5282},"line":131,"code":"    it('starts the quest when the last user reject', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/reject`);\n      await questingGroup.sync();\n      expect(questingGroup.quest.active).to.be.true;\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"cleans up user quest data for non-quest members when last member rejects","suites":["POST /groups/:groupId/quests/reject","successfully quest rejection"],"updatePoint":{"line":138,"column":80,"index":5718},"line":138,"code":"    it('cleans up user quest data for non-quest members when last member rejects', async () => {\n      const rejectingMember = partyMembers[1];\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`); // quest will start after everyone has accepted or rejected\n\n      await rejectingMember.post(`/groups/${questingGroup._id}/quests/reject`);\n      await sleep(0.5);\n      await questingGroup.sync();\n      expect(questingGroup.quest.active).to.be.true;\n      await rejectingMember.sync();\n      expect(rejectingMember.party.quest.RSVPNeeded).to.eql(false);\n      expect(rejectingMember.party.quest.key).to.not.exist;\n      expect(rejectingMember.party.quest.completed).to.not.exist;\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"starts the quest when the last user reject and verifies chat","suites":["POST /groups/:groupId/quests/reject","successfully quest rejection"],"updatePoint":{"line":152,"column":68,"index":6504},"line":152,"code":"    it('starts the quest when the last user reject and verifies chat', async () => {\n      await leader.post(`/groups/${questingGroup._id}/quests/invite/${PET_QUEST}`);\n      await partyMembers[0].post(`/groups/${questingGroup._id}/quests/accept`);\n      await partyMembers[1].post(`/groups/${questingGroup._id}/quests/reject`);\n      const groupChat = await Chat.find({\n        groupId: questingGroup._id\n      }).exec();\n      expect(groupChat[0].text).to.exist;\n      expect(groupChat[0]._meta).to.exist;\n      expect(groupChat[0]._meta).to.have.all.keys(['participatingMembers']);\n      const returnedGroup = await leader.get(`/groups/${questingGroup._id}`);\n      expect(returnedGroup.chat[0]._meta).to.be.undefined;\n    });","file":"api/v3/integration/quests/POST-groups_groupid_quests_reject.test.js","skipped":false,"dir":"test"},{"name":"returns a valid shop object","suites":["GET /shops/backgrounds"],"updatePoint":{"line":7,"column":33,"index":242},"line":7,"code":"  it('returns a valid shop object', async () => {\n    const shop = await user.get('/shops/backgrounds');\n    expect(shop.identifier).to.equal('backgroundShop');\n    expect(shop.text).to.eql(t('backgroundShop'));\n    expect(shop.notes).to.eql(t('backgroundShop'));\n    expect(shop.imageName).to.equal('background_shop');\n    expect(shop.sets).to.be.an('array');\n    const sets = shop.sets.map(set => set.identifier);\n    expect(sets).to.include('incentiveBackgrounds');\n    expect(sets).to.include('backgrounds062014');\n  });","file":"api/v3/integration/shops/GET-shops_backgrounds.test.js","skipped":false,"dir":"test"},{"name":"returns a valid shop object","suites":["GET /shops/market"],"updatePoint":{"line":7,"column":33,"index":237},"line":7,"code":"  it('returns a valid shop object', async () => {\n    const shop = await user.get('/shops/market');\n    expect(shop.identifier).to.equal('market');\n    expect(shop.text).to.eql(t('market'));\n    expect(shop.notes).to.eql(t('welcomeMarketMobile'));\n    expect(shop.imageName).to.be.a('string');\n    expect(shop.categories).to.be.an('array');\n    const categories = shop.categories.map(cat => cat.identifier);\n    expect(categories).to.include('eggs');\n    expect(categories).to.include('hatchingPotions');\n    expect(categories).to.include('food');\n  });","file":"api/v3/integration/shops/GET-shops_market.test.js","skipped":false,"dir":"test"},{"name":"can purchase anything returned from the shops object using the /user/purchase route","suites":["GET /shops/market"],"updatePoint":{"line":19,"column":89,"index":847},"line":19,"code":"  it('can purchase anything returned from the shops object using the /user/purchase route', async () => {\n    await user.update({\n      balance: 99999999,\n      'stats.gp': 99999999\n    });\n    const shop = await user.get('/shops/market');\n    const items = shop.categories.reduce((array, category) => {\n      category.items.forEach(item => {\n        array.push(item);\n      });\n      return array;\n    }, []);\n    const results = await Promise.all(items.map(item => {\n      const {\n        purchaseType,\n        key\n      } = item;\n      return user.post(`/user/purchase/${purchaseType}/${key}`);\n    }));\n    expect(results.length).to.be.greaterThan(0);\n    items.forEach(item => {\n      expect(item).to.include.keys('key', 'text', 'notes', 'class', 'value', 'currency');\n    });\n  });","file":"api/v3/integration/shops/GET-shops_market.test.js","skipped":false,"dir":"test"},{"name":"returns a valid shop object","suites":["GET /shops/quests"],"updatePoint":{"line":7,"column":33,"index":237},"line":7,"code":"  it('returns a valid shop object', async () => {\n    const shop = await user.get('/shops/quests');\n    expect(shop.identifier).to.equal('questShop');\n    expect(shop.text).to.eql(t('quests'));\n    expect(shop.notes).to.eql(t('ianTextMobile'));\n    expect(shop.imageName).to.be.a('string');\n    expect(shop.categories).to.be.an('array');\n    const categories = shop.categories.map(cat => cat.identifier);\n    expect(categories).to.include('unlockable');\n    expect(categories).to.include('gold');\n    expect(categories).to.include('pet');\n  });","file":"api/v3/integration/shops/GET-shops_quests.test.js","skipped":false,"dir":"test"},{"name":"returns a valid shop object","suites":["GET /shops/seasonal"],"updatePoint":{"line":7,"column":33,"index":239},"line":7,"code":"  it('returns a valid shop object', async () => {\n    const shop = await user.get('/shops/seasonal');\n    expect(shop.identifier).to.equal('seasonalShop');\n    expect(shop.text).to.eql(t('seasonalShop'));\n    expect(shop.notes).to.be.a('string');\n    expect(shop.imageName).to.be.a('string');\n    expect(shop.categories).to.be.an('array');\n  });","file":"api/v3/integration/shops/GET-shops_seasonal.test.js","skipped":false,"dir":"test"},{"name":"returns a valid shop object","suites":["GET /shops/time-travelers"],"updatePoint":{"line":7,"column":33,"index":245},"line":7,"code":"  it('returns a valid shop object', async () => {\n    const shop = await user.get('/shops/time-travelers');\n    expect(shop.identifier).to.equal('timeTravelersShop');\n    expect(shop.text).to.eql(t('timeTravelers'));\n    expect(shop.notes).to.be.a('string');\n    expect(shop.imageName).to.be.a('string');\n    expect(shop.categories).to.be.an('array');\n    const categories = shop.categories.map(cat => cat.identifier);\n    expect(categories).to.include('pets');\n    expect(categories).to.include('mounts');\n    expect(categories).to.include('201606');\n    const mammothPet = shop.categories.find(cat => cat.identifier === 'pets').items.find(pet => pet.key === 'Mammoth-Base');\n    const mantisShrimp = shop.categories.find(cat => cat.identifier === 'mounts').items.find(pet => pet.key === 'MantisShrimp-Base');\n    expect(mammothPet).to.exist;\n    expect(mantisShrimp).to.exist;\n  });","file":"api/v3/integration/shops/GET-shops_time_travelers.test.js","skipped":false,"dir":"test"},{"name":"returns active shop notes and imageName if user has trinkets","suites":["GET /shops/time-travelers"],"updatePoint":{"line":23,"column":66,"index":1163},"line":23,"code":"  it('returns active shop notes and imageName if user has trinkets', async () => {\n    await user.update({\n      'purchased.plan.consecutive.trinkets': 1\n    });\n    const shop = await user.get('/shops/time-travelers');\n    expect(shop.notes).to.eql(t('timeTravelersPopover'));\n    expect(shop.imageName).to.eql('npc_timetravelers_active');\n  });","file":"api/v3/integration/shops/GET-shops_time_travelers.test.js","skipped":false,"dir":"test"},{"name":"returns inactive shop notes and imageName if user has trinkets","suites":["GET /shops/time-travelers"],"updatePoint":{"line":31,"column":68,"index":1512},"line":31,"code":"  it('returns inactive shop notes and imageName if user has trinkets', async () => {\n    const shop = await user.get('/shops/time-travelers');\n    expect(shop.notes).to.eql(t('timeTravelersPopoverNoSubMobile'));\n    expect(shop.imageName).to.eql('npc_timetravelers');\n  });","file":"api/v3/integration/shops/GET-shops_time_travelers.test.js","skipped":false,"dir":"test"},{"name":"does not return mystery sets that are already owned","suites":["GET /shops/time-travelers"],"updatePoint":{"line":36,"column":57,"index":1775},"line":36,"code":"  it('does not return mystery sets that are already owned', async () => {\n    await user.update({\n      'items.gear.owned': {\n        head_mystery_201606: true,\n        // eslint-disable-line camelcase\n        armor_mystery_201606: true // eslint-disable-line camelcase\n\n      }\n    });\n    const shop = await user.get('/shops/time-travelers');\n    const categories = shop.categories.map(cat => cat.identifier);\n    expect(categories).to.not.include('201606');\n  });","file":"api/v3/integration/shops/GET-shops_time_travelers.test.js","skipped":false,"dir":"test"},{"name":"does not return pets and mounts that user already owns","suites":["GET /shops/time-travelers"],"updatePoint":{"line":49,"column":60,"index":2245},"line":49,"code":"  it('does not return pets and mounts that user already owns', async () => {\n    await user.update({\n      'items.mounts': {\n        'MantisShrimp-Base': true\n      },\n      'items.pets': {\n        'Mammoth-Base': 5\n      }\n    });\n    const shop = await user.get('/shops/time-travelers');\n    const mammothPet = shop.categories.find(cat => cat.identifier === 'pets').items.find(pet => pet.key === 'Mammoth-Base');\n    const mantisShrimp = shop.categories.find(cat => cat.identifier === 'mounts').items.find(pet => pet.key === 'MantisShrimp-Base');\n    expect(mammothPet).to.not.exist;\n    expect(mantisShrimp).to.not.exist;\n  });","file":"api/v3/integration/shops/GET-shops_time_travelers.test.js","skipped":false,"dir":"test"},{"name":"returns status: up","suites":["GET /status"],"updatePoint":{"line":3,"column":24,"index":125},"line":3,"code":"  it('returns status: up', async () => {\n    const res = await requester().get('/status');\n    expect(res).to.eql({\n      status: 'up'\n    });\n  });","file":"api/v3/integration/status/GET-status.test.js","skipped":false,"dir":"test"},{"name":"deletes a tag given it's id","suites":["DELETE /tags/:tagId"],"updatePoint":{"line":7,"column":34,"index":220},"line":7,"code":"  it('deletes a tag given it\\'s id', async () => {\n    const tagName = 'Tag 1';\n    const tag = await user.post('/tags', {\n      name: tagName\n    });\n    const numberOfTags = (await user.get('/tags')).length;\n    await user.del(`/tags/${tag.id}`);\n    const tags = await user.get('/tags');\n    const tagNames = tags.map(t => t.name);\n    expect(tags.length).to.equal(numberOfTags - 1);\n    expect(tagNames).to.not.include(tagName);\n  });","file":"api/v3/integration/tags/DELETE-tags_id.test.js","skipped":false,"dir":"test"},{"name":"returns a tag given it's id","suites":["GET /tags/:tagId"],"updatePoint":{"line":7,"column":34,"index":217},"line":7,"code":"  it('returns a tag given it\\'s id', async () => {\n    const createdTag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    const tag = await user.get(`/tags/${createdTag.id}`);\n    expect(tag).to.deep.equal(createdTag);\n  });","file":"api/v3/integration/tags/GET-tags_id.test.js","skipped":false,"dir":"test"},{"name":"handles non-existing tags","suites":["GET /tags/:tagId"],"updatePoint":{"line":14,"column":31,"index":450},"line":14,"code":"  it('handles non-existing tags');","file":"api/v3/integration/tags/GET-tags_id.test.js","skipped":false,"dir":"test"},{"name":"returns all user's tags","suites":["GET /tags"],"updatePoint":{"line":9,"column":30,"index":228},"line":9,"code":"  it('returns all user\\'s tags', async () => {\n    const tag1 = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    const tag2 = await user.post('/tags', {\n      name: 'Tag 2'\n    });\n    const tags = await user.get('/tags');\n    expect(tags.length).to.equal(2);\n    expect(tags[0].name).to.equal(tag1.name);\n    expect(tags[1].name).to.equal(tag2.name);\n  });","file":"api/v3/integration/tags/GET-tags.test.js","skipped":false,"dir":"test"},{"name":"returns error when no parameters are provided","suites":["POST /reorder-tags"],"updatePoint":{"line":9,"column":51,"index":274},"line":9,"code":"  it('returns error when no parameters are provided', async () => {\n    await expect(user.post('/reorder-tags')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/tags/POST-tag-reorder.test.js","skipped":false,"dir":"test"},{"name":"returns error when tag is not found","suites":["POST /reorder-tags"],"updatePoint":{"line":16,"column":41,"index":516},"line":16,"code":"  it('returns error when tag is not found', async () => {\n    await expect(user.post('/reorder-tags', {\n      tagId: 'fake-id',\n      to: 3\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('tagNotFound')\n    });\n  });","file":"api/v3/integration/tags/POST-tag-reorder.test.js","skipped":false,"dir":"test"},{"name":"updates tags","suites":["POST /reorder-tags"],"updatePoint":{"line":26,"column":18,"index":765},"line":26,"code":"  it('updates tags', async () => {\n    const tag1Name = 'Tag 1';\n    const tag2Name = 'Tag 2';\n    await user.post('/tags', {\n      name: tag1Name\n    });\n    await user.post('/tags', {\n      name: tag2Name\n    });\n    await user.sync();\n    await user.post('/reorder-tags', {\n      tagId: user.tags[0].id,\n      to: 1\n    });\n    await user.sync();\n    expect(user.tags[0].name).to.equal(tag2Name);\n    expect(user.tags[1].name).to.equal(tag1Name);\n  });","file":"api/v3/integration/tags/POST-tag-reorder.test.js","skipped":false,"dir":"test"},{"name":"creates a tag correctly","suites":["POST /tags"],"updatePoint":{"line":7,"column":29,"index":210},"line":7,"code":"  it('creates a tag correctly', async () => {\n    const tagName = 'Tag 1';\n    const createdTag = await user.post('/tags', {\n      name: tagName,\n      ignored: false\n    });\n    const tag = await user.get(`/tags/${createdTag.id}`);\n    expect(tag.name).to.equal(tagName);\n    expect(tag.ignored).to.not.exist;\n    expect(tag).to.deep.equal(createdTag);\n  });","file":"api/v3/integration/tags/POST-tags.test.js","skipped":false,"dir":"test"},{"name":"updates a tag given it's id","suites":["PUT /tags/:tagId"],"updatePoint":{"line":7,"column":34,"index":217},"line":7,"code":"  it('updates a tag given it\\'s id', async () => {\n    const updatedTagName = 'Tag updated';\n    let createdTag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    const updatedTag = await user.put(`/tags/${createdTag.id}`, {\n      name: updatedTagName,\n      ignored: true\n    });\n    createdTag = await user.get(`/tags/${updatedTag.id}`);\n    expect(updatedTag.name).to.equal(updatedTagName);\n    expect(updatedTag.ignored).to.not.exist;\n    expect(createdTag.name).to.equal(updatedTagName);\n    expect(createdTag.ignored).to.not.exist;\n  });","file":"api/v3/integration/tags/PUT-tags_id.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":13,"column":29,"index":512},"line":13,"code":"  it('fails on task not found', async () => {\n    await expect(user.del(`/tasks/${generateUUID()}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_challenge_challengeId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on checklist item not found","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":20,"column":39,"index":783},"line":20,"code":"  it('fails on checklist item not found', async () => {\n    const createdTask = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'daily',\n      text: 'daily with checklist'\n    });\n    await expect(user.del(`/tasks/${createdTask._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('checklistItemNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_challenge_challengeId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not a member of the challenge","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":31,"column":62,"index":1223},"line":31,"code":"  it('returns error when user is not a member of the challenge', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    const savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    const anotherUser = await generateUser();\n    await expect(anotherUser.del(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyChalLeaderEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_challenge_challengeId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"deletes a checklist item from a daily","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":47,"column":43,"index":1836},"line":47,"code":"  it('deletes a checklist item from a daily', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    await user.del(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`);\n    savedTask = await user.get(`/tasks/${task._id}`);\n    expect(savedTask.checklist.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_challenge_challengeId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"deletes a checklist item from a todo","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":60,"column":42,"index":2357},"line":60,"code":"  it('deletes a checklist item from a todo', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'todo',\n      text: 'Todo with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    await user.del(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`);\n    savedTask = await user.get(`/tasks/${task._id}`);\n    expect(savedTask.checklist.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_challenge_challengeId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"does not work with habits","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":73,"column":31,"index":2865},"line":73,"code":"  it('does not work with habits', async () => {\n    const habit = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.del(`/tasks/${habit._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_challenge_challengeId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"does not work with rewards","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":84,"column":32,"index":3266},"line":84,"code":"  it('does not work with rewards', async () => {\n    const reward = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.del(`/tasks/${reward._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_challenge_challengeId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"cannot delete a non-existent task","suites":["DELETE /tasks/:id"],"updatePoint":{"line":20,"column":39,"index":672},"line":20,"code":"  it('cannot delete a non-existent task', async () => {\n    await expect(user.del(`/tasks/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_id_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not leader of the challenge","suites":["DELETE /tasks/:id"],"updatePoint":{"line":27,"column":60,"index":936},"line":27,"code":"  it('returns error when user is not leader of the challenge', async () => {\n    const anotherUser = await generateUser();\n    await expect(anotherUser.del(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyChalLeaderEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_id_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"deletes a user's task","suites":["DELETE /tasks/:id"],"updatePoint":{"line":35,"column":28,"index":1224},"line":35,"code":"  it('deletes a user\\'s task', async () => {\n    await user.del(`/tasks/${task._id}`);\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_id_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns error when user attempts to delete an active challenge task","suites":["DELETE /tasks/:id","challenge member"],"updatePoint":{"line":62,"column":75,"index":2338},"line":62,"code":"    it('returns error when user attempts to delete an active challenge task', async () => {\n      await expect(anotherUser.del(`/tasks/${anotherUsersNewChallengeTaskID}`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('cantDeleteChallengeTasks')\n      });\n    });","file":"api/v3/integration/tasks/challenges/DELETE-tasks_id_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"allows user to delete challenge task after user leaves challenge","suites":["DELETE /tasks/:id","challenge member"],"updatePoint":{"line":69,"column":72,"index":2659},"line":69,"code":"    it('allows user to delete challenge task after user leaves challenge', async () => {\n      await anotherUser.post(`/challenges/${challenge._id}/leave`);\n      await anotherUser.del(`/tasks/${anotherUsersNewChallengeTaskID}`);\n      await expect(anotherUser.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageTaskNotFound')\n      });\n    }); // TODO for some reason this test fails on TravisCI,","file":"api/v3/integration/tasks/challenges/DELETE-tasks_id_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"allows user to delete challenge task after challenge task is broken","suites":["DELETE /tasks/:id","challenge member"],"updatePoint":{"line":80,"column":76,"index":3199},"line":80,"code":"    xit('allows user to delete challenge task after challenge task is broken', async () => {\n      await expect(user.del(`/tasks/${newChallengeTask._id}`));\n      await sleep(2);\n      await expect(anotherUser.del(`/tasks/${anotherUsersNewChallengeTaskID}`));\n      await sleep(2);\n      await expect(anotherUser.get(`/tasks/${anotherUsersNewChallengeTaskID}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageTaskNotFound')\n      });\n    });","skipped":true,"file":"api/v3/integration/tasks/challenges/DELETE-tasks_id_challenge_challengeId.test.js","dir":"test"},{"name":"returns error when challenge is not found","suites":["GET /tasks/challenge/:challengeId"],"updatePoint":{"line":40,"column":47,"index":1011},"line":40,"code":"  it('returns error when challenge is not found', async () => {\n    const dummyId = generateUUID();\n    await expect(user.get(`/tasks/challenge/${dummyId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/GET_tasks_challenge.id.test.js","skipped":false,"dir":"test"},{"name":"gets challenge tasks","suites":["GET /tasks/challenge/:challengeId",""],"updatePoint":{"line":55,"column":30,"index":1583},"line":55,"code":"      it('gets challenge tasks', async () => {\n        const getTask = await user.get(`/tasks/challenge/${challengeWithTask._id}`);\n        expect(getTask).to.eql(tasks);\n      });","file":"api/v3/integration/tasks/challenges/GET_tasks_challenge.id.test.js","skipped":false,"dir":"test"},{"name":"gets challenge tasks filtered by type","suites":["GET /tasks/challenge/:challengeId",""],"updatePoint":{"line":59,"column":47,"index":1781},"line":59,"code":"      it('gets challenge tasks filtered by type', async () => {\n        const challengeTasks = await user.get(`/tasks/challenge/${challengeWithTask._id}?type=${task.type}s`);\n        expect(challengeTasks).to.eql([task]);\n      });","file":"api/v3/integration/tasks/challenges/GET_tasks_challenge.id.test.js","skipped":false,"dir":"test"},{"name":"cannot get a task owned by someone else","suites":["GET /tasks/challenge/:challengeId",""],"updatePoint":{"line":63,"column":49,"index":2015},"line":63,"code":"      it('cannot get a task owned by someone else', async () => {\n        const anotherUser = await generateUser();\n        await expect(anotherUser.get(`/tasks/challenge/${challengeWithTask._id}`)).to.eventually.be.rejected.and.eql({\n          code: 404,\n          error: 'NotFound',\n          message: t('challengeNotFound')\n        });\n      });","file":"api/v3/integration/tasks/challenges/GET_tasks_challenge.id.test.js","skipped":false,"dir":"test"},{"name":"maintains challenge task order","suites":["GET /tasks/challenge/:challengeId",""],"updatePoint":{"line":73,"column":36,"index":2365},"line":73,"code":"  it('maintains challenge task order', async () => {\n    const orderedTasks = {};\n    Object.entries(tasksToTest).forEach(async (taskType, taskValue) => {\n      const results = [];\n\n      for (let i = 0; i < 5; i += 1) {\n        results.push(user.post(`/tasks/challenge/${challenge._id}`, taskValue));\n      }\n\n      const taskList = await Promise.all(results);\n      await user.post(`/tasks/${taskList[0]._id}/move/to/3`);\n      const firstTask = taskList.unshift();\n      taskList.splice(3, 0, firstTask);\n      orderedTasks[taskType] = taskList;\n    });\n    const results = await user.get(`/tasks/challenge/${challenge._id}`);\n    const resultTasks = {};\n    results.forEach(result => {\n      if (!resultTasks[result.type]) {\n        resultTasks[result.type] = [];\n      }\n\n      resultTasks[result.type].push(result);\n    });\n    Object.entries(orderedTasks).forEach((taskType, taskList) => {\n      expect(resultTasks[taskType]).to.eql(taskList);\n    });\n  });","file":"api/v3/integration/tasks/challenges/GET_tasks_challenge.id.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":13,"column":29,"index":503},"line":13,"code":"  it('fails on task not found', async () => {\n    await expect(user.post(`/tasks/${generateUUID()}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_challengeId_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not a member of the challenge","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":22,"column":62,"index":820},"line":22,"code":"  it('returns error when user is not a member of the challenge', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    const anotherUser = await generateUser();\n    await expect(anotherUser.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      ignored: false,\n      _id: 123\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyChalLeaderEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_challengeId_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"adds a checklist item to a daily","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":38,"column":38,"index":1343},"line":38,"code":"  it('adds a checklist item to a daily', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    const savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      ignored: false,\n      _id: 123\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('Checklist Item 1');\n    expect(savedTask.checklist[0].completed).to.equal(false);\n    expect(savedTask.checklist[0].id).to.be.a('string');\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n    expect(savedTask.checklist[0].ignored).to.be.an('undefined');\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_challengeId_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"adds a checklist item to a todo","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":55,"column":37,"index":2054},"line":55,"code":"  it('adds a checklist item to a todo', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'todo',\n      text: 'Todo with checklist'\n    });\n    const savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      ignored: false,\n      _id: 123\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('Checklist Item 1');\n    expect(savedTask.checklist[0].completed).to.equal(false);\n    expect(savedTask.checklist[0].id).to.be.a('string');\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n    expect(savedTask.checklist[0].ignored).to.be.an('undefined');\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_challengeId_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"does not add a checklist to habits","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":72,"column":40,"index":2766},"line":72,"code":"  it('does not add a checklist to habits', async () => {\n    const habit = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.post(`/tasks/${habit._id}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_challengeId_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"does not add a checklist to rewards","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":85,"column":41,"index":3199},"line":85,"code":"  it('does not add a checklist to rewards', async () => {\n    const reward = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.post(`/tasks/${reward._id}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_challengeId_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"returns error when challenge is not found","suites":["POST /tasks/challenge/:challengeId"],"updatePoint":{"line":26,"column":47,"index":829},"line":26,"code":"  it('returns error when challenge is not found', async () => {\n    const fakeChallengeId = generateUUID();\n    await expect(user.post(`/tasks/challenge/${fakeChallengeId}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('challengeNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_id.test.js","skipped":false,"dir":"test"},{"name":"allows leader to add tasks to a challenge when not a member","suites":["POST /tasks/challenge/:challengeId"],"updatePoint":{"line":40,"column":65,"index":1261},"line":40,"code":"  it('allows leader to add tasks to a challenge when not a member', async () => {\n    await user.post(`/challenges/${challenge._id}/leave`);\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    });\n    const {\n      tasksOrder\n    } = await user.get(`/challenges/${challenge._id}`);\n    expect(tasksOrder.habits).to.include(task.id);\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_id.test.js","skipped":false,"dir":"test"},{"name":"allows non-leader admin to add tasks to a challenge when not a member","suites":["POST /tasks/challenge/:challengeId"],"updatePoint":{"line":54,"column":75,"index":1734},"line":54,"code":"  it('allows non-leader admin to add tasks to a challenge when not a member', async () => {\n    const admin = await generateUser({\n      'contributor.admin': true\n    });\n    const task = await admin.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test habit from admin',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    });\n    const {\n      tasksOrder\n    } = await user.get(`/challenges/${challenge._id}`);\n    expect(tasksOrder.habits).to.include(task.id);\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when user tries to create task with a alias","suites":["POST /tasks/challenge/:challengeId"],"updatePoint":{"line":70,"column":63,"index":2227},"line":70,"code":"  it('returns error when user tries to create task with a alias', async () => {\n    await expect(user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      alias: 'a-alias'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'habit validation failed'\n    });\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when non leader tries to edit challenge","suites":["POST /tasks/challenge/:challengeId"],"updatePoint":{"line":81,"column":59,"index":2582},"line":81,"code":"  it('returns error when non leader tries to edit challenge', async () => {\n    const userThatIsNotLeaderOfChallenge = await generateUser({\n      challenges: [challenge._id]\n    });\n    await expect(userThatIsNotLeaderOfChallenge.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyChalLeaderEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_id.test.js","skipped":false,"dir":"test"},{"name":"creates a habit","suites":["POST /tasks/challenge/:challengeId"],"updatePoint":{"line":97,"column":21,"index":3067},"line":97,"code":"  it('creates a habit', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    });\n    const challengeWithTask = await user.get(`/challenges/${challenge._id}`);\n    const memberTasks = await user.get('/tasks/user');\n    const userChallengeTask = find(memberTasks, findUserChallengeTask);\n    expect(challengeWithTask.tasksOrder.habits.indexOf(task._id)).to.be.above(-1);\n    expect(task.challenge.id).to.equal(challenge._id);\n    expect(task.text).to.eql('test habit');\n    expect(task.notes).to.eql('1976');\n    expect(task.type).to.eql('habit');\n    expect(task.up).to.eql(false);\n    expect(task.down).to.eql(true);\n    expect(userChallengeTask.notes).to.eql(task.notes);\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_id.test.js","skipped":false,"dir":"test"},{"name":"creates a todo","suites":["POST /tasks/challenge/:challengeId"],"updatePoint":{"line":117,"column":20,"index":3882},"line":117,"code":"  it('creates a todo', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test todo',\n      type: 'todo',\n      notes: 1976\n    });\n    const challengeWithTask = await user.get(`/challenges/${challenge._id}`);\n    const memberTasks = await user.get('/tasks/user');\n    const userChallengeTask = find(memberTasks, findUserChallengeTask);\n    expect(challengeWithTask.tasksOrder.todos.indexOf(task._id)).to.be.above(-1);\n    expect(task.challenge.id).to.equal(challenge._id);\n    expect(task.text).to.eql('test todo');\n    expect(task.notes).to.eql('1976');\n    expect(task.type).to.eql('todo');\n    expect(userChallengeTask.notes).to.eql(task.notes);\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_id.test.js","skipped":false,"dir":"test"},{"name":"creates a daily","suites":["POST /tasks/challenge/:challengeId"],"updatePoint":{"line":133,"column":21,"index":4587},"line":133,"code":"  it('creates a daily', async () => {\n    const now = new Date();\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test daily',\n      type: 'daily',\n      notes: 1976,\n      frequency: 'daily',\n      everyX: 5,\n      startDate: now\n    });\n    const challengeWithTask = await user.get(`/challenges/${challenge._id}`);\n    const memberTasks = await user.get('/tasks/user');\n    const userChallengeTask = find(memberTasks, findUserChallengeTask);\n    expect(challengeWithTask.tasksOrder.dailys.indexOf(task._id)).to.be.above(-1);\n    expect(task.challenge.id).to.equal(challenge._id);\n    expect(task.text).to.eql('test daily');\n    expect(task.notes).to.eql('1976');\n    expect(task.type).to.eql('daily');\n    expect(task.frequency).to.eql('daily');\n    expect(task.everyX).to.eql(5);\n    expect(new Date(task.startDate)).to.eql(new Date(now.setHours(0, 0, 0, 0)));\n    expect(userChallengeTask.notes).to.eql(task.notes);\n  });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenge_id.test.js","skipped":false,"dir":"test"},{"name":"scores and adds history","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":26,"column":31,"index":939},"line":26,"code":"    it('scores and adds history', async () => {\n      await user.post(`/tasks/${usersChallengeTaskId}/score/up`);\n      const tasks = await user.get(`/tasks/challenge/${challenge._id}`);\n      const task = find(tasks, {\n        _id: habit._id\n      });\n      previousTaskHistory = task.history[0]; // eslint-disable-line prefer-destructuring, max-len\n\n      expect(task.value).to.equal(1);\n      expect(task.history).to.have.lengthOf(1);\n    });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenges_challengeId_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"should update the history","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":37,"column":33,"index":1387},"line":37,"code":"    it('should update the history', async () => {\n      await user.post(`/tasks/${usersChallengeTaskId}/score/up`);\n      const tasks = await user.get(`/tasks/challenge/${challenge._id}`);\n      const task = find(tasks, {\n        _id: habit._id\n      });\n      expect(task.history).to.have.lengthOf(1);\n      expect(task.history[0].date).to.not.equal(previousTaskHistory.date);\n      expect(task.history[0].value).to.not.equal(previousTaskHistory.value);\n    });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenges_challengeId_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"it scores and adds history","suites":["POST /tasks/:id/score/:direction","dailies"],"updatePoint":{"line":61,"column":34,"index":2311},"line":61,"code":"    it('it scores and adds history', async () => {\n      await user.post(`/tasks/${usersChallengeTaskId}/score/up`);\n      const tasks = await user.get(`/tasks/challenge/${challenge._id}`);\n      const task = find(tasks, {\n        _id: daily._id\n      });\n      previousTaskHistory = task.history[0]; // eslint-disable-line prefer-destructuring\n\n      expect(task.history).to.have.lengthOf(1);\n      expect(task.value).to.equal(1);\n    });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenges_challengeId_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"should update the history","suites":["POST /tasks/:id/score/:direction","dailies"],"updatePoint":{"line":72,"column":33,"index":2750},"line":72,"code":"    it('should update the history', async () => {\n      const newCron = new Date(2015, 11, 20);\n      await user.post('/debug/set-cron', {\n        lastCron: newCron\n      });\n      await user.post('/cron');\n      await user.post(`/tasks/${usersChallengeTaskId}/score/up`);\n      const tasks = await user.get(`/tasks/challenge/${challenge._id}`);\n      const task = find(tasks, {\n        _id: daily._id\n      });\n      expect(task.history).to.have.lengthOf(1);\n      expect(task.history[0].date).to.not.equal(previousTaskHistory.date);\n      expect(task.history[0].value).to.not.equal(previousTaskHistory.value);\n    });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenges_challengeId_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"scores but does not add history","suites":["POST /tasks/:id/score/:direction","todos"],"updatePoint":{"line":100,"column":39,"index":3800},"line":100,"code":"    it('scores but does not add history', async () => {\n      await user.post(`/tasks/${usersChallengeTaskId}/score/up`);\n      const tasks = await user.get(`/tasks/challenge/${challenge._id}`);\n      const task = find(tasks, {\n        _id: todo._id\n      });\n      expect(task.history).to.not.exist;\n      expect(task.value).to.equal(1);\n    });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenges_challengeId_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"does not score","suites":["POST /tasks/:id/score/:direction","rewards"],"updatePoint":{"line":122,"column":22,"index":4564},"line":122,"code":"    it('does not score', async () => {\n      await user.post(`/tasks/${usersChallengeTaskId}/score/up`);\n      const tasks = await user.get(`/tasks/challenge/${challenge._id}`);\n      const task = find(tasks, {\n        _id: reward._id\n      });\n      expect(task.history).to.not.exist;\n      expect(task.value).to.equal(0);\n    });","file":"api/v3/integration/tasks/challenges/POST-tasks_challenges_challengeId_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":13,"column":29,"index":509},"line":13,"code":"  it('fails on task not found', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'todo',\n      text: 'Todo with checklist'\n    });\n    await expect(user.put(`/tasks/${task._id}/checklist/${generateUUID()}`, {\n      text: 'updated',\n      completed: true,\n      _id: 123 // ignored\n\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('checklistItemNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId_tasksId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not a member of the challenge","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":29,"column":62,"index":1015},"line":29,"code":"  it('returns error when user is not a member of the challenge', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'todo',\n      text: 'Todo with checklist'\n    });\n    const savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    const anotherUser = await generateUser();\n    await expect(anotherUser.put(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`, {\n      text: 'updated',\n      completed: true,\n      _id: 123 // ignored\n\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyChalLeaderEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId_tasksId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"updates a checklist item on dailies","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":50,"column":41,"index":1706},"line":50,"code":"  it('updates a checklist item on dailies', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    savedTask = await user.put(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`, {\n      text: 'updated',\n      completed: true,\n      _id: 123 // ignored\n\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('updated');\n    expect(savedTask.checklist[0].completed).to.equal(true);\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n  });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId_tasksId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"updates a checklist item on todos","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":70,"column":39,"index":2445},"line":70,"code":"  it('updates a checklist item on todos', async () => {\n    const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n      type: 'todo',\n      text: 'Todo with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    savedTask = await user.put(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`, {\n      text: 'updated',\n      completed: true,\n      _id: 123 // ignored\n\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('updated');\n    expect(savedTask.checklist[0].completed).to.equal(true);\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n  });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId_tasksId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on habits","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":90,"column":21,"index":3164},"line":90,"code":"  it('fails on habits', async () => {\n    const habit = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.put(`/tasks/${habit._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId_tasksId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on rewards","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":101,"column":22,"index":3533},"line":101,"code":"  it('fails on rewards', async () => {\n    const reward = await user.post('/tasks/user', {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.put(`/tasks/${reward._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId_tasksId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":112,"column":29,"index":3913},"line":112,"code":"  it('fails on task not found', async () => {\n    await expect(user.put(`/tasks/${generateUUID()}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId_tasksId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on checklist item not found","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":119,"column":39,"index":4184},"line":119,"code":"  it('fails on checklist item not found', async () => {\n    const createdTask = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'daily with checklist'\n    });\n    await expect(user.put(`/tasks/${createdTask._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('checklistItemNotFound')\n    });\n  });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId_tasksId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"returns error when incorrect id is passed","suites":["PUT /tasks/:id","errors"],"updatePoint":{"line":23,"column":49,"index":788},"line":23,"code":"    it('returns error when incorrect id is passed', async () => {\n      await expect(user.put(`/tasks/${generateUUID()}`, {\n        text: 'some new text',\n        up: false,\n        down: false,\n        notes: 'some new notes'\n      })).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageTaskNotFound')\n      });\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not a member of the challenge","suites":["PUT /tasks/:id","errors"],"updatePoint":{"line":35,"column":64,"index":1182},"line":35,"code":"    it('returns error when user is not a member of the challenge', async () => {\n      const anotherUser = await generateUser();\n      await expect(anotherUser.put(`/tasks/${task._id}`, {\n        text: 'some new text',\n        up: false,\n        down: false,\n        notes: 'some new notes'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlyChalLeaderEditTasks')\n      });\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns error when user attempts to update task with a alias","suites":["PUT /tasks/:id","errors"],"updatePoint":{"line":48,"column":68,"index":1638},"line":48,"code":"    it('returns error when user attempts to update task with a alias', async () => {\n      await expect(user.put(`/tasks/${task._id}`, {\n        alias: 'a-alias'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'habit validation failed'\n      });\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"ignores setting _id, type, userId, history, createdAt,\n                        updatedAt, challenge, completed, streak,\n                        dateCompleted fields","suites":["PUT /tasks/:id","validates params"],"updatePoint":{"line":68,"column":44,"index":2282},"line":66,"code":"    it(`ignores setting _id, type, userId, history, createdAt,\n                        updatedAt, challenge, completed, streak,\n                        dateCompleted fields`, async () => {\n      const savedTask = await user.put(`/tasks/${task._id}`, {\n        _id: 123,\n        type: 'daily',\n        userId: 123,\n        history: [123],\n        createdAt: 'yesterday',\n        updatedAt: 'tomorrow',\n        challenge: 'no',\n        completed: true,\n        streak: 25,\n        dateCompleted: 'never',\n        value: 324 // ignored because not a reward\n\n      });\n      expect(savedTask._id).to.equal(task._id);\n      expect(savedTask.type).to.equal(task.type);\n      expect(savedTask.userId).to.equal(task.userId);\n      expect(savedTask.history).to.eql(task.history);\n      expect(savedTask.createdAt).to.equal(task.createdAt);\n      expect(new Date(savedTask.updatedAt)).to.be.greaterThan(new Date(task.updatedAt));\n      expect(savedTask.challenge._id).to.equal(task.challenge._id);\n      expect(savedTask.completed).to.equal(task.completed);\n      expect(savedTask.streak).to.equal(task.streak);\n      expect(savedTask.dateCompleted).to.equal(task.dateCompleted);\n      expect(savedTask.value).to.equal(task.value);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"ignores invalid fields","suites":["PUT /tasks/:id","validates params"],"updatePoint":{"line":95,"column":30,"index":3370},"line":95,"code":"    it('ignores invalid fields', async () => {\n      const savedTask = await user.put(`/tasks/${task._id}`, {\n        notValid: true\n      });\n      expect(savedTask.notValid).to.be.undefined;\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"updates a habit","suites":["PUT /tasks/:id","habits"],"updatePoint":{"line":111,"column":23,"index":3800},"line":111,"code":"    it('updates a habit', async () => {\n      const savedHabit = await user.put(`/tasks/${habit._id}`, {\n        text: 'some new text',\n        up: false,\n        down: false,\n        notes: 'some new notes'\n      });\n      expect(savedHabit.text).to.eql('some new text');\n      expect(savedHabit.notes).to.eql('some new notes');\n      expect(savedHabit.up).to.eql(false);\n      expect(savedHabit.down).to.eql(false);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"allows user to update their copy","suites":["PUT /tasks/:id","habits"],"updatePoint":{"line":123,"column":40,"index":4243},"line":123,"code":"    it('allows user to update their copy', async () => {\n      const userTasks = await user.get('/tasks/user');\n      const userChallengeTasks = userTasks.filter(task => task.challenge.id === challenge._id);\n      const userCopyOfChallengeTask = userChallengeTasks[0];\n      await user.put(`/tasks/${userCopyOfChallengeTask._id}`, {\n        notes: 'some new notes',\n        counterDown: 1,\n        counterUp: 2\n      });\n      const savedHabit = await user.get(`/tasks/${userCopyOfChallengeTask._id}`);\n      expect(savedHabit.notes).to.eql('some new notes');\n      expect(savedHabit.counterDown).to.eql(1);\n      expect(savedHabit.counterUp).to.eql(2);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"updates a todo","suites":["PUT /tasks/:id","todos"],"updatePoint":{"line":147,"column":22,"index":5118},"line":147,"code":"    it('updates a todo', async () => {\n      const savedTodo = await user.put(`/tasks/${todo._id}`, {\n        text: 'some new text',\n        notes: 'some new notes'\n      });\n      expect(savedTodo.text).to.eql('some new text');\n      expect(savedTodo.notes).to.eql('some new notes');\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"can update checklists (replace it)","suites":["PUT /tasks/:id","todos"],"updatePoint":{"line":155,"column":42,"index":5431},"line":155,"code":"    it('can update checklists (replace it)', async () => {\n      await user.put(`/tasks/${todo._id}`, {\n        checklist: [{\n          text: 123,\n          completed: false\n        }, {\n          text: 456,\n          completed: true\n        }]\n      });\n      const savedTodo = await user.put(`/tasks/${todo._id}`, {\n        checklist: [{\n          text: 789,\n          completed: false\n        }]\n      });\n      expect(savedTodo.checklist.length).to.equal(1);\n      expect(savedTodo.checklist[0].text).to.equal('789');\n      expect(savedTodo.checklist[0].completed).to.equal(false);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"can update tags (replace them)","suites":["PUT /tasks/:id","todos"],"updatePoint":{"line":175,"column":38,"index":6021},"line":175,"code":"    it('can update tags (replace them)', async () => {\n      const finalUUID = generateUUID();\n      await user.put(`/tasks/${todo._id}`, {\n        tags: [generateUUID(), generateUUID()]\n      });\n      const savedTodo = await user.put(`/tasks/${todo._id}`, {\n        tags: [finalUUID]\n      });\n      expect(savedTodo.tags.length).to.equal(1);\n      expect(savedTodo.tags[0]).to.equal(finalUUID);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"updates a daily","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":196,"column":23,"index":6648},"line":196,"code":"    it('updates a daily', async () => {\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        text: 'some new text',\n        notes: 'some new notes',\n        frequency: 'daily',\n        everyX: 5\n      });\n      expect(savedDaily.text).to.eql('some new text');\n      expect(savedDaily.notes).to.eql('some new notes');\n      expect(savedDaily.frequency).to.eql('daily');\n      expect(savedDaily.everyX).to.eql(5);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"can update checklists (replace it)","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":208,"column":42,"index":7107},"line":208,"code":"    it('can update checklists (replace it)', async () => {\n      await user.put(`/tasks/${daily._id}`, {\n        checklist: [{\n          text: 123,\n          completed: false\n        }, {\n          text: 456,\n          completed: true\n        }]\n      });\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        checklist: [{\n          text: 789,\n          completed: false\n        }]\n      });\n      expect(savedDaily.checklist.length).to.equal(1);\n      expect(savedDaily.checklist[0].text).to.equal('789');\n      expect(savedDaily.checklist[0].completed).to.equal(false);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"can update tags (replace them)","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":228,"column":38,"index":7703},"line":228,"code":"    it('can update tags (replace them)', async () => {\n      const finalUUID = generateUUID();\n      await user.put(`/tasks/${daily._id}`, {\n        tags: [generateUUID(), generateUUID()]\n      });\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        tags: [finalUUID]\n      });\n      expect(savedDaily.tags.length).to.equal(1);\n      expect(savedDaily.tags[0]).to.equal(finalUUID);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"updates repeat, even if frequency is set to daily","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":239,"column":57,"index":8133},"line":239,"code":"    it('updates repeat, even if frequency is set to daily', async () => {\n      await user.put(`/tasks/${daily._id}`, {\n        frequency: 'daily'\n      });\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        repeat: {\n          m: false,\n          su: false\n        }\n      });\n      expect(savedDaily.repeat).to.eql({\n        m: false,\n        t: true,\n        w: true,\n        th: true,\n        f: true,\n        s: true,\n        su: false\n      });\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"updates everyX, even if frequency is set to weekly","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":259,"column":58,"index":8615},"line":259,"code":"    it('updates everyX, even if frequency is set to weekly', async () => {\n      await user.put(`/tasks/${daily._id}`, {\n        frequency: 'weekly'\n      });\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        everyX: 5\n      });\n      expect(savedDaily.everyX).to.eql(5);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"defaults startDate to today if none date object is passed in","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":268,"column":68,"index":8928},"line":268,"code":"    it('defaults startDate to today if none date object is passed in', async () => {\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        frequency: 'weekly'\n      });\n      expect(new Date(savedDaily.startDate).getDay()).to.eql(new Date().getDay());\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"updates a reward","suites":["PUT /tasks/:id","rewards"],"updatePoint":{"line":285,"column":24,"index":9423},"line":285,"code":"    it('updates a reward', async () => {\n      const savedReward = await user.put(`/tasks/${reward._id}`, {\n        text: 'some new text',\n        notes: 'some new notes',\n        value: 11\n      });\n      expect(savedReward.text).to.eql('some new text');\n      expect(savedReward.notes).to.eql('some new notes');\n      expect(savedReward.value).to.eql(11);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"requires value to be coerced into a number","suites":["PUT /tasks/:id","rewards"],"updatePoint":{"line":295,"column":50,"index":9815},"line":295,"code":"    it('requires value to be coerced into a number', async () => {\n      const savedReward = await user.put(`/tasks/${reward._id}`, {\n        value: '100'\n      });\n      expect(savedReward.value).to.eql(100);\n    });","file":"api/v3/integration/tasks/challenges/PUT-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"deletes a checklist item","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":8,"column":30,"index":298},"line":8,"code":"  it('deletes a checklist item', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    await user.del(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`);\n    savedTask = await user.get(`/tasks/${task._id}`);\n    expect(savedTask.checklist.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/checklists/DELETE-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"deletes a checklist item using task alias","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":21,"column":47,"index":802},"line":21,"code":"  it('deletes a checklist item using task alias', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'Daily with checklist',\n      alias: 'daily-with-alias'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    await user.del(`/tasks/${task.alias}/checklist/${savedTask.checklist[0].id}`);\n    savedTask = await user.get(`/tasks/${task._id}`);\n    expect(savedTask.checklist.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/checklists/DELETE-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"does not work with habits","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":35,"column":31,"index":1325},"line":35,"code":"  it('does not work with habits', async () => {\n    const habit = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.del(`/tasks/${habit._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/checklists/DELETE-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"does not work with rewards","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":46,"column":32,"index":1704},"line":46,"code":"  it('does not work with rewards', async () => {\n    const reward = await user.post('/tasks/user', {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.del(`/tasks/${reward._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/checklists/DELETE-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":57,"column":29,"index":2084},"line":57,"code":"  it('fails on task not found', async () => {\n    await expect(user.del(`/tasks/${generateUUID()}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/checklists/DELETE-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on checklist item not found","suites":["DELETE /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":64,"column":39,"index":2355},"line":64,"code":"  it('fails on checklist item not found', async () => {\n    const createdTask = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'daily with checklist'\n    });\n    await expect(user.del(`/tasks/${createdTask._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('checklistItemNotFound')\n    });\n  });","file":"api/v3/integration/tasks/checklists/DELETE-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"scores a checklist item","suites":["POST /tasks/:taskId/checklist/:itemId/score"],"updatePoint":{"line":8,"column":29,"index":316},"line":8,"code":"  it('scores a checklist item', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    savedTask = await user.post(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}/score`);\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].completed).to.equal(true);\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist_itemId_score.test.js","skipped":false,"dir":"test"},{"name":"can use a alias to score a checklist item","suites":["POST /tasks/:taskId/checklist/:itemId/score"],"updatePoint":{"line":21,"column":47,"index":846},"line":21,"code":"  it('can use a alias to score a checklist item', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'Daily with checklist',\n      alias: 'daily-with-shortname'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    savedTask = await user.post(`/tasks/${task.alias}/checklist/${savedTask.checklist[0].id}/score`);\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].completed).to.equal(true);\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist_itemId_score.test.js","skipped":false,"dir":"test"},{"name":"fails on habits","suites":["POST /tasks/:taskId/checklist/:itemId/score"],"updatePoint":{"line":35,"column":21,"index":1389},"line":35,"code":"  it('fails on habits', async () => {\n    const habit = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.post(`/tasks/${habit._id}/checklist/${generateUUID()}/score`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist_itemId_score.test.js","skipped":false,"dir":"test"},{"name":"fails on rewards","suites":["POST /tasks/:taskId/checklist/:itemId/score"],"updatePoint":{"line":48,"column":22,"index":1805},"line":48,"code":"  it('fails on rewards', async () => {\n    const reward = await user.post('/tasks/user', {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.post(`/tasks/${reward._id}/checklist/${generateUUID()}/score`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist_itemId_score.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["POST /tasks/:taskId/checklist/:itemId/score"],"updatePoint":{"line":59,"column":29,"index":2192},"line":59,"code":"  it('fails on task not found', async () => {\n    await expect(user.post(`/tasks/${generateUUID()}/checklist/${generateUUID()}/score`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist_itemId_score.test.js","skipped":false,"dir":"test"},{"name":"fails on checklist item not found","suites":["POST /tasks/:taskId/checklist/:itemId/score"],"updatePoint":{"line":66,"column":39,"index":2470},"line":66,"code":"  it('fails on checklist item not found', async () => {\n    const createdTask = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'daily with checklist'\n    });\n    await expect(user.post(`/tasks/${createdTask._id}/checklist/${generateUUID()}/score`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('checklistItemNotFound')\n    });\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist_itemId_score.test.js","skipped":false,"dir":"test"},{"name":"sends task activity webhooks","suites":["POST /tasks/:taskId/checklist/:itemId/score","sending task activity webhooks"],"updatePoint":{"line":84,"column":36,"index":3042},"line":84,"code":"    it('sends task activity webhooks', async () => {\n      const uuid = generateUUID();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          checklistScored: true,\n          updated: false\n        }\n      });\n      const task = await user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily'\n      });\n      const updatedTask = await user.post(`/tasks/${task.id}/checklist`, {\n        text: 'checklist item text'\n      });\n      const checklistItem = updatedTask.checklist[0];\n      const scoredItemTask = await user.post(`/tasks/${task.id}/checklist/${checklistItem.id}/score`);\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(body.type).to.eql('checklistScored');\n      expect(body.task).to.eql(scoredItemTask);\n      expect(body.item).to.eql(scoredItemTask.checklist[0]);\n    });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist_itemId_score.test.js","skipped":false,"dir":"test"},{"name":"adds a checklist item to a task","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":8,"column":37,"index":296},"line":8,"code":"  it('adds a checklist item to a task', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    const savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      ignored: false,\n      _id: 123\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('Checklist Item 1');\n    expect(savedTask.checklist[0].completed).to.equal(false);\n    expect(savedTask.checklist[0].id).to.be.a('string');\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n    expect(savedTask.checklist[0].ignored).to.be.an('undefined');\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"can use a alias to add checklist","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":25,"column":38,"index":986},"line":25,"code":"  it('can use a alias to add checklist', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'Daily with checklist',\n      alias: 'task-with-shortname'\n    });\n    const savedTask = await user.post(`/tasks/${task.alias}/checklist`, {\n      text: 'Checklist Item 1',\n      ignored: false,\n      _id: 123\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('Checklist Item 1');\n    expect(savedTask.checklist[0].completed).to.equal(false);\n    expect(savedTask.checklist[0].id).to.be.a('string');\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n    expect(savedTask.checklist[0].ignored).to.be.an('undefined');\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"does not add a checklist to habits","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":43,"column":40,"index":1716},"line":43,"code":"  it('does not add a checklist to habits', async () => {\n    const habit = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.post(`/tasks/${habit._id}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"does not add a checklist to rewards","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":56,"column":41,"index":2127},"line":56,"code":"  it('does not add a checklist to rewards', async () => {\n    const reward = await user.post('/tasks/user', {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.post(`/tasks/${reward._id}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["POST /tasks/:taskId/checklist/"],"updatePoint":{"line":69,"column":29,"index":2530},"line":69,"code":"  it('fails on task not found', async () => {\n    await expect(user.post(`/tasks/${generateUUID()}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/checklists/POST-tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"updates a checklist item","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":8,"column":30,"index":295},"line":8,"code":"  it('updates a checklist item', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    savedTask = await user.put(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`, {\n      text: 'updated',\n      completed: true,\n      _id: 123 // ignored\n\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('updated');\n    expect(savedTask.checklist[0].completed).to.equal(true);\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n  });","file":"api/v3/integration/tasks/checklists/PUT-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"updates a checklist item using task alias","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":28,"column":47,"index":1020},"line":28,"code":"  it('updates a checklist item using task alias', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'Daily with checklist',\n      alias: 'daily-with-shortname'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    savedTask = await user.put(`/tasks/${task.alias}/checklist/${savedTask.checklist[0].id}`, {\n      text: 'updated',\n      completed: true,\n      _id: 123 // ignored\n\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('updated');\n    expect(savedTask.checklist[0].completed).to.equal(true);\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n  });","file":"api/v3/integration/tasks/checklists/PUT-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on habits","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":49,"column":21,"index":1758},"line":49,"code":"  it('fails on habits', async () => {\n    const habit = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.put(`/tasks/${habit._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/checklists/PUT-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on rewards","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":60,"column":22,"index":2127},"line":60,"code":"  it('fails on rewards', async () => {\n    const reward = await user.post('/tasks/user', {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.put(`/tasks/${reward._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/checklists/PUT-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":71,"column":29,"index":2507},"line":71,"code":"  it('fails on task not found', async () => {\n    await expect(user.put(`/tasks/${generateUUID()}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/checklists/PUT-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on checklist item not found","suites":["PUT /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":78,"column":39,"index":2778},"line":78,"code":"  it('fails on checklist item not found', async () => {\n    const createdTask = await user.post('/tasks/user', {\n      type: 'daily',\n      text: 'daily with checklist'\n    });\n    await expect(user.put(`/tasks/${createdTask._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('checklistItemNotFound')\n    });\n  });","file":"api/v3/integration/tasks/checklists/PUT-tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"deletes a user's task","suites":["DELETE /tasks/:id","task can be deleted"],"updatePoint":{"line":17,"column":30,"index":561},"line":17,"code":"    it('deletes a user\\'s task', async () => {\n      await user.del(`/tasks/${task._id}`);\n      await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageTaskNotFound')\n      });\n    });","file":"api/v3/integration/tasks/DELETE-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can use a alias to delete a task","suites":["DELETE /tasks/:id","task can be deleted"],"updatePoint":{"line":25,"column":40,"index":855},"line":25,"code":"    it('can use a alias to delete a task', async () => {\n      await user.del(`/tasks/${task.alias}`);\n      await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageTaskNotFound')\n      });\n    });","file":"api/v3/integration/tasks/DELETE-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"sends task activity webhooks if task is user owned","suites":["DELETE /tasks/:id","sending task activity webhooks"],"updatePoint":{"line":41,"column":58,"index":1348},"line":41,"code":"    it('sends task activity webhooks if task is user owned', async () => {\n      const uuid = generateUUID();\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          created: false,\n          deleted: true\n        }\n      });\n      await user.del(`/tasks/${task.id}`);\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(body.type).to.eql('deleted');\n      expect(body.task).to.eql(task);\n    });","file":"api/v3/integration/tasks/DELETE-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"does not send task activity webhooks if task is not user owned","suites":["DELETE /tasks/:id","sending task activity webhooks"],"updatePoint":{"line":62,"column":70,"index":2031},"line":62,"code":"    it('does not send task activity webhooks if task is not user owned', async () => {\n      const uuid = generateUUID();\n      await user.update({\n        balance: 10\n      });\n      const guild = await generateGroup(user);\n      const challenge = await generateChallenge(user, guild);\n      await user.post(`/challenges/${challenge._id}/join`);\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          created: false,\n          deleted: true\n        }\n      });\n      const challengeTask = await user.post(`/tasks/challenge/${challenge._id}`, {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await user.del(`/tasks/${challengeTask.id}`);\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(body).to.not.exist;\n    });","file":"api/v3/integration/tasks/DELETE-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"cannot delete a non-existent task","suites":["DELETE /tasks/:id","task cannot be deleted"],"updatePoint":{"line":90,"column":41,"index":2952},"line":90,"code":"    it('cannot delete a non-existent task', async () => {\n      await expect(user.del('/tasks/550e8400-e29b-41d4-a716-446655440000')).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageTaskNotFound')\n      });\n    });","file":"api/v3/integration/tasks/DELETE-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"cannot delete a task owned by someone else","suites":["DELETE /tasks/:id","task cannot be deleted"],"updatePoint":{"line":97,"column":50,"index":3237},"line":97,"code":"    it('cannot delete a task owned by someone else', async () => {\n      const anotherUser = await generateUser();\n      const anotherUsersTask = await anotherUser.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await expect(user.del(`/tasks/${anotherUsersTask._id}`)).to.eventually.be.rejected.and.eql({\n        code: 404,\n        error: 'NotFound',\n        message: t('messageTaskNotFound')\n      });\n    });","file":"api/v3/integration/tasks/DELETE-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"removes a task from user.tasksOrder","suites":["DELETE /tasks/:id","task cannot be deleted"],"updatePoint":{"line":109,"column":43,"index":3681},"line":109,"code":"    it('removes a task from user.tasksOrder', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await user.del(`/tasks/${task._id}`);\n      await user.sync();\n      expect(user.tasksOrder.habits.indexOf(task._id)).to.eql(-1);\n    });","file":"api/v3/integration/tasks/DELETE-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when incorrect id is passed","suites":["GET /tasks/:taskId"],"updatePoint":{"line":38,"column":47,"index":948},"line":38,"code":"  it('returns error when incorrect id is passed', async () => {\n    await expect(user.get(`/tasks/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/GET-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"gets challenge task","suites":["GET /tasks/:taskId",""],"updatePoint":{"line":50,"column":29,"index":1380},"line":50,"code":"      it('gets challenge task', async () => {\n        const getTask = await user.get(`/tasks/${task._id}`);\n        expect(getTask).to.eql(task);\n      });","file":"api/v3/integration/tasks/GET-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not a member of the challenge","suites":["GET /tasks/:taskId",""],"updatePoint":{"line":54,"column":66,"index":1573},"line":54,"code":"      it('returns error when user is not a member of the challenge', async () => {\n        const anotherUser = await generateUser();\n        await expect(anotherUser.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n          code: 404,\n          error: 'NotFound',\n          message: t('messageTaskNotFound')\n        });\n      });","file":"api/v3/integration/tasks/GET-tasks_challenge_challengeId.test.js","skipped":false,"dir":"test"},{"name":"cannot get a non-existent task","suites":["GET /tasks/:id","general","task cannot be accessed"],"updatePoint":{"line":10,"column":40,"index":403},"line":10,"code":"      it('cannot get a non-existent task', async () => {\n        const dummyId = generateUUID();\n        await expect(user.get(`/tasks/${dummyId}`)).to.eventually.be.rejected.and.eql({\n          code: 404,\n          error: 'NotFound',\n          message: t('messageTaskNotFound')\n        });\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"gets specified task","suites":["GET /tasks/:id","user","task can be accessed"],"updatePoint":{"line":30,"column":29,"index":980},"line":30,"code":"      it('gets specified task', async () => {\n        const getTask = await user.get(`/tasks/${task._id}`);\n        expect(getTask).to.eql(task);\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can use alias to retrieve task","suites":["GET /tasks/:id","user","task can be accessed"],"updatePoint":{"line":34,"column":40,"index":1147},"line":34,"code":"      it('can use alias to retrieve task', async () => {\n        const getTask = await user.get(`/tasks/${task.alias}`);\n        expect(getTask).to.eql(task);\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"cannot get a task owned by someone else","suites":["GET /tasks/:id","user","task cannot be accessed"],"updatePoint":{"line":40,"column":49,"index":1380},"line":40,"code":"      it('cannot get a task owned by someone else', async () => {\n        const anotherUser = await generateUser();\n        const task = await user.post('/tasks/user', {\n          text: 'test habit',\n          type: 'habit'\n        });\n        await expect(anotherUser.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n          code: 404,\n          error: 'NotFound',\n          message: t('messageTaskNotFound')\n        });\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can get challenge task if member of that challenge","suites":["GET /tasks/:id","challenge","task can be accessed"],"updatePoint":{"line":75,"column":60,"index":2543},"line":75,"code":"      it('can get challenge task if member of that challenge', async () => {\n        await member.post(`/challenges/${challenge._id}/join`);\n        const getTask = await member.get(`/tasks/${task._id}`);\n        expect(getTask).to.eql(task);\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can get challenge task if leader of that challenge","suites":["GET /tasks/:id","challenge","task can be accessed"],"updatePoint":{"line":80,"column":60,"index":2796},"line":80,"code":"      it('can get challenge task if leader of that challenge', async () => {\n        const getTask = await leader.get(`/tasks/${task._id}`);\n        expect(getTask).to.eql(task);\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can get challenge task if admin","suites":["GET /tasks/:id","challenge","task can be accessed"],"updatePoint":{"line":84,"column":41,"index":2966},"line":84,"code":"      it('can get challenge task if admin', async () => {\n        const admin = await generateUser({\n          'contributor.admin': true\n        });\n        const getTask = await admin.get(`/tasks/${task._id}`);\n        expect(getTask).to.eql(task);\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"cannot get a task in a challenge i am not part of","suites":["GET /tasks/:id","challenge","task cannot be accessed"],"updatePoint":{"line":93,"column":59,"index":3299},"line":93,"code":"      it('cannot get a task in a challenge i am not part of', async () => {\n        await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n          code: 404,\n          error: 'NotFound',\n          message: t('messageTaskNotFound')\n        });\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can get group task if leader of that group","suites":["GET /tasks/:id","group","task can be accessed"],"updatePoint":{"line":124,"column":52,"index":4158},"line":124,"code":"      it('can get group task if leader of that group', async () => {\n        const getTask = await leader.get(`/tasks/${task._id}`);\n        expect(getTask).to.eql(task);\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can get group task if member of that group","suites":["GET /tasks/:id","group","task can be accessed"],"updatePoint":{"line":128,"column":52,"index":4339},"line":128,"code":"      it('can get group task if member of that group', async () => {\n        const getTask = await members[0].get(`/tasks/${task._id}`);\n        expect(getTask).to.eql(task);\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"cannot get a task in a group i am not part of","suites":["GET /tasks/:id","group","task cannot be accessed"],"updatePoint":{"line":134,"column":55,"index":4582},"line":134,"code":"      it('cannot get a task in a group i am not part of', async () => {\n        await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n          code: 404,\n          error: 'NotFound',\n          message: t('messageTaskNotFound')\n        });\n      });","file":"api/v3/integration/tasks/GET-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"returns all user's tasks","suites":["GET /tasks/user"],"updatePoint":{"line":8,"column":31,"index":246},"line":8,"code":"  it('returns all user\\'s tasks', async () => {\n    const createdTasks = await user.post('/tasks/user', [{\n      text: 'test habit',\n      type: 'habit'\n    }, {\n      text: 'test todo',\n      type: 'todo'\n    }]);\n    const tasks = await user.get('/tasks/user');\n    expect(tasks.length).to.equal(createdTasks.length + 1); // Plus one for generated todo\n  });","file":"api/v3/integration/tasks/GET-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns only a type of user's tasks if req.query.type is specified","suites":["GET /tasks/user"],"updatePoint":{"line":19,"column":73,"index":649},"line":19,"code":"  it('returns only a type of user\\'s tasks if req.query.type is specified', async () => {\n    const createdTasks = await user.post('/tasks/user', [{\n      text: 'test habit',\n      type: 'habit'\n    }, {\n      text: 'test daily',\n      type: 'daily'\n    }, {\n      text: 'test reward',\n      type: 'reward'\n    }, {\n      text: 'test todo',\n      type: 'todo'\n    }]);\n    const habits = await user.get('/tasks/user?type=habits');\n    const dailys = await user.get('/tasks/user?type=dailys');\n    const rewards = await user.get('/tasks/user?type=rewards');\n    expect(habits.length).to.be.at.least(1);\n    expect(habits[0]._id).to.equal(createdTasks[0]._id);\n    expect(dailys.length).to.be.at.least(1);\n    expect(dailys[0]._id).to.equal(createdTasks[1]._id);\n    expect(rewards.length).to.be.at.least(1);\n    expect(rewards[0]._id).to.equal(createdTasks[2]._id);\n  });","file":"api/v3/integration/tasks/GET-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns uncompleted todos if req.query.type is \"todos\"","suites":["GET /tasks/user"],"updatePoint":{"line":43,"column":60,"index":1507},"line":43,"code":"  it('returns uncompleted todos if req.query.type is \"todos\"', async () => {\n    const existingTodos = await user.get('/tasks/user?type=todos'); // populate user with other task types\n\n    await user.post('/tasks/user', [{\n      text: 'daily',\n      type: 'daily'\n    }, {\n      text: 'reward',\n      type: 'reward'\n    }, {\n      text: 'habit',\n      type: 'habit'\n    }]);\n    const newUncompletedTodos = await user.post('/tasks/user', [{\n      text: 'test todo 1',\n      type: 'todo'\n    }, {\n      text: 'test todo 2',\n      type: 'todo'\n    }]);\n    const todoToBeCompleted = await user.post('/tasks/user', {\n      text: 'wll be completed todo',\n      type: 'todo'\n    });\n    await user.post(`/tasks/${todoToBeCompleted._id}/score/up`);\n    const uncompletedTodos = [...existingTodos, ...newUncompletedTodos];\n    const todos = await user.get('/tasks/user?type=todos');\n    expect(todos.length).to.be.gte(2);\n    expect(todos.length).to.eql(uncompletedTodos.length);\n    expect(todos.every(task => task.type === 'todo'));\n    expect(todos.every(task => task.completed === false));\n  });","file":"api/v3/integration/tasks/GET-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns completed todos sorted by reverse completion date if req.query.type is \"completedTodos\"","suites":["GET /tasks/user"],"updatePoint":{"line":75,"column":101,"index":2641},"line":75,"code":"  it('returns completed todos sorted by reverse completion date if req.query.type is \"completedTodos\"', async () => {\n    const todo1 = await user.post('/tasks/user', {\n      text: 'todo to complete 1',\n      type: 'todo'\n    });\n    const todo2 = await user.post('/tasks/user', {\n      text: 'todo to complete 2',\n      type: 'todo'\n    });\n    await user.sync();\n    const initialTodoCount = user.tasksOrder.todos.length;\n    await user.post(`/tasks/${todo2._id}/score/up`);\n    await user.post(`/tasks/${todo1._id}/score/up`);\n    await user.sync();\n    expect(user.tasksOrder.todos.length).to.equal(initialTodoCount - 2);\n    const completedTodos = await user.get('/tasks/user?type=completedTodos');\n    expect(completedTodos.length).to.equal(2);\n    expect(completedTodos[completedTodos.length - 1].text).to.equal('todo to complete 2'); // last is the todo that was completed most recently\n  });","file":"api/v3/integration/tasks/GET-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns completed todos sorted by reverse completion date if req.query.type is \"_allCompletedTodos\"","suites":["GET /tasks/user"],"updatePoint":{"line":94,"column":105,"index":3546},"line":94,"code":"  it('returns completed todos sorted by reverse completion date if req.query.type is \"_allCompletedTodos\"', async () => {\n    const todo1 = await user.post('/tasks/user', {\n      text: 'todo to complete 1',\n      type: 'todo'\n    });\n    const todo2 = await user.post('/tasks/user', {\n      text: 'todo to complete 2',\n      type: 'todo'\n    });\n    await user.sync();\n    const initialTodoCount = user.tasksOrder.todos.length;\n    await user.post(`/tasks/${todo2._id}/score/up`);\n    await user.post(`/tasks/${todo1._id}/score/up`);\n    await user.sync();\n    expect(user.tasksOrder.todos.length).to.equal(initialTodoCount - 2);\n    const allCompletedTodos = await user.get('/tasks/user?type=_allCompletedTodos');\n    expect(allCompletedTodos.length).to.equal(2);\n    expect(allCompletedTodos[allCompletedTodos.length - 1].text).to.equal('todo to complete 2');\n  });","file":"api/v3/integration/tasks/GET-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns only some completed todos if req.query.type is \"completedTodos\" or \"_allCompletedTodos\"","suites":["GET /tasks/user"],"updatePoint":{"line":113,"column":101,"index":4410},"line":113,"code":"  it('returns only some completed todos if req.query.type is \"completedTodos\" or \"_allCompletedTodos\"', async () => {\n    const LIMIT = 30;\n    const numberOfTodos = LIMIT + 1;\n    const todosInput = [];\n\n    for (let i = 0; i < numberOfTodos; i += 1) {\n      todosInput[i] = {\n        text: `todo to complete ${i}`,\n        type: 'todo'\n      };\n    }\n\n    const todos = await user.post('/tasks/user', todosInput);\n    await user.sync();\n    const initialTodoCount = user.tasksOrder.todos.length;\n\n    for (let i = 0; i < numberOfTodos; i += 1) {\n      const id = todos[i]._id;\n      await user.post(`/tasks/${id}/score/up`); // eslint-disable-line no-await-in-loop\n    }\n\n    await user.sync();\n    expect(user.tasksOrder.todos.length).to.equal(initialTodoCount - numberOfTodos);\n    const completedTodos = await user.get('/tasks/user?type=completedTodos');\n    expect(completedTodos.length).to.equal(LIMIT);\n    const allCompletedTodos = await user.get('/tasks/user?type=_allCompletedTodos');\n    expect(allCompletedTodos.length).to.equal(numberOfTodos);\n  });","file":"api/v3/integration/tasks/GET-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns dailies with isDue for the date specified","suites":["GET /tasks/user"],"updatePoint":{"line":141,"column":55,"index":5428},"line":141,"code":"  it('returns dailies with isDue for the date specified', async () => {\n    // @TODO Add required format\n    const startDate = moment().subtract('1', 'days').toISOString();\n    const createdTasks = await user.post('/tasks/user', [{\n      text: 'test daily',\n      type: 'daily',\n      startDate,\n      frequency: 'daily',\n      everyX: 2\n    }]);\n    const dailys = await user.get('/tasks/user?type=dailys');\n    expect(dailys.length).to.be.at.least(1);\n    expect(dailys[0]._id).to.equal(createdTasks._id);\n    expect(dailys[0].isDue).to.be.false;\n    const dailys2 = await user.get(`/tasks/user?type=dailys&dueDate=${startDate}`);\n    expect(dailys2[0]._id).to.equal(createdTasks._id);\n    expect(dailys2[0].isDue).to.be.true;\n  });","file":"api/v3/integration/tasks/GET-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns dailies with isDue for the date specified and will add CDS offset if time is not supplied and assumes timezones","suites":["GET /tasks/user"],"updatePoint":{"line":159,"column":126,"index":6234},"line":159,"code":"  xit('returns dailies with isDue for the date specified and will add CDS offset if time is not supplied and assumes timezones', async () => {\n    const timezoneOffset = 420;\n    await user.update({\n      'preferences.dayStart': 0,\n      'preferences.timezoneOffset': timezoneOffset\n    });\n    const startDate = moment().utcOffset(-timezoneOffset).subtract('4', 'days').startOf('day').toISOString();\n    await user.post('/tasks/user', [{\n      text: 'test daily',\n      type: 'daily',\n      startDate,\n      frequency: 'daily',\n      everyX: 2\n    }]);\n    const today = moment().format('YYYY-MM-DD');\n    const dailys = await user.get(`/tasks/user?type=dailys&dueDate=${today}`);\n    expect(dailys[0].isDue).to.be.true;\n    const yesterday = moment().subtract('1', 'days').format('YYYY-MM-DD');\n    const dailys2 = await user.get(`/tasks/user?type=dailys&dueDate=${yesterday}`);\n    expect(dailys2[0].isDue).to.be.false;\n  });","skipped":true,"file":"api/v3/integration/tasks/GET-tasks_user.test.js","dir":"test"},{"name":"returns dailies with isDue for the date specified and will add CDS offset if time is not supplied and assumes timezones","suites":["GET /tasks/user"],"updatePoint":{"line":180,"column":126,"index":7163},"line":180,"code":"  xit('returns dailies with isDue for the date specified and will add CDS offset if time is not supplied and assumes timezones', async () => {\n    const timezoneOffset = 240;\n    await user.update({\n      'preferences.dayStart': 0,\n      'preferences.timezoneOffset': timezoneOffset\n    });\n    const startDate = moment().utcOffset(-timezoneOffset).subtract('4', 'days').startOf('day').toISOString();\n    await user.post('/tasks/user', [{\n      text: 'test daily',\n      type: 'daily',\n      startDate,\n      frequency: 'daily',\n      everyX: 2\n    }]);\n    const today = moment().format('YYYY-MM-DD');\n    const dailys = await user.get(`/tasks/user?type=dailys&dueDate=${today}`);\n    expect(dailys[0].isDue).to.be.true;\n    const yesterday = moment().subtract('1', 'days').format('YYYY-MM-DD');\n    const dailys2 = await user.get(`/tasks/user?type=dailys&dueDate=${yesterday}`);\n    expect(dailys2[0].isDue).to.be.false;\n  });","skipped":true,"file":"api/v3/integration/tasks/GET-tasks_user.test.js","dir":"test"},{"name":"returns dailies with isDue for the date specified and will add CDS offset if time is not supplied and assumes timezones","suites":["GET /tasks/user"],"updatePoint":{"line":201,"column":126,"index":8092},"line":201,"code":"  xit('returns dailies with isDue for the date specified and will add CDS offset if time is not supplied and assumes timezones', async () => {\n    const timezoneOffset = 540;\n    await user.update({\n      'preferences.dayStart': 0,\n      'preferences.timezoneOffset': timezoneOffset\n    });\n    const startDate = moment().utcOffset(-timezoneOffset).subtract('4', 'days').startOf('day').toISOString();\n    await user.post('/tasks/user', [{\n      text: 'test daily',\n      type: 'daily',\n      startDate,\n      frequency: 'daily',\n      everyX: 2\n    }]);\n    const today = moment().format('YYYY-MM-DD');\n    const dailys = await user.get(`/tasks/user?type=dailys&dueDate=${today}`);\n    expect(dailys[0].isDue).to.be.true;\n    const yesterday = moment().subtract('1', 'days').format('YYYY-MM-DD');\n    const dailys2 = await user.get(`/tasks/user?type=dailys&dueDate=${yesterday}`);\n    expect(dailys2[0].isDue).to.be.false;\n  });","skipped":true,"file":"api/v3/integration/tasks/GET-tasks_user.test.js","dir":"test"},{"name":"deletes a checklist item","suites":["DELETE group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":21,"column":30,"index":540},"line":21,"code":"  it('deletes a checklist item', async () => {\n    task = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    await user.del(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`);\n    savedTask = await user.get(`/tasks/group/${guild._id}`);\n    expect(savedTask[0].checklist.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/groups/checklists/DELETE-group_tasks_taskId_checklist_item.test.js","skipped":false,"dir":"test"},{"name":"does not work with habits","suites":["DELETE group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":34,"column":31,"index":1046},"line":34,"code":"  it('does not work with habits', async () => {\n    const habit = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.del(`/tasks/${habit._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/DELETE-group_tasks_taskId_checklist_item.test.js","skipped":false,"dir":"test"},{"name":"does not work with rewards","suites":["DELETE group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":45,"column":32,"index":1439},"line":45,"code":"  it('does not work with rewards', async () => {\n    const reward = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.del(`/tasks/${reward._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/DELETE-group_tasks_taskId_checklist_item.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["DELETE group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":56,"column":29,"index":1833},"line":56,"code":"  it('fails on task not found', async () => {\n    await expect(user.del(`/tasks/${generateUUID()}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/DELETE-group_tasks_taskId_checklist_item.test.js","skipped":false,"dir":"test"},{"name":"fails on checklist item not found","suites":["DELETE group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":63,"column":39,"index":2104},"line":63,"code":"  it('fails on checklist item not found', async () => {\n    const createdTask = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'daily',\n      text: 'daily with checklist'\n    });\n    await expect(user.del(`/tasks/${createdTask._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('checklistItemNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/DELETE-group_tasks_taskId_checklist_item.test.js","skipped":false,"dir":"test"},{"name":"adds a checklist item to a task","suites":["POST group /tasks/:taskId/checklist/"],"updatePoint":{"line":21,"column":37,"index":538},"line":21,"code":"  it('adds a checklist item to a task', async () => {\n    task = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      ignored: false,\n      _id: 123\n    });\n    const updatedTasks = await user.get(`/tasks/group/${guild._id}`);\n    const updatedTask = updatedTasks[0];\n    expect(updatedTask.checklist.length).to.equal(1);\n    expect(updatedTask.checklist[0].text).to.equal('Checklist Item 1');\n    expect(updatedTask.checklist[0].completed).to.equal(false);\n    expect(updatedTask.checklist[0].id).to.be.a('string');\n    expect(updatedTask.checklist[0].id).to.not.equal('123');\n    expect(updatedTask.checklist[0].ignored).to.be.an('undefined');\n  });","file":"api/v3/integration/tasks/groups/checklists/POST-group_tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"does not add a checklist to habits","suites":["POST group /tasks/:taskId/checklist/"],"updatePoint":{"line":40,"column":40,"index":1343},"line":40,"code":"  it('does not add a checklist to habits', async () => {\n    const habit = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.post(`/tasks/${habit._id}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/POST-group_tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"does not add a checklist to rewards","suites":["POST group /tasks/:taskId/checklist/"],"updatePoint":{"line":53,"column":41,"index":1768},"line":53,"code":"  it('does not add a checklist to rewards', async () => {\n    const reward = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.post(`/tasks/${reward._id}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/POST-group_tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["POST group /tasks/:taskId/checklist/"],"updatePoint":{"line":66,"column":29,"index":2185},"line":66,"code":"  it('fails on task not found', async () => {\n    await expect(user.post(`/tasks/${generateUUID()}/checklist`, {\n      text: 'Checklist Item 1'\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/POST-group_tasks_taskId_checklist.test.js","skipped":false,"dir":"test"},{"name":"updates a checklist item","suites":["PUT group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":21,"column":30,"index":537},"line":21,"code":"  it('updates a checklist item', async () => {\n    task = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'daily',\n      text: 'Daily with checklist'\n    });\n    let savedTask = await user.post(`/tasks/${task._id}/checklist`, {\n      text: 'Checklist Item 1',\n      completed: false\n    });\n    savedTask = await user.put(`/tasks/${task._id}/checklist/${savedTask.checklist[0].id}`, {\n      text: 'updated',\n      completed: true,\n      _id: 123 // ignored\n\n    });\n    expect(savedTask.checklist.length).to.equal(1);\n    expect(savedTask.checklist[0].text).to.equal('updated');\n    expect(savedTask.checklist[0].completed).to.equal(true);\n    expect(savedTask.checklist[0].id).to.not.equal('123');\n  });","file":"api/v3/integration/tasks/groups/checklists/PUT-group_tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on habits","suites":["PUT group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":41,"column":21,"index":1244},"line":41,"code":"  it('fails on habits', async () => {\n    const habit = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'habit',\n      text: 'habit with checklist'\n    });\n    await expect(user.put(`/tasks/${habit._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/PUT-group_tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on rewards","suites":["PUT group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":52,"column":22,"index":1627},"line":52,"code":"  it('fails on rewards', async () => {\n    const reward = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'reward',\n      text: 'reward with checklist'\n    });\n    await expect(user.put(`/tasks/${reward._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('checklistOnlyDailyTodo')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/PUT-group_tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["PUT group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":63,"column":29,"index":2021},"line":63,"code":"  it('fails on task not found', async () => {\n    await expect(user.put(`/tasks/${generateUUID()}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/PUT-group_tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"fails on checklist item not found","suites":["PUT group /tasks/:taskId/checklist/:itemId"],"updatePoint":{"line":70,"column":39,"index":2292},"line":70,"code":"  it('fails on checklist item not found', async () => {\n    const createdTask = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'daily',\n      text: 'daily with checklist'\n    });\n    await expect(user.put(`/tasks/${createdTask._id}/checklist/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('checklistItemNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/checklists/PUT-group_tasks_taskId_checklist_itemId.test.js","skipped":false,"dir":"test"},{"name":"deletes a group task","suites":["Groups DELETE /tasks/:id"],"updatePoint":{"line":42,"column":26,"index":1078},"line":42,"code":"  it('deletes a group task', async () => {\n    await user.del(`/tasks/${task._id}`);\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/DELETE-group_tasks_id.test.js","skipped":false,"dir":"test"},{"name":"allows a manager to delete a group task","suites":["Groups DELETE /tasks/:id"],"updatePoint":{"line":50,"column":45,"index":1363},"line":50,"code":"  it('allows a manager to delete a group task', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.del(`/tasks/${task._id}`);\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/DELETE-group_tasks_id.test.js","skipped":false,"dir":"test"},{"name":"removes deleted taskʾs approval pending notifications from managers","suites":["Groups DELETE /tasks/:id"],"updatePoint":{"line":61,"column":73,"index":1774},"line":61,"code":"  it('removes deleted taskʾs approval pending notifications from managers', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await user.put(`/tasks/${task._id}/`, {\n      requiresApproval: true\n    });\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await user.sync();\n    await member2.sync();\n    expect(user.notifications.length).to.equal(2);\n    expect(user.notifications[1].type).to.equal('GROUP_TASK_APPROVAL');\n    expect(member2.notifications.length).to.equal(2);\n    expect(member2.notifications[1].type).to.equal('GROUP_TASK_APPROVAL');\n    await member2.del(`/tasks/${task._id}`);\n    await user.sync();\n    await member2.sync();\n    expect(user.notifications.length).to.equal(1);\n    expect(member2.notifications.length).to.equal(1);\n  });","file":"api/v3/integration/tasks/groups/DELETE-group_tasks_id.test.js","skipped":false,"dir":"test"},{"name":"deletes task from assigned user","suites":["Groups DELETE /tasks/:id"],"updatePoint":{"line":83,"column":37,"index":2687},"line":83,"code":"  it('deletes task from assigned user', async () => {\n    await user.del(`/tasks/${task._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(syncedTask).to.not.exist;\n  });","file":"api/v3/integration/tasks/groups/DELETE-group_tasks_id.test.js","skipped":false,"dir":"test"},{"name":"deletes task from all assigned users","suites":["Groups DELETE /tasks/:id"],"updatePoint":{"line":89,"column":42,"index":2948},"line":89,"code":"  it('deletes task from all assigned users', async () => {\n    await user.del(`/tasks/${task._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    const member2Tasks = await member2.get('/tasks/user');\n    const member2SyncedTask = find(member2Tasks, findAssignedTask);\n    expect(syncedTask).to.not.exist;\n    expect(member2SyncedTask).to.not.exist;\n  });","file":"api/v3/integration/tasks/groups/DELETE-group_tasks_id.test.js","skipped":false,"dir":"test"},{"name":"prevents a user from deleting a task they are assigned to","suites":["Groups DELETE /tasks/:id"],"updatePoint":{"line":98,"column":63,"index":3401},"line":98,"code":"  it('prevents a user from deleting a task they are assigned to', async () => {\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await expect(member.del(`/tasks/${syncedTask._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('cantDeleteAssignedGroupTasks')\n    });\n  });","file":"api/v3/integration/tasks/groups/DELETE-group_tasks_id.test.js","skipped":false,"dir":"test"},{"name":"allows a user to delete a task after leaving a group","suites":["Groups DELETE /tasks/:id"],"updatePoint":{"line":107,"column":58,"index":3796},"line":107,"code":"  it('allows a user to delete a task after leaving a group', async () => {\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/groups/${guild._id}/leave`);\n    await member.del(`/tasks/${syncedTask._id}`);\n    await expect(member.get(`/tasks/${syncedTask._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: 'Task not found.'\n    });\n  });","file":"api/v3/integration/tasks/groups/DELETE-group_tasks_id.test.js","skipped":false,"dir":"test"},{"name":"provides only user's own tasks when user is not the group leader","suites":["GET /approvals/group/:groupId"],"updatePoint":{"line":56,"column":71,"index":1647},"line":56,"code":"  it('provides only user\\'s own tasks when user is not the group leader', async () => {\n    const approvals = await member.get(`/approvals/group/${guild._id}`);\n    expect(approvals[0]._id).to.equal(syncedTask._id);\n    expect(approvals[1]).to.not.exist;\n  });","file":"api/v3/integration/tasks/groups/GET-approvals_group_id.test.js","skipped":false,"dir":"test"},{"name":"allows group leaders to get a list of tasks that need approval","suites":["GET /approvals/group/:groupId"],"updatePoint":{"line":61,"column":68,"index":1905},"line":61,"code":"  it('allows group leaders to get a list of tasks that need approval', async () => {\n    const approvals = await user.get(`/approvals/group/${guild._id}`);\n    expect(approvals[0]._id).to.equal(syncedTask._id);\n    expect(approvals[1]._id).to.equal(addlSyncedTask._id);\n  });","file":"api/v3/integration/tasks/groups/GET-approvals_group_id.test.js","skipped":false,"dir":"test"},{"name":"allows managers to get a list of tasks that need approval","suites":["GET /approvals/group/:groupId"],"updatePoint":{"line":66,"column":63,"index":2176},"line":66,"code":"  it('allows managers to get a list of tasks that need approval', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member._id\n    });\n    const approvals = await member.get(`/approvals/group/${guild._id}`);\n    expect(approvals[0]._id).to.equal(syncedTask._id);\n    expect(approvals[1]._id).to.equal(addlSyncedTask._id);\n  });","file":"api/v3/integration/tasks/groups/GET-approvals_group_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when group is not found","suites":["GET /tasks/group/:groupId"],"updatePoint":{"line":37,"column":43,"index":847},"line":37,"code":"  it('returns error when group is not found', async () => {\n    const dummyId = generateUUID();\n    await expect(user.get(`/tasks/group/${dummyId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/GET-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"gets group tasks","suites":["GET /tasks/group/:groupId",""],"updatePoint":{"line":52,"column":26,"index":1387},"line":52,"code":"      it('gets group tasks', async () => {\n        const getTask = await user.get(`/tasks/group/${groupWithTask._id}`);\n        expect(getTask).to.eql(tasks);\n      });","file":"api/v3/integration/tasks/groups/GET-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"gets group tasks filtered by type","suites":["GET /tasks/group/:groupId",""],"updatePoint":{"line":56,"column":43,"index":1573},"line":56,"code":"      it('gets group tasks filtered by type', async () => {\n        const groupTasks = await user.get(`/tasks/group/${groupWithTask._id}?type=${task.type}s`);\n        expect(groupTasks).to.eql([task]);\n      });","file":"api/v3/integration/tasks/groups/GET-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"cannot get a task owned by someone else","suites":["GET /tasks/group/:groupId",""],"updatePoint":{"line":60,"column":49,"index":1791},"line":60,"code":"      it('cannot get a task owned by someone else', async () => {\n        const anotherUser = await generateUser();\n        await expect(anotherUser.get(`/tasks/group/${groupWithTask._id}`)).to.eventually.be.rejected.and.eql({\n          code: 404,\n          error: 'NotFound',\n          message: t('groupNotFound')\n        });\n      });","file":"api/v3/integration/tasks/groups/GET-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"maintains group task order","suites":["GET /tasks/group/:groupId",""],"updatePoint":{"line":70,"column":32,"index":2125},"line":70,"code":"  it('maintains group task order', async () => {\n    const orderedTasks = {};\n    Object.entries(tasksToTest).forEach(async (taskType, taskValue) => {\n      const results = [];\n\n      for (let i = 0; i < 5; i += 1) {\n        results.push(user.post(`/tasks/group/${group._id}`, taskValue));\n      }\n\n      const taskList = await Promise.all(results);\n      await user.post(`/tasks/${taskList[0]._id}/move/to/3`);\n      const firstTask = taskList.unshift();\n      taskList.splice(3, 0, firstTask);\n      orderedTasks[taskType] = taskList;\n    });\n    const results = await user.get(`/tasks/group/${group._id}`);\n    const resultTasks = {};\n    results.forEach(result => {\n      if (!resultTasks[result.type]) {\n        resultTasks[result.type] = [];\n      }\n\n      resultTasks[result.type].push(result);\n    });\n    Object.entries(orderedTasks).forEach((taskType, taskList) => {\n      expect(resultTasks[taskType]).to.eql(taskList);\n    });\n  });","file":"api/v3/integration/tasks/groups/GET-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"errors when user is not assigned","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":38,"column":38,"index":942},"line":38,"code":"  it('errors when user is not assigned', async () => {\n    await expect(user.post(`/tasks/${task._id}/approve/${member._id}`)).to.eventually.be.rejected.and.to.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"errors when user is not the group leader","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":45,"column":46,"index":1212},"line":45,"code":"  it('errors when user is not the group leader', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    await expect(member.post(`/tasks/${task._id}/approve/${member._id}`)).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupLeaderCanEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"approves an assigned user","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":53,"column":31,"index":1546},"line":53,"code":"  it('approves an assigned user', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    let memberTasks = await member.get('/tasks/user');\n    let syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await user.post(`/tasks/${task._id}/approve/${member._id}`);\n    await member.sync();\n    expect(member.notifications.length).to.equal(2);\n    expect(member.notifications[1].type).to.equal('GROUP_TASK_APPROVED');\n    expect(member.notifications[1].data.message).to.equal(t('yourTaskHasBeenApproved', {\n      taskText: task.text\n    }));\n    memberTasks = await member.get('/tasks/user');\n    syncedTask = find(memberTasks, findAssignedTask);\n    expect(syncedTask.group.approval.approved).to.be.true;\n    expect(syncedTask.group.approval.approvingUser).to.equal(user._id);\n    expect(syncedTask.group.approval.dateApproved).to.be.a('string'); // date gets converted to a string as json doesn't have a Date type\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"allows a manager to approve an assigned user","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":71,"column":50,"index":2571},"line":71,"code":"  it('allows a manager to approve an assigned user', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.post(`/tasks/${task._id}/assign/${member._id}`);\n    let memberTasks = await member.get('/tasks/user');\n    let syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await member2.post(`/tasks/${task._id}/approve/${member._id}`);\n    await member.sync();\n    expect(member.notifications.length).to.equal(2);\n    expect(member.notifications[1].type).to.equal('GROUP_TASK_APPROVED');\n    expect(member.notifications[1].data.message).to.equal(t('yourTaskHasBeenApproved', {\n      taskText: task.text\n    }));\n    memberTasks = await member.get('/tasks/user');\n    syncedTask = find(memberTasks, findAssignedTask);\n    expect(syncedTask.group.approval.approved).to.be.true;\n    expect(syncedTask.group.approval.approvingUser).to.equal(member2._id);\n    expect(syncedTask.group.approval.dateApproved).to.be.a('string'); // date gets converted to a string as json doesn't have a Date type\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"removes approval pending notifications from managers","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":92,"column":58,"index":3708},"line":92,"code":"  it('removes approval pending notifications from managers', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.post(`/tasks/${task._id}/assign/${member._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await user.sync();\n    await member2.sync();\n    expect(user.notifications.length).to.equal(2);\n    expect(user.notifications[1].type).to.equal('GROUP_TASK_APPROVAL');\n    expect(member2.notifications.length).to.equal(1);\n    expect(member2.notifications[0].type).to.equal('GROUP_TASK_APPROVAL');\n    await member2.post(`/tasks/${task._id}/approve/${member._id}`);\n    await user.sync();\n    await member2.sync();\n    expect(user.notifications.length).to.equal(1);\n    expect(member2.notifications.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"prevents double approval on a task","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":112,"column":40,"index":4633},"line":112,"code":"  it('prevents double approval on a task', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.post(`/tasks/${task._id}/assign/${member._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await member2.post(`/tasks/${task._id}/approve/${member._id}`);\n    await expect(user.post(`/tasks/${task._id}/approve/${member._id}`)).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('canOnlyApproveTaskOnce')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"prevents approving a task if it is not waiting for approval","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":127,"column":65,"index":5337},"line":127,"code":"  it('prevents approving a task if it is not waiting for approval', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    await expect(user.post(`/tasks/${task._id}/approve/${member._id}`)).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('taskApprovalWasNotRequested')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"completes master task when single-completion task is approved","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":135,"column":67,"index":5705},"line":135,"code":"  it('completes master task when single-completion task is approved', async () => {\n    const sharedCompletionTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'shared completion todo',\n      type: 'todo',\n      requiresApproval: true,\n      sharedCompletion: 'singleCompletion'\n    });\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member._id}`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member2._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/approve/${member._id}`);\n    const groupTasks = await user.get(`/tasks/group/${guild._id}?type=completedTodos`);\n    const masterTask = find(groupTasks, groupTask => groupTask._id === sharedCompletionTask._id);\n    expect(masterTask.completed).to.equal(true);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"deletes other assigned user tasks when single-completion task is approved","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":152,"column":79,"index":6680},"line":152,"code":"  it('deletes other assigned user tasks when single-completion task is approved', async () => {\n    const sharedCompletionTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'shared completion todo',\n      type: 'todo',\n      requiresApproval: true,\n      sharedCompletion: 'singleCompletion'\n    });\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member._id}`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member2._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/approve/${member._id}`);\n    const member2Tasks = await member2.get('/tasks/user');\n    const syncedTask2 = find(member2Tasks, memberTask => memberTask.group.taskId === sharedCompletionTask._id);\n    expect(syncedTask2).to.equal(undefined);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"does not complete master task when not all user tasks are approved if all assigned must complete","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":169,"column":102,"index":7659},"line":169,"code":"  it('does not complete master task when not all user tasks are approved if all assigned must complete', async () => {\n    const sharedCompletionTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'shared completion todo',\n      type: 'todo',\n      requiresApproval: true,\n      sharedCompletion: 'allAssignedCompletion'\n    });\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member._id}`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member2._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/approve/${member._id}`);\n    const groupTasks = await user.get(`/tasks/group/${guild._id}`);\n    const masterTask = find(groupTasks, groupTask => groupTask._id === sharedCompletionTask._id);\n    expect(masterTask.completed).to.equal(false);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"completes master task when all user tasks are approved if all assigned must complete","suites":["POST /tasks/:id/approve/:userId"],"updatePoint":{"line":186,"column":90,"index":8631},"line":186,"code":"  it('completes master task when all user tasks are approved if all assigned must complete', async () => {\n    const sharedCompletionTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'shared completion todo',\n      type: 'todo',\n      requiresApproval: true,\n      sharedCompletion: 'allAssignedCompletion'\n    });\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member._id}`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member2._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    const member2Tasks = await member2.get('/tasks/user');\n    const member2SyncedTask = find(member2Tasks, findAssignedTask);\n    await member2.post(`/tasks/${member2SyncedTask._id}/score/up`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/approve/${member._id}`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/approve/${member2._id}`);\n    const groupTasks = await user.get(`/tasks/group/${guild._id}?type=completedTodos`);\n    const masterTask = find(groupTasks, groupTask => groupTask._id === sharedCompletionTask._id);\n    expect(masterTask.completed).to.equal(true);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_approve_userId.test.js","skipped":false,"dir":"test"},{"name":"errors when user is not assigned","suites":["POST /tasks/:id/needs-work/:userId"],"updatePoint":{"line":38,"column":38,"index":945},"line":38,"code":"  it('errors when user is not assigned', async () => {\n    await expect(user.post(`/tasks/${task._id}/needs-work/${member._id}`)).to.eventually.be.rejected.and.to.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_needs-work_userId.test.js","skipped":false,"dir":"test"},{"name":"errors when user is not the group leader","suites":["POST /tasks/:id/needs-work/:userId"],"updatePoint":{"line":45,"column":46,"index":1218},"line":45,"code":"  it('errors when user is not the group leader', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    await expect(member.post(`/tasks/${task._id}/needs-work/${member._id}`)).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupLeaderCanEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_needs-work_userId.test.js","skipped":false,"dir":"test"},{"name":"marks a task as needing more work","suites":["POST /tasks/:id/needs-work/:userId"],"updatePoint":{"line":53,"column":39,"index":1563},"line":53,"code":"  it('marks a task as needing more work', async () => {\n    const initialNotifications = member.notifications.length;\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    let memberTasks = await member.get('/tasks/user');\n    let syncedTask = find(memberTasks, findAssignedTask); // score task to require approval\n\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await user.post(`/tasks/${task._id}/needs-work/${member._id}`);\n    [memberTasks] = await Promise.all([member.get('/tasks/user'), member.sync()]);\n    syncedTask = find(memberTasks, findAssignedTask); // Check that the notification approval request has been removed\n\n    expect(syncedTask.group.approval.requested).to.equal(false);\n    expect(syncedTask.group.approval.requestedDate).to.equal(undefined); // Check that the notification is correct\n\n    expect(member.notifications.length).to.equal(initialNotifications + 2);\n    const notification = member.notifications[member.notifications.length - 1];\n    expect(notification.type).to.equal('GROUP_TASK_NEEDS_WORK');\n    const taskText = syncedTask.text;\n    const managerName = user.profile.name;\n    expect(notification.data.message).to.equal(t('taskNeedsWork', {\n      taskText,\n      managerName\n    }));\n    expect(notification.data.task.id).to.equal(syncedTask._id);\n    expect(notification.data.task.text).to.equal(taskText);\n    expect(notification.data.group.id).to.equal(syncedTask.group.id);\n    expect(notification.data.group.name).to.equal(guild.name);\n    expect(notification.data.manager.id).to.equal(user._id);\n    expect(notification.data.manager.name).to.equal(managerName); // Check that the managers' GROUP_TASK_APPROVAL notifications have been removed\n\n    await user.sync();\n    expect(user.notifications.find(n => {\n      // eslint-disable-line arrow-body-style\n      return n.data.taskId === syncedTask._id && n.type === 'GROUP_TASK_APPROVAL';\n    })).to.equal(undefined);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_needs-work_userId.test.js","skipped":false,"dir":"test"},{"name":"allows a manager to mark a task as needing work","suites":["POST /tasks/:id/needs-work/:userId"],"updatePoint":{"line":89,"column":53,"index":3526},"line":89,"code":"  it('allows a manager to mark a task as needing work', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.post(`/tasks/${task._id}/assign/${member._id}`);\n    let memberTasks = await member.get('/tasks/user');\n    let syncedTask = find(memberTasks, findAssignedTask); // score task to require approval\n\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    const initialNotifications = member.notifications.length;\n    await member2.post(`/tasks/${task._id}/needs-work/${member._id}`);\n    [memberTasks] = await Promise.all([member.get('/tasks/user'), member.sync()]);\n    syncedTask = find(memberTasks, findAssignedTask); // Check that the notification approval request has been removed\n\n    expect(syncedTask.group.approval.requested).to.equal(false);\n    expect(syncedTask.group.approval.requestedDate).to.equal(undefined);\n    expect(member.notifications.length).to.equal(initialNotifications + 2);\n    const notification = member.notifications[member.notifications.length - 1];\n    expect(notification.type).to.equal('GROUP_TASK_NEEDS_WORK');\n    const taskText = syncedTask.text;\n    const managerName = member2.profile.name;\n    expect(notification.data.message).to.equal(t('taskNeedsWork', {\n      taskText,\n      managerName\n    }));\n    expect(notification.data.task.id).to.equal(syncedTask._id);\n    expect(notification.data.task.text).to.equal(taskText);\n    expect(notification.data.group.id).to.equal(syncedTask.group.id);\n    expect(notification.data.group.name).to.equal(guild.name);\n    expect(notification.data.manager.id).to.equal(member2._id);\n    expect(notification.data.manager.name).to.equal(managerName); // Check that the managers' GROUP_TASK_APPROVAL notifications have been removed\n\n    await Promise.all([user.sync(), member2.sync()]);\n    expect(user.notifications.find(n => {\n      // eslint-disable-line arrow-body-style\n      return n.data.taskId === syncedTask._id && n.type === 'GROUP_TASK_APPROVAL';\n    })).to.equal(undefined);\n    expect(member2.notifications.find(n => {\n      // eslint-disable-line arrow-body-style\n      return n.data.taskId === syncedTask._id && n.type === 'GROUP_TASK_APPROVAL';\n    })).to.equal(undefined);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_needs-work_userId.test.js","skipped":false,"dir":"test"},{"name":"prevents marking a task as needing work if it was already approved","suites":["POST /tasks/:id/needs-work/:userId"],"updatePoint":{"line":131,"column":72,"index":5806},"line":131,"code":"  it('prevents marking a task as needing work if it was already approved', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.post(`/tasks/${task._id}/assign/${member._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await member2.post(`/tasks/${task._id}/approve/${member._id}`);\n    await expect(user.post(`/tasks/${task._id}/needs-work/${member._id}`)).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('canOnlyApproveTaskOnce')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_needs-work_userId.test.js","skipped":false,"dir":"test"},{"name":"prevents marking a task as needing work if it is not waiting for approval","suites":["POST /tasks/:id/needs-work/:userId"],"updatePoint":{"line":146,"column":79,"index":6527},"line":146,"code":"  it('prevents marking a task as needing work if it is not waiting for approval', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    await expect(user.post(`/tasks/${task._id}/needs-work/${member._id}`)).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('taskApprovalWasNotRequested')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_needs-work_userId.test.js","skipped":false,"dir":"test"},{"name":"prevents user from scoring a task that needs to be approved","suites":["POST /tasks/:id/score/:direction"],"updatePoint":{"line":39,"column":65,"index":1034},"line":39,"code":"  it('prevents user from scoring a task that needs to be approved', async () => {\n    await user.update({\n      'preferences.language': 'cs'\n    });\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    const direction = 'up';\n    const response = await member.post(`/tasks/${syncedTask._id}/score/${direction}`);\n    expect(response.data.requiresApproval).to.equal(true);\n    expect(response.message).to.equal(t('taskApprovalHasBeenRequested'));\n    const updatedTask = await member.get(`/tasks/${syncedTask._id}`);\n    await user.sync();\n    expect(user.notifications.length).to.equal(2);\n    expect(user.notifications[1].type).to.equal('GROUP_TASK_APPROVAL');\n    expect(user.notifications[1].data.message).to.equal(t('userHasRequestedTaskApproval', {\n      user: member.auth.local.username,\n      taskName: updatedTask.text,\n      taskId: updatedTask._id,\n      direction\n    }, 'cs')); // This test only works if we have the notification translated\n\n    expect(user.notifications[1].data.groupId).to.equal(guild._id);\n    expect(updatedTask.group.approval.requested).to.equal(true);\n    expect(updatedTask.group.approval.requestedDate).to.be.a('string'); // date gets converted to a string as json doesn't have a Date type\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"sends notifications to all managers","suites":["POST /tasks/:id/score/:direction"],"updatePoint":{"line":64,"column":41,"index":2311},"line":64,"code":"  it('sends notifications to all managers', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    const direction = 'up';\n    await member.post(`/tasks/${syncedTask._id}/score/${direction}`);\n    const updatedTask = await member.get(`/tasks/${syncedTask._id}`);\n    await user.sync();\n    await member2.sync();\n    expect(user.notifications.length).to.equal(2);\n    expect(user.notifications[1].type).to.equal('GROUP_TASK_APPROVAL');\n    expect(user.notifications[1].data.message).to.equal(t('userHasRequestedTaskApproval', {\n      user: member.auth.local.username,\n      taskName: updatedTask.text,\n      taskId: updatedTask._id,\n      direction\n    }));\n    expect(user.notifications[1].data.groupId).to.equal(guild._id);\n    expect(member2.notifications.length).to.equal(1);\n    expect(member2.notifications[0].type).to.equal('GROUP_TASK_APPROVAL');\n    expect(member2.notifications[0].data.message).to.equal(t('userHasRequestedTaskApproval', {\n      user: member.auth.local.username,\n      taskName: updatedTask.text,\n      taskId: updatedTask._id,\n      direction\n    }));\n    expect(member2.notifications[0].data.groupId).to.equal(guild._id);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"errors when approval has already been requested","suites":["POST /tasks/:id/score/:direction"],"updatePoint":{"line":94,"column":53,"index":3654},"line":94,"code":"  it('errors when approval has already been requested', async () => {\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    const response = await member.post(`/tasks/${syncedTask._id}/score/up`);\n    expect(response.data.requiresApproval).to.equal(true);\n    expect(response.message).to.equal(t('taskRequiresApproval'));\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"allows a user to score an approved task","suites":["POST /tasks/:id/score/:direction"],"updatePoint":{"line":102,"column":45,"index":4101},"line":102,"code":"  it('allows a user to score an approved task', async () => {\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await user.post(`/tasks/${task._id}/approve/${member._id}`);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    const updatedTask = await member.get(`/tasks/${syncedTask._id}`);\n    expect(updatedTask.completed).to.equal(true);\n    expect(updatedTask.dateCompleted).to.be.a('string'); // date gets converted to a string as json doesn't have a Date type\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"completes master task when single-completion task is completed","suites":["POST /tasks/:id/score/:direction"],"updatePoint":{"line":112,"column":68,"index":4739},"line":112,"code":"  it('completes master task when single-completion task is completed', async () => {\n    const sharedCompletionTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'shared completion todo',\n      type: 'todo',\n      requiresApproval: false,\n      sharedCompletion: 'singleCompletion'\n    });\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, memberTask => memberTask.group.taskId === sharedCompletionTask._id);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    const groupTasks = await user.get(`/tasks/group/${guild._id}?type=completedTodos`);\n    const masterTask = find(groupTasks, groupTask => groupTask._id === sharedCompletionTask._id);\n    expect(masterTask.completed).to.equal(true);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"deletes other assigned user tasks when single-completion task is completed","suites":["POST /tasks/:id/score/:direction"],"updatePoint":{"line":127,"column":80,"index":5604},"line":127,"code":"  it('deletes other assigned user tasks when single-completion task is completed', async () => {\n    const sharedCompletionTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'shared completion todo',\n      type: 'todo',\n      requiresApproval: false,\n      sharedCompletion: 'singleCompletion'\n    });\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member._id}`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member2._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, memberTask => memberTask.group.taskId === sharedCompletionTask._id);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    const member2Tasks = await member2.get('/tasks/user');\n    const syncedTask2 = find(member2Tasks, memberTask => memberTask.group.taskId === sharedCompletionTask._id);\n    expect(syncedTask2).to.equal(undefined);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"does not complete master task when not all user tasks are completed if all assigned must complete","suites":["POST /tasks/:id/score/:direction"],"updatePoint":{"line":143,"column":103,"index":6554},"line":143,"code":"  it('does not complete master task when not all user tasks are completed if all assigned must complete', async () => {\n    const sharedCompletionTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'shared completion todo',\n      type: 'todo',\n      requiresApproval: false,\n      sharedCompletion: 'allAssignedCompletion'\n    });\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member._id}`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member2._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, memberTask => memberTask.group.taskId === sharedCompletionTask._id);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    const groupTasks = await user.get(`/tasks/group/${guild._id}`);\n    const masterTask = find(groupTasks, groupTask => groupTask._id === sharedCompletionTask._id);\n    expect(masterTask.completed).to.equal(false);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"completes master task when all user tasks are completed if all assigned must complete","suites":["POST /tasks/:id/score/:direction"],"updatePoint":{"line":159,"column":91,"index":7497},"line":159,"code":"  it('completes master task when all user tasks are completed if all assigned must complete', async () => {\n    const sharedCompletionTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'shared completion todo',\n      type: 'todo',\n      requiresApproval: false,\n      sharedCompletion: 'allAssignedCompletion'\n    });\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member._id}`);\n    await user.post(`/tasks/${sharedCompletionTask._id}/assign/${member2._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const member2Tasks = await member2.get('/tasks/user');\n    const syncedTask = find(memberTasks, memberTask => memberTask.group.taskId === sharedCompletionTask._id);\n    const syncedTask2 = find(member2Tasks, memberTask => memberTask.group.taskId === sharedCompletionTask._id);\n    await member.post(`/tasks/${syncedTask._id}/score/up`);\n    await member2.post(`/tasks/${syncedTask2._id}/score/up`);\n    const groupTasks = await user.get(`/tasks/group/${guild._id}?type=completedTodos`);\n    const masterTask = find(groupTasks, groupTask => groupTask._id === sharedCompletionTask._id);\n    expect(masterTask.completed).to.equal(true);\n  });","file":"api/v3/integration/tasks/groups/POST-group_tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"returns error when task is not found","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":41,"column":42,"index":1034},"line":41,"code":"  it('returns error when task is not found', async () => {\n    await expect(user.post(`/tasks/${generateUUID()}/assign/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when task is not a group task","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":48,"column":49,"index":1309},"line":48,"code":"  it('returns error when task is not a group task', async () => {\n    const nonGroupTask = await user.post('/tasks/user', {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    });\n    await expect(user.post(`/tasks/${nonGroupTask._id}/assign/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupTasksCanBeAssigned')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not a member of the group","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":62,"column":58,"index":1774},"line":62,"code":"  it('returns error when user is not a member of the group', async () => {\n    const nonUser = await generateUser();\n    await expect(nonUser.post(`/tasks/${task._id}/assign/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when non leader tries to create a task","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":70,"column":58,"index":2091},"line":70,"code":"  it('returns error when non leader tries to create a task', async () => {\n    await expect(member2.post(`/tasks/${task._id}/assign/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupLeaderCanEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"allows user to assign themselves (claim)","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":77,"column":46,"index":2373},"line":77,"code":"  it('allows user to assign themselves (claim)', async () => {\n    await member.post(`/tasks/${task._id}/assign/${member._id}`);\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(groupTask[0].group.assignedUsers).to.contain(member._id);\n    expect(syncedTask).to.exist;\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"sends notifications to group leader and managers when a task is claimed","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":85,"column":77,"index":2825},"line":85,"code":"  it('sends notifications to group leader and managers when a task is claimed', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member.post(`/tasks/${task._id}/assign/${member._id}`);\n    await user.sync();\n    await member2.sync();\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    expect(user.notifications.length).to.equal(2); // includes Guild Joined achievement\n\n    expect(user.notifications[1].type).to.equal('GROUP_TASK_CLAIMED');\n    expect(user.notifications[1].data.taskId).to.equal(groupTask[0]._id);\n    expect(user.notifications[1].data.groupId).to.equal(guild._id);\n    expect(member2.notifications.length).to.equal(1);\n    expect(member2.notifications[0].type).to.equal('GROUP_TASK_CLAIMED');\n    expect(member2.notifications[0].data.taskId).to.equal(groupTask[0]._id);\n    expect(member2.notifications[0].data.groupId).to.equal(guild._id);\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"assigns a task to a user","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":103,"column":30,"index":3733},"line":103,"code":"  it('assigns a task to a user', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(groupTask[0].group.assignedUsers).to.contain(member._id);\n    expect(syncedTask).to.exist;\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"sends a notification to assigned user","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":111,"column":43,"index":4149},"line":111,"code":"  it('sends a notification to assigned user', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    await member.sync();\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    expect(member.notifications.length).to.equal(1);\n    expect(member.notifications[0].type).to.equal('GROUP_TASK_ASSIGNED');\n    expect(member.notifications[0].taskId).to.equal(groupTask._id);\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"assigns a task to multiple users","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":119,"column":38,"index":4561},"line":119,"code":"  it('assigns a task to multiple users', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member._id}`);\n    await user.post(`/tasks/${task._id}/assign/${member2._id}`);\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const member1SyncedTask = find(memberTasks, findAssignedTask);\n    const member2Tasks = await member2.get('/tasks/user');\n    const member2SyncedTask = find(member2Tasks, findAssignedTask);\n    expect(groupTask[0].group.assignedUsers).to.contain(member._id);\n    expect(groupTask[0].group.assignedUsers).to.contain(member2._id);\n    expect(member1SyncedTask).to.exist;\n    expect(member2SyncedTask).to.exist;\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"allows a manager to assign tasks","suites":["POST /tasks/:taskId/assign/:memberId"],"updatePoint":{"line":132,"column":38,"index":5288},"line":132,"code":"  it('allows a manager to assign tasks', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.post(`/tasks/${task._id}/assign/${member._id}`);\n    const groupTask = await member2.get(`/tasks/group/${guild._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(groupTask[0].group.assignedUsers).to.contain(member._id);\n    expect(syncedTask).to.exist;\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id_assign_user_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when group is not found","suites":["POST /tasks/group/:groupid"],"updatePoint":{"line":35,"column":43,"index":1017},"line":35,"code":"  it('returns error when group is not found', async () => {\n    await expect(user.post(`/tasks/group/${generateUUID()}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not a member of the group","suites":["POST /tasks/group/:groupid"],"updatePoint":{"line":48,"column":58,"index":1389},"line":48,"code":"  it('returns error when user is not a member of the group', async () => {\n    const userWithoutChallenge = await generateUser();\n    await expect(userWithoutChallenge.post(`/tasks/group/${guild._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    })).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"returns error when non leader tries to create a task","suites":["POST /tasks/group/:groupid"],"updatePoint":{"line":62,"column":58,"index":1827},"line":62,"code":"  it('returns error when non leader tries to create a task', async () => {\n    const userThatIsNotLeaderOfGroup = await generateUser({\n      guilds: [guild._id]\n    });\n    await expect(userThatIsNotLeaderOfGroup.post(`/tasks/group/${guild._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupLeaderCanEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"creates a habit","suites":["POST /tasks/group/:groupid"],"updatePoint":{"line":78,"column":21,"index":2292},"line":78,"code":"  it('creates a habit', async () => {\n    const task = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    });\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    expect(groupTask[0].group.id).to.equal(guild._id);\n    expect(task.text).to.eql('test habit');\n    expect(task.notes).to.eql('1976');\n    expect(task.type).to.eql('habit');\n    expect(task.up).to.eql(false);\n    expect(task.down).to.eql(true);\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"creates a todo","suites":["POST /tasks/group/:groupid"],"updatePoint":{"line":94,"column":20,"index":2822},"line":94,"code":"  it('creates a todo', async () => {\n    const task = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'test todo',\n      type: 'todo',\n      notes: 1976\n    });\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    expect(groupTask[0].group.id).to.equal(guild._id);\n    expect(task.text).to.eql('test todo');\n    expect(task.notes).to.eql('1976');\n    expect(task.type).to.eql('todo');\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"creates a daily","suites":["POST /tasks/group/:groupid"],"updatePoint":{"line":106,"column":21,"index":3243},"line":106,"code":"  it('creates a daily', async () => {\n    const now = new Date();\n    const task = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'test daily',\n      type: 'daily',\n      notes: 1976,\n      frequency: 'daily',\n      everyX: 5,\n      startDate: now\n    });\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    expect(groupTask[0].group.id).to.equal(guild._id);\n    expect(task.text).to.eql('test daily');\n    expect(task.notes).to.eql('1976');\n    expect(task.type).to.eql('daily');\n    expect(task.frequency).to.eql('daily');\n    expect(task.everyX).to.eql(5);\n    expect(new Date(task.startDate)).to.eql(new Date(now.setHours(0, 0, 0, 0)));\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"allows a manager to add a group task","suites":["POST /tasks/group/:groupid"],"updatePoint":{"line":125,"column":42,"index":3942},"line":125,"code":"  it('allows a manager to add a group task', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: manager._id\n    });\n    const task = await manager.post(`/tasks/group/${guild._id}`, {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    });\n    const groupTask = await manager.get(`/tasks/group/${guild._id}`);\n    expect(groupTask[0].group.id).to.equal(guild._id);\n    expect(task.text).to.eql('test habit');\n    expect(task.notes).to.eql('1976');\n    expect(task.type).to.eql('habit');\n    expect(task.up).to.eql(false);\n    expect(task.down).to.eql(true);\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_group_id.test.js","skipped":false,"dir":"test"},{"name":"can move task to new position","suites":["POST group-tasks/:taskId/move/to/:position"],"updatePoint":{"line":13,"column":35,"index":371},"line":13,"code":"  it('can move task to new position', async () => {\n    const tasks = await user.post(`/tasks/group/${guild._id}`, [{\n      type: 'habit',\n      text: 'habit 1'\n    }, {\n      type: 'habit',\n      text: 'habit 2'\n    }, {\n      type: 'daily',\n      text: 'daily 1'\n    }, {\n      type: 'habit',\n      text: 'habit 3'\n    }, {\n      type: 'habit',\n      text: 'habit 4'\n    }, {\n      type: 'todo',\n      text: 'todo 1'\n    }, {\n      type: 'habit',\n      text: 'habit 5'\n    }]);\n    const taskToMove = tasks[1];\n    expect(taskToMove.text).to.equal('habit 2');\n    const newOrder = await user.post(`/group-tasks/${tasks[1]._id}/move/to/3`);\n    expect(newOrder[3]).to.equal(taskToMove._id);\n    expect(newOrder.length).to.equal(5);\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_move_taskId_to_position.test.js","skipped":false,"dir":"test"},{"name":"can push to bottom","suites":["POST group-tasks/:taskId/move/to/:position"],"updatePoint":{"line":42,"column":24,"index":1099},"line":42,"code":"  it('can push to bottom', async () => {\n    const tasks = await user.post(`/tasks/group/${guild._id}`, [{\n      type: 'habit',\n      text: 'habit 1'\n    }, {\n      type: 'habit',\n      text: 'habit 2'\n    }, {\n      type: 'daily',\n      text: 'daily 1'\n    }, {\n      type: 'habit',\n      text: 'habit 3'\n    }, {\n      type: 'habit',\n      text: 'habit 4'\n    }, {\n      type: 'todo',\n      text: 'todo 1'\n    }, {\n      type: 'habit',\n      text: 'habit 5'\n    }]);\n    const taskToMove = tasks[1];\n    expect(taskToMove.text).to.equal('habit 2');\n    const newOrder = await user.post(`/group-tasks/${tasks[1]._id}/move/to/-1`);\n    expect(newOrder[4]).to.equal(taskToMove._id);\n    expect(newOrder.length).to.equal(5);\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_move_taskId_to_position.test.js","skipped":false,"dir":"test"},{"name":"returns error when task is not found","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":42,"column":42,"index":1100},"line":42,"code":"  it('returns error when task is not found', async () => {\n    await expect(user.post(`/tasks/${generateUUID()}/unassign/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","skipped":false,"dir":"test"},{"name":"returns error when task is not a group task","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":49,"column":49,"index":1377},"line":49,"code":"  it('returns error when task is not a group task', async () => {\n    const nonGroupTask = await user.post('/tasks/user', {\n      text: 'test habit',\n      type: 'habit',\n      up: false,\n      down: true,\n      notes: 1976\n    });\n    await expect(user.post(`/tasks/${nonGroupTask._id}/unassign/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupTasksCanBeAssigned')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","skipped":false,"dir":"test"},{"name":"returns error when user is not a member of the group","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":63,"column":58,"index":1844},"line":63,"code":"  it('returns error when user is not a member of the group', async () => {\n    const nonUser = await generateUser();\n    await expect(nonUser.post(`/tasks/${task._id}/unassign/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('groupNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","skipped":false,"dir":"test"},{"name":"unassigns a user from a task","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":71,"column":34,"index":2139},"line":71,"code":"  it('unassigns a user from a task', async () => {\n    await user.post(`/tasks/${task._id}/unassign/${member._id}`);\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(groupTask[0].group.assignedUsers).to.not.contain(member._id);\n    expect(syncedTask).to.not.exist;\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","skipped":false,"dir":"test"},{"name":"removes task assignment notification from unassigned user","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":79,"column":63,"index":2585},"line":79,"code":"  it('removes task assignment notification from unassigned user', async () => {\n    await user.post(`/tasks/${task._id}/unassign/${member._id}`);\n    await member.sync();\n    expect(member.notifications.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","skipped":false,"dir":"test"},{"name":"unassigns a user and only that user from a task","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":84,"column":53,"index":2805},"line":84,"code":"  it('unassigns a user and only that user from a task', async () => {\n    await user.post(`/tasks/${task._id}/assign/${member2._id}`);\n    await user.post(`/tasks/${task._id}/unassign/${member._id}`);\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const member1SyncedTask = find(memberTasks, findAssignedTask);\n    const member2Tasks = await member2.get('/tasks/user');\n    const member2SyncedTask = find(member2Tasks, findAssignedTask);\n    expect(groupTask[0].group.assignedUsers).to.not.contain(member._id);\n    expect(member1SyncedTask).to.not.exist;\n    expect(groupTask[0].group.assignedUsers).to.contain(member2._id);\n    expect(member2SyncedTask).to.exist;\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","skipped":false,"dir":"test"},{"name":"allows a manager to unassign a user from a task","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":97,"column":53,"index":3557},"line":97,"code":"  it('allows a manager to unassign a user from a task', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.post(`/tasks/${task._id}/unassign/${member._id}`);\n    const groupTask = await member2.get(`/tasks/group/${guild._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(groupTask[0].group.assignedUsers).to.not.contain(member._id);\n    expect(syncedTask).to.not.exist;\n  });","file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","skipped":false,"dir":"test"},{"name":"allows a user to unassign themselves","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":108,"column":42,"index":4083},"line":108,"code":"  it('allows a user to unassign themselves', async () => {\n    await member.post(`/tasks/${task._id}/unassign/${member._id}`);\n    const groupTask = await user.get(`/tasks/group/${guild._id}`);\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(groupTask[0].group.assignedUsers).to.not.contain(member._id);\n    expect(syncedTask).to.not.exist;\n  }); // @TODO: Which do we want? The user to unassign themselves or not. This test was in","file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","skipped":false,"dir":"test"},{"name":"returns error when non leader tries to unassign their a task","suites":["POST /tasks/:taskId/unassign/:memberId"],"updatePoint":{"line":118,"column":67,"index":4680},"line":118,"code":"  xit('returns error when non leader tries to unassign their a task', async () => {\n    await expect(member.post(`/tasks/${task._id}/unassign/${member._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupLeaderCanEditTasks')\n    });\n  });","skipped":true,"file":"api/v3/integration/tasks/groups/POST-tasks_task_id_unassign.test.js","dir":"test"},{"name":"updates a group task","suites":["PUT /tasks/:id"],"updatePoint":{"line":48,"column":26,"index":1213},"line":48,"code":"  it('updates a group task', async () => {\n    const savedHabit = await user.put(`/tasks/${habit._id}`, {\n      notes: 'some new notes'\n    });\n    expect(savedHabit.notes).to.eql('some new notes');\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"updates a group task - approval is required","suites":["PUT /tasks/:id"],"updatePoint":{"line":54,"column":49,"index":1441},"line":54,"code":"  it('updates a group task - approval is required', async () => {\n    // allow to manage\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member._id\n    }); // change the habit\n\n    habit = await member.put(`/tasks/${habit._id}`, {\n      text: 'new text!',\n      requiresApproval: true\n    });\n    const memberTasks = await member2.get('/tasks/user');\n    const syncedTask = find(memberTasks, memberTask => memberTask.group.taskId === habit._id); // score up to trigger approval\n\n    const response = await member2.post(`/tasks/${syncedTask._id}/score/up`);\n    expect(response.data.requiresApproval).to.equal(true);\n    expect(response.message).to.equal(t('taskApprovalHasBeenRequested'));\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"member updates a group task value - not allowed","suites":["PUT /tasks/:id"],"updatePoint":{"line":71,"column":53,"index":2168},"line":71,"code":"  it('member updates a group task value - not allowed', async () => {\n    // change the todo\n    await expect(member.put(`/tasks/${habit._id}`, {\n      text: 'new text!'\n    })).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupLeaderCanEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"member updates the collapseChecklist property - change is allowed","suites":["PUT /tasks/:id"],"updatePoint":{"line":81,"column":71,"index":2512},"line":81,"code":"  it('member updates the collapseChecklist property - change is allowed', async () => {\n    // change the todo\n    await member.put(`/tasks/${todo._id}`, {\n      collapseChecklist: true\n    });\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"member updates the collapseChecklist and another property - change not allowed","suites":["PUT /tasks/:id"],"updatePoint":{"line":87,"column":84,"index":2725},"line":87,"code":"  it('member updates the collapseChecklist and another property - change not allowed', async () => {\n    // change the todo\n    await expect(member.put(`/tasks/${todo._id}`, {\n      collapseChecklist: true,\n      title: 'test'\n    })).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('onlyGroupLeaderCanEditTasks')\n    });\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"updates a group task with checklist","suites":["PUT /tasks/:id"],"updatePoint":{"line":98,"column":41,"index":3065},"line":98,"code":"  it('updates a group task with checklist', async () => {\n    // add a new todo\n    habit = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'todo',\n      type: 'todo',\n      checklist: [{\n        text: 'checklist 1'\n      }]\n    });\n    await user.post(`/tasks/${habit._id}/assign/${member._id}`); // change the checklist text\n\n    habit = await user.put(`/tasks/${habit._id}`, {\n      checklist: [{\n        id: habit.checklist[0].id,\n        text: 'checklist 1 - edit'\n      }, {\n        text: 'checklist 2 - edit'\n      }]\n    });\n    expect(habit.checklist.length).to.eql(2);\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"updates the linked tasks","suites":["PUT /tasks/:id"],"updatePoint":{"line":119,"column":30,"index":3650},"line":119,"code":"  it('updates the linked tasks', async () => {\n    await user.put(`/tasks/${habit._id}`, {\n      text: 'some new text',\n      up: false,\n      down: false,\n      notes: 'some new notes'\n    });\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(syncedTask.text).to.eql('some new text');\n    expect(syncedTask.up).to.eql(false);\n    expect(syncedTask.down).to.eql(false);\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"updates the linked tasks for all assigned users","suites":["PUT /tasks/:id"],"updatePoint":{"line":132,"column":53,"index":4127},"line":132,"code":"  it('updates the linked tasks for all assigned users', async () => {\n    await user.put(`/tasks/${habit._id}`, {\n      text: 'some new text',\n      up: false,\n      down: false,\n      notes: 'some new notes'\n    });\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    const member2Tasks = await member2.get('/tasks/user');\n    const member2SyncedTask = find(member2Tasks, findAssignedTask);\n    expect(syncedTask.text).to.eql('some new text');\n    expect(syncedTask.up).to.eql(false);\n    expect(syncedTask.down).to.eql(false);\n    expect(member2SyncedTask.text).to.eql('some new text');\n    expect(member2SyncedTask.up).to.eql(false);\n    expect(member2SyncedTask.down).to.eql(false);\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"updates the linked tasks","suites":["PUT /tasks/:id"],"updatePoint":{"line":150,"column":30,"index":4866},"line":150,"code":"  it('updates the linked tasks', async () => {\n    await user.post(`/groups/${guild._id}/add-manager`, {\n      managerId: member2._id\n    });\n    await member2.put(`/tasks/${habit._id}`, {\n      text: 'some new text',\n      up: false,\n      down: false,\n      notes: 'some new notes'\n    });\n    const memberTasks = await member.get('/tasks/user');\n    const syncedTask = find(memberTasks, findAssignedTask);\n    expect(syncedTask.text).to.eql('some new text');\n    expect(syncedTask.up).to.eql(false);\n    expect(syncedTask.down).to.eql(false);\n  });","file":"api/v3/integration/tasks/groups/PUT-group_task_id.test.js","skipped":false,"dir":"test"},{"name":"removes a tag from a task","suites":[],"updatePoint":{"line":23,"column":31,"index":659},"line":23,"code":"  it('removes a tag from a task', async () => {\n    task = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    const tag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    await user.post(`/tasks/${task._id}/tags/${tag.id}`);\n    await user.del(`/tasks/${task._id}/tags/${tag.id}`);\n    const updatedTask = await user.get(`/tasks/group/${guild._id}`);\n    expect(updatedTask[0].tags.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/groups/tags/DELETE-group_tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"only deletes existing tags","suites":[],"updatePoint":{"line":36,"column":32,"index":1136},"line":36,"code":"  it('only deletes existing tags', async () => {\n    const createdTask = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    await expect(user.del(`/tasks/${createdTask._id}/tags/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('tagNotFound')\n    });\n  });","file":"api/v3/integration/tasks/groups/tags/DELETE-group_tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"adds a tag to a task","suites":[],"updatePoint":{"line":23,"column":26,"index":652},"line":23,"code":"  it('adds a tag to a task', async () => {\n    task = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    const tag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    const savedTask = await user.post(`/tasks/${task._id}/tags/${tag.id}`);\n    expect(savedTask.tags[0]).to.equal(tag.id);\n  });","file":"api/v3/integration/tasks/groups/tags/POST-tasks_taskId_tags.test.js","skipped":false,"dir":"test"},{"name":"does not add a tag to a task twice","suites":[],"updatePoint":{"line":34,"column":40,"index":1025},"line":34,"code":"  it('does not add a tag to a task twice', async () => {\n    task = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    const tag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    await user.post(`/tasks/${task._id}/tags/${tag.id}`);\n    await expect(user.post(`/tasks/${task._id}/tags/${tag.id}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('alreadyTagged')\n    });\n  });","file":"api/v3/integration/tasks/groups/tags/POST-tasks_taskId_tags.test.js","skipped":false,"dir":"test"},{"name":"does not add a non existing tag to a task","suites":[],"updatePoint":{"line":49,"column":47,"index":1526},"line":49,"code":"  it('does not add a non existing tag to a task', async () => {\n    task = await user.post(`/tasks/group/${guild._id}`, {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    await expect(user.post(`/tasks/${task._id}/tags/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/tasks/groups/tags/POST-tasks_taskId_tags.test.js","skipped":false,"dir":"test"},{"name":"deletes all completed todos except the ones from a challenge and group","suites":["POST /tasks/clearCompletedTodos"],"updatePoint":{"line":3,"column":76,"index":234},"line":3,"code":"  it('deletes all completed todos except the ones from a challenge and group', async () => {\n    const user = await generateUser({\n      balance: 1\n    });\n    const guild = await generateGroup(user);\n    const challenge = await generateChallenge(user, guild);\n    await user.post(`/challenges/${challenge._id}/join`);\n    const initialTodoCount = user.tasksOrder.todos.length;\n    await user.post('/tasks/user', [{\n      text: 'todo 1',\n      type: 'todo'\n    }, {\n      text: 'todo 2',\n      type: 'todo'\n    }, {\n      text: 'todo 3',\n      type: 'todo'\n    }, {\n      text: 'todo 4',\n      type: 'todo'\n    }, {\n      text: 'todo 5',\n      type: 'todo'\n    }]);\n    await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'todo 6',\n      type: 'todo'\n    });\n    const groupTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'todo 7',\n      type: 'todo'\n    });\n    await user.post(`/tasks/${groupTask._id}/assign/${user._id}`);\n    const tasks = await user.get('/tasks/user?type=todos');\n    expect(tasks.length).to.equal(initialTodoCount + 7);\n\n    for (const task of tasks) {\n      // eslint-disable-line\n      if (['todo 2', 'todo 3', 'todo 6'].indexOf(task.text) !== -1) {\n        await user.post(`/tasks/${task._id}/score/up`); // eslint-disable-line no-await-in-loop\n      }\n    }\n\n    await user.post('/tasks/clearCompletedTodos');\n    const completedTodos = await user.get('/tasks/user?type=completedTodos');\n    const todos = await user.get('/tasks/user?type=todos');\n    const allTodos = todos.concat(completedTodos); // + 7 - 3 completed (but one is from challenge)\n\n    expect(allTodos.length).to.equal(initialTodoCount + 5);\n    expect(allTodos[allTodos.length - 1].text).to.equal('todo 6'); // last completed todo\n  });","file":"api/v3/integration/tasks/POST-tasks_clearCompletedTodos.test.js","skipped":false,"dir":"test"},{"name":"can use an id to identify the task","suites":["POST /tasks/:id/score/:direction","all"],"updatePoint":{"line":12,"column":42,"index":441},"line":12,"code":"    it('can use an id to identify the task', async () => {\n      const todo = await user.post('/tasks/user', {\n        text: 'test todo',\n        type: 'todo',\n        alias: 'alias'\n      });\n      const res = await user.post(`/tasks/${todo._id}/score/up`);\n      expect(res).to.be.ok;\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"can use a alias in place of the id","suites":["POST /tasks/:id/score/:direction","all"],"updatePoint":{"line":21,"column":42,"index":736},"line":21,"code":"    it('can use a alias in place of the id', async () => {\n      const todo = await user.post('/tasks/user', {\n        text: 'test todo',\n        type: 'todo',\n        alias: 'alias'\n      });\n      const res = await user.post(`/tasks/${todo.alias}/score/up`);\n      expect(res).to.be.ok;\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"requires a task direction","suites":["POST /tasks/:id/score/:direction","all"],"updatePoint":{"line":30,"column":33,"index":1024},"line":30,"code":"    it('requires a task direction', async () => {\n      await expect(user.post(`/tasks/${generateUUID()}/score/tt`)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: apiError('directionUpDown')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"sends task scored webhooks","suites":["POST /tasks/:id/score/:direction","all"],"updatePoint":{"line":37,"column":34,"index":1289},"line":37,"code":"    it('sends task scored webhooks', async () => {\n      const uuid = generateUUID();\n      await server.start();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          created: false,\n          scored: true\n        }\n      });\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await user.post(`/tasks/${task.id}/score/up`);\n      await sleep();\n      await server.close();\n      const body = server.getWebhookData(uuid);\n      expect(body.user).to.have.all.keys('_id', '_tmp', 'stats');\n      expect(body.user.stats).to.have.all.keys('hp', 'mp', 'exp', 'gp', 'lvl', 'class', 'points', 'str', 'con', 'int', 'per', 'buffs', 'training', 'maxHealth', 'maxMP', 'toNextLevel');\n      expect(body.task.id).to.eql(task.id);\n      expect(body.direction).to.eql('up');\n      expect(body.delta).to.be.greaterThan(0);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"sends user activity webhook when the user levels up","suites":["POST /tasks/:id/score/:direction","all","sending user activity webhooks"],"updatePoint":{"line":70,"column":61,"index":2519},"line":70,"code":"      it('sends user activity webhook when the user levels up', async () => {\n        const uuid = generateUUID();\n        await user.post('/user/webhook', {\n          url: `http://localhost:${server.port}/webhooks/${uuid}`,\n          type: 'userActivity',\n          enabled: true,\n          options: {\n            leveledUp: true\n          }\n        });\n        const initialLvl = user.stats.lvl;\n        await user.update({\n          'stats.exp': 3000\n        });\n        const task = await user.post('/tasks/user', {\n          text: 'test habit',\n          type: 'habit'\n        });\n        await user.post(`/tasks/${task.id}/score/up`);\n        await user.sync();\n        await sleep();\n        const body = server.getWebhookData(uuid);\n        expect(body.type).to.eql('leveledUp');\n        expect(body.initialLvl).to.eql(initialLvl);\n        expect(body.finalLvl).to.eql(user.stats.lvl);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"completes todo when direction is up","suites":["POST /tasks/:id/score/:direction","todos"],"updatePoint":{"line":106,"column":43,"index":3601},"line":106,"code":"    it('completes todo when direction is up', async () => {\n      await user.post(`/tasks/${todo._id}/score/up`);\n      const task = await user.get(`/tasks/${todo._id}`);\n      expect(task.completed).to.equal(true);\n      expect(task.dateCompleted).to.be.a('string'); // date gets converted to a string as json doesn't have a Date type\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"moves completed todos out of user.tasksOrder.todos","suites":["POST /tasks/:id/score/:direction","todos"],"updatePoint":{"line":112,"column":58,"index":3960},"line":112,"code":"    it('moves completed todos out of user.tasksOrder.todos', async () => {\n      const getUser = await user.get('/user');\n      expect(getUser.tasksOrder.todos.indexOf(todo._id)).to.not.equal(-1);\n      await user.post(`/tasks/${todo._id}/score/up`);\n      const updatedTask = await user.get(`/tasks/${todo._id}`);\n      expect(updatedTask.completed).to.equal(true);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.todos.indexOf(todo._id)).to.equal(-1);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"moves un-completed todos back into user.tasksOrder.todos","suites":["POST /tasks/:id/score/:direction","todos"],"updatePoint":{"line":121,"column":64,"index":4467},"line":121,"code":"    it('moves un-completed todos back into user.tasksOrder.todos', async () => {\n      const getUser = await user.get('/user');\n      expect(getUser.tasksOrder.todos.indexOf(todo._id)).to.not.equal(-1);\n      await user.post(`/tasks/${todo._id}/score/up`);\n      await user.post(`/tasks/${todo._id}/score/down`);\n      const updatedTask = await user.get(`/tasks/${todo._id}`);\n      expect(updatedTask.completed).to.equal(false);\n      const updatedUser = await user.get('/user');\n      const l = updatedUser.tasksOrder.todos.length;\n      expect(updatedUser.tasksOrder.todos.indexOf(todo._id)).not.to.equal(-1); // Check that it was pushed at the bottom\n\n      expect(updatedUser.tasksOrder.todos.indexOf(todo._id)).to.equal(l - 1);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"uncompletes todo when direction is down","suites":["POST /tasks/:id/score/:direction","todos"],"updatePoint":{"line":134,"column":47,"index":5192},"line":134,"code":"    it('uncompletes todo when direction is down', async () => {\n      await user.post(`/tasks/${todo._id}/score/up`);\n      await user.post(`/tasks/${todo._id}/score/down`);\n      const updatedTask = await user.get(`/tasks/${todo._id}`);\n      expect(updatedTask.completed).to.equal(false);\n      expect(updatedTask.dateCompleted).to.be.a('undefined');\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"doesn't let a todo be completed twice","suites":["POST /tasks/:id/score/:direction","todos"],"updatePoint":{"line":141,"column":46,"index":5552},"line":141,"code":"    it('doesn\\'t let a todo be completed twice', async () => {\n      await user.post(`/tasks/${todo._id}/score/up`);\n      await expect(user.post(`/tasks/${todo._id}/score/up`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('sessionOutdated')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"doesn't let a todo be uncompleted twice","suites":["POST /tasks/:id/score/:direction","todos"],"updatePoint":{"line":149,"column":48,"index":5875},"line":149,"code":"    it('doesn\\'t let a todo be uncompleted twice', async () => {\n      await expect(user.post(`/tasks/${todo._id}/score/down`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('sessionOutdated')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's mp","suites":["POST /tasks/:id/score/:direction","todos","user stats when direction is up"],"updatePoint":{"line":162,"column":30,"index":6350},"line":162,"code":"      it('increases user\\'s mp', () => {\n        expect(updatedUser.stats.mp).to.be.greaterThan(user.stats.mp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's exp","suites":["POST /tasks/:id/score/:direction","todos","user stats when direction is up"],"updatePoint":{"line":165,"column":31,"index":6473},"line":165,"code":"      it('increases user\\'s exp', () => {\n        expect(updatedUser.stats.exp).to.be.greaterThan(user.stats.exp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's gold","suites":["POST /tasks/:id/score/:direction","todos","user stats when direction is up"],"updatePoint":{"line":168,"column":32,"index":6599},"line":168,"code":"      it('increases user\\'s gold', () => {\n        expect(updatedUser.stats.gp).to.be.greaterThan(user.stats.gp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"decreases user's mp","suites":["POST /tasks/:id/score/:direction","todos","user stats when direction is down"],"updatePoint":{"line":181,"column":30,"index":7081},"line":181,"code":"      it('decreases user\\'s mp', () => {\n        expect(updatedUser.stats.mp).to.be.lessThan(initialUser.stats.mp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"decreases user's exp","suites":["POST /tasks/:id/score/:direction","todos","user stats when direction is down"],"updatePoint":{"line":184,"column":31,"index":7208},"line":184,"code":"      it('decreases user\\'s exp', () => {\n        expect(updatedUser.stats.exp).to.be.lessThan(initialUser.stats.exp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"decreases user's gold","suites":["POST /tasks/:id/score/:direction","todos","user stats when direction is down"],"updatePoint":{"line":187,"column":32,"index":7338},"line":187,"code":"      it('decreases user\\'s gold', () => {\n        expect(updatedUser.stats.gp).to.be.lessThan(initialUser.stats.gp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"completes daily when direction is up","suites":["POST /tasks/:id/score/:direction","dailys"],"updatePoint":{"line":200,"column":44,"index":7679},"line":200,"code":"    it('completes daily when direction is up', async () => {\n      await user.post(`/tasks/${daily._id}/score/up`);\n      const task = await user.get(`/tasks/${daily._id}`);\n      expect(task.completed).to.equal(true);\n      expect(task.value).to.be.greaterThan(daily.value);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"uncompletes daily when direction is down","suites":["POST /tasks/:id/score/:direction","dailys"],"updatePoint":{"line":206,"column":48,"index":7967},"line":206,"code":"    it('uncompletes daily when direction is down', async () => {\n      await user.post(`/tasks/${daily._id}/score/up`);\n      await user.post(`/tasks/${daily._id}/score/down`);\n      const task = await user.get(`/tasks/${daily._id}`);\n      expect(task.completed).to.equal(false);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"computes isDue","suites":["POST /tasks/:id/score/:direction","dailys"],"updatePoint":{"line":212,"column":22,"index":8230},"line":212,"code":"    it('computes isDue', async () => {\n      await user.post(`/tasks/${daily._id}/score/up`);\n      const task = await user.get(`/tasks/${daily._id}`);\n      expect(task.isDue).to.equal(true);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"computes nextDue","suites":["POST /tasks/:id/score/:direction","dailys"],"updatePoint":{"line":217,"column":24,"index":8433},"line":217,"code":"    it('computes nextDue', async () => {\n      await user.post(`/tasks/${daily._id}/score/up`);\n      const task = await user.get(`/tasks/${daily._id}`);\n      expect(task.nextDue.length).to.eql(6);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"doesn't let a daily be completed twice","suites":["POST /tasks/:id/score/:direction","dailys"],"updatePoint":{"line":222,"column":47,"index":8663},"line":222,"code":"    it('doesn\\'t let a daily be completed twice', async () => {\n      await user.post(`/tasks/${daily._id}/score/up`);\n      await expect(user.post(`/tasks/${daily._id}/score/up`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('sessionOutdated')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"doesn't let a daily be uncompleted twice","suites":["POST /tasks/:id/score/:direction","dailys"],"updatePoint":{"line":230,"column":49,"index":8989},"line":230,"code":"    it('doesn\\'t let a daily be uncompleted twice', async () => {\n      await expect(user.post(`/tasks/${daily._id}/score/down`)).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('sessionOutdated')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's mp","suites":["POST /tasks/:id/score/:direction","dailys","user stats when direction is up"],"updatePoint":{"line":243,"column":30,"index":9466},"line":243,"code":"      it('increases user\\'s mp', () => {\n        expect(updatedUser.stats.mp).to.be.greaterThan(user.stats.mp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's exp","suites":["POST /tasks/:id/score/:direction","dailys","user stats when direction is up"],"updatePoint":{"line":246,"column":31,"index":9589},"line":246,"code":"      it('increases user\\'s exp', () => {\n        expect(updatedUser.stats.exp).to.be.greaterThan(user.stats.exp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's gold","suites":["POST /tasks/:id/score/:direction","dailys","user stats when direction is up"],"updatePoint":{"line":249,"column":32,"index":9715},"line":249,"code":"      it('increases user\\'s gold', () => {\n        expect(updatedUser.stats.gp).to.be.greaterThan(user.stats.gp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"decreases user's mp","suites":["POST /tasks/:id/score/:direction","dailys","user stats when direction is down"],"updatePoint":{"line":262,"column":30,"index":10199},"line":262,"code":"      it('decreases user\\'s mp', () => {\n        expect(updatedUser.stats.mp).to.be.lessThan(initialUser.stats.mp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"decreases user's exp","suites":["POST /tasks/:id/score/:direction","dailys","user stats when direction is down"],"updatePoint":{"line":265,"column":31,"index":10326},"line":265,"code":"      it('decreases user\\'s exp', () => {\n        expect(updatedUser.stats.exp).to.be.lessThan(initialUser.stats.exp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"decreases user's gold","suites":["POST /tasks/:id/score/:direction","dailys","user stats when direction is down"],"updatePoint":{"line":268,"column":32,"index":10456},"line":268,"code":"      it('decreases user\\'s gold', () => {\n        expect(updatedUser.stats.gp).to.be.lessThan(initialUser.stats.gp);\n      });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"prevents plus only habit from scoring down","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":289,"column":50,"index":11026},"line":289,"code":"    it('prevents plus only habit from scoring down'); // Yes?","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"prevents minus only habit from scoring up","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":291,"column":49,"index":11088},"line":291,"code":"    it('prevents minus only habit from scoring up'); // Yes?","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's mp when direction is up","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":293,"column":49,"index":11150},"line":293,"code":"    it('increases user\\'s mp when direction is up', async () => {\n      await user.post(`/tasks/${habit._id}/score/up`);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.stats.mp).to.be.greaterThan(user.stats.mp);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"decreases user's mp when direction is down","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":298,"column":51,"index":11401},"line":298,"code":"    it('decreases user\\'s mp when direction is down', async () => {\n      await user.post(`/tasks/${habit._id}/score/down`);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.stats.mp).to.be.lessThan(user.stats.mp);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's exp when direction is up","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":303,"column":50,"index":11650},"line":303,"code":"    it('increases user\\'s exp when direction is up', async () => {\n      await user.post(`/tasks/${habit._id}/score/up`);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.stats.exp).to.be.greaterThan(user.stats.exp);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"increases user's gold when direction is up","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":308,"column":51,"index":11903},"line":308,"code":"    it('increases user\\'s gold when direction is up', async () => {\n      await user.post(`/tasks/${habit._id}/score/up`);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.stats.gp).to.be.greaterThan(user.stats.gp);\n    }); // not supported anymore","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"does not add score notes to task","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":314,"column":40,"index":12169},"line":314,"code":"    it('does not add score notes to task', async () => {\n      const scoreNotesString = 'test-notes';\n      await user.post(`/tasks/${habit._id}/score/up`, {\n        scoreNotes: scoreNotesString\n      });\n      const updatedTask = await user.get(`/tasks/${habit._id}`);\n      expect(updatedTask.history[0].scoreNotes).to.eql(undefined);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"records only one history entry per day","suites":["POST /tasks/:id/score/:direction","habits"],"updatePoint":{"line":322,"column":46,"index":12520},"line":322,"code":"    it('records only one history entry per day', async () => {\n      const initialHistoryLength = habit.history.length;\n      await user.post(`/tasks/${habit._id}/score/up`);\n      await user.post(`/tasks/${habit._id}/score/up`);\n      await user.post(`/tasks/${habit._id}/score/down`);\n      await user.post(`/tasks/${habit._id}/score/up`);\n      const updatedTask = await user.get(`/tasks/${habit._id}`);\n      expect(updatedTask.history.length).to.eql(initialHistoryLength + 1);\n      const lastHistoryEntry = updatedTask.history[updatedTask.history.length - 1];\n      expect(lastHistoryEntry.scoredUp).to.equal(3);\n      expect(lastHistoryEntry.scoredDown).to.equal(1);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"purchases reward","suites":["POST /tasks/:id/score/:direction","reward"],"updatePoint":{"line":347,"column":24,"index":13517},"line":347,"code":"    it('purchases reward', () => {\n      expect(user.stats.gp).to.equal(updatedUser.stats.gp + 5);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"does not change user's mp","suites":["POST /tasks/:id/score/:direction","reward"],"updatePoint":{"line":350,"column":34,"index":13634},"line":350,"code":"    it('does not change user\\'s mp', () => {\n      expect(user.stats.mp).to.equal(updatedUser.stats.mp);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"does not change user's exp","suites":["POST /tasks/:id/score/:direction","reward"],"updatePoint":{"line":353,"column":35,"index":13748},"line":353,"code":"    it('does not change user\\'s exp', () => {\n      expect(user.stats.exp).to.equal(updatedUser.stats.exp);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"does not allow a down direction","suites":["POST /tasks/:id/score/:direction","reward"],"updatePoint":{"line":356,"column":39,"index":13868},"line":356,"code":"    it('does not allow a down direction', () => {\n      expect(user.stats.mp).to.equal(updatedUser.stats.mp);\n    });","file":"api/v3/integration/tasks/POST-tasks_id_score_direction.test.js","skipped":false,"dir":"test"},{"name":"requires a numeric position parameter","suites":["POST /tasks/:taskId/move/to/:position"],"updatePoint":{"line":8,"column":43,"index":310},"line":8,"code":"  it('requires a numeric position parameter', async () => {\n    await expect(user.post(`/tasks/${generateUUID()}/move/to/notANumber`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_move_taskId_to_position.test.js","skipped":false,"dir":"test"},{"name":"taskId must match a valid task","suites":["POST /tasks/:taskId/move/to/:position"],"updatePoint":{"line":15,"column":36,"index":569},"line":15,"code":"  it('taskId must match a valid task', async () => {\n    await expect(user.post(`/tasks/${generateUUID()}/move/to/1`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_move_taskId_to_position.test.js","skipped":false,"dir":"test"},{"name":"can move task to new position","suites":["POST /tasks/:taskId/move/to/:position"],"updatePoint":{"line":22,"column":35,"index":819},"line":22,"code":"  it('can move task to new position', async () => {\n    const tasks = await user.post('/tasks/user', [{\n      type: 'habit',\n      text: 'habit 1'\n    }, {\n      type: 'habit',\n      text: 'habit 2'\n    }, {\n      type: 'daily',\n      text: 'daily 1'\n    }, {\n      type: 'habit',\n      text: 'habit 3'\n    }, {\n      type: 'habit',\n      text: 'habit 4'\n    }, {\n      type: 'todo',\n      text: 'todo 1'\n    }, {\n      type: 'habit',\n      text: 'habit 5'\n    }]);\n    const taskToMove = tasks[1];\n    expect(taskToMove.text).to.equal('habit 2');\n    const newOrder = await user.post(`/tasks/${tasks[1]._id}/move/to/3`);\n    await user.sync();\n    expect(newOrder[3]).to.equal(taskToMove._id);\n    expect(newOrder.length).to.equal(5);\n    expect(user.tasksOrder.habits).to.eql(newOrder);\n  });","file":"api/v3/integration/tasks/POST-tasks_move_taskId_to_position.test.js","skipped":false,"dir":"test"},{"name":"can move task to new position using alias","suites":["POST /tasks/:taskId/move/to/:position"],"updatePoint":{"line":53,"column":47,"index":1626},"line":53,"code":"  it('can move task to new position using alias', async () => {\n    const tasks = await user.post('/tasks/user', [{\n      type: 'habit',\n      text: 'habit 1'\n    }, {\n      type: 'habit',\n      text: 'habit 2',\n      alias: 'move'\n    }, {\n      type: 'daily',\n      text: 'daily 1'\n    }, {\n      type: 'habit',\n      text: 'habit 3'\n    }, {\n      type: 'habit',\n      text: 'habit 4'\n    }, {\n      type: 'todo',\n      text: 'todo 1'\n    }, {\n      type: 'habit',\n      text: 'habit 5'\n    }]);\n    const taskToMove = tasks[1];\n    expect(taskToMove.text).to.equal('habit 2');\n    const newOrder = await user.post(`/tasks/${taskToMove.alias}/move/to/3`);\n    expect(newOrder[3]).to.equal(taskToMove._id);\n    expect(newOrder.length).to.equal(5);\n  });","file":"api/v3/integration/tasks/POST-tasks_move_taskId_to_position.test.js","skipped":false,"dir":"test"},{"name":"can't move completed todo","suites":["POST /tasks/:taskId/move/to/:position"],"updatePoint":{"line":83,"column":32,"index":2367},"line":83,"code":"  it('can\\'t move completed todo', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'todo',\n      text: 'todo 1'\n    });\n    await user.post(`/tasks/${task._id}/score/up`);\n    await expect(user.post(`/tasks/${task._id}/move/to/1`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('cantMoveCompletedTodo')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_move_taskId_to_position.test.js","skipped":false,"dir":"test"},{"name":"can push to bottom","suites":["POST /tasks/:taskId/move/to/:position"],"updatePoint":{"line":95,"column":24,"index":2755},"line":95,"code":"  it('can push to bottom', async () => {\n    const tasks = await user.post('/tasks/user', [{\n      type: 'habit',\n      text: 'habit 1'\n    }, {\n      type: 'habit',\n      text: 'habit 2'\n    }, {\n      type: 'daily',\n      text: 'daily 1'\n    }, {\n      type: 'habit',\n      text: 'habit 3'\n    }, {\n      type: 'habit',\n      text: 'habit 4'\n    }, {\n      type: 'todo',\n      text: 'todo 1'\n    }, {\n      type: 'habit',\n      text: 'habit 5'\n    }]);\n    const taskToMove = tasks[1];\n    expect(taskToMove.text).to.equal('habit 2');\n    await user.post(`/tasks/${tasks[1]._id}/move/to/-1`);\n    await user.sync();\n    const newOrder = user.tasksOrder.habits;\n    expect(newOrder[4]).to.equal(taskToMove._id);\n    expect(newOrder.length).to.equal(5);\n  });","file":"api/v3/integration/tasks/POST-tasks_move_taskId_to_position.test.js","skipped":false,"dir":"test"},{"name":"fails if no keep query","suites":["POST /tasks/unlink-all/:challengeId"],"updatePoint":{"line":35,"column":28,"index":864},"line":35,"code":"  it('fails if no keep query', async () => {\n    await expect(user.post(`/tasks/unlink-all/${challenge._id}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-all_challengeId.test.js","skipped":false,"dir":"test"},{"name":"fails if invalid challenge id","suites":["POST /tasks/unlink-all/:challengeId"],"updatePoint":{"line":42,"column":35,"index":1113},"line":42,"code":"  it('fails if invalid challenge id', async () => {\n    await expect(user.post('/tasks/unlink-all/123?keep=remove-all')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-all_challengeId.test.js","skipped":false,"dir":"test"},{"name":"fails on an unbroken challenge","suites":["POST /tasks/unlink-all/:challengeId"],"updatePoint":{"line":49,"column":36,"index":1366},"line":49,"code":"  it('fails on an unbroken challenge', async () => {\n    await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.daily);\n    await expect(user.post(`/tasks/unlink-all/${challenge._id}?keep=remove-all`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('cantOnlyUnlinkChalTask')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-all_challengeId.test.js","skipped":false,"dir":"test"},{"name":"unlinks all tasks from a challenge and deletes them on keep=remove-all","suites":["POST /tasks/unlink-all/:challengeId"],"updatePoint":{"line":57,"column":76,"index":1755},"line":57,"code":"  it('unlinks all tasks from a challenge and deletes them on keep=remove-all', async () => {\n    const daily = await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.daily);\n    await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.habit);\n    await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.reward);\n    await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.todo);\n    await user.del(`/challenges/${challenge._id}`);\n    const response = await user.post(`/tasks/unlink-all/${challenge._id}?keep=remove-all`);\n    expect(response).to.eql({});\n    await expect(user.get(`/tasks/${daily._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-all_challengeId.test.js","skipped":false,"dir":"test"},{"name":"unlinks a task from a challenge on keep=keep-all","suites":["POST /tasks/unlink-all/:challengeId"],"updatePoint":{"line":71,"column":54,"index":2507},"line":71,"code":"  it('unlinks a task from a challenge on keep=keep-all', async () => {\n    const daily = await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.daily);\n    const anotherUser = await generateUser();\n    await user.post(`/groups/${guild._id}/invite`, {\n      uuids: [anotherUser._id]\n    }); // Have the second user join the group and challenge\n\n    await anotherUser.post(`/groups/${guild._id}/join`);\n    await anotherUser.post(`/challenges/${challenge._id}/join`); // Have the leader delete the challenge and unlink the tasks\n\n    await user.del(`/challenges/${challenge._id}`);\n    await user.post(`/tasks/unlink-all/${challenge._id}?keep=keep-all`); // Get the task for the second user\n\n    const [anotherUserTask] = await anotherUser.get('/tasks/user'); // Expect the second user to still have the task, but unlinked\n\n    expect(anotherUserTask.challenge).to.eql({\n      taskId: daily._id,\n      id: challenge._id,\n      shortName: challenge.shortName,\n      broken: 'CHALLENGE_DELETED',\n      winner: null\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-all_challengeId.test.js","skipped":false,"dir":"test"},{"name":"fails if no keep query","suites":["POST /tasks/unlink-one/:taskId"],"updatePoint":{"line":36,"column":28,"index":902},"line":36,"code":"  it('fails if no keep query', async () => {\n    const daily = await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.daily);\n    await expect(user.post(`/tasks/unlink-one/${daily._id}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-one_taskId.test.js","skipped":false,"dir":"test"},{"name":"fails if invalid task id","suites":["POST /tasks/unlink-one/:taskId"],"updatePoint":{"line":44,"column":30,"index":1233},"line":44,"code":"  it('fails if invalid task id', async () => {\n    await expect(user.post('/tasks/unlink-one/123?keep=remove')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-one_taskId.test.js","skipped":false,"dir":"test"},{"name":"fails on task not found","suites":["POST /tasks/unlink-one/:taskId"],"updatePoint":{"line":51,"column":29,"index":1475},"line":51,"code":"  it('fails on task not found', async () => {\n    await expect(user.post(`/tasks/unlink-one/${generateUUID()}?keep=keep`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-one_taskId.test.js","skipped":false,"dir":"test"},{"name":"fails on task unlinked to challenge","suites":["POST /tasks/unlink-one/:taskId"],"updatePoint":{"line":58,"column":41,"index":1742},"line":58,"code":"  it('fails on task unlinked to challenge', async () => {\n    const daily = await user.post('/tasks/user', tasksToTest.daily);\n    await expect(user.post(`/tasks/unlink-one/${daily._id}?keep=keep`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('cantOnlyUnlinkChalTask')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-one_taskId.test.js","skipped":false,"dir":"test"},{"name":"fails on unbroken challenge","suites":["POST /tasks/unlink-one/:taskId"],"updatePoint":{"line":66,"column":33,"index":2070},"line":66,"code":"  it('fails on unbroken challenge', async () => {\n    await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.daily);\n    const [daily] = await user.get('/tasks/user');\n    await expect(user.post(`/tasks/unlink-one/${daily._id}?keep=keep`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('cantOnlyUnlinkChalTask')\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-one_taskId.test.js","skipped":false,"dir":"test"},{"name":"unlinks a task from a challenge and saves it on keep=keep","suites":["POST /tasks/unlink-one/:taskId"],"updatePoint":{"line":75,"column":63,"index":2487},"line":75,"code":"  it('unlinks a task from a challenge and saves it on keep=keep', async () => {\n    await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.daily);\n    let [daily] = await user.get('/tasks/user');\n    await user.del(`/challenges/${challenge._id}`);\n    await user.post(`/tasks/unlink-one/${daily._id}?keep=keep`);\n    [daily] = await user.get('/tasks/user');\n    expect(daily.challenge).to.eql({});\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-one_taskId.test.js","skipped":false,"dir":"test"},{"name":"unlinks a task from a challenge and deletes it on keep=remove","suites":["POST /tasks/unlink-one/:taskId"],"updatePoint":{"line":83,"column":67,"index":2905},"line":83,"code":"  it('unlinks a task from a challenge and deletes it on keep=remove', async () => {\n    await user.post(`/tasks/challenge/${challenge._id}`, tasksToTest.daily);\n    const [daily] = await user.get('/tasks/user');\n    await user.del(`/challenges/${challenge._id}`);\n    await user.post(`/tasks/unlink-one/${daily._id}?keep=remove`);\n    const tasks = await user.get('/tasks/user'); // Only the default task should remain\n\n    expect(tasks.length).to.eql(1);\n  });","file":"api/v3/integration/tasks/POST-tasks_unlink-one_taskId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.body.type is absent","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":15,"column":51,"index":500},"line":15,"code":"    it('returns an error if req.body.type is absent', async () => {\n      await expect(user.post('/tasks/user', {\n        notType: 'habit'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidTaskType')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.body.type is not valid","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":24,"column":54,"index":792},"line":24,"code":"    it('returns an error if req.body.type is not valid', async () => {\n      await expect(user.post('/tasks/user', {\n        type: 'habitF'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidTaskType')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if one object inside an array is invalid","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":33,"column":65,"index":1093},"line":33,"code":"    it('returns an error if one object inside an array is invalid', async () => {\n      await expect(user.post('/tasks/user', [{\n        type: 'habitF'\n      }, {\n        type: 'habit'\n      }])).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidTaskType')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if req.body.text is absent","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":44,"column":51,"index":1415},"line":44,"code":"    it('returns an error if req.body.text is absent', async () => {\n      await expect(user.post('/tasks/user', {\n        type: 'habit'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'habit validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if reward value is a negative number","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":53,"column":61,"index":1716},"line":53,"code":"    it('returns an error if reward value is a negative number', async () => {\n      await expect(user.post('/tasks/user', {\n        type: 'reward',\n        text: 'reward with negative value',\n        value: -10\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'reward validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"does not update user.tasksOrder.{taskType} when the task is not saved because invalid","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":64,"column":93,"index":2115},"line":64,"code":"    it('does not update user.tasksOrder.{taskType} when the task is not saved because invalid', async () => {\n      const originalHabitsOrder = (await user.get('/user')).tasksOrder.habits;\n      await expect(user.post('/tasks/user', {\n        type: 'habit'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'habit validation failed'\n      });\n      const updatedHabitsOrder = (await user.get('/user')).tasksOrder.habits;\n      expect(updatedHabitsOrder).to.eql(originalHabitsOrder);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"does not update user.tasksOrder.{taskType} when a task inside an array is not saved because invalid","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":76,"column":107,"index":2681},"line":76,"code":"    it('does not update user.tasksOrder.{taskType} when a task inside an array is not saved because invalid', async () => {\n      const originalHabitsOrder = (await user.get('/user')).tasksOrder.habits;\n      await expect(user.post('/tasks/user', [{\n        type: 'habit'\n      }, // Missing text\n      {\n        type: 'habit',\n        text: 'valid'\n      } // Valid\n      ])).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'habit validation failed'\n      });\n      const updatedHabitsOrder = (await user.get('/user')).tasksOrder.habits;\n      expect(updatedHabitsOrder).to.eql(originalHabitsOrder);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"does not save any task sent in an array when 1 is invalid","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":93,"column":65,"index":3301},"line":93,"code":"    it('does not save any task sent in an array when 1 is invalid', async () => {\n      const originalTasks = await user.get('/tasks/user');\n      await expect(user.post('/tasks/user', [{\n        type: 'habit'\n      }, // Missing text\n      {\n        type: 'habit',\n        text: 'valid'\n      } // Valid\n      ])).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'habit validation failed'\n      }).then(async () => {\n        const updatedTasks = await user.get('/tasks/user');\n        expect(updatedTasks).to.eql(originalTasks);\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"automatically sets \"task.userId\" to user's uuid","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":111,"column":56,"index":3892},"line":111,"code":"    it('automatically sets \"task.userId\" to user\\'s uuid', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      expect(task.userId).to.equal(user._id);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"ignores setting userId, history, createdAt,\n                        updatedAt, challenge, completed,\n                        dateCompleted fields","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":120,"column":44,"index":4228},"line":118,"code":"    it(`ignores setting userId, history, createdAt,\n                        updatedAt, challenge, completed,\n                        dateCompleted fields`, async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        userId: 123,\n        history: [123],\n        createdAt: 'yesterday',\n        updatedAt: 'tomorrow',\n        challenge: 'no',\n        completed: true,\n        dateCompleted: 'never',\n        value: 324 // ignored because not a reward\n\n      });\n      expect(task.userId).to.equal(user._id);\n      expect(task.history).to.eql([]);\n      expect(task.createdAt).not.to.equal('yesterday');\n      expect(task.updatedAt).not.to.equal('tomorrow');\n      expect(task.challenge).not.to.equal('no');\n      expect(task.completed).to.equal(false);\n      expect(task.dateCompleted).not.to.equal('never');\n      expect(task.value).not.to.equal(324);\n      expect(task.yesterDaily).to.equal(true);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"ignores invalid fields","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":144,"column":30,"index":5076},"line":144,"code":"    it('ignores invalid fields', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        notValid: true\n      });\n      expect(task).not.to.have.property('notValid');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"errors if alias already exists on another task","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":152,"column":54,"index":5344},"line":152,"code":"    it('errors if alias already exists on another task', async () => {\n      await user.post('/tasks/user', {\n        // first task that will succeed\n        type: 'habit',\n        text: 'todo text',\n        alias: 'alias'\n      });\n      await expect(user.post('/tasks/user', {\n        type: 'todo',\n        text: 'todo text',\n        alias: 'alias'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'todo validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"errors if alias contains invalid values","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":169,"column":47,"index":5842},"line":169,"code":"    it('errors if alias contains invalid values', async () => {\n      await expect(user.post('/tasks/user', {\n        type: 'todo',\n        text: 'todo text',\n        alias: 'short name!'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'todo validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"errors if alias is a valid uuid","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":180,"column":39,"index":6176},"line":180,"code":"    it('errors if alias is a valid uuid', async () => {\n      await expect(user.post('/tasks/user', {\n        type: 'todo',\n        text: 'todo text',\n        alias: generateUUID()\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'todo validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"errors if the same shortname is used on 2 or more tasks","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":191,"column":63,"index":6535},"line":191,"code":"    it('errors if the same shortname is used on 2 or more tasks', async () => {\n      await expect(user.post('/tasks/user', [{\n        type: 'habit',\n        text: 'habit text',\n        alias: 'alias'\n      }, {\n        type: 'todo',\n        text: 'todo text'\n      }, {\n        type: 'todo',\n        text: 'todo text',\n        alias: 'alias'\n      }])).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('taskAliasAlreadyUsed')\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"errors if todo due date supplied is an invalid date","suites":["POST /tasks/user","validates params"],"updatePoint":{"line":210,"column":57,"index":7034},"line":210,"code":"  it('errors if todo due date supplied is an invalid date', async () => {\n    await expect(user.post('/tasks/user', {\n      type: 'todo',\n      text: 'todo text',\n      date: 'invalid date'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'todo validation failed'\n    });\n  });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"sends task activity webhooks","suites":["POST /tasks/user","sending task activity webhooks"],"updatePoint":{"line":228,"column":36,"index":7518},"line":228,"code":"    it('sends task activity webhooks', async () => {\n      const uuid = generateUUID();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          created: true\n        }\n      });\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(body.task).to.eql(task);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"sends a task activity webhook for each task","suites":["POST /tasks/user","sending task activity webhooks"],"updatePoint":{"line":246,"column":51,"index":8070},"line":246,"code":"    it('sends a task activity webhook for each task', async () => {\n      const uuid = generateUUID();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          created: true\n        }\n      });\n      const tasks = await user.post('/tasks/user', [{\n        text: 'test habit',\n        type: 'habit'\n      }, {\n        text: 'test todo',\n        type: 'todo'\n      }]);\n      await sleep();\n      const taskBodies = [server.getWebhookData(uuid), server.getWebhookData(uuid)];\n      expect(taskBodies.find(body => body.task.id === tasks[0].id)).to.exist;\n      expect(taskBodies.find(body => body.task.id === tasks[1].id)).to.exist;\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"can create reminders","suites":["POST /tasks/user","all types"],"updatePoint":{"line":270,"column":28,"index":8853},"line":270,"code":"    it('can create reminders', async () => {\n      const id1 = generateUUID();\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit',\n        reminders: [{\n          id: id1,\n          startDate: new Date(),\n          time: new Date()\n        }]\n      });\n      expect(task.reminders).to.be.an('array');\n      expect(task.reminders.length).to.eql(1);\n      expect(task.reminders[0]).to.be.an('object');\n      expect(task.reminders[0].id).to.eql(id1);\n      expect(task.reminders[0].startDate).to.be.a('string'); // json doesn't have dates\n\n      expect(task.reminders[0].time).to.be.a('string');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"can create a task with a alias","suites":["POST /tasks/user","all types"],"updatePoint":{"line":289,"column":38,"index":9515},"line":289,"code":"    it('can create a task with a alias', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit',\n        alias: 'a_alias012'\n      });\n      expect(task.alias).to.eql('a_alias012');\n    }); // This is a special case for iOS requests","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"will round a priority (difficulty)","suites":["POST /tasks/user","all types"],"updatePoint":{"line":298,"column":42,"index":9814},"line":298,"code":"    it('will round a priority (difficulty)', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit',\n        priority: 0.10000000000005\n      });\n      expect(task.priority).to.eql(0.1);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"creates a habit","suites":["POST /tasks/user","habits"],"updatePoint":{"line":308,"column":23,"index":10085},"line":308,"code":"    it('creates a habit', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit',\n        up: false,\n        down: true,\n        notes: 1976\n      });\n      expect(task.userId).to.equal(user._id);\n      expect(task.text).to.eql('test habit');\n      expect(task.notes).to.eql('1976');\n      expect(task.type).to.eql('habit');\n      expect(task.up).to.eql(false);\n      expect(task.down).to.eql(true);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"updates user.tasksOrder.habits when a new habit is created","suites":["POST /tasks/user","habits"],"updatePoint":{"line":323,"column":66,"index":10597},"line":323,"code":"    it('updates user.tasksOrder.habits when a new habit is created', async () => {\n      const originalHabitsOrderLen = (await user.get('/user')).tasksOrder.habits.length;\n      const task = await user.post('/tasks/user', {\n        type: 'habit',\n        text: 'an habit'\n      });\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.habits[0]).to.eql(task._id);\n      expect(updatedUser.tasksOrder.habits.length).to.eql(originalHabitsOrderLen + 1);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"updates user.tasksOrder.habits when multiple habits are created","suites":["POST /tasks/user","habits"],"updatePoint":{"line":333,"column":71,"index":11095},"line":333,"code":"    it('updates user.tasksOrder.habits when multiple habits are created', async () => {\n      const originalHabitsOrderLen = (await user.get('/user')).tasksOrder.habits.length;\n      const [task, task2] = await user.post('/tasks/user', [{\n        type: 'habit',\n        text: 'an habit'\n      }, {\n        type: 'habit',\n        text: 'another habit'\n      }]);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.habits[0]).to.eql(task2._id);\n      expect(updatedUser.tasksOrder.habits[1]).to.eql(task._id);\n      expect(updatedUser.tasksOrder.habits.length).to.eql(originalHabitsOrderLen + 2);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"creates multiple habits","suites":["POST /tasks/user","habits"],"updatePoint":{"line":347,"column":31,"index":11694},"line":347,"code":"    it('creates multiple habits', async () => {\n      const [task, task2] = await user.post('/tasks/user', [{\n        text: 'test habit',\n        type: 'habit',\n        up: false,\n        down: true,\n        notes: 1976\n      }, {\n        text: 'test habit 2',\n        type: 'habit',\n        up: true,\n        down: false,\n        notes: 1977\n      }]);\n      expect(task.userId).to.equal(user._id);\n      expect(task.text).to.eql('test habit');\n      expect(task.notes).to.eql('1976');\n      expect(task.type).to.eql('habit');\n      expect(task.up).to.eql(false);\n      expect(task.down).to.eql(true);\n      expect(task2.userId).to.equal(user._id);\n      expect(task2.text).to.eql('test habit 2');\n      expect(task2.notes).to.eql('1977');\n      expect(task2.type).to.eql('habit');\n      expect(task2.up).to.eql(true);\n      expect(task2.down).to.eql(false);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"defaults to setting up and down to true","suites":["POST /tasks/user","habits"],"updatePoint":{"line":374,"column":47,"index":12578},"line":374,"code":"    it('defaults to setting up and down to true', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit',\n        notes: 1976\n      });\n      expect(task.up).to.eql(true);\n      expect(task.down).to.eql(true);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"cannot create checklists","suites":["POST /tasks/user","habits"],"updatePoint":{"line":383,"column":32,"index":12842},"line":383,"code":"    it('cannot create checklists', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit',\n        checklist: [{\n          _id: 123,\n          completed: false,\n          text: 'checklist'\n        }]\n      });\n      expect(task).not.to.have.property('checklist');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"creates a todo","suites":["POST /tasks/user","todos"],"updatePoint":{"line":397,"column":22,"index":13198},"line":397,"code":"    it('creates a todo', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test todo',\n        type: 'todo',\n        notes: 1976\n      });\n      expect(task.userId).to.equal(user._id);\n      expect(task.text).to.eql('test todo');\n      expect(task.notes).to.eql('1976');\n      expect(task.type).to.eql('todo');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"creates multiple todos","suites":["POST /tasks/user","todos"],"updatePoint":{"line":408,"column":30,"index":13556},"line":408,"code":"    it('creates multiple todos', async () => {\n      const [task, task2] = await user.post('/tasks/user', [{\n        text: 'test todo',\n        type: 'todo',\n        notes: 1976\n      }, {\n        text: 'test todo 2',\n        type: 'todo',\n        notes: 1977\n      }]);\n      expect(task.userId).to.equal(user._id);\n      expect(task.text).to.eql('test todo');\n      expect(task.notes).to.eql('1976');\n      expect(task.type).to.eql('todo');\n      expect(task2.userId).to.equal(user._id);\n      expect(task2.text).to.eql('test todo 2');\n      expect(task2.notes).to.eql('1977');\n      expect(task2.type).to.eql('todo');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"updates user.tasksOrder.todos when a new todo is created","suites":["POST /tasks/user","todos"],"updatePoint":{"line":427,"column":64,"index":14219},"line":427,"code":"    it('updates user.tasksOrder.todos when a new todo is created', async () => {\n      const originalTodosOrderLen = (await user.get('/user')).tasksOrder.todos.length;\n      const task = await user.post('/tasks/user', {\n        type: 'todo',\n        text: 'a todo'\n      });\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.todos[0]).to.eql(task._id);\n      expect(updatedUser.tasksOrder.todos.length).to.eql(originalTodosOrderLen + 1);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"updates user.tasksOrder.todos when multiple todos are created","suites":["POST /tasks/user","todos"],"updatePoint":{"line":437,"column":69,"index":14707},"line":437,"code":"    it('updates user.tasksOrder.todos when multiple todos are created', async () => {\n      const originalTodosOrderLen = (await user.get('/user')).tasksOrder.todos.length;\n      const [task, task2] = await user.post('/tasks/user', [{\n        type: 'todo',\n        text: 'a todo'\n      }, {\n        type: 'todo',\n        text: 'another todo'\n      }]);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.todos[0]).to.eql(task2._id);\n      expect(updatedUser.tasksOrder.todos[1]).to.eql(task._id);\n      expect(updatedUser.tasksOrder.todos.length).to.eql(originalTodosOrderLen + 2);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"can create checklists","suites":["POST /tasks/user","todos"],"updatePoint":{"line":451,"column":29,"index":15293},"line":451,"code":"    it('can create checklists', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test todo',\n        type: 'todo',\n        checklist: [{\n          completed: false,\n          text: 'checklist'\n        }]\n      });\n      expect(task.checklist).to.be.an('array');\n      expect(task.checklist.length).to.eql(1);\n      expect(task.checklist[0]).to.be.an('object');\n      expect(task.checklist[0].text).to.eql('checklist');\n      expect(task.checklist[0].completed).to.eql(false);\n      expect(task.checklist[0].id).to.be.a('string');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"creates a daily","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":469,"column":23,"index":15891},"line":469,"code":"    it('creates a daily', async () => {\n      const now = new Date();\n      const task = await user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        notes: 1976,\n        frequency: 'daily',\n        everyX: 5,\n        startDate: now,\n        daysOfMonth: [15],\n        weeksOfMonth: [3]\n      });\n      expect(task.userId).to.equal(user._id);\n      expect(task.text).to.eql('test daily');\n      expect(task.notes).to.eql('1976');\n      expect(task.type).to.eql('daily');\n      expect(task.frequency).to.eql('daily');\n      expect(task.everyX).to.eql(5);\n      expect(task.daysOfMonth).to.eql([15]);\n      expect(task.weeksOfMonth).to.eql([3]);\n      expect(new Date(task.startDate)).to.eql(new Date(now.setHours(0, 0, 0, 0)));\n      expect(task.isDue).to.be.true;\n      expect(task.nextDue.length).to.eql(6);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"creates multiple dailys","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":493,"column":31,"index":16747},"line":493,"code":"    it('creates multiple dailys', async () => {\n      const [task, task2] = await user.post('/tasks/user', [{\n        text: 'test daily',\n        type: 'daily',\n        notes: 1976\n      }, {\n        text: 'test daily 2',\n        type: 'daily',\n        notes: 1977\n      }]);\n      expect(task.userId).to.equal(user._id);\n      expect(task.text).to.eql('test daily');\n      expect(task.notes).to.eql('1976');\n      expect(task.type).to.eql('daily');\n      expect(task2.userId).to.equal(user._id);\n      expect(task2.text).to.eql('test daily 2');\n      expect(task2.notes).to.eql('1977');\n      expect(task2.type).to.eql('daily');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"updates user.tasksOrder.dailys when a new daily is created","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":512,"column":66,"index":17420},"line":512,"code":"    it('updates user.tasksOrder.dailys when a new daily is created', async () => {\n      const originalDailysOrderLen = (await user.get('/user')).tasksOrder.dailys.length;\n      const task = await user.post('/tasks/user', {\n        type: 'daily',\n        text: 'a daily'\n      });\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.dailys[0]).to.eql(task._id);\n      expect(updatedUser.tasksOrder.dailys.length).to.eql(originalDailysOrderLen + 1);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"updates user.tasksOrder.dailys when multiple dailys are created","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":522,"column":71,"index":17917},"line":522,"code":"    it('updates user.tasksOrder.dailys when multiple dailys are created', async () => {\n      const originalDailysOrderLen = (await user.get('/user')).tasksOrder.dailys.length;\n      const [task, task2] = await user.post('/tasks/user', [{\n        type: 'daily',\n        text: 'a daily'\n      }, {\n        type: 'daily',\n        text: 'another daily'\n      }]);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.dailys[0]).to.eql(task2._id);\n      expect(updatedUser.tasksOrder.dailys[1]).to.eql(task._id);\n      expect(updatedUser.tasksOrder.dailys.length).to.eql(originalDailysOrderLen + 2);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"defaults to a weekly frequency, with every day set","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":536,"column":58,"index":18542},"line":536,"code":"    it('defaults to a weekly frequency, with every day set', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily'\n      });\n      expect(task.frequency).to.eql('weekly');\n      expect(task.everyX).to.eql(1);\n      expect(task.repeat).to.eql({\n        m: true,\n        t: true,\n        w: true,\n        th: true,\n        f: true,\n        s: true,\n        su: true\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"allows repeat field to be configured","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":553,"column":44,"index":18972},"line":553,"code":"    it('allows repeat field to be configured', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        repeat: {\n          m: false,\n          w: false,\n          su: false\n        }\n      });\n      expect(task.repeat).to.eql({\n        m: false,\n        t: true,\n        w: false,\n        th: true,\n        f: true,\n        s: true,\n        su: false\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"defaults startDate to today","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":573,"column":35,"index":19401},"line":573,"code":"    it('defaults startDate to today', async () => {\n      const today = new Date().getDay();\n      const task = await user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily'\n      });\n      expect(new Date(task.startDate).getDay()).to.eql(today);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the start date is empty","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":581,"column":51,"index":19693},"line":581,"code":"    it('returns an error if the start date is empty', async () => {\n      await expect(user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        startDate: ''\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'daily validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if everyX is a non int","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":592,"column":47,"index":20031},"line":592,"code":"    it('returns an error if everyX is a non int', async () => {\n      await expect(user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        everyX: 2.5\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'daily validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if everyX is negative","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":603,"column":46,"index":20366},"line":603,"code":"    it('returns an error if everyX is negative', async () => {\n      await expect(user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        everyX: -1\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'daily validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if everyX is above 9999","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":614,"column":48,"index":20702},"line":614,"code":"    it('returns an error if everyX is above 9999', async () => {\n      await expect(user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        everyX: 10000\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'daily validation failed'\n      });\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"can create checklists","suites":["POST /tasks/user","dailys"],"updatePoint":{"line":625,"column":29,"index":21022},"line":625,"code":"    it('can create checklists', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test daily',\n        type: 'daily',\n        checklist: [{\n          completed: false,\n          text: 'checklist'\n        }]\n      });\n      expect(task.checklist).to.be.an('array');\n      expect(task.checklist.length).to.eql(1);\n      expect(task.checklist[0]).to.be.an('object');\n      expect(task.checklist[0].text).to.eql('checklist');\n      expect(task.checklist[0].completed).to.eql(false);\n      expect(task.checklist[0].id).to.be.a('string');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"creates a reward","suites":["POST /tasks/user","rewards"],"updatePoint":{"line":643,"column":24,"index":21624},"line":643,"code":"    it('creates a reward', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test reward',\n        type: 'reward',\n        notes: 1976,\n        value: 10\n      });\n      expect(task.userId).to.equal(user._id);\n      expect(task.text).to.eql('test reward');\n      expect(task.notes).to.eql('1976');\n      expect(task.type).to.eql('reward');\n      expect(task.value).to.eql(10);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"creates multiple rewards","suites":["POST /tasks/user","rewards"],"updatePoint":{"line":656,"column":32,"index":22048},"line":656,"code":"    it('creates multiple rewards', async () => {\n      const [task, task2] = await user.post('/tasks/user', [{\n        text: 'test reward',\n        type: 'reward',\n        notes: 1976,\n        value: 11\n      }, {\n        text: 'test reward 2',\n        type: 'reward',\n        notes: 1977,\n        value: 12\n      }]);\n      expect(task.userId).to.equal(user._id);\n      expect(task.text).to.eql('test reward');\n      expect(task.notes).to.eql('1976');\n      expect(task.type).to.eql('reward');\n      expect(task.value).to.eql(11);\n      expect(task2.userId).to.equal(user._id);\n      expect(task2.text).to.eql('test reward 2');\n      expect(task2.notes).to.eql('1977');\n      expect(task2.type).to.eql('reward');\n      expect(task2.value).to.eql(12);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"updates user.tasksOrder.rewards when a new reward is created","suites":["POST /tasks/user","rewards"],"updatePoint":{"line":679,"column":68,"index":22844},"line":679,"code":"    it('updates user.tasksOrder.rewards when a new reward is created', async () => {\n      const originalRewardsOrderLen = (await user.get('/user')).tasksOrder.rewards.length;\n      const task = await user.post('/tasks/user', {\n        type: 'reward',\n        text: 'a reward'\n      });\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.rewards[0]).to.eql(task._id);\n      expect(updatedUser.tasksOrder.rewards.length).to.eql(originalRewardsOrderLen + 1);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"updates user.tasksOrder.dreward when multiple rewards are created","suites":["POST /tasks/user","rewards"],"updatePoint":{"line":689,"column":73,"index":23350},"line":689,"code":"    it('updates user.tasksOrder.dreward when multiple rewards are created', async () => {\n      const originalRewardsOrderLen = (await user.get('/user')).tasksOrder.rewards.length;\n      const [task, task2] = await user.post('/tasks/user', [{\n        type: 'reward',\n        text: 'a reward'\n      }, {\n        type: 'reward',\n        text: 'another reward'\n      }]);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.rewards[0]).to.eql(task2._id);\n      expect(updatedUser.tasksOrder.rewards[1]).to.eql(task._id);\n      expect(updatedUser.tasksOrder.rewards.length).to.eql(originalRewardsOrderLen + 2);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"defaults to a 0 value","suites":["POST /tasks/user","rewards"],"updatePoint":{"line":703,"column":29,"index":23956},"line":703,"code":"    it('defaults to a 0 value', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test reward',\n        type: 'reward'\n      });\n      expect(task.value).to.eql(0);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"requires value to be coerced into a number","suites":["POST /tasks/user","rewards"],"updatePoint":{"line":710,"column":50,"index":24181},"line":710,"code":"    it('requires value to be coerced into a number', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test reward',\n        type: 'reward',\n        value: '10'\n      });\n      expect(task.value).to.eql(10);\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"cannot create checklists","suites":["POST /tasks/user","rewards"],"updatePoint":{"line":718,"column":32,"index":24410},"line":718,"code":"    it('cannot create checklists', async () => {\n      const task = await user.post('/tasks/user', {\n        text: 'test reward',\n        type: 'reward',\n        checklist: [{\n          _id: 123,\n          completed: false,\n          text: 'checklist'\n        }]\n      });\n      expect(task).not.to.have.property('checklist');\n    });","file":"api/v3/integration/tasks/POST-tasks_user.test.js","skipped":false,"dir":"test"},{"name":"ignores setting _id, type, userId, history, createdAt,\n                        updatedAt, challenge, completed, streak,\n                        dateCompleted fields","suites":["PUT /tasks/:id","validates params"],"updatePoint":{"line":25,"column":44,"index":817},"line":23,"code":"    it(`ignores setting _id, type, userId, history, createdAt,\n                        updatedAt, challenge, completed, streak,\n                        dateCompleted fields`, async () => {\n      const savedTask = await user.put(`/tasks/${task._id}`, {\n        _id: 123,\n        type: 'daily',\n        userId: 123,\n        history: [123],\n        createdAt: 'yesterday',\n        updatedAt: 'tomorrow',\n        challenge: 'no',\n        completed: true,\n        streak: 25,\n        dateCompleted: 'never'\n      });\n      expect(savedTask._id).to.equal(task._id);\n      expect(savedTask.type).to.equal(task.type);\n      expect(savedTask.userId).to.equal(task.userId);\n      expect(savedTask.history).to.eql(task.history);\n      expect(savedTask.createdAt).to.equal(task.createdAt);\n      expect(new Date(savedTask.updatedAt)).to.be.greaterThan(new Date(task.updatedAt));\n      expect(savedTask.challenge).to.eql(task.challenge);\n      expect(savedTask.completed).to.eql(task.completed);\n      expect(savedTask.streak).to.equal(savedTask.streak); // it's an habit, dailies can change it\n\n      expect(savedTask.dateCompleted).to.equal(task.dateCompleted);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"ignores invalid fields","suites":["PUT /tasks/:id","validates params"],"updatePoint":{"line":50,"column":30,"index":1834},"line":50,"code":"    it('ignores invalid fields', async () => {\n      const savedTask = await user.put(`/tasks/${task._id}`, {\n        notValid: true\n      });\n      expect(savedTask.notValid).to.be.undefined;\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"only allows setting streak, alias, reminders, checklist, notes, attribute, tags\n        fields for challenge tasks owned by a user","suites":["PUT /tasks/:id","validates params"],"updatePoint":{"line":57,"column":50,"index":2143},"line":56,"code":"    it(`only allows setting streak, alias, reminders, checklist, notes, attribute, tags\n        fields for challenge tasks owned by a user`, async () => {\n      const guild = await generateGroup(user);\n      const challenge = await generateChallenge(user, guild);\n      await user.post(`/challenges/${challenge._id}/join`);\n      const challengeTask = await user.post(`/tasks/challenge/${challenge._id}`, {\n        type: 'daily',\n        text: 'Daily in challenge',\n        reminders: [{\n          time: new Date(),\n          startDate: new Date()\n        }],\n        checklist: [{\n          text: 123,\n          completed: false\n        }],\n        collapseChecklist: false\n      });\n      await sleep(2);\n      await user.sync(); // Pick challenge task\n\n      const challengeUserTaskId = user.tasksOrder.dailys[user.tasksOrder.dailys.length - 1];\n      const challengeUserTask = await user.get(`/tasks/${challengeUserTaskId}`);\n      const savedChallengeUserTask = await user.put(`/tasks/${challengeUserTaskId}`, {\n        _id: 123,\n        type: 'daily',\n        userId: 123,\n        alias: 'a-short-task-name',\n        history: [123],\n        createdAt: 'yesterday',\n        updatedAt: 'tomorrow',\n        challenge: 'no',\n        completed: true,\n        streak: 25,\n        priority: 1.5,\n        repeat: {\n          m: false\n        },\n        everyX: 15,\n        frequency: 'weekly',\n        text: 'new text',\n        dateCompleted: 'never',\n        reminders: [{\n          time: new Date(),\n          startDate: new Date()\n        }, {\n          time: new Date(),\n          startDate: new Date()\n        }],\n        checklist: [{\n          text: 123,\n          completed: false\n        }, {\n          text: 456,\n          completed: true\n        }],\n        collapseChecklist: true,\n        notes: 'new notes',\n        attribute: 'per',\n        tags: [challengeUserTaskId]\n      }); // original task is not touched\n\n      const updatedChallengeTask = await user.get(`/tasks/${challengeTask._id}`);\n      expect(updatedChallengeTask).to.eql(challengeTask); // ignored\n\n      expect(savedChallengeUserTask._id).to.equal(challengeUserTask._id);\n      expect(savedChallengeUserTask.type).to.equal(challengeUserTask.type);\n      expect(savedChallengeUserTask.repeat.m).to.equal(true);\n      expect(savedChallengeUserTask.priority).to.equal(challengeUserTask.priority);\n      expect(savedChallengeUserTask.frequency).to.equal(challengeUserTask.frequency);\n      expect(savedChallengeUserTask.userId).to.equal(challengeUserTask.userId);\n      expect(savedChallengeUserTask.text).to.equal(challengeUserTask.text);\n      expect(savedChallengeUserTask.history).to.eql(challengeUserTask.history);\n      expect(savedChallengeUserTask.createdAt).to.equal(challengeUserTask.createdAt);\n      expect(new Date(savedChallengeUserTask.updatedAt)).to.be.greaterThan(new Date(challengeUserTask.updatedAt));\n      expect(savedChallengeUserTask.challenge).to.eql(challengeUserTask.challenge);\n      expect(savedChallengeUserTask.completed).to.equal(challengeUserTask.completed);\n      expect(savedChallengeUserTask.dateCompleted).to.equal(challengeUserTask.dateCompleted);\n      expect(savedChallengeUserTask.priority).to.equal(challengeUserTask.priority); // changed\n\n      expect(savedChallengeUserTask.notes).to.equal('new notes');\n      expect(savedChallengeUserTask.attribute).to.equal('per');\n      expect(savedChallengeUserTask.tags).to.eql([challengeUserTaskId]);\n      expect(savedChallengeUserTask.streak).to.equal(25);\n      expect(savedChallengeUserTask.reminders.length).to.equal(2);\n      expect(savedChallengeUserTask.checklist.length).to.equal(2);\n      expect(savedChallengeUserTask.alias).to.equal('a-short-task-name');\n      expect(savedChallengeUserTask.collapseChecklist).to.equal(true);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"sends task activity webhooks if task is user owned","suites":["PUT /tasks/:id","sending task activity webhooks"],"updatePoint":{"line":153,"column":58,"index":6046},"line":153,"code":"    it('sends task activity webhooks if task is user owned', async () => {\n      const uuid = generateUUID();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          created: false,\n          updated: true\n        }\n      });\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      const updatedTask = await user.put(`/tasks/${task.id}`, {\n        text: 'updated text'\n      });\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(body.type).to.eql('updated');\n      expect(body.task).to.eql(updatedTask);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"does not send task activity webhooks if task is not user owned","suites":["PUT /tasks/:id","sending task activity webhooks"],"updatePoint":{"line":176,"column":70,"index":6796},"line":176,"code":"    it('does not send task activity webhooks if task is not user owned', async () => {\n      const uuid = generateUUID();\n      await user.update({\n        balance: 10\n      });\n      const guild = await generateGroup(user);\n      const challenge = await generateChallenge(user, guild);\n      await user.post(`/challenges/${challenge._id}/join`);\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          created: false,\n          updated: true\n        }\n      });\n      const task = await user.post(`/tasks/challenge/${challenge._id}`, {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await user.put(`/tasks/${task.id}`, {\n        text: 'updated text'\n      });\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(body).to.not.exist;\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can update reminders (replace them)","suites":["PUT /tasks/:id","all types"],"updatePoint":{"line":214,"column":43,"index":7908},"line":214,"code":"    it('can update reminders (replace them)', async () => {\n      await user.put(`/tasks/${daily._id}`, {\n        reminders: [{\n          time: new Date(),\n          startDate: new Date()\n        }]\n      });\n      const id1 = generateUUID();\n      const id2 = generateUUID();\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        reminders: [{\n          id: id1,\n          time: new Date(),\n          startDate: new Date()\n        }, {\n          id: id2,\n          time: new Date(),\n          startDate: new Date()\n        }]\n      });\n      expect(savedDaily.reminders.length).to.equal(2);\n      expect(savedDaily.reminders[0].id).to.equal(id1);\n      expect(savedDaily.reminders[1].id).to.equal(id2);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can set a alias if no other task has that alias","suites":["PUT /tasks/:id","all types"],"updatePoint":{"line":238,"column":55,"index":8651},"line":238,"code":"    it('can set a alias if no other task has that alias', async () => {\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        alias: 'alias'\n      });\n      expect(savedDaily.alias).to.eql('alias');\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"does not set alias to a alias that is already in use","suites":["PUT /tasks/:id","all types"],"updatePoint":{"line":244,"column":60,"index":8882},"line":244,"code":"    it('does not set alias to a alias that is already in use', async () => {\n      await user.post('/tasks/user', {\n        type: 'todo',\n        text: 'a todo',\n        alias: 'some-alias'\n      });\n      await expect(user.put(`/tasks/${daily._id}`, {\n        alias: 'some-alias'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'daily validation failed'\n      });\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can use alias to update a task","suites":["PUT /tasks/:id","all types"],"updatePoint":{"line":258,"column":38,"index":9296},"line":258,"code":"    it('can use alias to update a task', async () => {\n      daily = await user.put(`/tasks/${daily._id}`, {\n        alias: 'alias'\n      });\n      await user.put(`/tasks/${daily.alias}`, {\n        text: 'saved'\n      });\n      const fetchedDaily = await user.get(`/tasks/${daily._id}`);\n      expect(fetchedDaily.text).to.eql('saved');\n    }); // This is a special case for iOS requests","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"will round a priority (difficulty)","suites":["PUT /tasks/:id","all types"],"updatePoint":{"line":269,"column":42,"index":9689},"line":269,"code":"    it('will round a priority (difficulty)', async () => {\n      daily = await user.put(`/tasks/${daily._id}`, {\n        alias: 'alias',\n        priority: 0.10000000000005\n      });\n      expect(daily.priority).to.eql(0.1);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"updates a habit","suites":["PUT /tasks/:id","habits"],"updatePoint":{"line":286,"column":23,"index":10116},"line":286,"code":"    it('updates a habit', async () => {\n      const savedHabit = await user.put(`/tasks/${habit._id}`, {\n        text: 'some new text',\n        up: false,\n        down: false,\n        notes: 'some new notes'\n      });\n      expect(savedHabit.text).to.eql('some new text');\n      expect(savedHabit.notes).to.eql('some new notes');\n      expect(savedHabit.up).to.eql(false);\n      expect(savedHabit.down).to.eql(false);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"updates a todo","suites":["PUT /tasks/:id","todos"],"updatePoint":{"line":308,"column":22,"index":10750},"line":308,"code":"    it('updates a todo', async () => {\n      const savedTodo = await user.put(`/tasks/${todo._id}`, {\n        text: 'some new text',\n        notes: 'some new notes'\n      });\n      expect(savedTodo.text).to.eql('some new text');\n      expect(savedTodo.notes).to.eql('some new notes');\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can update checklists (replace it)","suites":["PUT /tasks/:id","todos"],"updatePoint":{"line":316,"column":42,"index":11063},"line":316,"code":"    it('can update checklists (replace it)', async () => {\n      await user.put(`/tasks/${todo._id}`, {\n        checklist: [{\n          text: 123,\n          completed: false\n        }, {\n          text: 456,\n          completed: true\n        }]\n      });\n      const savedTodo = await user.put(`/tasks/${todo._id}`, {\n        checklist: [{\n          text: 789,\n          completed: false\n        }]\n      });\n      expect(savedTodo.checklist.length).to.equal(1);\n      expect(savedTodo.checklist[0].text).to.equal('789');\n      expect(savedTodo.checklist[0].completed).to.equal(false);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can update tags (replace them)","suites":["PUT /tasks/:id","todos"],"updatePoint":{"line":336,"column":38,"index":11653},"line":336,"code":"    it('can update tags (replace them)', async () => {\n      const finalUUID = generateUUID();\n      await user.put(`/tasks/${todo._id}`, {\n        tags: [generateUUID(), generateUUID()]\n      });\n      const savedTodo = await user.put(`/tasks/${todo._id}`, {\n        tags: [finalUUID]\n      });\n      expect(savedTodo.tags.length).to.equal(1);\n      expect(savedTodo.tags[0]).to.equal(finalUUID);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"updates a daily","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":357,"column":23,"index":12258},"line":357,"code":"    it('updates a daily', async () => {\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        text: 'some new text',\n        notes: 'some new notes',\n        frequency: 'daily',\n        everyX: 5,\n        yesterDaily: false,\n        startDate: moment().add(1, 'days').toDate()\n      });\n      expect(savedDaily.text).to.eql('some new text');\n      expect(savedDaily.notes).to.eql('some new notes');\n      expect(savedDaily.frequency).to.eql('daily');\n      expect(savedDaily.everyX).to.eql(5);\n      expect(savedDaily.isDue).to.be.false;\n      expect(savedDaily.nextDue.length).to.eql(6);\n      expect(savedDaily.yesterDaily).to.be.false;\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can update checklists (replace it)","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":374,"column":42,"index":12943},"line":374,"code":"    it('can update checklists (replace it)', async () => {\n      await user.put(`/tasks/${daily._id}`, {\n        checklist: [{\n          text: 123,\n          completed: false\n        }, {\n          text: 456,\n          completed: true\n        }]\n      });\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        checklist: [{\n          text: 789,\n          completed: false\n        }]\n      });\n      expect(savedDaily.checklist.length).to.equal(1);\n      expect(savedDaily.checklist[0].text).to.equal('789');\n      expect(savedDaily.checklist[0].completed).to.equal(false);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"can update tags (replace them)","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":394,"column":38,"index":13539},"line":394,"code":"    it('can update tags (replace them)', async () => {\n      const finalUUID = generateUUID();\n      await user.put(`/tasks/${daily._id}`, {\n        tags: [generateUUID(), generateUUID()]\n      });\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        tags: [finalUUID]\n      });\n      expect(savedDaily.tags.length).to.equal(1);\n      expect(savedDaily.tags[0]).to.equal(finalUUID);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"updates repeat, even if frequency is set to daily","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":405,"column":57,"index":13969},"line":405,"code":"    it('updates repeat, even if frequency is set to daily', async () => {\n      await user.put(`/tasks/${daily._id}`, {\n        frequency: 'daily'\n      });\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        repeat: {\n          m: false,\n          su: false\n        }\n      });\n      expect(savedDaily.repeat).to.eql({\n        m: false,\n        t: true,\n        w: true,\n        th: true,\n        f: true,\n        s: true,\n        su: false\n      });\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"updates everyX, even if frequency is set to weekly","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":425,"column":58,"index":14451},"line":425,"code":"    it('updates everyX, even if frequency is set to weekly', async () => {\n      await user.put(`/tasks/${daily._id}`, {\n        frequency: 'weekly'\n      });\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        everyX: 5\n      });\n      expect(savedDaily.everyX).to.eql(5);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"defaults startDate to today if none date object is passed in","suites":["PUT /tasks/:id","dailys"],"updatePoint":{"line":434,"column":68,"index":14764},"line":434,"code":"    it('defaults startDate to today if none date object is passed in', async () => {\n      const savedDaily = await user.put(`/tasks/${daily._id}`, {\n        frequency: 'weekly'\n      });\n      expect(new Date(savedDaily.startDate).getDay()).to.eql(new Date().getDay());\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"updates days of month when start date updated","suites":["PUT /tasks/:id","monthly dailys"],"updatePoint":{"line":454,"column":53,"index":15459},"line":454,"code":"    it('updates days of month when start date updated', async () => {\n      const date2 = moment().add(6, 'months').toDate();\n      const savedMonthly = await user.put(`/tasks/${monthly._id}`, {\n        startDate: date2\n      });\n      expect(savedMonthly.daysOfMonth).to.deep.equal([moment(date2).date()]);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"updates next due when start date updated","suites":["PUT /tasks/:id","monthly dailys"],"updatePoint":{"line":461,"column":48,"index":15770},"line":461,"code":"    it('updates next due when start date updated', async () => {\n      const date2 = moment().add(6, 'months').toDate();\n      const savedMonthly = await user.put(`/tasks/${monthly._id}`, {\n        startDate: date2\n      });\n      expect(savedMonthly.nextDue.length).to.eql(6);\n      expect(moment(savedMonthly.nextDue[0]).isSame(moment(date2).add(1, 'months').startOf('day')));\n      expect(moment(savedMonthly.nextDue[1]).isSame(moment(date2).add(2, 'months').startOf('day')));\n      expect(moment(savedMonthly.nextDue[2]).isSame(moment(date2).add(3, 'months').startOf('day')));\n      expect(moment(savedMonthly.nextDue[3]).isSame(moment(date2).add(4, 'months').startOf('day')));\n      expect(moment(savedMonthly.nextDue[4]).isSame(moment(date2).add(5, 'months').startOf('day')));\n      expect(moment(savedMonthly.nextDue[5]).isSame(moment(date2).add(6, 'months').startOf('day')));\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"updates a reward","suites":["PUT /tasks/:id","rewards"],"updatePoint":{"line":485,"column":24,"index":16876},"line":485,"code":"    it('updates a reward', async () => {\n      const savedReward = await user.put(`/tasks/${reward._id}`, {\n        text: 'some new text',\n        notes: 'some new notes',\n        value: 10\n      });\n      expect(savedReward.text).to.eql('some new text');\n      expect(savedReward.notes).to.eql('some new notes');\n      expect(savedReward.value).to.eql(10);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"requires value to be coerced into a number","suites":["PUT /tasks/:id","rewards"],"updatePoint":{"line":495,"column":50,"index":17268},"line":495,"code":"    it('requires value to be coerced into a number', async () => {\n      const savedReward = await user.put(`/tasks/${reward._id}`, {\n        value: '100'\n      });\n      expect(savedReward.value).to.eql(100);\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"returns an error if reward value is a negative number","suites":["PUT /tasks/:id","rewards"],"updatePoint":{"line":501,"column":61,"index":17497},"line":501,"code":"    it('returns an error if reward value is a negative number', async () => {\n      await expect(user.put(`/tasks/${reward._id}`, {\n        value: -10\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'reward validation failed'\n      });\n    });","file":"api/v3/integration/tasks/PUT-tasks_id.test.js","skipped":false,"dir":"test"},{"name":"removes a tag from a task","suites":["DELETE /tasks/:taskId/tags/:tagId"],"updatePoint":{"line":8,"column":31,"index":293},"line":8,"code":"  it('removes a tag from a task', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    const tag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    await user.post(`/tasks/${task._id}/tags/${tag.id}`);\n    await user.del(`/tasks/${task._id}/tags/${tag.id}`);\n    const updatedTask = await user.get(`/tasks/${task._id}`);\n    expect(updatedTask.tags.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/tags/DELETE-tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"removes a tag from a task using task short name","suites":["DELETE /tasks/:taskId/tags/:tagId"],"updatePoint":{"line":21,"column":53,"index":773},"line":21,"code":"  it('removes a tag from a task using task short name', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'Task with tag',\n      alias: 'habit-with-alias'\n    });\n    const tag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    await user.post(`/tasks/${task._id}/tags/${tag.id}`);\n    await user.del(`/tasks/${task.alias}/tags/${tag.id}`);\n    const updatedTask = await user.get(`/tasks/${task._id}`);\n    expect(updatedTask.tags.length).to.equal(0);\n  });","file":"api/v3/integration/tasks/tags/DELETE-tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"only deletes existing tags","suites":["DELETE /tasks/:taskId/tags/:tagId"],"updatePoint":{"line":35,"column":32,"index":1267},"line":35,"code":"  it('only deletes existing tags', async () => {\n    const createdTask = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    await expect(user.del(`/tasks/${createdTask._id}/tags/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('tagNotFound')\n    });\n  });","file":"api/v3/integration/tasks/tags/DELETE-tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"adds a tag to a task","suites":["POST /tasks/:taskId/tags/:tagId"],"updatePoint":{"line":8,"column":26,"index":286},"line":8,"code":"  it('adds a tag to a task', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    const tag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    const savedTask = await user.post(`/tasks/${task._id}/tags/${tag.id}`);\n    expect(savedTask.tags[0]).to.equal(tag.id);\n  });","file":"api/v3/integration/tasks/tags/POST-tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"adds a tag to a task with alias","suites":["POST /tasks/:taskId/tags/:tagId"],"updatePoint":{"line":19,"column":37,"index":648},"line":19,"code":"  it('adds a tag to a task with alias', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'Task with tag',\n      alias: 'habit-with-alias'\n    });\n    const tag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    const savedTask = await user.post(`/tasks/${task.alias}/tags/${tag.id}`);\n    expect(savedTask.tags[0]).to.equal(tag.id);\n  });","file":"api/v3/integration/tasks/tags/POST-tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"does not add a tag to a task twice","suites":["POST /tasks/:taskId/tags/:tagId"],"updatePoint":{"line":31,"column":40,"index":1048},"line":31,"code":"  it('does not add a tag to a task twice', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    const tag = await user.post('/tags', {\n      name: 'Tag 1'\n    });\n    await user.post(`/tasks/${task._id}/tags/${tag.id}`);\n    await expect(user.post(`/tasks/${task._id}/tags/${tag.id}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('alreadyTagged')\n    });\n  });","file":"api/v3/integration/tasks/tags/POST-tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"does not add a non existing tag to a task","suites":["POST /tasks/:taskId/tags/:tagId"],"updatePoint":{"line":46,"column":47,"index":1541},"line":46,"code":"  it('does not add a non existing tag to a task', async () => {\n    const task = await user.post('/tasks/user', {\n      type: 'habit',\n      text: 'Task with tag'\n    });\n    await expect(user.post(`/tasks/${task._id}/tags/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/tasks/tags/POST-tasks_taskId_tags_tagId.test.js","skipped":false,"dir":"test"},{"name":"is not supported","suites":["DELETE social registration","NOT-SUPPORTED"],"updatePoint":{"line":8,"column":24,"index":275},"line":8,"code":"    it('is not supported', async () => {\n      await expect(user.del('/user/auth/social/SOME-OTHER-NETWORK')).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('unsupportedNetwork')\n      });\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"fails if user does not have an alternative registration method","suites":["DELETE social registration","Facebook"],"updatePoint":{"line":17,"column":70,"index":610},"line":17,"code":"    it('fails if user does not have an alternative registration method', async () => {\n      await user.update({\n        'auth.facebook.id': 'some-fb-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await expect(user.del('/user/auth/social/facebook')).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('cantDetachSocial')\n      });\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"succeeds if user has a local registration","suites":["DELETE social registration","Facebook"],"updatePoint":{"line":30,"column":49,"index":1010},"line":30,"code":"    it('succeeds if user has a local registration', async () => {\n      await user.update({\n        'auth.facebook.id': 'some-fb-id'\n      });\n      const response = await user.del('/user/auth/social/facebook');\n      expect(response).to.eql({});\n      await user.sync();\n      expect(user.auth.facebook).to.be.undefined;\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"succeeds if user has a google registration","suites":["DELETE social registration","Facebook"],"updatePoint":{"line":39,"column":50,"index":1341},"line":39,"code":"    it('succeeds if user has a google registration', async () => {\n      await user.update({\n        'auth.facebook.id': 'some-fb-id',\n        'auth.google.id': 'some-google-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      const response = await user.del('/user/auth/social/facebook');\n      expect(response).to.eql({});\n      await user.sync();\n      expect(user.auth.facebook).to.be.undefined;\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"fails if user does not have an alternative registration method","suites":["DELETE social registration","Google"],"updatePoint":{"line":54,"column":70,"index":1824},"line":54,"code":"    it('fails if user does not have an alternative registration method', async () => {\n      await user.update({\n        'auth.google.id': 'some-google-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await expect(user.del('/user/auth/social/google')).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('cantDetachSocial')\n      });\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"succeeds if user has a local registration","suites":["DELETE social registration","Google"],"updatePoint":{"line":67,"column":49,"index":2224},"line":67,"code":"    it('succeeds if user has a local registration', async () => {\n      await user.update({\n        'auth.google.id': 'some-google-id'\n      });\n      const response = await user.del('/user/auth/social/google');\n      expect(response).to.eql({});\n      await user.sync();\n      expect(user.auth.google).to.be.undefined;\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"succeeds if user has a facebook registration","suites":["DELETE social registration","Google"],"updatePoint":{"line":76,"column":52,"index":2555},"line":76,"code":"    it('succeeds if user has a facebook registration', async () => {\n      await user.update({\n        'auth.google.id': 'some-google-id',\n        'auth.facebook.id': 'some-facebook-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      const response = await user.del('/user/auth/social/google');\n      expect(response).to.eql({});\n      await user.sync();\n      expect(user.auth.goodl).to.be.undefined;\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"fails if user does not have an alternative registration method","suites":["DELETE social registration","Apple"],"updatePoint":{"line":91,"column":70,"index":3038},"line":91,"code":"    it('fails if user does not have an alternative registration method', async () => {\n      await user.update({\n        'auth.apple.id': 'some-apple-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await expect(user.del('/user/auth/social/apple')).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('cantDetachSocial')\n      });\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"succeeds if user has a local registration","suites":["DELETE social registration","Apple"],"updatePoint":{"line":104,"column":49,"index":3435},"line":104,"code":"    it('succeeds if user has a local registration', async () => {\n      await user.update({\n        'auth.apple.id': 'some-apple-id'\n      });\n      const response = await user.del('/user/auth/social/apple');\n      expect(response).to.eql({});\n      await user.sync();\n      expect(user.auth.apple).to.be.undefined;\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"succeeds if user has a facebook registration","suites":["DELETE social registration","Apple"],"updatePoint":{"line":113,"column":52,"index":3762},"line":113,"code":"    it('succeeds if user has a facebook registration', async () => {\n      await user.update({\n        'auth.apple.id': 'some-apple-id',\n        'auth.facebook.id': 'some-facebook-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      const response = await user.del('/user/auth/social/apple');\n      expect(response).to.eql({});\n      await user.sync();\n      expect(user.auth.goodl).to.be.undefined;\n    });","file":"api/v3/integration/user/auth/DELETE-user_auth_social_network.test.js","skipped":false,"dir":"test"},{"name":"registers a new user","suites":["GET /user/auth/apple"],"updatePoint":{"line":18,"column":26,"index":601},"line":18,"code":"  it('registers a new user', async () => {\n    const response = await api.get(appleEndpoint);\n    expect(response.apiToken).to.exist;\n    expect(response.id).to.exist;\n    expect(response.newUser).to.be.true;\n    await expect(getProperty('users', response.id, 'auth.apple.id')).to.eventually.equal('appleId');\n    await expect(getProperty('users', response.id, 'profile.name')).to.eventually.equal('an apple user');\n  });","file":"api/v3/integration/user/auth/GET-user_auth_apple.test.js","skipped":false,"dir":"test"},{"name":"logs an existing user in","suites":["GET /user/auth/apple"],"updatePoint":{"line":26,"column":30,"index":1027},"line":26,"code":"  it('logs an existing user in', async () => {\n    const registerResponse = await api.get(appleEndpoint);\n    const response = await api.get(appleEndpoint);\n    expect(response.apiToken).to.eql(registerResponse.apiToken);\n    expect(response.id).to.eql(registerResponse.id);\n    expect(response.newUser).to.be.false;\n  });","file":"api/v3/integration/user/auth/GET-user_auth_apple.test.js","skipped":false,"dir":"test"},{"name":"add social auth to an existing user","suites":["GET /user/auth/apple"],"updatePoint":{"line":33,"column":41,"index":1361},"line":33,"code":"  it('add social auth to an existing user', async () => {\n    const response = await user.get(appleEndpoint);\n    expect(response.apiToken).to.exist;\n    expect(response.id).to.exist;\n    expect(response.newUser).to.be.false;\n  });","file":"api/v3/integration/user/auth/GET-user_auth_apple.test.js","skipped":false,"dir":"test"},{"name":"success with username","suites":["POST /user/auth/local/login"],"updatePoint":{"line":13,"column":27,"index":522},"line":13,"code":"  it('success with username', async () => {\n    const response = await api.post(endpoint, {\n      username: user.auth.local.username,\n      password\n    });\n    expect(response.apiToken).to.eql(user.apiToken);\n  });","file":"api/v3/integration/user/auth/POST-login-local.test.js","skipped":false,"dir":"test"},{"name":"success with email","suites":["POST /user/auth/local/login"],"updatePoint":{"line":20,"column":24,"index":735},"line":20,"code":"  it('success with email', async () => {\n    const response = await api.post(endpoint, {\n      username: user.auth.local.email,\n      password\n    });\n    expect(response.apiToken).to.eql(user.apiToken);\n  });","file":"api/v3/integration/user/auth/POST-login-local.test.js","skipped":false,"dir":"test"},{"name":"user is blocked","suites":["POST /user/auth/local/login"],"updatePoint":{"line":27,"column":21,"index":942},"line":27,"code":"  it('user is blocked', async () => {\n    await user.update({\n      'auth.blocked': 1\n    });\n    await expect(api.post(endpoint, {\n      username: user.auth.local.username,\n      password\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('accountSuspended', {\n        communityManagerEmail: nconf.get('EMAILS_COMMUNITY_MANAGER_EMAIL'),\n        userId: user._id\n      })\n    });\n  });","file":"api/v3/integration/user/auth/POST-login-local.test.js","skipped":false,"dir":"test"},{"name":"wrong password","suites":["POST /user/auth/local/login"],"updatePoint":{"line":43,"column":20,"index":1384},"line":43,"code":"  it('wrong password', async () => {\n    await expect(api.post(endpoint, {\n      username: user.auth.local.username,\n      password: 'wrong-password'\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('invalidLoginCredentialsLong')\n    });\n  });","file":"api/v3/integration/user/auth/POST-login-local.test.js","skipped":false,"dir":"test"},{"name":"missing username","suites":["POST /user/auth/local/login"],"updatePoint":{"line":53,"column":22,"index":1689},"line":53,"code":"  it('missing username', async () => {\n    await expect(api.post(endpoint, {\n      password: 'wrong-password'\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/user/auth/POST-login-local.test.js","skipped":false,"dir":"test"},{"name":"missing password","suites":["POST /user/auth/local/login"],"updatePoint":{"line":62,"column":22,"index":1938},"line":62,"code":"  it('missing password', async () => {\n    await expect(api.post(endpoint, {\n      username: user.auth.local.username\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/user/auth/POST-login-local.test.js","skipped":false,"dir":"test"},{"name":"converts user with SHA1 encrypted password to bcrypt encryption","suites":["POST /user/auth/local/login"],"updatePoint":{"line":71,"column":69,"index":2242},"line":71,"code":"  it('converts user with SHA1 encrypted password to bcrypt encryption', async () => {\n    const textPassword = 'mySecretPassword';\n    const salt = sha1MakeSalt();\n    const sha1HashedPassword = sha1EncryptPassword(textPassword, salt);\n    await user.update({\n      'auth.local.hashed_password': sha1HashedPassword,\n      'auth.local.passwordHashMethod': 'sha1',\n      'auth.local.salt': salt\n    });\n    await user.sync();\n    expect(user.auth.local.passwordHashMethod).to.equal('sha1');\n    expect(user.auth.local.salt).to.equal(salt);\n    expect(user.auth.local.hashed_password).to.equal(sha1HashedPassword); // login\n\n    await api.post(endpoint, {\n      username: user.auth.local.email,\n      password: textPassword\n    });\n    await user.sync();\n    expect(user.auth.local.passwordHashMethod).to.equal('bcrypt');\n    expect(user.auth.local.salt).to.be.undefined;\n    expect(user.auth.local.hashed_password).not.to.equal(sha1HashedPassword);\n    const isValidPassword = await bcryptCompare(textPassword, user.auth.local.hashed_password);\n    expect(isValidPassword).to.equal(true);\n  });","file":"api/v3/integration/user/auth/POST-login-local.test.js","skipped":false,"dir":"test"},{"name":"user uses social authentication and has no password","suites":["POST /user/auth/local/login"],"updatePoint":{"line":96,"column":57,"index":3323},"line":96,"code":"  it('user uses social authentication and has no password', async () => {\n    await user.unset({\n      'auth.local.hashed_password': 1\n    });\n    await user.sync();\n    expect(user.auth.local.hashed_password).to.be.undefined;\n    await expect(api.post(endpoint, {\n      username: user.auth.local.username,\n      password: 'any-password'\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('invalidLoginCredentialsLong')\n    });\n  });","file":"api/v3/integration/user/auth/POST-login-local.test.js","skipped":false,"dir":"test"},{"name":"registers a new user","suites":["POST /user/auth/local/register","username and email are free"],"updatePoint":{"line":17,"column":28,"index":651},"line":17,"code":"    it('registers a new user', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user._id).to.exist;\n      expect(user.apiToken).to.exist;\n      expect(user.auth.local.username).to.eql(username);\n      expect(user.profile.name).to.eql(username);\n      expect(user.newUser).to.eql(true);\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"registers a new user and sets verifiedUsername to true","suites":["POST /user/auth/local/register","username and email are free"],"updatePoint":{"line":33,"column":62,"index":1248},"line":33,"code":"    it('registers a new user and sets verifiedUsername to true', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user._id).to.exist;\n      expect(user.apiToken).to.exist;\n      expect(user.flags.verifiedUsername).to.eql(true);\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"remove spaces from username","suites":["POST /user/auth/local/register","username and email are free"],"updatePoint":{"line":47,"column":36,"index":1727},"line":47,"code":"    xit('remove spaces from username', async () => {\n      // TODO can probably delete this test now\n      const username = ' usernamewithspaces ';\n      const email = 'test@example.com';\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.auth.local.username).to.eql(username.trim());\n      expect(user.profile.name).to.eql(username.trim());\n    });","skipped":true,"file":"api/v3/integration/user/auth/POST-register_local.test.js","dir":"test"},{"name":"requires to username to be less than 20","suites":["POST /user/auth/local/register","username and email are free","validates username"],"updatePoint":{"line":64,"column":49,"index":2369},"line":64,"code":"      it('requires to username to be less than 20', async () => {\n        const username = (Date.now() + uuid()).substring(0, 21);\n        await expect(api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        })).to.eventually.be.rejected.and.eql({\n          code: 400,\n          error: 'BadRequest',\n          message: 'Invalid request parameters.'\n        });\n      });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"rejects chracters not in [-_a-zA-Z0-9]","suites":["POST /user/auth/local/register","username and email are free","validates username"],"updatePoint":{"line":77,"column":48,"index":2824},"line":77,"code":"      it('rejects chracters not in [-_a-zA-Z0-9]', async () => {\n        const username = 'a-zA_Z09*';\n        await expect(api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        })).to.eventually.be.rejected.and.eql({\n          code: 400,\n          error: 'BadRequest',\n          message: 'Invalid request parameters.'\n        });\n      });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"allows only [-_a-zA-Z0-9] characters","suites":["POST /user/auth/local/register","username and email are free","validates username"],"updatePoint":{"line":90,"column":46,"index":3250},"line":90,"code":"      it('allows only [-_a-zA-Z0-9] characters', async () => {\n        const username = 'a-zA_Z09';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        expect(user.auth.local.username).to.eql(username);\n      });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"for a generic API consumer","suites":["POST /user/auth/local/register","username and email are free","provides default tags and tasks"],"updatePoint":{"line":102,"column":36,"index":3650},"line":102,"code":"      it('for a generic API consumer', async () => {\n        const username = generateRandomUserName();\n        const email = `${username}@example.com`;\n        const password = 'password';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        const requests = new ApiUser(user);\n        const habits = await requests.get('/tasks/user?type=habits');\n        const dailys = await requests.get('/tasks/user?type=dailys');\n        const todos = await requests.get('/tasks/user?type=todos');\n        const rewards = await requests.get('/tasks/user?type=rewards');\n        const tags = await requests.get('/tags');\n        expect(habits).to.have.a.lengthOf(0);\n        expect(dailys).to.have.a.lengthOf(0);\n        expect(todos).to.have.a.lengthOf(1);\n        expect(rewards).to.have.a.lengthOf(0);\n        expect(tags).to.have.a.lengthOf(7);\n        expect(tags[0].name).to.eql(t('defaultTag1'));\n        expect(tags[1].name).to.eql(t('defaultTag2'));\n        expect(tags[2].name).to.eql(t('defaultTag3'));\n        expect(tags[3].name).to.eql(t('defaultTag4'));\n        expect(tags[4].name).to.eql(t('defaultTag5'));\n        expect(tags[5].name).to.eql(t('defaultTag6'));\n        expect(tags[6].name).to.eql(t('defaultTag7'));\n      });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"for Web","suites":["POST /user/auth/local/register","username and email are free","provides default tags and tasks"],"updatePoint":{"line":131,"column":18,"index":4991},"line":131,"code":"      xit('for Web', async () => {\n        api = requester(null, {\n          'x-client': 'habitica-web'\n        });\n        const username = generateRandomUserName();\n        const email = `${username}@example.com`;\n        const password = 'password';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        const requests = new ApiUser(user);\n        const habits = await requests.get('/tasks/user?type=habits');\n        const dailys = await requests.get('/tasks/user?type=dailys');\n        const todos = await requests.get('/tasks/user?type=todos');\n        const rewards = await requests.get('/tasks/user?type=rewards');\n        const tags = await requests.get('/tags');\n        expect(habits).to.have.a.lengthOf(3);\n        expect(habits[0].text).to.eql(t('defaultHabit1Text'));\n        expect(habits[0].notes).to.eql('');\n        expect(habits[1].text).to.eql(t('defaultHabit2Text'));\n        expect(habits[1].notes).to.eql('');\n        expect(habits[2].text).to.eql(t('defaultHabit3Text'));\n        expect(habits[2].notes).to.eql('');\n        expect(dailys).to.have.a.lengthOf(0);\n        expect(todos).to.have.a.lengthOf(1);\n        expect(todos[0].text).to.eql(t('defaultTodo1Text'));\n        expect(todos[0].notes).to.eql(t('defaultTodoNotes'));\n        expect(rewards).to.have.a.lengthOf(1);\n        expect(rewards[0].text).to.eql(t('defaultReward1Text'));\n        expect(rewards[0].notes).to.eql('');\n        expect(tags).to.have.a.lengthOf(7);\n        expect(tags[0].name).to.eql(t('defaultTag1'));\n        expect(tags[1].name).to.eql(t('defaultTag2'));\n        expect(tags[2].name).to.eql(t('defaultTag3'));\n        expect(tags[3].name).to.eql(t('defaultTag4'));\n        expect(tags[4].name).to.eql(t('defaultTag5'));\n        expect(tags[5].name).to.eql(t('defaultTag6'));\n        expect(tags[6].name).to.eql(t('defaultTag7'));\n      });","skipped":true,"file":"api/v3/integration/user/auth/POST-register_local.test.js","dir":"test"},{"name":"for Android","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":175,"column":21,"index":7047},"line":175,"code":"      it('for Android', async () => {\n        api = requester(null, {\n          'x-client': 'habitica-android'\n        });\n        const username = generateRandomUserName();\n        const email = `${username}@example.com`;\n        const password = 'password';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        const requests = new ApiUser(user);\n        const habits = await requests.get('/tasks/user?type=habits');\n        const dailys = await requests.get('/tasks/user?type=dailys');\n        const todos = await requests.get('/tasks/user?type=todos');\n        const rewards = await requests.get('/tasks/user?type=rewards');\n        const tags = await requests.get('/tags');\n        expect(habits).to.have.a.lengthOf(0);\n        expect(dailys).to.have.a.lengthOf(0);\n        expect(todos).to.have.a.lengthOf(0);\n        expect(rewards).to.have.a.lengthOf(0);\n        expect(tags).to.have.a.lengthOf(0);\n      });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"for iOS","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":200,"column":17,"index":8087},"line":200,"code":"      it('for iOS', async () => {\n        api = requester(null, {\n          'x-client': 'habitica-ios'\n        });\n        const username = generateRandomUserName();\n        const email = `${username}@example.com`;\n        const password = 'password';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        const requests = new ApiUser(user);\n        const habits = await requests.get('/tasks/user?type=habits');\n        const dailys = await requests.get('/tasks/user?type=dailys');\n        const todos = await requests.get('/tasks/user?type=todos');\n        const rewards = await requests.get('/tasks/user?type=rewards');\n        const tags = await requests.get('/tags');\n        expect(habits).to.have.a.lengthOf(0);\n        expect(dailys).to.have.a.lengthOf(0);\n        expect(todos).to.have.a.lengthOf(0);\n        expect(rewards).to.have.a.lengthOf(0);\n        expect(tags).to.have.a.lengthOf(0);\n      });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"enrolls new users in an A/B test","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":226,"column":41,"index":9155},"line":226,"code":"    xit('enrolls new users in an A/B test', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await expect(getProperty('users', user._id, '_ABtests')).to.eventually.be.a('object');\n    });","skipped":true,"file":"api/v3/integration/user/auth/POST-register_local.test.js","dir":"test"},{"name":"includes items awarded by default when creating a new user","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":238,"column":66,"index":9630},"line":238,"code":"    it('includes items awarded by default when creating a new user', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.items.quests.dustbunnies).to.equal(1);\n      expect(user.purchased.background.violet).to.be.ok;\n      expect(user.preferences.background).to.equal('violet');\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires password and confirmPassword to match","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":252,"column":54,"index":10176},"line":252,"code":"    it('requires password and confirmPassword to match', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const confirmPassword = 'not password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires minimum length for the password","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":268,"column":48,"index":10703},"line":268,"code":"    it('requires minimum length for the password', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = '1234567';\n      const confirmPassword = '1234567';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires a username","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":284,"column":27,"index":11203},"line":284,"code":"    it('requires a username', async () => {\n      const email = `${generateRandomUserName()}@example.com`;\n      const password = 'password';\n      const confirmPassword = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        email,\n        password,\n        confirmPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires an email","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":298,"column":25,"index":11652},"line":298,"code":"    it('requires an email', async () => {\n      const username = generateRandomUserName();\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires a valid email","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":311,"column":30,"index":12063},"line":311,"code":"    it('requires a valid email', async () => {\n      const username = generateRandomUserName();\n      const email = 'notanemail@sdf';\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"sanitizes email params to a lowercase string before creating the user","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":326,"column":77,"index":12574},"line":326,"code":"    it('sanitizes email params to a lowercase string before creating the user', async () => {\n      const username = generateRandomUserName();\n      const email = 'ISANEmAiL@ExAmPle.coM';\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.auth.local.email).to.equal(email.toLowerCase());\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"fails on a habitica.com email","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":338,"column":37,"index":12992},"line":338,"code":"    it('fails on a habitica.com email', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@habitica.com`;\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"fails on a habitrpg.com email","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":353,"column":37,"index":13476},"line":353,"code":"    it('fails on a habitrpg.com email', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@habitrpg.com`;\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires a password","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":368,"column":27,"index":13950},"line":368,"code":"    it('requires a password', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const confirmPassword = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        confirmPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"checks onlySocialAttachLocal","suites":["POST /user/auth/local/register","attach to facebook user"],"updatePoint":{"line":391,"column":36,"index":14657},"line":391,"code":"    it('checks onlySocialAttachLocal', async () => {\n      await expect(user.post('/user/auth/local/register', {\n        email,\n        username,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlySocialAttachLocal')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"succeeds","suites":["POST /user/auth/local/register","attach to facebook user"],"updatePoint":{"line":403,"column":16,"index":14994},"line":403,"code":"    it('succeeds', async () => {\n      await user.update({\n        'auth.facebook.id': 'some-fb-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await user.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await user.sync();\n      expect(user.auth.local.username).to.eql(username);\n      expect(user.auth.local.email).to.eql(email);\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"checks onlySocialAttachLocal","suites":["POST /user/auth/local/register","attach to google user"],"updatePoint":{"line":429,"column":36,"index":15728},"line":429,"code":"    it('checks onlySocialAttachLocal', async () => {\n      await expect(user.post('/user/auth/local/register', {\n        email,\n        username,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlySocialAttachLocal')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"succeeds","suites":["POST /user/auth/local/register","attach to google user"],"updatePoint":{"line":441,"column":16,"index":16065},"line":441,"code":"    it('succeeds', async () => {\n      await user.update({\n        'auth.google.id': 'some-google-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await user.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await user.sync();\n      expect(user.auth.local.username).to.eql(username);\n      expect(user.auth.local.email).to.eql(email);\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"checks onlySocialAttachLocal","suites":["POST /user/auth/local/register","attach to apple user"],"updatePoint":{"line":467,"column":36,"index":16798},"line":467,"code":"    it('checks onlySocialAttachLocal', async () => {\n      await expect(user.post('/user/auth/local/register', {\n        email,\n        username,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlySocialAttachLocal')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"succeeds","suites":["POST /user/auth/local/register","attach to apple user"],"updatePoint":{"line":479,"column":16,"index":17135},"line":479,"code":"    it('succeeds', async () => {\n      await user.update({\n        'auth.apple.id': 'some-apple-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await user.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await user.sync();\n      expect(user.auth.local.username).to.eql(username);\n      expect(user.auth.local.email).to.eql(email);\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"rejects if username is already taken","suites":["POST /user/auth/local/register","login is already taken"],"updatePoint":{"line":511,"column":44,"index":18021},"line":511,"code":"    it('rejects if username is already taken', async () => {\n      const uniqueEmail = `${generateRandomUserName()}@exampe.com`;\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email: uniqueEmail,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('usernameTaken')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"rejects if email is already taken","suites":["POST /user/auth/local/register","login is already taken"],"updatePoint":{"line":525,"column":41,"index":18490},"line":525,"code":"    it('rejects if email is already taken', async () => {\n      const uniqueUsername = generateRandomUserName();\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username: uniqueUsername,\n        email,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('emailTaken')\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"does not crash the signup process when it's invalid","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":551,"column":60,"index":19247},"line":551,"code":"    it('does not crash the signup process when it\\'s invalid', async () => {\n      const user = await api.post('/user/auth/local/register?groupInvite=aaaaInvalid', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user._id).to.be.a('string');\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"supports invite using req.query.groupInvite","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":560,"column":51,"index":19549},"line":560,"code":"    it('supports invite using req.query.groupInvite', async () => {\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        }\n      });\n      const invite = encrypt(JSON.stringify({\n        id: group._id,\n        inviter: groupLeader._id,\n        sentAt: Date.now() // so we can let it expire\n\n      }));\n      const user = await api.post(`/user/auth/local/register?groupInvite=${invite}`, {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.invitations.parties[0].id).to.eql(group._id);\n      expect(user.invitations.parties[0].name).to.eql(group.name);\n      expect(user.invitations.parties[0].inviter).to.eql(groupLeader._id);\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"awards achievement to inviter","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":586,"column":37,"index":20356},"line":586,"code":"    it('awards achievement to inviter', async () => {\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        }\n      });\n      const invite = encrypt(JSON.stringify({\n        id: group._id,\n        inviter: groupLeader._id,\n        sentAt: Date.now()\n      }));\n      await api.post(`/user/auth/local/register?groupInvite=${invite}`, {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await groupLeader.sync();\n      expect(groupLeader.achievements.invitedFriend).to.be.true;\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"user not added to a party on expired invite","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":610,"column":51,"index":21027},"line":610,"code":"    it('user not added to a party on expired invite', async () => {\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        }\n      });\n      const invite = encrypt(JSON.stringify({\n        id: group._id,\n        inviter: groupLeader._id,\n        sentAt: Date.now() - 6.912e8 // 8 days old\n\n      }));\n      const user = await api.post(`/user/auth/local/register?groupInvite=${invite}`, {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.invitations.party).to.eql({});\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"adds a user to a guild on an invite of type other than party","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":634,"column":68,"index":21705},"line":634,"code":"    it('adds a user to a guild on an invite of type other than party', async () => {\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'private'\n        }\n      });\n      const invite = encrypt(JSON.stringify({\n        id: group._id,\n        inviter: groupLeader._id,\n        sentAt: Date.now()\n      }));\n      const user = await api.post(`/user/auth/local/register?groupInvite=${invite}`, {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.invitations.guilds[0]).to.eql({\n        id: group._id,\n        name: group.name,\n        inviter: groupLeader._id\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"sets all site tour values to -2 (already seen)","suites":["POST /user/auth/local/register","successful login via api"],"updatePoint":{"line":673,"column":54,"index":22722},"line":673,"code":"    it('sets all site tour values to -2 (already seen)', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.flags.tour).to.not.be.empty;\n      each(user.flags.tour, value => {\n        expect(value).to.eql(-2);\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"populates user with default todos, not no other task types","suites":["POST /user/auth/local/register","successful login via api"],"updatePoint":{"line":685,"column":66,"index":23103},"line":685,"code":"    it('populates user with default todos, not no other task types', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.tasksOrder.todos).to.not.be.empty;\n      expect(user.tasksOrder.dailys).to.be.empty;\n      expect(user.tasksOrder.habits).to.be.empty;\n      expect(user.tasksOrder.rewards).to.be.empty;\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"populates user with default tags","suites":["POST /user/auth/local/register","successful login via api"],"updatePoint":{"line":697,"column":40,"index":23532},"line":697,"code":"    it('populates user with default tags', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.tags).to.not.be.empty;\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"sets all common tutorial flags to true","suites":["POST /user/auth/local/register","successful login with habitica-web header"],"updatePoint":{"line":720,"column":46,"index":24154},"line":720,"code":"    it('sets all common tutorial flags to true', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.flags.tour).to.not.be.empty;\n      each(user.flags.tutorial.common, value => {\n        expect(value).to.eql(true);\n      });\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"populates user with default todos, habits, and rewards","suites":["POST /user/auth/local/register","successful login with habitica-web header"],"updatePoint":{"line":732,"column":62,"index":24544},"line":732,"code":"    it('populates user with default todos, habits, and rewards', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.tasksOrder.todos).to.be.empty;\n      expect(user.tasksOrder.dailys).to.be.empty;\n      expect(user.tasksOrder.habits).to.be.empty;\n      expect(user.tasksOrder.rewards).to.be.empty;\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"populates user with default tags","suites":["POST /user/auth/local/register","successful login with habitica-web header"],"updatePoint":{"line":744,"column":40,"index":24969},"line":744,"code":"    it('populates user with default tags', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.tags).to.not.be.empty;\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"adds the correct tags to the correct tasks","suites":["POST /user/auth/local/register","successful login with habitica-web header"],"updatePoint":{"line":753,"column":50,"index":25245},"line":753,"code":"    it('adds the correct tags to the correct tasks', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      const requests = new ApiUser(user);\n      const habits = await requests.get('/tasks/user?type=habits');\n      const todos = await requests.get('/tasks/user?type=todos');\n      expect(habits).to.have.a.lengthOf(0);\n      expect(todos).to.have.a.lengthOf(0);\n    });","file":"api/v3/integration/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"fails if network is not supported","suites":["POST /user/auth/social"],"updatePoint":{"line":15,"column":39,"index":515},"line":15,"code":"  it('fails if network is not supported', async () => {\n    await expect(api.post(endpoint, {\n      authResponse: {\n        access_token: randomAccessToken\n      },\n      // eslint-disable-line camelcase\n      network\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('unsupportedNetwork')\n    });\n  });","file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","skipped":false,"dir":"test"},{"name":"registers a new user","suites":["POST /user/auth/social","facebook"],"updatePoint":{"line":37,"column":28,"index":1153},"line":37,"code":"    it('registers a new user', async () => {\n      const response = await api.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      expect(response.apiToken).to.exist;\n      expect(response.id).to.exist;\n      expect(response.newUser).to.be.true;\n      expect(response.username).to.exist;\n      await expect(getProperty('users', response.id, 'profile.name')).to.eventually.equal('a facebook user');\n      await expect(getProperty('users', response.id, 'auth.local.lowerCaseUsername')).to.exist;\n      await expect(getProperty('users', response.id, 'auth.facebook.id')).to.eventually.equal(facebookId);\n    });","file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","skipped":false,"dir":"test"},{"name":"logs an existing user in","suites":["POST /user/auth/social","facebook"],"updatePoint":{"line":53,"column":32,"index":1880},"line":53,"code":"    it('logs an existing user in', async () => {\n      const registerResponse = await api.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      const response = await api.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      expect(response.apiToken).to.eql(registerResponse.apiToken);\n      expect(response.id).to.eql(registerResponse.id);\n      expect(response.newUser).to.be.false;\n    });","file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","skipped":false,"dir":"test"},{"name":"add social auth to an existing user","suites":["POST /user/auth/social","facebook"],"updatePoint":{"line":72,"column":43,"index":2510},"line":72,"code":"    it('add social auth to an existing user', async () => {\n      const response = await user.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      expect(response.apiToken).to.exist;\n      expect(response.id).to.exist;\n      expect(response.newUser).to.be.false;\n    });","file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","skipped":false,"dir":"test"},{"name":"enrolls a new user in an A/B test","suites":["POST /user/auth/social","facebook"],"updatePoint":{"line":84,"column":42,"index":2894},"line":84,"code":"    xit('enrolls a new user in an A/B test', async () => {\n      await api.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      await expect(getProperty('users', user._id, '_ABtests')).to.eventually.be.a('object');\n    });","skipped":true,"file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","dir":"test"},{"name":"registers a new user","suites":["POST /user/auth/social","google"],"updatePoint":{"line":104,"column":28,"index":3503},"line":104,"code":"    it('registers a new user', async () => {\n      const response = await api.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      expect(response.apiToken).to.exist;\n      expect(response.id).to.exist;\n      expect(response.newUser).to.be.true;\n      await expect(getProperty('users', response.id, 'auth.google.id')).to.eventually.equal(googleId);\n      await expect(getProperty('users', response.id, 'profile.name')).to.eventually.equal('a google user');\n    });","file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","skipped":false,"dir":"test"},{"name":"logs an existing user in","suites":["POST /user/auth/social","google"],"updatePoint":{"line":118,"column":32,"index":4086},"line":118,"code":"    it('logs an existing user in', async () => {\n      const registerResponse = await api.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      const response = await api.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      expect(response.apiToken).to.eql(registerResponse.apiToken);\n      expect(response.id).to.eql(registerResponse.id);\n      expect(response.newUser).to.be.false;\n    });","file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","skipped":false,"dir":"test"},{"name":"add social auth to an existing user","suites":["POST /user/auth/social","google"],"updatePoint":{"line":137,"column":43,"index":4716},"line":137,"code":"    it('add social auth to an existing user', async () => {\n      const response = await user.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      expect(response.apiToken).to.exist;\n      expect(response.id).to.exist;\n      expect(response.newUser).to.be.false;\n    });","file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","skipped":false,"dir":"test"},{"name":"enrolls a new user in an A/B test","suites":["POST /user/auth/social","google"],"updatePoint":{"line":149,"column":42,"index":5100},"line":149,"code":"    xit('enrolls a new user in an A/B test', async () => {\n      await api.post(endpoint, {\n        authResponse: {\n          access_token: randomAccessToken\n        },\n        // eslint-disable-line camelcase\n        network\n      });\n      await expect(getProperty('users', user._id, '_ABtests')).to.eventually.be.a('object');\n    });","skipped":true,"file":"api/v3/integration/user/auth/POST-user_auth_social.test.js","dir":"test"},{"name":"resets password","suites":["POST /user/reset-password"],"updatePoint":{"line":10,"column":21,"index":390},"line":10,"code":"  it('resets password', async () => {\n    const previousPassword = user.auth.local.hashed_password;\n    const response = await user.post(endpoint, {\n      email: user.auth.local.email\n    });\n    expect(response).to.eql({\n      data: {},\n      message: t('passwordReset')\n    });\n    await user.sync();\n    expect(user.auth.local.hashed_password).to.not.eql(previousPassword);\n  });","file":"api/v3/integration/user/auth/POST-user_reset_password.test.js","skipped":false,"dir":"test"},{"name":"same message on error as on success","suites":["POST /user/reset-password"],"updatePoint":{"line":22,"column":41,"index":793},"line":22,"code":"  it('same message on error as on success', async () => {\n    const response = await user.post(endpoint, {\n      email: 'nonExistent@email.com'\n    });\n    expect(response).to.eql({\n      data: {},\n      message: t('passwordReset')\n    });\n  });","file":"api/v3/integration/user/auth/POST-user_reset_password.test.js","skipped":false,"dir":"test"},{"name":"errors if email is not provided","suites":["POST /user/reset-password"],"updatePoint":{"line":31,"column":37,"index":1035},"line":31,"code":"  it('errors if email is not provided', async () => {\n    await expect(user.post(endpoint)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/user/auth/POST-user_reset_password.test.js","skipped":false,"dir":"test"},{"name":"sets a new password reset code on user.auth.local that expires in 1 day","suites":["POST /user/reset-password"],"updatePoint":{"line":38,"column":77,"index":1298},"line":38,"code":"  it('sets a new password reset code on user.auth.local that expires in 1 day', async () => {\n    expect(user.auth.local.passwordResetCode).to.be.undefined;\n    await user.post(endpoint, {\n      email: user.auth.local.email\n    });\n    await user.sync();\n    expect(user.auth.local.passwordResetCode).to.be.a.string;\n    const decryptedCode = JSON.parse(decrypt(user.auth.local.passwordResetCode));\n    expect(decryptedCode.userId).to.equal(user._id);\n    expect(moment(decryptedCode.expiresAt).isAfter(moment().add({\n      hours: 23\n    }))).to.equal(true);\n  });","file":"api/v3/integration/user/auth/POST-user_reset_password.test.js","skipped":false,"dir":"test"},{"name":"does not change email if email is not provided","suites":["PUT /user/auth/update-email","Local Authentication User"],"updatePoint":{"line":14,"column":54,"index":689},"line":14,"code":"    it('does not change email if email is not provided', async () => {\n      await expect(user.put(ENDPOINT)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_email.test.js","skipped":false,"dir":"test"},{"name":"does not change email if password is not provided","suites":["PUT /user/auth/update-email","Local Authentication User"],"updatePoint":{"line":21,"column":57,"index":943},"line":21,"code":"    it('does not change email if password is not provided', async () => {\n      await expect(user.put(ENDPOINT, {\n        newEmail\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_email.test.js","skipped":false,"dir":"test"},{"name":"does not change email if wrong password is provided","suites":["PUT /user/auth/update-email","Local Authentication User"],"updatePoint":{"line":30,"column":59,"index":1227},"line":30,"code":"    it('does not change email if wrong password is provided', async () => {\n      await expect(user.put(ENDPOINT, {\n        newEmail,\n        password: 'wrong password'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('wrongPassword')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_email.test.js","skipped":false,"dir":"test"},{"name":"changes email if new email and existing password are provided","suites":["PUT /user/auth/update-email","Local Authentication User"],"updatePoint":{"line":40,"column":69,"index":1557},"line":40,"code":"    it('changes email if new email and existing password are provided', async () => {\n      const lowerCaseNewEmail = newEmail.toLowerCase();\n      const response = await user.put(ENDPOINT, {\n        newEmail,\n        password: oldPassword\n      });\n      expect(response.email).to.eql(lowerCaseNewEmail);\n      await user.sync();\n      expect(user.auth.local.email).to.eql(lowerCaseNewEmail);\n    });","file":"api/v3/integration/user/auth/PUT-user_update_email.test.js","skipped":false,"dir":"test"},{"name":"rejects if email is already taken","suites":["PUT /user/auth/update-email","Local Authentication User"],"updatePoint":{"line":50,"column":41,"index":1931},"line":50,"code":"    it('rejects if email is already taken', async () => {\n      await expect(user.put(ENDPOINT, {\n        newEmail: user.auth.local.email,\n        password: oldPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('cannotFulfillReq', {\n          techAssistanceEmail: nconf.get('EMAILS_TECH_ASSISTANCE_EMAIL')\n        })\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_email.test.js","skipped":false,"dir":"test"},{"name":"converts user with SHA1 encrypted password to bcrypt encryption","suites":["PUT /user/auth/update-email","Local Authentication User"],"updatePoint":{"line":62,"column":71,"index":2370},"line":62,"code":"    it('converts user with SHA1 encrypted password to bcrypt encryption', async () => {\n      const textPassword = 'mySecretPassword';\n      const salt = sha1MakeSalt();\n      const sha1HashedPassword = sha1EncryptPassword(textPassword, salt);\n      const myNewEmail = 'my-new-random-email@example.net';\n      await user.update({\n        'auth.local.hashed_password': sha1HashedPassword,\n        'auth.local.passwordHashMethod': 'sha1',\n        'auth.local.salt': salt\n      });\n      await user.sync();\n      expect(user.auth.local.passwordHashMethod).to.equal('sha1');\n      expect(user.auth.local.salt).to.equal(salt);\n      expect(user.auth.local.hashed_password).to.equal(sha1HashedPassword); // update email\n\n      const response = await user.put(ENDPOINT, {\n        newEmail: myNewEmail,\n        password: textPassword\n      });\n      expect(response).to.eql({\n        email: myNewEmail\n      });\n      await user.sync();\n      expect(user.auth.local.email).to.equal(myNewEmail);\n      expect(user.auth.local.passwordHashMethod).to.equal('bcrypt');\n      expect(user.auth.local.salt).to.be.undefined;\n      expect(user.auth.local.hashed_password).not.to.equal(sha1HashedPassword);\n      const isValidPassword = await bcryptCompare(textPassword, user.auth.local.hashed_password);\n      expect(isValidPassword).to.equal(true);\n    });","file":"api/v3/integration/user/auth/PUT-user_update_email.test.js","skipped":false,"dir":"test"},{"name":"does not change email if user.auth.local.email does not exist for this user","suites":["PUT /user/auth/update-email","Social Login User"],"updatePoint":{"line":103,"column":83,"index":3966},"line":103,"code":"    it('does not change email if user.auth.local.email does not exist for this user', async () => {\n      await expect(socialUser.put(ENDPOINT, {\n        newEmail,\n        password: oldPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('userHasNoLocalRegistration')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_email.test.js","skipped":false,"dir":"test"},{"name":"successfully changes the password","suites":["PUT /user/auth/update-password"],"updatePoint":{"line":13,"column":39,"index":624},"line":13,"code":"  it('successfully changes the password', async () => {\n    const previousHashedPassword = user.auth.local.hashed_password;\n    const response = await user.put(ENDPOINT, {\n      password,\n      newPassword,\n      confirmPassword: newPassword\n    });\n    expect(response).to.eql({});\n    await user.sync();\n    expect(user.auth.local.hashed_password).to.not.eql(previousHashedPassword);\n  });","file":"api/v3/integration/user/auth/PUT-user_update_password.test.js","skipped":false,"dir":"test"},{"name":"returns an error when confirmPassword does not match newPassword","suites":["PUT /user/auth/update-password"],"updatePoint":{"line":24,"column":70,"index":1047},"line":24,"code":"  it('returns an error when confirmPassword does not match newPassword', async () => {\n    await expect(user.put(ENDPOINT, {\n      password,\n      newPassword,\n      confirmPassword: `${newPassword}-wrong-confirmation`\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('passwordConfirmationMatch')\n    });\n  });","file":"api/v3/integration/user/auth/PUT-user_update_password.test.js","skipped":false,"dir":"test"},{"name":"returns an error when existing password is wrong","suites":["PUT /user/auth/update-password"],"updatePoint":{"line":35,"column":54,"index":1401},"line":35,"code":"  it('returns an error when existing password is wrong', async () => {\n    await expect(user.put(ENDPOINT, {\n      password: wrongPassword,\n      newPassword,\n      confirmPassword: newPassword\n    })).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('wrongPassword')\n    });\n  });","file":"api/v3/integration/user/auth/PUT-user_update_password.test.js","skipped":false,"dir":"test"},{"name":"returns an error when password is missing","suites":["PUT /user/auth/update-password"],"updatePoint":{"line":46,"column":47,"index":1727},"line":46,"code":"  it('returns an error when password is missing', async () => {\n    const body = {\n      newPassword,\n      confirmPassword: newPassword\n    };\n    await expect(user.put(ENDPOINT, body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/user/auth/PUT-user_update_password.test.js","skipped":false,"dir":"test"},{"name":"returns an error when newPassword is missing","suites":["PUT /user/auth/update-password"],"updatePoint":{"line":57,"column":50,"index":2048},"line":57,"code":"  it('returns an error when newPassword is missing', async () => {\n    const body = {\n      password,\n      confirmPassword: newPassword\n    };\n    await expect(user.put(ENDPOINT, body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/user/auth/PUT-user_update_password.test.js","skipped":false,"dir":"test"},{"name":"returns an error when newPassword is too short","suites":["PUT /user/auth/update-password"],"updatePoint":{"line":68,"column":52,"index":2368},"line":68,"code":"  it('returns an error when newPassword is too short', async () => {\n    const body = {\n      password,\n      newPassword: '1234567',\n      confirmPassword: '1234567'\n    };\n    await expect(user.put(ENDPOINT, body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/user/auth/PUT-user_update_password.test.js","skipped":false,"dir":"test"},{"name":"returns an error when confirmPassword is missing","suites":["PUT /user/auth/update-password"],"updatePoint":{"line":80,"column":54,"index":2718},"line":80,"code":"  it('returns an error when confirmPassword is missing', async () => {\n    const body = {\n      password,\n      newPassword\n    };\n    await expect(user.put(ENDPOINT, body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/user/auth/PUT-user_update_password.test.js","skipped":false,"dir":"test"},{"name":"converts user with SHA1 encrypted password to bcrypt encryption","suites":["PUT /user/auth/update-password"],"updatePoint":{"line":91,"column":69,"index":3038},"line":91,"code":"  it('converts user with SHA1 encrypted password to bcrypt encryption', async () => {\n    const textPassword = 'mySecretPassword';\n    const salt = sha1MakeSalt();\n    const sha1HashedPassword = sha1EncryptPassword(textPassword, salt);\n    await user.update({\n      'auth.local.hashed_password': sha1HashedPassword,\n      'auth.local.passwordHashMethod': 'sha1',\n      'auth.local.salt': salt\n    });\n    user.sync();\n    expect(user.auth.local.passwordHashMethod).to.equal('sha1');\n    expect(user.auth.local.salt).to.equal(salt);\n    expect(user.auth.local.hashed_password).to.equal(sha1HashedPassword); // update email\n\n    await user.put(ENDPOINT, {\n      password: textPassword,\n      newPassword,\n      confirmPassword: newPassword\n    });\n    await user.sync();\n    expect(user.auth.local.passwordHashMethod).to.equal('bcrypt');\n    expect(user.auth.local.salt).to.be.undefined;\n    expect(user.auth.local.hashed_password).not.to.equal(sha1HashedPassword);\n    const isValidPassword = await bcryptCompare(newPassword, user.auth.local.hashed_password);\n    expect(isValidPassword).to.equal(true);\n  });","file":"api/v3/integration/user/auth/PUT-user_update_password.test.js","skipped":false,"dir":"test"},{"name":"successfully changes username with password","suites":["PUT /user/auth/update-username"],"updatePoint":{"line":11,"column":49,"index":554},"line":11,"code":"  it('successfully changes username with password', async () => {\n    const newUsername = 'new-username';\n    const response = await user.put(ENDPOINT, {\n      username: newUsername,\n      password\n    });\n    expect(response).to.eql({\n      username: newUsername\n    });\n    await user.sync();\n    expect(user.auth.local.username).to.eql(newUsername);\n  });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"successfully changes username without password","suites":["PUT /user/auth/update-username"],"updatePoint":{"line":23,"column":52,"index":916},"line":23,"code":"  it('successfully changes username without password', async () => {\n    const newUsername = 'new-username-nopw';\n    const response = await user.put(ENDPOINT, {\n      username: newUsername\n    });\n    expect(response).to.eql({\n      username: newUsername\n    });\n    await user.sync();\n    expect(user.auth.local.username).to.eql(newUsername);\n  });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"successfully changes username containing number and underscore","suites":["PUT /user/auth/update-username"],"updatePoint":{"line":34,"column":68,"index":1283},"line":34,"code":"  it('successfully changes username containing number and underscore', async () => {\n    const newUsername = 'new_username9';\n    const response = await user.put(ENDPOINT, {\n      username: newUsername\n    });\n    expect(response).to.eql({\n      username: newUsername\n    });\n    await user.sync();\n    expect(user.auth.local.username).to.eql(newUsername);\n  });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"sets verifiedUsername when changing username","suites":["PUT /user/auth/update-username"],"updatePoint":{"line":45,"column":50,"index":1628},"line":45,"code":"  it('sets verifiedUsername when changing username', async () => {\n    user.flags.verifiedUsername = false;\n    await user.sync();\n    const newUsername = 'new-username-verify';\n    const response = await user.put(ENDPOINT, {\n      username: newUsername\n    });\n    expect(response).to.eql({\n      username: newUsername\n    });\n    await user.sync();\n    expect(user.flags.verifiedUsername).to.eql(true);\n  });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"converts user with SHA1 encrypted password to bcrypt encryption","suites":["PUT /user/auth/update-username"],"updatePoint":{"line":58,"column":69,"index":2058},"line":58,"code":"  it('converts user with SHA1 encrypted password to bcrypt encryption', async () => {\n    const myNewUsername = 'my-new-username';\n    const textPassword = 'mySecretPassword';\n    const salt = sha1MakeSalt();\n    const sha1HashedPassword = sha1EncryptPassword(textPassword, salt);\n    await user.update({\n      'auth.local.hashed_password': sha1HashedPassword,\n      'auth.local.passwordHashMethod': 'sha1',\n      'auth.local.salt': salt\n    });\n    await user.sync();\n    expect(user.auth.local.passwordHashMethod).to.equal('sha1');\n    expect(user.auth.local.salt).to.equal(salt);\n    expect(user.auth.local.hashed_password).to.equal(sha1HashedPassword); // update email\n\n    const response = await user.put(ENDPOINT, {\n      username: myNewUsername,\n      password: textPassword\n    });\n    expect(response).to.eql({\n      username: myNewUsername\n    });\n    await user.sync();\n    expect(user.auth.local.username).to.eql(myNewUsername);\n    expect(user.auth.local.passwordHashMethod).to.equal('bcrypt');\n    expect(user.auth.local.salt).to.be.undefined;\n    expect(user.auth.local.hashed_password).not.to.equal(sha1HashedPassword);\n    const isValidPassword = await bcryptCompare(textPassword, user.auth.local.hashed_password);\n    expect(isValidPassword).to.equal(true);\n  });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"prevents username update if new username is already taken","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":89,"column":65,"index":3370},"line":89,"code":"    it('prevents username update if new username is already taken', async () => {\n      const existingUsername = 'existing-username';\n      await generateUser({\n        'auth.local.username': existingUsername,\n        'auth.local.lowerCaseUsername': existingUsername\n      });\n      await expect(user.put(ENDPOINT, {\n        username: existingUsername,\n        password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('usernameTaken')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"errors if password is wrong","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":104,"column":35,"index":3858},"line":104,"code":"    it('errors if password is wrong', async () => {\n      const newUsername = 'new-username';\n      await expect(user.put(ENDPOINT, {\n        username: newUsername,\n        password: 'wrong-password'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('wrongPassword')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"errors if new username is not provided","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":115,"column":46,"index":4220},"line":115,"code":"    it('errors if new username is not provided', async () => {\n      await expect(user.put(ENDPOINT, {\n        password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"errors if new username is a slur","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":124,"column":40,"index":4485},"line":124,"code":"    it('errors if new username is a slur', async () => {\n      await expect(user.put(ENDPOINT, {\n        username: 'TESTPLACEHOLDERSLURWORDHERE'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: [t('usernameIssueLength'), t('bannedSlurUsedInProfile')].join(' ')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"errors if new username contains a slur","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":133,"column":46,"index":4832},"line":133,"code":"    it('errors if new username contains a slur', async () => {\n      await expect(user.put(ENDPOINT, {\n        username: 'TESTPLACEHOLDERSLURWORDHERE_otherword'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: [t('usernameIssueLength'), t('bannedSlurUsedInProfile')].join(' ')\n      });\n      await expect(user.put(ENDPOINT, {\n        username: 'something_TESTPLACEHOLDERSLURWORDHERE'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: [t('usernameIssueLength'), t('bannedSlurUsedInProfile')].join(' ')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"errors if new username is not allowed","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":149,"column":45,"index":5474},"line":149,"code":"    it('errors if new username is not allowed', async () => {\n      await expect(user.put(ENDPOINT, {\n        username: 'support'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('usernameIssueForbidden')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"errors if new username is not allowed regardless of casing","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":158,"column":66,"index":5782},"line":158,"code":"    it('errors if new username is not allowed regardless of casing', async () => {\n      await expect(user.put(ENDPOINT, {\n        username: 'SUppORT'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('usernameIssueForbidden')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"errors if username has incorrect length","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":167,"column":47,"index":6071},"line":167,"code":"    it('errors if username has incorrect length', async () => {\n      await expect(user.put(ENDPOINT, {\n        username: 'thisisaverylongusernameover20characters'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('usernameIssueLength')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"errors if new username contains invalid characters","suites":["PUT /user/auth/update-username","errors"],"updatePoint":{"line":176,"column":58,"index":6400},"line":176,"code":"    it('errors if new username contains invalid characters', async () => {\n      await expect(user.put(ENDPOINT, {\n        username: 'Eichhörnchen'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('usernameIssueInvalidCharacters')\n      });\n      await expect(user.put(ENDPOINT, {\n        username: 'test.name'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('usernameIssueInvalidCharacters')\n      });\n      await expect(user.put(ENDPOINT, {\n        username: '🤬'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('usernameIssueInvalidCharacters')\n      });\n    });","file":"api/v3/integration/user/auth/PUT-user_update_username.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user does not have enough gold","suites":["POST /user/buy-armoire"],"updatePoint":{"line":10,"column":56,"index":338},"line":10,"code":"  it('returns an error if user does not have enough gold', async () => {\n    await user.update({\n      'stats.gp': 5\n    });\n    await expect(user.post('/user/buy-armoire')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageNotEnoughGold')\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_armoire.test.js","skipped":false,"dir":"test"},{"name":"reduces gold when buying from the armoire","suites":["POST /user/buy-armoire"],"updatePoint":{"line":20,"column":47,"index":641},"line":20,"code":"  it('reduces gold when buying from the armoire', async () => {\n    await user.post('/user/buy-armoire');\n    await user.sync();\n    expect(user.stats.gp).to.equal(300);\n  });","file":"api/v3/integration/user/buy/POST-user_buy_armoire.test.js","skipped":false,"dir":"test"},{"name":"buys a piece of armoire","suites":["POST /user/buy-armoire"],"updatePoint":{"line":25,"column":30,"index":800},"line":25,"code":"  xit('buys a piece of armoire', async () => {// Skipped because can't stub predictableRandom correctly\n  });","skipped":true,"file":"api/v3/integration/user/buy/POST-user_buy_armoire.test.js","dir":"test"},{"name":"returns an error if the item is not found","suites":["POST /user/buy-gear/:key"],"updatePoint":{"line":12,"column":47,"index":417},"line":12,"code":"  it('returns an error if the item is not found', async () => {\n    await expect(user.post('/user/buy-gear/notExisting')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: apiError('itemNotFound', {\n        key: 'notExisting'\n      })\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_gear.test.js","skipped":false,"dir":"test"},{"name":"buys the first level weapon gear","suites":["POST /user/buy-gear/:key"],"updatePoint":{"line":21,"column":38,"index":700},"line":21,"code":"  it('buys the first level weapon gear', async () => {\n    const key = 'weapon_warrior_0';\n    await user.post(`/user/buy-gear/${key}`);\n    await user.sync();\n    expect(user.items.gear.owned[key]).to.eql(true);\n  });","file":"api/v3/integration/user/buy/POST-user_buy_gear.test.js","skipped":false,"dir":"test"},{"name":"buys the first level armor gear","suites":["POST /user/buy-gear/:key"],"updatePoint":{"line":27,"column":37,"index":918},"line":27,"code":"  it('buys the first level armor gear', async () => {\n    const key = 'armor_warrior_1';\n    await user.post(`/user/buy-gear/${key}`);\n    await user.sync();\n    expect(user.items.gear.owned[key]).to.eql(true);\n  });","file":"api/v3/integration/user/buy/POST-user_buy_gear.test.js","skipped":false,"dir":"test"},{"name":"tries to buy subsequent, level gear","suites":["POST /user/buy-gear/:key"],"updatePoint":{"line":33,"column":41,"index":1139},"line":33,"code":"  it('tries to buy subsequent, level gear', async () => {\n    const key = 'armor_warrior_2';\n    return expect(user.post(`/user/buy-gear/${key}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: 'You need to purchase a lower level gear before this one.'\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_gear.test.js","skipped":false,"dir":"test"},{"name":"returns an error if tries to buy gear from a different class","suites":["POST /user/buy-gear/:key"],"updatePoint":{"line":41,"column":66,"index":1482},"line":41,"code":"  it('returns an error if tries to buy gear from a different class', async () => {\n    const key = 'armor_rogue_1';\n    return expect(user.post(`/user/buy-gear/${key}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: 'You can\\'t buy this item.'\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_gear.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user does not have enough gold","suites":["POST /user/buy-health-potion"],"updatePoint":{"line":14,"column":56,"index":435},"line":14,"code":"  it('returns an error if user does not have enough gold', async () => {\n    await expect(user.post('/user/buy-health-potion')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageNotEnoughGold')\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_health_potion.test.js","skipped":false,"dir":"test"},{"name":"buys a potion","suites":["POST /user/buy-health-potion"],"updatePoint":{"line":21,"column":19,"index":664},"line":21,"code":"  it('buys a potion', async () => {\n    await user.update({\n      'stats.gp': 400\n    });\n    const {\n      potion\n    } = content;\n    const res = await user.post('/user/buy-health-potion');\n    await user.sync();\n    expect(user.stats.hp).to.equal(50);\n    expect(res.data).to.eql(user.stats);\n    expect(res.message).to.equal(t('messageBought', {\n      itemText: potion.text()\n    }));\n  });","file":"api/v3/integration/user/buy/POST-user_buy_health_potion.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the mystery set is not found","suites":["POST /user/buy-mystery-set/:key"],"updatePoint":{"line":10,"column":54,"index":370},"line":10,"code":"  it('returns an error if the mystery set is not found', async () => {\n    await expect(user.post('/user/buy-mystery-set/notExisting')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('mysterySetNotFound')\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_mystery_set.test.js","skipped":false,"dir":"test"},{"name":"buys a mystery set","suites":["POST /user/buy-mystery-set/:key"],"updatePoint":{"line":17,"column":24,"index":607},"line":17,"code":"  it('buys a mystery set', async () => {\n    const key = 301404;\n    const res = await user.post(`/user/buy-mystery-set/${key}`);\n    await user.sync();\n    expect(res.data).to.eql({\n      items: JSON.parse(JSON.stringify(user.items)),\n      // otherwise dates can't be compared\n      purchasedPlanConsecutive: user.purchased.plan.consecutive\n    });\n    expect(res.message).to.equal(t('hourglassPurchaseSet'));\n  });","file":"api/v3/integration/user/buy/POST-user_buy_mystery_set.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the quest is not found","suites":["POST /user/buy-quest/:key"],"updatePoint":{"line":13,"column":48,"index":467},"line":13,"code":"  it('returns an error if the quest is not found', async () => {\n    await expect(user.post('/user/buy-quest/notExisting')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: apiError('questNotFound', {\n        key: 'notExisting'\n      })\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_quest.test.js","skipped":false,"dir":"test"},{"name":"buys a quest","suites":["POST /user/buy-quest/:key"],"updatePoint":{"line":22,"column":18,"index":732},"line":22,"code":"  it('buys a quest', async () => {\n    const key = 'dilatoryDistress1';\n    const item = content.quests[key];\n    await user.update({\n      'stats.gp': 250\n    });\n    const res = await user.post(`/user/buy-quest/${key}`);\n    await user.sync();\n    expect(res.data).to.eql(user.items.quests);\n    expect(res.message).to.equal(t('messageBought', {\n      itemText: item.text()\n    }));\n  });","file":"api/v3/integration/user/buy/POST-user_buy_quest.test.js","skipped":false,"dir":"test"},{"name":"returns an error if quest prerequisites are not met","suites":["POST /user/buy-quest/:key"],"updatePoint":{"line":35,"column":57,"index":1162},"line":35,"code":"  it('returns an error if quest prerequisites are not met', async () => {\n    const key = 'dilatoryDistress2';\n    await expect(user.post(`/user/buy-quest/${key}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('mustComplete', {\n        quest: 'dilatoryDistress1'\n      })\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_quest.test.js","skipped":false,"dir":"test"},{"name":"allows purchase of a quest if prerequisites are met","suites":["POST /user/buy-quest/:key"],"updatePoint":{"line":45,"column":57,"index":1503},"line":45,"code":"  it('allows purchase of a quest if prerequisites are met', async () => {\n    const prerequisite = 'dilatoryDistress1';\n    const key = 'dilatoryDistress2';\n    const item = content.quests[key];\n    const achievementName = `achievements.quests.${prerequisite}`;\n    await user.update({\n      [achievementName]: true,\n      'stats.gp': 9999\n    });\n    const res = await user.post(`/user/buy-quest/${key}`);\n    await user.sync();\n    expect(res.data).to.eql(user.items.quests);\n    expect(res.message).to.equal(t('messageBought', {\n      itemText: item.text()\n    }));\n  });","file":"api/v3/integration/user/buy/POST-user_buy_quest.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the special spell is not found","suites":["POST /user/buy-special-spell/:key"],"updatePoint":{"line":13,"column":56,"index":483},"line":13,"code":"  it('returns an error if the special spell is not found', async () => {\n    await expect(user.post('/user/buy-special-spell/notExisting')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: apiError('spellNotFound', {\n        spellId: 'notExisting'\n      })\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_special_spell.test.js","skipped":false,"dir":"test"},{"name":"buys a special spell","suites":["POST /user/buy-special-spell/:key"],"updatePoint":{"line":22,"column":26,"index":768},"line":22,"code":"  it('buys a special spell', async () => {\n    const key = 'thankyou';\n    const item = content.special[key];\n    await user.update({\n      'stats.gp': 250\n    });\n    const res = await user.post(`/user/buy-special-spell/${key}`);\n    await user.sync();\n    expect(res.data).to.eql({\n      items: JSON.parse(JSON.stringify(user.items)),\n      // otherwise dates can't be compared\n      stats: user.stats\n    });\n    expect(res.message).to.equal(t('messageBought', {\n      itemText: item.text()\n    }));\n  });","file":"api/v3/integration/user/buy/POST-user_buy_special_spell.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user does not have enough gold","suites":["POST /user/buy-special-spell/:key"],"updatePoint":{"line":39,"column":56,"index":1307},"line":39,"code":"  it('returns an error if user does not have enough gold', async () => {\n    const key = 'thankyou';\n    await user.update({\n      'stats.gp': 5\n    });\n    await expect(user.post(`/user/buy-special-spell/${key}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageNotEnoughGold')\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy_special_spell.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the item is not found","suites":["POST /user/buy/:key"],"updatePoint":{"line":16,"column":47,"index":520},"line":16,"code":"  it('returns an error if the item is not found', async () => {\n    await expect(user.post('/user/buy/notExisting')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: apiError('itemNotFound', {\n        key: 'notExisting'\n      })\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy.test.js","skipped":false,"dir":"test"},{"name":"buys a potion","suites":["POST /user/buy/:key"],"updatePoint":{"line":25,"column":19,"index":779},"line":25,"code":"  it('buys a potion', async () => {\n    await user.update({\n      'stats.gp': 400,\n      'stats.hp': 40\n    });\n    const {\n      potion\n    } = content;\n    const res = await user.post('/user/buy/potion');\n    await user.sync();\n    expect(user.stats.hp).to.equal(50);\n    expect(res.data).to.eql(user.stats);\n    expect(res.message).to.equal(t('messageBought', {\n      itemText: potion.text()\n    }));\n  });","file":"api/v3/integration/user/buy/POST-user_buy.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user tries to buy a potion with full health","suites":["POST /user/buy/:key"],"updatePoint":{"line":41,"column":69,"index":1239},"line":41,"code":"  it('returns an error if user tries to buy a potion with full health', async () => {\n    await user.update({\n      'stats.gp': 40,\n      'stats.hp': 50\n    });\n    await expect(user.post('/user/buy/potion')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageHealthAlreadyMax')\n    });\n  });","file":"api/v3/integration/user/buy/POST-user_buy.test.js","skipped":false,"dir":"test"},{"name":"buys a piece of gear","suites":["POST /user/buy/:key"],"updatePoint":{"line":52,"column":26,"index":1546},"line":52,"code":"  it('buys a piece of gear', async () => {\n    const key = 'armor_warrior_1';\n    await user.post(`/user/buy/${key}`);\n    await user.sync();\n    expect(user.items.gear.owned.armor_warrior_1).to.eql(true);\n  });","file":"api/v3/integration/user/buy/POST-user_buy.test.js","skipped":false,"dir":"test"},{"name":"buys a special spell","suites":["POST /user/buy/:key"],"updatePoint":{"line":58,"column":26,"index":1758},"line":58,"code":"  it('buys a special spell', async () => {\n    const key = 'spookySparkles';\n    const item = content.special[key];\n    const stub = sinon.stub(item, 'canOwn').returns(true);\n    await user.update({\n      'stats.gp': 250\n    });\n    const res = await user.post(`/user/buy/${key}`);\n    await user.sync();\n    expect(res.data).to.eql({\n      items: JSON.parse(JSON.stringify(user.items)),\n      // otherwise dates can't be compared\n      stats: user.stats\n    });\n    expect(res.message).to.equal(t('messageBought', {\n      itemText: item.text()\n    }));\n    stub.restore();\n  });","file":"api/v3/integration/user/buy/POST-user_buy.test.js","skipped":false,"dir":"test"},{"name":"allows for bulk purchases","suites":["POST /user/buy/:key"],"updatePoint":{"line":77,"column":31,"index":2343},"line":77,"code":"  it('allows for bulk purchases', async () => {\n    await user.update({\n      'stats.gp': 400,\n      'stats.hp': 20\n    });\n    const {\n      potion\n    } = content;\n    const res = await user.post('/user/buy/potion', {\n      quantity: 2\n    });\n    await user.sync();\n    expect(user.stats.hp).to.equal(50);\n    expect(res.data).to.eql(user.stats);\n    expect(res.message).to.equal(t('messageBought', {\n      itemText: potion.text()\n    }));\n  });","file":"api/v3/integration/user/buy/POST-user_buy.test.js","skipped":false,"dir":"test"},{"name":"one message","suites":["DELETE user message"],"updatePoint":{"line":22,"column":17,"index":800},"line":22,"code":"  it('one message', async () => {\n    const result = await user.del(`/user/messages/${messagesId[0]}`);\n    messagesId = Object.keys(result);\n    expect(messagesId.length).to.eql(1);\n    const userRes = await user.get('/user');\n    expect(Object.keys(userRes.inbox.messages).length).to.eql(1);\n    expect(userRes.inbox.messages[messagesId[0]].text).to.eql('first');\n  });","file":"api/v3/integration/user/DELETE-user_messages.test.js","skipped":false,"dir":"test"},{"name":"clear all","suites":["DELETE user message"],"updatePoint":{"line":30,"column":15,"index":1170},"line":30,"code":"  it('clear all', async () => {\n    const result = await user.del('/user/messages');\n    const userRes = await user.get('/user');\n    expect(userRes.inbox.messages).to.eql({});\n    expect(result).to.eql({});\n  });","file":"api/v3/integration/user/DELETE-user_messages.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user does not have the push device","suites":["DELETE /user/push-devices"],"updatePoint":{"line":9,"column":60,"index":316},"line":9,"code":"  it('returns an error if user does not have the push device', async () => {\n    await expect(user.del(`/user/push-devices/${regId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('pushDeviceNotFound')\n    });\n  });","file":"api/v3/integration/user/DELETE-user_push_device.test.js","skipped":false,"dir":"test"},{"name":"removes a push device from the user","suites":["DELETE /user/push-devices"],"updatePoint":{"line":16,"column":41,"index":563},"line":16,"code":"  it('removes a push device from the user', async () => {\n    await user.post('/user/push-devices', {\n      type,\n      regId\n    });\n    const response = await user.del(`/user/push-devices/${regId}`);\n    await user.sync();\n    expect(response.message).to.equal(t('pushDeviceRemoved'));\n    expect(user.pushDevices.length).to.equal(0);\n  });","file":"api/v3/integration/user/DELETE-user_push_device.test.js","skipped":false,"dir":"test"},{"name":"returns an error if password is wrong","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":16,"column":45,"index":762},"line":16,"code":"    it('returns an error if password is wrong', async () => {\n      await expect(user.del('/user', {\n        password: 'wrong-password'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('wrongPassword')\n      });\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if password is not supplied","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":25,"column":52,"index":1056},"line":25,"code":"    it('returns an error if password is not supplied', async () => {\n      await expect(user.del('/user', {\n        password: ''\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('missingPassword')\n      });\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"deletes the user","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":34,"column":24,"index":1307},"line":34,"code":"    it('deletes the user', async () => {\n      await user.del('/user', {\n        password\n      });\n      await expect(checkExistence('users', user._id)).to.eventually.eql(false);\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if excessive feedback is supplied","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":40,"column":58,"index":1529},"line":40,"code":"    it('returns an error if excessive feedback is supplied', async () => {\n      const feedbackText = 'spam feedback ';\n      let feedback = feedbackText;\n\n      while (feedback.length < 10000) {\n        feedback += feedbackText;\n      }\n\n      await expect(user.del('/user', {\n        password,\n        feedback\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'Account deletion feedback is limited to 10,000 characters. For lengthy feedback, email admin@habitica.com.'\n      });\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user has active subscription","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":57,"column":56,"index":2078},"line":57,"code":"    it('returns an error if user has active subscription', async () => {\n      const userWithSubscription = await generateUser({\n        'purchased.plan.customerId': 'fake-customer-id'\n      });\n      await expect(userWithSubscription.del('/user', {\n        password\n      })).to.be.rejected.and.to.eventually.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('cannotDeleteActiveAccount')\n      });\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"deletes the user's tasks","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":69,"column":33,"index":2488},"line":69,"code":"    it('deletes the user\\'s tasks', async () => {\n      await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await user.sync(); // gets the user's tasks ids\n\n      const ids = [];\n      each(user.tasksOrder, idsForOrder => {\n        ids.push(...idsForOrder);\n      });\n      expect(ids.length).to.be.above(0); // make sure the user has some task to delete\n\n      await user.del('/user', {\n        password\n      });\n      await Promise.all(map(ids, id => expect(checkExistence('tasks', id)).to.eventually.eql(false)));\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"reduces memberCount in challenges user is linked to","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":87,"column":59,"index":3087},"line":87,"code":"    it('reduces memberCount in challenges user is linked to', async () => {\n      const populatedGroup = await createAndPopulateGroup({\n        members: 2\n      });\n      const {\n        group\n      } = populatedGroup;\n      const authorizedUser = populatedGroup.members[1];\n      const challenge = await generateChallenge(populatedGroup.groupLeader, group);\n      await populatedGroup.groupLeader.post(`/challenges/${challenge._id}/join`);\n      await authorizedUser.post(`/challenges/${challenge._id}/join`);\n      await challenge.sync();\n      expect(challenge.memberCount).to.eql(2);\n      await authorizedUser.del('/user', {\n        password\n      });\n      await challenge.sync();\n      expect(challenge.memberCount).to.eql(1);\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"sends feedback to the admin email","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":106,"column":41,"index":3811},"line":106,"code":"    it('sends feedback to the admin email', async () => {\n      sandbox.spy(email, 'sendTxn');\n      const feedback = 'Reasons for Deletion';\n      await user.del('/user', {\n        password,\n        feedback\n      });\n      expect(email.sendTxn).to.be.calledOnce;\n      sandbox.restore();\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"does not send email if no feedback is supplied","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":116,"column":54,"index":4122},"line":116,"code":"    it('does not send email if no feedback is supplied', async () => {\n      sandbox.spy(email, 'sendTxn');\n      await user.del('/user', {\n        password\n      });\n      expect(email.sendTxn).to.not.be.called;\n      sandbox.restore();\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"deletes the user with a legacy sha1 password","suites":["DELETE /user","user with local auth"],"updatePoint":{"line":124,"column":52,"index":4366},"line":124,"code":"    it('deletes the user with a legacy sha1 password', async () => {\n      const textPassword = 'mySecretPassword';\n      const salt = sha1MakeSalt();\n      const sha1HashedPassword = sha1EncryptPassword(textPassword, salt);\n      await user.update({\n        'auth.local.hashed_password': sha1HashedPassword,\n        'auth.local.passwordHashMethod': 'sha1',\n        'auth.local.salt': salt\n      });\n      await user.sync();\n      expect(user.auth.local.passwordHashMethod).to.equal('sha1');\n      expect(user.auth.local.salt).to.equal(salt);\n      expect(user.auth.local.hashed_password).to.equal(sha1HashedPassword); // delete the user\n\n      await user.del('/user', {\n        password: textPassword\n      });\n      await expect(checkExistence('users', user._id)).to.eventually.eql(false);\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"deletes party when user is the only member","suites":["DELETE /user","user with local auth","last member of a party"],"updatePoint":{"line":151,"column":52,"index":5380},"line":151,"code":"      it('deletes party when user is the only member', async () => {\n        await user.del('/user', {\n          password\n        });\n        await expect(checkExistence('party', party._id)).to.eventually.eql(false);\n      });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"deletes guild when user is the only member","suites":["DELETE /user","user with local auth","last member of a private guild"],"updatePoint":{"line":166,"column":52,"index":5851},"line":166,"code":"      it('deletes guild when user is the only member', async () => {\n        await user.del('/user', {\n          password\n        });\n        await expect(checkExistence('groups', privateGuild._id)).to.eventually.eql(false);\n      });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"chooses new group leader for any group user was the leader of","suites":["DELETE /user","user with local auth","groups user is leader of"],"updatePoint":{"line":194,"column":71,"index":6640},"line":194,"code":"      it('chooses new group leader for any group user was the leader of', async () => {\n        await oldLeader.del('/user', {\n          password\n        });\n        const updatedGuild = await newLeader.get(`/groups/${guild._id}`);\n        expect(updatedGuild.leader).to.exist;\n        expect(updatedGuild.leader._id).to.not.eql(oldLeader._id);\n      });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"removes user from all groups user was a part of","suites":["DELETE /user","user with local auth","groups user is a part of"],"updatePoint":{"line":231,"column":57,"index":7742},"line":231,"code":"      it('removes user from all groups user was a part of', async () => {\n        await userToDelete.del('/user', {\n          password\n        });\n        const updatedGroup1Members = await otherUser.get(`/groups/${group1._id}/members`);\n        const updatedGroup2Members = await otherUser.get(`/groups/${group2._id}/members`);\n        const userInGroup = find(updatedGroup2Members, member => member._id === userToDelete._id);\n        expect(updatedGroup1Members).to.be.empty;\n        expect(updatedGroup2Members).to.not.be.empty;\n        expect(userInGroup).to.not.exist;\n      });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if confirmation phrase is wrong","suites":["DELETE /user","user with Facebook auth"],"updatePoint":{"line":254,"column":56,"index":8561},"line":254,"code":"    it('returns an error if confirmation phrase is wrong', async () => {\n      await expect(user.del('/user', {\n        password: 'just-do-it'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('incorrectDeletePhrase', {\n          magicWord: 'DELETE'\n        })\n      });\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if confirmation phrase is not supplied","suites":["DELETE /user","user with Facebook auth"],"updatePoint":{"line":265,"column":63,"index":8913},"line":265,"code":"    it('returns an error if confirmation phrase is not supplied', async () => {\n      await expect(user.del('/user', {\n        password: ''\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('missingPassword')\n      });\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"deletes a Facebook user","suites":["DELETE /user","user with Facebook auth"],"updatePoint":{"line":274,"column":31,"index":9171},"line":274,"code":"    it('deletes a Facebook user', async () => {\n      await user.del('/user', {\n        password: DELETE_CONFIRMATION\n      });\n      await expect(checkExistence('users', user._id)).to.eventually.eql(false);\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"deletes a Google user","suites":["DELETE /user","user with Google auth"],"updatePoint":{"line":291,"column":29,"index":9607},"line":291,"code":"    it('deletes a Google user', async () => {\n      await user.del('/user', {\n        password: DELETE_CONFIRMATION\n      });\n      await expect(checkExistence('users', user._id)).to.eventually.eql(false);\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"deletes a Apple user","suites":["DELETE /user","user with Apple auth"],"updatePoint":{"line":308,"column":28,"index":10039},"line":308,"code":"    it('deletes a Apple user', async () => {\n      await user.del('/user', {\n        password: DELETE_CONFIRMATION\n      });\n      await expect(checkExistence('users', user._id)).to.eventually.eql(false);\n    });","file":"api/v3/integration/user/DELETE-user.test.js","skipped":false,"dir":"test"},{"name":"returns the authenticated user","suites":["GET /user/anonymized"],"updatePoint":{"line":73,"column":36,"index":2257},"line":73,"code":"  it('returns the authenticated user', async () => {\n    let returnedUser = await user.get(endpoint);\n    returnedUser = returnedUser.user;\n    expect(returnedUser._id).to.equal(user._id);\n  });","file":"api/v3/integration/user/GET-user_anonymized.test.js","skipped":false,"dir":"test"},{"name":"does not return private paths (and apiToken)","suites":["GET /user/anonymized"],"updatePoint":{"line":78,"column":50,"index":2466},"line":78,"code":"  it('does not return private paths (and apiToken)', async () => {\n    let returnedUser = await user.get(endpoint);\n    const tasks2 = returnedUser.tasks;\n    returnedUser = returnedUser.user;\n    expect(returnedUser.auth.local).to.not.exist;\n    expect(returnedUser.apiToken).to.not.exist;\n    expect(returnedUser.stats.maxHealth).to.eql(common.maxHealth);\n    expect(returnedUser.stats.toNextLevel).to.eql(common.tnl(user.stats.lvl));\n    expect(returnedUser.stats.maxMP).to.eql(30); // TODO why 30?\n\n    expect(returnedUser.newMessages).to.not.exist;\n    expect(returnedUser.notifications).to.not.exist;\n    expect(returnedUser.profile).to.not.exist;\n    expect(returnedUser.purchased.plan).to.not.exist;\n    expect(returnedUser.contributor).to.not.exist;\n    expect(returnedUser.invitations).to.not.exist;\n    expect(returnedUser.items.special.nyeReceived).to.not.exist;\n    expect(returnedUser.items.special.valentineReceived).to.not.exist;\n    expect(returnedUser.webhooks).to.not.exist;\n    expect(returnedUser.achievements.challenges).to.not.exist;\n\n    _.forEach(returnedUser.inbox.messages, msg => {\n      expect(msg.text).to.eql('inbox message text');\n    });\n\n    _.forEach(returnedUser.tags, tag => {\n      expect(tag.name).to.eql('tag');\n      expect(tag.challenge).to.eql('challenge');\n    }); // tasks\n\n\n    expect(tasks2).to.exist;\n    expect(tasks2.length).to.eql(5);\n    expect(tasks2[0].checklist).to.exist;\n\n    _.forEach(tasks2, task => {\n      expect(task.text).to.eql('task text');\n      expect(task.notes).to.eql('task notes');\n\n      if (task.checklist) {\n        _.forEach(task.checklist, c => {\n          expect(c.text.substr(0, 5)).to.eql('item ');\n        });\n      }\n    });\n\n    expect(returnedUser.secret).to.not.exist;\n  });","file":"api/v3/integration/user/GET-user_anonymized.test.js","skipped":false,"dir":"test"},{"name":"returns the reward items available for purchase","suites":["GET /user/in-app-rewards"],"updatePoint":{"line":7,"column":53,"index":260},"line":7,"code":"  it('returns the reward items available for purchase', async () => {\n    const buyList = await user.get('/user/in-app-rewards');\n    expect(_.find(buyList, item => item.text === t('armorWarrior1Text'))).to.exist;\n    expect(_.find(buyList, item => item.text === t('armorWarrior2Text'))).to.not.exist;\n  });","file":"api/v3/integration/user/GET-user_inAppRewards.test.js","skipped":false,"dir":"test"},{"name":"returns the gear items available for purchase","suites":["GET /user/inventory/buy"],"updatePoint":{"line":8,"column":51,"index":298},"line":8,"code":"  it('returns the gear items available for purchase', async () => {\n    const buyList = await user.get('/user/inventory/buy');\n    expect(_.find(buyList, item => item.text === t('armorWarrior1Text'))).to.exist;\n    expect(_.find(buyList, item => item.text === t('armorWarrior2Text'))).to.not.exist;\n  });","file":"api/v3/integration/user/GET-user_inventory_buy.test.js","skipped":false,"dir":"test"},{"name":"cannot unpin potion","suites":["GET /user/toggle-pinned-item"],"updatePoint":{"line":7,"column":25,"index":236},"line":7,"code":"  it('cannot unpin potion', async () => {\n    await expect(user.get('/user/toggle-pinned-item/potion/potion')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('cannotUnpinItem')\n    });\n  });","file":"api/v3/integration/user/GET-user_toggle-pinned-item.test.js","skipped":false,"dir":"test"},{"name":"can pin shield_rogue_5","suites":["GET /user/toggle-pinned-item"],"updatePoint":{"line":14,"column":28,"index":480},"line":14,"code":"  it('can pin shield_rogue_5', async () => {\n    const result = await user.get('/user/toggle-pinned-item/marketGear/gear.flat.shield_rogue_5');\n    expect(result.pinnedItems.length).to.be.eql(user.pinnedItems.length + 1);\n  });","file":"api/v3/integration/user/GET-user_toggle-pinned-item.test.js","skipped":false,"dir":"test"},{"name":"returns the authenticated user with computed stats","suites":["GET /user"],"updatePoint":{"line":9,"column":56,"index":318},"line":9,"code":"  it('returns the authenticated user with computed stats', async () => {\n    const returnedUser = await user.get('/user');\n    expect(returnedUser._id).to.equal(user._id);\n    expect(returnedUser.stats.maxMP).to.exist;\n    expect(returnedUser.stats.maxHealth).to.equal(common.maxHealth);\n    expect(returnedUser.stats.toNextLevel).to.equal(common.tnl(returnedUser.stats.lvl));\n  });","file":"api/v3/integration/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"does not return private paths (and apiToken)","suites":["GET /user"],"updatePoint":{"line":16,"column":50,"index":695},"line":16,"code":"  it('does not return private paths (and apiToken)', async () => {\n    const returnedUser = await user.get('/user');\n    expect(returnedUser.auth.local.hashed_password).to.not.exist;\n    expect(returnedUser.auth.local.passwordHashMethod).to.not.exist;\n    expect(returnedUser.auth.local.salt).to.not.exist;\n    expect(returnedUser.apiToken).to.not.exist;\n    expect(returnedUser.secret).to.not.exist;\n  });","file":"api/v3/integration/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"returns only user properties requested","suites":["GET /user"],"updatePoint":{"line":24,"column":44,"index":1096},"line":24,"code":"  it('returns only user properties requested', async () => {\n    const returnedUser = await user.get('/user?userFields=achievements,items.mounts');\n    expect(returnedUser._id).to.equal(user._id);\n    expect(returnedUser.achievements).to.exist;\n    expect(returnedUser.items.mounts).to.exist; // Notifications are always returned\n\n    expect(returnedUser.notifications).to.exist;\n    expect(returnedUser.stats).to.not.exist;\n  });","file":"api/v3/integration/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"does not return requested private properties","suites":["GET /user"],"updatePoint":{"line":33,"column":50,"index":1533},"line":33,"code":"  it('does not return requested private properties', async () => {\n    const returnedUser = await user.get('/user?userFields=apiToken,secret.text');\n    expect(returnedUser.apiToken).to.not.exist;\n    expect(returnedUser.secret).to.not.exist;\n  });","file":"api/v3/integration/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"returns the full inbox","suites":["GET /user"],"updatePoint":{"line":38,"column":28,"index":1760},"line":38,"code":"  it('returns the full inbox', async () => {\n    const otherUser = await generateUser();\n    const amountOfMessages = 12;\n    const allMessagesPromise = range(amountOfMessages).map(i => otherUser.post('/members/send-private-message', {\n      toUserId: user.id,\n      message: `Message Num: ${i}`\n    }));\n    await Promise.all(allMessagesPromise);\n    const returnedUser = await user.get('/user');\n    expect(returnedUser._id).to.equal(user._id);\n    expect(returnedUser.inbox).to.exist;\n    expect(Object.keys(returnedUser.inbox.messages)).to.have.a.lengthOf(amountOfMessages);\n  });","file":"api/v3/integration/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"validates uuid","suites":["block user"],"updatePoint":{"line":17,"column":20,"index":506},"line":17,"code":"  it('validates uuid', async () => {\n    await expect(user.post('/user/block/1')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidUUID')\n    });\n  });","file":"api/v3/integration/user/POST-user_block.test.js","skipped":false,"dir":"test"},{"name":"successfully","suites":["block user"],"updatePoint":{"line":24,"column":18,"index":712},"line":24,"code":"  it('successfully', async () => {\n    const response = await user.post(`/user/block/${blockedUser2._id}`);\n    await user.sync();\n    expect(response).to.eql([blockedUser._id, blockedUser2._id]);\n    expect(user.inbox.blocks.length).to.eql(2);\n    expect(user.inbox.blocks).to.include(blockedUser2._id);\n  });","file":"api/v3/integration/user/POST-user_block.test.js","skipped":false,"dir":"test"},{"name":"changes class","suites":["POST /user/change-class"],"updatePoint":{"line":11,"column":19,"index":319},"line":11,"code":"  it('changes class', async () => {\n    const res = await user.post('/user/change-class?class=rogue');\n    await user.sync();\n    expect(res).to.eql(JSON.parse(JSON.stringify({\n      preferences: user.preferences,\n      stats: user.stats,\n      flags: user.flags,\n      items: user.items\n    })));\n  });","file":"api/v3/integration/user/POST-user_change-class.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell does not exist","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":10,"column":46,"index":470},"line":10,"code":"  it('returns an error if spell does not exist', async () => {\n    await user.update({\n      'stats.class': 'rogue'\n    });\n    const spellId = 'invalidSpell';\n    await expect(user.post(`/user/class/cast/${spellId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: apiError('spellNotFound', {\n        spellId\n      })\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell does not exist in user's class","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":23,"column":63,"index":866},"line":23,"code":"  it('returns an error if spell does not exist in user\\'s class', async () => {\n    const spellId = 'pickPocket';\n    await expect(user.post(`/user/class/cast/${spellId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: apiError('spellNotFound', {\n        spellId\n      })\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell.mana > user.mana","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":33,"column":48,"index":1184},"line":33,"code":"  it('returns an error if spell.mana > user.mana', async () => {\n    await user.update({\n      'stats.class': 'rogue'\n    });\n    await expect(user.post('/user/class/cast/backStab')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughMana')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell.value > user.gold","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":43,"column":49,"index":1499},"line":43,"code":"  it('returns an error if spell.value > user.gold', async () => {\n    await expect(user.post('/user/class/cast/birthday')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageNotEnoughGold')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if use Healing Light spell with full health","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":50,"column":66,"index":1777},"line":50,"code":"  it('returns an error if use Healing Light spell with full health', async () => {\n    await user.update({\n      'stats.class': 'healer',\n      'stats.lvl': 11,\n      'stats.hp': 50,\n      'stats.mp': 200\n    });\n    await expect(user.post('/user/class/cast/heal')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageHealthAlreadyMax')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell.lvl > user.level","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":63,"column":48,"index":2166},"line":63,"code":"  it('returns an error if spell.lvl > user.level', async () => {\n    await user.update({\n      'stats.mp': 200,\n      'stats.class': 'wizard'\n    });\n    await expect(user.post('/user/class/cast/earth')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('spellLevelTooHigh', {\n        level: 13\n      })\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user doesn't own the spell","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":76,"column":53,"index":2539},"line":76,"code":"  it('returns an error if user doesn\\'t own the spell', async () => {\n    await expect(user.post('/user/class/cast/snowball')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('spellNotOwned')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if targetId is not an UUID","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":83,"column":49,"index":2793},"line":83,"code":"  it('returns an error if targetId is not an UUID', async () => {\n    await expect(user.post('/user/class/cast/spellId?targetId=notAnUUID')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if targetId is required but missing","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":90,"column":58,"index":3074},"line":90,"code":"  it('returns an error if targetId is required but missing', async () => {\n    await user.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 11\n    });\n    await expect(user.post('/user/class/cast/pickPocket')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('targetIdUUID')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if targeted task doesn't exist","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":101,"column":54,"index":3415},"line":101,"code":"  it('returns an error if targeted task doesn\\'t exist', async () => {\n    await user.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 11\n    });\n    await expect(user.post(`/user/class/cast/pickPocket?targetId=${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if a challenge task was targeted","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":112,"column":55,"index":3789},"line":112,"code":"  it('returns an error if a challenge task was targeted', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup();\n    const challenge = await generateChallenge(groupLeader, group);\n    await groupLeader.post(`/challenges/${challenge._id}/join`);\n    await groupLeader.post(`/tasks/challenge/${challenge._id}`, [{\n      type: 'habit',\n      text: 'task text'\n    }]);\n    await groupLeader.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 11\n    });\n    await sleep(0.5);\n    await groupLeader.sync();\n    await expect(groupLeader.post(`/user/class/cast/pickPocket?targetId=${groupLeader.tasksOrder.habits[0]}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('challengeTasksNoCast')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if a group task was targeted","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":135,"column":51,"index":4582},"line":135,"code":"  it('returns an error if a group task was targeted', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup();\n    const groupTask = await groupLeader.post(`/tasks/group/${group._id}`, {\n      text: 'todo group',\n      type: 'todo'\n    });\n    await groupLeader.post(`/tasks/${groupTask._id}/assign/${groupLeader._id}`);\n    const memberTasks = await groupLeader.get('/tasks/user');\n    const syncedGroupTask = find(memberTasks, memberTask => memberTask.group.id === group._id);\n    await groupLeader.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 11\n    });\n    await sleep(0.5);\n    await groupLeader.sync();\n    await expect(groupLeader.post(`/user/class/cast/pickPocket?targetId=${syncedGroupTask._id}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('groupTasksNoCast')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"Issue #12361: returns an error if stealth has already been cast","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":159,"column":69,"index":5491},"line":159,"code":"  it('Issue #12361: returns an error if stealth has already been cast', async () => {\n    await user.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 15,\n      'stats.mp': 400,\n      'stats.buffs.stealth': 1\n    });\n    await user.sync();\n    await expect(user.post('/user/class/cast/stealth')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('spellAlreadyCast')\n    });\n    expect(user.stats.mp).to.equal(400);\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if targeted party member doesn't exist","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":174,"column":62,"index":5960},"line":174,"code":"  it('returns an error if targeted party member doesn\\'t exist', async () => {\n    const {\n      groupLeader\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 1\n    });\n    await groupLeader.update({\n      'items.special.snowball': 3\n    });\n    const target = generateUUID();\n    await expect(groupLeader.post(`/user/class/cast/snowball?targetId=${target}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: target\n      })\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if party does not exists","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":196,"column":47,"index":6555},"line":196,"code":"  it('returns an error if party does not exists', async () => {\n    await user.update({\n      'items.special.snowball': 3\n    });\n    await expect(user.post(`/user/class/cast/snowball?targetId=${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('partyNotFound')\n    });\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"send message in party chat if party && !spell.silent","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":206,"column":58,"index":6906},"line":206,"code":"  it('send message in party chat if party && !spell.silent', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 1\n    });\n    await groupLeader.update({\n      'stats.mp': 200,\n      'stats.class': 'wizard',\n      'stats.lvl': 13\n    });\n    await groupLeader.post('/user/class/cast/earth');\n    await sleep(1);\n    const groupMessages = await groupLeader.get(`/groups/${group._id}/chat`);\n    expect(groupMessages[0]).to.exist;\n    expect(groupMessages[0].uuid).to.equal('system');\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"Ethereal Surge does not recover mp of other mages","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":228,"column":55,"index":7532},"line":228,"code":"  it('Ethereal Surge does not recover mp of other mages', async () => {\n    const group = await createAndPopulateGroup({\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 4\n    });\n    let promises = [];\n    promises.push(group.groupLeader.update({\n      'stats.mp': 200,\n      'stats.class': 'wizard',\n      'stats.lvl': 20\n    }));\n    promises.push(group.members[0].update({\n      'stats.mp': 0,\n      'stats.class': 'warrior',\n      'stats.lvl': 20\n    }));\n    promises.push(group.members[1].update({\n      'stats.mp': 0,\n      'stats.class': 'wizard',\n      'stats.lvl': 20\n    }));\n    promises.push(group.members[2].update({\n      'stats.mp': 0,\n      'stats.class': 'rogue',\n      'stats.lvl': 20\n    }));\n    promises.push(group.members[3].update({\n      'stats.mp': 0,\n      'stats.class': 'healer',\n      'stats.lvl': 20\n    }));\n    await Promise.all(promises);\n    await group.groupLeader.post('/user/class/cast/mpheal');\n    promises = [];\n    promises.push(group.members[0].sync());\n    promises.push(group.members[1].sync());\n    promises.push(group.members[2].sync());\n    promises.push(group.members[3].sync());\n    await Promise.all(promises);\n    expect(group.members[0].stats.mp).to.be.greaterThan(0); // warrior\n\n    expect(group.members[1].stats.mp).to.equal(0); // wizard\n\n    expect(group.members[2].stats.mp).to.be.greaterThan(0); // rogue\n\n    expect(group.members[3].stats.mp).to.be.greaterThan(0); // healer\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"cast bulk","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":278,"column":15,"index":8982},"line":278,"code":"  it('cast bulk', async () => {\n    let {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup({\n      // eslint-disable-line prefer-const\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 1\n    });\n    await groupLeader.update({\n      'stats.mp': 200,\n      'stats.class': 'wizard',\n      'stats.lvl': 13\n    });\n    await groupLeader.post('/user/class/cast/earth', {\n      quantity: 2\n    });\n    await sleep(1);\n    group = await groupLeader.get(`/groups/${group._id}`);\n    expect(group.chat[0]).to.exist;\n    expect(group.chat[0].uuid).to.equal('system');\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"searing brightness does not affect challenge or group tasks","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":303,"column":65,"index":9660},"line":303,"code":"  it('searing brightness does not affect challenge or group tasks', async () => {\n    const guild = await generateGroup(user);\n    const challenge = await generateChallenge(user, guild);\n    await user.post(`/challenges/${challenge._id}/join`);\n    await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test challenge habit',\n      type: 'habit'\n    });\n    const groupTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'todo group',\n      type: 'todo'\n    });\n    await user.update({\n      'stats.class': 'healer',\n      'stats.mp': 200,\n      'stats.lvl': 15\n    });\n    await user.post(`/tasks/${groupTask._id}/assign/${user._id}`);\n    await user.post('/user/class/cast/brightness');\n    await user.sync();\n    const memberTasks = await user.get('/tasks/user');\n    const syncedGroupTask = find(memberTasks, memberTask => memberTask.group.id === guild._id);\n    const userChallengeTask = find(memberTasks, memberTask => memberTask.challenge.id === challenge._id);\n    expect(userChallengeTask).to.exist;\n    expect(syncedGroupTask).to.exist;\n    expect(userChallengeTask.value).to.equal(0);\n    expect(syncedGroupTask.value).to.equal(0);\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"increases both user's achievement values","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":331,"column":47,"index":10819},"line":331,"code":"  it('increases both user\\'s achievement values', async () => {\n    const party = await createAndPopulateGroup({\n      members: 1\n    });\n    const leader = party.groupLeader;\n    const recipient = party.members[0];\n    await leader.update({\n      'stats.gp': 10\n    });\n    await leader.post(`/user/class/cast/birthday?targetId=${recipient._id}`);\n    await leader.sync();\n    await recipient.sync();\n    expect(leader.achievements.birthday).to.equal(1);\n    expect(recipient.achievements.birthday).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"only increases user's achievement one if target == caster","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":346,"column":64,"index":11355},"line":346,"code":"  it('only increases user\\'s achievement one if target == caster', async () => {\n    await user.update({\n      'stats.gp': 10\n    });\n    await user.post(`/user/class/cast/birthday?targetId=${user._id}`);\n    await user.sync();\n    expect(user.achievements.birthday).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'task'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":354,"column":65,"index":11642},"line":354,"code":"  it('passes correct target to spell when targetType === \\'task\\'', async () => {\n    await user.update({\n      'stats.class': 'wizard',\n      'stats.lvl': 11\n    });\n    const task = await user.post('/tasks/user', {\n      text: 'test habit',\n      type: 'habit'\n    });\n    const result = await user.post(`/user/class/cast/fireball?targetId=${task._id}`);\n    expect(result.task._id).to.equal(task._id);\n  });","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'self'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":366,"column":65,"index":12053},"line":366,"code":"  it('passes correct target to spell when targetType === \\'self\\'', async () => {\n    await user.update({\n      'stats.class': 'wizard',\n      'stats.lvl': 14,\n      'stats.mp': 50\n    });\n    const result = await user.post('/user/class/cast/frost');\n    expect(result.user.stats.mp).to.equal(10);\n  }); // TODO find a way to have sinon working in integration tests","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'tasks'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":377,"column":66,"index":12488},"line":377,"code":"  it('passes correct target to spell when targetType === \\'tasks\\'');","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'party'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":378,"column":66,"index":12558},"line":378,"code":"  it('passes correct target to spell when targetType === \\'party\\'');","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'user'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":379,"column":65,"index":12627},"line":379,"code":"  it('passes correct target to spell when targetType === \\'user\\'');","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'party' and user is not in a party","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":380,"column":93,"index":12724},"line":380,"code":"  it('passes correct target to spell when targetType === \\'party\\' and user is not in a party');","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'user' and user is not in a party","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":381,"column":92,"index":12820},"line":381,"code":"  it('passes correct target to spell when targetType === \\'user\\' and user is not in a party');","file":"api/v3/integration/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"updates user.preferences.dayStart","suites":["POST /user/custom-day-start"],"updatePoint":{"line":9,"column":39,"index":323},"line":9,"code":"  it('updates user.preferences.dayStart', async () => {\n    expect(user.preferences.dayStart).to.eql(0);\n    await user.post(endpoint, {\n      dayStart: 1\n    });\n    await user.sync();\n    expect(user.preferences.dayStart).to.eql(1);\n  });","file":"api/v3/integration/user/POST-user_custom-day-start.test.js","skipped":false,"dir":"test"},{"name":"sets lastCron to the current time to prevent an unexpected cron","suites":["POST /user/custom-day-start"],"updatePoint":{"line":17,"column":69,"index":594},"line":17,"code":"  it('sets lastCron to the current time to prevent an unexpected cron', async () => {\n    const oldCron = moment().subtract(7, 'hours');\n    await user.update({\n      lastCron: oldCron\n    });\n    await user.post(endpoint, {\n      dayStart: 1\n    });\n    await user.sync();\n    expect(user.lastCron.valueOf()).to.be.gt(oldCron.valueOf());\n  });","file":"api/v3/integration/user/POST-user_custom-day-start.test.js","skipped":false,"dir":"test"},{"name":"returns a confirmation message","suites":["POST /user/custom-day-start"],"updatePoint":{"line":28,"column":36,"index":906},"line":28,"code":"  it('returns a confirmation message', async () => {\n    const {\n      message\n    } = await user.post(endpoint, {\n      dayStart: 1\n    });\n    expect(message).to.eql(t('customDayStartHasChanged'));\n  });","file":"api/v3/integration/user/POST-user_custom-day-start.test.js","skipped":false,"dir":"test"},{"name":"errors if invalid value is passed","suites":["POST /user/custom-day-start"],"updatePoint":{"line":36,"column":39,"index":1115},"line":36,"code":"  it('errors if invalid value is passed', async () => {\n    await expect(user.post(endpoint, {\n      dayStart: 'foo'\n    })).to.eventually.be.rejected;\n    await expect(user.post(endpoint, {\n      dayStart: 24\n    })).to.eventually.be.rejected;\n  });","file":"api/v3/integration/user/POST-user_custom-day-start.test.js","skipped":false,"dir":"test"},{"name":"disable classes","suites":["POST /user/disable-classes"],"updatePoint":{"line":8,"column":21,"index":259},"line":8,"code":"  it('disable classes', async () => {\n    const res = await user.post('/user/disable-classes');\n    await user.sync();\n    expect(res).to.eql(JSON.parse(JSON.stringify({\n      preferences: user.preferences,\n      stats: user.stats,\n      flags: user.flags\n    })));\n  });","file":"api/v3/integration/user/POST-user_disable-classes.test.js","skipped":false,"dir":"test"},{"name":"equip an item","suites":["POST /user/equip/:type/:key"],"updatePoint":{"line":9,"column":19,"index":289},"line":9,"code":"  it('equip an item', async () => {\n    await user.update({\n      'items.gear.owned': {\n        weapon_warrior_0: true,\n        weapon_warrior_1: true,\n        weapon_warrior_2: true,\n        weapon_wizard_1: true,\n        weapon_wizard_2: true,\n        shield_base_0: true,\n        shield_warrior_1: true\n      },\n      'items.gear.equipped': {\n        weapon: 'weapon_warrior_0',\n        shield: 'shield_base_0'\n      },\n      'stats.gp': 200\n    });\n    await user.post('/user/equip/equipped/weapon_warrior_1');\n    const res = await user.post('/user/equip/equipped/weapon_warrior_2');\n    await user.sync();\n    expect(res).to.eql(JSON.parse(JSON.stringify(user.items)));\n  });","file":"api/v3/integration/user/POST-user_equip_type_key.test.js","skipped":false,"dir":"test"},{"name":"does not enjoy the food","suites":["POST /user/feed/:pet/:food"],"updatePoint":{"line":11,"column":29,"index":440},"line":11,"code":"  it('does not enjoy the food', async () => {\n    await user.update({\n      'items.pets.Wolf-Base': 5,\n      'items.food.Milk': 2\n    });\n    const food = content.food.Milk;\n    const pet = content.petInfo['Wolf-Base'];\n    const res = await user.post('/user/feed/Wolf-Base/Milk');\n    await user.sync();\n    expect(res).to.eql({\n      data: user.items.pets['Wolf-Base'],\n      message: t('messageDontEnjoyFood', {\n        egg: pet.text(),\n        foodText: food.textThe()\n      })\n    });\n    expect(user.items.food.Milk).to.equal(1);\n    expect(user.items.pets['Wolf-Base']).to.equal(7);\n  });","file":"api/v3/integration/user/POST-user_feed_pet_food.test.js","skipped":false,"dir":"test"},{"name":"bulk feeding pet with non-preferred food","suites":["POST /user/feed/:pet/:food"],"updatePoint":{"line":30,"column":46,"index":1053},"line":30,"code":"  it('bulk feeding pet with non-preferred food', async () => {\n    await user.update({\n      'items.pets.Wolf-Base': 5,\n      'items.food.Milk': 3\n    });\n    const food = content.food.Milk;\n    const pet = content.petInfo['Wolf-Base'];\n    const res = await user.post('/user/feed/Wolf-Base/Milk?amount=2');\n    await user.sync();\n    expect(res).to.eql({\n      data: user.items.pets['Wolf-Base'],\n      message: t('messageDontEnjoyFood', {\n        egg: pet.text(),\n        foodText: food.textThe()\n      })\n    });\n    expect(user.items.food.Milk).to.eql(1);\n    expect(user.items.pets['Wolf-Base']).to.equal(9);\n  });","file":"api/v3/integration/user/POST-user_feed_pet_food.test.js","skipped":false,"dir":"test"},{"name":"sends user activity webhook when a new mount is raised","suites":["POST /user/feed/:pet/:food","sending user activity webhooks"],"updatePoint":{"line":56,"column":62,"index":1862},"line":56,"code":"    it('sends user activity webhook when a new mount is raised', async () => {\n      const uuid = generateUUID();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'userActivity',\n        enabled: true,\n        options: {\n          mountRaised: true\n        }\n      });\n      await user.update({\n        'items.pets.Wolf-Base': 49,\n        'items.food.Milk': 2\n      });\n      const res = await user.post('/user/feed/Wolf-Base/Milk');\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(user.achievements.allYourBase).to.not.equal(true);\n      expect(body.type).to.eql('mountRaised');\n      expect(body.pet).to.eql('Wolf-Base');\n      expect(body.message).to.eql(res.message);\n    });","file":"api/v3/integration/user/POST-user_feed_pet_food.test.js","skipped":false,"dir":"test"},{"name":"sends user activity webhook (mount raised after full bulk feeding)","suites":["POST /user/feed/:pet/:food","sending user activity webhooks"],"updatePoint":{"line":78,"column":74,"index":2659},"line":78,"code":"    it('sends user activity webhook (mount raised after full bulk feeding)', async () => {\n      const uuid = generateUUID();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'userActivity',\n        enabled: true,\n        options: {\n          mountRaised: true\n        }\n      });\n      await user.update({\n        'items.pets.Wolf-Base': 47,\n        'items.food.Milk': 3\n      });\n      const res = await user.post('/user/feed/Wolf-Base/Milk?amount=2');\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(user.achievements.allYourBase).to.not.equal(true);\n      expect(body.type).to.eql('mountRaised');\n      expect(body.pet).to.eql('Wolf-Base');\n      expect(body.message).to.eql(res.message);\n    });","file":"api/v3/integration/user/POST-user_feed_pet_food.test.js","skipped":false,"dir":"test"},{"name":"hatch a new pet","suites":["POST /user/hatch/:egg/:hatchingPotion"],"updatePoint":{"line":9,"column":21,"index":344},"line":9,"code":"  it('hatch a new pet', async () => {\n    await user.update({\n      'items.eggs.Wolf': 1,\n      'items.hatchingPotions.Base': 1\n    });\n    const res = await user.post('/user/hatch/Wolf/Base');\n    await user.sync();\n    expect(user.items.pets['Wolf-Base']).to.equal(5);\n    expect(user.items.eggs.Wolf).to.equal(0);\n    expect(user.items.hatchingPotions.Base).to.equal(0);\n    expect(user.achievements.backToBasics).to.not.equal(true);\n    expect(res).to.eql({\n      message: t('messageHatched'),\n      data: JSON.parse(JSON.stringify(user.items))\n    });\n  });","file":"api/v3/integration/user/POST-user_hatch_egg_hatchingPotion.test.js","skipped":false,"dir":"test"},{"name":"sends user activity webhook when a new pet is hatched","suites":["POST /user/hatch/:egg/:hatchingPotion","sending user activity webhooks"],"updatePoint":{"line":32,"column":61,"index":1120},"line":32,"code":"    it('sends user activity webhook when a new pet is hatched', async () => {\n      const uuid = generateUUID();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'userActivity',\n        enabled: true,\n        options: {\n          petHatched: true\n        }\n      });\n      await user.update({\n        'items.eggs.Wolf': 1,\n        'items.hatchingPotions.Base': 1\n      });\n      const res = await user.post('/user/hatch/Wolf/Base');\n      await sleep();\n      const body = server.getWebhookData(uuid);\n      expect(body.type).to.eql('petHatched');\n      expect(body.pet).to.eql('Wolf-Base');\n      expect(body.message).to.eql(res.message);\n    });","file":"api/v3/integration/user/POST-user_hatch_egg_hatchingPotion.test.js","skipped":false,"dir":"test"},{"name":"marks user's private messages as read","suites":["POST /user/mark-pms-read"],"updatePoint":{"line":8,"column":44,"index":280},"line":8,"code":"  it('marks user\\'s private messages as read', async () => {\n    await user.update({\n      'inbox.newMessages': 1\n    });\n    await user.post('/user/mark-pms-read');\n    await user.sync();\n    expect(user.inbox.newMessages).to.equal(0);\n  });","file":"api/v3/integration/user/POST-user_mark_pms_read.test.js","skipped":false,"dir":"test"},{"name":"opens a mystery item","suites":["POST /user/open-mystery-item"],"updatePoint":{"line":21,"column":26,"index":804},"line":21,"code":"  it('opens a mystery item', async () => {\n    expect(user.notifications.length).to.equal(1);\n    const response = await user.post('/user/open-mystery-item');\n    await user.sync();\n    expect(user.notifications.length).to.equal(0);\n    expect(user.items.gear.owned[mysteryItemKey]).to.be.true;\n    expect(response.message).to.equal(t('mysteryItemOpened'));\n    expect(response.data.key).to.eql(mysteryItemKey);\n    expect(response.data.index).to.eql(mysteryItemIndex);\n    expect(response.data.type).to.eql(mysteryItemType);\n    expect(response.data.text).to.eql(mysteryItemText);\n  });","file":"api/v3/integration/user/POST-user_open_mystery_item.test.js","skipped":false,"dir":"test"},{"name":"buys an hourglass pet","suites":["POST /user/purchase-hourglass/:type/:key"],"updatePoint":{"line":10,"column":27,"index":349},"line":10,"code":"  it('buys an hourglass pet', async () => {\n    const response = await user.post('/user/purchase-hourglass/pets/MantisShrimp-Base');\n    await user.sync();\n    expect(response.message).to.eql(t('hourglassPurchase'));\n    expect(user.purchased.plan.consecutive.trinkets).to.eql(1);\n    expect(user.items.pets['MantisShrimp-Base']).to.eql(5);\n  });","file":"api/v3/integration/user/POST-user_purchase_hourglass.test.js","skipped":false,"dir":"test"},{"name":"buys an hourglass quest","suites":["POST /user/purchase-hourglass/:type/:key"],"updatePoint":{"line":17,"column":29,"index":698},"line":17,"code":"  it('buys an hourglass quest', async () => {\n    const response = await user.post('/user/purchase-hourglass/quests/robot');\n    await user.sync();\n    expect(response.message).to.eql(t('hourglassPurchase'));\n    expect(user.purchased.plan.consecutive.trinkets).to.eql(1);\n    expect(user.items.quests.robot).to.eql(1);\n  });","file":"api/v3/integration/user/POST-user_purchase_hourglass.test.js","skipped":false,"dir":"test"},{"name":"buys multiple hourglass quests","suites":["POST /user/purchase-hourglass/:type/:key"],"updatePoint":{"line":24,"column":36,"index":1031},"line":24,"code":"  it('buys multiple hourglass quests', async () => {\n    const response = await user.post('/user/purchase-hourglass/quests/robot', {\n      quantity: 2\n    });\n    await user.sync();\n    expect(response.message).to.eql(t('hourglassPurchase'));\n    expect(user.purchased.plan.consecutive.trinkets).to.eql(0);\n    expect(user.items.quests.robot).to.eql(2);\n  });","file":"api/v3/integration/user/POST-user_purchase_hourglass.test.js","skipped":false,"dir":"test"},{"name":"returns an error when key is not provided","suites":["POST /user/purchase/:type/:key"],"updatePoint":{"line":12,"column":47,"index":410},"line":12,"code":"  it('returns an error when key is not provided', async () => {\n    await expect(user.post('/user/purchase/gems/gem')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('mustSubscribeToPurchaseGems')\n    });\n  });","file":"api/v3/integration/user/POST-user_purchase.test.js","skipped":false,"dir":"test"},{"name":"purchases a gem item","suites":["POST /user/purchase/:type/:key"],"updatePoint":{"line":19,"column":26,"index":653},"line":19,"code":"  it('purchases a gem item', async () => {\n    await user.post(`/user/purchase/${type}/${key}`);\n    await user.sync();\n    expect(user.items[type][key]).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_purchase.test.js","skipped":false,"dir":"test"},{"name":"can convert gold to gems if subscribed","suites":["POST /user/purchase/:type/:key"],"updatePoint":{"line":24,"column":44,"index":844},"line":24,"code":"  it('can convert gold to gems if subscribed', async () => {\n    const oldBalance = user.balance;\n    await user.update({\n      'purchased.plan.customerId': 'group-plan',\n      'stats.gp': 1000\n    });\n    await user.post('/user/purchase/gems/gem');\n    await user.sync();\n    expect(user.balance).to.equal(oldBalance + 0.25);\n  });","file":"api/v3/integration/user/POST-user_purchase.test.js","skipped":false,"dir":"test"},{"name":"leader can convert gold to gems even if the group plan prevents it","suites":["POST /user/purchase/:type/:key"],"updatePoint":{"line":34,"column":72,"index":1205},"line":34,"code":"  it('leader can convert gold to gems even if the group plan prevents it', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        name: 'test',\n        type: 'guild',\n        privacy: 'private'\n      }\n    });\n    await group.update({\n      'leaderOnly.getGems': true,\n      'purchased.plan.customerId': 123\n    });\n    await groupLeader.sync();\n    const oldBalance = groupLeader.balance;\n    await groupLeader.update({\n      'purchased.plan.customerId': 'group-plan',\n      'stats.gp': 1000\n    });\n    await groupLeader.post('/user/purchase/gems/gem');\n    await groupLeader.sync();\n    expect(groupLeader.balance).to.equal(oldBalance + 0.25);\n  });","file":"api/v3/integration/user/POST-user_purchase.test.js","skipped":false,"dir":"test"},{"name":"cannot convert gold to gems if the group plan prevents it","suites":["POST /user/purchase/:type/:key"],"updatePoint":{"line":59,"column":63,"index":1920},"line":59,"code":"  it('cannot convert gold to gems if the group plan prevents it', async () => {\n    const {\n      group,\n      members\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        name: 'test',\n        type: 'guild',\n        privacy: 'private'\n      },\n      members: 1\n    });\n    await group.update({\n      'leaderOnly.getGems': true,\n      'purchased.plan.customerId': 123\n    });\n    const oldBalance = members[0].balance;\n    await members[0].update({\n      'purchased.plan.customerId': 'group-plan',\n      'stats.gp': 1000\n    });\n    await expect(members[0].post('/user/purchase/gems/gem')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('groupPolicyCannotGetGems')\n    });\n    await members[0].sync();\n    expect(members[0].balance).to.equal(oldBalance);\n  });","file":"api/v3/integration/user/POST-user_purchase.test.js","skipped":false,"dir":"test"},{"name":"purchases a gem item","suites":["POST /user/purchase/:type/:key","bulk purchasing"],"updatePoint":{"line":89,"column":28,"index":2753},"line":89,"code":"    it('purchases a gem item', async () => {\n      await user.post(`/user/purchase/${type}/${key}`, {\n        quantity: 2\n      });\n      await user.sync();\n      expect(user.items[type][key]).to.equal(2);\n    });","file":"api/v3/integration/user/POST-user_purchase.test.js","skipped":false,"dir":"test"},{"name":"can convert gold to gems if subscribed","suites":["POST /user/purchase/:type/:key","bulk purchasing"],"updatePoint":{"line":96,"column":46,"index":2985},"line":96,"code":"    it('can convert gold to gems if subscribed', async () => {\n      const oldBalance = user.balance;\n      await user.update({\n        'purchased.plan.customerId': 'group-plan',\n        'stats.gp': 1000\n      });\n      await user.post('/user/purchase/gems/gem', {\n        quantity: 2\n      });\n      await user.sync();\n      expect(user.balance).to.equal(oldBalance + 0.50);\n    });","file":"api/v3/integration/user/POST-user_purchase.test.js","skipped":false,"dir":"test"},{"name":"returns an error when regId is not provided","suites":["POST /user/push-devices"],"updatePoint":{"line":9,"column":49,"index":303},"line":9,"code":"  it('returns an error when regId is not provided', async () => {\n    await expect(user.post('/user/push-devices'), {\n      type\n    }).to.eventually.be.rejected.and.to.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/user/POST-user_push_device.test.js","skipped":false,"dir":"test"},{"name":"returns an error when type is not provided","suites":["POST /user/push-devices"],"updatePoint":{"line":18,"column":48,"index":580},"line":18,"code":"  it('returns an error when type is not provided', async () => {\n    await expect(user.post('/user/push-devices', {\n      regId\n    })).to.eventually.be.rejected.and.to.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/user/POST-user_push_device.test.js","skipped":false,"dir":"test"},{"name":"returns an error when type is not valid","suites":["POST /user/push-devices"],"updatePoint":{"line":27,"column":45,"index":855},"line":27,"code":"  it('returns an error when type is not valid', async () => {\n    await expect(user.post('/user/push-devices', {\n      regId,\n      type: 'invalid'\n    })).to.eventually.be.rejected.and.to.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v3/integration/user/POST-user_push_device.test.js","skipped":false,"dir":"test"},{"name":"fails silently if user already has the push device","suites":["POST /user/push-devices"],"updatePoint":{"line":37,"column":56,"index":1164},"line":37,"code":"  it('fails silently if user already has the push device', async () => {\n    await user.post('/user/push-devices', {\n      type,\n      regId\n    });\n    const response = await user.post('/user/push-devices', {\n      type,\n      regId\n    });\n    await user.sync();\n    expect(response.message).to.equal(t('pushDeviceAdded'));\n    expect(response.data[0].type).to.equal(type);\n    expect(response.data[0].regId).to.equal(regId);\n    expect(user.pushDevices[0].type).to.equal(type);\n    expect(user.pushDevices[0].regId).to.equal(regId);\n  });","file":"api/v3/integration/user/POST-user_push_device.test.js","skipped":false,"dir":"test"},{"name":"adds a push device to the user","suites":["POST /user/push-devices"],"updatePoint":{"line":53,"column":36,"index":1686},"line":53,"code":"  it('adds a push device to the user', async () => {\n    const response = await user.post('/user/push-devices', {\n      type,\n      regId\n    });\n    await user.sync();\n    expect(response.message).to.equal(t('pushDeviceAdded'));\n    expect(response.data[0].type).to.equal(type);\n    expect(response.data[0].regId).to.equal(regId);\n    expect(user.pushDevices[0].type).to.equal(type);\n    expect(user.pushDevices[0].regId).to.equal(regId);\n  });","file":"api/v3/integration/user/POST-user_push_device.test.js","skipped":false,"dir":"test"},{"name":"returns an error when unknown cardType is provded","suites":["POST /user/read-card/:cardType"],"updatePoint":{"line":8,"column":55,"index":303},"line":8,"code":"  it('returns an error when unknown cardType is provded', async () => {\n    await expect(user.post('/user/read-card/randomCardType')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('cardTypeNotAllowed')\n    });\n  }); // More tests in common code unit tests","file":"api/v3/integration/user/POST-user_read_card.test.js","skipped":false,"dir":"test"},{"name":"reads a card","suites":["POST /user/read-card/:cardType"],"updatePoint":{"line":16,"column":18,"index":580},"line":16,"code":"  it('reads a card', async () => {\n    await user.update({\n      'items.special.greetingReceived': [true],\n      'flags.cardReceived': true,\n      notifications: [{\n        type: 'CARD_RECEIVED',\n        data: {\n          card: cardType\n        }\n      }]\n    });\n    await user.sync();\n    expect(user.notifications.length).to.equal(1);\n    const response = await user.post(`/user/read-card/${cardType}`);\n    await user.sync();\n    expect(response.message).to.equal(t('readCard', {\n      cardType\n    }));\n    expect(user.items.special[`${cardType}Received`]).to.be.empty;\n    expect(user.flags.cardReceived).to.be.false;\n    expect(user.notifications.length).to.equal(0);\n  });","file":"api/v3/integration/user/POST-user_read_card.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user balance is too low","suites":["POST /user/rebirth"],"updatePoint":{"line":7,"column":51,"index":287},"line":7,"code":"  it('returns an error when user balance is too low', async () => {\n    await expect(user.post('/user/rebirth')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughGems')\n    });\n  }); // More tests in common code unit tests","file":"api/v3/integration/user/POST-user_rebirth.test.js","skipped":false,"dir":"test"},{"name":"resets user's tasks","suites":["POST /user/rebirth"],"updatePoint":{"line":15,"column":26,"index":550},"line":15,"code":"  it('resets user\\'s tasks', async () => {\n    await user.update({\n      balance: 1.5\n    });\n    const daily = await generateDaily({\n      text: 'test habit',\n      type: 'daily',\n      value: 1,\n      streak: 1,\n      userId: user._id\n    });\n    const reward = await generateReward({\n      text: 'test reward',\n      type: 'reward',\n      value: 1,\n      userId: user._id\n    });\n    const response = await user.post('/user/rebirth');\n    await user.sync();\n    expect(user.notifications.length).to.equal(1);\n    expect(user.notifications[0].type).to.equal('REBIRTH_ACHIEVEMENT');\n    const updatedDaily = await user.get(`/tasks/${daily._id}`);\n    const updatedReward = await user.get(`/tasks/${reward._id}`);\n    expect(response.message).to.equal(t('rebirthComplete'));\n    expect(updatedDaily.streak).to.equal(0);\n    expect(updatedDaily.value).to.equal(0);\n    expect(updatedReward.value).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_rebirth.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user balance is too low and user does not have triadBingo","suites":["POST /user/release-both"],"updatePoint":{"line":35,"column":86,"index":1004},"line":35,"code":"  xit('returns an error when user balance is too low and user does not have triadBingo', async () => {\n    await expect(user.post('/user/release-both')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughGems')\n    });\n  }); // More tests in common code unit tests","skipped":true,"file":"api/v3/integration/user/POST-user_release_both.test.js","dir":"test"},{"name":"grants triad bingo with gems","suites":["POST /user/release-both"],"updatePoint":{"line":43,"column":34,"index":1280},"line":43,"code":"  it('grants triad bingo with gems', async () => {\n    await user.update();\n    const response = await user.post('/user/release-both');\n    await user.sync();\n    expect(response.message).to.equal(t('mountsAndPetsReleased'));\n    expect(user.balance).to.equal(0);\n    expect(user.items.currentMount).to.equal('');\n    expect(user.items.currentPet).to.equal('');\n    expect(user.items.pets[animal]).to.equal(0);\n    expect(user.items.mounts[animal]).to.equal(null);\n    expect(user.achievements.beastMasterCount).to.equal(1);\n    expect(user.achievements.mountMasterCount).to.equal(1);\n    expect(user.achievements.triadBingoCount).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_release_both.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user balance is too low","suites":["POST /user/release-mounts"],"updatePoint":{"line":22,"column":51,"index":635},"line":22,"code":"  it('returns an error when user balance is too low', async () => {\n    await expect(user.post('/user/release-mounts')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughGems')\n    });\n  }); // More tests in common code unit tests","file":"api/v3/integration/user/POST-user_release_mounts.test.js","skipped":false,"dir":"test"},{"name":"releases mounts","suites":["POST /user/release-mounts"],"updatePoint":{"line":30,"column":21,"index":900},"line":30,"code":"  it('releases mounts', async () => {\n    await user.update({\n      balance: 1\n    });\n    const response = await user.post('/user/release-mounts');\n    await user.sync();\n    expect(response.message).to.equal(t('mountsReleased'));\n    expect(user.balance).to.equal(0);\n    expect(user.items.currentMount).to.be.empty;\n    expect(user.items.mounts[animal]).to.equal(null);\n    expect(user.achievements.mountMasterCount).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_release_mounts.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user balance is too low","suites":["POST /user/release-pets"],"updatePoint":{"line":22,"column":51,"index":614},"line":22,"code":"  it('returns an error when user balance is too low', async () => {\n    await expect(user.post('/user/release-pets')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughGems')\n    });\n  }); // More tests in common code unit tests","file":"api/v3/integration/user/POST-user_release_pets.test.js","skipped":false,"dir":"test"},{"name":"releases pets","suites":["POST /user/release-pets"],"updatePoint":{"line":30,"column":19,"index":875},"line":30,"code":"  it('releases pets', async () => {\n    await user.update({\n      balance: 1\n    });\n    const response = await user.post('/user/release-pets');\n    await user.sync();\n    expect(response.message).to.equal(t('petsReleased'));\n    expect(user.balance).to.equal(0);\n    expect(user.items.currentPet).to.be.empty;\n    expect(user.items.pets[animal]).to.equal(0);\n    expect(user.achievements.beastMasterCount).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_release_pets.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user balance is too low","suites":["POST /user/reroll"],"updatePoint":{"line":7,"column":51,"index":286},"line":7,"code":"  it('returns an error when user balance is too low', async () => {\n    await expect(user.post('/user/reroll')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughGems')\n    });\n  }); // More tests in common code unit tests","file":"api/v3/integration/user/POST-user_reroll.test.js","skipped":false,"dir":"test"},{"name":"resets user's tasks","suites":["POST /user/reroll"],"updatePoint":{"line":15,"column":26,"index":548},"line":15,"code":"  it('resets user\\'s tasks', async () => {\n    await user.update({\n      balance: 2\n    });\n    const daily = await generateDaily({\n      text: 'test habit',\n      type: 'daily',\n      userId: user._id\n    });\n    const reward = await generateReward({\n      text: 'test reward',\n      type: 'reward',\n      value: 1,\n      userId: user._id\n    });\n    const response = await user.post('/user/reroll');\n    await user.sync();\n    const updatedDaily = await user.get(`/tasks/${daily._id}`);\n    const updatedReward = await user.get(`/tasks/${reward._id}`);\n    expect(response.message).to.equal(t('fortifyComplete'));\n    expect(updatedDaily.value).to.equal(0);\n    expect(updatedReward.value).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_reroll.test.js","skipped":false,"dir":"test"},{"name":"resets user's habits","suites":["POST /user/reset"],"updatePoint":{"line":9,"column":27,"index":336},"line":9,"code":"  it('resets user\\'s habits', async () => {\n    const task = await user.post('/tasks/user', {\n      text: 'test habit',\n      type: 'habit'\n    });\n    await user.post('/user/reset');\n    await user.sync();\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n    expect(user.tasksOrder.habits).to.be.empty;\n  });","file":"api/v3/integration/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"resets user's dailys","suites":["POST /user/reset"],"updatePoint":{"line":23,"column":27,"index":772},"line":23,"code":"  it('resets user\\'s dailys', async () => {\n    const task = await user.post('/tasks/user', {\n      text: 'test daily',\n      type: 'daily'\n    });\n    await user.post('/user/reset');\n    await user.sync();\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n    expect(user.tasksOrder.dailys).to.be.empty;\n  });","file":"api/v3/integration/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"resets user's todos","suites":["POST /user/reset"],"updatePoint":{"line":37,"column":26,"index":1207},"line":37,"code":"  it('resets user\\'s todos', async () => {\n    const task = await user.post('/tasks/user', {\n      text: 'test todo',\n      type: 'todo'\n    });\n    await user.post('/user/reset');\n    await user.sync();\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n    expect(user.tasksOrder.todos).to.be.empty;\n  });","file":"api/v3/integration/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"resets user's rewards","suites":["POST /user/reset"],"updatePoint":{"line":51,"column":28,"index":1641},"line":51,"code":"  it('resets user\\'s rewards', async () => {\n    const task = await user.post('/tasks/user', {\n      text: 'test reward',\n      type: 'reward'\n    });\n    await user.post('/user/reset');\n    await user.sync();\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n    expect(user.tasksOrder.rewards).to.be.empty;\n  });","file":"api/v3/integration/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"does not delete challenge or group tasks","suites":["POST /user/reset"],"updatePoint":{"line":65,"column":46,"index":2099},"line":65,"code":"  it('does not delete challenge or group tasks', async () => {\n    const guild = await generateGroup(user);\n    const challenge = await generateChallenge(user, guild);\n    await user.post(`/challenges/${challenge._id}/join`);\n    await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test challenge habit',\n      type: 'habit'\n    });\n    const groupTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'todo group',\n      type: 'todo'\n    });\n    await user.post(`/tasks/${groupTask._id}/assign/${user._id}`);\n    await user.post('/user/reset');\n    await user.sync();\n    const memberTasks = await user.get('/tasks/user');\n    const syncedGroupTask = find(memberTasks, memberTask => memberTask.group.id === guild._id);\n    const userChallengeTask = find(memberTasks, memberTask => memberTask.challenge.id === challenge._id);\n    expect(userChallengeTask).to.exist;\n    expect(syncedGroupTask).to.exist;\n  });","file":"api/v3/integration/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"does not delete secret","suites":["POST /user/reset"],"updatePoint":{"line":86,"column":28,"index":3019},"line":86,"code":"  it('does not delete secret', async () => {\n    const admin = await generateUser({\n      contributor: {\n        admin: true\n      }\n    });\n    const hero = await generateUser({\n      contributor: {\n        level: 1\n      },\n      secret: {\n        text: 'Super-Hero'\n      }\n    });\n    await hero.post('/user/reset');\n    const heroRes = await admin.get(`/hall/heroes/${hero.auth.local.username}`);\n    expect(heroRes.secret).to.exist;\n    expect(heroRes.secret.text).to.be.eq('Super-Hero');\n  });","file":"api/v3/integration/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user is not dead","suites":["POST /user/revive"],"updatePoint":{"line":11,"column":44,"index":320},"line":11,"code":"  it('returns an error when user is not dead', async () => {\n    await expect(user.post('/user/revive')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('cannotRevive')\n    });\n  }); // More tests in common code unit tests","file":"api/v3/integration/user/POST-user_revive.test.js","skipped":false,"dir":"test"},{"name":"decreases a stat","suites":["POST /user/revive"],"updatePoint":{"line":19,"column":22,"index":577},"line":19,"code":"  it('decreases a stat', async () => {\n    await user.update({\n      'stats.str': 2,\n      'stats.hp': 0\n    });\n    await user.post('/user/revive');\n    await user.sync();\n    expect(user.stats.str).to.equal(1);\n  });","file":"api/v3/integration/user/POST-user_revive.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user does not have item","suites":["POST /user/sell/:type/:key"],"updatePoint":{"line":11,"column":51,"index":418},"line":11,"code":"  it('returns an error when user does not have item', async () => {\n    await expect(user.post(`/user/sell/${type}/${key}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userItemsKeyNotFound', {\n        type\n      })\n    });\n  });","file":"api/v3/integration/user/POST-user_sell.test.js","skipped":false,"dir":"test"},{"name":"sells an item","suites":["POST /user/sell/:type/:key"],"updatePoint":{"line":20,"column":19,"index":668},"line":20,"code":"  it('sells an item', async () => {\n    await user.update({\n      items: {\n        eggs: {\n          Wolf: 1\n        }\n      }\n    });\n    await user.post(`/user/sell/${type}/${key}`);\n    await user.sync();\n    expect(user.stats.gp).to.equal(content[type][key].value);\n  });","file":"api/v3/integration/user/POST-user_sell.test.js","skipped":false,"dir":"test"},{"name":"toggles sleep status","suites":["POST /user/sleep"],"updatePoint":{"line":9,"column":26,"index":359},"line":9,"code":"  it('toggles sleep status', async () => {\n    const res = await user.post('/user/sleep');\n    expect(res).to.eql(true);\n    await user.sync();\n    expect(user.preferences.sleep).to.be.true;\n    const res2 = await user.post('/user/sleep');\n    expect(res2).to.eql(false);\n    await user.sync();\n    expect(user.preferences.sleep).to.be.false;\n  });","file":"api/v3/integration/user/POST-user_sleep.test.js","skipped":false,"dir":"test"},{"name":"sends sleep status to analytics service","suites":["POST /user/sleep"],"updatePoint":{"line":19,"column":45,"index":727},"line":19,"code":"  it('sends sleep status to analytics service', async () => {\n    sandbox.spy(analytics, 'track');\n    await user.post('/user/sleep');\n    await user.sync();\n    expect(analytics.track).to.be.calledOnce;\n    expect(analytics.track).to.be.calledWith('sleep', sandbox.match.has('status', user.preferences.sleep));\n    sandbox.restore();\n  });","file":"api/v3/integration/user/POST-user_sleep.test.js","skipped":false,"dir":"test"},{"name":"updates the user","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":10,"column":24,"index":379},"line":10,"code":"    it('updates the user', async () => {\n      await user.put('/user', {\n        'profile.name': 'Frodo',\n        'preferences.costume': true,\n        'stats.hp': 14\n      });\n      await user.sync();\n      expect(user.profile.name).to.eql('Frodo');\n      expect(user.preferences.costume).to.eql(true);\n      expect(user.stats.hp).to.eql(14);\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"tags must be an array","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":21,"column":29,"index":735},"line":21,"code":"    it('tags must be an array', async () => {\n      await expect(user.put('/user', {\n        tags: {\n          tag: true\n        }\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'mustBeArray'\n      });\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"update tags","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":32,"column":19,"index":999},"line":32,"code":"    it('update tags', async () => {\n      const userTags = user.tags;\n      await user.put('/user', {\n        tags: [...user.tags, {\n          name: 'new tag'\n        }]\n      });\n      await user.sync();\n      expect(user.tags.length).to.be.eql(userTags.length + 1);\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"validates profile.name","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":42,"column":30,"index":1286},"line":42,"code":"    it('validates profile.name', async () => {\n      await expect(user.put('/user', {\n        'profile.name': ' ' // string should be trimmed\n\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n      await expect(user.put('/user', {\n        'profile.name': ''\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n      await expect(user.put('/user', {\n        'profile.name': null\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n      await expect(user.put('/user', {\n        'profile.name': 'this is a very long display name that will not be allowed due to length'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('displaynameIssueLength')\n      });\n      await expect(user.put('/user', {\n        'profile.name': 'TESTPLACEHOLDERSLURWORDHERE'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('bannedSlurUsedInProfile')\n      });\n      await expect(user.put('/user', {\n        'profile.name': 'TESTPLACEHOLDERSWEARWORDHERE'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('bannedWordUsedInProfile')\n      });\n      await expect(user.put('/user', {\n        'profile.name': 'namecontainsnewline\\n'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('displaynameIssueNewline')\n      });\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"can set flags.newStuff to false","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":94,"column":39,"index":3025},"line":94,"code":"    it('can set flags.newStuff to false', async () => {\n      NewsPost.updateLastNewsPost({\n        _id: '1234',\n        publishDate: new Date(),\n        title: 'Title',\n        published: true\n      });\n      await user.update({\n        'flags.lastNewStuffRead': '123'\n      });\n      await user.put('/user', {\n        'flags.newStuff': false\n      });\n      await user.sync();\n      expect(user.flags.lastNewStuffRead).to.eql('1234');\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"does not allow updating ","suites":["PUT /user","Top Level Protected Operations"],"updatePoint":{"line":152,"column":45,"index":4485},"line":152,"code":"      it(`does not allow updating ${testName}`, async () => {\n        const errorText = t('messageUserOperationProtected', {\n          operation: Object.keys(data)[0]\n        });\n        await expect(user.put('/user', data)).to.eventually.be.rejected.and.eql({\n          code: 401,\n          error: 'NotAuthorized',\n          message: errorText\n        });\n      });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"does not allow updating ","suites":["PUT /user","Sub-Level Protected Operations"],"updatePoint":{"line":188,"column":45,"index":5443},"line":188,"code":"      it(`does not allow updating ${testName}`, async () => {\n        const errorText = t('messageUserOperationProtected', {\n          operation: Object.keys(data)[0]\n        });\n        await expect(user.put('/user', data)).to.eventually.be.rejected.and.eql({\n          code: 401,\n          error: 'NotAuthorized',\n          message: errorText\n        });\n      });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"updates user with  that is a default","suites":["PUT /user","Default Appearance Preferences"],"updatePoint":{"line":213,"column":53,"index":6185},"line":213,"code":"      it(`updates user with ${type} that is a default`, async () => {\n        const dbUpdate = {};\n        dbUpdate[`purchased.${type}.${item}`] = true;\n        await user.update(dbUpdate); // Sanity checks to make sure user is not already equipped with item\n\n        expect(get(user.preferences, type)).to.not.eql(item);\n        const updatedUser = await user.put('/user', update);\n        expect(get(updatedUser.preferences, type)).to.eql(item);\n      });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user tries to update body size with invalid type","suites":["PUT /user","Default Appearance Preferences"],"updatePoint":{"line":223,"column":76,"index":6674},"line":223,"code":"    it('returns an error if user tries to update body size with invalid type', async () => {\n      await expect(user.put('/user', {\n        'preferences.size': 'round'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('mustPurchaseToSet', {\n          val: 'round',\n          key: 'preferences.size'\n        })\n      });\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"can set beard to default","suites":["PUT /user","Default Appearance Preferences"],"updatePoint":{"line":235,"column":32,"index":7024},"line":235,"code":"    it('can set beard to default', async () => {\n      await user.update({\n        'purchased.hair.beard': 3,\n        'preferences.hair.beard': 3\n      });\n      const updatedUser = await user.put('/user', {\n        'preferences.hair.beard': 0\n      });\n      expect(updatedUser.preferences.hair.beard).to.eql(0);\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"can set mustache to default","suites":["PUT /user","Default Appearance Preferences"],"updatePoint":{"line":245,"column":35,"index":7349},"line":245,"code":"    it('can set mustache to default', async () => {\n      await user.update({\n        'purchased.hair.mustache': 2,\n        'preferences.hair.mustache': 2\n      });\n      const updatedUser = await user.put('/user', {\n        'preferences.hair.mustache': 0\n      });\n      expect(updatedUser.preferences.hair.mustache).to.eql(0);\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user tries to update  with  the user does not own","suites":["PUT /user","Purchasable Appearance Preferences"],"updatePoint":{"line":269,"column":93,"index":8120},"line":269,"code":"      it(`returns an error if user tries to update ${type} with ${type} the user does not own`, async () => {\n        await expect(user.put('/user', update)).to.eventually.be.rejected.and.eql({\n          code: 401,\n          error: 'NotAuthorized',\n          message: t('mustPurchaseToSet', {\n            val: item,\n            key: `preferences.${type}`\n          })\n        });\n      });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"updates user with  user does own","suites":["PUT /user","Purchasable Appearance Preferences"],"updatePoint":{"line":279,"column":49,"index":8466},"line":279,"code":"      it(`updates user with ${type} user does own`, async () => {\n        const dbUpdate = {};\n        dbUpdate[`purchased.${type}.${item}`] = true;\n        await user.update(dbUpdate); // Sanity check to make sure user is not already equipped with item\n\n        expect(get(user.preferences, type)).to.not.eql(item);\n        const updatedUser = await user.put('/user', update);\n        expect(get(updatedUser.preferences, type)).to.eql(item);\n      });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"sets valid categories","suites":["PUT /user","Improvement Categories"],"updatePoint":{"line":291,"column":29,"index":8957},"line":291,"code":"    it('sets valid categories', async () => {\n      await user.put('/user', {\n        'preferences.improvementCategories': ['work', 'school']\n      });\n      await user.sync();\n      expect(user.preferences.improvementCategories).to.eql(['work', 'school']);\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"discards invalid categories","suites":["PUT /user","Improvement Categories"],"updatePoint":{"line":298,"column":35,"index":9229},"line":298,"code":"    it('discards invalid categories', async () => {\n      await expect(user.put('/user', {\n        'preferences.improvementCategories': ['work', 'procrastination', 'school']\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n    });","file":"api/v3/integration/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user does not have enough points","suites":["POST /user/allocate-bulk"],"updatePoint":{"line":18,"column":58,"index":495},"line":18,"code":"  it('returns an error if user does not have enough points', async () => {\n    await expect(user.post('/user/allocate-bulk', statsUpdate)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughAttrPoints')\n    });\n  });","file":"api/v3/integration/user/stats/POST-user_allocate_bulk.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user has not selected class","suites":["POST /user/allocate-bulk"],"updatePoint":{"line":25,"column":53,"index":766},"line":25,"code":"  it('returns an error if user has not selected class', async () => {\n    await user.update({\n      'flags.classSelected': false\n    });\n    await expect(user.post('/user/allocate-bulk', statsUpdate)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('classNotSelected')\n    });\n  });","file":"api/v3/integration/user/stats/POST-user_allocate_bulk.test.js","skipped":false,"dir":"test"},{"name":"allocates attribute points","suites":["POST /user/allocate-bulk"],"updatePoint":{"line":35,"column":32,"index":1080},"line":35,"code":"  it('allocates attribute points', async () => {\n    await user.update({\n      'stats.points': 3\n    });\n    await user.post('/user/allocate-bulk', statsUpdate);\n    await user.sync();\n    expect(user.stats.con).to.equal(1);\n    expect(user.stats.str).to.equal(2);\n    expect(user.stats.points).to.equal(0);\n  });","file":"api/v3/integration/user/stats/POST-user_allocate_bulk.test.js","skipped":false,"dir":"test"},{"name":"auto allocates all points","suites":["POST /user/allocate-now"],"updatePoint":{"line":4,"column":31,"index":192},"line":4,"code":"  it('auto allocates all points', async () => {\n    const user = await generateUser({\n      'stats.points': 5,\n      'stats.int': 3,\n      'stats.con': 9,\n      'stats.per': 9,\n      'stats.str': 9,\n      'preferences.allocationMode': 'flat'\n    });\n    const res = await user.post('/user/allocate-now');\n    await user.sync();\n    expect(res).to.eql(user.stats);\n    expect(user.stats.points).to.equal(0);\n    expect(user.stats.con).to.equal(9);\n    expect(user.stats.int).to.equal(8);\n    expect(user.stats.per).to.equal(9);\n    expect(user.stats.str).to.equal(9);\n  });","file":"api/v3/integration/user/stats/POST-user_allocate_now.test.js","skipped":false,"dir":"test"},{"name":"returns an error if an invalid attribute is supplied","suites":["POST /user/allocate"],"updatePoint":{"line":13,"column":58,"index":486},"line":13,"code":"  it('returns an error if an invalid attribute is supplied', async () => {\n    await expect(user.post('/user/allocate?stat=invalid')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: apiError('invalidAttribute', {\n        attr: 'invalid'\n      })\n    });\n  });","file":"api/v3/integration/user/stats/POST-user_allocate.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the user doesn't have attribute points","suites":["POST /user/allocate"],"updatePoint":{"line":22,"column":65,"index":800},"line":22,"code":"  it('returns an error if the user doesn\\'t have attribute points', async () => {\n    await expect(user.post('/user/allocate')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughAttrPoints')\n    });\n  });","file":"api/v3/integration/user/stats/POST-user_allocate.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the user hasn't selected class","suites":["POST /user/allocate"],"updatePoint":{"line":29,"column":57,"index":1057},"line":29,"code":"  it('returns an error if the user hasn\\'t selected class', async () => {\n    await user.update({\n      'flags.classSelected': false\n    });\n    await expect(user.post('/user/allocate')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('classNotSelected')\n    });\n  });","file":"api/v3/integration/user/stats/POST-user_allocate.test.js","skipped":false,"dir":"test"},{"name":"allocates attribute points","suites":["POST /user/allocate"],"updatePoint":{"line":39,"column":32,"index":1353},"line":39,"code":"  it('allocates attribute points', async () => {\n    await user.update({\n      'stats.points': 1\n    });\n    const res = await user.post('/user/allocate?stat=con');\n    await user.sync();\n    expect(user.stats.con).to.equal(1);\n    expect(user.stats.points).to.equal(0);\n    expect(res.con).to.equal(1);\n  });","file":"api/v3/integration/user/stats/POST-user_allocate.test.js","skipped":false,"dir":"test"},{"name":"deletes a webhook","suites":["DELETE /user/webhook"],"updatePoint":{"line":18,"column":23,"index":533},"line":18,"code":"  it('deletes a webhook', async () => {\n    expect(user.webhooks).to.have.a.lengthOf(2);\n    await user.del(`${endpoint}/${webhookToDelete.id}`);\n    await user.sync();\n    expect(user.webhooks).to.have.a.lengthOf(1);\n  });","file":"api/v3/integration/webhook/DELETE-user_delete_webhook.test.js","skipped":false,"dir":"test"},{"name":"returns the remaining webhooks","suites":["DELETE /user/webhook"],"updatePoint":{"line":24,"column":36,"index":770},"line":24,"code":"  it('returns the remaining webhooks', async () => {\n    const [remainingWebhook] = await user.del(`${endpoint}/${webhookToDelete.id}`);\n    await user.sync();\n    const webhook = user.webhooks[0];\n    expect(remainingWebhook.id).to.eql(webhook.id);\n    expect(remainingWebhook.url).to.eql(webhook.url);\n    expect(remainingWebhook.type).to.eql(webhook.type);\n    expect(remainingWebhook.options).to.eql(webhook.options);\n  });","file":"api/v3/integration/webhook/DELETE-user_delete_webhook.test.js","skipped":false,"dir":"test"},{"name":"returns an error if webhook with id does not exist","suites":["DELETE /user/webhook"],"updatePoint":{"line":33,"column":56,"index":1218},"line":33,"code":"  it('returns an error if webhook with id does not exist', async () => {\n    await expect(user.del(`${endpoint}/id-that-does-not-exist`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('noWebhookWithId', {\n        id: 'id-that-does-not-exist'\n      })\n    });\n  });","file":"api/v3/integration/webhook/DELETE-user_delete_webhook.test.js","skipped":false,"dir":"test"},{"name":"returns users webhooks","suites":["GET /user/webhook"],"updatePoint":{"line":22,"column":28,"index":568},"line":22,"code":"  it('returns users webhooks', async () => {\n    const response = await user.get('/user/webhook');\n    expect(response).to.eql(user.webhooks.map(w => {\n      w.createdAt = w.createdAt.toISOString();\n      w.updatedAt = w.updatedAt.toISOString();\n      return w;\n    }));\n  });","file":"api/v3/integration/webhook/GET-user-webhook.test.js","skipped":false,"dir":"test"},{"name":"requires a url","suites":["POST /user/webhook"],"updatePoint":{"line":16,"column":20,"index":486},"line":16,"code":"  it('requires a url', async () => {\n    delete body.url;\n    await expect(user.post('/user/webhook', body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'User validation failed'\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"requires custom id to be a uuid","suites":["POST /user/webhook"],"updatePoint":{"line":24,"column":37,"index":746},"line":24,"code":"  it('requires custom id to be a uuid', async () => {\n    body.id = 'not-a-uuid';\n    await expect(user.post('/user/webhook', body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'User validation failed'\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"defaults id to a uuid","suites":["POST /user/webhook"],"updatePoint":{"line":32,"column":27,"index":1003},"line":32,"code":"  it('defaults id to a uuid', async () => {\n    delete body.id;\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.id).to.exist;\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"requires type to be of an accetable type","suites":["POST /user/webhook"],"updatePoint":{"line":37,"column":46,"index":1185},"line":37,"code":"  it('requires type to be of an accetable type', async () => {\n    body.type = 'not a valid type';\n    await expect(user.post('/user/webhook', body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'User validation failed'\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"defaults enabled to true","suites":["POST /user/webhook"],"updatePoint":{"line":45,"column":30,"index":1453},"line":45,"code":"  it('defaults enabled to true', async () => {\n    delete body.enabled;\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.enabled).to.be.true;\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"can pass a label","suites":["POST /user/webhook"],"updatePoint":{"line":50,"column":22,"index":1623},"line":50,"code":"  it('can pass a label', async () => {\n    body.label = 'Custom Label';\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.label).to.equal('Custom Label');\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"defaults type to taskActivity","suites":["POST /user/webhook"],"updatePoint":{"line":55,"column":35,"index":1826},"line":55,"code":"  it('defaults type to taskActivity', async () => {\n    delete body.type;\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.type).to.eql('taskActivity');\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"ignores protected fields","suites":["POST /user/webhook"],"updatePoint":{"line":60,"column":30,"index":2010},"line":60,"code":"  it('ignores protected fields', async () => {\n    body.failures = 3;\n    body.lastFailureAt = new Date();\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.failures).to.eql(0);\n    expect(webhook.lastFailureAt).to.eql(undefined);\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"successfully adds the webhook","suites":["POST /user/webhook"],"updatePoint":{"line":67,"column":35,"index":2281},"line":67,"code":"  it('successfully adds the webhook', async () => {\n    expect(user.webhooks).to.eql([]);\n    const response = await user.post('/user/webhook', body);\n    expect(response.id).to.eql(body.id);\n    expect(response.type).to.eql(body.type);\n    expect(response.url).to.eql(body.url);\n    expect(response.enabled).to.eql(body.enabled);\n    await user.sync();\n    expect(user.webhooks).to.not.eql([]);\n    const webhook = user.webhooks[0];\n    expect(webhook.enabled).to.be.false;\n    expect(webhook.type).to.eql('taskActivity');\n    expect(webhook.url).to.eql(body.url);\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"cannot use an id of a webhook that already exists","suites":["POST /user/webhook"],"updatePoint":{"line":81,"column":55,"index":2873},"line":81,"code":"  it('cannot use an id of a webhook that already exists', async () => {\n    await user.post('/user/webhook', body);\n    await expect(user.post('/user/webhook', body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('webhookIdAlreadyTaken', {\n        id: body.id\n      })\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"defaults taskActivity options","suites":["POST /user/webhook"],"updatePoint":{"line":91,"column":35,"index":3187},"line":91,"code":"  it('defaults taskActivity options', async () => {\n    body.type = 'taskActivity';\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options).to.eql({\n      checklistScored: false,\n      created: false,\n      updated: false,\n      deleted: false,\n      scored: true\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"can set taskActivity options","suites":["POST /user/webhook"],"updatePoint":{"line":102,"column":34,"index":3496},"line":102,"code":"  it('can set taskActivity options', async () => {\n    body.type = 'taskActivity';\n    body.options = {\n      checklistScored: true,\n      created: true,\n      updated: true,\n      deleted: true,\n      scored: false\n    };\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options).to.eql({\n      checklistScored: true,\n      created: true,\n      updated: true,\n      deleted: true,\n      scored: false\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"discards extra properties in taskActivity options","suites":["POST /user/webhook"],"updatePoint":{"line":120,"column":55,"index":3963},"line":120,"code":"  it('discards extra properties in taskActivity options', async () => {\n    body.type = 'taskActivity';\n    body.options = {\n      checklistScored: false,\n      created: true,\n      updated: true,\n      deleted: true,\n      scored: false,\n      foo: 'bar'\n    };\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options.foo).to.not.exist;\n    expect(webhook.options).to.eql({\n      checklistScored: false,\n      created: true,\n      updated: true,\n      deleted: true,\n      scored: false\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"requires taskActivity option  to be a boolean","suites":["POST /user/webhook"],"updatePoint":{"line":141,"column":62,"index":4569},"line":141,"code":"    it(`requires taskActivity option ${option} to be a boolean`, async () => {\n      body.type = 'taskActivity';\n      body.options = {\n        [option]: 'not a boolean'\n      };\n      await expect(user.post('/user/webhook', body)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('webhookBooleanOption', {\n          option\n        })\n      });\n    });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"can set groupChatReceived options","suites":["POST /user/webhook"],"updatePoint":{"line":155,"column":39,"index":4959},"line":155,"code":"  it('can set groupChatReceived options', async () => {\n    body.type = 'groupChatReceived';\n    body.options = {\n      groupId: generateUUID()\n    };\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options).to.eql({\n      groupId: body.options.groupId\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"groupChatReceived options requires a uuid for the groupId","suites":["POST /user/webhook"],"updatePoint":{"line":165,"column":63,"index":5281},"line":165,"code":"  it('groupChatReceived options requires a uuid for the groupId', async () => {\n    body.type = 'groupChatReceived';\n    body.options = {\n      groupId: 'not-a-uuid'\n    };\n    await expect(user.post('/user/webhook', body)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: apiError('groupIdRequired')\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"discards extra properties in groupChatReceived options","suites":["POST /user/webhook"],"updatePoint":{"line":176,"column":60,"index":5639},"line":176,"code":"  it('discards extra properties in groupChatReceived options', async () => {\n    body.type = 'groupChatReceived';\n    body.options = {\n      groupId: generateUUID(),\n      foo: 'bar'\n    };\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options.foo).to.not.exist;\n    expect(webhook.options).to.eql({\n      groupId: body.options.groupId\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"defaults questActivity options","suites":["POST /user/webhook"],"updatePoint":{"line":188,"column":36,"index":5998},"line":188,"code":"  it('defaults questActivity options', async () => {\n    body.type = 'questActivity';\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options).to.eql({\n      questStarted: false,\n      questFinished: false,\n      questInvited: false\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"can set questActivity options","suites":["POST /user/webhook"],"updatePoint":{"line":197,"column":35,"index":6275},"line":197,"code":"  it('can set questActivity options', async () => {\n    body.type = 'questActivity';\n    body.options = {\n      questStarted: true,\n      questFinished: true,\n      questInvited: true\n    };\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options).to.eql({\n      questStarted: true,\n      questFinished: true,\n      questInvited: true\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"discards extra properties in questActivity options","suites":["POST /user/webhook"],"updatePoint":{"line":211,"column":56,"index":6676},"line":211,"code":"  it('discards extra properties in questActivity options', async () => {\n    body.type = 'questActivity';\n    body.options = {\n      questStarted: false,\n      questFinished: true,\n      questInvited: true,\n      foo: 'bar'\n    };\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options.foo).to.not.exist;\n    expect(webhook.options).to.eql({\n      questStarted: false,\n      questFinished: true,\n      questInvited: true\n    });\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"requires questActivity option  to be a boolean","suites":["POST /user/webhook"],"updatePoint":{"line":228,"column":63,"index":7222},"line":228,"code":"    it(`requires questActivity option ${option} to be a boolean`, async () => {\n      body.type = 'questActivity';\n      body.options = {\n        [option]: 'not a boolean'\n      };\n      await expect(user.post('/user/webhook', body)).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('webhookBooleanOption', {\n          option\n        })\n      });\n    });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"discards extra properties in globalActivity options","suites":["POST /user/webhook"],"updatePoint":{"line":242,"column":57,"index":7631},"line":242,"code":"  it('discards extra properties in globalActivity options', async () => {\n    body.type = 'globalActivity';\n    body.options = {\n      foo: 'bar'\n    };\n    const webhook = await user.post('/user/webhook', body);\n    expect(webhook.options.foo).to.not.exist;\n    expect(webhook.options).to.eql({});\n  });","file":"api/v3/integration/webhook/POST-user_add_webhook.test.js","skipped":false,"dir":"test"},{"name":"returns an error if webhook with id does not exist","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":25,"column":56,"index":777},"line":25,"code":"  it('returns an error if webhook with id does not exist', async () => {\n    await expect(user.put('/user/webhook/id-that-does-not-exist')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('noWebhookWithId', {\n        id: 'id-that-does-not-exist'\n      })\n    });\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"returns an error if validation fails","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":34,"column":42,"index":1079},"line":34,"code":"  it('returns an error if validation fails', async () => {\n    await expect(user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      url: 'foo_invalid',\n      enabled: true\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'User validation failed'\n    });\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"updates a webhook","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":44,"column":23,"index":1374},"line":44,"code":"  it('updates a webhook', async () => {\n    const url = 'http://a-new-url.com';\n    const type = 'groupChatReceived';\n    const label = 'New Label';\n    const options = {\n      groupId: generateUUID()\n    };\n    await user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      url,\n      type,\n      options,\n      label\n    });\n    await user.sync();\n    const webhook = user.webhooks.find(hook => webhookToUpdate.id === hook.id);\n    expect(webhook.url).to.equal(url);\n    expect(webhook.label).to.equal(label);\n    expect(webhook.type).to.equal(type);\n    expect(webhook.options).to.eql(options);\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"ignores protected fields","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":64,"column":30,"index":1984},"line":64,"code":"  it('ignores protected fields', async () => {\n    const failures = 3;\n    const lastFailureAt = new Date();\n    await user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      failures,\n      lastFailureAt\n    });\n    await user.sync();\n    const webhook = user.webhooks.find(hook => webhookToUpdate.id === hook.id);\n    expect(webhook.failures).to.eql(0);\n    expect(webhook.lastFailureAt).to.eql(undefined);\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"updates a webhook with empty label","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":76,"column":40,"index":2409},"line":76,"code":"  it('updates a webhook with empty label', async () => {\n    const url = 'http://a-new-url.com';\n    const type = 'groupChatReceived';\n    const label = '';\n    const options = {\n      groupId: generateUUID()\n    };\n    await user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      url,\n      type,\n      options,\n      label\n    });\n    await user.sync();\n    const webhook = user.webhooks.find(hook => webhookToUpdate.id === hook.id);\n    expect(webhook.url).to.equal(url);\n    expect(webhook.label).to.equal(label);\n    expect(webhook.type).to.equal(type);\n    expect(webhook.options).to.eql(options);\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"returns the updated webhook","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":96,"column":33,"index":3013},"line":96,"code":"  it('returns the updated webhook', async () => {\n    const url = 'http://a-new-url.com';\n    const type = 'groupChatReceived';\n    const options = {\n      groupId: generateUUID()\n    };\n    const response = await user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      url,\n      type,\n      options\n    });\n    expect(response.url).to.eql(url);\n    expect(response.type).to.eql(type);\n    expect(response.options).to.eql(options);\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"cannot update the id","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":111,"column":26,"index":3445},"line":111,"code":"  it('cannot update the id', async () => {\n    const id = generateUUID();\n    const url = 'http://a-new-url.com';\n    await user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      url,\n      id\n    });\n    await user.sync();\n    const webhook = user.webhooks.find(hook => webhookToUpdate.id === hook.id);\n    expect(webhook.id).to.eql(webhookToUpdate.id);\n    expect(webhook.url).to.eql(url);\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"can update taskActivity options","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":123,"column":37,"index":3855},"line":123,"code":"  it('can update taskActivity options', async () => {\n    const type = 'taskActivity';\n    const options = {\n      checklistScored: true,\n      updated: false,\n      scored: false\n    };\n    const expected = {\n      checklistScored: true,\n      created: true,\n      // starting value\n      updated: false,\n      deleted: false,\n      // starting value\n      scored: false\n    };\n    const returnedWebhook = await user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      type,\n      options\n    });\n    await user.sync();\n    const savedWebhook = user.webhooks.find(hook => webhookToUpdate.id === hook.id);\n    expect(returnedWebhook.options).to.eql(expected);\n    expect(savedWebhook.options).to.eql(expected);\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"errors if taskActivity option is not a boolean","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":148,"column":52,"index":4586},"line":148,"code":"  it('errors if taskActivity option is not a boolean', async () => {\n    const type = 'taskActivity';\n    const options = {\n      created: 'not a boolean',\n      updated: false,\n      deleted: true\n    };\n    await expect(user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      type,\n      options\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('webhookBooleanOption', {\n        option: 'created'\n      })\n    });\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"errors if groupChatRecieved groupId option is not a uuid","suites":["PUT /user/webhook/:id"],"updatePoint":{"line":166,"column":62,"index":5074},"line":166,"code":"  it('errors if groupChatRecieved groupId option is not a uuid', async () => {\n    const type = 'groupChatReceived';\n    const options = {\n      groupId: 'not-a-uuid'\n    };\n    await expect(user.put(`/user/webhook/${webhookToUpdate.id}`, {\n      type,\n      options\n    })).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: apiError('groupIdRequired')\n    });\n  });","file":"api/v3/integration/webhook/PUT-user_update_webhook.test.js","skipped":false,"dir":"test"},{"name":"returns empty worldBoss object when world boss is not active (and does not require authentication)","suites":["GET /world-state"],"updatePoint":{"line":10,"column":104,"index":546},"line":10,"code":"  it('returns empty worldBoss object when world boss is not active (and does not require authentication)', async () => {\n    const res = await requester().get('/world-state');\n    expect(res.worldBoss).to.eql({});\n  });","file":"api/v3/integration/world-state/GET-world-state.test.js","skipped":false,"dir":"test"},{"name":"returns Tavern quest data when world boss is active","suites":["GET /world-state"],"updatePoint":{"line":14,"column":57,"index":719},"line":14,"code":"  it('returns Tavern quest data when world boss is active', async () => {\n    await updateDocument('groups', {\n      _id: TAVERN_ID\n    }, {\n      quest: {\n        active: true,\n        key: 'dysheartener',\n        progress: {\n          hp: 50000,\n          rage: 9999\n        }\n      }\n    });\n    const res = await requester().get('/world-state');\n    expect(res).to.have.nested.property('worldBoss');\n    expect(res.worldBoss).to.eql({\n      active: true,\n      extra: {},\n      key: 'dysheartener',\n      progress: {\n        collect: {},\n        hp: 50000,\n        rage: 9999\n      }\n    });\n  });","file":"api/v3/integration/world-state/GET-world-state.test.js","skipped":false,"dir":"test"},{"name":"returns a string representing the current season for NPC sprites","suites":["GET /world-state"],"updatePoint":{"line":40,"column":70,"index":1334},"line":40,"code":"  it('returns a string representing the current season for NPC sprites', async () => {\n    const res = await requester().get('/world-state');\n    expect(res).to.have.nested.property('npcImageSuffix');\n    expect(res.npcImageSuffix).to.be.a('string');\n  });","file":"api/v3/integration/world-state/GET-world-state.test.js","skipped":false,"dir":"test"},{"name":"returns null for the current event when there is none active","suites":["GET /world-state","no current event"],"updatePoint":{"line":52,"column":68,"index":1801},"line":52,"code":"    it('returns null for the current event when there is none active', async () => {\n      const res = await requester().get('/world-state');\n      expect(res.currentEvent).to.be.null;\n    });","file":"api/v3/integration/world-state/GET-world-state.test.js","skipped":false,"dir":"test"},{"name":"returns the current event when there is an active one","suites":["GET /world-state","no current event"],"updatePoint":{"line":67,"column":61,"index":2288},"line":67,"code":"    it('returns the current event when there is an active one', async () => {\n      const res = await requester().get('/world-state');\n      expect(res.currentEvent).to.eql(evt);\n    });","file":"api/v3/integration/world-state/GET-world-state.test.js","skipped":false,"dir":"test"},{"name":"returns an error if code is missing","suites":["POST /coupons/enter/:code"],"updatePoint":{"line":14,"column":41,"index":416},"line":14,"code":"  it('returns an error if code is missing', async () => {\n    await expect(user.post('/coupons/enter')).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: 'Not found.'\n    });\n  });","file":"api/v4/coupon/POST-coupons_enter_code.test.js","skipped":false,"dir":"test"},{"name":"returns an error if code is invalid","suites":["POST /coupons/enter/:code"],"updatePoint":{"line":21,"column":41,"index":640},"line":21,"code":"  it('returns an error if code is invalid', async () => {\n    await expect(user.post('/coupons/enter/notValid')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidCoupon')\n    });\n  });","file":"api/v4/coupon/POST-coupons_enter_code.test.js","skipped":false,"dir":"test"},{"name":"returns an error if coupon has been used","suites":["POST /coupons/enter/:code"],"updatePoint":{"line":28,"column":46,"index":886},"line":28,"code":"  it('returns an error if coupon has been used', async () => {\n    const [coupon] = await sudoUser.post('/coupons/generate/wondercon?count=1');\n    await user.post(`/coupons/enter/${coupon._id}`); // use coupon\n\n    await expect(user.post(`/coupons/enter/${coupon._id}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('couponUsed')\n    });\n  });","file":"api/v4/coupon/POST-coupons_enter_code.test.js","skipped":false,"dir":"test"},{"name":"should apply the coupon to the user","suites":["POST /coupons/enter/:code"],"updatePoint":{"line":38,"column":41,"index":1281},"line":38,"code":"  it('should apply the coupon to the user', async () => {\n    const [coupon] = await sudoUser.post('/coupons/generate/wondercon?count=1');\n    const userRes = await user.post(`/coupons/enter/${coupon._id}`);\n    expect(userRes._id).to.equal(user._id);\n    expect(userRes.items.gear.owned.eyewear_special_wondercon_red).to.be.true;\n    expect(userRes.items.gear.owned.eyewear_special_wondercon_black).to.be.true;\n    expect(userRes.items.gear.owned.back_special_wondercon_black).to.be.true;\n    expect(userRes.items.gear.owned.back_special_wondercon_red).to.be.true;\n    expect(userRes.items.gear.owned.body_special_wondercon_red).to.be.true;\n    expect(userRes.items.gear.owned.body_special_wondercon_black).to.be.true;\n    expect(userRes.items.gear.owned.body_special_wondercon_gold).to.be.true;\n    expect(userRes.extra).to.eql({\n      signupEvent: 'wondercon'\n    });\n  });","file":"api/v4/coupon/POST-coupons_enter_code.test.js","skipped":false,"dir":"test"},{"name":"returns faq (and does not require authentication)","suites":["GET /faq","language parameter"],"updatePoint":{"line":5,"column":57,"index":263},"line":5,"code":"    it('returns faq (and does not require authentication)', async () => {\n      const res = await requester().get('/faq');\n      expect(res).to.have.property('stillNeedHelp');\n      expect(res.stillNeedHelp.ios).to.equal(translate('iosFaqStillNeedHelp'));\n      expect(res).to.have.property('questions');\n      expect(res.questions[0].question).to.equal(translate('faqQuestion0'));\n    });","file":"api/v4/faq/GET-faq.test.js","skipped":false,"dir":"test"},{"name":"returns faq not in English","suites":["GET /faq","language parameter"],"updatePoint":{"line":12,"column":34,"index":630},"line":12,"code":"    it('returns faq not in English', async () => {\n      const res = await requester().get('/faq?language=de');\n      expect(res).to.have.nested.property('stillNeedHelp.ios');\n      expect(res.stillNeedHelp.ios).to.equal(i18n.t('iosFaqStillNeedHelp', 'de'));\n    });","file":"api/v4/faq/GET-faq.test.js","skipped":false,"dir":"test"},{"name":"falls back to English if the desired language is not found","suites":["GET /faq","language parameter"],"updatePoint":{"line":17,"column":66,"index":929},"line":17,"code":"    it('falls back to English if the desired language is not found', async () => {\n      const res = await requester().get('/faq?language=wrong');\n      expect(res).to.have.nested.property('stillNeedHelp.ios');\n      expect(res.stillNeedHelp.ios).to.equal(translate('iosFaqStillNeedHelp'));\n    });","file":"api/v4/faq/GET-faq.test.js","skipped":false,"dir":"test"},{"name":"returns faq with answers for ios platform only","suites":["GET /faq","platform parameter"],"updatePoint":{"line":24,"column":54,"index":1263},"line":24,"code":"    it('returns faq with answers for ios platform only', async () => {\n      const res = await requester().get('/faq?platform=ios');\n      expect(res).to.have.property('stillNeedHelp');\n      expect(res.stillNeedHelp).to.eql({\n        ios: translate('iosFaqStillNeedHelp')\n      });\n      expect(res).to.have.property('questions');\n      expect(res.questions[0]).to.eql({\n        question: translate('faqQuestion0'),\n        ios: translate('iosFaqAnswer0')\n      });\n    });","file":"api/v4/faq/GET-faq.test.js","skipped":false,"dir":"test"},{"name":"returns an error when invalid platform parameter is specified","suites":["GET /faq","platform parameter"],"updatePoint":{"line":36,"column":69,"index":1753},"line":36,"code":"    it('returns an error when invalid platform parameter is specified', async () => {\n      const request = requester().get('/faq?platform=wrong');\n      await expect(request).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: i18n.t('invalidReqParams')\n      });\n    });","file":"api/v4/faq/GET-faq.test.js","skipped":false,"dir":"test"},{"name":"falls back to \"web\" description if there is no description for specified platform","suites":["GET /faq","platform parameter"],"updatePoint":{"line":44,"column":89,"index":2095},"line":44,"code":"    it('falls back to \"web\" description if there is no description for specified platform', async () => {\n      const res = await requester().get('/faq?platform=android');\n      expect(res).to.have.property('stillNeedHelp');\n      expect(res.stillNeedHelp).to.eql({\n        web: translate('webFaqStillNeedHelp')\n      });\n      expect(res).to.have.property('questions');\n      expect(res.questions[0]).to.eql({\n        question: translate('faqQuestion0'),\n        android: translate('androidFaqAnswer0')\n      });\n    });","file":"api/v4/faq/GET-faq.test.js","skipped":false,"dir":"test"},{"name":"removes all inbox messages for the user","suites":["DELETE /inbox/clear"],"updatePoint":{"line":3,"column":45,"index":154},"line":3,"code":"  it('removes all inbox messages for the user', async () => {\n    const [user, otherUser] = await Promise.all([generateUser(), generateUser()]);\n    await otherUser.post('/members/send-private-message', {\n      toUserId: user.id,\n      message: 'first'\n    });\n    await user.post('/members/send-private-message', {\n      toUserId: otherUser.id,\n      message: 'second'\n    });\n    await otherUser.post('/members/send-private-message', {\n      toUserId: user.id,\n      message: 'third'\n    });\n    let messages = await user.get('/inbox/messages');\n    expect(messages.length).to.equal(3);\n    await user.del('/inbox/clear/');\n    messages = await user.get('/inbox/messages');\n    expect(messages.length).to.equal(0);\n  });","file":"api/v4/inbox/DELETE-inbox_clear.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the messageId parameter is not an UUID","suites":["DELETE /inbox/messages/:messageId"],"updatePoint":{"line":21,"column":64,"index":730},"line":21,"code":"  it('returns an error if the messageId parameter is not an UUID', async () => {\n    await expect(user.del('/inbox/messages/123')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v4/inbox/DELETE-inbox_messages_messageId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the message does not exist","suites":["DELETE /inbox/messages/:messageId"],"updatePoint":{"line":28,"column":52,"index":988},"line":28,"code":"  it('returns an error if the message does not exist', async () => {\n    await expect(user.del(`/inbox/messages/${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageGroupChatNotFound')\n    });\n  });","file":"api/v4/inbox/DELETE-inbox_messages_messageId.test.js","skipped":false,"dir":"test"},{"name":"deletes one message","suites":["DELETE /inbox/messages/:messageId"],"updatePoint":{"line":35,"column":25,"index":1231},"line":35,"code":"  it('deletes one message', async () => {\n    const messages = await user.get('/inbox/paged-messages');\n    expect(messages.length).to.equal(3);\n    expect(messages[0].text).to.equal('third');\n    expect(messages[1].text).to.equal('second');\n    expect(messages[2].text).to.equal('first');\n    await user.del(`/inbox/messages/${messages[1]._id}`);\n    const updatedMessages = await user.get('/inbox/paged-messages');\n    expect(updatedMessages.length).to.equal(2);\n    expect(updatedMessages[0].text).to.equal('third');\n    expect(updatedMessages[1].text).to.equal('first');\n  });","file":"api/v4/inbox/DELETE-inbox_messages_messageId.test.js","skipped":false,"dir":"test"},{"name":"returns the conversations","suites":["GET /inbox/conversations"],"updatePoint":{"line":30,"column":31,"index":929},"line":30,"code":"  it('returns the conversations', async () => {\n    const result = await user.get('/inbox/conversations');\n    expect(result.length).to.be.equal(3);\n    expect(result[0].user).to.be.equal(user.profile.name);\n    expect(result[0].username).to.be.equal(user.auth.local.username);\n    expect(result[0].text).to.be.not.empty;\n  });","file":"api/v4/inbox/GET-inbox-conversations.test.js","skipped":false,"dir":"test"},{"name":"returns the user inbox messages as an array of ordered messages (from most to least recent)","suites":["GET /inbox/conversations"],"updatePoint":{"line":37,"column":97,"index":1323},"line":37,"code":"  it('returns the user inbox messages as an array of ordered messages (from most to least recent)', async () => {\n    const messages = await user.get('/inbox/paged-messages');\n    expect(messages.length).to.equal(5); // message to yourself\n\n    expect(messages[0].text).to.equal('fifth');\n    expect(messages[0].sent).to.equal(false);\n    expect(messages[0].uuid).to.equal(user._id);\n    expect(messages[1].text).to.equal('fourth');\n    expect(messages[2].text).to.equal('third');\n    expect(messages[3].text).to.equal('second');\n    expect(messages[4].text).to.equal('first');\n  });","file":"api/v4/inbox/GET-inbox-conversations.test.js","skipped":false,"dir":"test"},{"name":"returns five messages when using page-query ","suites":["GET /inbox/conversations"],"updatePoint":{"line":49,"column":50,"index":1860},"line":49,"code":"  it('returns five messages when using page-query ', async () => {\n    const promises = [];\n\n    for (let i = 0; i < 10; i += 1) {\n      promises.push(user.post('/members/send-private-message', {\n        toUserId: user.id,\n        message: 'fourth'\n      }));\n    }\n\n    await Promise.all(promises);\n    const messages = await user.get('/inbox/paged-messages?page=1');\n    expect(messages.length).to.equal(5);\n  });","file":"api/v4/inbox/GET-inbox-conversations.test.js","skipped":false,"dir":"test"},{"name":"returns only the messages of one conversation","suites":["GET /inbox/conversations"],"updatePoint":{"line":63,"column":51,"index":2277},"line":63,"code":"  it('returns only the messages of one conversation', async () => {\n    const messages = await user.get(`/inbox/paged-messages?conversation=${otherUser.id}`);\n    expect(messages.length).to.equal(3);\n  });","file":"api/v4/inbox/GET-inbox-conversations.test.js","skipped":false,"dir":"test"},{"name":"returns the correct message format","suites":["GET /inbox/conversations"],"updatePoint":{"line":67,"column":40,"index":2472},"line":67,"code":"  it('returns the correct message format', async () => {\n    const messages = await otherUser.get(`/inbox/paged-messages?conversation=${user.id}`);\n    expect(messages[0].toUUID).to.equal(user.id); // from user\n\n    expect(messages[1].toUUID).to.not.exist; // only filled if its from the chat partner\n\n    expect(messages[2].toUUID).to.equal(user.id); // from user\n  });","file":"api/v4/inbox/GET-inbox-conversations.test.js","skipped":false,"dir":"test"},{"name":"validates req.params.memberId","suites":["GET /members/:memberId/purchase-history"],"updatePoint":{"line":11,"column":35,"index":310},"line":11,"code":"  it('validates req.params.memberId', async () => {\n    await expect(user.get('/members/invalidUUID/purchase-history')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v4/members/GET-purchase_history.test.js","skipped":false,"dir":"test"},{"name":"returns error if user is not admin","suites":["GET /members/:memberId/purchase-history"],"updatePoint":{"line":18,"column":40,"index":566},"line":18,"code":"  it('returns error if user is not admin', async () => {\n    const member = await generateUser();\n    const nonAdmin = await generateUser();\n    await expect(nonAdmin.get(`/members/${member._id}/purchase-history`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('noAdminAccess')\n    });\n  });","file":"api/v4/members/GET-purchase_history.test.js","skipped":false,"dir":"test"},{"name":"returns purchase history based on given user","suites":["GET /members/:memberId/purchase-history"],"updatePoint":{"line":27,"column":50,"index":922},"line":27,"code":"  it('returns purchase history based on given user', async () => {\n    const member = await generateUser();\n    const response = await user.get(`/members/${member._id}/purchase-history`);\n    expect(response.length).to.equal(0);\n  });","file":"api/v4/members/GET-purchase_history.test.js","skipped":false,"dir":"test"},{"name":"Allows players to flag their own private message","suites":["POST /members/flag-private-message/:messageId"],"updatePoint":{"line":8,"column":54,"index":357},"line":8,"code":"  it('Allows players to flag their own private message', async () => {\n    const receiver = await generateUser();\n    await userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    });\n    const senderMessages = await userToSendMessage.get('/inbox/paged-messages');\n\n    const sendersMessageInSendersInbox = _.find(senderMessages, message => message.toUUID === receiver._id && message.text === messageToSend);\n\n    expect(sendersMessageInSendersInbox).to.exist;\n    await expect(userToSendMessage.post(`/members/flag-private-message/${sendersMessageInSendersInbox.id}`)).to.eventually.be.ok;\n  });","file":"api/v4/members/POST-flag_private_message.test.js","skipped":false,"dir":"test"},{"name":"Flags a private message","suites":["POST /members/flag-private-message/:messageId"],"updatePoint":{"line":21,"column":29,"index":994},"line":21,"code":"  it('Flags a private message', async () => {\n    const receiver = await generateUser();\n    await userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    });\n    const receiversMessages = await receiver.get('/inbox/paged-messages');\n\n    const sendersMessageInReceiversInbox = _.find(receiversMessages, message => message.uuid === userToSendMessage._id && message.text === messageToSend);\n\n    expect(sendersMessageInReceiversInbox).to.exist;\n    await expect(receiver.post(`/members/flag-private-message/${sendersMessageInReceiversInbox.id}`)).to.eventually.be.ok;\n  });","file":"api/v4/members/POST-flag_private_message.test.js","skipped":false,"dir":"test"},{"name":"Returns an error when user tries to flag a private message that is already flagged","suites":["POST /members/flag-private-message/:messageId"],"updatePoint":{"line":34,"column":88,"index":1691},"line":34,"code":"  it('Returns an error when user tries to flag a private message that is already flagged', async () => {\n    const receiver = await generateUser();\n    await userToSendMessage.post('/members/send-private-message', {\n      message: messageToSend,\n      toUserId: receiver._id\n    });\n    const receiversMessages = await receiver.get('/inbox/paged-messages');\n\n    const sendersMessageInReceiversInbox = _.find(receiversMessages, message => message.uuid === userToSendMessage._id && message.text === messageToSend);\n\n    expect(sendersMessageInReceiversInbox).to.exist;\n    await expect(receiver.post(`/members/flag-private-message/${sendersMessageInReceiversInbox.id}`)).to.eventually.be.ok;\n    await expect(receiver.post(`/members/flag-private-message/${sendersMessageInReceiversInbox.id}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('messageGroupChatFlagAlreadyReported')\n    });\n  });","file":"api/v4/members/POST-flag_private_message.test.js","skipped":false,"dir":"test"},{"name":"disallows access to non-newsPosters","suites":["DELETE /news/:newsID"],"updatePoint":{"line":17,"column":41,"index":461},"line":17,"code":"  it('disallows access to non-newsPosters', async () => {\n    const nonAdminUser = await generateUser({\n      'contributor.newsPoster': false\n    });\n    await expect(nonAdminUser.del(`/news/${v4()}`)).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: 'You don\\'t have news poster access.'\n    });\n  });","file":"api/v4/news/DELETE-news.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the post does not exist","suites":["DELETE /news/:newsID"],"updatePoint":{"line":27,"column":49,"index":821},"line":27,"code":"  it('returns an error if the post does not exist', async () => {\n    await expect(user.del(`/news/${v4()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('newsPostNotFound')\n    });\n  });","file":"api/v4/news/DELETE-news.test.js","skipped":false,"dir":"test"},{"name":"deletes news posts","suites":["DELETE /news/:newsID"],"updatePoint":{"line":34,"column":24,"index":1035},"line":34,"code":"  it('deletes news posts', async () => {\n    const existingPost = await user.post('/news', newsPost);\n    await user.del(`/news/${existingPost._id}`);\n    const returnedPosts = await user.get('/news');\n    const deletedPost = returnedPosts.find(returnedPost => returnedPost._id === existingPost._id);\n    expect(returnedPosts).is.an('array');\n    expect(deletedPost).to.not.exist;\n  });","file":"api/v4/news/DELETE-news.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the post does not exist","suites":["GET /news/:newsID"],"updatePoint":{"line":17,"column":49,"index":466},"line":17,"code":"  it('returns an error if the post does not exist', async () => {\n    await expect(user.get(`/news/${v4()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('newsPostNotFound')\n    });\n  });","file":"api/v4/news/GET-news_id.test.js","skipped":false,"dir":"test"},{"name":"fetches an existing post","suites":["GET /news/:newsID"],"updatePoint":{"line":24,"column":30,"index":686},"line":24,"code":"  it('fetches an existing post', async () => {\n    const existingPost = await user.post('/news', newsPost);\n    const fetchedPost = await user.get(`/news/${existingPost._id}`);\n    expect(fetchedPost._id).to.equal(existingPost._id);\n  });","file":"api/v4/news/GET-news_id.test.js","skipped":false,"dir":"test"},{"name":"returns the latest news in json format, does not require authentication, 10 per page","suites":["GET /news"],"updatePoint":{"line":18,"column":90,"index":876},"line":18,"code":"  it('returns the latest news in json format, does not require authentication, 10 per page', async () => {\n    const res = await api.get('/news');\n    expect(res.length).to.be.equal(10);\n    expect(res[0].title).to.be.not.empty;\n    expect(res[0].text).to.be.not.empty;\n  });","file":"api/v4/news/GET-news.test.js","skipped":false,"dir":"test"},{"name":"supports pagination","suites":["GET /news"],"updatePoint":{"line":24,"column":25,"index":1087},"line":24,"code":"  it('supports pagination', async () => {\n    const res = await api.get('/news?page=1');\n    expect(res.length).to.be.equal(2);\n    expect(res[0].title).to.be.not.empty;\n    expect(res[0].text).to.be.not.empty;\n  });","file":"api/v4/news/GET-news.test.js","skipped":false,"dir":"test"},{"name":"marks new stuff as read","suites":["POST /news/read"],"updatePoint":{"line":8,"column":29,"index":292},"line":8,"code":"  it('marks new stuff as read', async () => {\n    NewsPost.updateLastNewsPost({\n      _id: '1234',\n      publishDate: new Date(),\n      published: true\n    });\n    await user.post('/news/read');\n    await user.sync();\n    expect(user.flags.lastNewStuffRead).to.equal('1234'); // fetching the user because newStuff is a computed property\n\n    expect((await user.get('/user')).flags.newStuff).to.equal(false);\n  });","file":"api/v4/news/POST-news_read.test.js","skipped":false,"dir":"test"},{"name":"disallows access to non-admins","suites":["POST /news"],"updatePoint":{"line":18,"column":36,"index":519},"line":18,"code":"  it('disallows access to non-admins', async () => {\n    const nonAdminUser = await generateUser({\n      'contributor.newsPoster': false\n    });\n    await expect(nonAdminUser.post('/news')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: 'You don\\'t have news poster access.'\n    });\n  });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"creates news posts","suites":["POST /news"],"updatePoint":{"line":28,"column":24,"index":847},"line":28,"code":"  it('creates news posts', async () => {\n    const response = await user.post('/news', newsPost);\n    expect(response.title).to.equal(newsPost.title);\n    expect(response.credits).to.equal(newsPost.credits);\n    expect(response.text).to.equal(newsPost.text);\n    expect(response._id).to.exist;\n    const res = await user.get('/news');\n    expect(res[0]._id).to.equal(response._id);\n    expect(res[0].title).to.equal(newsPost.title);\n    expect(res[0].text).to.equal(newsPost.text);\n  });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"new post is published and the most recent one","suites":["POST /news","calls updateLastNewsPost"],"updatePoint":{"line":47,"column":53,"index":1590},"line":47,"code":"    it('new post is published and the most recent one', async () => {\n      newsPost.publishDate = new Date();\n      const newPost = await user.post('/news', newsPost);\n      await sleep(0.05);\n      expect(NewsPost.lastNewsPost()._id).to.equal(newPost._id);\n    });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"new post is not published","suites":["POST /news","calls updateLastNewsPost"],"updatePoint":{"line":53,"column":33,"index":1837},"line":53,"code":"    it('new post is not published', async () => {\n      newsPost.published = false;\n      const newPost = await user.post('/news', newsPost);\n      await sleep(0.05);\n      expect(NewsPost.lastNewsPost()._id).to.not.equal(newPost._id);\n    });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"new post is published but in the future","suites":["POST /news","calls updateLastNewsPost"],"updatePoint":{"line":59,"column":47,"index":2095},"line":59,"code":"    it('new post is published but in the future', async () => {\n      newsPost.publishDate = moment().add({\n        days: 1\n      }).toDate();\n      const newPost = await user.post('/news', newsPost);\n      await sleep(0.05);\n      expect(NewsPost.lastNewsPost()._id).to.not.equal(newPost._id);\n    });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"new post is published but not the most recent one","suites":["POST /news","calls updateLastNewsPost"],"updatePoint":{"line":67,"column":57,"index":2408},"line":67,"code":"    it('new post is published but not the most recent one', async () => {\n      const oldPost = await user.post('/news', newsPost);\n      newsPost.publishDate = moment().subtract({\n        days: 1\n      }).toDate();\n      await user.post('/news', newsPost);\n      await sleep(0.05);\n      expect(NewsPost.lastNewsPost()._id).to.equal(oldPost._id);\n    });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"sets default fields","suites":["POST /news","calls updateLastNewsPost"],"updatePoint":{"line":77,"column":25,"index":2738},"line":77,"code":"  it('sets default fields', async () => {\n    const response = await user.post('/news', {\n      title: 'A post',\n      credits: 'Credits',\n      text: 'Text'\n    });\n    expect(response.published).to.equal(false);\n    expect(response.publishDate).to.exist;\n    expect(response.author).to.equal(user._id);\n    expect(response.createdAt).to.exist;\n    expect(response.updatedAt).to.exist;\n  });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"title","suites":["POST /news","required fields"],"updatePoint":{"line":90,"column":13,"index":3156},"line":90,"code":"    it('title', async () => {\n      await expect(user.post('/news', {\n        text: 'Text',\n        credits: 'Credits'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'NewsPost validation failed'\n      });\n    });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"credits","suites":["POST /news","required fields"],"updatePoint":{"line":100,"column":15,"index":3435},"line":100,"code":"    it('credits', async () => {\n      await expect(user.post('/news', {\n        text: 'Text',\n        title: 'Title'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'NewsPost validation failed'\n      });\n    });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"text","suites":["POST /news","required fields"],"updatePoint":{"line":110,"column":12,"index":3707},"line":110,"code":"    it('text', async () => {\n      await expect(user.post('/news', {\n        credits: 'credits',\n        title: 'Title'\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'NewsPost validation failed'\n      });\n    });","file":"api/v4/news/POST-news.test.js","skipped":false,"dir":"test"},{"name":"disallows access to non-admins","suites":["PUT /news/:newsID"],"updatePoint":{"line":18,"column":36,"index":540},"line":18,"code":"  it('disallows access to non-admins', async () => {\n    const nonAdminUser = await generateUser({\n      'contributor.newsPoster': false\n    });\n    await expect(nonAdminUser.put('/news/1234')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: 'You don\\'t have news poster access.'\n    });\n  });","file":"api/v4/news/PUT-news_newsId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if the post does not exist","suites":["PUT /news/:newsID"],"updatePoint":{"line":28,"column":49,"index":897},"line":28,"code":"  it('returns an error if the post does not exist', async () => {\n    await expect(user.put(`/news/${v4()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('newsPostNotFound')\n    });\n  });","file":"api/v4/news/PUT-news_newsId.test.js","skipped":false,"dir":"test"},{"name":"updates existing news posts","suites":["PUT /news/:newsID"],"updatePoint":{"line":35,"column":33,"index":1120},"line":35,"code":"  it('updates existing news posts', async () => {\n    const existingPost = await user.post('/news', newsPost);\n    const updatedPost = await user.put(`/news/${existingPost._id}`, {\n      title: 'Changed Title'\n    });\n    expect(updatedPost.title).to.equal('Changed Title');\n    expect(updatedPost.credits).to.equal(existingPost.credits);\n    expect(updatedPost.text).to.equal(existingPost.text);\n    expect(updatedPost.published).to.equal(existingPost.published);\n    expect(updatedPost._id).to.equal(existingPost._id);\n  });","file":"api/v4/news/PUT-news_newsId.test.js","skipped":false,"dir":"test"},{"name":"updates post data","suites":["PUT /news/:newsID","calls updateLastNewsPost"],"updatePoint":{"line":50,"column":25,"index":1755},"line":50,"code":"    it('updates post data', async () => {\n      const existingPost = await user.post('/news', { ...newsPost,\n        publishDate: new Date()\n      });\n      const updatedPost = await user.put(`/news/${existingPost._id}`, {\n        title: 'Changed Title'\n      });\n      await sleep(0.05);\n      expect(NewsPost.lastNewsPost().title).to.equal(updatedPost.title);\n    });","file":"api/v4/news/PUT-news_newsId.test.js","skipped":false,"dir":"test"},{"name":"updated post is not published","suites":["PUT /news/:newsID","calls updateLastNewsPost"],"updatePoint":{"line":60,"column":37,"index":2137},"line":60,"code":"    it('updated post is not published', async () => {\n      const oldPost = await user.post('/news', { ...newsPost,\n        publishDate: new Date()\n      });\n      const newUnpublished = await user.post('/news', { ...newsPost,\n        published: false\n      });\n      await user.put(`/news/${newUnpublished._id}`, {\n        title: 'Changed Title'\n      });\n      await sleep(0.05);\n      expect(NewsPost.lastNewsPost()._id).to.equal(oldPost._id);\n    });","file":"api/v4/news/PUT-news_newsId.test.js","skipped":false,"dir":"test"},{"name":"updated post is published","suites":["PUT /news/:newsID","calls updateLastNewsPost"],"updatePoint":{"line":73,"column":33,"index":2588},"line":73,"code":"    it('updated post is published', async () => {\n      await user.post('/news', { ...newsPost,\n        publishDate: new Date()\n      });\n      const newUnpublished = await user.post('/news', { ...newsPost,\n        published: false,\n        publishDate: new Date()\n      });\n      await user.put(`/news/${newUnpublished._id}`, {\n        publishDate: new Date(),\n        published: true\n      });\n      await sleep(0.05);\n      expect(NewsPost.lastNewsPost()._id).to.equal(newUnpublished._id);\n    });","file":"api/v4/news/PUT-news_newsId.test.js","skipped":false,"dir":"test"},{"name":"updated post publishDate is in future","suites":["PUT /news/:newsID","calls updateLastNewsPost"],"updatePoint":{"line":88,"column":45,"index":3101},"line":88,"code":"    it('updated post publishDate is in future', async () => {\n      const oldPost = await user.post('/news', { ...newsPost,\n        publishDate: new Date()\n      });\n      const newUnpublished = await user.post('/news', newsPost);\n      await user.put(`/news/${newUnpublished._id}`, {\n        publishDate: Date.now() + 50000\n      });\n      await sleep(0.05);\n      expect(NewsPost.lastNewsPost()._id).to.equal(oldPost._id);\n    });","file":"api/v4/news/PUT-news_newsId.test.js","skipped":false,"dir":"test"},{"name":"returns an error when message is not added","suites":["POST /bug-report"],"updatePoint":{"line":7,"column":48,"index":229},"line":7,"code":"  it('returns an error when message is not added', async () => {\n    await expect(user.post('/bug-report', {\n      message: ''\n    })).to.eventually.be.rejected.and.to.eql({\n      code: 400,\n      error: 'BadRequest',\n      // seems it is not possible to get the real error message\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v4/POST-bug-report.test.js","skipped":false,"dir":"test"},{"name":"returns an error when email is not added","suites":["POST /bug-report"],"updatePoint":{"line":17,"column":46,"index":568},"line":17,"code":"  it('returns an error when email is not added', async () => {\n    await expect(user.post('/bug-report', {\n      message: 'message',\n      email: ''\n    })).to.eventually.be.rejected.and.to.eql({\n      code: 400,\n      error: 'BadRequest',\n      // seems it is not possible to get the real error message\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v4/POST-bug-report.test.js","skipped":false,"dir":"test"},{"name":"returns an error when email is not valid","suites":["POST /bug-report"],"updatePoint":{"line":28,"column":46,"index":931},"line":28,"code":"  it('returns an error when email is not valid', async () => {\n    await expect(user.post('/bug-report', {\n      message: 'message',\n      email: 'notamail'\n    })).to.eventually.be.rejected.and.to.eql({\n      code: 400,\n      error: 'BadRequest',\n      // seems it is not possible to get the real error message\n      message: 'Invalid request parameters.'\n    });\n  });","file":"api/v4/POST-bug-report.test.js","skipped":false,"dir":"test"},{"name":"can use id to identify the task","suites":["POST /tasks/bulk-score","all"],"updatePoint":{"line":11,"column":39,"index":357},"line":11,"code":"    it('can use id to identify the task', async () => {\n      const todo = await user.post('/tasks/user', {\n        text: 'test todo',\n        type: 'todo',\n        alias: 'alias'\n      });\n      const res = await user.post('/tasks/bulk-score', [{\n        id: todo.id,\n        direction: 'up'\n      }]);\n      expect(res).to.be.ok;\n      expect(res.tasks.length).to.equal(1);\n      expect(res.tasks[0].id).to.equal(todo._id);\n      expect(res.tasks[0].delta).to.be.greaterThan(0);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"can use a alias in place of the id","suites":["POST /tasks/bulk-score","all"],"updatePoint":{"line":26,"column":42,"index":849},"line":26,"code":"    it('can use a alias in place of the id', async () => {\n      const todo = await user.post('/tasks/user', {\n        text: 'test todo',\n        type: 'todo',\n        alias: 'alias'\n      });\n      const res = await user.post('/tasks/bulk-score', [{\n        id: todo.alias,\n        direction: 'up'\n      }]);\n      expect(res).to.be.ok;\n      expect(res.tasks.length).to.equal(1);\n      expect(res.tasks[0].id).to.equal(todo._id);\n      expect(res.tasks[0].delta).to.be.greaterThan(0);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"sends task scored webhooks","suites":["POST /tasks/bulk-score","all"],"updatePoint":{"line":41,"column":34,"index":1336},"line":41,"code":"    it('sends task scored webhooks', async () => {\n      const uuid = generateUUID();\n      await server.start();\n      await user.post('/user/webhook', {\n        url: `http://localhost:${server.port}/webhooks/${uuid}`,\n        type: 'taskActivity',\n        enabled: true,\n        options: {\n          created: false,\n          scored: true\n        }\n      });\n      const task = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await user.post('/tasks/bulk-score', [{\n        id: task.id,\n        direction: 'up'\n      }]);\n      await sleep();\n      await server.close();\n      const body = server.getWebhookData(uuid);\n      expect(body.user).to.have.all.keys('_id', '_tmp', 'stats');\n      expect(body.user.stats).to.have.all.keys('hp', 'mp', 'exp', 'gp', 'lvl', 'class', 'points', 'str', 'con', 'int', 'per', 'buffs', 'training', 'maxHealth', 'maxMP', 'toNextLevel');\n      expect(body.task.id).to.eql(task.id);\n      expect(body.direction).to.eql('up');\n      expect(body.delta).to.be.greaterThan(0);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"sends user activity webhook when the user levels up","suites":["POST /tasks/bulk-score","all","sending user activity webhooks"],"updatePoint":{"line":77,"column":61,"index":2615},"line":77,"code":"      it('sends user activity webhook when the user levels up', async () => {\n        const uuid = generateUUID();\n        await user.post('/user/webhook', {\n          url: `http://localhost:${server.port}/webhooks/${uuid}`,\n          type: 'userActivity',\n          enabled: true,\n          options: {\n            leveledUp: true\n          }\n        });\n        const initialLvl = user.stats.lvl;\n        await user.update({\n          'stats.exp': 3000\n        });\n        const task = await user.post('/tasks/user', {\n          text: 'test habit',\n          type: 'habit'\n        });\n        await user.post('/tasks/bulk-score', [{\n          id: task.id,\n          direction: 'up'\n        }]);\n        await user.sync();\n        await sleep();\n        const body = server.getWebhookData(uuid);\n        expect(body.type).to.eql('leveledUp');\n        expect(body.initialLvl).to.eql(initialLvl);\n        expect(body.finalLvl).to.eql(user.stats.lvl);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"fails the entire op if one task scoring fails","suites":["POST /tasks/bulk-score","all","sending user activity webhooks"],"updatePoint":{"line":107,"column":53,"index":3574},"line":107,"code":"    it('fails the entire op if one task scoring fails', async () => {\n      const todo = await user.post('/tasks/user', {\n        text: 'test todo',\n        type: 'todo'\n      });\n      const habit = await user.post('/tasks/user', {\n        text: 'test habit',\n        type: 'habit'\n      });\n      await expect(user.post('/tasks/bulk-score', [{\n        id: todo.id,\n        direction: 'down'\n      }, {\n        id: habit.id,\n        direction: 'down'\n      }])).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('sessionOutdated')\n      });\n      const updatedHabit = await user.get(`/tasks/${habit._id}`);\n      expect(updatedHabit.history.length).to.equal(0);\n      expect(updatedHabit.value).to.equal(0);\n      const updatedTodo = await user.get(`/tasks/${todo._id}`);\n      expect(updatedTodo.value).to.equal(0);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"sends _tmp for each task","suites":["POST /tasks/bulk-score","all","sending user activity webhooks"],"updatePoint":{"line":133,"column":32,"index":4435},"line":133,"code":"    it('sends _tmp for each task', async () => {\n      const habit1 = await user.post('/tasks/user', {\n        text: 'test habit 1',\n        type: 'habit'\n      });\n      const habit2 = await user.post('/tasks/user', {\n        text: 'test habit 2',\n        type: 'habit'\n      });\n      await user.update({\n        'party.quest.key': 'gryphon'\n      });\n      const res = await user.post('/tasks/bulk-score', [{\n        id: habit1._id,\n        direction: 'up'\n      }, {\n        id: habit2._id,\n        direction: 'up'\n      }]);\n      await user.sync();\n      expect(res.tasks[0]._tmp.quest.progressDelta).to.be.greaterThan(0);\n      expect(res.tasks[1]._tmp.quest.progressDelta).to.be.greaterThan(0);\n      expect(user.party.quest.progress.up).to.eql(res.tasks[0]._tmp.quest.progressDelta + res.tasks[1]._tmp.quest.progressDelta);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"completes todo when direction is up","suites":["POST /tasks/bulk-score","todos"],"updatePoint":{"line":166,"column":43,"index":5475},"line":166,"code":"    it('completes todo when direction is up', async () => {\n      await user.post('/tasks/bulk-score', [{\n        id: todo.id,\n        direction: 'up'\n      }]);\n      const task = await user.get(`/tasks/${todo._id}`);\n      expect(task.completed).to.equal(true);\n      expect(task.dateCompleted).to.be.a('string'); // date gets converted to a string as json doesn't have a Date type\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"moves completed todos out of user.tasksOrder.todos","suites":["POST /tasks/bulk-score","todos"],"updatePoint":{"line":175,"column":58,"index":5882},"line":175,"code":"    it('moves completed todos out of user.tasksOrder.todos', async () => {\n      const getUser = await user.get('/user');\n      expect(getUser.tasksOrder.todos.indexOf(todo._id)).to.not.equal(-1);\n      await user.post('/tasks/bulk-score', [{\n        id: todo.id,\n        direction: 'up'\n      }]);\n      const updatedTask = await user.get(`/tasks/${todo._id}`);\n      expect(updatedTask.completed).to.equal(true);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.tasksOrder.todos.indexOf(todo._id)).to.equal(-1);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"moves un-completed todos back into user.tasksOrder.todos","suites":["POST /tasks/bulk-score","todos"],"updatePoint":{"line":187,"column":64,"index":6437},"line":187,"code":"    it('moves un-completed todos back into user.tasksOrder.todos', async () => {\n      const getUser = await user.get('/user');\n      expect(getUser.tasksOrder.todos.indexOf(todo._id)).to.not.equal(-1);\n      await user.post('/tasks/bulk-score', [{\n        id: todo.id,\n        direction: 'up'\n      }]);\n      await user.post('/tasks/bulk-score', [{\n        id: todo.id,\n        direction: 'down'\n      }]);\n      const updatedTask = await user.get(`/tasks/${todo._id}`);\n      expect(updatedTask.completed).to.equal(false);\n      const updatedUser = await user.get('/user');\n      const l = updatedUser.tasksOrder.todos.length;\n      expect(updatedUser.tasksOrder.todos.indexOf(todo._id)).not.to.equal(-1); // Check that it was pushed at the bottom\n\n      expect(updatedUser.tasksOrder.todos.indexOf(todo._id)).to.equal(l - 1);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"uncompletes todo when direction is down","suites":["POST /tasks/bulk-score","todos"],"updatePoint":{"line":206,"column":47,"index":7258},"line":206,"code":"    it('uncompletes todo when direction is down', async () => {\n      await user.post('/tasks/bulk-score', [{\n        id: todo.id,\n        direction: 'up'\n      }, {\n        id: todo.id,\n        direction: 'down'\n      }]);\n      const updatedTask = await user.get(`/tasks/${todo._id}`);\n      expect(updatedTask.completed).to.equal(false);\n      expect(updatedTask.dateCompleted).to.be.a('undefined');\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"doesn't let a todo be uncompleted twice","suites":["POST /tasks/bulk-score","todos"],"updatePoint":{"line":218,"column":48,"index":7670},"line":218,"code":"    it('doesn\\'t let a todo be uncompleted twice', async () => {\n      await expect(user.post('/tasks/bulk-score', [{\n        id: todo.id,\n        direction: 'down'\n      }])).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('sessionOutdated')\n      });\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's mp","suites":["POST /tasks/bulk-score","todos","user stats when direction is up"],"updatePoint":{"line":238,"column":30,"index":8268},"line":238,"code":"      it('increases user\\'s mp', () => {\n        expect(updatedUser.stats.mp).to.be.greaterThan(user.stats.mp);\n        expect(res.mp).to.equal(updatedUser.stats.mp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's exp","suites":["POST /tasks/bulk-score","todos","user stats when direction is up"],"updatePoint":{"line":242,"column":31,"index":8446},"line":242,"code":"      it('increases user\\'s exp', () => {\n        expect(updatedUser.stats.exp).to.be.greaterThan(user.stats.exp);\n        expect(res.exp).to.equal(updatedUser.stats.exp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's gold","suites":["POST /tasks/bulk-score","todos","user stats when direction is up"],"updatePoint":{"line":246,"column":32,"index":8629},"line":246,"code":"      it('increases user\\'s gold', () => {\n        expect(updatedUser.stats.gp).to.be.greaterThan(user.stats.gp);\n        expect(res.gp).to.equal(updatedUser.stats.gp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"decreases user's mp","suites":["POST /tasks/bulk-score","todos","user stats when direction is down"],"updatePoint":{"line":267,"column":30,"index":9295},"line":267,"code":"      it('decreases user\\'s mp', () => {\n        expect(updatedUser.stats.mp).to.be.lessThan(initialUser.stats.mp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"decreases user's exp","suites":["POST /tasks/bulk-score","todos","user stats when direction is down"],"updatePoint":{"line":270,"column":31,"index":9422},"line":270,"code":"      it('decreases user\\'s exp', () => {\n        expect(updatedUser.stats.exp).to.be.lessThan(initialUser.stats.exp);\n        expect(res.exp).to.equal(updatedUser.stats.exp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"decreases user's gold","suites":["POST /tasks/bulk-score","todos","user stats when direction is down"],"updatePoint":{"line":274,"column":32,"index":9609},"line":274,"code":"      it('decreases user\\'s gold', () => {\n        expect(updatedUser.stats.gp).to.be.lessThan(initialUser.stats.gp);\n        expect(res.gp).to.equal(updatedUser.stats.gp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"completes daily when direction is up","suites":["POST /tasks/bulk-score","dailys"],"updatePoint":{"line":288,"column":44,"index":10005},"line":288,"code":"    it('completes daily when direction is up', async () => {\n      await user.post('/tasks/bulk-score', [{\n        id: daily.id,\n        direction: 'up'\n      }]);\n      const task = await user.get(`/tasks/${daily._id}`);\n      expect(task.completed).to.equal(true);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"uncompletes daily when direction is down","suites":["POST /tasks/bulk-score","dailys"],"updatePoint":{"line":296,"column":48,"index":10284},"line":296,"code":"    it('uncompletes daily when direction is down', async () => {\n      await user.post('/tasks/bulk-score', [{\n        id: daily.id,\n        direction: 'up'\n      }, {\n        id: daily.id,\n        direction: 'down'\n      }]);\n      const task = await user.get(`/tasks/${daily._id}`);\n      expect(task.completed).to.equal(false);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"computes isDue","suites":["POST /tasks/bulk-score","dailys"],"updatePoint":{"line":307,"column":22,"index":10597},"line":307,"code":"    it('computes isDue', async () => {\n      await user.post('/tasks/bulk-score', [{\n        id: daily.id,\n        direction: 'up'\n      }]);\n      const task = await user.get(`/tasks/${daily._id}`);\n      expect(task.isDue).to.equal(true);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"computes nextDue","suites":["POST /tasks/bulk-score","dailys"],"updatePoint":{"line":315,"column":24,"index":10848},"line":315,"code":"    it('computes nextDue', async () => {\n      await user.post('/tasks/bulk-score', [{\n        id: daily.id,\n        direction: 'up'\n      }]);\n      const task = await user.get(`/tasks/${daily._id}`);\n      expect(task.nextDue.length).to.eql(6);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's mp","suites":["POST /tasks/bulk-score","dailys","user stats when direction is up"],"updatePoint":{"line":333,"column":30,"index":11407},"line":333,"code":"      it('increases user\\'s mp', () => {\n        expect(updatedUser.stats.mp).to.be.greaterThan(user.stats.mp);\n        expect(res.mp).to.equal(updatedUser.stats.mp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's exp","suites":["POST /tasks/bulk-score","dailys","user stats when direction is up"],"updatePoint":{"line":337,"column":31,"index":11585},"line":337,"code":"      it('increases user\\'s exp', () => {\n        expect(updatedUser.stats.exp).to.be.greaterThan(user.stats.exp);\n        expect(res.exp).to.equal(updatedUser.stats.exp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's gold","suites":["POST /tasks/bulk-score","dailys","user stats when direction is up"],"updatePoint":{"line":341,"column":32,"index":11768},"line":341,"code":"      it('increases user\\'s gold', () => {\n        expect(updatedUser.stats.gp).to.be.greaterThan(user.stats.gp);\n        expect(res.gp).to.equal(updatedUser.stats.gp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"decreases user's mp","suites":["POST /tasks/bulk-score","dailys","user stats when direction is down"],"updatePoint":{"line":362,"column":30,"index":12436},"line":362,"code":"      it('decreases user\\'s mp', () => {\n        expect(updatedUser.stats.mp).to.be.lessThan(initialUser.stats.mp);\n        expect(res.mp).to.equal(updatedUser.stats.mp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"decreases user's exp","suites":["POST /tasks/bulk-score","dailys","user stats when direction is down"],"updatePoint":{"line":366,"column":31,"index":12618},"line":366,"code":"      it('decreases user\\'s exp', () => {\n        expect(updatedUser.stats.exp).to.be.lessThan(initialUser.stats.exp);\n        expect(res.exp).to.equal(updatedUser.stats.exp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"decreases user's gold","suites":["POST /tasks/bulk-score","dailys","user stats when direction is down"],"updatePoint":{"line":370,"column":32,"index":12805},"line":370,"code":"      it('decreases user\\'s gold', () => {\n        expect(updatedUser.stats.gp).to.be.lessThan(initialUser.stats.gp);\n        expect(res.gp).to.equal(updatedUser.stats.gp);\n      });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's mp when direction is up","suites":["POST /tasks/bulk-score","habits"],"updatePoint":{"line":404,"column":49,"index":13740},"line":404,"code":"    it('increases user\\'s mp when direction is up', async () => {\n      const res = await user.post('/tasks/bulk-score', [{\n        id: habit.id,\n        direction: 'up'\n      }, {\n        id: plusHabit.id,\n        direction: 'up'\n      }]);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.stats.mp).to.be.greaterThan(user.stats.mp);\n      expect(res.mp).to.equal(updatedUser.stats.mp);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"decreases user's mp when direction is down","suites":["POST /tasks/bulk-score","habits"],"updatePoint":{"line":416,"column":51,"index":14165},"line":416,"code":"    it('decreases user\\'s mp when direction is down', async () => {\n      const res = await user.post('/tasks/bulk-score', [{\n        id: habit.id,\n        direction: 'down'\n      }, {\n        id: minusHabit.id,\n        direction: 'down'\n      }]);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.stats.mp).to.be.lessThan(user.stats.mp);\n      expect(res.mp).to.equal(updatedUser.stats.mp);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's exp when direction is up","suites":["POST /tasks/bulk-score","habits"],"updatePoint":{"line":428,"column":50,"index":14591},"line":428,"code":"    it('increases user\\'s exp when direction is up', async () => {\n      const res = await user.post('/tasks/bulk-score', [{\n        id: habit.id,\n        direction: 'up'\n      }, {\n        id: plusHabit.id,\n        direction: 'up'\n      }]);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.stats.exp).to.be.greaterThan(user.stats.exp);\n      expect(res.exp).to.equal(updatedUser.stats.exp);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"increases user's gold when direction is up","suites":["POST /tasks/bulk-score","habits"],"updatePoint":{"line":440,"column":51,"index":15020},"line":440,"code":"    it('increases user\\'s gold when direction is up', async () => {\n      const res = await user.post('/tasks/bulk-score', [{\n        id: habit.id,\n        direction: 'up'\n      }, {\n        id: plusHabit.id,\n        direction: 'up'\n      }]);\n      const updatedUser = await user.get('/user');\n      expect(updatedUser.stats.gp).to.be.greaterThan(user.stats.gp);\n      expect(res.gp).to.equal(updatedUser.stats.gp);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"records only one history entry per day","suites":["POST /tasks/bulk-score","habits"],"updatePoint":{"line":452,"column":46,"index":15440},"line":452,"code":"    it('records only one history entry per day', async () => {\n      const initialHistoryLength = habit.history.length;\n      await user.post('/tasks/bulk-score', [{\n        id: habit.id,\n        direction: 'up'\n      }, {\n        id: habit.id,\n        direction: 'up'\n      }, {\n        id: habit.id,\n        direction: 'down'\n      }, {\n        id: habit.id,\n        direction: 'up'\n      }]);\n      const updatedTask = await user.get(`/tasks/${habit._id}`);\n      expect(updatedTask.history.length).to.eql(initialHistoryLength + 1);\n      const lastHistoryEntry = updatedTask.history[updatedTask.history.length - 1];\n      expect(lastHistoryEntry.scoredUp).to.equal(3);\n      expect(lastHistoryEntry.scoredDown).to.equal(1);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"scores habits, dailies, todos","suites":["POST /tasks/bulk-score","mixed"],"updatePoint":{"line":492,"column":37,"index":16601},"line":492,"code":"    it('scores habits, dailies, todos', async () => {\n      const res = await user.post('/tasks/bulk-score', [{\n        id: habit.id,\n        direction: 'down'\n      }, {\n        id: daily.id,\n        direction: 'up'\n      }, {\n        id: todo.id,\n        direction: 'up'\n      }]);\n      expect(res.tasks[0].id).to.eql(habit.id);\n      expect(res.tasks[0].delta).to.be.below(0);\n      expect(res.tasks[0]._tmp).to.exist;\n      expect(res.tasks[1].id).to.eql(daily.id);\n      expect(res.tasks[1].delta).to.be.greaterThan(0);\n      expect(res.tasks[1]._tmp).to.exist;\n      expect(res.tasks[2].id).to.eql(todo.id);\n      expect(res.tasks[2].delta).to.be.greaterThan(0);\n      expect(res.tasks[2]._tmp).to.exist;\n      const updatedHabit = await user.get(`/tasks/${habit._id}`);\n      const updatedDaily = await user.get(`/tasks/${daily._id}`);\n      const updatedTodo = await user.get(`/tasks/${todo._id}`);\n      expect(habit.value).to.be.greaterThan(updatedHabit.value);\n      expect(updatedHabit.counterDown).to.equal(1);\n      expect(updatedDaily.value).to.be.greaterThan(daily.value);\n      expect(updatedTodo.value).to.be.greaterThan(todo.value);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"correctly handles rewards","suites":["POST /tasks/bulk-score","reward"],"updatePoint":{"line":522,"column":33,"index":17792},"line":522,"code":"    it('correctly handles rewards', async () => {\n      const reward = await user.post('/tasks/user', {\n        text: 'test reward',\n        type: 'reward',\n        value: 5\n      });\n      const res = await user.post('/tasks/bulk-score', [{\n        id: reward.id,\n        direction: 'up'\n      }]);\n      const updatedUser = await user.get('/user'); // purchases reward\n\n      expect(user.stats.gp).to.equal(updatedUser.stats.gp + 5);\n      expect(res.gp).to.equal(updatedUser.stats.gp); // does not change user\\'s mp\n\n      expect(user.stats.mp).to.equal(updatedUser.stats.mp);\n      expect(res.mp).to.equal(updatedUser.stats.mp); // does not change user\\'s exp\n\n      expect(user.stats.exp).to.equal(updatedUser.stats.exp);\n      expect(res.exp).to.equal(updatedUser.stats.exp);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"fails if the user does not have enough gold","suites":["POST /tasks/bulk-score","reward"],"updatePoint":{"line":543,"column":51,"index":18600},"line":543,"code":"    it('fails if the user does not have enough gold', async () => {\n      const reward = await user.post('/tasks/user', {\n        text: 'test reward',\n        type: 'reward',\n        value: 500\n      });\n      await expect(user.post('/tasks/bulk-score', [{\n        id: reward.id,\n        direction: 'up'\n      }])).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('messageNotEnoughGold')\n      });\n      const updatedUser = await user.get('/user'); // does not purchase reward\n\n      expect(user.stats.gp).to.equal(updatedUser.stats.gp);\n    });","file":"api/v4/tasks/POST-tasks-bulk-score.test.js","skipped":false,"dir":"test"},{"name":"registers a new user","suites":["POST /user/auth/local/register","username and email are free"],"updatePoint":{"line":17,"column":28,"index":642},"line":17,"code":"    it('registers a new user', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user._id).to.exist;\n      expect(user.apiToken).to.exist;\n      expect(user.auth.local.username).to.eql(username);\n      expect(user.profile.name).to.eql(username);\n      expect(user.newUser).to.eql(true);\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"remove spaces from username","suites":["POST /user/auth/local/register","username and email are free"],"updatePoint":{"line":33,"column":36,"index":1213},"line":33,"code":"    xit('remove spaces from username', async () => {\n      // TODO can probably delete this test now\n      const username = ' usernamewithspaces ';\n      const email = 'test@example.com';\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.auth.local.username).to.eql(username.trim());\n      expect(user.profile.name).to.eql(username.trim());\n    });","skipped":true,"file":"api/v4/user/auth/POST-register_local.test.js","dir":"test"},{"name":"requires to username to be less than 20","suites":["POST /user/auth/local/register","username and email are free","validates username"],"updatePoint":{"line":50,"column":49,"index":1855},"line":50,"code":"      it('requires to username to be less than 20', async () => {\n        const username = (Date.now() + uuid()).substring(0, 21);\n        await expect(api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        })).to.eventually.be.rejected.and.eql({\n          code: 400,\n          error: 'BadRequest',\n          message: 'Invalid request parameters.'\n        });\n      });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"rejects chracters not in [-_a-zA-Z0-9]","suites":["POST /user/auth/local/register","username and email are free","validates username"],"updatePoint":{"line":63,"column":48,"index":2310},"line":63,"code":"      it('rejects chracters not in [-_a-zA-Z0-9]', async () => {\n        const username = 'a-zA_Z09*';\n        await expect(api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        })).to.eventually.be.rejected.and.eql({\n          code: 400,\n          error: 'BadRequest',\n          message: 'Invalid request parameters.'\n        });\n      });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"allows only [-_a-zA-Z0-9] characters","suites":["POST /user/auth/local/register","username and email are free","validates username"],"updatePoint":{"line":76,"column":46,"index":2736},"line":76,"code":"      it('allows only [-_a-zA-Z0-9] characters', async () => {\n        const username = 'a-zA_Z09';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        expect(user.auth.local.username).to.eql(username);\n      });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"for a generic API consumer","suites":["POST /user/auth/local/register","username and email are free","provides default tags and tasks"],"updatePoint":{"line":88,"column":36,"index":3136},"line":88,"code":"      it('for a generic API consumer', async () => {\n        const username = generateRandomUserName();\n        const email = `${username}@example.com`;\n        const password = 'password';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        const requests = new ApiUser(user);\n        const habits = await requests.get('/tasks/user?type=habits');\n        const dailys = await requests.get('/tasks/user?type=dailys');\n        const todos = await requests.get('/tasks/user?type=todos');\n        const rewards = await requests.get('/tasks/user?type=rewards');\n        const tags = await requests.get('/tags');\n        expect(habits).to.have.a.lengthOf(0);\n        expect(dailys).to.have.a.lengthOf(0);\n        expect(todos).to.have.a.lengthOf(1);\n        expect(rewards).to.have.a.lengthOf(0);\n        expect(tags).to.have.a.lengthOf(7);\n        expect(tags[0].name).to.eql(t('defaultTag1'));\n        expect(tags[1].name).to.eql(t('defaultTag2'));\n        expect(tags[2].name).to.eql(t('defaultTag3'));\n        expect(tags[3].name).to.eql(t('defaultTag4'));\n        expect(tags[4].name).to.eql(t('defaultTag5'));\n        expect(tags[5].name).to.eql(t('defaultTag6'));\n        expect(tags[6].name).to.eql(t('defaultTag7'));\n      });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"for Web","suites":["POST /user/auth/local/register","username and email are free","provides default tags and tasks"],"updatePoint":{"line":117,"column":18,"index":4477},"line":117,"code":"      xit('for Web', async () => {\n        api = requester(null, {\n          'x-client': 'habitica-web'\n        });\n        const username = generateRandomUserName();\n        const email = `${username}@example.com`;\n        const password = 'password';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        const requests = new ApiUser(user);\n        const habits = await requests.get('/tasks/user?type=habits');\n        const dailys = await requests.get('/tasks/user?type=dailys');\n        const todos = await requests.get('/tasks/user?type=todos');\n        const rewards = await requests.get('/tasks/user?type=rewards');\n        const tags = await requests.get('/tags');\n        expect(habits).to.have.a.lengthOf(3);\n        expect(habits[0].text).to.eql(t('defaultHabit1Text'));\n        expect(habits[0].notes).to.eql('');\n        expect(habits[1].text).to.eql(t('defaultHabit2Text'));\n        expect(habits[1].notes).to.eql('');\n        expect(habits[2].text).to.eql(t('defaultHabit3Text'));\n        expect(habits[2].notes).to.eql('');\n        expect(dailys).to.have.a.lengthOf(0);\n        expect(todos).to.have.a.lengthOf(1);\n        expect(todos[0].text).to.eql(t('defaultTodo1Text'));\n        expect(todos[0].notes).to.eql(t('defaultTodoNotes'));\n        expect(rewards).to.have.a.lengthOf(1);\n        expect(rewards[0].text).to.eql(t('defaultReward1Text'));\n        expect(rewards[0].notes).to.eql('');\n        expect(tags).to.have.a.lengthOf(7);\n        expect(tags[0].name).to.eql(t('defaultTag1'));\n        expect(tags[1].name).to.eql(t('defaultTag2'));\n        expect(tags[2].name).to.eql(t('defaultTag3'));\n        expect(tags[3].name).to.eql(t('defaultTag4'));\n        expect(tags[4].name).to.eql(t('defaultTag5'));\n        expect(tags[5].name).to.eql(t('defaultTag6'));\n        expect(tags[6].name).to.eql(t('defaultTag7'));\n      });","skipped":true,"file":"api/v4/user/auth/POST-register_local.test.js","dir":"test"},{"name":"for Android","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":161,"column":21,"index":6533},"line":161,"code":"      it('for Android', async () => {\n        api = requester(null, {\n          'x-client': 'habitica-android'\n        });\n        const username = generateRandomUserName();\n        const email = `${username}@example.com`;\n        const password = 'password';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        const requests = new ApiUser(user);\n        const habits = await requests.get('/tasks/user?type=habits');\n        const dailys = await requests.get('/tasks/user?type=dailys');\n        const todos = await requests.get('/tasks/user?type=todos');\n        const rewards = await requests.get('/tasks/user?type=rewards');\n        const tags = await requests.get('/tags');\n        expect(habits).to.have.a.lengthOf(0);\n        expect(dailys).to.have.a.lengthOf(0);\n        expect(todos).to.have.a.lengthOf(0);\n        expect(rewards).to.have.a.lengthOf(0);\n        expect(tags).to.have.a.lengthOf(0);\n      });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"for iOS","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":186,"column":17,"index":7573},"line":186,"code":"      it('for iOS', async () => {\n        api = requester(null, {\n          'x-client': 'habitica-ios'\n        });\n        const username = generateRandomUserName();\n        const email = `${username}@example.com`;\n        const password = 'password';\n        const user = await api.post('/user/auth/local/register', {\n          username,\n          email,\n          password,\n          confirmPassword: password\n        });\n        const requests = new ApiUser(user);\n        const habits = await requests.get('/tasks/user?type=habits');\n        const dailys = await requests.get('/tasks/user?type=dailys');\n        const todos = await requests.get('/tasks/user?type=todos');\n        const rewards = await requests.get('/tasks/user?type=rewards');\n        const tags = await requests.get('/tags');\n        expect(habits).to.have.a.lengthOf(0);\n        expect(dailys).to.have.a.lengthOf(0);\n        expect(todos).to.have.a.lengthOf(0);\n        expect(rewards).to.have.a.lengthOf(0);\n        expect(tags).to.have.a.lengthOf(0);\n      });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"enrolls new users in an A/B test","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":212,"column":40,"index":8640},"line":212,"code":"    it('enrolls new users in an A/B test', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await expect(getProperty('users', user._id, '_ABtests')).to.eventually.be.a('object');\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"includes items awarded by default when creating a new user","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":224,"column":66,"index":9115},"line":224,"code":"    it('includes items awarded by default when creating a new user', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.items.quests.dustbunnies).to.equal(1);\n      expect(user.purchased.background.violet).to.be.ok;\n      expect(user.preferences.background).to.equal('violet');\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires password and confirmPassword to match","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":238,"column":54,"index":9661},"line":238,"code":"    it('requires password and confirmPassword to match', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const password = 'password';\n      const confirmPassword = 'not password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires a username","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":254,"column":27,"index":10167},"line":254,"code":"    it('requires a username', async () => {\n      const email = `${generateRandomUserName()}@example.com`;\n      const password = 'password';\n      const confirmPassword = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        email,\n        password,\n        confirmPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires an email","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":268,"column":25,"index":10616},"line":268,"code":"    it('requires an email', async () => {\n      const username = generateRandomUserName();\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires a valid email","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":281,"column":30,"index":11027},"line":281,"code":"    it('requires a valid email', async () => {\n      const username = generateRandomUserName();\n      const email = 'notanemail@sdf';\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"sanitizes email params to a lowercase string before creating the user","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":296,"column":77,"index":11538},"line":296,"code":"    it('sanitizes email params to a lowercase string before creating the user', async () => {\n      const username = generateRandomUserName();\n      const email = 'ISANEmAiL@ExAmPle.coM';\n      const password = 'password';\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.auth.local.email).to.equal(email.toLowerCase());\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"fails on a habitica.com email","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":308,"column":37,"index":11956},"line":308,"code":"    it('fails on a habitica.com email', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@habitica.com`;\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"fails on a habitrpg.com email","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":323,"column":37,"index":12440},"line":323,"code":"    it('fails on a habitrpg.com email', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@habitrpg.com`;\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"requires a password","suites":["POST /user/auth/local/register","username and email are free","does not provide default tags and tasks"],"updatePoint":{"line":338,"column":27,"index":12914},"line":338,"code":"    it('requires a password', async () => {\n      const username = generateRandomUserName();\n      const email = `${username}@example.com`;\n      const confirmPassword = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email,\n        confirmPassword\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"checks onlySocialAttachLocal","suites":["POST /user/auth/local/register","attach to facebook user"],"updatePoint":{"line":361,"column":36,"index":13621},"line":361,"code":"    it('checks onlySocialAttachLocal', async () => {\n      await expect(user.post('/user/auth/local/register', {\n        email,\n        username,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlySocialAttachLocal')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"succeeds","suites":["POST /user/auth/local/register","attach to facebook user"],"updatePoint":{"line":373,"column":16,"index":13958},"line":373,"code":"    it('succeeds', async () => {\n      await user.update({\n        'auth.facebook.id': 'some-fb-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await user.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await user.sync();\n      expect(user.auth.local.username).to.eql(username);\n      expect(user.auth.local.email).to.eql(email);\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"checks onlySocialAttachLocal","suites":["POST /user/auth/local/register","attach to google user"],"updatePoint":{"line":399,"column":36,"index":14692},"line":399,"code":"    it('checks onlySocialAttachLocal', async () => {\n      await expect(user.post('/user/auth/local/register', {\n        email,\n        username,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlySocialAttachLocal')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"succeeds","suites":["POST /user/auth/local/register","attach to google user"],"updatePoint":{"line":411,"column":16,"index":15029},"line":411,"code":"    it('succeeds', async () => {\n      await user.update({\n        'auth.google.id': 'some-google-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await user.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await user.sync();\n      expect(user.auth.local.username).to.eql(username);\n      expect(user.auth.local.email).to.eql(email);\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"checks onlySocialAttachLocal","suites":["POST /user/auth/local/register","attach to apple user"],"updatePoint":{"line":437,"column":36,"index":15762},"line":437,"code":"    it('checks onlySocialAttachLocal', async () => {\n      await expect(user.post('/user/auth/local/register', {\n        email,\n        username,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('onlySocialAttachLocal')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"succeeds","suites":["POST /user/auth/local/register","attach to apple user"],"updatePoint":{"line":449,"column":16,"index":16099},"line":449,"code":"    it('succeeds', async () => {\n      await user.update({\n        'auth.apple.id': 'some-apple-id',\n        'auth.local': {\n          ok: true\n        }\n      });\n      await user.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await user.sync();\n      expect(user.auth.local.username).to.eql(username);\n      expect(user.auth.local.email).to.eql(email);\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"rejects if username is already taken","suites":["POST /user/auth/local/register","login is already taken"],"updatePoint":{"line":481,"column":44,"index":16985},"line":481,"code":"    it('rejects if username is already taken', async () => {\n      const uniqueEmail = `${generateRandomUserName()}@example.com`;\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username,\n        email: uniqueEmail,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('usernameTaken')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"rejects if email is already taken","suites":["POST /user/auth/local/register","login is already taken"],"updatePoint":{"line":495,"column":41,"index":17455},"line":495,"code":"    it('rejects if email is already taken', async () => {\n      const uniqueUsername = generateRandomUserName();\n      const password = 'password';\n      await expect(api.post('/user/auth/local/register', {\n        username: uniqueUsername,\n        email,\n        password,\n        confirmPassword: password\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('emailTaken')\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"does not crash the signup process when it's invalid","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":521,"column":60,"index":18212},"line":521,"code":"    it('does not crash the signup process when it\\'s invalid', async () => {\n      const user = await api.post('/user/auth/local/register?groupInvite=aaaaInvalid', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user._id).to.be.a('string');\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"supports invite using req.query.groupInvite","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":530,"column":51,"index":18514},"line":530,"code":"    it('supports invite using req.query.groupInvite', async () => {\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        }\n      });\n      const invite = encrypt(JSON.stringify({\n        id: group._id,\n        inviter: groupLeader._id,\n        sentAt: Date.now() // so we can let it expire\n\n      }));\n      const user = await api.post(`/user/auth/local/register?groupInvite=${invite}`, {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.invitations.parties[0].id).to.eql(group._id);\n      expect(user.invitations.parties[0].name).to.eql(group.name);\n      expect(user.invitations.parties[0].inviter).to.eql(groupLeader._id);\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"awards achievement to inviter","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":556,"column":37,"index":19321},"line":556,"code":"    it('awards achievement to inviter', async () => {\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        }\n      });\n      const invite = encrypt(JSON.stringify({\n        id: group._id,\n        inviter: groupLeader._id,\n        sentAt: Date.now()\n      }));\n      await api.post(`/user/auth/local/register?groupInvite=${invite}`, {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      await groupLeader.sync();\n      expect(groupLeader.achievements.invitedFriend).to.be.true;\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"user not added to a party on expired invite","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":580,"column":51,"index":19992},"line":580,"code":"    it('user not added to a party on expired invite', async () => {\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'party',\n          privacy: 'private'\n        }\n      });\n      const invite = encrypt(JSON.stringify({\n        id: group._id,\n        inviter: groupLeader._id,\n        sentAt: Date.now() - 6.912e8 // 8 days old\n\n      }));\n      const user = await api.post(`/user/auth/local/register?groupInvite=${invite}`, {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.invitations.party).to.eql({});\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"adds a user to a guild on an invite of type other than party","suites":["POST /user/auth/local/register","req.query.groupInvite"],"updatePoint":{"line":604,"column":68,"index":20670},"line":604,"code":"    it('adds a user to a guild on an invite of type other than party', async () => {\n      const {\n        group,\n        groupLeader\n      } = await createAndPopulateGroup({\n        groupDetails: {\n          type: 'guild',\n          privacy: 'private'\n        }\n      });\n      const invite = encrypt(JSON.stringify({\n        id: group._id,\n        inviter: groupLeader._id,\n        sentAt: Date.now()\n      }));\n      const user = await api.post(`/user/auth/local/register?groupInvite=${invite}`, {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.invitations.guilds[0]).to.eql({\n        id: group._id,\n        name: group.name,\n        inviter: groupLeader._id\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"sets all site tour values to -2 (already seen)","suites":["POST /user/auth/local/register","successful login via api"],"updatePoint":{"line":643,"column":54,"index":21687},"line":643,"code":"    it('sets all site tour values to -2 (already seen)', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.flags.tour).to.not.be.empty;\n      each(user.flags.tour, value => {\n        expect(value).to.eql(-2);\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"populates user with default todos, not no other task types","suites":["POST /user/auth/local/register","successful login via api"],"updatePoint":{"line":655,"column":66,"index":22068},"line":655,"code":"    it('populates user with default todos, not no other task types', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.tasksOrder.todos).to.not.be.empty;\n      expect(user.tasksOrder.dailys).to.be.empty;\n      expect(user.tasksOrder.habits).to.be.empty;\n      expect(user.tasksOrder.rewards).to.be.empty;\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"populates user with default tags","suites":["POST /user/auth/local/register","successful login via api"],"updatePoint":{"line":667,"column":40,"index":22497},"line":667,"code":"    it('populates user with default tags', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.tags).to.not.be.empty;\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"sets all common tutorial flags to true","suites":["POST /user/auth/local/register","successful login with habitica-web header"],"updatePoint":{"line":690,"column":46,"index":23119},"line":690,"code":"    it('sets all common tutorial flags to true', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.flags.tour).to.not.be.empty;\n      each(user.flags.tutorial.common, value => {\n        expect(value).to.eql(true);\n      });\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"populates user with default todos, habits, and rewards","suites":["POST /user/auth/local/register","successful login with habitica-web header"],"updatePoint":{"line":702,"column":62,"index":23509},"line":702,"code":"    it('populates user with default todos, habits, and rewards', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.tasksOrder.todos).to.be.empty;\n      expect(user.tasksOrder.dailys).to.be.empty;\n      expect(user.tasksOrder.habits).to.be.empty;\n      expect(user.tasksOrder.rewards).to.be.empty;\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"populates user with default tags","suites":["POST /user/auth/local/register","successful login with habitica-web header"],"updatePoint":{"line":714,"column":40,"index":23934},"line":714,"code":"    it('populates user with default tags', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      expect(user.tags).to.not.be.empty;\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"adds the correct tags to the correct tasks","suites":["POST /user/auth/local/register","successful login with habitica-web header"],"updatePoint":{"line":723,"column":50,"index":24210},"line":723,"code":"    it('adds the correct tags to the correct tasks', async () => {\n      const user = await api.post('/user/auth/local/register', {\n        username,\n        email,\n        password,\n        confirmPassword: password\n      });\n      const requests = new ApiUser(user);\n      const habits = await requests.get('/tasks/user?type=habits');\n      const todos = await requests.get('/tasks/user?type=todos');\n      expect(habits).to.have.a.lengthOf(0);\n      expect(todos).to.have.a.lengthOf(0);\n    });","file":"api/v4/user/auth/POST-register_local.test.js","skipped":false,"dir":"test"},{"name":"successfully verifies display name including funky characters","suites":["POST /user/auth/verify-display-name"],"updatePoint":{"line":8,"column":67,"index":346},"line":8,"code":"  it('successfully verifies display name including funky characters', async () => {\n    const newDisplayName = 'Sabé 🤬';\n    const response = await user.post(ENDPOINT, {\n      displayName: newDisplayName\n    });\n    expect(response).to.eql({\n      isUsable: true\n    });\n  });","file":"api/v4/user/auth/POST-user_verify_display_name.test.js","skipped":false,"dir":"test"},{"name":"errors if display name is not provided","suites":["POST /user/auth/verify-display-name","errors"],"updatePoint":{"line":18,"column":46,"index":637},"line":18,"code":"    it('errors if display name is not provided', async () => {\n      await expect(user.post(ENDPOINT, {})).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_display_name.test.js","skipped":false,"dir":"test"},{"name":"errors if display name is a slur","suites":["POST /user/auth/verify-display-name","errors"],"updatePoint":{"line":25,"column":40,"index":879},"line":25,"code":"    it('errors if display name is a slur', async () => {\n      await expect(user.post(ENDPOINT, {\n        displayName: 'TESTPLACEHOLDERSLURWORDHERE'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('bannedSlurUsedInProfile')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_display_name.test.js","skipped":false,"dir":"test"},{"name":"errors if display name contains a slur","suites":["POST /user/auth/verify-display-name","errors"],"updatePoint":{"line":33,"column":46,"index":1154},"line":33,"code":"    it('errors if display name contains a slur', async () => {\n      await expect(user.post(ENDPOINT, {\n        displayName: 'TESTPLACEHOLDERSLURWORDHERE_otherword'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('displaynameIssueLength'), t('bannedSlurUsedInProfile')]\n      });\n      await expect(user.post(ENDPOINT, {\n        displayName: 'something_TESTPLACEHOLDERSLURWORDHERE'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('displaynameIssueLength'), t('bannedSlurUsedInProfile')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_display_name.test.js","skipped":false,"dir":"test"},{"name":"errors if display name has incorrect length","suites":["POST /user/auth/verify-display-name","errors"],"updatePoint":{"line":47,"column":51,"index":1716},"line":47,"code":"    it('errors if display name has incorrect length', async () => {\n      await expect(user.post(ENDPOINT, {\n        displayName: 'this is a very long display name over 30 characters'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('displaynameIssueLength')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_display_name.test.js","skipped":false,"dir":"test"},{"name":"errors if display name contains a newline","suites":["POST /user/auth/verify-display-name","errors"],"updatePoint":{"line":55,"column":49,"index":2017},"line":55,"code":"    it('errors if display name contains a newline', async () => {\n      await expect(user.post(ENDPOINT, {\n        displayName: 'namecontainsnewline\\n'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('displaynameIssueNewline')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_display_name.test.js","skipped":false,"dir":"test"},{"name":"successfully verifies username","suites":["POST /user/auth/verify-username"],"updatePoint":{"line":8,"column":36,"index":307},"line":8,"code":"  it('successfully verifies username', async () => {\n    const newUsername = 'new-username';\n    const response = await user.post(ENDPOINT, {\n      username: newUsername\n    });\n    expect(response).to.eql({\n      isUsable: true\n    });\n  });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"successfully verifies username with allowed characters","suites":["POST /user/auth/verify-username"],"updatePoint":{"line":17,"column":60,"index":574},"line":17,"code":"  it('successfully verifies username with allowed characters', async () => {\n    const newUsername = 'new-username_123';\n    const response = await user.post(ENDPOINT, {\n      username: newUsername\n    });\n    expect(response).to.eql({\n      isUsable: true\n    });\n  });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"errors if username is not provided","suites":["POST /user/auth/verify-username","errors"],"updatePoint":{"line":27,"column":42,"index":861},"line":27,"code":"    it('errors if username is not provided', async () => {\n      await expect(user.post(ENDPOINT, {})).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"errors if username is a slur","suites":["POST /user/auth/verify-username","errors"],"updatePoint":{"line":34,"column":36,"index":1099},"line":34,"code":"    it('errors if username is a slur', async () => {\n      await expect(user.post(ENDPOINT, {\n        username: 'TESTPLACEHOLDERSLURWORDHERE'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueLength'), t('usernameIssueSlur')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"errors if username contains a slur","suites":["POST /user/auth/verify-username","errors"],"updatePoint":{"line":42,"column":42,"index":1387},"line":42,"code":"    it('errors if username contains a slur', async () => {\n      await expect(user.post(ENDPOINT, {\n        username: 'TESTPLACEHOLDERSLURWORDHERE_otherword'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueLength'), t('usernameIssueSlur')]\n      });\n      await expect(user.post(ENDPOINT, {\n        username: 'something_TESTPLACEHOLDERSLURWORDHERE'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueLength'), t('usernameIssueSlur')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"errors if username is not allowed","suites":["POST /user/auth/verify-username","errors"],"updatePoint":{"line":56,"column":41,"index":1915},"line":56,"code":"    it('errors if username is not allowed', async () => {\n      await expect(user.post(ENDPOINT, {\n        username: 'support'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueForbidden')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"errors if username is not allowed regardless of casing","suites":["POST /user/auth/verify-username","errors"],"updatePoint":{"line":64,"column":62,"index":2182},"line":64,"code":"    it('errors if username is not allowed regardless of casing', async () => {\n      await expect(user.post(ENDPOINT, {\n        username: 'SUppORT'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueForbidden')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"errors if username has incorrect length","suites":["POST /user/auth/verify-username","errors"],"updatePoint":{"line":72,"column":47,"index":2434},"line":72,"code":"    it('errors if username has incorrect length', async () => {\n      await expect(user.post(ENDPOINT, {\n        username: 'thisisaverylongusernameover20characters'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueLength')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"errors if username contains invalid characters","suites":["POST /user/auth/verify-username","errors"],"updatePoint":{"line":80,"column":54,"index":2722},"line":80,"code":"    it('errors if username contains invalid characters', async () => {\n      await expect(user.post(ENDPOINT, {\n        username: 'Eichhörnchen'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueInvalidCharacters')]\n      });\n      await expect(user.post(ENDPOINT, {\n        username: 'test.name'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueInvalidCharacters')]\n      });\n      await expect(user.post(ENDPOINT, {\n        username: '🤬'\n      })).to.eventually.eql({\n        isUsable: false,\n        issues: [t('usernameIssueInvalidCharacters')]\n      });\n    });","file":"api/v4/user/auth/POST-user_verify_username.test.js","skipped":false,"dir":"test"},{"name":"returns the authenticated user with computed stats","suites":["GET /user"],"updatePoint":{"line":8,"column":56,"index":278},"line":8,"code":"  it('returns the authenticated user with computed stats', async () => {\n    const returnedUser = await user.get('/user');\n    expect(returnedUser._id).to.equal(user._id);\n    expect(returnedUser.stats.maxMP).to.exist;\n    expect(returnedUser.stats.maxHealth).to.equal(common.maxHealth);\n    expect(returnedUser.stats.toNextLevel).to.equal(common.tnl(returnedUser.stats.lvl));\n  });","file":"api/v4/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"does not return private paths (and apiToken)","suites":["GET /user"],"updatePoint":{"line":15,"column":50,"index":655},"line":15,"code":"  it('does not return private paths (and apiToken)', async () => {\n    const returnedUser = await user.get('/user');\n    expect(returnedUser.auth.local.hashed_password).to.not.exist;\n    expect(returnedUser.auth.local.passwordHashMethod).to.not.exist;\n    expect(returnedUser.auth.local.salt).to.not.exist;\n    expect(returnedUser.apiToken).to.not.exist;\n    expect(returnedUser.secret).to.not.exist;\n  });","file":"api/v4/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"returns only user properties requested","suites":["GET /user"],"updatePoint":{"line":23,"column":44,"index":1056},"line":23,"code":"  it('returns only user properties requested', async () => {\n    const returnedUser = await user.get('/user?userFields=achievements,items.mounts');\n    expect(returnedUser._id).to.equal(user._id);\n    expect(returnedUser.achievements).to.exist;\n    expect(returnedUser.items.mounts).to.exist; // Notifications are always returned\n\n    expect(returnedUser.notifications).to.exist;\n    expect(returnedUser.stats).to.not.exist;\n  });","file":"api/v4/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"does not return requested private properties","suites":["GET /user"],"updatePoint":{"line":32,"column":50,"index":1493},"line":32,"code":"  it('does not return requested private properties', async () => {\n    const returnedUser = await user.get('/user?userFields=apiToken,secret.text');\n    expect(returnedUser.apiToken).to.not.exist;\n    expect(returnedUser.secret).to.not.exist;\n  });","file":"api/v4/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"does not return new inbox messages","suites":["GET /user"],"updatePoint":{"line":37,"column":40,"index":1732},"line":37,"code":"  it('does not return new inbox messages', async () => {\n    const otherUser = await generateUser();\n    await otherUser.post('/members/send-private-message', {\n      toUserId: user.id,\n      message: 'first'\n    });\n    await otherUser.post('/members/send-private-message', {\n      toUserId: user.id,\n      message: 'second'\n    });\n    const returnedUser = await user.get('/user');\n    expect(returnedUser._id).to.equal(user._id);\n    expect(returnedUser.inbox.messages).to.be.undefined;\n  });","file":"api/v4/user/GET-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell does not exist","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":10,"column":46,"index":464},"line":10,"code":"  it('returns an error if spell does not exist', async () => {\n    await user.update({\n      'stats.class': 'rogue'\n    });\n    const spellId = 'invalidSpell';\n    await expect(user.post(`/user/class/cast/${spellId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: apiError('spellNotFound', {\n        spellId\n      })\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell does not exist in user's class","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":23,"column":63,"index":860},"line":23,"code":"  it('returns an error if spell does not exist in user\\'s class', async () => {\n    const spellId = 'pickPocket';\n    await expect(user.post(`/user/class/cast/${spellId}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: apiError('spellNotFound', {\n        spellId\n      })\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell.mana > user.mana","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":33,"column":48,"index":1178},"line":33,"code":"  it('returns an error if spell.mana > user.mana', async () => {\n    await user.update({\n      'stats.class': 'rogue'\n    });\n    await expect(user.post('/user/class/cast/backStab')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughMana')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell.value > user.gold","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":43,"column":49,"index":1493},"line":43,"code":"  it('returns an error if spell.value > user.gold', async () => {\n    await expect(user.post('/user/class/cast/birthday')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('messageNotEnoughGold')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if spell.lvl > user.level","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":50,"column":48,"index":1753},"line":50,"code":"  it('returns an error if spell.lvl > user.level', async () => {\n    await user.update({\n      'stats.mp': 200,\n      'stats.class': 'wizard'\n    });\n    await expect(user.post('/user/class/cast/earth')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('spellLevelTooHigh', {\n        level: 13\n      })\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user doesn't own the spell","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":63,"column":53,"index":2126},"line":63,"code":"  it('returns an error if user doesn\\'t own the spell', async () => {\n    await expect(user.post('/user/class/cast/snowball')).to.eventually.be.rejected.and.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('spellNotOwned')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if targetId is not an UUID","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":70,"column":49,"index":2380},"line":70,"code":"  it('returns an error if targetId is not an UUID', async () => {\n    await expect(user.post('/user/class/cast/spellId?targetId=notAnUUID')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('invalidReqParams')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if targetId is required but missing","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":77,"column":58,"index":2661},"line":77,"code":"  it('returns an error if targetId is required but missing', async () => {\n    await user.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 11\n    });\n    await expect(user.post('/user/class/cast/pickPocket')).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('targetIdUUID')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if targeted task doesn't exist","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":88,"column":54,"index":3002},"line":88,"code":"  it('returns an error if targeted task doesn\\'t exist', async () => {\n    await user.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 11\n    });\n    await expect(user.post(`/user/class/cast/pickPocket?targetId=${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if a challenge task was targeted","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":99,"column":55,"index":3376},"line":99,"code":"  it('returns an error if a challenge task was targeted', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup();\n    const challenge = await generateChallenge(groupLeader, group);\n    await groupLeader.post(`/challenges/${challenge._id}/join`);\n    await groupLeader.post(`/tasks/challenge/${challenge._id}`, [{\n      type: 'habit',\n      text: 'task text'\n    }]);\n    await groupLeader.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 11\n    });\n    await sleep(0.5);\n    await groupLeader.sync();\n    await expect(groupLeader.post(`/user/class/cast/pickPocket?targetId=${groupLeader.tasksOrder.habits[0]}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('challengeTasksNoCast')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if a group task was targeted","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":122,"column":51,"index":4169},"line":122,"code":"  it('returns an error if a group task was targeted', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup();\n    const groupTask = await groupLeader.post(`/tasks/group/${group._id}`, {\n      text: 'todo group',\n      type: 'todo'\n    });\n    await groupLeader.post(`/tasks/${groupTask._id}/assign/${groupLeader._id}`);\n    const memberTasks = await groupLeader.get('/tasks/user');\n    const syncedGroupTask = find(memberTasks, memberTask => memberTask.group.id === group._id);\n    await groupLeader.update({\n      'stats.class': 'rogue',\n      'stats.lvl': 11\n    });\n    await sleep(0.5);\n    await groupLeader.sync();\n    await expect(groupLeader.post(`/user/class/cast/pickPocket?targetId=${syncedGroupTask._id}`)).to.eventually.be.rejected.and.eql({\n      code: 400,\n      error: 'BadRequest',\n      message: t('groupTasksNoCast')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if targeted party member doesn't exist","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":146,"column":62,"index":5071},"line":146,"code":"  it('returns an error if targeted party member doesn\\'t exist', async () => {\n    const {\n      groupLeader\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 1\n    });\n    await groupLeader.update({\n      'items.special.snowball': 3\n    });\n    const target = generateUUID();\n    await expect(groupLeader.post(`/user/class/cast/snowball?targetId=${target}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('userWithIDNotFound', {\n        userId: target\n      })\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error if party does not exists","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":168,"column":47,"index":5666},"line":168,"code":"  it('returns an error if party does not exists', async () => {\n    await user.update({\n      'items.special.snowball': 3\n    });\n    await expect(user.post(`/user/class/cast/snowball?targetId=${generateUUID()}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('partyNotFound')\n    });\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"send message in party chat if party && !spell.silent","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":178,"column":58,"index":6017},"line":178,"code":"  it('send message in party chat if party && !spell.silent', async () => {\n    const {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup({\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 1\n    });\n    await groupLeader.update({\n      'stats.mp': 200,\n      'stats.class': 'wizard',\n      'stats.lvl': 13\n    });\n    await groupLeader.post('/user/class/cast/earth');\n    await sleep(1);\n    const groupMessages = await groupLeader.get(`/groups/${group._id}/chat`);\n    expect(groupMessages[0]).to.exist;\n    expect(groupMessages[0].uuid).to.equal('system');\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"Ethereal Surge does not recover mp of other mages","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":200,"column":55,"index":6643},"line":200,"code":"  it('Ethereal Surge does not recover mp of other mages', async () => {\n    const group = await createAndPopulateGroup({\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 4\n    });\n    let promises = [];\n    promises.push(group.groupLeader.update({\n      'stats.mp': 200,\n      'stats.class': 'wizard',\n      'stats.lvl': 20\n    }));\n    promises.push(group.members[0].update({\n      'stats.mp': 0,\n      'stats.class': 'warrior',\n      'stats.lvl': 20\n    }));\n    promises.push(group.members[1].update({\n      'stats.mp': 0,\n      'stats.class': 'wizard',\n      'stats.lvl': 20\n    }));\n    promises.push(group.members[2].update({\n      'stats.mp': 0,\n      'stats.class': 'rogue',\n      'stats.lvl': 20\n    }));\n    promises.push(group.members[3].update({\n      'stats.mp': 0,\n      'stats.class': 'healer',\n      'stats.lvl': 20\n    }));\n    await Promise.all(promises);\n    await group.groupLeader.post('/user/class/cast/mpheal');\n    promises = [];\n    promises.push(group.members[0].sync());\n    promises.push(group.members[1].sync());\n    promises.push(group.members[2].sync());\n    promises.push(group.members[3].sync());\n    await Promise.all(promises);\n    expect(group.members[0].stats.mp).to.be.greaterThan(0); // warrior\n\n    expect(group.members[1].stats.mp).to.equal(0); // wizard\n\n    expect(group.members[2].stats.mp).to.be.greaterThan(0); // rogue\n\n    expect(group.members[3].stats.mp).to.be.greaterThan(0); // healer\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"cast bulk","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":250,"column":15,"index":8093},"line":250,"code":"  it('cast bulk', async () => {\n    let {\n      group,\n      groupLeader\n    } = await createAndPopulateGroup({\n      // eslint-disable-line prefer-const\n      groupDetails: {\n        type: 'party',\n        privacy: 'private'\n      },\n      members: 1\n    });\n    await groupLeader.update({\n      'stats.mp': 200,\n      'stats.class': 'wizard',\n      'stats.lvl': 13\n    });\n    await groupLeader.post('/user/class/cast/earth', {\n      quantity: 2\n    });\n    await sleep(1);\n    group = await groupLeader.get(`/groups/${group._id}`);\n    expect(group.chat[0]).to.exist;\n    expect(group.chat[0].uuid).to.equal('system');\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"searing brightness does not affect challenge or group tasks","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":275,"column":65,"index":8771},"line":275,"code":"  it('searing brightness does not affect challenge or group tasks', async () => {\n    const guild = await generateGroup(user);\n    const challenge = await generateChallenge(user, guild);\n    await user.post(`/challenges/${challenge._id}/join`);\n    await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test challenge habit',\n      type: 'habit'\n    });\n    const groupTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'todo group',\n      type: 'todo'\n    });\n    await user.update({\n      'stats.class': 'healer',\n      'stats.mp': 200,\n      'stats.lvl': 15\n    });\n    await user.post(`/tasks/${groupTask._id}/assign/${user._id}`);\n    await user.post('/user/class/cast/brightness');\n    await user.sync();\n    const memberTasks = await user.get('/tasks/user');\n    const syncedGroupTask = find(memberTasks, memberTask => memberTask.group.id === guild._id);\n    const userChallengeTask = find(memberTasks, memberTask => memberTask.challenge.id === challenge._id);\n    expect(userChallengeTask).to.exist;\n    expect(syncedGroupTask).to.exist;\n    expect(userChallengeTask.value).to.equal(0);\n    expect(syncedGroupTask.value).to.equal(0);\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"increases both user's achievement values","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":303,"column":47,"index":9930},"line":303,"code":"  it('increases both user\\'s achievement values', async () => {\n    const party = await createAndPopulateGroup({\n      members: 1\n    });\n    const leader = party.groupLeader;\n    const recipient = party.members[0];\n    await leader.update({\n      'stats.gp': 10\n    });\n    await leader.post(`/user/class/cast/birthday?targetId=${recipient._id}`);\n    await leader.sync();\n    await recipient.sync();\n    expect(leader.achievements.birthday).to.equal(1);\n    expect(recipient.achievements.birthday).to.equal(1);\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"only increases user's achievement one if target == caster","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":318,"column":64,"index":10466},"line":318,"code":"  it('only increases user\\'s achievement one if target == caster', async () => {\n    await user.update({\n      'stats.gp': 10\n    });\n    await user.post(`/user/class/cast/birthday?targetId=${user._id}`);\n    await user.sync();\n    expect(user.achievements.birthday).to.equal(1);\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'task'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":326,"column":65,"index":10753},"line":326,"code":"  it('passes correct target to spell when targetType === \\'task\\'', async () => {\n    await user.update({\n      'stats.class': 'wizard',\n      'stats.lvl': 11\n    });\n    const task = await user.post('/tasks/user', {\n      text: 'test habit',\n      type: 'habit'\n    });\n    const result = await user.post(`/user/class/cast/fireball?targetId=${task._id}`);\n    expect(result.task._id).to.equal(task._id);\n  });","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'self'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":338,"column":65,"index":11164},"line":338,"code":"  it('passes correct target to spell when targetType === \\'self\\'', async () => {\n    await user.update({\n      'stats.class': 'wizard',\n      'stats.lvl': 14,\n      'stats.mp': 50\n    });\n    const result = await user.post('/user/class/cast/frost');\n    expect(result.user.stats.mp).to.equal(10);\n  }); // TODO find a way to have sinon working in integration tests","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'tasks'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":349,"column":66,"index":11599},"line":349,"code":"  it('passes correct target to spell when targetType === \\'tasks\\'');","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'party'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":350,"column":66,"index":11669},"line":350,"code":"  it('passes correct target to spell when targetType === \\'party\\'');","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'user'","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":351,"column":65,"index":11738},"line":351,"code":"  it('passes correct target to spell when targetType === \\'user\\'');","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'party' and user is not in a party","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":352,"column":93,"index":11835},"line":352,"code":"  it('passes correct target to spell when targetType === \\'party\\' and user is not in a party');","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"passes correct target to spell when targetType === 'user' and user is not in a party","suites":["POST /user/class/cast/:spellId"],"updatePoint":{"line":353,"column":92,"index":11931},"line":353,"code":"  it('passes correct target to spell when targetType === \\'user\\' and user is not in a party');","file":"api/v4/user/POST-user_class_cast_spellId.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user balance is too low","suites":["POST /user/rebirth"],"updatePoint":{"line":7,"column":51,"index":284},"line":7,"code":"  it('returns an error when user balance is too low', async () => {\n    await expect(user.post('/user/rebirth')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughGems')\n    });\n  }); // More tests in common code unit tests","file":"api/v4/user/POST-user_rebirth.test.js","skipped":false,"dir":"test"},{"name":"resets user's tasks","suites":["POST /user/rebirth"],"updatePoint":{"line":15,"column":26,"index":547},"line":15,"code":"  it('resets user\\'s tasks', async () => {\n    await user.update({\n      balance: 1.5\n    });\n    const daily = await generateDaily({\n      text: 'test habit',\n      type: 'daily',\n      value: 1,\n      streak: 1,\n      userId: user._id\n    });\n    const reward = await generateReward({\n      text: 'test reward',\n      type: 'reward',\n      value: 1,\n      userId: user._id\n    });\n    const response = await user.post('/user/rebirth');\n    await user.sync();\n    expect(user.notifications.length).to.equal(1);\n    expect(user.notifications[0].type).to.equal('REBIRTH_ACHIEVEMENT');\n    const updatedDaily = await user.get(`/tasks/${daily._id}`);\n    const updatedReward = await user.get(`/tasks/${reward._id}`);\n    expect(response.message).to.equal(t('rebirthComplete'));\n    expect(updatedDaily.streak).to.equal(0);\n    expect(updatedDaily.value).to.equal(0);\n    expect(updatedReward.value).to.equal(1);\n  });","file":"api/v4/user/POST-user_rebirth.test.js","skipped":false,"dir":"test"},{"name":"returns an error when user balance is too low","suites":["POST /user/reroll"],"updatePoint":{"line":7,"column":51,"index":283},"line":7,"code":"  it('returns an error when user balance is too low', async () => {\n    await expect(user.post('/user/reroll')).to.eventually.be.rejected.and.to.eql({\n      code: 401,\n      error: 'NotAuthorized',\n      message: t('notEnoughGems')\n    });\n  }); // More tests in common code unit tests","file":"api/v4/user/POST-user_reroll.test.js","skipped":false,"dir":"test"},{"name":"resets user's tasks","suites":["POST /user/reroll"],"updatePoint":{"line":15,"column":26,"index":545},"line":15,"code":"  it('resets user\\'s tasks', async () => {\n    await user.update({\n      balance: 2\n    });\n    const daily = await generateDaily({\n      text: 'test habit',\n      type: 'daily',\n      userId: user._id\n    });\n    const reward = await generateReward({\n      text: 'test reward',\n      type: 'reward',\n      value: 1,\n      userId: user._id\n    });\n    const response = await user.post('/user/reroll');\n    await user.sync();\n    const updatedDaily = await user.get(`/tasks/${daily._id}`);\n    const updatedReward = await user.get(`/tasks/${reward._id}`);\n    expect(response.message).to.equal(t('fortifyComplete'));\n    expect(updatedDaily.value).to.equal(0);\n    expect(updatedReward.value).to.equal(1);\n  });","file":"api/v4/user/POST-user_reroll.test.js","skipped":false,"dir":"test"},{"name":"resets user's habits","suites":["POST /user/reset"],"updatePoint":{"line":9,"column":27,"index":333},"line":9,"code":"  it('resets user\\'s habits', async () => {\n    const task = await user.post('/tasks/user', {\n      text: 'test habit',\n      type: 'habit'\n    });\n    await user.post('/user/reset');\n    await user.sync();\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n    expect(user.tasksOrder.habits).to.be.empty;\n  });","file":"api/v4/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"resets user's dailys","suites":["POST /user/reset"],"updatePoint":{"line":23,"column":27,"index":769},"line":23,"code":"  it('resets user\\'s dailys', async () => {\n    const task = await user.post('/tasks/user', {\n      text: 'test daily',\n      type: 'daily'\n    });\n    await user.post('/user/reset');\n    await user.sync();\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n    expect(user.tasksOrder.dailys).to.be.empty;\n  });","file":"api/v4/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"resets user's todos","suites":["POST /user/reset"],"updatePoint":{"line":37,"column":26,"index":1204},"line":37,"code":"  it('resets user\\'s todos', async () => {\n    const task = await user.post('/tasks/user', {\n      text: 'test todo',\n      type: 'todo'\n    });\n    await user.post('/user/reset');\n    await user.sync();\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n    expect(user.tasksOrder.todos).to.be.empty;\n  });","file":"api/v4/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"resets user's rewards","suites":["POST /user/reset"],"updatePoint":{"line":51,"column":28,"index":1638},"line":51,"code":"  it('resets user\\'s rewards', async () => {\n    const task = await user.post('/tasks/user', {\n      text: 'test reward',\n      type: 'reward'\n    });\n    await user.post('/user/reset');\n    await user.sync();\n    await expect(user.get(`/tasks/${task._id}`)).to.eventually.be.rejected.and.eql({\n      code: 404,\n      error: 'NotFound',\n      message: t('messageTaskNotFound')\n    });\n    expect(user.tasksOrder.rewards).to.be.empty;\n  });","file":"api/v4/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"does not delete challenge or group tasks","suites":["POST /user/reset"],"updatePoint":{"line":65,"column":46,"index":2096},"line":65,"code":"  it('does not delete challenge or group tasks', async () => {\n    const guild = await generateGroup(user);\n    const challenge = await generateChallenge(user, guild);\n    await user.post(`/challenges/${challenge._id}/join`);\n    await user.post(`/tasks/challenge/${challenge._id}`, {\n      text: 'test challenge habit',\n      type: 'habit'\n    });\n    const groupTask = await user.post(`/tasks/group/${guild._id}`, {\n      text: 'todo group',\n      type: 'todo'\n    });\n    await user.post(`/tasks/${groupTask._id}/assign/${user._id}`);\n    await user.post('/user/reset');\n    await user.sync();\n    const memberTasks = await user.get('/tasks/user');\n    const syncedGroupTask = find(memberTasks, memberTask => memberTask.group.id === guild._id);\n    const userChallengeTask = find(memberTasks, memberTask => memberTask.challenge.id === challenge._id);\n    expect(userChallengeTask).to.exist;\n    expect(syncedGroupTask).to.exist;\n  });","file":"api/v4/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"does not delete secret","suites":["POST /user/reset"],"updatePoint":{"line":86,"column":28,"index":3016},"line":86,"code":"  it('does not delete secret', async () => {\n    const admin = await generateUser({\n      contributor: {\n        admin: true\n      }\n    });\n    const hero = await generateUser({\n      contributor: {\n        level: 1\n      },\n      secret: {\n        text: 'Super-Hero'\n      }\n    });\n    await hero.post('/user/reset');\n    const heroRes = await admin.get(`/hall/heroes/${hero.auth.local.username}`);\n    expect(heroRes.secret).to.exist;\n    expect(heroRes.secret.text).to.be.eq('Super-Hero');\n  });","file":"api/v4/user/POST-user_reset.test.js","skipped":false,"dir":"test"},{"name":"should unequip all battle gear items","suites":["POST /user/unequip","Gear"],"updatePoint":{"line":40,"column":44,"index":1112},"line":40,"code":"    it('should unequip all battle gear items', async () => {\n      await user.post(`/user/unequip/${UNEQUIP_EQUIPPED}`);\n      await user.sync();\n      expect(user.items.gear.equipped.weapon).to.eq('weapon_base_0');\n      expect(user.items.gear.equipped.shield).to.eq('shield_base_0');\n    });","file":"api/v4/user/POST-user_unequip.test.js","skipped":false,"dir":"test"},{"name":"updates the user","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":9,"column":24,"index":293},"line":9,"code":"    it('updates the user', async () => {\n      await user.put('/user', {\n        'profile.name': 'Frodo',\n        'preferences.costume': true,\n        'stats.hp': 14\n      });\n      await user.sync();\n      expect(user.profile.name).to.eql('Frodo');\n      expect(user.preferences.costume).to.eql(true);\n      expect(user.stats.hp).to.eql(14);\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"tags must be an array","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":20,"column":29,"index":649},"line":20,"code":"    it('tags must be an array', async () => {\n      await expect(user.put('/user', {\n        tags: {\n          tag: true\n        }\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'mustBeArray'\n      });\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"update tags","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":31,"column":19,"index":913},"line":31,"code":"    it('update tags', async () => {\n      const userTags = user.tags;\n      await user.put('/user', {\n        tags: [...user.tags, {\n          name: 'new tag'\n        }]\n      });\n      await user.sync();\n      expect(user.tags.length).to.be.eql(userTags.length + 1);\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"profile.name cannot be an empty string or null","suites":["PUT /user","Allowed Operations"],"updatePoint":{"line":41,"column":54,"index":1224},"line":41,"code":"    it('profile.name cannot be an empty string or null', async () => {\n      await expect(user.put('/user', {\n        'profile.name': ' ' // string should be trimmed\n\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n      await expect(user.put('/user', {\n        'profile.name': ''\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n      await expect(user.put('/user', {\n        'profile.name': null\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: t('invalidReqParams')\n      });\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"does not allow updating ","suites":["PUT /user","Top Level Protected Operations"],"updatePoint":{"line":107,"column":45,"index":2968},"line":107,"code":"      it(`does not allow updating ${testName}`, async () => {\n        const errorText = t('messageUserOperationProtected', {\n          operation: Object.keys(data)[0]\n        });\n        await expect(user.put('/user', data)).to.eventually.be.rejected.and.eql({\n          code: 401,\n          error: 'NotAuthorized',\n          message: errorText\n        });\n      });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"does not allow updating ","suites":["PUT /user","Sub-Level Protected Operations"],"updatePoint":{"line":143,"column":45,"index":3926},"line":143,"code":"      it(`does not allow updating ${testName}`, async () => {\n        const errorText = t('messageUserOperationProtected', {\n          operation: Object.keys(data)[0]\n        });\n        await expect(user.put('/user', data)).to.eventually.be.rejected.and.eql({\n          code: 401,\n          error: 'NotAuthorized',\n          message: errorText\n        });\n      });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"updates user with  that is a default","suites":["PUT /user","Default Appearance Preferences"],"updatePoint":{"line":168,"column":53,"index":4668},"line":168,"code":"      it(`updates user with ${type} that is a default`, async () => {\n        const dbUpdate = {};\n        dbUpdate[`purchased.${type}.${item}`] = true;\n        await user.update(dbUpdate); // Sanity checks to make sure user is not already equipped with item\n\n        expect(get(user.preferences, type)).to.not.eql(item);\n        const updatedUser = await user.put('/user', update);\n        expect(get(updatedUser.preferences, type)).to.eql(item);\n      });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user tries to update body size with invalid type","suites":["PUT /user","Default Appearance Preferences"],"updatePoint":{"line":178,"column":76,"index":5157},"line":178,"code":"    it('returns an error if user tries to update body size with invalid type', async () => {\n      await expect(user.put('/user', {\n        'preferences.size': 'round'\n      })).to.eventually.be.rejected.and.eql({\n        code: 401,\n        error: 'NotAuthorized',\n        message: t('mustPurchaseToSet', {\n          val: 'round',\n          key: 'preferences.size'\n        })\n      });\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"can set beard to default","suites":["PUT /user","Default Appearance Preferences"],"updatePoint":{"line":190,"column":32,"index":5507},"line":190,"code":"    it('can set beard to default', async () => {\n      await user.update({\n        'purchased.hair.beard': 3,\n        'preferences.hair.beard': 3\n      });\n      const updatedUser = await user.put('/user', {\n        'preferences.hair.beard': 0\n      });\n      expect(updatedUser.preferences.hair.beard).to.eql(0);\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"can set mustache to default","suites":["PUT /user","Default Appearance Preferences"],"updatePoint":{"line":200,"column":35,"index":5832},"line":200,"code":"    it('can set mustache to default', async () => {\n      await user.update({\n        'purchased.hair.mustache': 2,\n        'preferences.hair.mustache': 2\n      });\n      const updatedUser = await user.put('/user', {\n        'preferences.hair.mustache': 0\n      });\n      expect(updatedUser.preferences.hair.mustache).to.eql(0);\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"returns an error if user tries to update  with  the user does not own","suites":["PUT /user","Purchasable Appearance Preferences"],"updatePoint":{"line":224,"column":93,"index":6603},"line":224,"code":"      it(`returns an error if user tries to update ${type} with ${type} the user does not own`, async () => {\n        await expect(user.put('/user', update)).to.eventually.be.rejected.and.eql({\n          code: 401,\n          error: 'NotAuthorized',\n          message: t('mustPurchaseToSet', {\n            val: item,\n            key: `preferences.${type}`\n          })\n        });\n      });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"updates user with  user does own","suites":["PUT /user","Purchasable Appearance Preferences"],"updatePoint":{"line":234,"column":49,"index":6949},"line":234,"code":"      it(`updates user with ${type} user does own`, async () => {\n        const dbUpdate = {};\n        dbUpdate[`purchased.${type}.${item}`] = true;\n        await user.update(dbUpdate); // Sanity check to make sure user is not already equipped with item\n\n        expect(get(user.preferences, type)).to.not.eql(item);\n        const updatedUser = await user.put('/user', update);\n        expect(get(updatedUser.preferences, type)).to.eql(item);\n      });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"sets valid categories","suites":["PUT /user","Improvement Categories"],"updatePoint":{"line":246,"column":29,"index":7440},"line":246,"code":"    it('sets valid categories', async () => {\n      await user.put('/user', {\n        'preferences.improvementCategories': ['work', 'school']\n      });\n      await user.sync();\n      expect(user.preferences.improvementCategories).to.eql(['work', 'school']);\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"discards invalid categories","suites":["PUT /user","Improvement Categories"],"updatePoint":{"line":253,"column":35,"index":7712},"line":253,"code":"    it('discards invalid categories', async () => {\n      await expect(user.put('/user', {\n        'preferences.improvementCategories': ['work', 'procrastination', 'school']\n      })).to.eventually.be.rejected.and.eql({\n        code: 400,\n        error: 'BadRequest',\n        message: 'User validation failed'\n      });\n    });","file":"api/v4/user/PUT-user.test.js","skipped":false,"dir":"test"},{"name":"increases the lowest stat","suites":["shared.fns.autoAllocate","flat allocation mode"],"updatePoint":{"line":21,"column":33,"index":681},"line":21,"code":"    it('increases the lowest stat', () => {\n      autoAllocate(user);\n      expect(user.stats.con).to.equal(5);\n      expect(user.stats.int).to.equal(5);\n      expect(user.stats.per).to.equal(4);\n      expect(user.stats.str).to.equal(8);\n    });","file":"common/fns/autoAllocate.test.js","skipped":false,"dir":"test"},{"name":"increases highest training stat","suites":["shared.fns.autoAllocate","task based allocation mode"],"updatePoint":{"line":41,"column":39,"index":1315},"line":41,"code":"    it('increases highest training stat', () => {\n      autoAllocate(user);\n      expect(user.stats.con).to.equal(5);\n      expect(user.stats.int).to.equal(5);\n      expect(user.stats.per).to.equal(4);\n      expect(user.stats.str).to.equal(8);\n    });","file":"common/fns/autoAllocate.test.js","skipped":false,"dir":"test"},{"name":"increases strength if no stat can be suggested","suites":["shared.fns.autoAllocate","task based allocation mode"],"updatePoint":{"line":48,"column":54,"index":1582},"line":48,"code":"    it('increases strength if no stat can be suggested', () => {\n      user.stats.training = {};\n      autoAllocate(user);\n      expect(user.stats.con).to.equal(5);\n      expect(user.stats.int).to.equal(5);\n      expect(user.stats.per).to.equal(3);\n      expect(user.stats.str).to.equal(9);\n    });","file":"common/fns/autoAllocate.test.js","skipped":false,"dir":"test"},{"name":"resets training object","suites":["shared.fns.autoAllocate","task based allocation mode"],"updatePoint":{"line":56,"column":30,"index":1857},"line":56,"code":"    it('resets training object', () => {\n      autoAllocate(user);\n      expect(user.stats.training.con).to.equal(0);\n      expect(user.stats.training.int).to.equal(0);\n      expect(user.stats.training.per).to.equal(0);\n      expect(user.stats.training.str).to.equal(0);\n    });","file":"common/fns/autoAllocate.test.js","skipped":false,"dir":"test"},{"name":"increases stats based on class preference","suites":["shared.fns.autoAllocate","class based allocation mode"],"updatePoint":{"line":73,"column":49,"index":2426},"line":73,"code":"    it('increases stats based on class preference', () => {\n      user.stats.class = 'healer';\n      autoAllocate(user);\n      expect(user.stats.con).to.equal(6);\n      expect(user.stats.int).to.equal(5);\n      expect(user.stats.per).to.equal(3);\n      expect(user.stats.str).to.equal(8);\n    });","file":"common/fns/autoAllocate.test.js","skipped":false,"dir":"test"},{"name":"increases strenth","suites":["shared.fns.autoAllocate","invalid alocation mode"],"updatePoint":{"line":90,"column":25,"index":2933},"line":90,"code":"    it('increases strenth', () => {\n      autoAllocate(user);\n      expect(user.stats.con).to.equal(5);\n      expect(user.stats.int).to.equal(5);\n      expect(user.stats.per).to.equal(3);\n      expect(user.stats.str).to.equal(9);\n    });","file":"common/fns/autoAllocate.test.js","skipped":false,"dir":"test"},{"name":"computes","suites":["crit"],"updatePoint":{"line":8,"column":14,"index":226},"line":8,"code":"  it('computes', () => {\n    const result = crit.crit(user);\n    expect(result).to.eql(1);\n  });","file":"common/fns/crit.test.js","skipped":false,"dir":"test"},{"name":"returns 0 when user.timezoneOffset is not set","suites":["getUtcOffset"],"updatePoint":{"line":9,"column":51,"index":242},"line":9,"code":"  it('returns 0 when user.timezoneOffset is not set', () => {\n    expect(getUtcOffset(user)).to.equal(0);\n  });","file":"common/fns/getUtcOffset.test.js","skipped":false,"dir":"test"},{"name":"returns 0 when user.timezoneOffset is zero","suites":["getUtcOffset"],"updatePoint":{"line":12,"column":48,"index":351},"line":12,"code":"  it('returns 0 when user.timezoneOffset is zero', () => {\n    user.preferences.timezoneOffset = 0;\n    expect(getUtcOffset(user)).to.equal(0);\n  });","file":"common/fns/getUtcOffset.test.js","skipped":false,"dir":"test"},{"name":"returns the opposite of user.timezoneOffset","suites":["getUtcOffset"],"updatePoint":{"line":16,"column":49,"index":502},"line":16,"code":"  it('returns the opposite of user.timezoneOffset', () => {\n    user.preferences.timezoneOffset = -10;\n    expect(getUtcOffset(user)).to.eql(10);\n  });","file":"common/fns/getUtcOffset.test.js","skipped":false,"dir":"test"},{"name":"returns a number","suites":["shared.fns.predictableRandom"],"updatePoint":{"line":8,"column":22,"index":284},"line":8,"code":"  it('returns a number', () => {\n    expect(predictableRandom(user)).to.be.a('number');\n  });","file":"common/fns/predictableRandom.test.js","skipped":false,"dir":"test"},{"name":"returns the same value when user.stats is the same and no seed is passed","suites":["shared.fns.predictableRandom"],"updatePoint":{"line":11,"column":78,"index":434},"line":11,"code":"  it('returns the same value when user.stats is the same and no seed is passed', () => {\n    user.stats.hp = 43;\n    user.stats.gp = 34;\n    const val1 = predictableRandom(user);\n    const val2 = predictableRandom(user);\n    expect(val2).to.equal(val1);\n  });","file":"common/fns/predictableRandom.test.js","skipped":false,"dir":"test"},{"name":"returns a different value when user.stats is not the same and no seed is passed","suites":["shared.fns.predictableRandom"],"updatePoint":{"line":18,"column":85,"index":701},"line":18,"code":"  it('returns a different value when user.stats is not the same and no seed is passed', () => {\n    user.stats.hp = 43;\n    user.stats.gp = 34;\n    const val1 = predictableRandom(user);\n    user.stats.gp = 35;\n    const val2 = predictableRandom(user);\n    expect(val2).to.not.equal(val1);\n  });","file":"common/fns/predictableRandom.test.js","skipped":false,"dir":"test"},{"name":"returns the same value when the same seed is passed","suites":["shared.fns.predictableRandom"],"updatePoint":{"line":26,"column":57,"index":968},"line":26,"code":"  it('returns the same value when the same seed is passed', () => {\n    const val1 = predictableRandom(user, 4452673762);\n    const val2 = predictableRandom(user, 4452673762);\n    expect(val2).to.equal(val1);\n  });","file":"common/fns/predictableRandom.test.js","skipped":false,"dir":"test"},{"name":"returns a different value when a different seed is passed","suites":["shared.fns.predictableRandom"],"updatePoint":{"line":31,"column":63,"index":1189},"line":31,"code":"  it('returns a different value when a different seed is passed', () => {\n    const val1 = predictableRandom(user, 4452673761);\n    const val2 = predictableRandom(user, 4452673762);\n    expect(val2).to.not.equal(val1);\n  });","file":"common/fns/predictableRandom.test.js","skipped":false,"dir":"test"},{"name":"drops an item for the user.party.quest.progress","suites":["common.fns.randomDrop"],"updatePoint":{"line":18,"column":53,"index":645},"line":18,"code":"  it('drops an item for the user.party.quest.progress', () => {\n    expect(user.party.quest.progress.collectedItems).to.eql(0);\n    user.party.quest.key = 'vice2';\n    predictableRandom.returns(0.0001);\n    randomDrop(user, {\n      task,\n      predictableRandom\n    });\n    expect(user.party.quest.progress.collectedItems).to.eql(1);\n    expect(user._tmp.quest.collection).to.eql(1);\n    randomDrop(user, {\n      task,\n      predictableRandom\n    });\n    expect(user.party.quest.progress.collectedItems).to.eql(2);\n    expect(user._tmp.quest.collection).to.eql(1);\n  });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"awards an egg and a hatching potion if user has never received any","suites":["common.fns.randomDrop","drops enabled"],"updatePoint":{"line":39,"column":74,"index":1333},"line":39,"code":"    it('awards an egg and a hatching potion if user has never received any', () => {\n      delete user.items.eggs.Wolf;\n      randomDrop(user, {\n        task,\n        predictableRandom\n      });\n      expect(user._tmp.firstDrops.egg).to.be.a.string;\n      expect(user._tmp.firstDrops.hatchingPotion).to.be.a.string;\n    });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"does nothing if user.items.lastDrop.count is exceeded","suites":["common.fns.randomDrop","drops enabled"],"updatePoint":{"line":48,"column":61,"index":1644},"line":48,"code":"    it('does nothing if user.items.lastDrop.count is exceeded', () => {\n      user.items.lastDrop.count = 100;\n      randomDrop(user, {\n        task,\n        predictableRandom\n      });\n      expect(user._tmp.drop).to.be.undefined;\n    });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops something when the task is a todo","suites":["common.fns.randomDrop","drops enabled"],"updatePoint":{"line":56,"column":47,"index":1870},"line":56,"code":"    it('drops something when the task is a todo', () => {\n      expect(user._tmp).to.eql({});\n      predictableRandom.returns(0.1);\n      randomDrop(user, {\n        task,\n        predictableRandom\n      });\n      expect(user._tmp).to.not.eql({});\n    });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops something when the task is a habit","suites":["common.fns.randomDrop","drops enabled"],"updatePoint":{"line":65,"column":48,"index":2126},"line":65,"code":"    it('drops something when the task is a habit', () => {\n      task = generateHabit({\n        userId: user._id\n      });\n      expect(user._tmp).to.eql({});\n      predictableRandom.returns(0.1);\n      randomDrop(user, {\n        task,\n        predictableRandom\n      });\n      expect(user._tmp).to.not.eql({});\n    });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops something when the task is a daily","suites":["common.fns.randomDrop","drops enabled"],"updatePoint":{"line":77,"column":48,"index":2446},"line":77,"code":"    it('drops something when the task is a daily', () => {\n      task = generateDaily({\n        userId: user._id\n      });\n      expect(user._tmp).to.eql({});\n      predictableRandom.returns(0.1);\n      randomDrop(user, {\n        task,\n        predictableRandom\n      });\n      expect(user._tmp).to.not.eql({});\n    });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops something when the task is a reward","suites":["common.fns.randomDrop","drops enabled"],"updatePoint":{"line":89,"column":49,"index":2767},"line":89,"code":"    it('drops something when the task is a reward', () => {\n      task = generateReward({\n        userId: user._id\n      });\n      expect(user._tmp).to.eql({});\n      predictableRandom.returns(0.1);\n      randomDrop(user, {\n        task,\n        predictableRandom\n      });\n      expect(user._tmp).to.not.eql({});\n    });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops food","suites":["common.fns.randomDrop","drops enabled"],"updatePoint":{"line":101,"column":18,"index":3058},"line":101,"code":"    it('drops food', () => {\n      predictableRandom.returns(0.65);\n      randomDrop(user, {\n        task,\n        predictableRandom\n      });\n      expect(user._tmp.drop.type).to.eql('Food');\n    });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops eggs","suites":["common.fns.randomDrop","drops enabled"],"updatePoint":{"line":109,"column":18,"index":3259},"line":109,"code":"    it('drops eggs', () => {\n      predictableRandom.returns(0.35);\n      randomDrop(user, {\n        task,\n        predictableRandom\n      });\n      expect(user._tmp.drop.type).to.eql('Egg');\n    });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops a very rare potion","suites":["common.fns.randomDrop","drops enabled","drops hatching potion"],"updatePoint":{"line":118,"column":34,"index":3520},"line":118,"code":"      it('drops a very rare potion', () => {\n        predictableRandom.returns(0.01);\n        randomDrop(user, {\n          task,\n          predictableRandom\n        });\n        expect(user._tmp.drop.type).to.eql('HatchingPotion');\n        expect(user._tmp.drop.value).to.eql(5);\n        expect(user._tmp.drop.key).to.eql('Golden');\n      });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops a rare potion","suites":["common.fns.randomDrop","drops enabled","drops hatching potion"],"updatePoint":{"line":128,"column":29,"index":3857},"line":128,"code":"      it('drops a rare potion', () => {\n        predictableRandom.returns(0.08);\n        randomDrop(user, {\n          task,\n          predictableRandom\n        });\n        expect(user._tmp.drop.type).to.eql('HatchingPotion');\n        expect(user._tmp.drop.value).to.eql(4);\n        const acceptableDrops = ['Zombie', 'CottonCandyPink', 'CottonCandyBlue']; // deterministically 'CottonCandyBlue'\n\n        expect(acceptableDrops).to.contain(user._tmp.drop.key);\n      });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops an uncommon potion","suites":["common.fns.randomDrop","drops enabled","drops hatching potion"],"updatePoint":{"line":140,"column":34,"index":4332},"line":140,"code":"      it('drops an uncommon potion', () => {\n        predictableRandom.returns(0.17);\n        randomDrop(user, {\n          task,\n          predictableRandom\n        });\n        expect(user._tmp.drop.type).to.eql('HatchingPotion');\n        expect(user._tmp.drop.value).to.eql(3);\n        const acceptableDrops = ['Red', 'Shade', 'Skeleton'];\n        expect(acceptableDrops).to.contain(user._tmp.drop.key); // always skeleton\n      });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"drops a common potion","suites":["common.fns.randomDrop","drops enabled","drops hatching potion"],"updatePoint":{"line":151,"column":31,"index":4763},"line":151,"code":"      it('drops a common potion', () => {\n        predictableRandom.returns(0.20);\n        randomDrop(user, {\n          task,\n          predictableRandom\n        });\n        expect(user._tmp.drop.type).to.eql('HatchingPotion');\n        expect(user._tmp.drop.value).to.eql(2);\n        const acceptableDrops = ['Base', 'White', 'Desert'];\n        expect(acceptableDrops).to.contain(user._tmp.drop.key); // always Desert\n      });","file":"common/fns/randomDrop.test.js","skipped":false,"dir":"test"},{"name":"returns default values","suites":["common.fns.statsComputed"],"updatePoint":{"line":8,"column":28,"index":279},"line":8,"code":"  it('returns default values', () => {\n    const result = statsComputed(user);\n    expect(result.per).to.eql(0);\n    expect(result.con).to.eql(0);\n    expect(result.str).to.eql(0);\n    expect(result.maxMP).to.eql(30);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"calculates stat bonuses for equipment","suites":["common.fns.statsComputed"],"updatePoint":{"line":15,"column":43,"index":518},"line":15,"code":"  it('calculates stat bonuses for equipment', () => {\n    user.items.gear.equipped.weapon = 'weapon_rogue_1';\n    const result = statsComputed(user);\n    expect(result.str).to.eql(2);\n    expect(result.gearBonus.str).to.eql(2);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"calculates stat bonuses for class","suites":["common.fns.statsComputed"],"updatePoint":{"line":21,"column":39,"index":748},"line":21,"code":"  it('calculates stat bonuses for class', () => {\n    user.items.gear.equipped.weapon = 'weapon_warrior_1';\n    const result = statsComputed(user);\n    expect(result.str).to.eql(4.5);\n    expect(result.gearBonus.str).to.eql(3);\n    expect(result.classBonus.str).to.eql(1.5);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"calculates stat bonuses for level","suites":["common.fns.statsComputed"],"updatePoint":{"line":28,"column":39,"index":1029},"line":28,"code":"  it('calculates stat bonuses for level', () => {\n    user.stats.lvl = 25;\n    const result = statsComputed(user);\n    expect(result.str).to.eql(12);\n    expect(result.levelBonus.str).to.eql(12);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"correctly caps level stat bonuses","suites":["common.fns.statsComputed"],"updatePoint":{"line":34,"column":39,"index":1231},"line":34,"code":"  it('correctly caps level stat bonuses', () => {\n    user.stats.lvl = 150;\n    const result = statsComputed(user);\n    expect(result.str).to.eql(50);\n    expect(result.levelBonus.str).to.eql(50);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"sets baseStat field","suites":["common.fns.statsComputed"],"updatePoint":{"line":40,"column":25,"index":1420},"line":40,"code":"  it('sets baseStat field', () => {\n    user.stats.str = 20;\n    const result = statsComputed(user);\n    expect(result.str).to.eql(20);\n    expect(result.baseStat.str).to.eql(20);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"sets buffs field","suites":["common.fns.statsComputed"],"updatePoint":{"line":46,"column":22,"index":1603},"line":46,"code":"  it('sets buffs field', () => {\n    user.stats.buffs.str = 150;\n    const result = statsComputed(user);\n    expect(result.str).to.eql(150);\n    expect(result.buff.str).to.eql(150);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"calculates mp from intelligence","suites":["common.fns.statsComputed"],"updatePoint":{"line":52,"column":37,"index":1806},"line":52,"code":"  it('calculates mp from intelligence', () => {\n    user.stats.int = 150;\n    user.stats.buffs.int = 50;\n    const result = statsComputed(user);\n    expect(result.maxMP).to.eql(430);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"calculates stat bonuses for back equipment","suites":["common.fns.statsComputed"],"updatePoint":{"line":58,"column":48,"index":2006},"line":58,"code":"  it('calculates stat bonuses for back equipment', () => {\n    user.items.gear.equipped.back = 'back_special_takeThis';\n    const result = statsComputed(user);\n    expect(result.int).to.eql(1);\n    expect(result.per).to.eql(1);\n    expect(result.con).to.eql(1);\n    expect(result.str).to.eql(1);\n  });","file":"common/fns/statsComputed.test.js","skipped":false,"dir":"test"},{"name":"updates user's hp","suites":["common.fns.updateStats","No Hp"],"updatePoint":{"line":10,"column":26,"index":337},"line":10,"code":"    it('updates user\\'s hp', () => {\n      const stats = {\n        hp: 0\n      };\n      expect(user.stats.hp).to.not.eql(0);\n      updateStats(user, stats);\n      expect(user.stats.hp).to.eql(0);\n      updateStats(user, {\n        hp: 2\n      });\n      expect(user.stats.hp).to.eql(2);\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"does not lower hp below 0","suites":["common.fns.updateStats","No Hp"],"updatePoint":{"line":22,"column":33,"index":637},"line":22,"code":"    it('does not lower hp below 0', () => {\n      const stats = {\n        hp: -5\n      };\n      updateStats(user, stats);\n      expect(user.stats.hp).to.eql(0);\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"adds only attribute points up to user's level","suites":["common.fns.updateStats","Stat Allocation"],"updatePoint":{"line":31,"column":54,"index":870},"line":31,"code":"    it('adds only attribute points up to user\\'s level', () => {\n      const stats = {\n        exp: 261\n      };\n      expect(user.stats.points).to.eql(0);\n      user.stats.lvl = 10;\n      updateStats(user, stats);\n      expect(user.stats.points).to.eql(11);\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"adds an attibute point when user's stat points are less than max level","suites":["common.fns.updateStats","Stat Allocation"],"updatePoint":{"line":40,"column":79,"index":1162},"line":40,"code":"    it('adds an attibute point when user\\'s stat points are less than max level', () => {\n      const stats = {\n        exp: 3581\n      };\n      user.stats.lvl = 99;\n      user.stats.str = 25;\n      user.stats.int = 25;\n      user.stats.con = 25;\n      user.stats.per = 24;\n      updateStats(user, stats);\n      expect(user.stats.points).to.eql(1);\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"does not add an attibute point when user's stat points are equal to max level","suites":["common.fns.updateStats","Stat Allocation"],"updatePoint":{"line":52,"column":86,"index":1526},"line":52,"code":"    it('does not add an attibute point when user\\'s stat points are equal to max level', () => {\n      const stats = {\n        exp: 3581\n      };\n      user.stats.lvl = 99;\n      user.stats.str = 25;\n      user.stats.int = 25;\n      user.stats.con = 25;\n      user.stats.per = 25;\n      updateStats(user, stats);\n      expect(user.stats.points).to.eql(0);\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"does not add an attibute point when user's stat points + unallocated points are equal to max level","suites":["common.fns.updateStats","Stat Allocation"],"updatePoint":{"line":64,"column":107,"index":1911},"line":64,"code":"    it('does not add an attibute point when user\\'s stat points + unallocated points are equal to max level', () => {\n      const stats = {\n        exp: 3581\n      };\n      user.stats.lvl = 99;\n      user.stats.str = 25;\n      user.stats.int = 25;\n      user.stats.con = 25;\n      user.stats.per = 15;\n      user.stats.points = 10;\n      updateStats(user, stats);\n      expect(user.stats.points).to.eql(10);\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"only awards stat points up to level 100 if user is missing unallocated stat points and is over level 100","suites":["common.fns.updateStats","Stat Allocation"],"updatePoint":{"line":77,"column":112,"index":2332},"line":77,"code":"    it('only awards stat points up to level 100 if user is missing unallocated stat points and is over level 100', () => {\n      const stats = {\n        exp: 5581\n      };\n      user.stats.lvl = 104;\n      user.stats.str = 25;\n      user.stats.int = 25;\n      user.stats.con = 25;\n      user.stats.per = 15;\n      user.stats.points = 0;\n      updateStats(user, stats);\n      expect(user.stats.points).to.eql(10);\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"add user notification when the user levels up","suites":["common.fns.updateStats","Stat Allocation"],"updatePoint":{"line":90,"column":53,"index":2694},"line":90,"code":"    it('add user notification when the user levels up', () => {\n      const initialLvl = user.stats.lvl;\n      updateStats(user, {\n        exp: 3000\n      });\n      expect(user._tmp.leveledUp).to.eql([{\n        initialLvl,\n        newLvl: user.stats.lvl\n      }]);\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"add user notification when rebirth is enabled","suites":["common.fns.updateStats","Stat Allocation"],"updatePoint":{"line":100,"column":53,"index":2967},"line":100,"code":"    it('add user notification when rebirth is enabled', () => {\n      user.stats.lvl = 51;\n      updateStats(user, {});\n      expect(user.addNotification).to.be.calledOnce;\n      expect(user.addNotification).to.be.calledWith('REBIRTH_ENABLED');\n    });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"for atom1","suites":["common.fns.updateStats","Stat Allocation","assigns flags.levelDrops"],"updatePoint":{"line":107,"column":19,"index":3234},"line":107,"code":"      it('for atom1', () => {\n        user.stats.lvl = 16;\n        user.flags.levelDrops.atom1 = false;\n        expect(user.items.quests.atom1).to.eql(undefined);\n        updateStats(user, {\n          atom1: true\n        });\n        expect(user.items.quests.atom1).to.eql(1);\n        expect(user.flags.levelDrops.atom1).to.eql(true);\n        updateStats(user, {\n          atom1: true\n        });\n        expect(user.items.quests.atom1).to.eql(1); // no change\n      });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"for vice1","suites":["common.fns.updateStats","Stat Allocation","assigns flags.levelDrops"],"updatePoint":{"line":121,"column":19,"index":3704},"line":121,"code":"      it('for vice1', () => {\n        user.stats.lvl = 31;\n        user.flags.levelDrops.vice1 = false;\n        expect(user.items.quests.vice1).to.eql(undefined);\n        updateStats(user, {\n          vice1: true\n        });\n        expect(user.items.quests.vice1).to.eql(1);\n        expect(user.flags.levelDrops.vice1).to.eql(true);\n        updateStats(user, {\n          vice1: true\n        });\n        expect(user.items.quests.vice1).to.eql(1);\n      });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"moonstone","suites":["common.fns.updateStats","Stat Allocation","assigns flags.levelDrops"],"updatePoint":{"line":135,"column":19,"index":4161},"line":135,"code":"      it('moonstone', () => {\n        user.stats.lvl = 60;\n        user.flags.levelDrops.moonstone1 = false;\n        expect(user.items.quests.moonstone1).to.eql(undefined);\n        updateStats(user, {\n          moonstone1: true\n        });\n        expect(user.flags.levelDrops.moonstone1).to.eql(true);\n        expect(user.items.quests.moonstone1).to.eql(1);\n        updateStats(user, {\n          moonstone1: true\n        });\n        expect(user.items.quests.moonstone1).to.eql(1);\n      });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"for goldenknight1","suites":["common.fns.updateStats","Stat Allocation","assigns flags.levelDrops"],"updatePoint":{"line":149,"column":27,"index":4661},"line":149,"code":"      it('for goldenknight1', () => {\n        user.stats.lvl = 40;\n        user.flags.levelDrops.goldenknight1 = false;\n        expect(user.items.quests.goldenknight1).to.eql(undefined);\n        updateStats(user, {\n          goldenknight1: true\n        });\n        expect(user.items.quests.goldenknight1).to.eql(1);\n        expect(user.flags.levelDrops.goldenknight1).to.eql(true);\n        updateStats(user, {\n          goldenknight1: true\n        });\n        expect(user.items.quests.goldenknight1).to.eql(1);\n      });","file":"common/fns/updateStats.test.js","skipped":false,"dir":"test"},{"name":"auto allocates stats if automaticAllocation is turned on","suites":["common.fns.updateStats","Stat Allocation","assigns flags.levelDrops"],"updatePoint":{"line":165,"column":65,"index":5260},"line":165,"code":"    xit('auto allocates stats if automaticAllocation is turned on', () => {\n      sandbox.stub(user.fns, 'autoAllocate');\n      const stats = {\n        exp: 261\n      };\n      user.stats.lvl = 10;\n      user.fns.updateStats(stats);\n      expect(user.fns.autoAllocate).to.be.calledOnce;\n    });","skipped":true,"file":"common/fns/updateStats.test.js","dir":"test"},{"name":"each category has 'label' and 'achievements' fields","suites":["achievements","general well-formedness"],"updatePoint":{"line":7,"column":63,"index":360},"line":7,"code":"    it('each category has \\'label\\' and \\'achievements\\' fields', () => {\n      _.each(achievements, category => {\n        expect(category).to.have.property('label').that.is.a('string');\n        expect(category).to.have.property('achievements').that.is.a('object');\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"each achievement has all required fields of correct types","suites":["achievements","general well-formedness"],"updatePoint":{"line":13,"column":65,"index":646},"line":13,"code":"    it('each achievement has all required fields of correct types', () => {\n      _.each(achievements, category => {\n        _.each(category.achievements, achiev => {\n          // May have additional fields (such as 'value' and 'optionalCount').\n          expect(achiev).to.contain.all.keys(['title', 'text', 'icon', 'earned', 'index']);\n          expect(achiev.title).to.be.a('string');\n          expect(achiev.text).to.be.a('string');\n          expect(achiev.icon).to.be.a('string');\n          expect(achiev.earned).to.be.a('boolean');\n          expect(achiev.index).to.be.a('number');\n        });\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"categories have unique labels","suites":["achievements","general well-formedness"],"updatePoint":{"line":26,"column":37,"index":1236},"line":26,"code":"    it('categories have unique labels', () => {\n      const achievementsArray = _.values(achievements).map(cat => cat.label);\n\n      const labels = _.uniq(achievementsArray);\n\n      expect(labels.length).to.be.greaterThan(0);\n      expect(labels.length).to.eql(_.size(achievements));\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"achievements have unique keys","suites":["achievements","general well-formedness"],"updatePoint":{"line":34,"column":37,"index":1528},"line":34,"code":"    it('achievements have unique keys', () => {\n      const keysSoFar = {};\n\n      _.each(achievements, category => {\n        _.keys(category.achievements).forEach(key => {\n          expect(keysSoFar[key]).to.be.undefined;\n          keysSoFar[key] = key;\n        });\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"achievements have unique indices","suites":["achievements","general well-formedness"],"updatePoint":{"line":44,"column":40,"index":1816},"line":44,"code":"    it('achievements have unique indices', () => {\n      const indicesSoFar = {};\n\n      _.each(achievements, category => {\n        _.each(category.achievements, achiev => {\n          const i = achiev.index;\n          expect(indicesSoFar[i]).to.be.undefined;\n          indicesSoFar[i] = i;\n        });\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"all categories have at least 1 achievement","suites":["achievements","general well-formedness"],"updatePoint":{"line":55,"column":50,"index":2146},"line":55,"code":"    it('all categories have at least 1 achievement', () => {\n      _.each(achievements, category => {\n        expect(_.size(category.achievements)).to.be.greaterThan(0);\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"streak and perfect day achievements exist with counts","suites":["achievements","unearned basic achievements"],"updatePoint":{"line":64,"column":61,"index":2531},"line":64,"code":"    it('streak and perfect day achievements exist with counts', () => {\n      const {\n        streak\n      } = basicAchievs;\n      const {\n        perfect\n      } = basicAchievs;\n      expect(streak).to.exist;\n      expect(streak).to.have.property('optionalCount').that.is.a('number');\n      expect(perfect).to.exist;\n      expect(perfect).to.have.property('optionalCount').that.is.a('number');\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"party up/on achievements exist with no counts","suites":["achievements","unearned basic achievements"],"updatePoint":{"line":76,"column":53,"index":2926},"line":76,"code":"    it('party up/on achievements exist with no counts', () => {\n      const {\n        partyUp\n      } = basicAchievs;\n      const {\n        partyOn\n      } = basicAchievs;\n      expect(partyUp).to.exist;\n      expect(partyUp.optionalCount).to.be.undefined;\n      expect(partyOn).to.exist;\n      expect(partyOn.optionalCount).to.be.undefined;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"pet/mount master and triad bingo achievements exist with counts","suites":["achievements","unearned basic achievements"],"updatePoint":{"line":88,"column":71,"index":3294},"line":88,"code":"    it('pet/mount master and triad bingo achievements exist with counts', () => {\n      const {\n        beastMaster\n      } = basicAchievs;\n      const {\n        mountMaster\n      } = basicAchievs;\n      const {\n        triadBingo\n      } = basicAchievs;\n      expect(beastMaster).to.exist;\n      expect(beastMaster).to.have.property('optionalCount').that.is.a('number');\n      expect(mountMaster).to.exist;\n      expect(mountMaster).to.have.property('optionalCount').that.is.a('number');\n      expect(triadBingo).to.exist;\n      expect(triadBingo).to.have.property('optionalCount').that.is.a('number');\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"ultimate gear achievements exist with no counts","suites":["achievements","unearned basic achievements"],"updatePoint":{"line":105,"column":55,"index":3890},"line":105,"code":"    it('ultimate gear achievements exist with no counts', () => {\n      const gearTypes = ['healer', 'rogue', 'warrior', 'mage'];\n      gearTypes.forEach(gear => {\n        const gearAchiev = basicAchievs[`${gear}UltimateGear`];\n        expect(gearAchiev).to.exist;\n        expect(gearAchiev.optionalCount).to.be.undefined;\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"card achievements exist with counts","suites":["achievements","unearned basic achievements"],"updatePoint":{"line":113,"column":43,"index":4219},"line":113,"code":"    it('card achievements exist with counts', () => {\n      const cardTypes = ['greeting', 'thankyou', 'birthday', 'congrats', 'getwell', 'goodluck'];\n      cardTypes.forEach(card => {\n        const cardAchiev = basicAchievs[`${card}Cards`];\n        expect(cardAchiev).to.exist;\n        expect(cardAchiev).to.have.property('optionalCount').that.is.a('number');\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"rebirth achievement exists with no count","suites":["achievements","unearned basic achievements"],"updatePoint":{"line":121,"column":48,"index":4603},"line":121,"code":"    it('rebirth achievement exists with no count', () => {\n      const {\n        rebirth\n      } = basicAchievs;\n      expect(rebirth).to.exist;\n      expect(rebirth.optionalCount).to.be.undefined;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"habiticaDays and habitBirthdays achievements exist with counts","suites":["achievements","unearned seasonal achievements"],"updatePoint":{"line":133,"column":70,"index":5073},"line":133,"code":"    it('habiticaDays and habitBirthdays achievements exist with counts', () => {\n      const {\n        habiticaDays\n      } = seasonalAchievs;\n      const {\n        habitBirthdays\n      } = seasonalAchievs;\n      expect(habiticaDays).to.exist;\n      expect(habiticaDays).to.have.property('optionalCount').that.is.a('number');\n      expect(habitBirthdays).to.exist;\n      expect(habitBirthdays).to.have.property('optionalCount').that.is.a('number');\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"spell achievements exist with counts","suites":["achievements","unearned seasonal achievements"],"updatePoint":{"line":145,"column":44,"index":5504},"line":145,"code":"    it('spell achievements exist with counts', () => {\n      const spellTypes = ['snowball', 'spookySparkles', 'shinySeed', 'seafoam'];\n      spellTypes.forEach(spell => {\n        const spellAchiev = seasonalAchievs[spell];\n        expect(spellAchiev).to.exist;\n        expect(spellAchiev).to.have.property('optionalCount').that.is.a('number');\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"quest achievements do not exist","suites":["achievements","unearned seasonal achievements"],"updatePoint":{"line":153,"column":39,"index":5862},"line":153,"code":"    it('quest achievements do not exist', () => {\n      const quests = ['dilatory', 'stressbeast', 'burnout', 'bewilder'];\n      quests.forEach(quest => {\n        const questAchiev = seasonalAchievs[`${quest}Quest`];\n        expect(questAchiev).to.not.exist;\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"costumeContests achievement exists with count","suites":["achievements","unearned seasonal achievements"],"updatePoint":{"line":160,"column":53,"index":6153},"line":160,"code":"    it('costumeContests achievement exists with count', () => {\n      const {\n        costumeContests\n      } = seasonalAchievs;\n      expect(costumeContests).to.exist;\n      expect(costumeContests).to.have.property('optionalCount').that.is.a('number');\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"card achievements exist with counts","suites":["achievements","unearned seasonal achievements"],"updatePoint":{"line":167,"column":43,"index":6405},"line":167,"code":"    it('card achievements exist with counts', () => {\n      const cardTypes = ['nye', 'valentine'];\n      cardTypes.forEach(card => {\n        const cardAchiev = seasonalAchievs[`${card}Cards`];\n        expect(cardAchiev).to.exist;\n        expect(cardAchiev).to.have.property('optionalCount').that.is.a('number');\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"habitSurveys achievement exists with count","suites":["achievements","unearned special achievements"],"updatePoint":{"line":179,"column":50,"index":6935},"line":179,"code":"    it('habitSurveys achievement exists with count', () => {\n      const {\n        habitSurveys\n      } = specialAchievs;\n      expect(habitSurveys).to.exist;\n      expect(habitSurveys).to.have.property('optionalCount').that.is.a('number');\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"contributor achievement exists with value and no count","suites":["achievements","unearned special achievements"],"updatePoint":{"line":186,"column":62,"index":7196},"line":186,"code":"    it('contributor achievement exists with value and no count', () => {\n      const {\n        contributor\n      } = specialAchievs;\n      expect(contributor).to.exist;\n      expect(contributor).to.have.property('value').that.is.a('number');\n      expect(contributor.optionalCount).to.be.undefined;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"npc achievement is hidden if unachieved","suites":["achievements","unearned special achievements"],"updatePoint":{"line":194,"column":47,"index":7488},"line":194,"code":"    it('npc achievement is hidden if unachieved', () => {\n      const {\n        npc\n      } = specialAchievs;\n      expect(npc).to.not.exist;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"kickstarter achievement is hidden if unachieved","suites":["achievements","unearned special achievements"],"updatePoint":{"line":200,"column":55,"index":7646},"line":200,"code":"    it('kickstarter achievement is hidden if unachieved', () => {\n      const {\n        kickstarter\n      } = specialAchievs;\n      expect(kickstarter).to.not.exist;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"veteran achievement is hidden if unachieved","suites":["achievements","unearned special achievements"],"updatePoint":{"line":206,"column":51,"index":7816},"line":206,"code":"    it('veteran achievement is hidden if unachieved', () => {\n      const {\n        veteran\n      } = specialAchievs;\n      expect(veteran).to.not.exist;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"originalUser achievement is hidden if unachieved","suites":["achievements","unearned special achievements"],"updatePoint":{"line":212,"column":56,"index":7983},"line":212,"code":"    it('originalUser achievement is hidden if unachieved', () => {\n      const {\n        originalUser\n      } = specialAchievs;\n      expect(originalUser).to.not.exist;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"created task achievement exists with no count","suites":["achievements","unearned onboarding achievements"],"updatePoint":{"line":222,"column":53,"index":8358},"line":222,"code":"    it('created task achievement exists with no count', () => {\n      const {\n        createdTask\n      } = onboardingAchievs;\n      expect(createdTask).to.exist;\n      expect(createdTask.optionalCount).to.be.undefined;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"completed task achievement exists with no count","suites":["achievements","unearned onboarding achievements"],"updatePoint":{"line":229,"column":55,"index":8588},"line":229,"code":"    it('completed task achievement exists with no count', () => {\n      const {\n        completedTask\n      } = onboardingAchievs;\n      expect(completedTask).to.exist;\n      expect(completedTask.optionalCount).to.be.undefined;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"hatched pet achievement exists with no count","suites":["achievements","unearned onboarding achievements"],"updatePoint":{"line":236,"column":52,"index":8821},"line":236,"code":"    it('hatched pet achievement exists with no count', () => {\n      const {\n        hatchedPet\n      } = onboardingAchievs;\n      expect(hatchedPet).to.exist;\n      expect(hatchedPet.optionalCount).to.be.undefined;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"fed pet achievement exists with no count","suites":["achievements","unearned onboarding achievements"],"updatePoint":{"line":243,"column":48,"index":9041},"line":243,"code":"    it('fed pet achievement exists with no count', () => {\n      const {\n        fedPet\n      } = onboardingAchievs;\n      expect(fedPet).to.exist;\n      expect(fedPet.optionalCount).to.be.undefined;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"purchased equipment achievement exists with no count","suites":["achievements","unearned onboarding achievements"],"updatePoint":{"line":250,"column":60,"index":9261},"line":250,"code":"    it('purchased equipment achievement exists with no count', () => {\n      const {\n        purchasedEquipment\n      } = onboardingAchievs;\n      expect(purchasedEquipment).to.exist;\n      expect(purchasedEquipment.optionalCount).to.be.undefined;\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"quest achievements exist","suites":["achievements","earned seasonal achievements"],"updatePoint":{"line":266,"column":32,"index":9881},"line":266,"code":"    it('quest achievements exist', () => {\n      quests.forEach(quest => {\n        const questAchiev = seasonalAchievs[`${quest}Quest`];\n        expect(questAchiev).to.exist;\n        expect(questAchiev.optionalCount).to.be.undefined;\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"habitSurveys achievement is earned with correct value","suites":["achievements","earned special achievements"],"updatePoint":{"line":289,"column":61,"index":10552},"line":289,"code":"    it('habitSurveys achievement is earned with correct value', () => {\n      const {\n        habitSurveys\n      } = specialAchievs;\n      expect(habitSurveys).to.exist;\n      expect(habitSurveys.earned).to.eql(true);\n      expect(habitSurveys.value).to.eql(2);\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"contributor achievement is earned with correct value","suites":["achievements","earned special achievements"],"updatePoint":{"line":297,"column":60,"index":10821},"line":297,"code":"    it('contributor achievement is earned with correct value', () => {\n      const {\n        contributor\n      } = specialAchievs;\n      expect(contributor).to.exist;\n      expect(contributor.earned).to.eql(true);\n      expect(contributor.value).to.eql(1);\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"npc achievement is earned with correct value","suites":["achievements","earned special achievements"],"updatePoint":{"line":305,"column":52,"index":11078},"line":305,"code":"    it('npc achievement is earned with correct value', () => {\n      const npcUser = generateUser({\n        backer: {\n          npc: 'test'\n        }\n      });\n      const {\n        npc\n      } = shared.achievements.getAchievementsForProfile(npcUser).special.achievements;\n      expect(npc).to.exist;\n      expect(npc.earned).to.eql(true);\n      expect(npc.value).to.eql('test');\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"kickstarter achievement is earned with correct value","suites":["achievements","earned special achievements"],"updatePoint":{"line":318,"column":60,"index":11474},"line":318,"code":"    it('kickstarter achievement is earned with correct value', () => {\n      const {\n        kickstarter\n      } = specialAchievs;\n      expect(kickstarter).to.exist;\n      expect(kickstarter.earned).to.eql(true);\n      expect(kickstarter.value).to.eql(3);\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"veteran achievement is earned","suites":["achievements","earned special achievements"],"updatePoint":{"line":326,"column":37,"index":11716},"line":326,"code":"    it('veteran achievement is earned', () => {\n      const {\n        veteran\n      } = specialAchievs;\n      expect(veteran).to.exist;\n      expect(veteran.earned).to.eql(true);\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"originalUser achievement is earned","suites":["achievements","earned special achievements"],"updatePoint":{"line":333,"column":42,"index":11908},"line":333,"code":"    it('originalUser achievement is earned', () => {\n      const {\n        originalUser\n      } = specialAchievs;\n      expect(originalUser).to.exist;\n      expect(originalUser.earned).to.eql(true);\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"master and triad bingo achievements do not include *Text2 strings if no keys have been used","suites":["achievements","mountMaster, beastMaster, and triadBingo achievements"],"updatePoint":{"line":342,"column":99,"index":12254},"line":342,"code":"    it('master and triad bingo achievements do not include *Text2 strings if no keys have been used', () => {\n      const user = generateUser();\n      const basicAchievs = shared.achievements.getAchievementsForProfile(user).basic.achievements;\n      const {\n        beastMaster\n      } = basicAchievs;\n      const {\n        mountMaster\n      } = basicAchievs;\n      const {\n        triadBingo\n      } = basicAchievs;\n      expect(beastMaster.text).to.not.match(/released/);\n      expect(beastMaster.text).to.not.match(/0 time\\(s\\)/);\n      expect(mountMaster.text).to.not.match(/released/);\n      expect(mountMaster.text).to.not.match(/0 time\\(s\\)/);\n      expect(triadBingo.text).to.not.match(/released/);\n      expect(triadBingo.text).to.not.match(/0 time\\(s\\)/);\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"master and triad bingo achievements includes *Text2 strings if keys have been used","suites":["achievements","mountMaster, beastMaster, and triadBingo achievements"],"updatePoint":{"line":361,"column":90,"index":13019},"line":361,"code":"    it('master and triad bingo achievements includes *Text2 strings if keys have been used', () => {\n      const user = generateUser({\n        achievements: {\n          beastMasterCount: 1,\n          mountMasterCount: 2,\n          triadBingoCount: 3\n        }\n      });\n      const basicAchievs = shared.achievements.getAchievementsForProfile(user).basic.achievements;\n      const {\n        beastMaster\n      } = basicAchievs;\n      const {\n        mountMaster\n      } = basicAchievs;\n      const {\n        triadBingo\n      } = basicAchievs;\n      expect(beastMaster.text).to.match(/released/);\n      expect(beastMaster.text).to.match(/1 time\\(s\\)/);\n      expect(mountMaster.text).to.match(/released/);\n      expect(mountMaster.text).to.match(/2 time\\(s\\)/);\n      expect(triadBingo.text).to.match(/released/);\n      expect(triadBingo.text).to.match(/3 time\\(s\\)/);\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"title and text contain localized class info","suites":["achievements","ultimateGear achievements"],"updatePoint":{"line":388,"column":51,"index":13909},"line":388,"code":"    it('title and text contain localized class info', () => {\n      const user = generateUser();\n      const basicAchievs = shared.achievements.getAchievementsForProfile(user).basic.achievements;\n      const gearTypes = ['healer', 'rogue', 'warrior', 'mage'];\n      gearTypes.forEach(gear => {\n        const gearAchiev = basicAchievs[`${gear}UltimateGear`];\n        const classNameRegex = new RegExp(gear.charAt(0).toUpperCase() + gear.slice(1));\n        expect(gearAchiev.title).to.match(classNameRegex);\n        expect(gearAchiev.text).to.match(classNameRegex);\n      });\n    });","file":"common/libs/achievements.test.js","skipped":false,"dir":"test"},{"name":"returns the tasks","suites":["appliedTags"],"updatePoint":{"line":3,"column":23,"index":131},"line":3,"code":"  it('returns the tasks', () => {\n    const userTags = [{\n      id: 'tag1',\n      name: 'tag 1'\n    }, {\n      id: 'tag2',\n      name: 'tag 2'\n    }, {\n      id: 'tag3',\n      name: 'tag 3'\n    }];\n    const taskTags = ['tag2', 'tag3'];\n    const result = appliedTags(userTags, taskTags);\n    expect(result).to.eql('tag 2, tag 3');\n  });","file":"common/libs/appliedTags.test.js","skipped":false,"dir":"test"},{"name":"is zero when no daystart configured","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":10,"column":43,"index":348},"line":10,"code":"    it('is zero when no daystart configured', () => {\n      const options = {\n        now: moment('2020-02-02 09:30:00Z'),\n        timezoneOffset: 0\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment('2020-02-02 00:00:00Z');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"is zero when negative daystart configured","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":18,"column":49,"index":625},"line":18,"code":"    it('is zero when negative daystart configured', () => {\n      const options = {\n        now: moment('2020-02-02 09:30:00Z'),\n        timezoneOffset: 0,\n        daystart: -5\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment('2020-02-02 00:00:00Z');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"is zero when daystart over 24 is configured","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":27,"column":51,"index":926},"line":27,"code":"    it('is zero when daystart over 24 is configured', () => {\n      const options = {\n        now: moment('2020-02-02 09:30:00Z'),\n        timezoneOffset: 0,\n        daystart: 25\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment('2020-02-02 00:00:00Z');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"is equal to daystart o'clock when daystart configured","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":36,"column":62,"index":1238},"line":36,"code":"    it('is equal to daystart o\\'clock when daystart configured', () => {\n      const options = {\n        now: moment('2020-02-02 09:30:00Z'),\n        timezoneOffset: 0,\n        dayStart: 5\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment('2020-02-02 05:00:00Z');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"is previous day daystart o'clock when daystart is after current time","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":45,"column":77,"index":1564},"line":45,"code":"    it('is previous day daystart o\\'clock when daystart is after current time', () => {\n      const options = {\n        now: moment('2020-02-02 04:30:00Z'),\n        timezoneOffset: 0,\n        dayStart: 5\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment('2020-02-01 05:00:00Z');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"is daystart o'clock when daystart is after current time due to timezone","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":54,"column":80,"index":1893},"line":54,"code":"    it('is daystart o\\'clock when daystart is after current time due to timezone', () => {\n      const options = {\n        now: moment('2020-02-02 04:30:00Z'),\n        timezoneOffset: -120,\n        dayStart: 5\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment('2020-02-02 05:00:00+02:00');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"returns in default timezone if no timezone defined","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":63,"column":58,"index":2208},"line":63,"code":"    it('returns in default timezone if no timezone defined', () => {\n      const utcOffset = moment().utcOffset();\n      const now = localMoment('2020-02-02 04:30:00', utcOffset).utc();\n      const result = startOfDay({\n        now\n      });\n      expect(result).to.be.sameMoment(localMoment('2020-02-02', utcOffset));\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"returns in default timezone if timezone lower than -12:00","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":71,"column":65,"index":2542},"line":71,"code":"    it('returns in default timezone if timezone lower than -12:00', () => {\n      const utcOffset = moment().utcOffset();\n      const options = {\n        now: localMoment('2020-02-02 17:30:00', utcOffset).utc(),\n        timezoneOffset: 721\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment(localMoment('2020-02-02', utcOffset));\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"returns in default timezone if timezone higher than +14:00","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":80,"column":66,"index":2919},"line":80,"code":"    it('returns in default timezone if timezone higher than +14:00', () => {\n      const utcOffset = moment().utcOffset();\n      const options = {\n        now: localMoment('2020-02-02 07:32:25.376', utcOffset).utc(),\n        timezoneOffset: -841\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment(localMoment('2020-02-02', utcOffset));\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"returns in overridden timezone if override present","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":89,"column":58,"index":3293},"line":89,"code":"    it('returns in overridden timezone if override present', () => {\n      const options = {\n        now: moment('2020-02-02 13:30:27Z'),\n        timezoneOffset: 0,\n        timezoneUtcOffsetOverride: -240\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment('2020-02-02 00:00:00-04:00');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"returns start of yesterday if timezone difference carries it over datelines","suites":["cron utility functions","startOfDay"],"updatePoint":{"line":98,"column":83,"index":3650},"line":98,"code":"    it('returns start of yesterday if timezone difference carries it over datelines', () => {\n      const offset = 300;\n      const options = {\n        now: moment('2020-02-02 04:30:00Z'),\n        timezoneOffset: offset\n      };\n      const result = startOfDay(options);\n      expect(result).to.be.sameMoment(localMoment('2020-02-01', -offset));\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"correctly calculates days between two dates","suites":["cron utility functions","daysSince"],"updatePoint":{"line":109,"column":51,"index":4010},"line":109,"code":"    it('correctly calculates days between two dates', () => {\n      const now = moment();\n      const dayBeforeYesterday = moment(now).subtract({\n        days: 2\n      });\n      expect(daysSince(dayBeforeYesterday, {\n        now\n      })).to.equal(2);\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"is one lower if current time is before dayStart","suites":["cron utility functions","daysSince"],"updatePoint":{"line":118,"column":55,"index":4274},"line":118,"code":"    it('is one lower if current time is before dayStart', () => {\n      const oneWeekAgoAtOnePm = moment().hour(13).subtract({\n        days: 7\n      });\n      const thisMorningThreeAm = moment().hour(3);\n      const options = {\n        now: thisMorningThreeAm,\n        dayStart: 6\n      };\n      const result = daysSince(oneWeekAgoAtOnePm, options);\n      expect(result).to.equal(6);\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"is one higher if reference time is before dayStart and current time after dayStart","suites":["cron utility functions","daysSince"],"updatePoint":{"line":130,"column":90,"index":4701},"line":130,"code":"    it('is one higher if reference time is before dayStart and current time after dayStart', () => {\n      const oneWeekAgoAtEightAm = moment().hour(8).subtract({\n        days: 7\n      });\n      const todayAtFivePm = moment().hour(17);\n      const options = {\n        now: todayAtFivePm,\n        dayStart: 11\n      };\n      const result = daysSince(oneWeekAgoAtEightAm, options);\n      expect(result).to.equal(8);\n    }); // Variations in timezone configuration options are already covered by startOfDay tests.","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"uses now in user timezone as configured in options","suites":["cron utility functions","daysSince"],"updatePoint":{"line":143,"column":58,"index":5181},"line":143,"code":"    it('uses now in user timezone as configured in options', () => {\n      const timezoneOffset = 120;\n      const options = {\n        now: moment('1989-11-09 02:53:00+01:00'),\n        timezoneOffset\n      };\n      const result = daysSince(localMoment('1989-11-08', -timezoneOffset), options);\n      expect(result).to.equal(0);\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"offset 0, next date in 3 months","suites":["cron utility functions","getPlanContext"],"updatePoint":{"line":184,"column":39,"index":6364},"line":184,"code":"    it('offset 0, next date in 3 months', () => {\n      const user = baseUserData(60, 0, 'group_plan_auto');\n      const planContext = getPlanContext(user, now);\n      expect(planContext.nextHourglassDate).to.be.sameMoment('2022-08-10T02:00:00.144Z');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"offset 1, next date in 1 months","suites":["cron utility functions","getPlanContext"],"updatePoint":{"line":189,"column":39,"index":6624},"line":189,"code":"    it('offset 1, next date in 1 months', () => {\n      const user = baseUserData(60, 1, 'group_plan_auto');\n      const planContext = getPlanContext(user, now);\n      expect(planContext.nextHourglassDate).to.be.sameMoment('2022-06-10T02:00:00.144Z');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"offset 2, next date in 2 months - with any plan","suites":["cron utility functions","getPlanContext"],"updatePoint":{"line":194,"column":55,"index":6900},"line":194,"code":"    it('offset 2, next date in 2 months - with any plan', () => {\n      const user = baseUserData(60, 2, 'basic_3mo');\n      const planContext = getPlanContext(user, now);\n      expect(planContext.nextHourglassDate).to.be.sameMoment('2022-07-10T02:00:00.144Z');\n    });","file":"common/libs/cron.test.js","skipped":false,"dir":"test"},{"name":"Should return the  on  buff","suites":["getDebuffPotionItems"],"updatePoint":{"line":17,"column":50,"index":772},"line":17,"code":"    it(`Should return the ${debuff} on ${key} buff`, () => {\n      user.stats.buffs[key] = true;\n      const result = getDebuffPotionItems(user);\n      expect(result).to.be.an('array').that.deep.includes({\n        path: `spells.special.${debuff}`,\n        type: 'debuffPotion'\n      });\n    });","file":"common/libs/getDebuffPotionItems.test.js","skipped":false,"dir":"test"},{"name":"Should return all debuff potions for all buffs","suites":["getDebuffPotionItems"],"updatePoint":{"line":27,"column":52,"index":1074},"line":27,"code":"  it('Should return all debuff potions for all buffs', () => {\n    user.stats.buffs.seafoam = true;\n    user.stats.buffs.spookySparkles = true;\n    user.stats.buffs.snowball = true;\n    user.stats.buffs.shinySeed = true;\n    const result = getDebuffPotionItems(user);\n    expect(result).to.be.an('array').that.deep.include.members([{\n      path: 'spells.special.sand',\n      type: 'debuffPotion'\n    }, {\n      path: 'spells.special.petalFreePotion',\n      type: 'debuffPotion'\n    }, {\n      path: 'spells.special.salt',\n      type: 'debuffPotion'\n    }, {\n      path: 'spells.special.opaquePotion',\n      type: 'debuffPotion'\n    }]);\n  });","file":"common/libs/getDebuffPotionItems.test.js","skipped":false,"dir":"test"},{"name":"is 0","suites":["gold"],"updatePoint":{"line":3,"column":10,"index":97},"line":3,"code":"  it('is 0', () => {\n    expect(gold()).to.eql('0');\n  });","file":"common/libs/gold.test.js","skipped":false,"dir":"test"},{"name":"is 5 in 5.2 of gold","suites":["gold"],"updatePoint":{"line":6,"column":25,"index":171},"line":6,"code":"  it('is 5 in 5.2 of gold', () => {\n    expect(gold(5.2)).to.eql(5);\n  });","file":"common/libs/gold.test.js","skipped":false,"dir":"test"},{"name":"returns false for user with level below 10","suites":["hasClass"],"updatePoint":{"line":4,"column":48,"index":207},"line":4,"code":"  it('returns false for user with level below 10', () => {\n    const userLvl9 = generateUser({\n      'stats.lvl': 9,\n      'flags.classSelected': true,\n      'preferences.disableClasses': false\n    });\n    const result = hasClass(userLvl9);\n    expect(result).to.eql(false);\n  });","file":"common/libs/hasClass.test.js","skipped":false,"dir":"test"},{"name":"returns false for user with class not selected","suites":["hasClass"],"updatePoint":{"line":13,"column":52,"index":492},"line":13,"code":"  it('returns false for user with class not selected', () => {\n    const userClassNotSelected = generateUser({\n      'stats.lvl': 10,\n      'flags.classSelected': false,\n      'preferences.disableClasses': false\n    });\n    const result = hasClass(userClassNotSelected);\n    expect(result).to.eql(false);\n  });","file":"common/libs/hasClass.test.js","skipped":false,"dir":"test"},{"name":"returns false for user with classes disabled","suites":["hasClass"],"updatePoint":{"line":22,"column":50,"index":801},"line":22,"code":"  it('returns false for user with classes disabled', () => {\n    const userClassesDisabled = generateUser({\n      'stats.lvl': 10,\n      'flags.classSelected': true,\n      'preferences.disableClasses': true\n    });\n    const result = hasClass(userClassesDisabled);\n    expect(result).to.eql(false);\n  });","file":"common/libs/hasClass.test.js","skipped":false,"dir":"test"},{"name":"returns true for user with class","suites":["hasClass"],"updatePoint":{"line":31,"column":38,"index":1094},"line":31,"code":"  it('returns true for user with class', () => {\n    const userClassSelected = generateUser({\n      'stats.lvl': 10,\n      'flags.classSelected': true,\n      'preferences.disableClasses': false\n    });\n    const result = hasClass(userClassSelected);\n    expect(result).to.eql(true);\n  });","file":"common/libs/hasClass.test.js","skipped":false,"dir":"test"},{"name":"returns true for no tags","suites":["noTags"],"updatePoint":{"line":3,"column":30,"index":123},"line":3,"code":"  it('returns true for no tags', () => {\n    const result = noTags([]);\n    expect(result).to.eql(true);\n  });","file":"common/libs/noTags.test.js","skipped":false,"dir":"test"},{"name":"returns false for some tags","suites":["noTags"],"updatePoint":{"line":7,"column":33,"index":237},"line":7,"code":"  it('returns false for some tags', () => {\n    const result = noTags(['a', 'b', 'c']);\n    expect(result).to.eql(false);\n  });","file":"common/libs/noTags.test.js","skipped":false,"dir":"test"},{"name":"returns false if no achievement has been awarded","suites":["onboarding","hasCompletedOnboarding"],"updatePoint":{"line":13,"column":56,"index":567},"line":13,"code":"    it('returns false if no achievement has been awarded', () => {\n      const result = hasCompletedOnboarding(user);\n      expect(result).to.eql(false);\n    });","file":"common/libs/onboarding.test.js","skipped":false,"dir":"test"},{"name":"returns false if not all achievements have been awarded","suites":["onboarding","hasCompletedOnboarding"],"updatePoint":{"line":17,"column":63,"index":736},"line":17,"code":"    it('returns false if not all achievements have been awarded', () => {\n      user.achievements.completedTask = true;\n      const result = hasCompletedOnboarding(user);\n      expect(result).to.eql(false);\n    });","file":"common/libs/onboarding.test.js","skipped":false,"dir":"test"},{"name":"returns true if all achievements have been awarded","suites":["onboarding","hasCompletedOnboarding"],"updatePoint":{"line":22,"column":58,"index":946},"line":22,"code":"    it('returns true if all achievements have been awarded', () => {\n      user.achievements.createdTask = true;\n      user.achievements.completedTask = true;\n      user.achievements.hatchedPet = true;\n      user.achievements.fedPet = true;\n      user.achievements.purchasedEquipment = true;\n      const result = hasCompletedOnboarding(user);\n      expect(result).to.eql(true);\n    });","file":"common/libs/onboarding.test.js","skipped":false,"dir":"test"},{"name":"awards prizes","suites":["onboarding","onOnboardingComplete"],"updatePoint":{"line":33,"column":21,"index":1344},"line":33,"code":"    it('awards prizes', () => {\n      const {\n        gp\n      } = user.stats;\n      onOnboardingComplete(user);\n      expect(user.stats.gp).to.eql(gp + 100);\n    });","file":"common/libs/onboarding.test.js","skipped":false,"dir":"test"},{"name":"does nothing if onboarding is not active","suites":["onboarding","checkOnboardingStatus"],"updatePoint":{"line":42,"column":48,"index":1588},"line":42,"code":"    it('does nothing if onboarding is not active', () => {\n      const {\n        gp\n      } = user.stats;\n      user.auth.timestamps.created = moment('2019-12-01').toDate();\n      checkOnboardingStatus(user);\n      expect(user.addNotification).to.not.be.called;\n      expect(user.stats.gp).to.eql(gp);\n    });","file":"common/libs/onboarding.test.js","skipped":false,"dir":"test"},{"name":"does nothing if onboarding is not complete","suites":["onboarding","checkOnboardingStatus"],"updatePoint":{"line":51,"column":50,"index":1900},"line":51,"code":"    it('does nothing if onboarding is not complete', () => {\n      const {\n        gp\n      } = user.stats;\n      checkOnboardingStatus(user);\n      expect(user.addNotification).to.not.be.called;\n      expect(user.stats.gp).to.eql(gp);\n    });","file":"common/libs/onboarding.test.js","skipped":false,"dir":"test"},{"name":"awards prize and add notification when onboarding is complete","suites":["onboarding","checkOnboardingStatus"],"updatePoint":{"line":59,"column":69,"index":2163},"line":59,"code":"    it('awards prize and add notification when onboarding is complete', () => {\n      user.achievements.createdTask = true;\n      user.achievements.completedTask = true;\n      user.achievements.hatchedPet = true;\n      user.achievements.fedPet = true;\n      user.achievements.purchasedEquipment = true;\n      const {\n        gp\n      } = user.stats;\n      checkOnboardingStatus(user);\n      expect(user.addNotification).to.be.calledOnce;\n      expect(user.addNotification).to.be.calledWith('ONBOARDING_COMPLETE');\n      expect(user.stats.gp).to.eql(gp + 100);\n    });","file":"common/libs/onboarding.test.js","skipped":false,"dir":"test"},{"name":"with direction \"up\"","suites":["percent"],"updatePoint":{"line":3,"column":25,"index":121},"line":3,"code":"  it('with direction \"up\"', () => {\n    expect(percent(1, 10, 'up')).to.eql(10);\n    expect(percent(1, 20, 'up')).to.eql(5);\n    expect(percent(1.22, 10.99, 'up')).to.eql(12);\n  });","file":"common/libs/percent.test.js","skipped":false,"dir":"test"},{"name":"with direction \"down\"","suites":["percent"],"updatePoint":{"line":8,"column":27,"index":305},"line":8,"code":"  it('with direction \"down\"', () => {\n    expect(percent(1, 10, 'down')).to.eql(10);\n    expect(percent(1, 20, 'down')).to.eql(5);\n    expect(percent(1.22, 10.99, 'down')).to.eql(11);\n  });","file":"common/libs/percent.test.js","skipped":false,"dir":"test"},{"name":"with no direction","suites":["percent"],"updatePoint":{"line":13,"column":23,"index":491},"line":13,"code":"  it('with no direction', () => {\n    expect(percent(1.22, 10.99)).to.eql(11);\n  });","file":"common/libs/percent.test.js","skipped":false,"dir":"test"},{"name":"Should push the debuff item to pinned items of user","suites":["setDebuffPotionItems"],"updatePoint":{"line":8,"column":57,"index":318},"line":8,"code":"  it('Should push the debuff item to pinned items of user', () => {\n    user.stats.buffs.spookySparkles = true;\n    const previousPinnedItemsLength = user.pinnedItems.length;\n    const result = setDebuffPotionItems(user);\n    expect(result.pinnedItems.length).to.be.greaterThan(previousPinnedItemsLength);\n  });","file":"common/libs/setDebuffPotionItems.test.js","skipped":false,"dir":"test"},{"name":"Shouldn't create duplicate of already added debuff potion","suites":["setDebuffPotionItems"],"updatePoint":{"line":14,"column":64,"index":637},"line":14,"code":"  it('Shouldn\\'t create duplicate of already added debuff potion', () => {\n    user.stats.buffs.spookySparkles = true;\n    const firstSetResult = [...setDebuffPotionItems(user).pinnedItems];\n    const secondSetResult = [...setDebuffPotionItems(user).pinnedItems];\n    expect(firstSetResult).to.be.deep.equal(secondSetResult);\n  });","file":"common/libs/setDebuffPotionItems.test.js","skipped":false,"dir":"test"},{"name":"Should remove all debuff items from pinnedItems of the user if user have no buffs","suites":["setDebuffPotionItems"],"updatePoint":{"line":20,"column":87,"index":992},"line":20,"code":"  it('Should remove all debuff items from pinnedItems of the user if user have no buffs', () => {\n    user.stats.buffs.seafoam = true;\n    user.stats.buffs.spookySparkles = true;\n    user.stats.buffs.snowball = true;\n    user.stats.buffs.shinySeed = true;\n    const firstSetResult = [...setDebuffPotionItems(user).pinnedItems];\n    expect(firstSetResult).to.have.lengthOf(4);\n    user.stats.buffs.seafoam = false;\n    user.stats.buffs.spookySparkles = false;\n    user.stats.buffs.snowball = false;\n    user.stats.buffs.shinySeed = false;\n    const secondSetResult = [...setDebuffPotionItems(user).pinnedItems];\n    expect(secondSetResult).to.have.lengthOf(0);\n  });","file":"common/libs/setDebuffPotionItems.test.js","skipped":false,"dir":"test"},{"name":"is 0","suites":["silver"],"updatePoint":{"line":3,"column":10,"index":103},"line":3,"code":"  it('is 0', () => {\n    expect(silver(0)).to.eql('00');\n  });","file":"common/libs/silver.test.js","skipped":false,"dir":"test"},{"name":"20 coins in 5.2 of gold: two decimal places","suites":["silver"],"updatePoint":{"line":6,"column":49,"index":205},"line":6,"code":"  it('20 coins in 5.2 of gold: two decimal places', () => {\n    expect(silver(5.2)).to.eql('20');\n  });","file":"common/libs/silver.test.js","skipped":false,"dir":"test"},{"name":"4 coint in 5.04 of gold: one decimal place","suites":["silver"],"updatePoint":{"line":9,"column":48,"index":308},"line":9,"code":"  it('4 coint in 5.04 of gold: one decimal place', () => {\n    expect(silver(5.04)).to.eql('04');\n  });","file":"common/libs/silver.test.js","skipped":false,"dir":"test"},{"name":"is no value","suites":["silver"],"updatePoint":{"line":12,"column":17,"index":381},"line":12,"code":"  it('is no value', () => {\n    expect(silver()).to.eql('00');\n  });","file":"common/libs/silver.test.js","skipped":false,"dir":"test"},{"name":"returns an array","suites":["splitWhitespace"],"updatePoint":{"line":3,"column":22,"index":142},"line":3,"code":"  it('returns an array', () => {\n    expect(splitWhitespace('a b')).to.eql(['a', 'b']);\n  });","file":"common/libs/splitWhitespace.test.js","skipped":false,"dir":"test"},{"name":"applies defaults to undefined type or habit","suites":["taskDefaults"],"updatePoint":{"line":6,"column":49,"index":325},"line":6,"code":"  it('applies defaults to undefined type or habit', () => {\n    const task = taskDefaults({}, generateUser());\n    expect(task.type).to.eql('habit');\n    expect(task._id).to.exist;\n    expect(task.text).to.eql(task._id);\n    expect(task.tags).to.eql([]);\n    expect(task.value).to.eql(0);\n    expect(task.priority).to.eql(1);\n    expect(task.up).to.eql(true);\n    expect(task.down).to.eql(true);\n    expect(task.history).to.eql([]);\n    expect(task.frequency).to.equal('daily');\n    expect(task.counterUp).to.equal(0);\n    expect(task.counterDown).to.equal(0);\n  });","file":"common/libs/taskDefaults.test.js","skipped":false,"dir":"test"},{"name":"applies defaults to a daily","suites":["taskDefaults"],"updatePoint":{"line":21,"column":33,"index":876},"line":21,"code":"  it('applies defaults to a daily', () => {\n    const task = taskDefaults({\n      type: 'daily'\n    }, generateUser());\n    expect(task.type).to.eql('daily');\n    expect(task._id).to.exist;\n    expect(task.text).to.eql(task._id);\n    expect(task.tags).to.eql([]);\n    expect(task.value).to.eql(0);\n    expect(task.priority).to.eql(1);\n    expect(task.history).to.eql([]);\n    expect(task.completed).to.eql(false);\n    expect(task.streak).to.eql(0);\n    expect(task.repeat).to.eql({\n      m: true,\n      t: true,\n      w: true,\n      th: true,\n      f: true,\n      s: true,\n      su: true\n    });\n    expect(task.frequency).to.eql('weekly');\n    expect(task.startDate).to.exist;\n  });","file":"common/libs/taskDefaults.test.js","skipped":false,"dir":"test"},{"name":"applies defaults a reward","suites":["taskDefaults"],"updatePoint":{"line":46,"column":31,"index":1558},"line":46,"code":"  it('applies defaults a reward', () => {\n    const task = taskDefaults({\n      type: 'reward'\n    }, generateUser());\n    expect(task.type).to.eql('reward');\n    expect(task._id).to.exist;\n    expect(task.text).to.eql(task._id);\n    expect(task.tags).to.eql([]);\n    expect(task.value).to.eql(10);\n    expect(task.priority).to.eql(1);\n  });","file":"common/libs/taskDefaults.test.js","skipped":false,"dir":"test"},{"name":"applies defaults a todo","suites":["taskDefaults"],"updatePoint":{"line":57,"column":29,"index":1898},"line":57,"code":"  it('applies defaults a todo', () => {\n    const task = taskDefaults({\n      type: 'todo'\n    }, generateUser());\n    expect(task.type).to.eql('todo');\n    expect(task._id).to.exist;\n    expect(task.text).to.eql(task._id);\n    expect(task.tags).to.eql([]);\n    expect(task.value).to.eql(0);\n    expect(task.priority).to.eql(1);\n    expect(task.completed).to.eql(false);\n  });","file":"common/libs/taskDefaults.test.js","skipped":false,"dir":"test"},{"name":"starts a task yesterday if user cron is later today","suites":["taskDefaults"],"updatePoint":{"line":69,"column":57,"index":2303},"line":69,"code":"  it('starts a task yesterday if user cron is later today', () => {\n    // Configure to have a day start that's *always* tomorrow.\n    const user = generateUser({\n      'preferences.dayStart': 25\n    });\n    const task = taskDefaults({\n      type: 'daily'\n    }, user);\n    expect(task.startDate).to.eql(moment().utcOffset(getUtcOffset(user)).startOf('day').subtract(1, 'day').toDate());\n  });","file":"common/libs/taskDefaults.test.js","skipped":false,"dir":"test"},{"name":"validates uuid","suites":["shared.ops.blockUser"],"updatePoint":{"line":14,"column":20,"index":464},"line":14,"code":"  it('validates uuid', done => {\n    try {\n      blockUser(user, {\n        params: {\n          uuid: '1'\n        }\n      });\n    } catch (error) {\n      expect(error.message).to.eql(i18n.t('invalidUUID'));\n      done();\n    }\n  });","file":"common/ops/blockUser.test.js","skipped":false,"dir":"test"},{"name":"validates user can't block himself","suites":["shared.ops.blockUser"],"updatePoint":{"line":26,"column":41,"index":717},"line":26,"code":"  it('validates user can\\'t block himself', done => {\n    try {\n      blockUser(user, {\n        params: {\n          uuid: user._id\n        }\n      });\n    } catch (error) {\n      expect(error.message).to.eql(i18n.t('blockYourself'));\n      done();\n    }\n  });","file":"common/ops/blockUser.test.js","skipped":false,"dir":"test"},{"name":"blocks user","suites":["shared.ops.blockUser"],"updatePoint":{"line":38,"column":17,"index":953},"line":38,"code":"  it('blocks user', () => {\n    let [result] = blockUser(user, {\n      params: {\n        uuid: blockedUser._id\n      }\n    });\n    expect(user.inbox.blocks).to.eql([blockedUser._id]);\n    expect(result).to.eql([blockedUser._id]);\n    [result] = blockUser(user, {\n      params: {\n        uuid: blockedUser2._id\n      }\n    });\n    expect(user.inbox.blocks).to.eql([blockedUser._id, blockedUser2._id]);\n    expect(result).to.eql([blockedUser._id, blockedUser2._id]);\n  });","file":"common/ops/blockUser.test.js","skipped":false,"dir":"test"},{"name":"blocks, then unblocks user","suites":["shared.ops.blockUser"],"updatePoint":{"line":54,"column":32,"index":1439},"line":54,"code":"  it('blocks, then unblocks user', () => {\n    blockUser(user, {\n      params: {\n        uuid: blockedUser._id\n      }\n    });\n    expect(user.inbox.blocks).to.eql([blockedUser._id]);\n    const [result] = blockUser(user, {\n      params: {\n        uuid: blockedUser._id\n      }\n    });\n    expect(user.inbox.blocks).to.eql([]);\n    expect(result).to.eql([]);\n  });","file":"common/ops/blockUser.test.js","skipped":false,"dir":"test"},{"name":"throws an error when scoring a reward if user does not have enough gold","suites":["shared.ops.scoreTask"],"updatePoint":{"line":50,"column":77,"index":1835},"line":50,"code":"  it('throws an error when scoring a reward if user does not have enough gold', done => {\n    const reward = generateReward({\n      userId: ref.afterUser._id,\n      text: 'some reward',\n      value: 100\n    });\n\n    try {\n      scoreTask({\n        user: ref.afterUser,\n        task: reward\n      });\n    } catch (err) {\n      expect(err).to.be.an.instanceof(NotAuthorized);\n      expect(err.message).to.eql(i18n.t('messageNotEnoughGold'));\n      done();\n    }\n  });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"completes when the task direction is up","suites":["shared.ops.scoreTask"],"updatePoint":{"line":68,"column":45,"index":2269},"line":68,"code":"  it('completes when the task direction is up', () => {\n    const task = generateTodo({\n      userId: ref.afterUser._id,\n      text: 'todo to complete',\n      cron: false\n    });\n    scoreTask({\n      user: ref.afterUser,\n      task,\n      direction: 'up'\n    });\n    expect(task.completed).to.eql(true);\n    expectRoughlyEqualDates(task.dateCompleted, new Date());\n  });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"uncompletes when the task direction is down","suites":["shared.ops.scoreTask"],"updatePoint":{"line":82,"column":49,"index":2645},"line":82,"code":"  it('uncompletes when the task direction is down', () => {\n    const task = generateTodo({\n      userId: ref.afterUser._id,\n      text: 'todo to complete',\n      cron: false\n    });\n    scoreTask({\n      user: ref.afterUser,\n      task,\n      direction: 'down'\n    });\n    expect(task.completed).to.eql(false);\n    expect(task.dateCompleted).to.not.exist;\n  });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"works","suites":["shared.ops.scoreTask","verifies that times parameter in scoring works"],"updatePoint":{"line":105,"column":13,"index":3216},"line":105,"code":"    it('works', () => {\n      const delta1 = scoreTask({\n        user: ref.afterUser,\n        task: habit,\n        direction: 'up',\n        times: 5,\n        cron: false\n      });\n      ref = beforeAfter();\n      habit = generateHabit({\n        userId: ref.afterUser._id,\n        text: 'some habit'\n      });\n      const delta2 = scoreTask({\n        user: ref.afterUser,\n        task: habit,\n        direction: 'up',\n        times: 4,\n        cron: false\n      });\n      ref = beforeAfter();\n      habit = generateHabit({\n        userId: ref.afterUser._id,\n        text: 'some habit'\n      });\n      const delta3 = scoreTask({\n        user: ref.afterUser,\n        task: habit,\n        direction: 'up',\n        times: 5,\n        cron: false\n      });\n      expect(Math.abs(delta1 - delta2)).to.be.greaterThan(EPSILON);\n      expect(Math.abs(delta1 - delta3)).to.be.lessThan(EPSILON);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"checks that the streak parameters affects the score","suites":["shared.ops.scoreTask","verifies that times parameter in scoring works"],"updatePoint":{"line":141,"column":57,"index":4157},"line":141,"code":"  it('checks that the streak parameters affects the score', () => {\n    const task = generateDaily({\n      userId: ref.afterUser._id,\n      text: 'task to check streak'\n    });\n    scoreTask({\n      user: ref.afterUser,\n      task,\n      direction: 'up',\n      cron: false\n    });\n    scoreTask({\n      user: ref.afterUser,\n      task,\n      direction: 'up',\n      cron: false\n    });\n    expect(task.streak).to.eql(2);\n  });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"awards the first streak achievement","suites":["shared.ops.scoreTask","verifies that 21-day streak achievements are given/removed correctly"],"updatePoint":{"line":166,"column":43,"index":4800},"line":166,"code":"    it('awards the first streak achievement', () => {\n      const task = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'some daily',\n        streak: initialStreakCount\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task,\n        direction: 'up'\n      });\n      expect(ref.afterUser.achievements.streak).to.equal(1);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"increments the streak achievement for a second streak","suites":["shared.ops.scoreTask","verifies that 21-day streak achievements are given/removed correctly"],"updatePoint":{"line":179,"column":61,"index":5179},"line":179,"code":"    it('increments the streak achievement for a second streak', () => {\n      const task1 = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'first daily',\n        streak: initialStreakCount\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task: task1,\n        direction: 'up'\n      });\n      const task2 = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'second daily',\n        streak: initialStreakCount\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task: task2,\n        direction: 'up'\n      });\n      expect(ref.afterUser.achievements.streak).to.equal(2);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"removes the first streak achievement when unticking a Daily","suites":["shared.ops.scoreTask","verifies that 21-day streak achievements are given/removed correctly"],"updatePoint":{"line":202,"column":67,"index":5821},"line":202,"code":"    it('removes the first streak achievement when unticking a Daily', () => {\n      const task = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'some daily',\n        streak: initialStreakCount\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task,\n        direction: 'up'\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task,\n        direction: 'down'\n      });\n      expect(ref.afterUser.achievements.streak).to.equal(0);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"decrements a multiple streak achievement when unticking a Daily","suites":["shared.ops.scoreTask","verifies that 21-day streak achievements are given/removed correctly"],"updatePoint":{"line":220,"column":71,"index":6307},"line":220,"code":"    it('decrements a multiple streak achievement when unticking a Daily', () => {\n      const task1 = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'first daily',\n        streak: initialStreakCount\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task: task1,\n        direction: 'up'\n      });\n      const task2 = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'second daily',\n        streak: initialStreakCount\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task: task2,\n        direction: 'up'\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task: task2,\n        direction: 'down'\n      });\n      expect(ref.afterUser.achievements.streak).to.equal(1);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"does not give a streak achievement for a streak of zero","suites":["shared.ops.scoreTask","verifies that 21-day streak achievements are given/removed correctly"],"updatePoint":{"line":248,"column":63,"index":7049},"line":248,"code":"    it('does not give a streak achievement for a streak of zero', () => {\n      const task = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'some daily',\n        streak: -1\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task,\n        direction: 'up'\n      });\n      expect(ref.afterUser.achievements.streak).to.equal(0);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"does not remove a streak achievement when unticking a Daily gives a streak of zero","suites":["shared.ops.scoreTask","verifies that 21-day streak achievements are given/removed correctly"],"updatePoint":{"line":261,"column":90,"index":7441},"line":261,"code":"    it('does not remove a streak achievement when unticking a Daily gives a streak of zero', () => {\n      const task1 = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'first daily',\n        streak: initialStreakCount\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task: task1,\n        direction: 'up'\n      });\n      const task2 = generateDaily({\n        userId: ref.afterUser._id,\n        text: 'second daily',\n        streak: 1\n      });\n      scoreTask({\n        user: ref.afterUser,\n        task: task2,\n        direction: 'down'\n      });\n      expect(ref.afterUser.achievements.streak).to.equal(1);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"critical hits","suites":["shared.ops.scoreTask","scores"],"updatePoint":{"line":322,"column":21,"index":9066},"line":322,"code":"    it('critical hits', () => {\n      const normalUser = ref.beforeUser;\n      expect(normalUser.party.quest.progress.up).to.eql(0);\n      normalUser.party.quest.key = 'gryphon';\n      const critUser = ref.afterUser;\n      expect(critUser.party.quest.progress.up).to.eql(0);\n      critUser.party.quest.key = 'gryphon';\n      const normalTask = todo;\n      const critTask = freshTodo;\n      scoreTask({\n        user: normalUser,\n        task: normalTask,\n        direction: 'up',\n        cron: false\n      });\n      const normalTaskDelta = normalUser.party.quest.progress.up;\n      sandbox.stub(crit, 'crit').returns(1.5);\n      scoreTask({\n        user: critUser,\n        task: critTask,\n        direction: 'up',\n        cron: false\n      });\n      const critTaskDelta = critUser.party.quest.progress.up;\n      crit.crit.restore();\n      expect(critUser.stats.hp).to.eql(normalUser.stats.hp);\n      expect(critUser.stats.gp).to.be.greaterThan(normalUser.stats.gp);\n      expect(critUser.stats.mp).to.be.greaterThan(normalUser.stats.mp);\n      expect(critUser.stats.exp).to.be.greaterThan(normalUser.stats.exp);\n      expect(critTask.value).to.eql(normalTask.value);\n      expect(critTaskDelta).to.be.greaterThan(normalTaskDelta);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"and increments quest progress","suites":["shared.ops.scoreTask","scores"],"updatePoint":{"line":354,"column":37,"index":10320},"line":354,"code":"    it('and increments quest progress', () => {\n      expect(ref.afterUser.party.quest.progress.up).to.eql(0);\n      ref.afterUser.party.quest.key = 'gryphon';\n      scoreTask({\n        user: ref.afterUser,\n        task: habit,\n        direction: 'up',\n        cron: false\n      });\n      const firstTaskDelta = ref.afterUser.party.quest.progress.up;\n      expect(firstTaskDelta).to.be.greaterThan(0);\n      expect(ref.afterUser._tmp.quest.progressDelta).to.eql(firstTaskDelta);\n      scoreTask({\n        user: ref.afterUser,\n        task: habit,\n        direction: 'up',\n        cron: false\n      });\n      const secondTaskDelta = ref.afterUser.party.quest.progress.up - firstTaskDelta;\n      expect(secondTaskDelta).to.be.greaterThan(0);\n      expect(ref.afterUser._tmp.quest.progressDelta).to.eql(secondTaskDelta);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"does not modify stats when task need approval","suites":["shared.ops.scoreTask","scores"],"updatePoint":{"line":376,"column":53,"index":11162},"line":376,"code":"    it('does not modify stats when task need approval', () => {\n      todo.group.approval.required = true;\n      options = {\n        user: ref.afterUser,\n        task: todo,\n        direction: 'up',\n        times: 5,\n        cron: false\n      };\n      scoreTask(options);\n      expect(ref.afterUser.stats.hp).to.eql(50);\n      expect(ref.afterUser.stats.exp).to.equal(ref.beforeUser.stats.exp);\n      expect(ref.afterUser.stats.gp).to.equal(ref.beforeUser.stats.gp);\n    });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"up","suites":["shared.ops.scoreTask","scores","habits"],"updatePoint":{"line":391,"column":12,"index":11626},"line":391,"code":"      it('up', () => {\n        options = {\n          user: ref.afterUser,\n          task: habit,\n          direction: 'up',\n          times: 5,\n          cron: false\n        };\n        scoreTask(options);\n        expect(habit.history.length).to.eql(1);\n        expect(habit.value).to.be.greaterThan(0);\n        expect(habit.counterUp).to.equal(5);\n        expect(ref.afterUser.stats.hp).to.eql(50);\n        expect(ref.afterUser.stats.exp).to.be.greaterThan(ref.beforeUser.stats.exp);\n        expect(ref.afterUser.stats.gp).to.be.greaterThan(ref.beforeUser.stats.gp);\n      }); // not supported anymore","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"does not add score notes to task","suites":["shared.ops.scoreTask","scores","habits"],"updatePoint":{"line":408,"column":42,"index":12259},"line":408,"code":"      it('does not add score notes to task', () => {\n        const scoreNotesString = 'scoreNotes';\n        habit.scoreNotes = scoreNotesString;\n        options = {\n          user: ref.afterUser,\n          task: habit,\n          direction: 'up',\n          times: 5,\n          cron: false\n        };\n        scoreTask(options);\n        expect(habit.history[0].scoreNotes).to.eql(undefined);\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"down","suites":["shared.ops.scoreTask","scores","habits"],"updatePoint":{"line":421,"column":14,"index":12631},"line":421,"code":"      it('down', () => {\n        scoreTask({\n          user: ref.afterUser,\n          task: habit,\n          direction: 'down',\n          times: 5,\n          cron: false\n        }, {});\n        expect(habit.history.length).to.eql(1);\n        expect(habit.value).to.be.lessThan(0);\n        expect(habit.counterDown).to.equal(5);\n        expect(ref.afterUser.stats.hp).to.be.lessThan(ref.beforeUser.stats.hp);\n        expect(ref.afterUser.stats.exp).to.eql(0);\n        expect(ref.afterUser.stats.gp).to.eql(0);\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"up","suites":["shared.ops.scoreTask","scores","dailys"],"updatePoint":{"line":438,"column":12,"index":13186},"line":438,"code":"      it('up', () => {\n        expect(daily.completed).to.not.eql(true);\n        scoreTask({\n          user: ref.afterUser,\n          task: daily,\n          direction: 'up'\n        });\n        expectGainedPoints(ref.beforeUser, ref.afterUser, freshDaily, daily);\n        expect(daily.completed).to.eql(true);\n        expect(daily.history.length).to.eql(1);\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"up, down","suites":["shared.ops.scoreTask","scores","dailys"],"updatePoint":{"line":449,"column":18,"index":13559},"line":449,"code":"      it('up, down', () => {\n        scoreTask({\n          user: ref.afterUser,\n          task: daily,\n          direction: 'up'\n        });\n        expect(daily.history.length).to.eql(1);\n        scoreTask({\n          user: ref.afterUser,\n          task: daily,\n          direction: 'down'\n        });\n        expect(daily.history.length).to.eql(0);\n        expectClosePoints(ref.beforeUser, ref.afterUser, freshDaily, daily);\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"sets completed = false on direction = down","suites":["shared.ops.scoreTask","scores","dailys"],"updatePoint":{"line":464,"column":52,"index":14031},"line":464,"code":"      it('sets completed = false on direction = down', () => {\n        daily.completed = true;\n        expect(daily.completed).to.not.eql(false);\n        scoreTask({\n          user: ref.afterUser,\n          task: daily,\n          direction: 'down'\n        });\n        expect(daily.completed).to.eql(false);\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"up","suites":["shared.ops.scoreTask","scores","todos"],"updatePoint":{"line":476,"column":12,"index":14345},"line":476,"code":"      it('up', () => {\n        scoreTask({\n          user: ref.afterUser,\n          task: todo,\n          direction: 'up'\n        });\n        expectGainedPoints(ref.beforeUser, ref.afterUser, freshTodo, todo);\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"up, down","suites":["shared.ops.scoreTask","scores","todos"],"updatePoint":{"line":484,"column":18,"index":14571},"line":484,"code":"      it('up, down', () => {\n        scoreTask({\n          user: ref.afterUser,\n          task: todo,\n          direction: 'up'\n        });\n        scoreTask({\n          user: ref.afterUser,\n          task: todo,\n          direction: 'down'\n        });\n        expectClosePoints(ref.beforeUser, ref.afterUser, freshTodo, todo);\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"adds the achievement to the user and checks the onboarding status","suites":["shared.ops.scoreTask","scores","onboarding"],"updatePoint":{"line":506,"column":75,"index":15252},"line":506,"code":"      it('adds the achievement to the user and checks the onboarding status', () => {\n        scoreTask({\n          user: ref.afterUser,\n          task: todo,\n          direction: 'up'\n        });\n        expect(ref.afterUser.addAchievement).to.be.calledOnce;\n        expect(ref.afterUser.addAchievement).to.be.calledWith('completedTask');\n        expect(shared.onboarding.checkOnboardingStatus).to.be.calledOnce;\n        expect(shared.onboarding.checkOnboardingStatus).to.be.calledWith(ref.afterUser);\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"does not add the onboarding achievement to the user if it's already been awarded","suites":["shared.ops.scoreTask","scores","onboarding"],"updatePoint":{"line":517,"column":91,"index":15781},"line":517,"code":"      it('does not add the onboarding achievement to the user if it\\'s already been awarded', () => {\n        ref.afterUser.achievements.completedTask = true;\n        scoreTask({\n          user: ref.afterUser,\n          task: todo,\n          direction: 'up'\n        });\n        expect(ref.afterUser.addAchievement).to.not.be.called;\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"does not add the onboarding achievement to the user if it's scored down","suites":["shared.ops.scoreTask","scores","onboarding"],"updatePoint":{"line":526,"column":82,"index":16115},"line":526,"code":"      it('does not add the onboarding achievement to the user if it\\'s scored down', () => {\n        scoreTask({\n          user: ref.afterUser,\n          task: todo,\n          direction: 'down'\n        });\n        expect(ref.afterUser.addAchievement).to.not.be.called;\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"does not add the onboarding achievement to the user if cron is running","suites":["shared.ops.scoreTask","scores","onboarding"],"updatePoint":{"line":534,"column":80,"index":16392},"line":534,"code":"      it('does not add the onboarding achievement to the user if cron is running', () => {\n        scoreTask({\n          user: ref.afterUser,\n          task: todo,\n          direction: 'up',\n          cron: true\n        });\n        expect(ref.afterUser.addAchievement).to.not.be.called;\n      });","file":"common/ops/scoreTask.test.js","skipped":false,"dir":"test"},{"name":"returns false if task type is not a daily","suites":["shouldDo"],"updatePoint":{"line":31,"column":47,"index":761},"line":31,"code":"  it('returns false if task type is not a daily', () => {\n    expect(shouldDo(day, {\n      type: 'todo'\n    })).to.equal(false);\n    expect(shouldDo(day, {\n      type: 'habit'\n    })).to.equal(false);\n    expect(shouldDo(day, {\n      type: 'reward'\n    })).to.equal(false);\n  });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if startDate is in the future","suites":["shouldDo"],"updatePoint":{"line":42,"column":49,"index":1043},"line":42,"code":"  it('returns false if startDate is in the future', () => {\n    dailyTask.startDate = moment().add(1, 'days').toDate();\n    expect(shouldDo(day, dailyTask, options)).to.equal(false);\n  });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if Start Date is before today","suites":["shouldDo","Timezone variations","User timezone is UTC"],"updatePoint":{"line":51,"column":52,"index":1391},"line":51,"code":"      it('returns true if Start Date is before today', () => {\n        dailyTask.startDate = moment().subtract(1, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if Start Date is today","suites":["shouldDo","Timezone variations","User timezone is UTC"],"updatePoint":{"line":55,"column":45,"index":1592},"line":55,"code":"      it('returns true if Start Date is today', () => {\n        dailyTask.startDate = moment().toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if Start Date is after today","suites":["shouldDo","Timezone variations","User timezone is UTC"],"updatePoint":{"line":59,"column":52,"index":1780},"line":59,"code":"      it('returns false if Start Date is after today', () => {\n        dailyTask.startDate = moment().add(1, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if Start Date is before today","suites":["shouldDo","Timezone variations","User timezone is between UTC-12 and UTC (0~720)"],"updatePoint":{"line":68,"column":52,"index":2136},"line":68,"code":"      it('returns true if Start Date is before today', () => {\n        dailyTask.startDate = moment().subtract(1, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if Start Date is today","suites":["shouldDo","Timezone variations","User timezone is between UTC-12 and UTC (0~720)"],"updatePoint":{"line":72,"column":45,"index":2337},"line":72,"code":"      it('returns true if Start Date is today', () => {\n        dailyTask.startDate = moment().startOf('day').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if the user's current time is after start date and Custom Day Start","suites":["shouldDo","Timezone variations","User timezone is between UTC-12 and UTC (0~720)"],"updatePoint":{"line":76,"column":91,"index":2579},"line":76,"code":"      it('returns true if the user\\'s current time is after start date and Custom Day Start', () => {\n        options.dayStart = 4;\n        day = moment().utcOffset(-options.timezoneOffset).startOf('day').add(6, 'hours').toDate();\n        dailyTask.startDate = moment().utcOffset(-options.timezoneOffset).startOf('day').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if the user's current time is before Custom Day Start","suites":["shouldDo","Timezone variations","User timezone is between UTC-12 and UTC (0~720)"],"updatePoint":{"line":82,"column":78,"index":2972},"line":82,"code":"      it('returns false if the user\\'s current time is before Custom Day Start', () => {\n        options.dayStart = 8;\n        day = moment().utcOffset(-options.timezoneOffset).startOf('day').add(2, 'hours').toDate();\n        dailyTask.startDate = moment().utcOffset(-options.timezoneOffset).startOf('day').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if Start Date is before today","suites":["shouldDo","Timezone variations","User timezone is between UTC and GMT+14 (-840~0)"],"updatePoint":{"line":93,"column":52,"index":3494},"line":93,"code":"      it('returns true if Start Date is before today', () => {\n        dailyTask.startDate = moment().subtract(1, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if Start Date is today","suites":["shouldDo","Timezone variations","User timezone is between UTC and GMT+14 (-840~0)"],"updatePoint":{"line":97,"column":45,"index":3695},"line":97,"code":"      it('returns true if Start Date is today', () => {\n        dailyTask.startDate = moment().startOf('day').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if the user's current time is after Custom Day Start","suites":["shouldDo","Timezone variations","User timezone is between UTC and GMT+14 (-840~0)"],"updatePoint":{"line":101,"column":76,"index":3922},"line":101,"code":"      it('returns true if the user\\'s current time is after Custom Day Start', () => {\n        options.dayStart = 4;\n        day = moment().utcOffset(-options.timezoneOffset).startOf('day').add(6, 'hours').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if the user's current time is before Custom Day Start","suites":["shouldDo","Timezone variations","User timezone is between UTC and GMT+14 (-840~0)"],"updatePoint":{"line":106,"column":78,"index":4216},"line":106,"code":"      it('returns false if the user\\'s current time is before Custom Day Start', () => {\n        options.dayStart = 8;\n        day = moment().utcOffset(-options.timezoneOffset).startOf('day').add(2, 'hours').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due yesterday","suites":["shouldDo","Custom Day Start variations","Custom Day Start is midnight (Default dayStart=0)","Current Date is yesterday"],"updatePoint":{"line":125,"column":39,"index":4912},"line":125,"code":"        it('should not be due yesterday', () => {\n          day = moment(day).subtract(1, 'days').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current time is before midnight","suites":["shouldDo","Custom Day Start variations","Custom Day Start is midnight (Default dayStart=0)","Current Date is today"],"updatePoint":{"line":131,"column":60,"index":5179},"line":131,"code":"        it('returns false if current time is before midnight', () => {\n          day = moment(day).startOf('day').subtract(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current time is after midnight","suites":["shouldDo","Custom Day Start variations","Custom Day Start is midnight (Default dayStart=0)","Current Date is today"],"updatePoint":{"line":135,"column":58,"index":5403},"line":135,"code":"        it('returns true if current time is after midnight', () => {\n          day = moment(day).startOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due tomorrow","suites":["shouldDo","Custom Day Start variations","Custom Day Start is midnight (Default dayStart=0)","Current Date is tomorrow"],"updatePoint":{"line":141,"column":38,"index":5661},"line":141,"code":"        it('should not be due tomorrow', () => {\n          day = moment(day).add(1, 'days').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due yesterday","suites":["shouldDo","Custom Day Start variations","Custom Day Start is 0 <= n < 24","Current Date is yesterday"],"updatePoint":{"line":152,"column":39,"index":6034},"line":152,"code":"        it('should not be due yesterday', () => {\n          day = moment(day).subtract(1, 'days').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is before Custom Day Start","suites":["shouldDo","Custom Day Start variations","Custom Day Start is 0 <= n < 24","Current Date is today"],"updatePoint":{"line":158,"column":68,"index":6309},"line":158,"code":"        it('returns false if current hour is before Custom Day Start', () => {\n          day = moment(day).startOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is after Custom Day Start","suites":["shouldDo","Custom Day Start variations","Custom Day Start is 0 <= n < 24","Current Date is today"],"updatePoint":{"line":162,"column":66,"index":6536},"line":162,"code":"        it('returns true if current hour is after Custom Day Start', () => {\n          day = moment(day).startOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is before Custom Day Start","suites":["shouldDo","Custom Day Start variations","Custom Day Start is 0 <= n < 24","Current Date is tomorrow"],"updatePoint":{"line":168,"column":67,"index":6823},"line":168,"code":"        it('returns true if current hour is before Custom Day Start', () => {\n          day = moment(day).endOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is after Custom Day Start","suites":["shouldDo","Custom Day Start variations","Custom Day Start is 0 <= n < 24","Current Date is tomorrow"],"updatePoint":{"line":172,"column":67,"index":7048},"line":172,"code":"        it('returns false if current hour is after Custom Day Start', () => {\n          day = moment(day).endOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if daily does not have an everyX property","suites":["shouldDo","Every X Days"],"updatePoint":{"line":183,"column":63,"index":7396},"line":183,"code":"    it('returns false if daily does not have an everyX property', () => {\n      delete dailyTask.everyX;\n      expect(shouldDo(day, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false in between X Day intervals","suites":["shouldDo","Every X Days"],"updatePoint":{"line":187,"column":48,"index":7559},"line":187,"code":"    it('returns false in between X Day intervals', () => {\n      dailyTask.startDate = moment().subtract(1, 'days').toDate();\n      dailyTask.everyX = 2;\n      expect(shouldDo(day, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true on multiples of x","suites":["shouldDo","Every X Days"],"updatePoint":{"line":192,"column":38,"index":7776},"line":192,"code":"    it('returns true on multiples of x', () => {\n      dailyTask.startDate = moment().subtract(7, 'days').toDate();\n      dailyTask.everyX = 7;\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should compute daily nextDue values","suites":["shouldDo","Every X Days"],"updatePoint":{"line":197,"column":43,"index":7997},"line":197,"code":"    it('should compute daily nextDue values', () => {\n      options.timezoneOffset = 0;\n      options.nextDue = true;\n      day = moment.utc('2017-05-01').toDate();\n      dailyTask.frequency = 'daily';\n      dailyTask.everyX = 2;\n      dailyTask.startDate = day;\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue.length).to.eql(6);\n      expect(moment(nextDue[0]).toDate()).to.eql(moment.utc('2017-05-03').toDate());\n      expect(moment(nextDue[1]).toDate()).to.eql(moment.utc('2017-05-05').toDate());\n      expect(moment(nextDue[2]).toDate()).to.eql(moment.utc('2017-05-07').toDate());\n      expect(moment(nextDue[3]).toDate()).to.eql(moment.utc('2017-05-09').toDate());\n      expect(moment(nextDue[4]).toDate()).to.eql(moment.utc('2017-05-11').toDate());\n      expect(moment(nextDue[5]).toDate()).to.eql(moment.utc('2017-05-13').toDate());\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true when Custom Day Start is midnight","suites":["shouldDo","Every X Days","On multiples of x"],"updatePoint":{"line":214,"column":56,"index":8923},"line":214,"code":"      it('returns true when Custom Day Start is midnight', () => {\n        dailyTask.startDate = moment().subtract(7, 'days').toDate();\n        dailyTask.everyX = 7;\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        day = moment(day).add(7, 'days');\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        day = moment(day).add(7, 'days');\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true when current time is after Custom Day Start","suites":["shouldDo","Every X Days","On multiples of x"],"updatePoint":{"line":223,"column":66,"index":9391},"line":223,"code":"      it('returns true when current time is after Custom Day Start', () => {\n        dailyTask.startDate = moment().subtract(5, 'days').toDate();\n        dailyTask.everyX = 5;\n        options.dayStart = 3;\n        day = moment(day).startOf('day').add(8, 'hours').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(true);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false when current time is before Custom Day Start","suites":["shouldDo","Every X Days","On multiples of x"],"updatePoint":{"line":230,"column":68,"index":9742},"line":230,"code":"      it('returns false when current time is before Custom Day Start', () => {\n        dailyTask.startDate = moment().subtract(5, 'days').toDate();\n        dailyTask.everyX = 5;\n        options.dayStart = 14;\n        day = moment(day).startOf('day').add(7, 'hours').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false on the Start Date","suites":["shouldDo","Every X Days","If number of X days is zero"],"updatePoint":{"line":242,"column":41,"index":10192},"line":242,"code":"      it('returns false on the Start Date', () => {\n        dailyTask.startDate = moment().subtract(4, 'days').toDate();\n        day = moment().subtract(4, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false on the day before Start Date","suites":["shouldDo","Every X Days","If number of X days is zero"],"updatePoint":{"line":247,"column":52,"index":10454},"line":247,"code":"      it('returns false on the day before Start Date', () => {\n        dailyTask.startDate = moment().subtract(4, 'days').toDate();\n        day = moment().subtract(5, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false on the day after Start Date","suites":["shouldDo","Every X Days","If number of X days is zero"],"updatePoint":{"line":252,"column":51,"index":10715},"line":252,"code":"      it('returns false on the day after Start Date', () => {\n        dailyTask.startDate = moment().subtract(4, 'days').toDate();\n        day = moment().subtract(3, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if task does not have a repeat property","suites":["shouldDo","Certain Days of the Week"],"updatePoint":{"line":272,"column":61,"index":11271},"line":272,"code":"    it('returns false if task does not have a repeat property', () => {\n      delete dailyTask.repeat;\n      expect(shouldDo(day, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if day of the week does not match","suites":["shouldDo","Certain Days of the Week"],"updatePoint":{"line":276,"column":55,"index":11441},"line":276,"code":"    it('returns false if day of the week does not match', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      [0, 1, 2, 3, 4, 5, 6].forEach(weekday => {\n        day = moment().day(weekday).toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false and ignore malformed repeat object","suites":["shouldDo","Certain Days of the Week"],"updatePoint":{"line":291,"column":56,"index":11851},"line":291,"code":"    it('returns false and ignore malformed repeat object', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false,\n        errors: 'errors'\n      };\n      [0, 1, 2, 3, 4, 5, 6].forEach(weekday => {\n        day = moment().day(weekday).toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if day of the week does not match and active on the day it matches","suites":["shouldDo","Certain Days of the Week"],"updatePoint":{"line":307,"column":88,"index":12319},"line":307,"code":"    it('returns false if day of the week does not match and active on the day it matches', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: true,\n        w: false,\n        t: false,\n        m: false\n      };\n      [0, 1, 2, 3, 4, 5, 6].forEach(weekday => {\n        day = moment().add(1, 'weeks').day(weekday).toDate();\n\n        if (weekday === 4) {\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        } else {\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        }\n      });\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if Daily on matching days of the week","suites":["shouldDo","Certain Days of the Week"],"updatePoint":{"line":327,"column":58,"index":12873},"line":327,"code":"    it('returns true if Daily on matching days of the week', () => {\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should compute weekly nextDue values","suites":["shouldDo","Certain Days of the Week"],"updatePoint":{"line":330,"column":44,"index":13000},"line":330,"code":"    it('should compute weekly nextDue values', () => {\n      options.timezoneOffset = 0;\n      options.nextDue = true;\n      day = moment.utc('2017-05-01').toDate();\n      dailyTask.frequency = 'weekly';\n      dailyTask.everyX = 1;\n      dailyTask.repeat = {\n        su: true,\n        m: true,\n        t: true,\n        w: true,\n        th: true,\n        f: true,\n        s: true\n      };\n      dailyTask.startDate = day;\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue.length).to.eql(6);\n      expect(moment(nextDue[0]).toDate()).to.eql(moment.utc('2017-05-02').toDate());\n      expect(moment(nextDue[1]).toDate()).to.eql(moment.utc('2017-05-03').toDate());\n      expect(moment(nextDue[2]).toDate()).to.eql(moment.utc('2017-05-04').toDate());\n      expect(moment(nextDue[3]).toDate()).to.eql(moment.utc('2017-05-05').toDate());\n      expect(moment(nextDue[4]).toDate()).to.eql(moment.utc('2017-05-06').toDate());\n      expect(moment(nextDue[5]).toDate()).to.eql(moment.utc('2017-05-07').toDate());\n      dailyTask.everyX = 2;\n      dailyTask.repeat = {\n        su: true,\n        m: false,\n        t: false,\n        w: false,\n        th: false,\n        f: true,\n        s: false\n      };\n      dailyTask.startDate = day;\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue.length).to.eql(6);\n      expect(moment(nextDue[0]).toDate()).to.eql(moment.utc('2017-05-05').toDate());\n      expect(moment(nextDue[1]).toDate()).to.eql(moment.utc('2017-05-14').toDate());\n      expect(moment(nextDue[2]).toDate()).to.eql(moment.utc('2017-05-19').toDate());\n      expect(moment(nextDue[3]).toDate()).to.eql(moment.utc('2017-05-28').toDate());\n      expect(moment(nextDue[4]).toDate()).to.eql(moment.utc('2017-06-02').toDate());\n      expect(moment(nextDue[5]).toDate()).to.eql(moment.utc('2017-06-11').toDate());\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not go into an infinite loop with invalid values","suites":["shouldDo","Certain Days of the Week"],"updatePoint":{"line":374,"column":63,"index":14872},"line":374,"code":"    it('should not go into an infinite loop with invalid values', () => {\n      options.nextDue = true;\n      day = moment('2017-05-01').toDate();\n      dailyTask.frequency = 'weekly';\n      dailyTask.everyX = 1;\n      dailyTask.startDate = null;\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue).to.eql(false);\n      dailyTask.startDate = day;\n      dailyTask.everyX = 0;\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue).to.eql(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should return false","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is midnight (Default dayStart=0)","Current Date is one day before the matching day"],"updatePoint":{"line":417,"column":33,"index":16191},"line":417,"code":"          it('should return false', () => {\n            day = moment(day).subtract(1, 'days').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(false);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current time is before midnight","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is midnight (Default dayStart=0)","Current Date is on the matching day"],"updatePoint":{"line":423,"column":62,"index":16484},"line":423,"code":"          it('returns false if current time is before midnight', () => {\n            day = moment(day).startOf('day').subtract(1, 'hours').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(false);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current time is after midnight","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is midnight (Default dayStart=0)","Current Date is on the matching day"],"updatePoint":{"line":427,"column":60,"index":16716},"line":427,"code":"          it('returns true if current time is after midnight', () => {\n            day = moment(day).startOf('day').add(1, 'hours').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(true);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due tomorrow","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is midnight (Default dayStart=0)","Current Date is one day after the matching day"],"updatePoint":{"line":433,"column":40,"index":17008},"line":433,"code":"          it('should not be due tomorrow', () => {\n            day = moment(day).add(1, 'days').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(false);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is 0 <= n < 24","Current Date is one day before the matching day"],"updatePoint":{"line":444,"column":31,"index":17415},"line":444,"code":"          it('should not be due', () => {\n            day = moment(day).subtract(1, 'days').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(false);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is before Custom Day Start","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":450,"column":70,"index":17716},"line":450,"code":"          it('returns false if current hour is before Custom Day Start', () => {\n            day = moment(day).startOf('day').add(1, 'hours').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(false);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is after Custom Day Start","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":454,"column":68,"index":17951},"line":454,"code":"          it('returns true if current hour is after Custom Day Start', () => {\n            day = moment(day).startOf('day').add(9, 'hours').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(true);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is before Custom Day Start","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":460,"column":69,"index":18272},"line":460,"code":"          it('returns true if current hour is before Custom Day Start', () => {\n            day = moment(day).endOf('day').add(1, 'hours').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(true);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is after Custom Day Start","suites":["shouldDo","Certain Days of the Week","Day of the week matches","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":464,"column":69,"index":18505},"line":464,"code":"          it('returns false if current hour is after Custom Day Start', () => {\n            day = moment(day).endOf('day').add(9, 'hours').toDate();\n            expect(shouldDo(day, dailyTask, options)).to.equal(false);\n          });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false for a day before the Start Date","suites":["shouldDo","Certain Days of the Week","No days of the week is selected"],"updatePoint":{"line":483,"column":55,"index":19026},"line":483,"code":"      it('returns false for a day before the Start Date', () => {\n        day = moment().subtract(1, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false for the Start Date","suites":["shouldDo","Certain Days of the Week","No days of the week is selected"],"updatePoint":{"line":487,"column":42,"index":19209},"line":487,"code":"      it('returns false for the Start Date', () => {\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false for a day after the Start Date","suites":["shouldDo","Certain Days of the Week","No days of the week is selected"],"updatePoint":{"line":490,"column":54,"index":19351},"line":490,"code":"      it('returns false for a day after the Start Date', () => {\n        day = moment().add(1, 'days').toDate();\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false for today","suites":["shouldDo","Certain Days of the Week","No days of the week is selected"],"updatePoint":{"line":494,"column":33,"index":19520},"line":494,"code":"      it('returns false for today', () => {\n        expect(shouldDo(day, dailyTask, options)).to.equal(false);\n      });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"leaves daily inactive if it has not been the specified number of weeks","suites":["shouldDo","Every X Weeks"],"updatePoint":{"line":500,"column":78,"index":19735},"line":500,"code":"    it('leaves daily inactive if it has not been the specified number of weeks', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      day = moment();\n      dailyTask.repeat[DAY_MAPPING[day.day()]] = true;\n      dailyTask.everyX = 3;\n      const tomorrow = day.add(2, 'weeks').day(day.day()).toDate();\n      expect(shouldDo(tomorrow, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"leaves daily inactive if on every (x) week on weekday it is incorrect weekday","suites":["shouldDo","Every X Weeks"],"updatePoint":{"line":516,"column":85,"index":20245},"line":516,"code":"    it('leaves daily inactive if on every (x) week on weekday it is incorrect weekday', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      day = moment();\n      dailyTask.repeat[DAY_MAPPING[day.day()]] = true;\n      dailyTask.everyX = 3;\n      const threeWeeksFromTodayPlusOne = day.add(1, 'day').add(3, 'weeks').toDate();\n      expect(shouldDo(threeWeeksFromTodayPlusOne, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on matching week","suites":["shouldDo","Every X Weeks"],"updatePoint":{"line":532,"column":40,"index":20745},"line":532,"code":"    it('activates Daily on matching week', () => {\n      dailyTask.everyX = 3;\n      const threeWeeksFromToday = moment().add(3, 'weeks').toDate();\n      expect(shouldDo(threeWeeksFromToday, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on every (x) week on weekday","suites":["shouldDo","Every X Weeks"],"updatePoint":{"line":537,"column":52,"index":20993},"line":537,"code":"    it('activates Daily on every (x) week on weekday', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      day = moment();\n      dailyTask.repeat[DAY_MAPPING[day.day()]] = true;\n      dailyTask.everyX = 3;\n      const threeWeeksFromToday = day.add(6, 'weeks').day(day.day()).toDate();\n      expect(shouldDo(threeWeeksFromToday, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on every (x) week on weekday across a year","suites":["shouldDo","Every X Weeks"],"updatePoint":{"line":553,"column":66,"index":21505},"line":553,"code":"    it('activates Daily on every (x) week on weekday across a year', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      day = moment('2017-11-19');\n      dailyTask.startDate = day.toDate();\n      dailyTask.repeat[DAY_MAPPING[day.day()]] = true;\n      dailyTask.everyX = 3;\n      const threeWeeksFromToday = moment('2018-01-21');\n      expect(shouldDo(threeWeeksFromToday, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on start date","suites":["shouldDo","Every X Weeks"],"updatePoint":{"line":570,"column":37,"index":22019},"line":570,"code":"    it('activates Daily on start date', () => {\n      dailyTask.everyX = 3;\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due","suites":["shouldDo","Every X Weeks","Custom Day Start is 0 <= n < 24","Current Date is one day before the matching day"],"updatePoint":{"line":593,"column":29,"index":22755},"line":593,"code":"        it('should not be due', () => {\n          day = moment(threeWeeksFromToday).subtract(1, 'days').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is before Custom Day Start","suites":["shouldDo","Every X Weeks","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":599,"column":68,"index":23060},"line":599,"code":"        it('returns false if current hour is before Custom Day Start', () => {\n          day = moment(threeWeeksFromToday).startOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is after Custom Day Start","suites":["shouldDo","Every X Weeks","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":603,"column":66,"index":23303},"line":603,"code":"        it('returns true if current hour is after Custom Day Start', () => {\n          day = moment(threeWeeksFromToday).startOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is before Custom Day Start","suites":["shouldDo","Every X Weeks","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":609,"column":67,"index":23628},"line":609,"code":"        it('returns true if current hour is before Custom Day Start', () => {\n          day = moment(threeWeeksFromToday).endOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is after Custom Day Start","suites":["shouldDo","Every X Weeks","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":613,"column":67,"index":23869},"line":613,"code":"        it('returns false if current hour is after Custom Day Start', () => {\n          day = moment(threeWeeksFromToday).endOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"leaves daily inactive if not day of the month","suites":["shouldDo","Monthly - Every X Months on a specified date"],"updatePoint":{"line":621,"column":53,"index":24187},"line":621,"code":"    it('leaves daily inactive if not day of the month', () => {\n      dailyTask.everyX = 1;\n      dailyTask.frequency = 'monthly';\n      const today = moment();\n      dailyTask.daysOfMonth = [today.date()];\n      const tomorrow = today.add(1, 'day').toDate();\n      expect(shouldDo(tomorrow, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on matching day of month","suites":["shouldDo","Monthly - Every X Months on a specified date"],"updatePoint":{"line":629,"column":48,"index":24520},"line":629,"code":"    it('activates Daily on matching day of month', () => {\n      day = moment();\n      dailyTask.everyX = 1;\n      dailyTask.frequency = 'monthly';\n      dailyTask.daysOfMonth = [day.date()];\n      day = day.add(1, 'months').date(day.date()).toDate();\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"leaves daily inactive if not on date of the x month","suites":["shouldDo","Monthly - Every X Months on a specified date"],"updatePoint":{"line":637,"column":59,"index":24855},"line":637,"code":"    it('leaves daily inactive if not on date of the x month', () => {\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'monthly';\n      const today = moment();\n      dailyTask.daysOfMonth = [today.date()];\n      const tomorrow = today.add(2, 'months').add(1, 'day').toDate();\n      expect(shouldDo(tomorrow, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily if on date of the x month","suites":["shouldDo","Monthly - Every X Months on a specified date"],"updatePoint":{"line":645,"column":49,"index":25206},"line":645,"code":"    it('activates Daily if on date of the x month', () => {\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'monthly';\n      dailyTask.daysOfMonth = [15];\n      day = moment().add(2, 'months').date(15).toDate();\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on start date","suites":["shouldDo","Monthly - Every X Months on a specified date"],"updatePoint":{"line":652,"column":37,"index":25486},"line":652,"code":"    it('activates Daily on start date', () => {\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'monthly';\n      dailyTask.daysOfMonth = [15];\n      day = moment().add(2, 'months').date(15).toDate();\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should compute monthly nextDue values","suites":["shouldDo","Monthly - Every X Months on a specified date"],"updatePoint":{"line":659,"column":45,"index":25774},"line":659,"code":"    it('should compute monthly nextDue values', () => {\n      options.timezoneOffset = 0;\n      options.nextDue = true;\n      day = moment.utc('2017-05-01').toDate();\n      dailyTask.frequency = 'monthly';\n      dailyTask.everyX = 3;\n      dailyTask.startDate = day;\n      dailyTask.daysOfMonth = [1];\n      dailyTask.weeksOfMonth = [];\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue.length).to.eql(6);\n      expect(moment(nextDue[0]).toDate()).to.eql(moment.utc('2017-08-01').toDate());\n      expect(moment(nextDue[1]).toDate()).to.eql(moment.utc('2017-11-01').toDate());\n      expect(moment(nextDue[2]).toDate()).to.eql(moment.utc('2018-02-01').toDate());\n      expect(moment(nextDue[3]).toDate()).to.eql(moment.utc('2018-05-01').toDate());\n      expect(moment(nextDue[4]).toDate()).to.eql(moment.utc('2018-08-01').toDate());\n      expect(moment(nextDue[5]).toDate()).to.eql(moment.utc('2018-11-01').toDate());\n      dailyTask.daysOfMonth = [];\n      dailyTask.weeksOfMonth = [0];\n      dailyTask.everyX = 1;\n      dailyTask.repeat = {\n        su: false,\n        m: true,\n        t: false,\n        w: false,\n        th: false,\n        f: false,\n        s: false\n      };\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue.length).to.eql(6);\n      expect(moment(nextDue[0]).toDate()).to.eql(moment.utc('2017-06-05').toDate());\n      expect(moment(nextDue[1]).toDate()).to.eql(moment.utc('2017-07-03').toDate());\n      expect(moment(nextDue[2]).toDate()).to.eql(moment.utc('2017-08-07').toDate());\n      expect(moment(nextDue[3]).toDate()).to.eql(moment.utc('2017-09-04').toDate());\n      expect(moment(nextDue[4]).toDate()).to.eql(moment.utc('2017-10-02').toDate());\n      expect(moment(nextDue[5]).toDate()).to.eql(moment.utc('2017-11-06').toDate());\n      day = moment.utc('2017-05-08').toDate();\n      dailyTask.daysOfMonth = [];\n      dailyTask.weeksOfMonth = [1];\n      dailyTask.startDate = day;\n      dailyTask.everyX = 1;\n      dailyTask.repeat = {\n        su: false,\n        m: true,\n        t: false,\n        w: false,\n        th: false,\n        f: false,\n        s: false\n      };\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue.length).to.eql(6);\n      expect(moment(nextDue[0]).toDate()).to.eql(moment.utc('2017-06-12').toDate());\n      expect(moment(nextDue[1]).toDate()).to.eql(moment.utc('2017-07-10').toDate());\n      expect(moment(nextDue[2]).toDate()).to.eql(moment.utc('2017-08-14').toDate());\n      expect(moment(nextDue[3]).toDate()).to.eql(moment.utc('2017-09-11').toDate());\n      expect(moment(nextDue[4]).toDate()).to.eql(moment.utc('2017-10-09').toDate());\n      expect(moment(nextDue[5]).toDate()).to.eql(moment.utc('2017-11-13').toDate());\n      day = moment.utc('2017-05-29').toDate();\n      dailyTask.daysOfMonth = [];\n      dailyTask.weeksOfMonth = [4];\n      dailyTask.startDate = day;\n      dailyTask.everyX = 1;\n      dailyTask.repeat = {\n        su: false,\n        m: true,\n        t: false,\n        w: false,\n        th: false,\n        f: false,\n        s: false\n      };\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue.length).to.eql(6);\n      expect(moment(nextDue[0]).toDate()).to.eql(moment.utc('2017-07-31').toDate());\n      expect(moment(nextDue[1]).toDate()).to.eql(moment.utc('2017-10-30').toDate());\n      expect(moment(nextDue[2]).toDate()).to.eql(moment.utc('2018-01-29').toDate());\n      expect(moment(nextDue[3]).toDate()).to.eql(moment.utc('2018-04-30').toDate());\n      expect(moment(nextDue[4]).toDate()).to.eql(moment.utc('2018-07-30').toDate());\n      expect(moment(nextDue[5]).toDate()).to.eql(moment.utc('2018-10-29').toDate());\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due","suites":["shouldDo","Monthly - Every X Months on a specified date","Custom Day Start is 0 <= n < 24","Current Date is one day before the matching day"],"updatePoint":{"line":750,"column":29,"index":29808},"line":750,"code":"        it('should not be due', () => {\n          day = moment(day).subtract(1, 'days').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is before Custom Day Start","suites":["shouldDo","Monthly - Every X Months on a specified date","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":756,"column":68,"index":30097},"line":756,"code":"        it('returns false if current hour is before Custom Day Start', () => {\n          day = moment(day).startOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is after Custom Day Start","suites":["shouldDo","Monthly - Every X Months on a specified date","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":760,"column":66,"index":30324},"line":760,"code":"        it('returns true if current hour is after Custom Day Start', () => {\n          day = moment(day).startOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is before Custom Day Start","suites":["shouldDo","Monthly - Every X Months on a specified date","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":766,"column":67,"index":30633},"line":766,"code":"        it('returns true if current hour is before Custom Day Start', () => {\n          day = moment(day).endOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is after Custom Day Start","suites":["shouldDo","Monthly - Every X Months on a specified date","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":770,"column":67,"index":30858},"line":770,"code":"        it('returns false if current hour is after Custom Day Start', () => {\n          day = moment(day).endOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"leaves daily inactive if not the correct week of the month on the day of the start date","suites":["shouldDo","Monthly - Certain days of the nth Week"],"updatePoint":{"line":778,"column":95,"index":31196},"line":778,"code":"    it('leaves daily inactive if not the correct week of the month on the day of the start date', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      const today = moment('2017-01-27');\n      const week = today.monthWeek();\n      const dayOfWeek = today.day();\n      dailyTask.startDate = today.toDate();\n      dailyTask.weeksOfMonth = [week];\n      dailyTask.repeat[DAY_MAPPING[dayOfWeek]] = true;\n      dailyTask.everyX = 1;\n      dailyTask.frequency = 'monthly';\n      day = moment('2017-02-23');\n      expect(shouldDo(day, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false when next due is requested and no repeats are available","suites":["shouldDo","Monthly - Certain days of the nth Week"],"updatePoint":{"line":799,"column":77,"index":31876},"line":799,"code":"    it('returns false when next due is requested and no repeats are available', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      const today = moment('2017-05-27T17:34:40.000Z');\n      const week = today.monthWeek();\n      dailyTask.startDate = today.toDate();\n      dailyTask.weeksOfMonth = [week];\n      dailyTask.everyX = 1;\n      dailyTask.frequency = 'monthly';\n      day = moment('2017-02-23');\n      options.nextDue = true;\n      expect(shouldDo(day, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily if correct week of the month on the day of the start date","suites":["shouldDo","Monthly - Certain days of the nth Week"],"updatePoint":{"line":819,"column":81,"index":32512},"line":819,"code":"    it('activates Daily if correct week of the month on the day of the start date', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      const today = moment('2017-01-27:00:00.000-00:00');\n      const week = today.monthWeek();\n      const dayOfWeek = today.day();\n      dailyTask.startDate = today.toDate();\n      dailyTask.weeksOfMonth = [week];\n      dailyTask.repeat[DAY_MAPPING[dayOfWeek]] = true;\n      dailyTask.everyX = 1;\n      dailyTask.frequency = 'monthly';\n      day = moment('2017-02-24:00:00.000-00:00');\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"leaves daily inactive if not day of the month with every x month on weekday","suites":["shouldDo","Monthly - Certain days of the nth Week"],"updatePoint":{"line":840,"column":83,"index":33229},"line":840,"code":"    it('leaves daily inactive if not day of the month with every x month on weekday', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      const today = moment('2017-01-26:00:00.000-00:00');\n      const week = today.monthWeek();\n      const dayOfWeek = today.day();\n      dailyTask.startDate = today.toDate();\n      dailyTask.weeksOfMonth = [week];\n      dailyTask.repeat[DAY_MAPPING[dayOfWeek]] = true;\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'monthly';\n      day = moment('2017-03-24:00:00.000-00:00');\n      expect(shouldDo(day, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily if on nth weekday of the x month","suites":["shouldDo","Monthly - Certain days of the nth Week"],"updatePoint":{"line":861,"column":56,"index":33920},"line":861,"code":"    it('activates Daily if on nth weekday of the x month', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      const today = moment('2017-01-27:00:00.000-00:00');\n      const week = today.monthWeek();\n      const dayOfWeek = today.day();\n      dailyTask.startDate = today.toDate();\n      dailyTask.weeksOfMonth = [week];\n      dailyTask.repeat[DAY_MAPPING[dayOfWeek]] = true;\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'monthly';\n      day = moment('2017-03-24:00:00.000-00:00');\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on start date","suites":["shouldDo","Monthly - Certain days of the nth Week"],"updatePoint":{"line":882,"column":37,"index":34591},"line":882,"code":"    it('activates Daily on start date', () => {\n      dailyTask.repeat = {\n        su: false,\n        s: false,\n        f: false,\n        th: false,\n        w: false,\n        t: false,\n        m: false\n      };\n      const today = moment('2017-01-27:00:00.000-00:00');\n      const week = today.monthWeek();\n      const dayOfWeek = today.day();\n      dailyTask.startDate = today.toDate();\n      dailyTask.weeksOfMonth = [week];\n      dailyTask.repeat[DAY_MAPPING[dayOfWeek]] = true;\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'monthly';\n      day = moment('2017-03-24:00:00.000-00:00');\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due","suites":["shouldDo","Monthly - Certain days of the nth Week","Custom Day Start is 0 <= n < 24","Current Date is one day before the matching day"],"updatePoint":{"line":926,"column":29,"index":36002},"line":926,"code":"        it('should not be due', () => {\n          day = moment(day).subtract(1, 'days').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is before Custom Day Start","suites":["shouldDo","Monthly - Certain days of the nth Week","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":932,"column":68,"index":36291},"line":932,"code":"        it('returns false if current hour is before Custom Day Start', () => {\n          day = moment(day).startOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is after Custom Day Start","suites":["shouldDo","Monthly - Certain days of the nth Week","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":936,"column":66,"index":36518},"line":936,"code":"        it('returns true if current hour is after Custom Day Start', () => {\n          day = moment(day).startOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is before Custom Day Start","suites":["shouldDo","Monthly - Certain days of the nth Week","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":942,"column":67,"index":36827},"line":942,"code":"        it('returns true if current hour is before Custom Day Start', () => {\n          day = moment(day).endOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is after Custom Day Start","suites":["shouldDo","Monthly - Certain days of the nth Week","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":946,"column":67,"index":37052},"line":946,"code":"        it('returns false if current hour is after Custom Day Start', () => {\n          day = moment(day).endOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"leaves daily inactive if not the correct year","suites":["shouldDo","Every X Years"],"updatePoint":{"line":954,"column":53,"index":37323},"line":954,"code":"    it('leaves daily inactive if not the correct year', () => {\n      day = moment();\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'yearly';\n      day = day.add(1, 'day').toDate();\n      expect(shouldDo(day, dailyTask, options)).to.equal(false);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on matching year","suites":["shouldDo","Every X Years"],"updatePoint":{"line":961,"column":40,"index":37575},"line":961,"code":"    it('activates Daily on matching year', () => {\n      day = moment();\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'yearly';\n      day = day.add(2, 'years').toDate();\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"activates Daily on start date","suites":["shouldDo","Every X Years"],"updatePoint":{"line":968,"column":37,"index":37825},"line":968,"code":"    it('activates Daily on start date', () => {\n      day = moment();\n      dailyTask.everyX = 2;\n      dailyTask.frequency = 'yearly';\n      day = day.add(2, 'years').toDate();\n      expect(shouldDo(day, dailyTask, options)).to.equal(true);\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should compute yearly nextDue values","suites":["shouldDo","Every X Years"],"updatePoint":{"line":975,"column":44,"index":38082},"line":975,"code":"    it('should compute yearly nextDue values', () => {\n      options.timezoneOffset = 0;\n      options.nextDue = true;\n      day = moment.utc('2017-05-01').toDate();\n      dailyTask.frequency = 'yearly';\n      dailyTask.everyX = 5;\n      dailyTask.startDate = day;\n      nextDue = shouldDo(day, dailyTask, options);\n      expect(nextDue.length).to.eql(6);\n      expect(moment(nextDue[0]).toDate()).to.eql(moment.utc('2022-05-01').toDate());\n      expect(moment(nextDue[1]).toDate()).to.eql(moment.utc('2027-05-01').toDate());\n      expect(moment(nextDue[2]).toDate()).to.eql(moment.utc('2032-05-01').toDate());\n      expect(moment(nextDue[3]).toDate()).to.eql(moment.utc('2037-05-01').toDate());\n      expect(moment(nextDue[4]).toDate()).to.eql(moment.utc('2042-05-01').toDate());\n      expect(moment(nextDue[5]).toDate()).to.eql(moment.utc('2047-05-01').toDate());\n    });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"should not be due","suites":["shouldDo","Every X Years","Custom Day Start is 0 <= n < 24","Current Date is one day before the matching day"],"updatePoint":{"line":1000,"column":29,"index":39272},"line":1000,"code":"        it('should not be due', () => {\n          day = moment(day).subtract(1, 'days').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is before Custom Day Start","suites":["shouldDo","Every X Years","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":1006,"column":68,"index":39561},"line":1006,"code":"        it('returns false if current hour is before Custom Day Start', () => {\n          day = moment(day).startOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is after Custom Day Start","suites":["shouldDo","Every X Years","Custom Day Start is 0 <= n < 24","Current Date is on the matching day"],"updatePoint":{"line":1010,"column":66,"index":39788},"line":1010,"code":"        it('returns true if current hour is after Custom Day Start', () => {\n          day = moment(day).startOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns true if current hour is before Custom Day Start","suites":["shouldDo","Every X Years","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":1016,"column":67,"index":40097},"line":1016,"code":"        it('returns true if current hour is before Custom Day Start', () => {\n          day = moment(day).endOf('day').add(1, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(true);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"returns false if current hour is after Custom Day Start","suites":["shouldDo","Every X Years","Custom Day Start is 0 <= n < 24","Current Date is one day after the matching day"],"updatePoint":{"line":1020,"column":67,"index":40322},"line":1020,"code":"        it('returns false if current hour is after Custom Day Start', () => {\n          day = moment(day).endOf('day').add(9, 'hours').toDate();\n          expect(shouldDo(day, dailyTask, options)).to.equal(false);\n        });","file":"common/shouldDo.test.js","skipped":false,"dir":"test"},{"name":"provides a maximum Health value","suites":["helper functions used in stat calculations","maxHealth"],"updatePoint":{"line":11,"column":39,"index":272},"line":11,"code":"    it('provides a maximum Health value', () => {\n      const HEALTH_CAP = 50;\n      expect(maxHealth).to.eql(HEALTH_CAP);\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"returns a maximum level for attribute gain","suites":["helper functions used in stat calculations","maxLevel"],"updatePoint":{"line":19,"column":50,"index":496},"line":19,"code":"    it('returns a maximum level for attribute gain', () => {\n      expect(maxLevel).to.eql(LEVEL_CAP);\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"returns level given if below cap","suites":["helper functions used in stat calculations","capByLevel"],"updatePoint":{"line":24,"column":40,"index":636},"line":24,"code":"    it('returns level given if below cap', () => {\n      expect(capByLevel(LEVEL)).to.eql(LEVEL);\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"returns level given if equal to cap","suites":["helper functions used in stat calculations","capByLevel"],"updatePoint":{"line":27,"column":43,"index":745},"line":27,"code":"    it('returns level given if equal to cap', () => {\n      expect(capByLevel(LEVEL_CAP)).to.eql(LEVEL_CAP);\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"returns level cap if above cap","suites":["helper functions used in stat calculations","capByLevel"],"updatePoint":{"line":30,"column":38,"index":857},"line":30,"code":"    it('returns level cap if above cap', () => {\n      expect(capByLevel(LEVEL_CAP + LEVEL)).to.eql(LEVEL_CAP);\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"increases Experience target from one level to the next","suites":["helper functions used in stat calculations","toNextLevel"],"updatePoint":{"line":35,"column":62,"index":1041},"line":35,"code":"    it('increases Experience target from one level to the next', () => {\n      _.times(110, level => {\n        expect(tnl(level + 1)).to.be.greaterThan(tnl(level));\n      });\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"provides a value under the maximum, given a bonus and maximum","suites":["helper functions used in stat calculations","diminishingReturns"],"updatePoint":{"line":45,"column":69,"index":1350},"line":45,"code":"    it('provides a value under the maximum, given a bonus and maximum', () => {\n      expect(diminishingReturns(BONUS, MAXIMUM)).to.be.lessThan(MAXIMUM);\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"provides a value under the maximum, given a bonus, maximum, and halfway point","suites":["helper functions used in stat calculations","diminishingReturns"],"updatePoint":{"line":48,"column":85,"index":1528},"line":48,"code":"    it('provides a value under the maximum, given a bonus, maximum, and halfway point', () => {\n      expect(diminishingReturns(BONUS, MAXIMUM, HALFWAY)).to.be.lessThan(MAXIMUM);\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"provides a different curve if a halfway point is defined","suites":["helper functions used in stat calculations","diminishingReturns"],"updatePoint":{"line":51,"column":64,"index":1694},"line":51,"code":"    it('provides a different curve if a halfway point is defined', () => {\n      expect(diminishingReturns(BONUS, MAXIMUM, HALFWAY)).to.not.eql(diminishingReturns(BONUS, MAXIMUM));\n    });","file":"common/statHelpers.test.js","skipped":false,"dir":"test"},{"name":"is a combination of drop and quest eggs","suites":["eggs","all"],"updatePoint":{"line":6,"column":47,"index":270},"line":6,"code":"    it('is a combination of drop and quest eggs', () => {\n      const dropNumber = Object.keys(eggs.drops).length;\n      const questNumber = Object.keys(eggs.quests).length;\n      const allNumber = Object.keys(eggs.all).length;\n      expect(allNumber).to.be.greaterThan(0);\n      expect(allNumber).to.equal(dropNumber + questNumber);\n    });","file":"content/eggs.test.js","skipped":false,"dir":"test"},{"name":"contains basic information about each egg","suites":["eggs","all"],"updatePoint":{"line":13,"column":49,"index":614},"line":13,"code":"    it('contains basic information about each egg', () => {\n      each(eggs.all, (egg, key) => {\n        expectValidTranslationString(egg.text);\n        expectValidTranslationString(egg.adjective);\n        expectValidTranslationString(egg.mountText);\n        expectValidTranslationString(egg.notes);\n        expect(egg.canBuy).to.be.a('function');\n        expect(egg.value).to.be.a('number');\n        expect(egg.key).to.equal(key);\n      });\n    });","file":"content/eggs.test.js","skipped":false,"dir":"test"},{"name":"is a combination of drop, premium, and wacky potions","suites":["hatchingPotions","all"],"updatePoint":{"line":6,"column":60,"index":317},"line":6,"code":"    it('is a combination of drop, premium, and wacky potions', () => {\n      const dropNumber = Object.keys(hatchingPotions.drops).length;\n      const premiumNumber = Object.keys(hatchingPotions.premium).length;\n      const wackyNumber = Object.keys(hatchingPotions.wacky).length;\n      const allNumber = Object.keys(hatchingPotions.all).length;\n      expect(allNumber).to.be.greaterThan(0);\n      expect(allNumber).to.equal(dropNumber + premiumNumber + wackyNumber);\n    });","file":"content/hatching-potions.test.js","skipped":false,"dir":"test"},{"name":"contains basic information about each potion","suites":["hatchingPotions","all"],"updatePoint":{"line":14,"column":52,"index":785},"line":14,"code":"    it('contains basic information about each potion', () => {\n      each(hatchingPotions.all, (potion, key) => {\n        expectValidTranslationString(potion.text);\n        expectValidTranslationString(potion.notes);\n        expect(potion.canBuy).to.be.a('function');\n        expect(potion.value).to.be.a('number');\n        expect(potion.key).to.equal(key);\n      });\n    });","file":"content/hatching-potions.test.js","skipped":false,"dir":"test"},{"name":"has a valid text string","suites":["Mystery Sets"],"updatePoint":{"line":5,"column":29,"index":244},"line":5,"code":"  it('has a valid text string', () => {\n    each(mysterySets, set => {\n      expectValidTranslationString(set.text);\n    });\n  });","file":"content/mysterySets.test.js","skipped":false,"dir":"test"},{"name":"contains a pet for each drop potion * each drop egg","suites":["stable","dropPets"],"updatePoint":{"line":9,"column":59,"index":505},"line":9,"code":"    it('contains a pet for each drop potion * each drop egg', () => {\n      const numberOfDropPotions = Object.keys(potions.drops).length;\n      const numberOfDropEggs = Object.keys(eggs.drops).length;\n      const numberOfDropPets = Object.keys(stable.dropPets).length;\n      const expectedTotal = numberOfDropPotions * numberOfDropEggs;\n      expect(numberOfDropPets).to.be.greaterThan(0);\n      expect(numberOfDropPets).to.equal(expectedTotal);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains a pet for each drop potion * each quest egg","suites":["stable","questPets"],"updatePoint":{"line":19,"column":60,"index":999},"line":19,"code":"    it('contains a pet for each drop potion * each quest egg', () => {\n      const numberOfDropPotions = Object.keys(potions.drops).length;\n      const numberOfQuestEggs = Object.keys(eggs.quests).length;\n      const numberOfQuestPets = Object.keys(stable.questPets).length;\n      const expectedTotal = numberOfDropPotions * numberOfQuestEggs;\n      expect(numberOfQuestPets).to.be.greaterThan(0);\n      expect(numberOfQuestPets).to.equal(expectedTotal);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains a pet for each premium potion * each drop egg","suites":["stable","premiumPets"],"updatePoint":{"line":29,"column":62,"index":1504},"line":29,"code":"    it('contains a pet for each premium potion * each drop egg', () => {\n      const numberOfPremiumPotions = Object.keys(potions.premium).length;\n      const numberOfDropEggs = Object.keys(eggs.drops).length;\n      const numberOfPremiumPets = Object.keys(stable.premiumPets).length;\n      const expectedTotal = numberOfPremiumPotions * numberOfDropEggs;\n      expect(numberOfPremiumPets).to.be.greaterThan(0);\n      expect(numberOfPremiumPets).to.equal(expectedTotal);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains a pet for each wacky potion * each drop egg","suites":["stable","wackyPets"],"updatePoint":{"line":39,"column":60,"index":2018},"line":39,"code":"    it('contains a pet for each wacky potion * each drop egg', () => {\n      const numberOfWackyPotions = Object.keys(potions.wacky).length;\n      const numberOfDropEggs = Object.keys(eggs.drops).length;\n      const numberOfWackyPets = Object.keys(stable.wackyPets).length;\n      const expectedTotal = numberOfWackyPotions * numberOfDropEggs;\n      expect(numberOfWackyPets).to.be.greaterThan(0);\n      expect(numberOfWackyPets).to.equal(expectedTotal);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"each value is a valid translation string","suites":["stable","specialPets"],"updatePoint":{"line":49,"column":48,"index":2508},"line":49,"code":"    it('each value is a valid translation string', () => {\n      each(stable.specialPets, pet => {\n        const string = t(pet);\n        expectValidTranslationString(string);\n      });\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains a mount for each drop potion * each drop egg","suites":["stable","dropMounts"],"updatePoint":{"line":57,"column":61,"index":2754},"line":57,"code":"    it('contains a mount for each drop potion * each drop egg', () => {\n      const numberOfDropPotions = Object.keys(potions.drops).length;\n      const numberOfDropEggs = Object.keys(eggs.drops).length;\n      const numberOfDropMounts = Object.keys(stable.dropMounts).length;\n      const expectedTotal = numberOfDropPotions * numberOfDropEggs;\n      expect(numberOfDropMounts).to.be.greaterThan(0);\n      expect(numberOfDropMounts).to.equal(expectedTotal);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains a mount for each drop potion * each quest egg","suites":["stable","questMounts"],"updatePoint":{"line":67,"column":62,"index":3260},"line":67,"code":"    it('contains a mount for each drop potion * each quest egg', () => {\n      const numberOfDropPotions = Object.keys(potions.drops).length;\n      const numberOfQuestEggs = Object.keys(eggs.quests).length;\n      const numberOfQuestMounts = Object.keys(stable.questMounts).length;\n      const expectedTotal = numberOfDropPotions * numberOfQuestEggs;\n      expect(numberOfQuestMounts).to.be.greaterThan(0);\n      expect(numberOfQuestMounts).to.equal(expectedTotal);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains a mount for each premium potion * each drop egg","suites":["stable","premiumMounts"],"updatePoint":{"line":77,"column":64,"index":3777},"line":77,"code":"    it('contains a mount for each premium potion * each drop egg', () => {\n      const numberOfPremiumPotions = Object.keys(potions.premium).length;\n      const numberOfDropEggs = Object.keys(eggs.drops).length;\n      const numberOfPremiumMounts = Object.keys(stable.premiumMounts).length;\n      const expectedTotal = numberOfPremiumPotions * numberOfDropEggs;\n      expect(numberOfPremiumMounts).to.be.greaterThan(0);\n      expect(numberOfPremiumMounts).to.equal(expectedTotal);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"each value is a valid translation string","suites":["stable","specialMounts"],"updatePoint":{"line":87,"column":48,"index":4291},"line":87,"code":"    it('each value is a valid translation string', () => {\n      each(stable.specialMounts, mount => {\n        const string = t(mount);\n        expectValidTranslationString(string);\n      });\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains an entry for all pets","suites":["stable","petInfo"],"updatePoint":{"line":95,"column":38,"index":4517},"line":95,"code":"    it('contains an entry for all pets', () => {\n      const dropNumber = Object.keys(stable.dropPets).length;\n      const questNumber = Object.keys(stable.questPets).length;\n      const specialNumber = Object.keys(stable.specialPets).length;\n      const premiumNumber = Object.keys(stable.premiumPets).length;\n      const wackyNumber = Object.keys(stable.wackyPets).length;\n      const allNumber = Object.keys(stable.petInfo).length;\n      expect(allNumber).to.be.greaterThan(0);\n      expect(allNumber).to.equal(dropNumber + questNumber + specialNumber + premiumNumber + wackyNumber);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains basic information about each pet","suites":["stable","petInfo"],"updatePoint":{"line":105,"column":49,"index":5123},"line":105,"code":"    it('contains basic information about each pet', () => {\n      each(stable.petInfo, (pet, key) => {\n        expectValidTranslationString(pet.text);\n        expect(pet.type).to.be.a('string');\n        expect(pet.key).to.equal(key);\n      });\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains an entry for all mounts","suites":["stable","mountInfo"],"updatePoint":{"line":114,"column":40,"index":5404},"line":114,"code":"    it('contains an entry for all mounts', () => {\n      const dropNumber = Object.keys(stable.dropMounts).length;\n      const questNumber = Object.keys(stable.questMounts).length;\n      const specialNumber = Object.keys(stable.specialMounts).length;\n      const premiumNumber = Object.keys(stable.premiumMounts).length;\n      const allNumber = Object.keys(stable.mountInfo).length;\n      expect(allNumber).to.be.greaterThan(0);\n      expect(allNumber).to.equal(dropNumber + questNumber + specialNumber + premiumNumber);\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"contains basic information about each mount","suites":["stable","mountInfo"],"updatePoint":{"line":123,"column":51,"index":5944},"line":123,"code":"    it('contains basic information about each mount', () => {\n      each(stable.mountInfo, (mount, key) => {\n        expectValidTranslationString(mount.text);\n        expect(mount.type).to.be.a('string');\n        expect(mount.key).to.equal(key);\n      });\n    });","file":"content/stable.test.js","skipped":false,"dir":"test"},{"name":"removes owned sets from the time travelers store","suites":["time-travelers store"],"updatePoint":{"line":8,"column":54,"index":299},"line":8,"code":"  it('removes owned sets from the time travelers store', () => {\n    user.items.gear.owned.head_mystery_201602 = true; // eslint-disable-line camelcase\n\n    expect(timeTravelers.timeTravelerStore(user)['201602']).to.not.exist;\n    expect(timeTravelers.timeTravelerStore(user)['201603']).to.exist;\n  });","file":"content/time-travelers.test.js","skipped":false,"dir":"test"},{"name":"removes unopened mystery item sets from the time travelers store","suites":["time-travelers store"],"updatePoint":{"line":14,"column":70,"index":618},"line":14,"code":"  it('removes unopened mystery item sets from the time travelers store', () => {\n    user.purchased = {\n      plan: {\n        mysteryItems: ['head_mystery_201602']\n      }\n    };\n    expect(timeTravelers.timeTravelerStore(user)['201602']).to.not.exist;\n    expect(timeTravelers.timeTravelerStore(user)['201603']).to.exist;\n  });","file":"content/time-travelers.test.js","skipped":false,"dir":"test"},{"name":"displays the right level in the title","suites":["LevelUp"],"updatePoint":{"line":56,"column":43,"index":1407},"line":56,"code":"  it('displays the right level in the title', () => {\n    const title = testFunction('title', 12);\n    expect(title()).to.equal('\"reachedLevel\" {\"level\":12}');\n  });","file":"unit/components/achievements/levelUp.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"does not display rewards for level 10","suites":["LevelUp"],"updatePoint":{"line":60,"column":43,"index":1573},"line":60,"code":"  it('does not display rewards for level 10', () => {\n    const displayRewardQuest = testFunction('displayRewardQuest', 10);\n    expect(displayRewardQuest()).to.be.false;\n  });","file":"unit/components/achievements/levelUp.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"does display rewards for level ","suites":["LevelUp"],"updatePoint":{"line":65,"column":47,"index":1792},"line":65,"code":"    it(`does display rewards for level ${level}`, () => {\n      const displayRewardQuest = testFunction('displayRewardQuest', level);\n      expect(displayRewardQuest()).to.be.true;\n    });","file":"unit/components/achievements/levelUp.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"generates the right test class for level 15","suites":["LevelUp"],"updatePoint":{"line":70,"column":49,"index":1989},"line":70,"code":"  it('generates the right test class for level 15', () => {\n    const questClass = testFunction('questClass', 15);\n    expect(questClass()).to.equal('scroll inventory_quest_scroll_atom1');\n  });","file":"unit/components/achievements/levelUp.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"accurately reports class status","suites":["avatar.vue","hasClass"],"updatePoint":{"line":48,"column":39,"index":934},"line":48,"code":"    it('accurately reports class status', () => {\n      expect(vm.hasClass).to.equal(false);\n      vm.member.preferences.disableClasses = false;\n      vm.member.flags.classSelected = true;\n      expect(vm.hasClass).to.equal(true);\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"accurately reports if buffed","suites":["avatar.vue","isBuffed"],"updatePoint":{"line":56,"column":36,"index":1207},"line":56,"code":"    it('accurately reports if buffed', () => {\n      expect(vm.isBuffed).to.equal(undefined);\n      vm.member.stats.buffs = {\n        str: 1\n      };\n      expect(vm.isBuffed).to.equal(1);\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"defaults to 27px","suites":["avatar.vue","paddingTop"],"updatePoint":{"line":65,"column":25,"index":1432},"line":65,"code":"    xit('defaults to 27px', () => {\n      vm.avatarOnly = true;\n      expect(vm.paddingTop).to.equal('27px');\n    });","skipped":true,"file":"unit/components/avatar.spec.js","dir":"website/client/tests"},{"name":"is 24px if user has a pet","suites":["avatar.vue","paddingTop"],"updatePoint":{"line":69,"column":33,"index":1558},"line":69,"code":"    it('is 24px if user has a pet', () => {\n      vm.member.items = merge({\n        currentPet: {\n          name: 'Foo'\n        }\n      }, baseMember.items);\n      expect(vm.paddingTop).to.equal('24px');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"is 0px if user has a mount","suites":["avatar.vue","paddingTop"],"updatePoint":{"line":77,"column":34,"index":1771},"line":77,"code":"    it('is 0px if user has a mount', () => {\n      vm.member.items = merge({\n        currentMount: 'Bar'\n      }, baseMember.items);\n      expect(vm.paddingTop).to.equal('0px');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can be overriden","suites":["avatar.vue","paddingTop"],"updatePoint":{"line":83,"column":24,"index":1947},"line":83,"code":"    it('can be overriden', () => {\n      vm.overrideTopPadding = '27px';\n      expect(vm.paddingTop).to.equal('27px');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns if showing equipped gear","suites":["avatar.vue","costumeClass"],"updatePoint":{"line":89,"column":40,"index":2131},"line":89,"code":"    it('returns if showing equipped gear', () => {\n      expect(vm.costumeClass).to.equal('equipped');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns if wearing a costume","suites":["avatar.vue","costumeClass"],"updatePoint":{"line":92,"column":36,"index":2238},"line":92,"code":"    it('returns if wearing a costume', () => {\n      vm.member.preferences = {\n        costume: true,\n        hair: {}\n      };\n      vm.member.items.gear.costume = {};\n      expect(vm.costumeClass).to.equal('costume');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns an array of buffs","suites":["avatar.vue","visualBuffs"],"updatePoint":{"line":102,"column":33,"index":2503},"line":102,"code":"    it('returns an array of buffs', () => {\n      vm.member = merge({\n        stats: {\n          class: 'warrior'\n        }\n      }, baseMember);\n      expect(vm.visualBuffs).to.include({\n        snowball: 'avatar_snowball_warrior'\n      });\n      expect(vm.visualBuffs).to.include({\n        spookySparkles: 'ghost'\n      });\n      expect(vm.visualBuffs).to.include({\n        shinySeed: 'avatar_floral_warrior'\n      });\n      expect(vm.visualBuffs).to.include({\n        seafoam: 'seafoam_star'\n      });\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"shows the background","suites":["avatar.vue","backgroundClass"],"updatePoint":{"line":129,"column":28,"index":3172},"line":129,"code":"    it('shows the background', () => {\n      expect(vm.backgroundClass).to.equal('background_pony');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can be overridden","suites":["avatar.vue","backgroundClass"],"updatePoint":{"line":132,"column":25,"index":3278},"line":132,"code":"    it('can be overridden', () => {\n      vm.overrideAvatarGear = {\n        background: 'character'\n      };\n      expect(vm.backgroundClass).to.equal('background_character');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns to a blank string if not showing background","suites":["avatar.vue","backgroundClass"],"updatePoint":{"line":138,"column":59,"index":3496},"line":138,"code":"    it('returns to a blank string if not showing background', () => {\n      vm.withBackground = false;\n      vm.avatarOnly = true;\n      expect(vm.backgroundClass).to.equal('');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"checks if riding a Kangaroo","suites":["avatar.vue","specialMountClass"],"updatePoint":{"line":145,"column":35,"index":3704},"line":145,"code":"    it('checks if riding a Kangaroo', () => {\n      expect(vm.specialMountClass).to.equal(null);\n      vm.member.items = {\n        currentMount: 'Kangaroo',\n        gear: {\n          equipped: {}\n        }\n      };\n      expect(vm.specialMountClass).to.equal('offset-kangaroo');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns current skin color","suites":["avatar.vue","skinClass"],"updatePoint":{"line":157,"column":34,"index":4028},"line":157,"code":"    it('returns current skin color', () => {\n      vm.member = merge({\n        preferences: {\n          skin: 'blue'\n        }\n      }, baseMember);\n      expect(vm.skinClass).to.equal('skin_blue');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns if sleep or not","suites":["avatar.vue","skinClass"],"updatePoint":{"line":165,"column":31,"index":4232},"line":165,"code":"    it('returns if sleep or not', () => {\n      vm.member = merge({\n        preferences: {\n          skin: 'blue',\n          sleep: false\n        }\n      }, baseMember);\n      expect(vm.skinClass).to.equal('skin_blue');\n      vm.member.preferences.sleep = true;\n      expect(vm.skinClass).to.equal('skin_blue_sleep');\n    });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns undefined if no match","suites":["avatar.vue","methods","getGearClass"],"updatePoint":{"line":193,"column":39,"index":4933},"line":193,"code":"      it('returns undefined if no match', () => {\n        expect(vm.getGearClass('foo')).to.equal(undefined);\n      });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns the matching gear","suites":["avatar.vue","methods","getGearClass"],"updatePoint":{"line":196,"column":35,"index":5049},"line":196,"code":"      it('returns the matching gear', () => {\n        expect(vm.getGearClass('Hat')).to.equal('Fancy Tophat');\n      });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can be overridden","suites":["avatar.vue","methods","getGearClass"],"updatePoint":{"line":199,"column":27,"index":5162},"line":199,"code":"      it('can be overridden', () => {\n        vm.overrideAvatarGear = {\n          Hat: 'Dapper Bowler'\n        };\n        expect(vm.getGearClass('Hat')).to.equal('Dapper Bowler');\n      });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns no weapon equipped","suites":["avatar.vue","methods","hideGear"],"updatePoint":{"line":207,"column":36,"index":5402},"line":207,"code":"      it('returns no weapon equipped', () => {\n        vm.member.items.gear.equipped = {};\n        expect(vm.hideGear('weapon')).to.equal(false);\n      });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"does if not showing visual buffs","suites":["avatar.vue","methods","show avatar"],"updatePoint":{"line":242,"column":42,"index":6267},"line":242,"code":"      it('does if not showing visual buffs', () => {\n        expect(vm.showAvatar()).to.equal(true);\n        const {\n          buffs\n        } = vm.member.stats;\n        buffs.snowball = true;\n        expect(vm.showAvatar()).to.equal(false);\n        buffs.snowball = false;\n        buffs.spookySparkles = true;\n        expect(vm.showAvatar()).to.equal(false);\n        buffs.spookySparkles = false;\n        buffs.shinySeed = true;\n        expect(vm.showAvatar()).to.equal(false);\n        buffs.shinySeed = false;\n        buffs.seafoam = true;\n        expect(vm.showAvatar()).to.equal(false);\n        buffs.seafoam = false;\n        vm.showVisualBuffs = false;\n        expect(vm.showAvatar()).to.equal(true);\n      });","file":"unit/components/avatar.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"displays a category","suites":["Category Tags"],"updatePoint":{"line":19,"column":25,"index":448},"line":19,"code":"  it('displays a category', () => {\n    wrapper.setProps({\n      categories: [{\n        name: 'test'\n      }]\n    });\n    return Vue.nextTick().then(() => {\n      expect(wrapper.contains('.category-label')).to.eq(true);\n      expect(wrapper.find('.category-label').text()).to.eq('test');\n    });\n  });","file":"unit/components/categories/categoryTags.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"displays a habitica official in purple","suites":["Category Tags"],"updatePoint":{"line":30,"column":44,"index":769},"line":30,"code":"  it('displays a habitica official in purple', () => {\n    wrapper.setProps({\n      categories: [{\n        name: 'habitica_official'\n      }]\n    });\n    expect(wrapper.contains('.category-label-purple')).to.eq(true);\n    expect(wrapper.find('.category-label').text()).to.eq('habitica_official');\n  });","file":"unit/components/categories/categoryTags.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"displays owner label","suites":["Category Tags"],"updatePoint":{"line":39,"column":26,"index":1054},"line":39,"code":"  it('displays owner label', () => {\n    wrapper.setProps({\n      owner: true\n    });\n    expect(wrapper.contains('.category-label-blue')).to.eq(true);\n    expect(wrapper.find('.category-label').text()).to.eq('owned');\n  });","file":"unit/components/categories/categoryTags.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"displays member label","suites":["Category Tags"],"updatePoint":{"line":46,"column":27,"index":1280},"line":46,"code":"  it('displays member label', () => {\n    wrapper.setProps({\n      member: true\n    });\n    expect(wrapper.contains('.category-label-green')).to.eq(true);\n    expect(wrapper.find('.category-label').text()).to.eq('joined');\n  });","file":"unit/components/categories/categoryTags.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"displays additional content at the end","suites":["Category Tags"],"updatePoint":{"line":53,"column":44,"index":1526},"line":53,"code":"  it('displays additional content at the end', () => {\n    expect(wrapper.find('p').text()).to.eq('This is a slot.');\n  });","file":"unit/components/categories/categoryTags.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"removes a destroyed task from task list","suites":["Challenge Detail"],"updatePoint":{"line":67,"column":45,"index":1551},"line":67,"code":"  it('removes a destroyed task from task list', () => {\n    const taskToRemove = {\n      _id: '1',\n      type: 'habit'\n    };\n    wrapper.vm.taskDestroyed(taskToRemove);\n    expect(wrapper.vm.tasksByType[taskToRemove.type].length).to.eq(0);\n  });","file":"unit/components/challenges/challengeDetail.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"shows the message text","suites":["ChatCard"],"updatePoint":{"line":53,"column":28,"index":1058},"line":53,"code":"  it('shows the message text', () => {\n    expect(wrapper.find('div.text').text()).to.equal(message.text);\n    expect(wrapper.find('div.mentioned-icon').exists()).to.be.false;\n  });","file":"unit/components/chat/chatCard.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"shows mention dot if user is mentioned","suites":["ChatCard"],"updatePoint":{"line":57,"column":44,"index":1256},"line":57,"code":"  it('shows mention dot if user is mentioned', () => {\n    wrapper.setProps({\n      msg: createMessage('@Tester')\n    });\n    expect(wrapper.find('div.mentioned-icon').exists()).to.be.true;\n  }); // Bug fixed by https://github.com/HabitRPG/habitica/pull/12177","file":"unit/components/chat/chatCard.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"shows mention dot if user is mentioned after almostmention","suites":["ChatCard"],"updatePoint":{"line":64,"column":64,"index":1537},"line":64,"code":"  it('shows mention dot if user is mentioned after almostmention', () => {\n    wrapper.setProps({\n      msg: createMessage('thetester @Tester')\n    });\n    expect(wrapper.find('div.mentioned-icon').exists()).to.be.true;\n  });","file":"unit/components/chat/chatCard.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should have an empty object as sort-option at start","suites":["Members Modal Component","Party Sort"],"updatePoint":{"line":14,"column":59,"index":427},"line":14,"code":"    it('should have an empty object as sort-option at start', () => {\n      const defaultData = vm.data();\n      expect(defaultData.sortOption).to.eq({});\n    });","file":"unit/components/groups/membersModal.spec.js","skipped":true,"dir":"website/client/tests"},{"name":"should accept sort-option object","suites":["Members Modal Component","Party Sort"],"updatePoint":{"line":18,"column":40,"index":571},"line":18,"code":"    it('should accept sort-option object', () => {\n      const sortOption = vm.data().sortOption[0];\n      vm.sort(sortOption);\n      Vue.nextTick(() => {\n        expect(vm.data().sortOption).to.eq(sortOption);\n      });\n    });","file":"unit/components/groups/membersModal.spec.js","skipped":true,"dir":"website/client/tests"},{"name":"renders all guilds with no filter and no search","suites":["myGuilds component"],"updatePoint":{"line":74,"column":53,"index":1501},"line":74,"code":"  it('renders all guilds with no filter and no search', () => {\n    const wrapper = makeWrapper({\n      computed\n    });\n    expect(wrapper.findAll(PublicGuildItem).length).to.equal(4);\n  });","file":"unit/components/groups/myGuilds.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"renders guilds with name matching against a single-word search term","suites":["myGuilds component"],"updatePoint":{"line":80,"column":73,"index":1713},"line":80,"code":"  it('renders guilds with name matching against a single-word search term', () => {\n    const search = 'vow';\n    const wrapper = makeWrapper({\n      computed\n    });\n    wrapper.setData({\n      search\n    });\n    expect(wrapper.findAll(PublicGuildItem).length).to.equal(1);\n  });","file":"unit/components/groups/myGuilds.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"renders guilds with summary matching against a single-word search term","suites":["myGuilds component"],"updatePoint":{"line":90,"column":76,"index":1997},"line":90,"code":"  it('renders guilds with summary matching against a single-word search term', () => {\n    const search = '3d';\n    const wrapper = makeWrapper({\n      computed\n    });\n    wrapper.setData({\n      search\n    });\n    expect(wrapper.findAll(PublicGuildItem).length).to.equal(2);\n  });","file":"unit/components/groups/myGuilds.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"renders guilds with description matching against a single-word search term","suites":["myGuilds component"],"updatePoint":{"line":100,"column":80,"index":2284},"line":100,"code":"  it('renders guilds with description matching against a single-word search term', () => {\n    const search = 'hoho';\n    const wrapper = makeWrapper({\n      computed\n    });\n    wrapper.setData({\n      search\n    });\n    expect(wrapper.findAll(PublicGuildItem).length).to.equal(1);\n  });","file":"unit/components/groups/myGuilds.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"renders guilds with summary matching against two search terms with space in between","suites":["myGuilds component"],"updatePoint":{"line":110,"column":89,"index":2582},"line":110,"code":"  it('renders guilds with summary matching against two search terms with space in between', () => {\n    const search = '3d    ohayou';\n    const wrapper = makeWrapper({\n      computed\n    });\n    wrapper.setData({\n      search\n    });\n    expect(wrapper.findAll(PublicGuildItem).length).to.equal(2);\n  });","file":"unit/components/groups/myGuilds.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"has a visible title","suites":["Home"],"updatePoint":{"line":49,"column":25,"index":1303},"line":49,"code":"  it('has a visible title', () => {\n    expect(wrapper.find('h1').text()).to.equal('motivateYourself');\n  });","file":"unit/components/home.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"registers a user from the form","suites":["Home","signup form"],"updatePoint":{"line":53,"column":38,"index":1460},"line":53,"code":"    it('registers a user from the form', async () => {\n      const username = 'newUser';\n      const email = 'rookie@habitica.com';\n      const password = 'ImmaG3tProductive!';\n      await fillOutUserForm(username, email, password);\n      await wrapper.find('form').trigger('submit');\n      expect(registerStub.calledOnce).to.be.true;\n      expect(registerStub.getCall(0).args[1]).to.deep.equal({\n        username,\n        email,\n        password,\n        passwordConfirm: password,\n        groupInvite: ''\n      });\n    });","file":"unit/components/home.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"registers a user with group invite if groupInvite in the query","suites":["Home","signup form"],"updatePoint":{"line":68,"column":70,"index":2017},"line":68,"code":"    it('registers a user with group invite if groupInvite in the query', async () => {\n      const groupInvite = 'TheBestGroup';\n      wrapper = mountWrapper({\n        groupInvite\n      });\n      await fillOutUserForm('invitedUser', 'invited@habitica.com', '1veGotFri3ndsHooray!');\n      await wrapper.find('form').trigger('submit');\n      expect(registerStub.calledOnce).to.be.true;\n      expect(registerStub.getCall(0).args[1].groupInvite).to.equal(groupInvite);\n    });","file":"unit/components/home.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"registers a user with group invite if p in the query","suites":["Home","signup form"],"updatePoint":{"line":78,"column":60,"index":2480},"line":78,"code":"    it('registers a user with group invite if p in the query', async () => {\n      const p = 'ThePiGroup';\n      wrapper = mountWrapper({\n        p\n      });\n      await fillOutUserForm('alsoInvitedUser', 'invited2@habitica.com', '1veGotFri3nds2!');\n      await wrapper.find('form').trigger('submit');\n      expect(registerStub.calledOnce).to.be.true;\n      expect(registerStub.getCall(0).args[1].groupInvite).to.equal(p);\n    });","file":"unit/components/home.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"registers a user with group invite invite if both p and groupInvite are in the query","suites":["Home","signup form"],"updatePoint":{"line":88,"column":92,"index":2943},"line":88,"code":"    it('registers a user with group invite invite if both p and groupInvite are in the query', async () => {\n      const groupInvite = 'StillTheBestGroup';\n      wrapper = mountWrapper({\n        p: 'LesserGroup',\n        groupInvite\n      });\n      await fillOutUserForm('doublyInvitedUser', 'invited3@habitica.com', '1veGotSm4rtFri3nds!');\n      await wrapper.find('form').trigger('submit');\n      expect(registerStub.calledOnce).to.be.true;\n      expect(registerStub.getCall(0).args[1].groupInvite).to.equal(groupInvite);\n    });","file":"unit/components/home.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"prevents flickering by setting a 1px margin-right on elements of class member-stats","suites":["Members Details Component"],"line":13,"code":"  it.skip('prevents flickering by setting a 1px margin-right on elements of class member-stats', () => {","file":"unit/components/memberDetails.spec.js","skipped":true,"dir":"website/client/tests"},{"name":"set user has class computed prop","suites":["Notifications"],"updatePoint":{"line":46,"column":38,"index":1132},"line":46,"code":"  it('set user has class computed prop', () => {\n    expect(wrapper.vm.userHasClass).to.be.false;\n    store.state.user.data.stats.lvl = 10;\n    store.state.user.data.flags.classSelected = true;\n    store.state.user.data.preferences.disableClasses = false;\n    expect(wrapper.vm.userHasClass).to.be.true;\n  });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"notifies when user gets more exp","suites":["Notifications","user exp notifcation"],"updatePoint":{"line":54,"column":40,"index":1487},"line":54,"code":"    it('notifies when user gets more exp', () => {\n      const expSpy = sinon.spy(wrapper.vm, 'exp');\n      const userLevel = 10;\n      store.state.user.data.stats.lvl = userLevel;\n      const userExpBefore = 10;\n      const userExpAfter = 12;\n      wrapper.vm.displayUserExpAndLvlNotifications(userExpAfter, userExpBefore, userLevel, userLevel);\n      expect(expSpy).to.be.calledWith(userExpAfter - userExpBefore);\n      expSpy.restore();\n    });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"when user levels with exact xp","suites":["Notifications","user exp notifcation"],"updatePoint":{"line":64,"column":38,"index":1933},"line":64,"code":"    it('when user levels with exact xp', () => {\n      const expSpy = sinon.spy(wrapper.vm, 'exp');\n      const userLevelBefore = 9;\n      const userLevelAfter = 10;\n      store.state.user.data.stats.lvl = userLevelAfter;\n      const expEarned = 5;\n      const userExpBefore = toNextLevel(userLevelBefore) - expEarned;\n      const userExpAfter = 0;\n      wrapper.vm.displayUserExpAndLvlNotifications(userExpAfter, userExpBefore, userLevelAfter, userLevelBefore);\n      expect(expSpy).to.be.calledWith(expEarned);\n      expSpy.restore();\n    });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"when user levels with exact more exp than needed","suites":["Notifications","user exp notifcation"],"updatePoint":{"line":76,"column":56,"index":2496},"line":76,"code":"    it('when user levels with exact more exp than needed', () => {\n      const expSpy = sinon.spy(wrapper.vm, 'exp');\n      const userLevelBefore = 9;\n      const userLevelAfter = 10;\n      store.state.user.data.stats.lvl = userLevelAfter;\n      const expEarned = 10;\n      const expNeeded = 5;\n      const userExpBefore = toNextLevel(userLevelBefore) - expNeeded;\n      const userExpAfter = 5;\n      wrapper.vm.displayUserExpAndLvlNotifications(userExpAfter, userExpBefore, userLevelAfter, userLevelBefore);\n      expect(expSpy).to.be.calledWith(expEarned);\n      expSpy.restore();\n    });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"when user has more exp than needed then levels","suites":["Notifications","user exp notifcation"],"updatePoint":{"line":89,"column":54,"index":3085},"line":89,"code":"    it('when user has more exp than needed then levels', () => {\n      const expSpy = sinon.spy(wrapper.vm, 'exp');\n      const userLevelBefore = 9;\n      const userLevelAfter = 10;\n      store.state.user.data.stats.lvl = userLevelAfter;\n      const expEarned = 10;\n      const expNeeded = -5;\n      const userExpBefore = toNextLevel(userLevelBefore) - expNeeded;\n      const userExpAfter = 15;\n      wrapper.vm.displayUserExpAndLvlNotifications(userExpAfter, userExpBefore, userLevelAfter, userLevelBefore);\n      expect(expSpy).to.be.calledWith(expEarned);\n      expSpy.restore();\n    });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"when user multilevels","suites":["Notifications","user exp notifcation"],"updatePoint":{"line":102,"column":29,"index":3651},"line":102,"code":"    it('when user multilevels', () => {\n      const expSpy = sinon.spy(wrapper.vm, 'exp');\n      const userLevelBefore = 8;\n      const userLevelAfter = 10;\n      store.state.user.data.stats.lvl = userLevelAfter;\n      const expEarned = 10 + toNextLevel(userLevelBefore + 1);\n      const expNeeded = 5;\n      const userExpBefore = toNextLevel(userLevelBefore) - expNeeded;\n      const userExpAfter = 5;\n      wrapper.vm.displayUserExpAndLvlNotifications(userExpAfter, userExpBefore, userLevelAfter, userLevelBefore);\n      expect(expSpy).to.be.calledWith(expEarned);\n      expSpy.restore();\n    });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"when user looses xp","suites":["Notifications","user exp notifcation"],"updatePoint":{"line":115,"column":27,"index":4248},"line":115,"code":"    it('when user looses xp', () => {\n      const expSpy = sinon.spy(wrapper.vm, 'exp');\n      const userLevel = 10;\n      store.state.user.data.stats.lvl = userLevel;\n      const userExpBefore = 10;\n      const userExpAfter = 5;\n      wrapper.vm.displayUserExpAndLvlNotifications(userExpAfter, userExpBefore, userLevel, userLevel);\n      expect(expSpy).to.be.calledWith(userExpAfter - userExpBefore);\n      expSpy.restore();\n    });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"when user looses xp under 0","suites":["Notifications","user exp notifcation"],"updatePoint":{"line":125,"column":35,"index":4690},"line":125,"code":"    it('when user looses xp under 0', () => {\n      const expSpy = sinon.spy(wrapper.vm, 'exp');\n      const userLevel = 10;\n      store.state.user.data.stats.lvl = userLevel;\n      const userExpBefore = 5;\n      const userExpAfter = -3;\n      wrapper.vm.displayUserExpAndLvlNotifications(userExpAfter, userExpBefore, userLevel, userLevel);\n      expect(expSpy).to.be.calledWith(userExpAfter - userExpBefore);\n      expSpy.restore();\n    });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"when user dies","suites":["Notifications","user exp notifcation"],"updatePoint":{"line":135,"column":22,"index":5119},"line":135,"code":"    it('when user dies', () => {\n      const expSpy = sinon.spy(wrapper.vm, 'exp');\n      const userLevelBefore = 10;\n      const userLevelAfter = 9;\n      store.state.user.data.stats.lvl = userLevelAfter;\n      const expEarned = -20;\n      const userExpBefore = 20;\n      const userExpAfter = 0;\n      wrapper.vm.displayUserExpAndLvlNotifications(userExpAfter, userExpBefore, userLevelAfter, userLevelBefore);\n      expect(expSpy).to.be.calledWith(expEarned);\n      expSpy.restore();\n    });","file":"unit/components/notifications.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"displays title","suites":["Sidebar Section"],"updatePoint":{"line":15,"column":20,"index":370},"line":15,"code":"  it('displays title', () => {\n    expect(wrapper.find('h3').text()).to.eq('Hello World');\n  });","file":"unit/components/sidebarSection.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"displays contents","suites":["Sidebar Section"],"updatePoint":{"line":18,"column":23,"index":470},"line":18,"code":"  it('displays contents', () => {\n    expect(wrapper.find('.section-body').find('p').text()).to.eq('This is a test.');\n  });","file":"unit/components/sidebarSection.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"displays tooltip icon","suites":["Sidebar Section"],"updatePoint":{"line":21,"column":27,"index":599},"line":21,"code":"  it('displays tooltip icon', () => {\n    expect(wrapper.contains('.section-info')).to.eq(false);\n    wrapper.setProps({\n      tooltip: 'This is a test'\n    });\n    expect(wrapper.contains('.section-info')).to.eq(true);\n  });","file":"unit/components/sidebarSection.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"hides contents","suites":["Sidebar Section"],"updatePoint":{"line":28,"column":20,"index":818},"line":28,"code":"  it('hides contents', () => {\n    expect(wrapper.find('.section-body').element.style.display).to.not.eq('none');\n    wrapper.find('[role=\"button\"').trigger('click');\n    expect(wrapper.find('.section-body').element.style.display).to.eq('none');\n    wrapper.find('[role=\"button\"').trigger('click');\n    expect(wrapper.find('.section-body').element.style.display).to.not.eq('none');\n  });","file":"unit/components/sidebarSection.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can hide contents by default","suites":["Sidebar Section"],"updatePoint":{"line":35,"column":34,"index":1220},"line":35,"code":"  it('can hide contents by default', () => {\n    wrapper = mount(SidebarSection, {\n      propsData: {\n        title: 'Hello World',\n        show: false\n      },\n      slots: {\n        default: '<p>This is a test.</p>'\n      }\n    });\n    expect(wrapper.find('.section-body').element.style.display).to.eq('none');\n  });","file":"unit/components/sidebarSection.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns a vue instance","suites":["Task Column"],"updatePoint":{"line":33,"column":28,"index":749},"line":33,"code":"  it('returns a vue instance', () => {\n    wrapper = makeWrapper();\n    expect(wrapper.isVueInstance()).to.be.true;\n  });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"defaults isUser to false","suites":["Task Column","Passed Properties"],"updatePoint":{"line":41,"column":32,"index":977},"line":41,"code":"    it('defaults isUser to false', () => {\n      expect(wrapper.vm.isUser).to.be.false;\n    });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"passes isUser to component instance","suites":["Task Column","Passed Properties"],"updatePoint":{"line":44,"column":43,"index":1084},"line":44,"code":"    it('passes isUser to component instance', () => {\n      wrapper.setProps({\n        isUser: false\n      });\n      expect(wrapper.vm.isUser).to.be.false;\n      wrapper.setProps({\n        isUser: true\n      });\n      expect(wrapper.vm.isUser).to.be.true;\n    });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns task list from props for group-plan","suites":["Task Column","Computed Properties"],"updatePoint":{"line":82,"column":51,"index":1972},"line":82,"code":"    it('returns task list from props for group-plan', () => {\n      wrapper.setProps({\n        taskListOverride\n      });\n      wrapper.vm.taskList.forEach((el, i) => {\n        expect(el).to.eq(taskListOverride[i]);\n      });\n      wrapper.setProps({\n        isUser: false\n      });\n      wrapper.vm.taskList.forEach((el, i) => {\n        expect(el).to.eq(taskListOverride[i]);\n      });\n    });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns task list from store for user","suites":["Task Column","Computed Properties"],"updatePoint":{"line":96,"column":45,"index":2361},"line":96,"code":"    it('returns task list from store for user', () => {\n      wrapper.setProps({\n        isUser: true,\n        taskListOverride\n      });\n      wrapper.vm.taskList.forEach((el, i) => {\n        expect(el).to.eq(habits[i]);\n      });\n    });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns all tasks if no tag is given","suites":["Task Column","Methods","Filter By Tags"],"updatePoint":{"line":120,"column":46,"index":2885},"line":120,"code":"      it('returns all tasks if no tag is given', () => {\n        const returnedTasks = wrapper.vm.filterByTagList(tasks);\n        expect(returnedTasks).to.have.lengthOf(tasks.length);\n        tasks.forEach((task, i) => {\n          expect(returnedTasks[i]).to.eq(task);\n        });\n      });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns tasks for given single tag","suites":["Task Column","Methods","Filter By Tags"],"updatePoint":{"line":127,"column":44,"index":3174},"line":127,"code":"      it('returns tasks for given single tag', () => {\n        const returnedTasks = wrapper.vm.filterByTagList(tasks, [3]);\n        expect(returnedTasks).to.have.lengthOf(3);\n        expect(returnedTasks[0]).to.eq(tasks[0]);\n        expect(returnedTasks[1]).to.eq(tasks[1]);\n        expect(returnedTasks[2]).to.eq(tasks[3]);\n      });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns tasks for given multiple tags","suites":["Task Column","Methods","Filter By Tags"],"updatePoint":{"line":134,"column":47,"index":3513},"line":134,"code":"      it('returns tasks for given multiple tags', () => {\n        const returnedTasks = wrapper.vm.filterByTagList(tasks, [2, 3]);\n        expect(returnedTasks).to.have.lengthOf(1);\n        expect(returnedTasks[0]).to.eq(tasks[1]);\n      });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns all tasks for empty search term","suites":["Task Column","Methods","Filter By Search Text"],"updatePoint":{"line":172,"column":49,"index":4516},"line":172,"code":"      it('returns all tasks for empty search term', () => {\n        const returnedTasks = wrapper.vm.filterBySearchText(tasks);\n        expect(returnedTasks).to.have.lengthOf(tasks.length);\n        tasks.forEach((task, i) => {\n          expect(returnedTasks[i]).to.eq(task);\n        });\n      });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns tasks for search term in title /i","suites":["Task Column","Methods","Filter By Search Text"],"updatePoint":{"line":179,"column":51,"index":4815},"line":179,"code":"      it('returns tasks for search term in title /i', () => {\n        ['Title', 'TITLE', 'title', 'tItLe'].forEach(term => {\n          expect(wrapper.vm.filterBySearchText(tasks, term)[0]).to.eq(tasks[2]);\n        });\n      });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns tasks for search term in note /i","suites":["Task Column","Methods","Filter By Search Text"],"updatePoint":{"line":184,"column":50,"index":5042},"line":184,"code":"      it('returns tasks for search term in note /i', () => {\n        ['Note', 'NOTE', 'note', 'nOtE'].forEach(term => {\n          expect(wrapper.vm.filterBySearchText(tasks, term)[0]).to.eq(tasks[3]);\n        });\n      });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns tasks for search term in checklist title /i","suites":["Task Column","Methods","Filter By Search Text"],"updatePoint":{"line":189,"column":61,"index":5276},"line":189,"code":"      it('returns tasks for search term in checklist title /i', () => {\n        ['Check', 'CHECK', 'check', 'cHeCK'].forEach(term => {\n          const returnedTasks = wrapper.vm.filterBySearchText(tasks, term);\n          expect(returnedTasks[0]).to.eq(tasks[2]);\n          expect(returnedTasks[1]).to.eq(tasks[3]);\n        });\n        ['Checkitem', 'CHECKITEM', 'checkitem', 'cHeCKiTEm'].forEach(term => {\n          expect(wrapper.vm.filterBySearchText(tasks, term)[0]).to.eq(tasks[3]);\n        });\n      });","file":"unit/components/tasks/column.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns a vue instance","suites":["Task"],"updatePoint":{"line":43,"column":28,"index":1031},"line":43,"code":"  it('returns a vue instance', () => {\n    wrapper = makeWrapper();\n    expect(wrapper.isVueInstance()).to.be.true;\n  });","file":"unit/components/tasks/task.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"formats due date to today if due today","suites":["Task","Due date calculation"],"updatePoint":{"line":59,"column":46,"index":1421},"line":59,"code":"    it('formats due date to today if due today', () => {\n      const now = setClockTo('2019-09-17T17:57:00+02:00');\n      wrapper = makeWrapper({\n        date: now\n      });\n      expect(wrapper.vm.formatDueDate()).to.equal('dueIn{\"dueIn\":\"today\"}');\n    });","file":"unit/components/tasks/task.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"formats due date to tomorrow if due tomorrow","suites":["Task","Due date calculation"],"updatePoint":{"line":66,"column":52,"index":1686},"line":66,"code":"    it('formats due date to tomorrow if due tomorrow', () => {\n      const now = setClockTo('2012-06-12T14:17:28Z');\n      wrapper = makeWrapper({\n        date: now.add(1, 'day')\n      });\n      expect(wrapper.vm.formatDueDate()).to.equal('dueIn{\"dueIn\":\"in a day\"}');\n    });","file":"unit/components/tasks/task.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"formats due date to 5 days if due in 5 days","suites":["Task","Due date calculation"],"updatePoint":{"line":73,"column":51,"index":1962},"line":73,"code":"    it('formats due date to 5 days if due in 5 days', () => {\n      const now = setClockTo();\n      wrapper = makeWrapper({\n        date: now.add(5, 'days')\n      });\n      expect(wrapper.vm.formatDueDate()).to.equal('dueIn{\"dueIn\":\"in 5 days\"}');\n    });","file":"unit/components/tasks/task.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"formats due date to tomorrow if today but before dayStart","suites":["Task","Due date calculation"],"updatePoint":{"line":80,"column":65,"index":2232},"line":80,"code":"    it('formats due date to tomorrow if today but before dayStart', () => {\n      const now = setClockTo('2019-06-12T04:23:37+02:00');\n      wrapper = makeWrapper({\n        date: now.add(8, 'hours')\n      }, {\n        preferences: {\n          dayStart: 7\n        }\n      });\n      expect(wrapper.vm.formatDueDate()).to.equal('dueIn{\"dueIn\":\"in a day\"}');\n    });","file":"unit/components/tasks/task.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should render a challenge tag under challenge header in tag filter popup when the challenge is active","suites":["Tasks User","Computed Properties"],"updatePoint":{"line":32,"column":109,"index":801},"line":32,"code":"    it('should render a challenge tag under challenge header in tag filter popup when the challenge is active', () => {\n      const activeChallengeTag = {\n        id: '1',\n        name: 'Challenge1',\n        challenge: true\n      };\n      const wrapper = createWrapper(activeChallengeTag);\n      const computedTagsByType = wrapper.vm.tagsByType;\n      expect(computedTagsByType.challenges.tags.length).to.equal(1);\n      expect(computedTagsByType.challenges.tags[0].id).to.equal(activeChallengeTag.id);\n      expect(computedTagsByType.challenges.tags[0].name).to.equal(activeChallengeTag.name);\n    });","file":"unit/components/tasks/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should render a challenge tag under normal tag header in tag filter popup when the challenge is no longer active","suites":["Tasks User","Computed Properties"],"updatePoint":{"line":44,"column":120,"index":1415},"line":44,"code":"    it('should render a challenge tag under normal tag header in tag filter popup when the challenge is no longer active', () => {\n      const inactiveChallengeTag = {\n        id: '1',\n        name: 'Challenge1',\n        challenge: false\n      };\n      const wrapper = createWrapper(inactiveChallengeTag);\n      const computedTagsByType = wrapper.vm.tagsByType;\n      expect(computedTagsByType.challenges.tags.length).to.equal(0);\n      expect(computedTagsByType.user.tags.length).to.equal(1);\n      expect(computedTagsByType.user.tags[0].id).to.equal(inactiveChallengeTag.id);\n      expect(computedTagsByType.user.tags[0].name).to.equal(inactiveChallengeTag.name);\n    });","file":"unit/components/tasks/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"sets the correct default data","suites":["DrawerComponent"],"updatePoint":{"line":4,"column":35,"index":153},"line":4,"code":"  it('sets the correct default data', () => {\n    expect(DrawerComponent.data).to.be.a('function');\n    const defaultData = DrawerComponent.data();\n    expect(defaultData.isOpened).to.be.true;\n  });","file":"unit/components/ui/drawer.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"renders the correct title","suites":["DrawerComponent"],"updatePoint":{"line":9,"column":31,"index":348},"line":9,"code":"  it('renders the correct title', () => {\n    const Ctor = Vue.extend(DrawerComponent);\n    const vm = new Ctor({\n      propsData: {\n        title: 'My title'\n      }\n    }).$mount();\n    expect(vm.$el.textContent.trim()).to.be.equal('My title');\n  });","file":"unit/components/ui/drawer.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can floor a decimal number","suites":["floor filter"],"updatePoint":{"line":3,"column":32,"index":109},"line":3,"code":"  it('can floor a decimal number', () => {\n    expect(floorFilter(4.567)).to.equal(4.56);\n    expect(floorFilter(4.562)).to.equal(4.56);\n  });","file":"unit/filters/floor.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can round a decimal number","suites":["round filter"],"updatePoint":{"line":3,"column":32,"index":109},"line":3,"code":"  it('can round a decimal number', () => {\n    expect(roundFilter(4.567)).to.equal(4.57);\n    expect(roundFilter(4.562)).to.equal(4.56);\n  });","file":"unit/filters/round.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can round a decimal number","suites":["round big number filter"],"updatePoint":{"line":3,"column":32,"index":138},"line":3,"code":"  it('can round a decimal number', () => {\n    expect(roundBigNumberFilter(4.567)).to.equal(4.57);\n    expect(roundBigNumberFilter(4.562)).to.equal(4.56);\n  });","file":"unit/filters/roundBigNumber.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can round thousands","suites":["round big number filter"],"updatePoint":{"line":7,"column":25,"index":292},"line":7,"code":"  it('can round thousands', () => {\n    expect(roundBigNumberFilter(70065)).to.equal('70.1k');\n  });","file":"unit/filters/roundBigNumber.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can round milions","suites":["round big number filter"],"updatePoint":{"line":10,"column":23,"index":391},"line":10,"code":"  it('can round milions', () => {\n    expect(roundBigNumberFilter(10000987)).to.equal('10.0m');\n  });","file":"unit/filters/roundBigNumber.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can round bilions","suites":["round big number filter"],"updatePoint":{"line":13,"column":23,"index":493},"line":13,"code":"  it('can round bilions', () => {\n    expect(roundBigNumberFilter(1000000000)).to.equal('1.0b');\n  });","file":"unit/filters/roundBigNumber.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"asyncResourceFactory","suites":["async resource"],"updatePoint":{"line":6,"column":26,"index":261},"line":6,"code":"  it('asyncResourceFactory', () => {\n    const resource = asyncResourceFactory();\n    expect(resource.loadingStatus).to.equal('NOT_LOADED');\n    expect(resource.data).to.equal(null);\n    expect(resource).to.not.equal(asyncResourceFactory);\n  });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"store is missing","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":17,"column":26,"index":670},"line":17,"code":"      it('store is missing', () => {\n        expect(() => loadAsyncResource({})).to.throw;\n      });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"path is missing","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":20,"column":25,"index":770},"line":20,"code":"      it('path is missing', () => {\n        expect(() => loadAsyncResource({\n          store: 'store'\n        })).to.throw;\n      });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"url is missing","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":25,"column":24,"index":903},"line":25,"code":"      it('url is missing', () => {\n        expect(() => loadAsyncResource({\n          store: 'store',\n          path: 'path'\n        })).to.throw;\n      });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"deserialize is missing","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":31,"column":32,"index":1068},"line":31,"code":"      it('deserialize is missing', () => {\n        expect(() => loadAsyncResource({\n          store: 'store',\n          path: 'path',\n          url: 'url'\n        })).to.throw;\n      });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"resource not found","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":38,"column":28,"index":1251},"line":38,"code":"      it('resource not found', () => {\n        const store = generateStore();\n        expect(() => loadAsyncResource({\n          store,\n          path: 'not existing path',\n          url: 'url',\n          deserialize: 'deserialize'\n        })).to.throw;\n      });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"invalid loading status","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":47,"column":32,"index":1519},"line":47,"code":"      it('invalid loading status', () => {\n        const store = generateStore();\n        store.state.user.loadingStatus = 'INVALID';\n        expect(loadAsyncResource({\n          store,\n          path: 'user',\n          url: 'url',\n          deserialize: 'deserialize'\n        })).to.eventually.be.rejected;\n      });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns the resource if it is already loaded and forceLoad is false","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":58,"column":75,"index":1888},"line":58,"code":"    it('returns the resource if it is already loaded and forceLoad is false', async () => {\n      const store = generateStore();\n      store.state.user.loadingStatus = 'LOADED';\n      store.state.user.data = {\n        _id: 1\n      };\n      sandbox.stub(axios, 'get');\n      const resource = await loadAsyncResource({\n        store,\n        path: 'user',\n        url: 'url',\n        deserialize: 'deserialize'\n      });\n      expect(resource).to.equal(store.state.user);\n      expect(axios.get).to.not.have.been.called;\n    });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"load the resource if it is not loaded","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":74,"column":45,"index":2385},"line":74,"code":"    it('load the resource if it is not loaded', async () => {\n      const store = generateStore();\n      store.state.user = asyncResourceFactory();\n      sandbox.stub(axios, 'get').withArgs('/api/v4/user').returns(Promise.resolve({\n        data: {\n          data: {\n            _id: 1\n          }\n        }\n      }));\n      const resource = await loadAsyncResource({\n        store,\n        path: 'user',\n        url: '/api/v4/user',\n\n        deserialize(response) {\n          return response.data.data;\n        }\n\n      });\n      expect(resource).to.equal(store.state.user);\n      expect(resource.loadingStatus).to.equal('LOADED');\n      expect(resource.data._id).to.equal(1);\n      expect(axios.get).to.have.been.calledOnce;\n    });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"load the resource if it is loaded but forceLoad is true","suites":["async resource","loadAsyncResource","errors"],"updatePoint":{"line":99,"column":63,"index":3137},"line":99,"code":"    it('load the resource if it is loaded but forceLoad is true', async () => {\n      const store = generateStore();\n      store.state.user.loadingStatus = 'LOADED';\n      sandbox.stub(axios, 'get').withArgs('/api/v4/user').returns(Promise.resolve({\n        data: {\n          data: {\n            _id: 1\n          }\n        }\n      }));\n      const resource = await loadAsyncResource({\n        store,\n        path: 'user',\n        url: '/api/v4/user',\n\n        deserialize(response) {\n          return response.data.data;\n        },\n\n        forceLoad: true\n      });\n      expect(resource).to.equal(store.state.user);\n      expect(resource.loadingStatus).to.equal('LOADED');\n      expect(resource.data._id).to.equal(1);\n      expect(axios.get).to.have.been.calledOnce;\n    });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"load the resource if it is loaded but the appVersion has changed","suites":["async resource","loadAsyncResource","reloadOnAppVersionChange"],"updatePoint":{"line":133,"column":74,"index":4217},"line":133,"code":"      it('load the resource if it is loaded but the appVersion has changed', async () => {\n        store.state.serverAppVersion = 2;\n        sandbox.stub(axios, 'get').withArgs('/api/v4/world-state').returns(Promise.resolve({\n          data: {\n            data: {\n              _id: 1\n            }\n          }\n        }));\n        const resource = await loadAsyncResource({\n          store,\n          path: 'worldState',\n          url: '/api/v4/world-state',\n          reloadOnAppVersionChange: true,\n\n          deserialize(response) {\n            return response.data.data;\n          }\n\n        });\n        expect(resource).to.equal(store.state.worldState);\n        expect(resource.loadingStatus).to.equal('LOADED');\n        expect(resource.data._id).to.equal(1);\n        expect(axios.get).to.have.been.calledOnce;\n      });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"does not load the resource if it is loaded but the appVersion has changed","suites":["async resource","loadAsyncResource","reloadOnAppVersionChange"],"updatePoint":{"line":158,"column":83,"index":5053},"line":158,"code":"      it('does not load the resource if it is loaded but the appVersion has changed', async () => {\n        sandbox.stub(axios, 'get').returns(Promise.resolve({\n          data: {\n            data: {\n              _id: 1\n            }\n          }\n        }));\n        const resource = await loadAsyncResource({\n          store,\n          path: 'worldState',\n          url: '/api/v4/world-state',\n          reloadOnAppVersionChange: true,\n\n          deserialize(response) {\n            return response.data.data;\n          }\n\n        });\n        expect(resource).to.equal(store.state.worldState);\n        expect(axios.get).to.not.have.been.called;\n      });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"does not send multiple requests if the resource is being loaded","suites":["async resource","loadAsyncResource","reloadOnAppVersionChange"],"updatePoint":{"line":181,"column":71,"index":5705},"line":181,"code":"    it('does not send multiple requests if the resource is being loaded', async () => {\n      const store = generateStore();\n      store.state.user.loadingStatus = 'LOADING';\n      sandbox.stub(axios, 'get').withArgs('/api/v4/user').returns(Promise.resolve({\n        data: {\n          data: {\n            _id: 1\n          }\n        }\n      }));\n      const resourcePromise = loadAsyncResource({\n        store,\n        path: 'user',\n        url: '/api/v4/user',\n\n        deserialize(response) {\n          return response.data.data;\n        },\n\n        forceLoad: true\n      });\n      await sleep(0.1);\n      const userData = {\n        _id: 1\n      };\n      expect(store.state.user.loadingStatus).to.equal('LOADING');\n      expect(axios.get).to.not.have.been.called;\n      store.state.user.data = userData;\n      store.state.user.loadingStatus = 'LOADED';\n      const result = await resourcePromise;\n      expect(axios.get).to.not.have.been.called;\n      expect(result).to.equal(store.state.user);\n    });","file":"unit/libs/asyncResource.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"deeply freezes an object","suites":["deepFreeze"],"updatePoint":{"line":3,"column":30,"index":106},"line":3,"code":"  it('deeply freezes an object', () => {\n    const obj = {\n      a: 1,\n\n      b() {\n        return this.a;\n      },\n\n      nested: {\n        c: 2,\n        nestedTwice: {\n          d: 1\n        }\n      }\n    };\n    const result = deepFreeze(obj);\n    expect(result).to.equal(obj);\n    expect(Object.isFrozen(obj)).to.equal(true);\n    expect(Object.isFrozen(obj.nested)).to.equal(true);\n    expect(Object.isFrozen(obj.nested.nestedTwice)).to.equal(true);\n  });","file":"unit/libs/deepFreeze.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"adds $t to Vue.prototype","suites":["i18n plugin"],"updatePoint":{"line":14,"column":30,"index":313},"line":14,"code":"  it('adds $t to Vue.prototype', () => {\n    expect(Vue.prototype.$t).to.exist;\n  });","file":"unit/libs/i18n.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"$t is a proxy for common/i18n.t","suites":["i18n plugin"],"updatePoint":{"line":17,"column":37,"index":406},"line":17,"code":"  it('$t is a proxy for common/i18n.t', () => {\n    const result = new Vue().$t('reportBug');\n    expect(result).to.equal(commoni18n.t('reportBug'));\n    expect(result).to.equal('Report a Bug');\n  });","file":"unit/libs/i18n.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns null if no text supplied","suites":["renderWithMentions"],"updatePoint":{"line":16,"column":38,"index":322},"line":16,"code":"  it('returns null if no text supplied', () => {\n    const result = renderMarkdown('', user('a', 'b'));\n    expect(result).to.be.null;\n  });","file":"unit/libs/renderWithMentions.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"highlights displayname","suites":["renderWithMentions"],"updatePoint":{"line":20,"column":28,"index":453},"line":20,"code":"  it('highlights displayname', () => {\n    const text = 'hello @displayedUser with text after';\n    const result = renderMarkdown(text, user('user', 'displayedUser'));\n    expect(result).to.contain('<span class=\"at-text at-highlight\">@displayedUser</span>');\n  });","file":"unit/libs/renderWithMentions.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"highlights username","suites":["renderWithMentions"],"updatePoint":{"line":25,"column":25,"index":715},"line":25,"code":"  it('highlights username', () => {\n    const text = 'hello @user';\n    const result = renderMarkdown(text, user('user', 'displayedUser'));\n    expect(result).to.contain('<span class=\"at-text at-highlight\">@user</span>');\n  });","file":"unit/libs/renderWithMentions.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"highlights username sandwiched with underscores","suites":["renderWithMentions"],"updatePoint":{"line":30,"column":53,"index":971},"line":30,"code":"  it('highlights username sandwiched with underscores', () => {\n    const text = 'hello @_user_';\n    const result = renderMarkdown(text, user('_user_', 'displayedUser'));\n    expect(result).to.contain('<span class=\"at-text at-highlight\">@_user_</span>');\n    expect(result).to.not.contain('<em>');\n    expect(result).to.not.contain('</em>');\n  });","file":"unit/libs/renderWithMentions.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"highlights username sandwiched with double underscores","suites":["renderWithMentions"],"updatePoint":{"line":37,"column":60,"index":1327},"line":37,"code":"  it('highlights username sandwiched with double underscores', () => {\n    const text = 'hello @__user__';\n    const result = renderMarkdown(text, user('diffUser', 'displayDiffUser'));\n    expect(result).to.contain('<span class=\"at-text\">@__user__</span>');\n    expect(result).to.not.contain('<strong>');\n    expect(result).to.not.contain('</strong>');\n  });","file":"unit/libs/renderWithMentions.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"not highlights any email","suites":["renderWithMentions"],"updatePoint":{"line":44,"column":30,"index":1656},"line":44,"code":"  it('not highlights any email', () => {\n    const result = renderMarkdown('hello@example.com', user('example', 'displayedUser'));\n    expect(result).to.not.contain('<span class=\"at-highlight\">@example</span>');\n  });","file":"unit/libs/renderWithMentions.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"complex highlight","suites":["renderWithMentions"],"updatePoint":{"line":48,"column":23,"index":1867},"line":48,"code":"  it('complex highlight', () => {\n    const plainText = 'a bit more @mentions to @use my@mentions.com broken @mail.com';\n    const result = renderMarkdown(plainText, user('use', 'mentions'));\n    expect(result).to.contain('<span class=\"at-text at-highlight\">@mentions</span>');\n    expect(result).to.contain('<span class=\"at-text at-highlight\">@use</span>');\n    expect(result).to.contain('<span class=\"at-text\">@mail</span>');\n    expect(result).to.not.contain('<span class=\"at-text at-highlight\">@mentions</span>.com');\n  });","file":"unit/libs/renderWithMentions.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"injects itself in all component","suites":["Store"],"updatePoint":{"line":53,"column":37,"index":1122},"line":53,"code":"  it('injects itself in all component', done => {\n    new Vue({\n      // eslint-disable-line no-new\n      store,\n\n      created() {\n        expect(this.$store).to.equal(store);\n        done();\n      }\n\n    });\n  });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can watch a function on the state","suites":["Store"],"updatePoint":{"line":65,"column":39,"index":1340},"line":65,"code":"  it('can watch a function on the state', done => {\n    store.watch(state => state.name, newName => {\n      expect(newName).to.equal('test updated');\n      done();\n    });\n    store.state.name = 'test updated';\n  });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"supports getters","suites":["Store","getters"],"updatePoint":{"line":73,"column":24,"index":1572},"line":73,"code":"    it('supports getters', () => {\n      expect(store.getters.computedName).to.equal('test computed!');\n      store.state.name = 'test updated';\n      expect(store.getters.computedName).to.equal('test updated computed!');\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"supports nested getters","suites":["Store","getters"],"updatePoint":{"line":78,"column":31,"index":1809},"line":78,"code":"    it('supports nested getters', () => {\n      expect(store.getters['nested:computedName']).to.equal('test computed!');\n      store.state.name = 'test updated';\n      expect(store.getters['nested:computedName']).to.equal('test updated computed!');\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can dispatch an action","suites":["Store","actions"],"updatePoint":{"line":85,"column":30,"index":2101},"line":85,"code":"    it('can dispatch an action', async () => {\n      expect(await store.dispatch('getName', 1, 2, 3)).to.deep.equal(['test', 1, 2, 3]);\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can dispatch a nested action","suites":["Store","actions"],"updatePoint":{"line":88,"column":36,"index":2251},"line":88,"code":"    it('can dispatch a nested action', async () => {\n      expect(await store.dispatch('nested:getName', 1, 2, 3)).to.deep.equal(['test', 1, 2, 3]);\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"throws an error if the action doesn't exists","suites":["Store","actions"],"updatePoint":{"line":91,"column":53,"index":2425},"line":91,"code":"    it('throws an error if the action doesn\\'t exists', () => {\n      expect(() => store.dispatched('wrong')).to.throw;\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"mapState","suites":["Store","helpers"],"updatePoint":{"line":96,"column":16,"index":2552},"line":96,"code":"    it('mapState', done => {\n      new Vue({\n        // eslint-disable-line no-new\n        store,\n        data: {\n          title: 'internal'\n        },\n        computed: { ...mapState(['name']),\n          ...mapState({\n            nameComputed(state, getters) {\n              return `${this.title} ${getters.computedName} ${state.name}`;\n            }\n\n          }),\n          ...mapState({\n            nestedTest: 'nested.name'\n          })\n        },\n\n        created() {\n          expect(this.name).to.equal('test');\n          expect(this.nameComputed).to.equal('internal test computed! test');\n          expect(this.nestedTest).to.equal('nested state test');\n          done();\n        }\n\n      });\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"mapGetters","suites":["Store","helpers"],"updatePoint":{"line":124,"column":18,"index":3265},"line":124,"code":"    it('mapGetters', done => {\n      new Vue({\n        // eslint-disable-line no-new\n        store,\n        data: {\n          title: 'internal'\n        },\n        computed: { ...mapGetters(['computedName']),\n          ...mapGetters({\n            nameComputedTwice: 'computedName'\n          })\n        },\n\n        created() {\n          expect(this.computedName).to.equal('test computed!');\n          expect(this.nameComputedTwice).to.equal('test computed!');\n          done();\n        }\n\n      });\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"mapActions","suites":["Store","helpers"],"updatePoint":{"line":145,"column":18,"index":3770},"line":145,"code":"    it('mapActions', done => {\n      new Vue({\n        // eslint-disable-line no-new\n        store,\n        data: {\n          title: 'internal'\n        },\n\n        async created() {\n          expect(await this.getName('123')).to.deep.equal(['test', '123']);\n          expect(await this.getNameRenamed('123')).to.deep.equal(['test', '123']);\n          done();\n        },\n\n        methods: { ...mapActions(['getName']),\n          ...mapActions({\n            getNameRenamed: 'getName'\n          })\n        }\n      });\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"flattenAndNamespace","suites":["Store","helpers"],"updatePoint":{"line":166,"column":27,"index":4302},"line":166,"code":"    it('flattenAndNamespace', () => {\n      const result = flattenAndNamespace({\n        nested: {\n          computed({\n            state\n          }, ...args) {\n            return [state.name, ...args];\n          },\n\n          getName({\n            state\n          }, ...args) {\n            return [state.name, ...args];\n          }\n\n        },\n        nested2: {\n          getName({\n            state\n          }, ...args) {\n            return [state.name, ...args];\n          }\n\n        }\n      });\n      expect(Object.keys(result).length).to.equal(3);\n      expect(Object.keys(result).sort()).to.deep.equal(['nested2:getName', 'nested:computed', 'nested:getName']);\n    });","file":"unit/libs/store.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return correct task type labels","suites":["Filter Category for Tasks","getTypeLabel"],"updatePoint":{"line":4,"column":46,"index":227},"line":4,"code":"    it('should return correct task type labels', () => {\n      expect(getTypeLabel('habit')).to.eq('habits');\n      expect(getTypeLabel('daily')).to.eq('dailies');\n      expect(getTypeLabel('todo')).to.eq('todos');\n      expect(getTypeLabel('reward')).to.eq('rewards');\n    });","file":"unit/libs/store/helpers/filterTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return all task type filter labels by type","suites":["Filter Category for Tasks","getFilterLabels"],"updatePoint":{"line":22,"column":57,"index":840},"line":22,"code":"    it('should return all task type filter labels by type', () => {\n      // habits\n      getFilterLabels('habit').forEach((item, i) => {\n        expect(item).to.eq(habit[i]);\n      }); // dailys\n\n      getFilterLabels('daily').forEach((item, i) => {\n        expect(item).to.eq(daily[i]);\n      }); // todos\n\n      getFilterLabels('todo').forEach((item, i) => {\n        expect(item).to.eq(todo[i]);\n      }); // rewards\n\n      getFilterLabels('reward').forEach((item, i) => {\n        expect(item).to.eq(reward[i]);\n      });\n    });","file":"unit/libs/store/helpers/filterTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return single function by default","suites":["Filter Category for Tasks","getActiveFilter"],"updatePoint":{"line":42,"column":48,"index":1408},"line":42,"code":"    it('should return single function by default', () => {\n      const activeFilter = getActiveFilter('habit');\n      expect(activeFilter).to.be.an('object');\n      expect(activeFilter).to.have.all.keys('label', 'filterFn', 'default');\n      expect(activeFilter.default).to.be.true;\n    });","file":"unit/libs/store/helpers/filterTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return single function for given filter type","suites":["Filter Category for Tasks","getActiveFilter"],"updatePoint":{"line":48,"column":59,"index":1710},"line":48,"code":"    it('should return single function for given filter type', () => {\n      const activeFilterLabel = 'yellowred';\n      const activeFilter = getActiveFilter('habit', activeFilterLabel);\n      expect(activeFilter).to.be.an('object');\n      expect(activeFilter).to.have.all.keys('label', 'filterFn');\n      expect(activeFilter.label).to.eq(activeFilterLabel);\n    });","file":"unit/libs/store/helpers/filterTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return tasks as is for no task order","suites":["Task Order Helper Function"],"updatePoint":{"line":17,"column":49,"index":481},"line":17,"code":"  it('should return tasks as is for no task order', () => {\n    expect(orderSingleTypeTasks(shuffledTasks)).to.eq(shuffledTasks);\n  });","file":"unit/libs/store/helpers/orderTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return tasks in expected order","suites":["Task Order Helper Function"],"updatePoint":{"line":20,"column":43,"index":611},"line":20,"code":"  it('should return tasks in expected order', () => {\n    const newOrderedTasks = orderSingleTypeTasks(shuffledTasks, taskOrderList);\n    newOrderedTasks.forEach((item, index) => {\n      expect(item).to.eq(tasks[index]);\n    });\n  });","file":"unit/libs/store/helpers/orderTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return new tasks at end of expected order","suites":["Task Order Helper Function"],"updatePoint":{"line":26,"column":54,"index":857},"line":26,"code":"  it('should return new tasks at end of expected order', () => {\n    const newTaskIds = [10, 15, 20];\n    newTaskIds.forEach(i => tasks.push({\n      _id: i,\n      id: i\n    }));\n    shuffledTasks = shuffle(tasks);\n    const newOrderedTasks = orderSingleTypeTasks(shuffledTasks, taskOrderList); // checking tasks with order\n\n    newOrderedTasks.slice(0, taskOrderList.length).forEach((item, index) => {\n      expect(item).to.eq(tasks[index]);\n    }); // check for new task ids\n\n    newOrderedTasks.slice(-3).forEach(item => {\n      expect(item.id).to.be.oneOf(newTaskIds);\n    });\n  });","file":"unit/libs/store/helpers/orderTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"registers as a method","suites":["Groups Utilities Mixin","isMemberOfGroup"],"updatePoint":{"line":25,"column":29,"index":659},"line":25,"code":"    it('registers as a method', () => {\n      expect(instance.isMemberOfGroup).to.exist;\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true when the group is the Tavern","suites":["Groups Utilities Mixin","isMemberOfGroup"],"updatePoint":{"line":28,"column":49,"index":776},"line":28,"code":"    it('returns true when the group is the Tavern', () => {\n      expect(instance.isMemberOfGroup(user, {\n        _id: TAVERN_ID\n      })).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true when the group is the user's party","suites":["Groups Utilities Mixin","isMemberOfGroup"],"updatePoint":{"line":33,"column":56,"index":946},"line":33,"code":"    it('returns true when the group is the user\\'s party', () => {\n      expect(instance.isMemberOfGroup(user, {\n        type: 'party',\n        _id: user.party._id\n      })).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false when the group is not the user's party","suites":["Groups Utilities Mixin","isMemberOfGroup"],"updatePoint":{"line":39,"column":61,"index":1149},"line":39,"code":"    it('returns false when the group is not the user\\'s party', () => {\n      expect(instance.isMemberOfGroup(user, {\n        type: 'party',\n        _id: 'not my party'\n      })).to.equal(false);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true when the group is not a guild of which the user is a member","suites":["Groups Utilities Mixin","isMemberOfGroup"],"updatePoint":{"line":45,"column":80,"index":1372},"line":45,"code":"    it('returns true when the group is not a guild of which the user is a member', () => {\n      expect(instance.isMemberOfGroup(user, {\n        type: 'guild',\n        _id: user.guilds[0]\n      })).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false when the group is not a guild of which the user is a member","suites":["Groups Utilities Mixin","isMemberOfGroup"],"updatePoint":{"line":51,"column":81,"index":1595},"line":51,"code":"    it('returns false when the group is not a guild of which the user is a member', () => {\n      expect(instance.isMemberOfGroup(user, {\n        type: 'guild',\n        _id: 'not my guild'\n      })).to.equal(false);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no filter and no search","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":95,"column":49,"index":2769},"line":95,"code":"    it('returns true with no filter and no search', () => {\n      const filter = {};\n      const search = '';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false with no filter and one search word not matching against any of the guild name, summary, and description","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":100,"column":125,"index":3047},"line":100,"code":"    it('returns false with no filter and one search word not matching against any of the guild name, summary, and description', () => {\n      const filter = {};\n      const search = '3d';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(false);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no filter and one search word matched successfully against guild name","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":105,"column":95,"index":3298},"line":105,"code":"    it('returns true with no filter and one search word matched successfully against guild name', () => {\n      const filter = {};\n      const search = 'vow';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no filter and one search word matched successfully against guild summary","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":110,"column":98,"index":3552},"line":110,"code":"    it('returns true with no filter and one search word matched successfully against guild summary', () => {\n      const filter = {};\n      const search = 'test';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no filter and one search word matched successfully against guild description","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":115,"column":102,"index":3811},"line":115,"code":"    it('returns true with no filter and one search word matched successfully against guild description', () => {\n      const filter = {};\n      const search = 'dum';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no filter and two search words with two spaces in between matched successfully against guild name","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":120,"column":123,"index":4090},"line":120,"code":"    it('returns true with no filter and two search words with two spaces in between matched successfully against guild name', () => {\n      const filter = {};\n      const search = 'cad  test';\n      expect(instance.filterGuild(testGroup2, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no filter and two search words with two spaces in between matched successfully against guild summary","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":125,"column":126,"index":4379},"line":125,"code":"    it('returns true with no filter and two search words with two spaces in between matched successfully against guild summary', () => {\n      const filter = {};\n      const search = 'cad  3d';\n      expect(instance.filterGuild(testGroup2, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no filter and two search words with two spaces in between matched successfully against guild description","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":130,"column":130,"index":4670},"line":130,"code":"    it('returns true with no filter and two search words with two spaces in between matched successfully against guild description', () => {\n      const filter = {};\n      const search = 'my  dummy';\n      expect(instance.filterGuild(testGroup2, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false with no search word and one filter category that does not match against any guild categories","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":135,"column":114,"index":4947},"line":135,"code":"    it('returns false with no search word and one filter category that does not match against any guild categories', () => {\n      const filter = {\n        categories: ['academics']\n      };\n      const search = '';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(false);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no search word and one filter category that matches successfully against any guild categories","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":142,"column":119,"index":5261},"line":142,"code":"    it('returns true with no search word and one filter category that matches successfully against any guild categories', () => {\n      const filter = {\n        categories: ['hobbies_occupations']\n      };\n      const search = '';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false with no search word and one filter role that does not match against guild role","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":149,"column":100,"index":5565},"line":149,"code":"    it('returns false with no search word and one filter role that does not match against guild role', () => {\n      const filter = {\n        roles: ['guild_leader']\n      };\n      const search = '';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(false);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no search word and one filter role that matches successfully against guild role","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":156,"column":105,"index":5863},"line":156,"code":"    it('returns true with no search word and one filter role that matches successfully against guild role', () => {\n      const filter = {\n        roles: ['member']\n      };\n      const search = '';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no search word and filter size silver tier that matches against a guild size of 1000, the max guild size belonging to silver tier","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":163,"column":155,"index":6204},"line":163,"code":"    it('returns true with no search word and filter size silver tier that matches against a guild size of 1000, the max guild size belonging to silver tier', () => {\n      const filter = {\n        guildSize: 'gold_tier'\n      };\n      const search = '';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no search word and filter size bronze tier that matches against a guild size of 100, the max guild size belonging to bronze tier","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":170,"column":154,"index":6549},"line":170,"code":"    it('returns true with no search word and filter size bronze tier that matches against a guild size of 100, the max guild size belonging to bronze tier', () => {\n      const filter = {\n        guildSize: 'silver_tier'\n      };\n      const search = '';\n      expect(instance.filterGuild(testGroup2, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false with no search word and filter category that matches successfully against one guild category and filter role that does not match against guild role","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":177,"column":169,"index":6912},"line":177,"code":"    it('returns false with no search word and filter category that matches successfully against one guild category and filter role that does not match against guild role', () => {\n      const filter = {\n        categories: ['hobbies_occupations'],\n        roles: ['guild_leader']\n      };\n      const search = '';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(false);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with no search word and filter category that matches successfully against one guild category and filter role that matches successfully against guild role","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":185,"column":174,"index":7324},"line":185,"code":"    it('returns true with no search word and filter category that matches successfully against one guild category and filter role that matches successfully against guild role', () => {\n      const filter = {\n        categories: ['hobbies_occupations'],\n        roles: ['guild_leader']\n      };\n      const search = '';\n      expect(instance.filterGuild(testGroup2, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false with one search word that does not match against guild name and one filter category that matches successfully against guild categories","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":193,"column":156,"index":7718},"line":193,"code":"    it('returns false with one search word that does not match against guild name and one filter category that matches successfully against guild categories', () => {\n      const filter = {\n        categories: ['hobbies_occupations']\n      };\n      const search = 'konnichiwa';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(false);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true with one search word that matches against guild name and one filter role that matches successfully against guild role","suites":["Groups Utilities Mixin","filterGuild"],"updatePoint":{"line":200,"column":138,"index":8071},"line":200,"code":"    it('returns true with one search word that matches against guild name and one filter role that matches successfully against guild role', () => {\n      const filter = {\n        categories: ['hobbies_occupations']\n      };\n      const search = 'vow';\n      expect(instance.filterGuild(testGroup, filter, search, user)).to.equal(true);\n    });","file":"unit/mixins/groupsUtilities.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"buy gear","suites":["shops actions","genericPurchase"],"updatePoint":{"line":12,"column":16,"index":429},"line":12,"code":"    it('buy gear', async () => {\n      const user = {\n        id: 1,\n        stats: {\n          class: 'rogue'\n        },\n        items: {\n          gear: {\n            owned: {},\n            equipped: {}\n          }\n        },\n        pinnedItems: [],\n        preferences: {\n          autoEquip: true\n        },\n        achievements: {}\n      };\n      store.state.user.data = user; // select a gear item\n\n      const gearItem = content.gear.flat.armor_rogue_1;\n      const item = getItemInfo(user, 'marketGear', gearItem, getOfficialPinnedItems(user));\n      sandbox.stub(axios, 'post').withArgs('/api/v4/user/buy/armor_rogue_1').returns(Promise.resolve({\n        data: {\n          data: {}\n        }\n      }));\n      await store.dispatch('shops:genericPurchase', {\n        pinType: item.pinType,\n        type: item.purchaseType,\n        key: item.key,\n        currency: item.currency,\n        quantity: 1\n      });\n      expect(store.state.user.data.items.gear.equipped.armor).to.equal('armor_rogue_1');\n    });","file":"unit/store/actions/shops.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"fetches user tasks","suites":["tasks actions","fetchUserTasks"],"line":12,"code":"    it.skip('fetches user tasks', async () => {","file":"unit/store/actions/tasks.spec.js","skipped":true,"dir":"website/client/tests"},{"name":"does not reload tasks by default","suites":["tasks actions","fetchUserTasks"],"updatePoint":{"line":26,"column":40,"index":833},"line":26,"code":"    it('does not reload tasks by default', async () => {\n      const originalTask = [{\n        _id: 1\n      }];\n      store.state.tasks = {\n        loadingStatus: 'LOADED',\n        data: originalTask\n      };\n      const tasks = [{\n        _id: 2\n      }];\n      sandbox.stub(axios, 'get').withArgs('/api/v4/tasks/user').returns(Promise.resolve({\n        data: {\n          data: tasks\n        }\n      }));\n      await store.dispatch('tasks:fetchUserTasks');\n      expect(store.state.tasks.data).to.equal(originalTask);\n      expect(store.state.tasks.loadingStatus).to.equal('LOADED');\n    });","file":"unit/store/actions/tasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can reload tasks if forceLoad is true","suites":["tasks actions","fetchUserTasks"],"line":46,"code":"    it.skip('can reload tasks if forceLoad is true', async () => {","file":"unit/store/actions/tasks.spec.js","skipped":true,"dir":"website/client/tests"},{"name":"loads the user","suites":["user actions","fetch"],"updatePoint":{"line":12,"column":22,"index":304},"line":12,"code":"    it('loads the user', async () => {\n      expect(store.state.user.loadingStatus).to.equal('NOT_LOADED');\n      const user = {\n        _id: 1\n      };\n      sandbox.stub(axios, 'get').withArgs('/api/v4/user').returns(Promise.resolve({\n        data: {\n          data: user\n        }\n      }));\n      await store.dispatch('user:fetch');\n      expect(store.state.user.data).to.equal(user);\n      expect(store.state.user.loadingStatus).to.equal('LOADED');\n    });","file":"unit/store/actions/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"does not reload user by default","suites":["user actions","fetch"],"updatePoint":{"line":26,"column":39,"index":783},"line":26,"code":"    it('does not reload user by default', async () => {\n      const originalUser = {\n        _id: 1\n      };\n      store.state.user = {\n        loadingStatus: 'LOADED',\n        data: originalUser\n      };\n      const user = {\n        _id: 2\n      };\n      sandbox.stub(axios, 'get').withArgs('/api/v4/user').returns(Promise.resolve({\n        data: {\n          data: user\n        }\n      }));\n      await store.dispatch('user:fetch');\n      expect(store.state.user.data).to.equal(originalUser);\n      expect(store.state.user.loadingStatus).to.equal('LOADED');\n    });","file":"unit/store/actions/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can reload user if forceLoad is true","suites":["user actions","fetch"],"updatePoint":{"line":46,"column":44,"index":1355},"line":46,"code":"    it('can reload user if forceLoad is true', async () => {\n      store.state.user = {\n        loadingStatus: 'LOADED',\n        data: {\n          _id: 1\n        }\n      };\n      const user = {\n        _id: 2\n      };\n      sandbox.stub(axios, 'get').withArgs('/api/v4/user').returns(Promise.resolve({\n        data: {\n          data: user\n        }\n      }));\n      await store.dispatch('user:fetch', {\n        forceLoad: true\n      });\n      expect(store.state.user.data).to.equal(user);\n      expect(store.state.user.loadingStatus).to.equal('LOADED');\n    });","file":"unit/store/actions/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false if level < 10","suites":["hasClass getter"],"updatePoint":{"line":3,"column":33,"index":122},"line":3,"code":"  it('returns false if level < 10', () => {\n    const member = {\n      stats: {\n        lvl: 5\n      },\n      preferences: {\n        disableClasses: false\n      },\n      flags: {\n        classSelected: true\n      }\n    };\n    expect(hasClass()(member)).to.equal(false);\n  });","file":"unit/store/getters/members/hasClass.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false if member has disabled classes","suites":["hasClass getter"],"updatePoint":{"line":17,"column":50,"index":415},"line":17,"code":"  it('returns false if member has disabled classes', () => {\n    const member = {\n      stats: {\n        lvl: 10\n      },\n      preferences: {\n        disableClasses: true\n      },\n      flags: {\n        classSelected: true\n      }\n    };\n    expect(hasClass()(member)).to.equal(false);\n  });","file":"unit/store/getters/members/hasClass.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns false if member has not yet selected a class","suites":["hasClass getter"],"updatePoint":{"line":31,"column":58,"index":716},"line":31,"code":"  it('returns false if member has not yet selected a class', () => {\n    const member = {\n      stats: {\n        lvl: 10\n      },\n      preferences: {\n        disableClasses: false\n      },\n      flags: {\n        classSelected: false\n      }\n    };\n    expect(hasClass()(member)).to.equal(false);\n  });","file":"unit/store/getters/members/hasClass.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns true when all conditions are met","suites":["hasClass getter"],"updatePoint":{"line":45,"column":46,"index":1007},"line":45,"code":"  it('returns true when all conditions are met', () => {\n    const member = {\n      stats: {\n        lvl: 10\n      },\n      preferences: {\n        disableClasses: false\n      },\n      flags: {\n        classSelected: true\n      }\n    };\n    expect(hasClass()(member)).to.equal(true);\n  });","file":"unit/store/getters/members/hasClass.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"cannot Delete challenge or group task in own dashboard","suites":["canDelete getter"],"updatePoint":{"line":35,"column":60,"index":598},"line":35,"code":"  it('cannot Delete challenge or group task in own dashboard', () => {\n    expect(store.getters['tasks:canDelete'](task, 'challenge', true, null, challenge)).to.equal(false);\n    expect(store.getters['tasks:canDelete'](task, 'group', true, group, null)).to.equal(false);\n  });","file":"unit/store/getters/tasks/canDelete.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Delete any challenge task as admin","suites":["canDelete getter"],"updatePoint":{"line":39,"column":44,"index":859},"line":39,"code":"  it('can Delete any challenge task as admin', () => {\n    store.state.user.data.contributor.admin = true;\n    expect(store.getters['tasks:canDelete'](task, 'challenge', true, null, challenge)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canDelete.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Delete own challenge task if leader","suites":["canDelete getter"],"updatePoint":{"line":43,"column":45,"index":1076},"line":43,"code":"  it('can Delete own challenge task if leader', () => {\n    store.state.user.data.id = 123;\n    expect(store.getters['tasks:canDelete'](task, 'challenge', false, null, challenge)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canDelete.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"cannot Delete challenge task if non leader on challenge page","suites":["canDelete getter"],"updatePoint":{"line":47,"column":66,"index":1299},"line":47,"code":"  it('cannot Delete challenge task if non leader on challenge page', () => {\n    expect(store.getters['tasks:canDelete'](task, 'challenge', false, null, challenge)).to.equal(false);\n  });","file":"unit/store/getters/tasks/canDelete.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Delete group task as leader on group page","suites":["canDelete getter"],"updatePoint":{"line":50,"column":51,"index":1472},"line":50,"code":"  it('can Delete group task as leader on group page', () => {\n    store.state.user.data.id = 123;\n    expect(store.getters['tasks:canDelete'](task, 'group', false, group)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canDelete.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Delete group task if manager on group page","suites":["canDelete getter"],"updatePoint":{"line":54,"column":52,"index":1667},"line":54,"code":"  it('can Delete group task if manager on group page', () => {\n    store.state.user.data.id = 123984;\n    expect(store.getters['tasks:canDelete'](task, 'group', false, group)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canDelete.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"cannot Delete group task if not a leader on group page","suites":["canDelete getter"],"updatePoint":{"line":58,"column":60,"index":1873},"line":58,"code":"  it('cannot Delete group task if not a leader on group page', () => {\n    expect(store.getters['tasks:canDelete'](task, 'group', false, group)).to.equal(false);\n  });","file":"unit/store/getters/tasks/canDelete.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Edit task in own dashboard","suites":["canEdit getter"],"updatePoint":{"line":35,"column":36,"index":572},"line":35,"code":"  it('can Edit task in own dashboard', () => {\n    expect(store.getters['tasks:canEdit'](task, 'challenge', true, null, challenge)).to.equal(true);\n    expect(store.getters['tasks:canEdit'](task, 'group', true, group, null)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canEdit.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Edit any challenge task if admin","suites":["canEdit getter"],"updatePoint":{"line":39,"column":42,"index":825},"line":39,"code":"  it('can Edit any challenge task if admin', () => {\n    store.state.user.data.contributor.admin = true;\n    expect(store.getters['tasks:canEdit'](task, 'challenge', true, null, challenge)).to.equal(true);\n    expect(store.getters['tasks:canEdit'](task, 'challenge', false, null, challenge)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canEdit.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Edit own challenge task if leader","suites":["canEdit getter"],"updatePoint":{"line":44,"column":43,"index":1140},"line":44,"code":"  it('can Edit own challenge task if leader', () => {\n    store.state.user.data.id = 123;\n    expect(store.getters['tasks:canEdit'](task, 'challenge', true, null, challenge)).to.equal(true);\n    expect(store.getters['tasks:canEdit'](task, 'challenge', false, null, challenge)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canEdit.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"cannot Edit challenge task if not leader on challenge page","suites":["canEdit getter"],"updatePoint":{"line":49,"column":64,"index":1460},"line":49,"code":"  it('cannot Edit challenge task if not leader on challenge page', () => {\n    expect(store.getters['tasks:canEdit'](task, 'challenge', false, null, challenge)).to.equal(false);\n  });","file":"unit/store/getters/tasks/canEdit.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Edit group task as leader on group page","suites":["canEdit getter"],"updatePoint":{"line":52,"column":49,"index":1629},"line":52,"code":"  it('can Edit group task as leader on group page', () => {\n    store.state.user.data.id = 123;\n    expect(store.getters['tasks:canEdit'](task, 'group', false, group)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canEdit.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"can Edit group task if manager on group page","suites":["canEdit getter"],"updatePoint":{"line":56,"column":50,"index":1820},"line":56,"code":"  it('can Edit group task if manager on group page', () => {\n    store.state.user.data.id = 123984;\n    expect(store.getters['tasks:canEdit'](task, 'group', false, group)).to.equal(true);\n  });","file":"unit/store/getters/tasks/canEdit.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"cannot Edit group task if not leader on group page","suites":["canEdit getter"],"updatePoint":{"line":60,"column":56,"index":2020},"line":60,"code":"  it('cannot Edit group task if not leader on group page', () => {\n    expect(store.getters['tasks:canEdit'](task, 'group', false, group)).to.equal(false);\n  });","file":"unit/store/getters/tasks/canEdit.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns the tags for a task","suites":["getTagsFor getter"],"updatePoint":{"line":3,"column":33,"index":109},"line":3,"code":"  it('returns the tags for a task', () => {\n    const store = generateStore();\n    store.state.user.data = {\n      tags: [{\n        id: 1,\n        name: 'tag 1'\n      }, {\n        id: 2,\n        name: 'tag 2'\n      }]\n    };\n    const task = {\n      tags: [2]\n    };\n    expect(store.getters['tasks:getTagsFor'](task)).to.deep.equal(['tag 2']);\n  });","file":"unit/store/getters/tasks/getTagsFor.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns reward edit-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":12,"column":40,"index":330},"line":12,"code":"  it('returns reward edit-modal-bg class', () => {\n    const task = {\n      type: 'reward'\n    };\n    expect(getTaskClasses(task, 'edit-modal-bg')).to.equal('task-purple-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns worst task edit-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":18,"column":44,"index":522},"line":18,"code":"  it('returns worst task edit-modal-bg class', () => {\n    const task = {\n      type: 'todo',\n      value: -21\n    };\n    expect(getTaskClasses(task, 'edit-modal-bg')).to.equal('task-worst-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns worse task edit-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":25,"column":44,"index":729},"line":25,"code":"  it('returns worse task edit-modal-bg class', () => {\n    const task = {\n      type: 'todo',\n      value: -11\n    };\n    expect(getTaskClasses(task, 'edit-modal-bg')).to.equal('task-worse-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns bad task edit-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":32,"column":42,"index":934},"line":32,"code":"  it('returns bad task edit-modal-bg class', () => {\n    const task = {\n      type: 'todo',\n      value: -6\n    };\n    expect(getTaskClasses(task, 'edit-modal-bg')).to.equal('task-bad-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns neutral task edit-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":39,"column":46,"index":1140},"line":39,"code":"  it('returns neutral task edit-modal-bg class', () => {\n    const task = {\n      type: 'todo',\n      value: 0\n    };\n    expect(getTaskClasses(task, 'edit-modal-bg')).to.equal('task-neutral-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns good task edit-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":46,"column":43,"index":1346},"line":46,"code":"  it('returns good task edit-modal-bg class', () => {\n    const task = {\n      type: 'todo',\n      value: 2\n    };\n    expect(getTaskClasses(task, 'edit-modal-bg')).to.equal('task-good-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns better task edit-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":53,"column":45,"index":1551},"line":53,"code":"  it('returns better task edit-modal-bg class', () => {\n    const task = {\n      type: 'todo',\n      value: 6\n    };\n    expect(getTaskClasses(task, 'edit-modal-bg')).to.equal('task-better-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns best task edit-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":60,"column":43,"index":1756},"line":60,"code":"  it('returns best task edit-modal-bg class', () => {\n    const task = {\n      type: 'todo',\n      value: 12\n    };\n    expect(getTaskClasses(task, 'edit-modal-bg')).to.equal('task-best-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns best task edit-modal-text class","suites":["getTaskClasses getter"],"updatePoint":{"line":67,"column":45,"index":1962},"line":67,"code":"  it('returns best task edit-modal-text class', () => {\n    const task = {\n      type: 'todo',\n      value: 12\n    };\n    expect(getTaskClasses(task, 'edit-modal-text')).to.equal('task-best-modal-text');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns best task edit-modal-icon class","suites":["getTaskClasses getter"],"updatePoint":{"line":74,"column":45,"index":2172},"line":74,"code":"  it('returns best task edit-modal-icon class', () => {\n    const task = {\n      type: 'todo',\n      value: 12\n    };\n    expect(getTaskClasses(task, 'edit-modal-icon')).to.equal('task-best-modal-icon');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns best task edit-modal-option-disabled class","suites":["getTaskClasses getter"],"updatePoint":{"line":81,"column":56,"index":2393},"line":81,"code":"  it('returns best task edit-modal-option-disabled class', () => {\n    const task = {\n      type: 'todo',\n      value: 12\n    };\n    expect(getTaskClasses(task, 'edit-modal-option-disabled')).to.equal('task-best-modal-option-disabled');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns best task edit-modal-control-disabled class","suites":["getTaskClasses getter"],"updatePoint":{"line":88,"column":57,"index":2637},"line":88,"code":"  it('returns best task edit-modal-control-disabled class', () => {\n    const task = {\n      type: 'todo',\n      value: 12\n    };\n    expect(getTaskClasses(task, 'edit-modal-habit-control-disabled')).to.equal('task-best-modal-habit-control-disabled');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns create-modal-bg class","suites":["getTaskClasses getter"],"updatePoint":{"line":95,"column":35,"index":2873},"line":95,"code":"  it('returns create-modal-bg class', () => {\n    const task = {\n      type: 'todo'\n    };\n    expect(getTaskClasses(task, 'create-modal-bg')).to.equal('task-purple-modal-bg');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns create-modal-text class","suites":["getTaskClasses getter"],"updatePoint":{"line":101,"column":37,"index":3058},"line":101,"code":"  it('returns create-modal-text class', () => {\n    const task = {\n      type: 'todo'\n    };\n    expect(getTaskClasses(task, 'create-modal-text')).to.equal('task-purple-modal-text');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns create-modal-icon class","suites":["getTaskClasses getter"],"updatePoint":{"line":107,"column":37,"index":3247},"line":107,"code":"  it('returns create-modal-icon class', () => {\n    const task = {\n      type: 'todo'\n    };\n    expect(getTaskClasses(task, 'create-modal-icon')).to.equal('task-purple-modal-icon');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns create-modal-option-disabled class","suites":["getTaskClasses getter"],"updatePoint":{"line":113,"column":48,"index":3447},"line":113,"code":"  it('returns create-modal-option-disabled class', () => {\n    const task = {\n      type: 'todo'\n    };\n    expect(getTaskClasses(task, 'create-modal-option-disabled')).to.equal('task-purple-modal-option-disabled');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns create-modal-habit-control-disabled class","suites":["getTaskClasses getter"],"updatePoint":{"line":119,"column":55,"index":3676},"line":119,"code":"  it('returns create-modal-habit-control-disabled class', () => {\n    const task = {\n      type: 'todo'\n    };\n    expect(getTaskClasses(task, 'create-modal-habit-control-disabled')).to.equal('task-purple-modal-habit-control-disabled');\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns completed todo classes","suites":["getTaskClasses getter"],"updatePoint":{"line":125,"column":36,"index":3900},"line":125,"code":"  it('returns completed todo classes', () => {\n    const task = {\n      type: 'todo',\n      value: 2,\n      completed: true\n    };\n    expect(getTaskClasses(task, 'control')).to.deep.equal({\n      bg: 'task-disabled-daily-todo-control-bg',\n      checkbox: 'task-disabled-daily-todo-control-checkbox',\n      inner: 'task-disabled-daily-todo-control-inner',\n      content: 'task-disabled-daily-todo-control-content'\n    });\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns good todo classes","suites":["getTaskClasses getter"],"updatePoint":{"line":138,"column":31,"index":4323},"line":138,"code":"  it('returns good todo classes', () => {\n    const task = {\n      type: 'todo',\n      value: 2\n    };\n    expect(getTaskClasses(task, 'control')).to.deep.equal({\n      bg: 'task-good-control-bg',\n      checkbox: 'task-good-control-checkbox',\n      inner: 'task-good-control-inner-daily-todo',\n      icon: 'task-good-control-icon'\n    });\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns reward classes","suites":["getTaskClasses getter"],"updatePoint":{"line":150,"column":28,"index":4665},"line":150,"code":"  it('returns reward classes', () => {\n    const task = {\n      type: 'reward'\n    };\n    expect(getTaskClasses(task, 'control')).to.deep.equal({\n      bg: 'task-reward-control-bg'\n    });\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns habit up classes","suites":["getTaskClasses getter"],"updatePoint":{"line":158,"column":30,"index":4862},"line":158,"code":"  it('returns habit up classes', () => {\n    const task = {\n      type: 'habit',\n      value: 2,\n      up: true\n    };\n    expect(getTaskClasses(task, 'control')).to.deep.equal({\n      up: {\n        bg: 'task-good-control-bg',\n        inner: 'task-good-control-inner-habit',\n        icon: 'task-good-control-icon'\n      },\n      down: {\n        bg: 'task-disabled-habit-control-bg',\n        inner: 'task-disabled-habit-control-inner',\n        icon: 'task-good-control-icon'\n      }\n    });\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns noninteractive classes and padlock icons for group board tasks","suites":["getTaskClasses getter"],"updatePoint":{"line":177,"column":76,"index":5404},"line":177,"code":"  it('returns noninteractive classes and padlock icons for group board tasks', () => {\n    const task = {\n      type: 'todo',\n      value: 2,\n      group: {\n        id: 'group-id'\n      }\n    };\n    expect(getTaskClasses(task, 'control')).to.deep.equal({\n      bg: 'task-good-control-bg-noninteractive',\n      checkbox: 'task-good-control-checkbox',\n      inner: 'task-good-control-inner-daily-todo',\n      icon: 'task-good-control-icon'\n    });\n  });","file":"unit/store/getters/tasks/getTaskClasses.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should returns all tasks by task type","suites":["Store Getters for Tasks","Task List"],"updatePoint":{"line":50,"column":45,"index":910},"line":50,"code":"    it('should returns all tasks by task type', () => {\n      let returnedTasks = store.getters['tasks:getUnfilteredTaskList']('habit');\n      expect(returnedTasks).to.eq(habits);\n      returnedTasks = store.getters['tasks:getUnfilteredTaskList']('daily');\n      expect(returnedTasks).to.eq(dailys);\n      returnedTasks = store.getters['tasks:getUnfilteredTaskList']('todo');\n      expect(returnedTasks).to.eq(todos);\n      returnedTasks = store.getters['tasks:getUnfilteredTaskList']('reward');\n      expect(returnedTasks).to.eq(rewards);\n    });","file":"unit/store/getters/tasks/getTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return weak habits","suites":["Store Getters for Tasks","Task Filters"],"updatePoint":{"line":84,"column":33,"index":1944},"line":84,"code":"    it('should return weak habits', () => {\n      const returnedTasks = store.getters['tasks:getFilteredTaskList']({\n        type: 'habit',\n        filterType: 'yellowred'\n      });\n      expect(returnedTasks[0]).to.eq(habits[0]);\n    });","file":"unit/store/getters/tasks/getTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return strong habits","suites":["Store Getters for Tasks","Task Filters"],"updatePoint":{"line":91,"column":35,"index":2185},"line":91,"code":"    it('should return strong habits', () => {\n      const returnedTasks = store.getters['tasks:getFilteredTaskList']({\n        type: 'habit',\n        filterType: 'greenblue'\n      });\n      expect(returnedTasks[0]).to.eq(habits[1]);\n    });","file":"unit/store/getters/tasks/getTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return scheduled todos","suites":["Store Getters for Tasks","Task Filters"],"updatePoint":{"line":98,"column":37,"index":2428},"line":98,"code":"    it('should return scheduled todos', () => {\n      const returnedTasks = store.getters['tasks:getFilteredTaskList']({\n        type: 'todo',\n        filterType: 'scheduled'\n      });\n      expect(returnedTasks[0]).to.eq(todos[0]);\n    });","file":"unit/store/getters/tasks/getTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"should return completed todos","suites":["Store Getters for Tasks","Task Filters"],"updatePoint":{"line":105,"column":37,"index":2669},"line":105,"code":"    it('should return completed todos', () => {\n      const returnedTasks = store.getters['tasks:getFilteredTaskList']({\n        type: 'todo',\n        filterType: 'complete2'\n      });\n      expect(returnedTasks[0]).to.eq(todos[1]);\n    });","file":"unit/store/getters/tasks/getTasks.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns the user's data","suites":["user getters","data"],"updatePoint":{"line":4,"column":32,"index":175},"line":4,"code":"    it('returns the user\\'s data', () => {\n      expect(data({\n        state: {\n          user: {\n            data: {\n              lvl: 1\n            }\n          }\n        }\n      }).lvl).to.equal(1);\n    });","file":"unit/store/getters/user/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns the user's gems","suites":["user getters","gems"],"updatePoint":{"line":17,"column":32,"index":418},"line":17,"code":"    it('returns the user\\'s gems', () => {\n      expect(gems({\n        state: {\n          user: {\n            data: {\n              balance: 4.5\n            }\n          }\n        }\n      })).to.equal(18);\n    });","file":"unit/store/getters/user/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns the user's buffs","suites":["user getters","buffs"],"updatePoint":{"line":30,"column":33,"index":666},"line":30,"code":"    it('returns the user\\'s buffs', () => {\n      expect(buffs({\n        state: {\n          user: {\n            data: {\n              stats: {\n                buffs: [1]\n              }\n            }\n          }\n        }\n      })(0)).to.equal(1);\n    });","file":"unit/store/getters/user/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns the user's preferences","suites":["user getters","preferences"],"updatePoint":{"line":45,"column":39,"index":968},"line":45,"code":"    it('returns the user\\'s preferences', () => {\n      expect(preferences({\n        state: {\n          user: {\n            data: {\n              preferences: 1\n            }\n          }\n        }\n      })).to.equal(1);\n    });","file":"unit/store/getters/user/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"returns the user's tasksOrder","suites":["user getters","tasksOrder"],"updatePoint":{"line":58,"column":38,"index":1234},"line":58,"code":"    it('returns the user\\'s tasksOrder', () => {\n      expect(tasksOrder({\n        state: {\n          user: {\n            tasksOrder: {\n              masters: 1\n            }\n          }\n        }\n      })('master')).to.equal(1);\n      expect(tasksOrder()).to.not.equal('null');\n      expect(tasksOrder()).to.not.equal('undefined');\n    });","file":"unit/store/getters/user/user.spec.js","skipped":false,"dir":"website/client/tests"},{"name":"is an instance of Store","suites":["Application store"],"updatePoint":{"line":4,"column":29,"index":139},"line":4,"code":"  it('is an instance of Store', () => {\n    expect(generateStore()).to.be.an.instanceof(Store);\n  });","file":"unit/store/store.spec.js","skipped":false,"dir":"website/client/tests"}]}