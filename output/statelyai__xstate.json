{"repo":"statelyai/xstate","url":"https://github.com/statelyai/xstate","branch":"main","configs":[{"package":"xstate","lang":"ts","dir":"packages/core/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/analytics","lang":"ts","dir":"packages/xstate-analytics/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/fsm","lang":"ts","dir":"packages/xstate-fsm/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/graph","lang":"ts","dir":"packages/xstate-graph/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/immer","lang":"ts","dir":"packages/xstate-immer/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/inspect","lang":"ts","dir":"packages/xstate-inspect/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/react","lang":"js","dir":"packages/xstate-react/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@xstate/scxml","lang":"ts","dir":"packages/xstate-scxml/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/svelte","lang":"ts","dir":"packages/xstate-svelte/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/test","lang":"ts","dir":"packages/xstate-test/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@xstate/vue","lang":"ts","dir":"packages/xstate-vue/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should accept a string action","suites":["action creators","()"],"updatePoint":{"line":9,"column":39},"line":9,"code":"      it('should accept a string action', () => {\n        const action = actions[actionKey]('test');\n        expect(action.type).toEqual(actionTypes[actionKey]);\n        expect(action).toEqual({\n          type: actionTypes[actionKey],\n          exec: undefined,\n          activity: {\n            type: 'test',\n            exec: undefined,\n            id: 'test'\n          }\n        });\n      });","file":"actionCreators.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept an action object","suites":["action creators","()"],"updatePoint":{"line":23,"column":40},"line":23,"code":"      it('should accept an action object', () => {\n        const action = actions[actionKey]({ type: 'test', foo: 'bar' } as any);\n        expect(action.type).toEqual(actionTypes[actionKey]);\n        expect(action).toEqual({\n          type: actionTypes[actionKey],\n          exec: undefined,\n          activity: {\n            type: 'test',\n            id: undefined,\n            foo: 'bar'\n          }\n        });\n      });","file":"actionCreators.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept an activity definition","suites":["action creators","()"],"updatePoint":{"line":37,"column":46},"line":37,"code":"      it('should accept an activity definition', () => {\n        const action = actions[actionKey]({\n          type: 'test',\n          foo: 'bar',\n          src: 'someSrc'\n        } as any);\n        expect(action.type).toEqual(actionTypes[actionKey]);\n        expect(action).toEqual({\n          type: actionTypes[actionKey],\n          exec: undefined,\n          activity: {\n            type: 'test',\n            id: undefined,\n            foo: 'bar',\n            src: 'someSrc'\n          }\n        });\n      });","file":"actionCreators.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept a string event","suites":["action creators","send()"],"updatePoint":{"line":59,"column":36},"line":59,"code":"    it('should accept a string event', () => {\n      const action = actions.send('foo');\n      expect(action).toEqual({\n        to: undefined,\n        type: actionTypes.send,\n        event: { type: 'foo' },\n        delay: undefined,\n        id: 'foo'\n      });\n    });","file":"actionCreators.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept an event object","suites":["action creators","send()"],"updatePoint":{"line":70,"column":37},"line":70,"code":"    it('should accept an event object', () => {\n      const action = actions.send({ type: 'foo', bar: 'baz' });\n      expect(action).toEqual({\n        to: undefined,\n        type: actionTypes.send,\n        event: { type: 'foo', bar: 'baz' },\n        delay: undefined,\n        id: 'foo'\n      });\n    });","file":"actionCreators.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept an id option","suites":["action creators","send()"],"updatePoint":{"line":81,"column":34},"line":81,"code":"    it('should accept an id option', () => {\n      const action = actions.send('foo', { id: 'foo-id' });\n      expect(action).toEqual({\n        to: undefined,\n        type: actionTypes.send,\n        event: { type: 'foo' },\n        delay: undefined,\n        id: 'foo-id'\n      });\n    });","file":"actionCreators.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept a delay option","suites":["action creators","send()"],"updatePoint":{"line":92,"column":36},"line":92,"code":"    it('should accept a delay option', () => {\n      const action = actions.send('foo', { delay: 1000 });\n      expect(action).toEqual({\n        to: undefined,\n        type: actionTypes.send,\n        event: { type: 'foo' },\n        delay: 1000,\n        id: 'foo'\n      });\n    });","file":"actionCreators.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept a delay option (expression)","suites":["action creators","send()"],"updatePoint":{"line":103,"column":49},"line":103,"code":"    it('should accept a delay option (expression)', () => {\n      const action = actions.send<\n        { delay: number },\n        { type: 'EVENT'; value: number } | { type: 'RECEIVED' }\n      >('RECEIVED', {\n        delay: (ctx, e) => ctx.delay + ('value' in e ? e.value : 0)\n      });\n\n      const resolvedAction = actions.resolveSend(\n        action,\n        { delay: 100 },\n        toSCXMLEvent({ type: 'EVENT', value: 50 } as {\n          type: 'EVENT';\n          value: number;\n        })\n      );\n\n      expect(resolvedAction.delay).toEqual(150);\n    });","file":"actionCreators.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry actions of an initial state","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":259,"column":59},"line":259,"code":"    it('should return the entry actions of an initial state', () => {\n      expect(lightMachine.initialState.actions.map((a) => a.type)).toEqual([\n        'enter_green'\n      ]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry actions of an initial state (deep)","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":265,"column":66},"line":265,"code":"    it('should return the entry actions of an initial state (deep)', () => {\n      expect(deepMachine.initialState.actions.map((a) => a.type)).toEqual([\n        'enter_a',\n        'enter_a1'\n      ]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry actions of an initial state (parallel)","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":272,"column":70},"line":272,"code":"    it('should return the entry actions of an initial state (parallel)', () => {\n      expect(parallelMachine.initialState.actions.map((a) => a.type)).toEqual([\n        'enter_a',\n        'enter_a1',\n        'enter_b',\n        'enter_b1'\n      ]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry and exit actions of a transition","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":281,"column":64},"line":281,"code":"    it('should return the entry and exit actions of a transition', () => {\n      expect(\n        lightMachine.transition('green', 'TIMER').actions.map((a) => a.type)\n      ).toEqual(['exit_green', 'enter_yellow']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry and exit actions of a deep transition","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":287,"column":69},"line":287,"code":"    it('should return the entry and exit actions of a deep transition', () => {\n      expect(\n        lightMachine.transition('yellow', 'TIMER').actions.map((a) => a.type)\n      ).toEqual(['exit_yellow', 'enter_red', 'enter_walk']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry and exit actions of a nested transition","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":293,"column":71},"line":293,"code":"    it('should return the entry and exit actions of a nested transition', () => {\n      expect(\n        lightMachine\n          .transition('red.walk', 'PED_COUNTDOWN')\n          .actions.map((a) => a.type)\n      ).toEqual(['exit_walk', 'enter_wait']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not have actions for unhandled events (shallow)","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":301,"column":62},"line":301,"code":"    it('should not have actions for unhandled events (shallow)', () => {\n      expect(\n        lightMachine.transition('green', 'FAKE').actions.map((a) => a.type)\n      ).toEqual([]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not have actions for unhandled events (deep)","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":307,"column":59},"line":307,"code":"    it('should not have actions for unhandled events (deep)', () => {\n      expect(\n        lightMachine.transition('red', 'FAKE').actions.map((a) => a.type)\n      ).toEqual([]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit and enter the state for self-transitions (shallow)","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":313,"column":70},"line":313,"code":"    it('should exit and enter the state for self-transitions (shallow)', () => {\n      expect(\n        lightMachine.transition('green', 'NOTHING').actions.map((a) => a.type)\n      ).toEqual(['exit_green', 'enter_green']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit and enter the state for self-transitions (deep)","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":319,"column":67},"line":319,"code":"    it('should exit and enter the state for self-transitions (deep)', () => {\n      // 'red' state resolves to 'red.walk'\n      expect(\n        lightMachine.transition('red', 'NOTHING').actions.map((a) => a.type)\n      ).toEqual(['exit_walk', 'exit_red', 'enter_red', 'enter_walk']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return actions for parallel machines","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":326,"column":51},"line":326,"code":"    it('should return actions for parallel machines', () => {\n      expect(\n        parallelMachine\n          .transition(parallelMachine.initialState, 'CHANGE')\n          .actions.map((a) => a.type)\n      ).toEqual([\n        'exit_b1', // reverse document order\n        'exit_a1',\n        'do_a2',\n        'another_do_a2',\n        'do_b2',\n        'enter_a2',\n        'enter_b2'\n      ]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return nested actions in the correct (child to parent) order","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":342,"column":75},"line":342,"code":"    it('should return nested actions in the correct (child to parent) order', () => {\n      expect(\n        deepMachine.transition('a.a1', 'CHANGE').actions.map((a) => a.type)\n      ).toEqual([\n        'exit_a1',\n        'exit_a',\n        'another_exit_a',\n        'enter_b',\n        'another_enter_b',\n        'enter_b1'\n      ]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should ignore parent state actions for same-parent substates","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":355,"column":68},"line":355,"code":"    it('should ignore parent state actions for same-parent substates', () => {\n      expect(\n        deepMachine.transition('a.a1', 'NEXT').actions.map((a) => a.type)\n      ).toEqual(['exit_a1', 'enter_a2']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with function actions","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":361,"column":41},"line":361,"code":"    it('should work with function actions', () => {\n      expect(\n        deepMachine\n          .transition(deepMachine.initialState, 'NEXT_FN')\n          .actions.map((action) => action.type)\n      ).toEqual(['exit_a1', 'enter_a3_fn']);\n\n      expect(\n        deepMachine\n          .transition('a.a3', 'NEXT')\n          .actions.map((action) => action.type)\n      ).toEqual(['exit_a3_fn', 'do_a3_to_a2', 'enter_a2']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit children of parallel state nodes","suites":["entry/exit actions","State.actions"],"updatePoint":{"line":375,"column":52},"line":375,"code":"    it('should exit children of parallel state nodes', () => {\n      const stateB = parallelMachine2.transition(\n        parallelMachine2.initialState,\n        'to-B'\n      );\n      const stateD2 = parallelMachine2.transition(stateB, 'to-D2');\n      const stateA = parallelMachine2.transition(stateD2, 'to-A');\n\n      expect(stateA.actions.map((action) => action.type)).toEqual(['D2 Exit']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"with a relative transition","suites":["entry/exit actions","State.actions","should ignore same-parent state actions (sparse)"],"updatePoint":{"line":423,"column":36},"line":423,"code":"      it('with a relative transition', () => {\n        expect(pingPong.transition('ping.foo', 'TACK').actions).toHaveLength(0);\n      });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"with an absolute transition","suites":["entry/exit actions","State.actions","should ignore same-parent state actions (sparse)"],"updatePoint":{"line":427,"column":37},"line":427,"code":"      it('with an absolute transition', () => {\n        expect(\n          pingPong.transition('ping.foo', 'ABSOLUTE_TACK').actions\n        ).toHaveLength(0);\n      });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry actions of an initial state","suites":["entry/exit actions","State.actions (with entry/exit instead of onEntry/onExit)"],"updatePoint":{"line":436,"column":59},"line":436,"code":"    it('should return the entry actions of an initial state', () => {\n      expect(newLightMachine.initialState.actions.map((a) => a.type)).toEqual([\n        'enter_green'\n      ]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry and exit actions of a transition","suites":["entry/exit actions","State.actions (with entry/exit instead of onEntry/onExit)"],"updatePoint":{"line":442,"column":64},"line":442,"code":"    it('should return the entry and exit actions of a transition', () => {\n      expect(\n        newLightMachine.transition('green', 'TIMER').actions.map((a) => a.type)\n      ).toEqual(['exit_green', 'enter_yellow']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry and exit actions of a deep transition","suites":["entry/exit actions","State.actions (with entry/exit instead of onEntry/onExit)"],"updatePoint":{"line":448,"column":69},"line":448,"code":"    it('should return the entry and exit actions of a deep transition', () => {\n      expect(\n        newLightMachine.transition('yellow', 'TIMER').actions.map((a) => a.type)\n      ).toEqual(['exit_yellow', 'enter_red', 'enter_walk']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the entry and exit actions of a nested transition","suites":["entry/exit actions","State.actions (with entry/exit instead of onEntry/onExit)"],"updatePoint":{"line":454,"column":71},"line":454,"code":"    it('should return the entry and exit actions of a nested transition', () => {\n      expect(\n        newLightMachine\n          .transition('red.walk', 'PED_COUNTDOWN')\n          .actions.map((a) => a.type)\n      ).toEqual(['exit_walk', 'enter_wait']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not have actions for unhandled events (shallow)","suites":["entry/exit actions","State.actions (with entry/exit instead of onEntry/onExit)"],"updatePoint":{"line":462,"column":62},"line":462,"code":"    it('should not have actions for unhandled events (shallow)', () => {\n      expect(\n        newLightMachine.transition('green', 'FAKE').actions.map((a) => a.type)\n      ).toEqual([]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not have actions for unhandled events (deep)","suites":["entry/exit actions","State.actions (with entry/exit instead of onEntry/onExit)"],"updatePoint":{"line":468,"column":59},"line":468,"code":"    it('should not have actions for unhandled events (deep)', () => {\n      expect(\n        newLightMachine.transition('red', 'FAKE').actions.map((a) => a.type)\n      ).toEqual([]);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit and enter the state for self-transitions (shallow)","suites":["entry/exit actions","State.actions (with entry/exit instead of onEntry/onExit)"],"updatePoint":{"line":474,"column":70},"line":474,"code":"    it('should exit and enter the state for self-transitions (shallow)', () => {\n      expect(\n        newLightMachine\n          .transition('green', 'NOTHING')\n          .actions.map((a) => a.type)\n      ).toEqual(['exit_green', 'enter_green']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit and enter the state for self-transitions (deep)","suites":["entry/exit actions","State.actions (with entry/exit instead of onEntry/onExit)"],"updatePoint":{"line":482,"column":67},"line":482,"code":"    it('should exit and enter the state for self-transitions (deep)', () => {\n      // 'red' state resolves to 'red.walk'\n      expect(\n        newLightMachine.transition('red', 'NOTHING').actions.map((a) => a.type)\n      ).toEqual(['exit_walk', 'exit_red', 'enter_red', 'enter_walk']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return entry action defined on parallel state","suites":["entry/exit actions","parallel states"],"updatePoint":{"line":491,"column":60},"line":491,"code":"    it('should return entry action defined on parallel state', () => {\n      const parallelMachineWithOnEntry = Machine({\n        id: 'fetch',\n        context: { attempts: 0 },\n        initial: 'start',\n        states: {\n          start: {\n            on: { ENTER_PARALLEL: 'p1' }\n          },\n          p1: {\n            type: 'parallel',\n            entry: 'enter_p1',\n            states: {\n              nested: {\n                initial: 'inner',\n                states: {\n                  inner: {\n                    entry: 'enter_inner'\n                  }\n                }\n              }\n            }\n          }\n        }\n      });\n\n      expect(\n        parallelMachineWithOnEntry\n          .transition('start', 'ENTER_PARALLEL')\n          .actions.map((a) => a.type)\n      ).toEqual(['enter_p1', 'enter_inner']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"shouldn't exit a state on a parent's targetless transition","suites":["entry/exit actions","targetless transitions"],"updatePoint":{"line":526,"column":66},"line":526,"code":"    it(\"shouldn't exit a state on a parent's targetless transition\", (done) => {\n      const actual: string[] = [];\n\n      const parent = Machine({\n        initial: 'one',\n        on: {\n          WHATEVER: {\n            actions: () => {\n              actual.push('got WHATEVER');\n            }\n          }\n        },\n        states: {\n          one: {\n            entry: () => {\n              actual.push('entered one');\n            },\n            always: 'two'\n          },\n          two: {\n            exit: () => {\n              actual.push('exited two');\n            }\n          }\n        }\n      });\n\n      const service = interpret(parent).start();\n\n      Promise.resolve()\n        .then(() => {\n          service.send('WHATEVER');\n        })\n        .then(() => {\n          expect(actual).toEqual(['entered one', 'got WHATEVER']);\n          done();\n        })\n        .catch(done);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"shouldn't exit (and reenter) state on targetless delayed transition","suites":["entry/exit actions","targetless transitions"],"updatePoint":{"line":566,"column":75},"line":566,"code":"    it(\"shouldn't exit (and reenter) state on targetless delayed transition\", (done) => {\n      const actual: string[] = [];\n\n      const machine = Machine({\n        initial: 'one',\n        states: {\n          one: {\n            entry: () => {\n              actual.push('entered one');\n            },\n            exit: () => {\n              actual.push('exited one');\n            },\n            after: {\n              10: {\n                actions: () => {\n                  actual.push('got FOO');\n                }\n              }\n            }\n          }\n        }\n      });\n\n      interpret(machine).start();\n\n      setTimeout(() => {\n        expect(actual).toEqual(['entered one', 'got FOO']);\n        done();\n      }, 50);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"exit actions should be called when invoked machine reaches its final state","suites":["entry/exit actions","when reaching a final state"],"updatePoint":{"line":601,"column":82},"line":601,"code":"    it('exit actions should be called when invoked machine reaches its final state', (done) => {\n      let exitCalled = false;\n      let childExitCalled = false;\n      const childMachine = Machine({\n        exit: () => {\n          exitCalled = true;\n        },\n        initial: 'a',\n        states: {\n          a: {\n            type: 'final',\n            exit: () => {\n              childExitCalled = true;\n            }\n          }\n        }\n      });\n\n      const parentMachine = Machine({\n        initial: 'active',\n        states: {\n          active: {\n            invoke: {\n              src: childMachine,\n              onDone: 'finished'\n            }\n          },\n          finished: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(parentMachine)\n        .onDone(() => {\n          expect(exitCalled).toBeTruthy();\n          expect(childExitCalled).toBeTruthy();\n          done();\n        })\n        .start();\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"exit actions should be called when stopping a machine","suites":["entry/exit actions","when stopped"],"updatePoint":{"line":645,"column":61},"line":645,"code":"    it('exit actions should be called when stopping a machine', () => {\n      let exitCalled = false;\n      let childExitCalled = false;\n\n      const machine = Machine({\n        exit: () => {\n          exitCalled = true;\n        },\n        initial: 'a',\n        states: {\n          a: {\n            exit: () => {\n              childExitCalled = true;\n            }\n          }\n        }\n      });\n\n      const service = interpret(machine).start();\n      service.stop();\n\n      expect(exitCalled).toBeTruthy();\n      expect(childExitCalled).toBeTruthy();\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call each exit handler only once when the service gets stopped","suites":["entry/exit actions","when stopped"],"updatePoint":{"line":670,"column":77},"line":670,"code":"    it('should call each exit handler only once when the service gets stopped', () => {\n      const actual: string[] = [];\n      const machine = createMachine({\n        exit: () => actual.push('root'),\n        initial: 'a',\n        states: {\n          a: {\n            exit: () => actual.push('a'),\n            initial: 'a1',\n            states: {\n              a1: {\n                exit: () => actual.push('a1')\n              }\n            }\n          }\n        }\n      });\n\n      interpret(machine).start().stop();\n      expect(actual).toEqual(['a1', 'a', 'root']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call exit actions in reversed document order when the service gets stopped","suites":["entry/exit actions","when stopped"],"updatePoint":{"line":692,"column":89},"line":692,"code":"    it('should call exit actions in reversed document order when the service gets stopped', () => {\n      const actual: string[] = [];\n      const machine = createMachine({\n        exit: () => actual.push('root'),\n        initial: 'a',\n        states: {\n          a: {\n            exit: () => actual.push('a'),\n            on: {\n              EV: {\n                // just a noop action to ensure that a transition is selected when we send an event\n                actions: () => {}\n              }\n            }\n          }\n        }\n      });\n\n      const service = interpret(machine).start();\n      // it's important to send an event here that results in a transition  that computes new `state.configuration`\n      // and that could impact the order in which exit actions are called\n      service.send({ type: 'EV' });\n      service.stop();\n\n      expect(actual).toEqual(['a', 'root']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call exit actions of parallel states in reversed document order when the service gets stopped after earlier region transition","suites":["entry/exit actions","when stopped"],"updatePoint":{"line":719,"column":140},"line":719,"code":"    it('should call exit actions of parallel states in reversed document order when the service gets stopped after earlier region transition', () => {\n      const actual: string[] = [];\n      const machine = createMachine({\n        exit: () => actual.push('root'),\n        type: 'parallel',\n        states: {\n          a: {\n            exit: () => actual.push('a'),\n            initial: 'child_a',\n            states: {\n              child_a: {\n                exit: () => actual.push('child_a'),\n                on: {\n                  EV: {\n                    // just a noop action to ensure that a transition is selected when we send an event\n                    actions: () => {}\n                  }\n                }\n              }\n            }\n          },\n          b: {\n            exit: () => actual.push('b'),\n            initial: 'child_b',\n            states: {\n              child_b: {\n                exit: () => actual.push('child_b')\n              }\n            }\n          }\n        }\n      });\n\n      const service = interpret(machine).start();\n      // it's important to send an event here that results in a transition as that computes new `state.configuration`\n      // and that could impact the order in which exit actions are called\n      service.send({ type: 'EV' });\n      service.stop();\n\n      expect(actual).toEqual(['child_b', 'b', 'child_a', 'a', 'root']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call exit actions of parallel states in reversed document order when the service gets stopped after later region transition","suites":["entry/exit actions","when stopped"],"updatePoint":{"line":761,"column":138},"line":761,"code":"    it('should call exit actions of parallel states in reversed document order when the service gets stopped after later region transition', () => {\n      const actual: string[] = [];\n      const machine = createMachine({\n        exit: () => actual.push('root'),\n        type: 'parallel',\n        states: {\n          a: {\n            exit: () => actual.push('a'),\n            initial: 'child_a',\n            states: {\n              child_a: {\n                exit: () => actual.push('child_a')\n              }\n            }\n          },\n          b: {\n            exit: () => actual.push('b'),\n            initial: 'child_b',\n            states: {\n              child_b: {\n                exit: () => actual.push('child_b'),\n                on: {\n                  EV: {\n                    // just a noop action to ensure that a transition is selected when we send an event\n                    actions: () => {}\n                  }\n                }\n              }\n            }\n          }\n        }\n      });\n\n      const service = interpret(machine).start();\n      // it's important to send an event here that results in a transition as that computes new `state.configuration`\n      // and that could impact the order in which exit actions are called\n      service.send({ type: 'EV' });\n      service.stop();\n\n      expect(actual).toEqual(['child_b', 'b', 'child_a', 'a', 'root']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call exit actions of parallel states in reversed document order when the service gets stopped after multiple regions transition","suites":["entry/exit actions","when stopped"],"updatePoint":{"line":803,"column":142},"line":803,"code":"    it('should call exit actions of parallel states in reversed document order when the service gets stopped after multiple regions transition', () => {\n      const actual: string[] = [];\n      const machine = createMachine({\n        exit: () => actual.push('root'),\n        type: 'parallel',\n        states: {\n          a: {\n            exit: () => actual.push('a'),\n            initial: 'child_a',\n            states: {\n              child_a: {\n                exit: () => actual.push('child_a'),\n                on: {\n                  EV: {\n                    // just a noop action to ensure that a transition is selected when we send an event\n                    actions: () => {}\n                  }\n                }\n              }\n            }\n          },\n          b: {\n            exit: () => actual.push('b'),\n            initial: 'child_b',\n            states: {\n              child_b: {\n                exit: () => actual.push('child_b'),\n                on: {\n                  EV: {\n                    // just a noop action to ensure that a transition is selected when we send an event\n                    actions: () => {}\n                  }\n                }\n              }\n            }\n          }\n        }\n      });\n\n      const service = interpret(machine).start();\n      // it's important to send an event here that results in a transition as that computes new `state.configuration`\n      // and that could impact the order in which exit actions are called\n      service.send({ type: 'EV' });\n      service.stop();\n\n      expect(actual).toEqual(['child_b', 'b', 'child_a', 'a', 'root']);\n    });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not recall previous actions","suites":["actions on invalid transition"],"updatePoint":{"line":869,"column":40},"line":869,"code":"  it('should not recall previous actions', () => {\n    const nextState = stopMachine.transition('idle', 'STOP');\n    expect(stopMachine.transition(nextState, 'INVALID').actions).toHaveLength(\n      0\n    );\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reference actions defined in actions parameter of machine options","suites":["actions config"],"updatePoint":{"line":928,"column":78},"line":928,"code":"  it('should reference actions defined in actions parameter of machine options', () => {\n    const { initialState } = simpleMachine;\n    const nextState = simpleMachine.transition(initialState, 'E');\n\n    expect(nextState.actions.map((a) => a.type)).toEqual(\n      expect.arrayContaining(['definedAction', 'undefinedAction'])\n    );\n\n    expect(nextState.actions).toEqual([\n      expect.objectContaining({ type: 'definedAction' }),\n      expect.objectContaining({ type: 'definedAction' }),\n      expect.objectContaining({ type: 'undefinedAction' })\n    ]);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reference actions defined in actions parameter of machine options (initial state)","suites":["actions config"],"updatePoint":{"line":943,"column":94},"line":943,"code":"  it('should reference actions defined in actions parameter of machine options (initial state)', () => {\n    const { initialState } = simpleMachine;\n\n    expect(initialState.actions.map((a) => a.type)).toEqual(\n      expect.arrayContaining(['definedAction', 'undefinedAction'])\n    );\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to reference action implementations from action objects","suites":["actions config"],"updatePoint":{"line":951,"column":76},"line":951,"code":"  it('should be able to reference action implementations from action objects', () => {\n    const state = simpleMachine.transition('a', 'EVENT');\n\n    expect(state.actions).toEqual([\n      expect.objectContaining({ type: 'definedAction' })\n    ]);\n\n    expect(state.context).toEqual({ count: 10 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with anonymous functions (with warning)","suites":["actions config"],"updatePoint":{"line":961,"column":57},"line":961,"code":"  it('should work with anonymous functions (with warning)', () => {\n    let onEntryCalled = false;\n    let actionCalled = false;\n    let onExitCalled = false;\n\n    const anonMachine = Machine({\n      id: 'anon',\n      initial: 'active',\n      states: {\n        active: {\n          entry: () => (onEntryCalled = true),\n          exit: () => (onExitCalled = true),\n          on: {\n            EVENT: {\n              target: 'inactive',\n              actions: [() => (actionCalled = true)]\n            }\n          }\n        },\n        inactive: {}\n      }\n    });\n\n    const { initialState } = anonMachine;\n\n    initialState.actions.forEach((action) => {\n      if (action.exec) {\n        action.exec(\n          initialState.context,\n          { type: 'any' },\n          {\n            action,\n            state: initialState,\n            _event: initialState._event\n          }\n        );\n      }\n    });\n\n    expect(onEntryCalled).toBe(true);\n\n    const inactiveState = anonMachine.transition(initialState, 'EVENT');\n\n    expect(inactiveState.actions.length).toBe(2);\n\n    inactiveState.actions.forEach((action) => {\n      if (action.exec) {\n        action.exec(\n          inactiveState.context,\n          { type: 'EVENT' },\n          {\n            action,\n            state: initialState,\n            _event: initialState._event\n          }\n        );\n      }\n    });\n\n    expect(onExitCalled).toBe(true);\n    expect(actionCalled).toBe(true);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide the original action and state to the exec function","suites":["action meta"],"updatePoint":{"line":1026,"column":71},"line":1026,"code":"  it('should provide the original action and state to the exec function', (done) => {\n    const testMachine = Machine(\n      {\n        id: 'test',\n        initial: 'foo',\n        states: {\n          foo: {\n            entry: {\n              type: 'entryAction',\n              value: 'something'\n            }\n          }\n        }\n      },\n      {\n        actions: {\n          entryAction: (_, __, meta) => {\n            expect(meta.state.value).toEqual('foo');\n            expect(meta.action.type).toEqual('entryAction');\n            expect(meta.action.value).toEqual('something');\n            done();\n          }\n        }\n      }\n    );\n\n    interpret(testMachine).start();\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow for a purely defined dynamic action","suites":["purely defined actions"],"updatePoint":{"line":1110,"column":54},"line":1110,"code":"  it('should allow for a purely defined dynamic action', () => {\n    const nextState = dynamicMachine.transition(dynamicMachine.initialState, {\n      type: 'SINGLE',\n      id: 3\n    });\n\n    expect(nextState.actions).toEqual([\n      {\n        type: 'SINGLE_EVENT',\n        length: 3,\n        id: 3\n      }\n    ]);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow for purely defined lack of actions","suites":["purely defined actions"],"updatePoint":{"line":1125,"column":53},"line":1125,"code":"  it('should allow for purely defined lack of actions', () => {\n    const nextState = dynamicMachine.transition(dynamicMachine.initialState, {\n      type: 'NONE',\n      id: 3\n    });\n\n    expect(nextState.actions).toEqual([]);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow for purely defined dynamic actions","suites":["purely defined actions"],"updatePoint":{"line":1134,"column":53},"line":1134,"code":"  it('should allow for purely defined dynamic actions', () => {\n    const nextState = dynamicMachine.transition(\n      dynamicMachine.initialState,\n      'EACH'\n    );\n\n    expect(nextState.actions).toEqual([\n      {\n        type: 'EVENT',\n        item: { id: 1 },\n        index: 0\n      },\n      {\n        type: 'EVENT',\n        item: { id: 2 },\n        index: 1\n      },\n      {\n        type: 'EVENT',\n        item: { id: 3 },\n        index: 2\n      }\n    ]);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should forward an event to a service","suites":["forwardTo()"],"updatePoint":{"line":1161,"column":42},"line":1161,"code":"  it('should forward an event to a service', (done) => {\n    const child = Machine<void, { type: 'EVENT'; value: number }>({\n      id: 'child',\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            EVENT: {\n              actions: sendParent('SUCCESS'),\n              cond: (_, e) => e.value === 42\n            }\n          }\n        }\n      }\n    });\n\n    const parent = Machine({\n      id: 'parent',\n      initial: 'first',\n      states: {\n        first: {\n          invoke: { src: child, id: 'myChild' },\n          on: {\n            EVENT: {\n              actions: forwardTo('myChild')\n            },\n            SUCCESS: 'last'\n          }\n        },\n        last: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(parent)\n      .onDone(() => done())\n      .start();\n\n    service.send('EVENT', { value: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should forward an event to a service (dynamic)","suites":["forwardTo()"],"updatePoint":{"line":1203,"column":52},"line":1203,"code":"  it('should forward an event to a service (dynamic)', (done) => {\n    const child = Machine<void, { type: 'EVENT'; value: number }>({\n      id: 'child',\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            EVENT: {\n              actions: sendParent('SUCCESS'),\n              cond: (_, e) => e.value === 42\n            }\n          }\n        }\n      }\n    });\n\n    const parent = Machine<{ child: any }>({\n      id: 'parent',\n      initial: 'first',\n      context: {\n        child: null\n      },\n      states: {\n        first: {\n          entry: assign({\n            child: () => spawn(child)\n          }),\n          on: {\n            EVENT: {\n              actions: forwardTo((ctx) => ctx.child)\n            },\n            SUCCESS: 'last'\n          }\n        },\n        last: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(parent)\n      .onDone(() => done())\n      .start();\n\n    service.send('EVENT', { value: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should log a string","suites":["log()"],"updatePoint":{"line":1270,"column":25},"line":1270,"code":"  it('should log a string', () => {\n    expect(logMachine.initialState.actions[0]).toMatchInlineSnapshot(`\n      Object {\n        \"expr\": \"some string\",\n        \"label\": \"string label\",\n        \"type\": \"xstate.log\",\n        \"value\": \"some string\",\n      }\n    `);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should log an expression","suites":["log()"],"updatePoint":{"line":1281,"column":30},"line":1281,"code":"  it('should log an expression', () => {\n    const nextState = logMachine.transition(logMachine.initialState, 'EXPR');\n    expect(nextState.actions[0]).toMatchInlineSnapshot(`\n      Object {\n        \"expr\": [Function],\n        \"label\": \"expr label\",\n        \"type\": \"xstate.log\",\n        \"value\": \"expr 42\",\n      }\n    `);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute a single conditional action","suites":["choose"],"updatePoint":{"line":1295,"column":48},"line":1295,"code":"  it('should execute a single conditional action', () => {\n    interface Ctx {\n      answer?: number;\n    }\n\n    const machine = createMachine<Ctx>({\n      context: {},\n      initial: 'foo',\n      states: {\n        foo: {\n          entry: choose([\n            { cond: () => true, actions: assign<Ctx>({ answer: 42 }) }\n          ])\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context).toEqual({ answer: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute a multiple conditional actions","suites":["choose"],"updatePoint":{"line":1317,"column":51},"line":1317,"code":"  it('should execute a multiple conditional actions', () => {\n    let executed = false;\n\n    interface Ctx {\n      answer?: number;\n    }\n\n    const machine = createMachine<Ctx>({\n      context: {},\n      initial: 'foo',\n      states: {\n        foo: {\n          entry: choose([\n            {\n              cond: () => true,\n              actions: [() => (executed = true), assign<Ctx>({ answer: 42 })]\n            }\n          ])\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context).toEqual({ answer: 42 });\n    expect(executed).toBeTruthy();\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should only execute matched actions","suites":["choose"],"updatePoint":{"line":1345,"column":41},"line":1345,"code":"  it('should only execute matched actions', () => {\n    interface Ctx {\n      answer?: number;\n      shouldNotAppear?: boolean;\n    }\n\n    const machine = createMachine<Ctx>({\n      context: {},\n      initial: 'foo',\n      states: {\n        foo: {\n          entry: choose([\n            {\n              cond: () => false,\n              actions: assign<Ctx>({ shouldNotAppear: true })\n            },\n            { cond: () => true, actions: assign<Ctx>({ answer: 42 }) }\n          ])\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context).toEqual({ answer: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow for fallback unguarded actions","suites":["choose"],"updatePoint":{"line":1372,"column":49},"line":1372,"code":"  it('should allow for fallback unguarded actions', () => {\n    interface Ctx {\n      answer?: number;\n      shouldNotAppear?: boolean;\n    }\n\n    const machine = createMachine<Ctx>({\n      context: {},\n      initial: 'foo',\n      states: {\n        foo: {\n          entry: choose([\n            {\n              cond: () => false,\n              actions: assign<Ctx>({ shouldNotAppear: true })\n            },\n            { actions: assign<Ctx>({ answer: 42 }) }\n          ])\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context).toEqual({ answer: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow for nested conditional actions","suites":["choose"],"updatePoint":{"line":1399,"column":49},"line":1399,"code":"  it('should allow for nested conditional actions', () => {\n    interface Ctx {\n      firstLevel: boolean;\n      secondLevel: boolean;\n      thirdLevel: boolean;\n    }\n\n    const machine = createMachine<Ctx>({\n      context: {\n        firstLevel: false,\n        secondLevel: false,\n        thirdLevel: false\n      },\n      initial: 'foo',\n      states: {\n        foo: {\n          entry: choose([\n            {\n              cond: () => true,\n              actions: [\n                assign<Ctx>({ firstLevel: true }),\n                choose([\n                  {\n                    cond: () => true,\n                    actions: [\n                      assign<Ctx>({ secondLevel: true }),\n                      choose([\n                        {\n                          cond: () => true,\n                          actions: [assign<Ctx>({ thirdLevel: true })]\n                        }\n                      ])\n                    ]\n                  }\n                ])\n              ]\n            }\n          ])\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context).toEqual({\n      firstLevel: true,\n      secondLevel: true,\n      thirdLevel: true\n    });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide context to a condition expression","suites":["choose"],"updatePoint":{"line":1450,"column":54},"line":1450,"code":"  it('should provide context to a condition expression', () => {\n    interface Ctx {\n      counter: number;\n      answer?: number;\n    }\n    const machine = createMachine<Ctx>({\n      context: {\n        counter: 101\n      },\n      initial: 'foo',\n      states: {\n        foo: {\n          entry: choose([\n            {\n              cond: (ctx) => ctx.counter > 100,\n              actions: assign<Ctx>({ answer: 42 })\n            }\n          ])\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context).toEqual({ counter: 101, answer: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide event to a condition expression","suites":["choose"],"updatePoint":{"line":1477,"column":52},"line":1477,"code":"  it('should provide event to a condition expression', () => {\n    interface Ctx {\n      answer?: number;\n    }\n    interface Events {\n      type: 'NEXT';\n      counter: number;\n    }\n\n    const machine = createMachine<Ctx, Events>({\n      context: {},\n      initial: 'foo',\n      states: {\n        foo: {\n          on: {\n            NEXT: {\n              target: 'bar',\n              actions: choose<Ctx, Events>([\n                {\n                  cond: (_, event) => event.counter > 100,\n                  actions: assign<Ctx, Events>({ answer: 42 })\n                }\n              ])\n            }\n          }\n        },\n        bar: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send({ type: 'NEXT', counter: 101 });\n    expect(service.state.context).toEqual({ answer: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide stateGuard.state to a condition expression","suites":["choose"],"updatePoint":{"line":1512,"column":63},"line":1512,"code":"  it('should provide stateGuard.state to a condition expression', () => {\n    type Ctx = { counter: number; answer?: number };\n    const machine = createMachine<Ctx>({\n      context: {\n        counter: 101\n      },\n      type: 'parallel',\n      states: {\n        foo: {\n          initial: 'waiting',\n          states: {\n            waiting: {\n              on: {\n                GIVE_ANSWER: 'answering'\n              }\n            },\n            answering: {\n              entry: choose([\n                {\n                  cond: (_, __, { state }) => state.matches('bar'),\n                  actions: assign<Ctx>({ answer: 42 })\n                }\n              ])\n            }\n          }\n        },\n        bar: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send('GIVE_ANSWER');\n\n    expect(service.state.context).toEqual({ counter: 101, answer: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to use actions and guards defined in options","suites":["choose"],"updatePoint":{"line":1548,"column":65},"line":1548,"code":"  it('should be able to use actions and guards defined in options', () => {\n    interface Ctx {\n      answer?: number;\n    }\n\n    const machine = createMachine<Ctx>(\n      {\n        context: {},\n        initial: 'foo',\n        states: {\n          foo: {\n            entry: choose([{ cond: 'worstGuard', actions: 'revealAnswer' }])\n          }\n        }\n      },\n      {\n        guards: {\n          worstGuard: () => true\n        },\n        actions: {\n          revealAnswer: assign<Ctx>({ answer: 42 })\n        }\n      }\n    );\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context).toEqual({ answer: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to use choose actions from within options","suites":["choose"],"updatePoint":{"line":1578,"column":62},"line":1578,"code":"  it('should be able to use choose actions from within options', () => {\n    interface Ctx {\n      answer?: number;\n    }\n\n    const machine = createMachine<Ctx>(\n      {\n        context: {},\n        initial: 'foo',\n        states: {\n          foo: {\n            entry: 'conditionallyRevealAnswer'\n          }\n        }\n      },\n      {\n        guards: {\n          worstGuard: () => true\n        },\n        actions: {\n          revealAnswer: assign<Ctx>({ answer: 42 }),\n          conditionallyRevealAnswer: choose([\n            { cond: 'worstGuard', actions: 'revealAnswer' }\n          ])\n        }\n      }\n    );\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context).toEqual({ answer: 42 });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"TS: should compile for any event","suites":["sendParent"],"updatePoint":{"line":1614,"column":38},"line":1614,"code":"  it('TS: should compile for any event', () => {\n    interface ChildContext {}\n    interface ChildEvent {\n      type: 'CHILD';\n    }\n\n    const child = Machine<ChildContext, any, ChildEvent>({\n      id: 'child',\n      initial: 'start',\n      states: {\n        start: {\n          // This should not be a TypeScript error\n          entry: [sendParent({ type: 'PARENT' })]\n        }\n      }\n    });\n\n    expect(child).toBeTruthy();\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to send an event to an actor","suites":["sendTo"],"updatePoint":{"line":1636,"column":49},"line":1636,"code":"  it('should be able to send an event to an actor', (done) => {\n    const childMachine = createMachine<any, { type: 'EVENT' }>({\n      initial: 'waiting',\n      states: {\n        waiting: {\n          on: {\n            EVENT: {\n              actions: () => done()\n            }\n          }\n        }\n      }\n    });\n\n    const parentMachine = createMachine<{\n      child: ActorRefFrom<typeof childMachine>;\n    }>({\n      context: () => ({\n        child: spawn(childMachine)\n      }),\n      entry: sendTo((ctx) => ctx.child, { type: 'EVENT' })\n    });\n\n    interpret(parentMachine).start();\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to send an event from expression to an actor","suites":["sendTo"],"updatePoint":{"line":1662,"column":65},"line":1662,"code":"  it('should be able to send an event from expression to an actor', (done) => {\n    const childMachine = createMachine<any, { type: 'EVENT'; count: number }>({\n      initial: 'waiting',\n      states: {\n        waiting: {\n          on: {\n            EVENT: {\n              cond: (_, e) => e.count === 42,\n              actions: () => done()\n            }\n          }\n        }\n      }\n    });\n\n    const parentMachine = createMachine<{\n      child: ActorRefFrom<typeof childMachine>;\n      count: number;\n    }>({\n      context: () => ({\n        child: spawn(childMachine),\n        count: 42\n      }),\n      entry: sendTo(\n        (ctx) => ctx.child,\n        (ctx) => ({ type: 'EVENT', count: ctx.count })\n      )\n    });\n\n    interpret(parentMachine).start();\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should report a type error for an invalid event","suites":["sendTo"],"updatePoint":{"line":1694,"column":53},"line":1694,"code":"  it('should report a type error for an invalid event', () => {\n    const childMachine = createMachine<any, { type: 'EVENT' }>({\n      initial: 'waiting',\n      states: {\n        waiting: {\n          on: {\n            EVENT: {}\n          }\n        }\n      }\n    });\n\n    createMachine<{\n      child: ActorRefFrom<typeof childMachine>;\n    }>({\n      context: () => ({\n        child: spawn(childMachine)\n      }),\n      entry: sendTo((ctx) => ctx.child, {\n        // @ts-expect-error\n        type: 'UNKNOWN'\n      })\n    });\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call transition actions in document order for same-level parallel regions","suites":["sendTo"],"updatePoint":{"line":1720,"column":84},"line":1720,"code":"it('should call transition actions in document order for same-level parallel regions', () => {\n  const actual: string[] = [];\n\n  const machine = createMachine({\n    type: 'parallel',\n    states: {\n      a: {\n        on: {\n          FOO: {\n            actions: () => actual.push('a')\n          }\n        }\n      },\n      b: {\n        on: {\n          FOO: {\n            actions: () => actual.push('b')\n          }\n        }\n      }\n    }\n  });\n  const service = interpret(machine).start();\n  service.send({ type: 'FOO' });\n\n  expect(actual).toEqual(['a', 'b']);\n});","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call transition actions in document order for states at different levels of parallel regions","suites":["sendTo"],"updatePoint":{"line":1748,"column":103},"line":1748,"code":"it('should call transition actions in document order for states at different levels of parallel regions', () => {\n  const actual: string[] = [];\n\n  const machine = createMachine({\n    type: 'parallel',\n    states: {\n      a: {\n        initial: 'a1',\n        states: {\n          a1: {\n            on: {\n              FOO: {\n                actions: () => actual.push('a1')\n              }\n            }\n          }\n        }\n      },\n      b: {\n        on: {\n          FOO: {\n            actions: () => actual.push('b')\n          }\n        }\n      }\n    }\n  });\n  const service = interpret(machine).start();\n  service.send({ type: 'FOO' });\n\n  expect(actual).toEqual(['a1', 'b']);\n});","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should preserve action order when .preserveActionOrder = true","suites":["assign action order"],"updatePoint":{"line":1782,"column":67},"line":1782,"code":"  it('should preserve action order when .preserveActionOrder = true', () => {\n    const captured: number[] = [];\n\n    const machine = createMachine<{ count: number }>({\n      context: { count: 0 },\n      entry: [\n        (ctx) => captured.push(ctx.count), // 0\n        assign({ count: (ctx) => ctx.count + 1 }),\n        (ctx) => captured.push(ctx.count), // 1\n        assign({ count: (ctx) => ctx.count + 1 }),\n        (ctx) => captured.push(ctx.count) // 2\n      ],\n      preserveActionOrder: true\n    });\n\n    interpret(machine).start();\n\n    expect(captured).toEqual([0, 1, 2]);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should deeply preserve action order when .preserveActionOrder = true","suites":["assign action order"],"updatePoint":{"line":1802,"column":74},"line":1802,"code":"  it('should deeply preserve action order when .preserveActionOrder = true', () => {\n    const captured: number[] = [];\n\n    interface CountCtx {\n      count: number;\n    }\n\n    const machine = createMachine<CountCtx>({\n      context: { count: 0 },\n      entry: [\n        (ctx) => captured.push(ctx.count), // 0\n        pure(() => {\n          return [\n            assign<CountCtx>({ count: (ctx) => ctx.count + 1 }),\n            { type: 'capture', exec: (ctx: any) => captured.push(ctx.count) }, // 1\n            assign<CountCtx>({ count: (ctx) => ctx.count + 1 })\n          ];\n        }),\n        (ctx) => captured.push(ctx.count) // 2\n      ],\n      preserveActionOrder: true\n    });\n\n    interpret(machine).start();\n\n    expect(captured).toEqual([0, 1, 2]);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should capture correct context values on subsequent transitions","suites":["assign action order"],"updatePoint":{"line":1830,"column":69},"line":1830,"code":"  it('should capture correct context values on subsequent transitions', () => {\n    let captured: number[] = [];\n\n    const machine = createMachine<{ counter: number }>({\n      context: {\n        counter: 0\n      },\n      on: {\n        EV: {\n          actions: [\n            assign({ counter: (ctx) => ctx.counter + 1 }),\n            (ctx) => captured.push(ctx.counter)\n          ]\n        }\n      },\n      preserveActionOrder: true\n    });\n\n    const service = interpret(machine).start();\n\n    service.send('EV');\n    service.send('EV');\n\n    expect(captured).toEqual([1, 2]);\n  });","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should prioritize assign actions when .preserveActionOrder = %i","suites":["assign action order"],"line":1856,"code":"  it.each([undefined, false])(\n    'should prioritize assign actions when .preserveActionOrder = %i',\n    (preserveActionOrder) => {\n      const captured: number[] = [];\n\n      const machine = createMachine<{ count: number }>({\n        context: { count: 0 },\n        entry: [\n          (ctx) => captured.push(ctx.count),\n          assign({ count: (ctx) => ctx.count + 1 }),\n          (ctx) => captured.push(ctx.count),\n          assign({ count: (ctx) => ctx.count + 1 }),\n          (ctx) => captured.push(ctx.count)\n        ],\n        preserveActionOrder\n      });\n\n      interpret(machine).start();\n\n      expect(captured).toEqual([2, 2, 2]);\n    }\n  );","file":"actions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should activate even if there are subsequent automatic, but blocked transitions","suites":["activities with guarded transitions"],"updatePoint":{"line":59,"column":85},"line":59,"code":"  it('should activate even if there are subsequent automatic, but blocked transitions', () => {\n    let state = machine.initialState;\n    state = machine.transition(state, 'E');\n    expect(state.activities.B_ACTIVITY).toBeTruthy();\n    expect(state.actions).toEqual([\n      start({ type: 'B_ACTIVITY', id: 'B_ACTIVITY', exec: undefined })\n    ]);\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should remember the activities even after an event","suites":["remembering activities"],"updatePoint":{"line":87,"column":56},"line":87,"code":"  it('should remember the activities even after an event', () => {\n    let state = machine.initialState;\n    state = machine.transition(state, 'E');\n    state = machine.transition(state, 'IGNORE');\n    expect(state.activities.B_ACTIVITY).toBeTruthy();\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"identifies initial activities","suites":["activities"],"updatePoint":{"line":96,"column":35},"line":96,"code":"  it('identifies initial activities', () => {\n    const { initialState } = lightMachine;\n\n    expect(initialState.activities.fadeInGreen).toBeTruthy();\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"identifies start activities","suites":["activities"],"updatePoint":{"line":101,"column":33},"line":101,"code":"  it('identifies start activities', () => {\n    const nextState = lightMachine.transition('yellow', 'TIMER');\n    expect(nextState.activities.activateCrosswalkLight).toBeTruthy();\n    expect(nextState.actions).toEqual([start('activateCrosswalkLight')]);\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"identifies start activities for child states and active activities","suites":["activities"],"updatePoint":{"line":107,"column":72},"line":107,"code":"  it('identifies start activities for child states and active activities', () => {\n    const redWalkState = lightMachine.transition('yellow', 'TIMER');\n    const nextState = lightMachine.transition(redWalkState, 'PED_WAIT');\n    expect(nextState.activities.activateCrosswalkLight).toBeTruthy();\n    expect(nextState.activities.blinkCrosswalkLight).toBeTruthy();\n    expect(nextState.actions).toEqual([start('blinkCrosswalkLight')]);\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"identifies stop activities for child states","suites":["activities"],"updatePoint":{"line":115,"column":49},"line":115,"code":"  it('identifies stop activities for child states', () => {\n    const redWalkState = lightMachine.transition('yellow', 'TIMER');\n    const redWaitState = lightMachine.transition(redWalkState, 'PED_WAIT');\n    const nextState = lightMachine.transition(redWaitState, 'PED_STOP');\n\n    expect(nextState.activities.activateCrosswalkLight).toBeTruthy();\n    expect(nextState.activities.blinkCrosswalkLight).toBe(false);\n    expect(nextState.actions).toEqual([stop('blinkCrosswalkLight')]);\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"identifies multiple stop activities for child and parent states","suites":["activities"],"updatePoint":{"line":125,"column":69},"line":125,"code":"  it('identifies multiple stop activities for child and parent states', () => {\n    const redWalkState = lightMachine.transition('yellow', 'TIMER');\n    const redWaitState = lightMachine.transition(redWalkState, 'PED_WAIT');\n    const redStopState = lightMachine.transition(redWaitState, 'PED_STOP');\n    const nextState = lightMachine.transition(redStopState, 'TIMER');\n\n    expect(nextState.activities.fadeInGreen).toBeTruthy();\n    expect(nextState.activities.activateCrosswalkLight).toBe(false);\n    expect(nextState.activities.blinkCrosswalkLight).toBe(false);\n\n    expect(nextState.actions).toEqual([\n      stop('activateCrosswalkLight'),\n      start('fadeInGreen')\n    ]);\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have started initial activities","suites":["transient activities"],"updatePoint":{"line":220,"column":44},"line":220,"code":"  it('should have started initial activities', () => {\n    const state = machine.initialState;\n    expect(state.activities.A).toBeTruthy();\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have started deep initial activities","suites":["transient activities"],"updatePoint":{"line":225,"column":49},"line":225,"code":"  it('should have started deep initial activities', () => {\n    const state = machine.initialState;\n    expect(state.activities.A1).toBeTruthy();\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have kept existing activities","suites":["transient activities"],"updatePoint":{"line":230,"column":42},"line":230,"code":"  it('should have kept existing activities', () => {\n    let state = machine.initialState;\n    state = machine.transition(state, 'A');\n    expect(state.activities.A).toBeTruthy();\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have kept same activities","suites":["transient activities"],"updatePoint":{"line":236,"column":38},"line":236,"code":"  it('should have kept same activities', () => {\n    let state = machine.initialState;\n    state = machine.transition(state, 'C_SIMILAR');\n    expect(state.activities.C1).toBeTruthy();\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have kept same activities after self transition","suites":["transient activities"],"updatePoint":{"line":242,"column":60},"line":242,"code":"  it('should have kept same activities after self transition', () => {\n    let state = machine.initialState;\n    state = machine.transition(state, 'C');\n    expect(state.activities.C1).toBeTruthy();\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have stopped after automatic transitions","suites":["transient activities"],"updatePoint":{"line":248,"column":53},"line":248,"code":"  it('should have stopped after automatic transitions', () => {\n    let state = machine.initialState;\n    state = machine.transition(state, 'A');\n    expect(state.value).toEqual({ A: 'A2', B: 'B2', C: 'C1' });\n    expect(state.activities.B2).toBeTruthy();\n  });","file":"activities.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should invoke actors","suites":["spawning machines"],"updatePoint":{"line":153,"column":26},"line":153,"code":"  it('should invoke actors', (done) => {\n    const service = interpret(todosMachine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n\n    service.send('ADD', { id: 42 });\n    service.send('SET_COMPLETE', { id: 42 });\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should invoke actors (when sending batch)","suites":["spawning machines"],"updatePoint":{"line":164,"column":47},"line":164,"code":"  it('should invoke actors (when sending batch)', (done) => {\n    const service = interpret(todosMachine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n\n    service.send([{ type: 'ADD', id: 42 }]);\n    service.send('SET_COMPLETE', { id: 42 });\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should invoke a null actor if spawned outside of a service","suites":["spawning machines"],"updatePoint":{"line":175,"column":64},"line":175,"code":"  it('should invoke a null actor if spawned outside of a service', () => {\n    expect(spawn(todoMachine)).toBeTruthy();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow bidirectional communication between parent/child actors","suites":["spawning machines"],"updatePoint":{"line":179,"column":74},"line":179,"code":"  it('should allow bidirectional communication between parent/child actors', (done) => {\n    interpret(clientMachine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to spawn a promise","suites":["spawning promises"],"updatePoint":{"line":222,"column":39},"line":222,"code":"  it('should be able to spawn a promise', (done) => {\n    const promiseService = interpret(promiseMachine).onDone(() => {\n      done();\n    });\n\n    promiseService.start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to spawn an actor from a callback","suites":["spawning callbacks"],"updatePoint":{"line":265,"column":54},"line":265,"code":"  it('should be able to spawn an actor from a callback', (done) => {\n    const callbackService = interpret(callbackMachine).onDone(() => {\n      done();\n    });\n\n    callbackService.start();\n    callbackService.send('START_CB');\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to spawn an observable","suites":["spawning observables"],"updatePoint":{"line":316,"column":43},"line":316,"code":"  it('should be able to spawn an observable', (done) => {\n    const observableService = interpret(observableMachine).onDone(() => {\n      done();\n    });\n\n    observableService.start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should treat an interpreter as an actor","suites":["communicating with spawned actors"],"updatePoint":{"line":326,"column":45},"line":326,"code":"  it('should treat an interpreter as an actor', (done) => {\n    const existingMachine = Machine({\n      initial: 'inactive',\n      states: {\n        inactive: {\n          on: { ACTIVATE: 'active' }\n        },\n        active: {\n          entry: respond('EXISTING.DONE')\n        }\n      }\n    });\n\n    const existingService = interpret(existingMachine).start();\n\n    const parentMachine = Machine<any>({\n      initial: 'pending',\n      context: {\n        existingRef: undefined as any\n      },\n      states: {\n        pending: {\n          entry: assign({\n            // No need to spawn an existing service:\n            // existingRef: () => spawn(existingService)\n            existingRef: existingService\n          }),\n          on: {\n            'EXISTING.DONE': 'success'\n          },\n          after: {\n            100: {\n              actions: send('ACTIVATE', { to: (ctx) => ctx.existingRef })\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    const parentService = interpret(parentMachine).onDone(() => {\n      done();\n    });\n\n    parentService.start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to name existing actors","suites":["communicating with spawned actors"],"updatePoint":{"line":375,"column":44},"line":375,"code":"  it('should be able to name existing actors', (done) => {\n    const existingMachine = Machine({\n      initial: 'inactive',\n      states: {\n        inactive: {\n          on: { ACTIVATE: 'active' }\n        },\n        active: {\n          entry: respond('EXISTING.DONE')\n        }\n      }\n    });\n\n    const existingService = interpret(existingMachine).start();\n\n    const parentMachine = createMachine<{\n      existingRef: ActorRef<any> | undefined;\n    }>({\n      initial: 'pending',\n      context: {\n        existingRef: undefined\n      },\n      states: {\n        pending: {\n          entry: assign({\n            existingRef: () => spawn(existingService, 'existing')\n          }),\n          on: {\n            'EXISTING.DONE': 'success'\n          },\n          after: {\n            100: {\n              actions: send('ACTIVATE', { to: 'existing' })\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    const parentService = interpret(parentMachine).onDone(() => {\n      done();\n    });\n\n    parentService.start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to communicate with arbitrary actors if sessionId is known","suites":["communicating with spawned actors"],"updatePoint":{"line":424,"column":79},"line":424,"code":"  it('should be able to communicate with arbitrary actors if sessionId is known', (done) => {\n    const existingMachine = Machine({\n      initial: 'inactive',\n      states: {\n        inactive: {\n          on: { ACTIVATE: 'active' }\n        },\n        active: {\n          entry: respond('EXISTING.DONE')\n        }\n      }\n    });\n\n    const existingService = interpret(existingMachine).start();\n\n    const parentMachine = Machine<any>({\n      initial: 'pending',\n      states: {\n        pending: {\n          entry: send('ACTIVATE', { to: existingService.sessionId }),\n          on: {\n            'EXISTING.DONE': 'success'\n          },\n          after: {\n            100: {\n              actions: send('ACTIVATE', { to: (ctx) => ctx.existingRef })\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    const parentService = interpret(parentMachine).onDone(() => {\n      done();\n    });\n\n    parentService.start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should only spawn actors defined on initial state once","suites":["actors"],"updatePoint":{"line":468,"column":60},"line":468,"code":"  it('should only spawn actors defined on initial state once', () => {\n    let count = 0;\n\n    const startMachine = Machine<any>({\n      id: 'start',\n      initial: 'start',\n      context: {\n        items: [0, 1, 2, 3],\n        refs: []\n      },\n      states: {\n        start: {\n          entry: assign({\n            refs: (ctx) => {\n              count++;\n              const c = ctx.items.map((item: any) =>\n                spawn(new Promise((res) => res(item)))\n              );\n\n              return c;\n            }\n          })\n        }\n      }\n    });\n\n    interpret(startMachine)\n      .onTransition(() => {\n        expect(count).toEqual(1);\n      })\n      .start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should only spawn an actor in an initial state of a child that gets invoked in the initial state of a parent when the parent gets started","suites":["actors"],"updatePoint":{"line":501,"column":143},"line":501,"code":"  it('should only spawn an actor in an initial state of a child that gets invoked in the initial state of a parent when the parent gets started', () => {\n    let spawnCounter = 0;\n\n    interface TestContext {\n      promise?: ActorRefFrom<Promise<string>>;\n    }\n\n    const child = Machine<TestContext>({\n      initial: 'bar',\n      context: {},\n      states: {\n        bar: {\n          entry: assign<TestContext>({\n            promise: () => {\n              return spawn(() => {\n                spawnCounter++;\n                return Promise.resolve('answer');\n              });\n            }\n          })\n        }\n      }\n    });\n\n    const parent = Machine({\n      initial: 'foo',\n      states: {\n        foo: {\n          invoke: {\n            src: child,\n            onDone: 'end'\n          }\n        },\n        end: { type: 'final' }\n      }\n    });\n    interpret(parent).start();\n    expect(spawnCounter).toBe(1);\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should only spawn an initial actor once when it synchronously responds with an event","suites":["actors"],"updatePoint":{"line":542,"column":90},"line":542,"code":"  it('should only spawn an initial actor once when it synchronously responds with an event', () => {\n    let spawnCalled = 0;\n    const anotherMachine = createMachine({\n      initial: 'hello',\n      states: {\n        hello: {\n          entry: sendParent('ping')\n        }\n      }\n    });\n\n    const testMachine = createMachine<{ ref: ActorRef<any> }>({\n      initial: 'testing',\n      context: () => {\n        spawnCalled++;\n        // throw in case of an infinite loop\n        expect(spawnCalled).toBe(1);\n        return {\n          ref: spawn(anotherMachine)\n        };\n      },\n      states: {\n        testing: {\n          on: {\n            ping: {\n              target: 'done'\n            }\n          }\n        },\n        done: {}\n      }\n    });\n\n    const service = interpret(testMachine).start();\n    expect(service.state.value).toEqual('done');\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should spawn null actors if not used within a service","suites":["actors"],"updatePoint":{"line":579,"column":59},"line":579,"code":"  it('should spawn null actors if not used within a service', () => {\n    interface TestContext {\n      ref?: ActorRef<any>;\n    }\n\n    const nullActorMachine = Machine<TestContext>({\n      initial: 'foo',\n      context: { ref: undefined },\n      states: {\n        foo: {\n          entry: assign<TestContext>({\n            ref: () => spawn(Promise.resolve(42))\n          })\n        }\n      }\n    });\n\n    const { initialState } = nullActorMachine;\n\n    // expect(initialState.context.ref!.id).toBe('null'); // TODO: identify null actors\n    expect(initialState.context.ref!.send).toBeDefined();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not forward events to a spawned actor by default","suites":["actors","autoForward option"],"updatePoint":{"line":621,"column":63},"line":621,"code":"    it('should not forward events to a spawned actor by default', () => {\n      let pongCounter = 0;\n\n      const machine = Machine<any>({\n        id: 'client',\n        context: { counter: 0, serverRef: undefined },\n        initial: 'initial',\n        states: {\n          initial: {\n            entry: assign(() => ({\n              serverRef: spawn(pongActorMachine)\n            })),\n            on: {\n              PONG: {\n                actions: () => ++pongCounter\n              }\n            }\n          }\n        }\n      });\n      const service = interpret(machine);\n      service.start();\n      service.send('PING');\n      service.send('PING');\n      expect(pongCounter).toEqual(0);\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not forward events to a spawned actor when { autoForward: false }","suites":["actors","autoForward option"],"updatePoint":{"line":648,"column":80},"line":648,"code":"    it('should not forward events to a spawned actor when { autoForward: false }', () => {\n      let pongCounter = 0;\n\n      const machine = Machine<{ counter: number; serverRef?: ActorRef<any> }>({\n        id: 'client',\n        context: { counter: 0, serverRef: undefined },\n        initial: 'initial',\n        states: {\n          initial: {\n            entry: assign((ctx) => ({\n              ...ctx,\n              serverRef: spawn(pongActorMachine, { autoForward: false })\n            })),\n            on: {\n              PONG: {\n                actions: () => ++pongCounter\n              }\n            }\n          }\n        }\n      });\n      const service = interpret(machine);\n      service.start();\n      service.send('PING');\n      service.send('PING');\n      expect(pongCounter).toEqual(0);\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should forward events to a spawned actor when { autoForward: true }","suites":["actors","autoForward option"],"updatePoint":{"line":676,"column":75},"line":676,"code":"    it('should forward events to a spawned actor when { autoForward: true }', () => {\n      let pongCounter = 0;\n\n      const machine = Machine<any>({\n        id: 'client',\n        context: { counter: 0, serverRef: undefined },\n        initial: 'initial',\n        states: {\n          initial: {\n            entry: assign(() => ({\n              serverRef: spawn(pongActorMachine, { autoForward: true })\n            })),\n            on: {\n              PONG: {\n                actions: () => ++pongCounter\n              }\n            }\n          }\n        }\n      });\n      const service = interpret(machine);\n      service.start();\n      service.send('PING');\n      service.send('PING');\n      expect(pongCounter).toEqual(2);\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should sync spawned actor state when { sync: true }","suites":["actors","sync option"],"updatePoint":{"line":746,"column":59},"line":746,"code":"    it('should sync spawned actor state when { sync: true }', () => {\n      return new Promise<void>((res) => {\n        const service = interpret(parentMachine, {\n          id: 'a-service'\n        }).onTransition((s) => {\n          if (s.context.ref?.getSnapshot()?.context.value === 42) {\n            res();\n          }\n        });\n        service.start();\n      });\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not sync spawned actor state when { sync: false }","suites":["actors","sync option"],"updatePoint":{"line":759,"column":64},"line":759,"code":"    it('should not sync spawned actor state when { sync: false }', () => {\n      return new Promise<void>((res, rej) => {\n        const service = interpret(parentMachine, {\n          id: 'b-service'\n        }).onTransition((s) => {\n          if (s.context.refNoSync?.getSnapshot()?.context.value === 42) {\n            rej(new Error('value change caused transition'));\n          }\n        });\n        service.start();\n\n        setTimeout(() => {\n          expect(\n            service.state.context.refNoSync?.getSnapshot()?.context.value\n          ).toBe(42);\n          res();\n        }, 30);\n      });\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not sync spawned actor state (default)","suites":["actors","sync option"],"updatePoint":{"line":779,"column":53},"line":779,"code":"    it('should not sync spawned actor state (default)', () => {\n      return new Promise<void>((res, rej) => {\n        const service = interpret(parentMachine, {\n          id: 'c-service'\n        }).onTransition((s) => {\n          if (s.context.refNoSyncDefault?.getSnapshot()?.context.value === 42) {\n            rej(new Error('value change caused transition'));\n          }\n        });\n        service.start();\n\n        setTimeout(() => {\n          expect(\n            service.state.context.refNoSyncDefault?.getSnapshot()?.context.value\n          ).toBe(42);\n          res();\n        }, 30);\n      });\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"parent state should be changed if synced child actor update occurs","suites":["actors","sync option"],"updatePoint":{"line":799,"column":74},"line":799,"code":"    it('parent state should be changed if synced child actor update occurs', (done) => {\n      const syncChildMachine = Machine({\n        initial: 'active',\n        states: {\n          active: {\n            after: { 500: 'inactive' }\n          },\n          inactive: {}\n        }\n      });\n\n      interface SyncMachineContext {\n        ref?: ActorRefFrom<typeof syncChildMachine>;\n      }\n\n      const syncMachine = Machine<SyncMachineContext>({\n        initial: 'same',\n        context: {},\n        states: {\n          same: {\n            entry: assign<SyncMachineContext>({\n              ref: () => spawn(syncChildMachine, { sync: true })\n            })\n          }\n        }\n      });\n\n      interpret(syncMachine)\n        .onTransition((state) => {\n          if (state.context.ref?.getSnapshot()?.matches('inactive')) {\n            expect(state.changed).toBe(true);\n            done();\n          }\n        })\n        .start();\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"parent state should NOT be changed regardless of unsynced child actor update (options: )","suites":["actors","sync option"],"updatePoint":{"line":841,"column":9},"line":839,"code":"      it(`parent state should NOT be changed regardless of unsynced child actor update (options: ${JSON.stringify(\n        falseSyncOption\n      )})`, (done) => {\n        const syncChildMachine = Machine({\n          initial: 'active',\n          states: {\n            active: {\n              after: { 10: 'inactive' }\n            },\n            inactive: {}\n          }\n        });\n\n        interface SyncMachineContext {\n          ref?: ActorRefFrom<typeof syncChildMachine>;\n        }\n\n        const syncMachine = Machine<SyncMachineContext>({\n          initial: 'same',\n          context: {},\n          states: {\n            same: {\n              entry: assign<SyncMachineContext>({\n                ref: () => spawn(syncChildMachine, falseSyncOption)\n              })\n            }\n          }\n        });\n\n        const service = interpret(syncMachine)\n          .onTransition((state) => {\n            if (\n              state.context.ref &&\n              state.context.ref.getSnapshot()?.matches('inactive')\n            ) {\n              expect(state.changed).toBe(false);\n            }\n          })\n          .start();\n\n        setTimeout(() => {\n          expect(\n            service.state.context.ref?.getSnapshot()?.matches('inactive')\n          ).toBe(true);\n          done();\n        }, 20);\n      });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"parent state should be changed if unsynced child actor manually sends update event (options: )","suites":["actors","sync option"],"updatePoint":{"line":889,"column":9},"line":887,"code":"      it(`parent state should be changed if unsynced child actor manually sends update event (options: ${JSON.stringify(\n        falseSyncOption\n      )})`, (done) => {\n        const syncChildMachine = Machine({\n          initial: 'active',\n          states: {\n            active: {\n              after: { 10: 'inactive' }\n            },\n            inactive: {\n              entry: sendUpdate()\n            }\n          }\n        });\n\n        interface SyncMachineContext {\n          ref?: ActorRefFrom<typeof syncChildMachine>;\n        }\n\n        const syncMachine = Machine<SyncMachineContext>({\n          initial: 'same',\n          context: {},\n          states: {\n            same: {\n              entry: assign<SyncMachineContext>({\n                ref: () => spawn(syncChildMachine, falseSyncOption)\n              })\n            }\n          }\n        });\n\n        interpret(syncMachine)\n          .onTransition((state) => {\n            if (state.context.ref?.getSnapshot()?.matches('inactive')) {\n              expect(state.changed).toBe(true);\n              done();\n            }\n          })\n          .start();\n      });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a reducer behavior","suites":["actors","with behaviors"],"updatePoint":{"line":931,"column":43},"line":931,"code":"    it('should work with a reducer behavior', (done) => {\n      const countBehavior: Behavior<EventObject, number> = {\n        transition: (count, event) => {\n          if (event.type === 'INC') {\n            return count + 1;\n          } else {\n            return count - 1;\n          }\n        },\n        initialState: 0\n      };\n\n      const countMachine = createMachine<{\n        count: ActorRefFrom<typeof countBehavior> | undefined;\n      }>({\n        context: {\n          count: undefined\n        },\n        entry: assign({\n          count: () => spawn(countBehavior)\n        }),\n        on: {\n          INC: {\n            actions: forwardTo((ctx) => ctx.count!)\n          }\n        }\n      });\n\n      const countService = interpret(countMachine)\n        .onTransition((state) => {\n          if (state.context.count?.getSnapshot() === 2) {\n            done();\n          }\n        })\n        .start();\n\n      countService.send('INC');\n      countService.send('INC');\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a promise behavior (fulfill)","suites":["actors","with behaviors"],"updatePoint":{"line":971,"column":53},"line":971,"code":"    it('should work with a promise behavior (fulfill)', (done) => {\n      const promiseBehavior = fromPromise(\n        () =>\n          new Promise<number>((res) => {\n            setTimeout(() => res(42));\n          })\n      );\n\n      const countMachine = createMachine<{\n        count: ActorRefFrom<typeof promiseBehavior> | undefined;\n      }>({\n        context: {\n          count: undefined\n        },\n        entry: assign({\n          count: () => spawn(promiseBehavior, 'test')\n        }),\n        initial: 'pending',\n        states: {\n          pending: {\n            on: {\n              'done.invoke.test': {\n                target: 'success',\n                cond: (_, e) => e.data === 42\n              }\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      const countService = interpret(countMachine).onDone(() => {\n        done();\n      });\n      countService.start();\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a promise behavior (reject)","suites":["actors","with behaviors"],"updatePoint":{"line":1010,"column":52},"line":1010,"code":"    it('should work with a promise behavior (reject)', (done) => {\n      const errorMessage = 'An error occurred';\n      const promiseBehavior = fromPromise(\n        () =>\n          new Promise<number>((_, rej) => {\n            setTimeout(() => rej(errorMessage), 1000);\n          })\n      );\n\n      const countMachine = createMachine<{\n        count: ActorRefFrom<typeof promiseBehavior>;\n      }>({\n        context: () => ({\n          count: spawn(promiseBehavior, 'test')\n        }),\n        initial: 'pending',\n        states: {\n          pending: {\n            on: {\n              [error('test')]: {\n                target: 'success',\n                cond: (_, e) => {\n                  return e.data === errorMessage;\n                }\n              }\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      const countService = interpret(countMachine).onDone(() => {\n        done();\n      });\n      countService.start();\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"behaviors should have reference to the parent","suites":["actors","with behaviors"],"updatePoint":{"line":1049,"column":53},"line":1049,"code":"    it('behaviors should have reference to the parent', (done) => {\n      const pongBehavior: Behavior<EventObject, undefined> = {\n        transition: (_, event, { parent }) => {\n          if (event.type === 'PING') {\n            parent?.send({ type: 'PONG' });\n          }\n\n          return undefined;\n        },\n        initialState: undefined\n      };\n\n      const pingMachine = createMachine<{\n        ponger: ActorRefFrom<typeof pongBehavior> | undefined;\n      }>({\n        initial: 'waiting',\n        context: {\n          ponger: undefined\n        },\n        entry: assign({\n          ponger: () => spawn(pongBehavior)\n        }),\n        states: {\n          waiting: {\n            entry: send('PING', { to: (ctx) => ctx.ponger! }),\n            invoke: {\n              id: 'ponger',\n              src: () => pongBehavior\n            },\n            on: {\n              PONG: 'success'\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      const pingService = interpret(pingMachine).onDone(() => {\n        done();\n      });\n      pingService.start();\n    });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to spawn callback actors in (lazy) initial context","suites":["actors","with behaviors"],"updatePoint":{"line":1095,"column":71},"line":1095,"code":"  it('should be able to spawn callback actors in (lazy) initial context', (done) => {\n    const machine = createMachine<{ ref: ActorRef<any> }>({\n      context: () => ({\n        ref: spawn((sendBack) => {\n          sendBack('TEST');\n        })\n      }),\n      initial: 'waiting',\n      states: {\n        waiting: {\n          on: { TEST: 'success' }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    interpret(machine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to spawn machines in (lazy) initial context","suites":["actors","with behaviors"],"updatePoint":{"line":1120,"column":64},"line":1120,"code":"  it('should be able to spawn machines in (lazy) initial context', (done) => {\n    const childMachine = createMachine({\n      entry: sendParent('TEST')\n    });\n\n    const machine = createMachine<{ ref: ActorRef<any> }>({\n      context: () => ({\n        ref: spawn(childMachine)\n      }),\n      initial: 'waiting',\n      states: {\n        waiting: {\n          on: { TEST: 'success' }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    interpret(machine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not crash on child machine sync completion during self-initialization","suites":["actors","with behaviors"],"updatePoint":{"line":1148,"column":82},"line":1148,"code":"  it('should not crash on child machine sync completion during self-initialization', () => {\n    const childMachine = createMachine({\n      initial: 'idle',\n      states: {\n        idle: {\n          always: [\n            {\n              target: 'stopped'\n            }\n          ]\n        },\n        stopped: {\n          type: 'final'\n        }\n      }\n    });\n\n    const parentMachine = createMachine<{\n      child: ActorRefFrom<typeof childMachine> | null;\n    }>(\n      {\n        context: {\n          child: null\n        },\n        entry: 'setup'\n      },\n      {\n        actions: {\n          setup: assign({\n            child: (_) => spawn(childMachine)\n          })\n        }\n      }\n    );\n    const service = interpret(parentMachine);\n    expect(() => {\n      service.start();\n    }).not.toThrow();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not crash on child promise-like sync completion during self-initialization","suites":["actors","with behaviors"],"updatePoint":{"line":1188,"column":87},"line":1188,"code":"  it('should not crash on child promise-like sync completion during self-initialization', () => {\n    const parentMachine = createMachine<{\n      child: ActorRef<never, any> | null;\n    }>({\n      context: {\n        child: null\n      },\n      entry: assign({\n        child: () => spawn({ then: (fn: any) => fn(null) } as any)\n      })\n    });\n    const service = interpret(parentMachine);\n    expect(() => {\n      service.start();\n    }).not.toThrow();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not crash on child observable sync completion during self-initialization","suites":["actors","with behaviors"],"updatePoint":{"line":1205,"column":85},"line":1205,"code":"  it('should not crash on child observable sync completion during self-initialization', () => {\n    const createEmptyObservable = (): any => ({\n      subscribe(_next: () => void, _error: () => void, complete: () => void) {\n        complete();\n      }\n    });\n    const parentMachine = createMachine<{\n      child: ActorRef<never, any> | null;\n    }>({\n      context: {\n        child: null\n      },\n      entry: assign({\n        child: () => spawn(createEmptyObservable())\n      })\n    });\n    const service = interpret(parentMachine);\n    expect(() => {\n      service.start();\n    }).not.toThrow();\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should receive done event from an immediately completed observable when self-initializing","suites":["actors","with behaviors"],"updatePoint":{"line":1227,"column":95},"line":1227,"code":"  it('should receive done event from an immediately completed observable when self-initializing', () => {\n    const parentMachine = createMachine<{\n      child: ActorRef<EventObject, unknown> | null;\n    }>({\n      context: {\n        child: null\n      },\n      entry: assign({\n        child: () => spawn(EMPTY, 'myactor')\n      }),\n      initial: 'init',\n      states: {\n        init: {\n          on: {\n            'done.invoke.myactor': 'done'\n          }\n        },\n        done: {}\n      }\n    });\n    const service = interpret(parentMachine);\n\n    service.start();\n\n    expect(service.state.value).toBe('done');\n  });","file":"actor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition after delay","suites":["delayed transitions"],"updatePoint":{"line":29,"column":35},"line":29,"code":"  it('should transition after delay', () => {\n    const nextState = lightMachine.transition(\n      lightMachine.initialState,\n      after(1000, 'light.green')\n    );\n\n    expect(nextState.value).toEqual('yellow');\n    expect(nextState.actions).toEqual([\n      cancel(after(1000, 'light.green')),\n      {\n        ...send(after(1000, 'light.yellow'), { delay: 1000 }),\n        _event: toSCXMLEvent(after(1000, 'light.yellow'))\n      }\n    ]);\n  });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should format transitions properly","suites":["delayed transitions"],"updatePoint":{"line":45,"column":40},"line":45,"code":"  it('should format transitions properly', () => {\n    const greenNode = lightMachine.states.green;\n\n    const transitions = greenNode.transitions;\n\n    expect(transitions.map((t) => t.eventType)).toEqual([\n      after(1000, greenNode.id)\n    ]);\n  });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to transition with delay from nested initial state","suites":["delayed transitions"],"updatePoint":{"line":55,"column":71},"line":55,"code":"  it('should be able to transition with delay from nested initial state', (done) => {\n    const machine = createMachine({\n      initial: 'nested',\n      states: {\n        nested: {\n          initial: 'wait',\n          states: {\n            wait: {\n              after: {\n                10: '#end'\n              }\n            }\n          }\n        },\n        end: {\n          id: 'end',\n          type: 'final'\n        }\n      }\n    });\n\n    interpret(machine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n  });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"parent state should enter child state without re-entering self (relative target)","suites":["delayed transitions"],"updatePoint":{"line":83,"column":86},"line":83,"code":"  it('parent state should enter child state without re-entering self (relative target)', (done) => {\n    const actual: string[] = [];\n    const machine = createMachine({\n      initial: 'one',\n      states: {\n        one: {\n          initial: 'two',\n          entry: () => actual.push('entered one'),\n          states: {\n            two: {\n              entry: () => actual.push('entered two')\n            },\n            three: {\n              entry: () => actual.push('entered three'),\n              always: '#end'\n            }\n          },\n          after: {\n            10: '.three'\n          }\n        },\n        end: {\n          id: 'end',\n          type: 'final'\n        }\n      }\n    });\n\n    interpret(machine)\n      .onDone(() => {\n        expect(actual).toEqual(['entered one', 'entered two', 'entered three']);\n        done();\n      })\n      .start();\n  });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should defer a single send event for a delayed transition with multiple conditions (#886)","suites":["delayed transitions"],"updatePoint":{"line":119,"column":95},"line":119,"code":"  it('should defer a single send event for a delayed transition with multiple conditions (#886)', () => {\n    type Events = { type: 'FOO' };\n\n    const machine = createMachine<{}, Events>({\n      initial: 'X',\n      states: {\n        X: {\n          on: {\n            FOO: 'X'\n          },\n          after: {\n            1500: [\n              {\n                target: 'Y',\n                cond: () => true\n              },\n              {\n                target: 'Z'\n              }\n            ]\n          }\n        },\n        Y: {},\n        Z: {}\n      }\n    });\n\n    expect(machine.initialState.actions.length).toBe(1);\n  });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute an after transition after starting from a state resolved using `machine.getInitialState`","suites":["delayed transitions"],"updatePoint":{"line":149,"column":109},"line":149,"code":"  it('should execute an after transition after starting from a state resolved using `machine.getInitialState`', (done) => {\n    const machine = createMachine({\n      id: 'machine',\n      initial: 'a',\n      states: {\n        a: {},\n\n        withAfter: {\n          after: {\n            1: { target: 'done' }\n          }\n        },\n\n        done: {\n          type: 'final'\n        }\n      }\n    });\n\n    interpret(machine)\n      .onDone(() => done())\n      .start(machine.getInitialState('withAfter'));\n  });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute an after transition after starting from a persisted state","suites":["delayed transitions"],"updatePoint":{"line":173,"column":78},"line":173,"code":"  it('should execute an after transition after starting from a persisted state', (done) => {\n    const createMyMachine = () =>\n      createMachine({\n        initial: 'A',\n        states: {\n          A: {\n            on: {\n              NEXT: 'B'\n            }\n          },\n          B: {\n            after: {\n              1: 'C'\n            }\n          },\n          C: {\n            type: 'final'\n          }\n        }\n      });\n\n    let service = interpret(createMyMachine()).start();\n\n    const persistedState = State.create(\n      JSON.parse(JSON.stringify(service.state))\n    );\n\n    service = interpret(createMyMachine()).start(persistedState);\n\n    service.send({ type: 'NEXT' });\n\n    service.onDone(() => done());\n  });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should evaluate the expression (function) to determine the delay","suites":["delayed transitions","delay expressions"],"updatePoint":{"line":256,"column":72},"line":256,"code":"    it('should evaluate the expression (function) to determine the delay', () => {\n      const { initialState } = delayExprMachine;\n\n      const sendActions = initialState.actions.filter(\n        (a) => a.type === actionTypes.send\n      );\n\n      expect(sendActions.length).toBe(1);\n\n      expect(sendActions[0].delay).toEqual(1000);\n    });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should evaluate the expression (string) to determine the delay","suites":["delayed transitions","delay expressions"],"updatePoint":{"line":268,"column":70},"line":268,"code":"    it('should evaluate the expression (string) to determine the delay', () => {\n      const { initialState } = delayExprMachine;\n      const activeState = delayExprMachine.transition(initialState, {\n        type: 'ACTIVATE',\n        delay: 500\n      });\n\n      const sendActions = activeState.actions.filter(\n        (a) => a.type === actionTypes.send\n      );\n\n      expect(sendActions.length).toBe(1);\n\n      expect(sendActions[0].delay).toEqual(1000 + 500);\n    });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set delay to undefined if expression not found","suites":["delayed transitions","delay expressions"],"updatePoint":{"line":284,"column":61},"line":284,"code":"    it('should set delay to undefined if expression not found', () => {\n      const { initialState } = delayExprMachine;\n      const activeState = delayExprMachine.transition(initialState, {\n        type: 'NOEXPR',\n        delay: 500\n      });\n\n      const sendActions = activeState.actions.filter(\n        (a) => a.type === actionTypes.send\n      );\n\n      expect(sendActions.length).toBe(1);\n\n      expect(sendActions[0].delay).toEqual(undefined);\n    });","file":"after.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"getConfiguration","suites":["algorithm"],"updatePoint":{"line":72,"column":22},"line":72,"code":"  it('getConfiguration', () => {\n    const prevNodes = testMachine.getStateNodes({\n      b1: {\n        c1: 'd1',\n        c2: {},\n        c3: 'd3'\n      }\n    });\n    const nodes = ['c1', 'd4'].map((id) => testMachine.getStateNodeById(id));\n\n    const c = getConfiguration(prevNodes, nodes);\n\n    expect([...c].map((sn) => sn.id).sort()).toEqual([\n      'a',\n      'b1',\n      'c1',\n      'c2',\n      'c3',\n      'd1',\n      'd4',\n      'e3'\n    ]);\n  });","file":"algorithm.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"applies the assignment to the external state (property assignment)","suites":["assign"],"updatePoint":{"line":99,"column":72},"line":99,"code":"  it('applies the assignment to the external state (property assignment)', () => {\n    const oneState = counterMachine.transition(\n      counterMachine.initialState,\n      'DEC'\n    );\n\n    expect(oneState.value).toEqual('counting');\n    expect(oneState.context).toEqual({ count: -1, foo: 'bar' });\n\n    const twoState = counterMachine.transition(oneState, 'DEC');\n\n    expect(twoState.value).toEqual('counting');\n    expect(twoState.context).toEqual({ count: -2, foo: 'bar' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"applies the assignment to the external state","suites":["assign"],"updatePoint":{"line":114,"column":50},"line":114,"code":"  it('applies the assignment to the external state', () => {\n    const oneState = counterMachine.transition(\n      counterMachine.initialState,\n      'INC'\n    );\n\n    expect(oneState.value).toEqual('counting');\n    expect(oneState.context).toEqual({ count: 1, foo: 'bar' });\n\n    const twoState = counterMachine.transition(oneState, 'INC');\n\n    expect(twoState.value).toEqual('counting');\n    expect(twoState.context).toEqual({ count: 2, foo: 'bar' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"applies the assignment to multiple properties (property assignment)","suites":["assign"],"updatePoint":{"line":129,"column":73},"line":129,"code":"  it('applies the assignment to multiple properties (property assignment)', () => {\n    const nextState = counterMachine.transition(\n      counterMachine.initialState,\n      'WIN_PROP'\n    );\n\n    expect(nextState.context).toEqual({ count: 100, foo: 'win' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"applies the assignment to multiple properties (static)","suites":["assign"],"updatePoint":{"line":138,"column":60},"line":138,"code":"  it('applies the assignment to multiple properties (static)', () => {\n    const nextState = counterMachine.transition(\n      counterMachine.initialState,\n      'WIN_STATIC'\n    );\n\n    expect(nextState.context).toEqual({ count: 100, foo: 'win' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"applies the assignment to multiple properties (static + prop assignment)","suites":["assign"],"updatePoint":{"line":147,"column":78},"line":147,"code":"  it('applies the assignment to multiple properties (static + prop assignment)', () => {\n    const nextState = counterMachine.transition(\n      counterMachine.initialState,\n      'WIN_MIX'\n    );\n\n    expect(nextState.context).toEqual({ count: 100, foo: 'win' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"applies the assignment to multiple properties","suites":["assign"],"updatePoint":{"line":156,"column":51},"line":156,"code":"  it('applies the assignment to multiple properties', () => {\n    const nextState = counterMachine.transition(\n      counterMachine.initialState,\n      'WIN'\n    );\n\n    expect(nextState.context).toEqual({ count: 100, foo: 'win' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"applies the assignment to the explicit external state (property assignment)","suites":["assign"],"updatePoint":{"line":165,"column":81},"line":165,"code":"  it('applies the assignment to the explicit external state (property assignment)', () => {\n    const oneState = counterMachine.transition(\n      counterMachine.initialState,\n      'DEC',\n      { count: 50, foo: 'bar' }\n    );\n\n    expect(oneState.value).toEqual('counting');\n    expect(oneState.context).toEqual({ count: 49, foo: 'bar' });\n\n    const twoState = counterMachine.transition(oneState, 'DEC');\n\n    expect(twoState.value).toEqual('counting');\n    expect(twoState.context).toEqual({ count: 48, foo: 'bar' });\n\n    const threeState = counterMachine.transition(twoState, 'DEC', {\n      count: 100,\n      foo: 'bar'\n    });\n\n    expect(threeState.value).toEqual('counting');\n    expect(threeState.context).toEqual({ count: 99, foo: 'bar' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"applies the assignment to the explicit external state","suites":["assign"],"updatePoint":{"line":189,"column":59},"line":189,"code":"  it('applies the assignment to the explicit external state', () => {\n    const oneState = counterMachine.transition(\n      counterMachine.initialState,\n      'INC',\n      { count: 50, foo: 'bar' }\n    );\n\n    expect(oneState.value).toEqual('counting');\n    expect(oneState.context).toEqual({ count: 51, foo: 'bar' });\n\n    const twoState = counterMachine.transition(oneState, 'INC');\n\n    expect(twoState.value).toEqual('counting');\n    expect(twoState.context).toEqual({ count: 52, foo: 'bar' });\n\n    const threeState = counterMachine.transition(twoState, 'INC', {\n      count: 102,\n      foo: 'bar'\n    });\n\n    expect(threeState.value).toEqual('counting');\n    expect(threeState.context).toEqual({ count: 103, foo: 'bar' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should maintain state after unhandled event","suites":["assign"],"updatePoint":{"line":213,"column":49},"line":213,"code":"  it('should maintain state after unhandled event', () => {\n    const { initialState } = counterMachine;\n\n    const nextState = counterMachine.transition(initialState, 'FAKE_EVENT');\n\n    expect(nextState.context).toBeDefined();\n    expect(nextState.context).toEqual({ count: 0, foo: 'bar' });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"sets undefined properties","suites":["assign"],"updatePoint":{"line":222,"column":31},"line":222,"code":"  it('sets undefined properties', () => {\n    const { initialState } = counterMachine;\n\n    const nextState = counterMachine.transition(initialState, 'SET_MAYBE');\n\n    expect(nextState.context.maybe).toBeDefined();\n    expect(nextState.context).toEqual({\n      count: 0,\n      foo: 'bar',\n      maybe: 'defined'\n    });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can assign from event","suites":["assign"],"updatePoint":{"line":235,"column":27},"line":235,"code":"  it('can assign from event', () => {\n    const machine = createMachine<\n      { count: number },\n      { type: 'INC'; value: number }\n    >({\n      initial: 'active',\n      context: {\n        count: 0\n      },\n      states: {\n        active: {\n          on: {\n            INC: {\n              actions: assign({\n                count: (_, event) => event.value\n              })\n            }\n          }\n        }\n      }\n    });\n\n    const nextState = machine.transition(undefined, { type: 'INC', value: 30 });\n\n    expect(nextState.context.count).toEqual(30);\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide the state in regular transitions (prop assigner)","suites":["assign meta"],"updatePoint":{"line":303,"column":69},"line":303,"code":"  it('should provide the state in regular transitions (prop assigner)', () => {\n    const { initialState } = machine;\n\n    const nextState = machine.transition(initialState, 'NEXT');\n\n    expect(nextState.context).toEqual({ count: 3 });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide the state in regular transitions (assigner)","suites":["assign meta"],"updatePoint":{"line":311,"column":64},"line":311,"code":"  it('should provide the state in regular transitions (assigner)', () => {\n    const { initialState } = machine;\n\n    const nextState = machine.transition(initialState, 'NEXT_FN');\n\n    expect(nextState.context).toEqual({ count: 3 });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide the assign action","suites":["assign meta"],"updatePoint":{"line":319,"column":38},"line":319,"code":"  it('should provide the assign action', () => {\n    const { initialState } = machine;\n\n    const nextState = machine.transition(initialState, 'NEXT_ASSIGNER');\n\n    expect(nextState.context).toEqual({ count: 5 });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not provide the state from initial state","suites":["assign meta"],"updatePoint":{"line":327,"column":53},"line":327,"code":"  it('should not provide the state from initial state', () => {\n    const { initialState } = machine;\n\n    expect(initialState.context).toEqual({ count: 1 });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide meta._event to assigner","suites":["assign meta"],"updatePoint":{"line":333,"column":44},"line":333,"code":"  it('should provide meta._event to assigner', () => {\n    interface Ctx {\n      eventLog: Array<{ event: string; origin: string | undefined }>;\n    }\n\n    const assignEventLog = assign<Ctx>((ctx, event, meta) => ({\n      eventLog: ctx.eventLog.concat({\n        event: event.type,\n        origin: meta._event.origin\n      })\n    }));\n\n    const childMachine = Machine({\n      initial: 'bar',\n      states: {\n        bar: {}\n      },\n      on: {\n        PING: {\n          actions: [sendParent('PONG')]\n        }\n      }\n    });\n\n    const parentMachine = Machine<Ctx>({\n      initial: 'foo',\n      context: {\n        eventLog: []\n      },\n      states: {\n        foo: {\n          invoke: {\n            id: 'child',\n            src: childMachine\n          }\n        }\n      },\n      on: {\n        PING_CHILD: {\n          actions: [send('PING', { to: 'child' }), assignEventLog]\n        },\n        '*': {\n          actions: [assignEventLog]\n        }\n      }\n    });\n\n    let state: any;\n\n    const service = interpret(parentMachine)\n      .onTransition((s) => {\n        state = s;\n      })\n      .start();\n\n    service.send('PING_CHILD');\n    service.send('PING_CHILD');\n\n    expect(state.context).toEqual({\n      eventLog: [\n        { event: 'PING_CHILD', origin: undefined },\n        { event: 'PONG', origin: expect.stringMatching(/.+/) },\n        { event: 'PING_CHILD', origin: undefined },\n        { event: 'PONG', origin: expect.stringMatching(/.+/) }\n      ]\n    });\n  });","file":"assign.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit all substates when superstates exits (A_EVENT)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":97,"column":66},"line":97,"code":"    it('should exit all substates when superstates exits (A_EVENT)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'A_EVENT')\n        .actions.map((a) => a.type);\n      const expected = ['EXIT_D', 'EXIT_C', 'EXIT_B', 'EXIT_A'];\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit substates and superstates when exiting (B_EVENT)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":105,"column":68},"line":105,"code":"    it('should exit substates and superstates when exiting (B_EVENT)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'B_EVENT')\n        .actions.map((a) => a.type);\n      const expected = ['EXIT_D', 'EXIT_C', 'EXIT_B', 'EXIT_A'];\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit substates and superstates when exiting (C_EVENT)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":113,"column":68},"line":113,"code":"    it('should exit substates and superstates when exiting (C_EVENT)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'C_EVENT')\n        .actions.map((a) => a.type);\n      const expected = ['EXIT_D', 'EXIT_C', 'EXIT_B', 'EXIT_A'];\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit superstates when exiting (D_EVENT)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":121,"column":54},"line":121,"code":"    it('should exit superstates when exiting (D_EVENT)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'D_EVENT')\n        .actions.map((a) => a.type);\n      const expected = ['EXIT_D', 'EXIT_C', 'EXIT_B', 'EXIT_A'];\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit substate when machine handles event (MACHINE_EVENT)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":129,"column":71},"line":129,"code":"    it('should exit substate when machine handles event (MACHINE_EVENT)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'MACHINE_EVENT')\n        .actions.map((a) => a.type);\n      const expected = ['EXIT_D', 'EXIT_C', 'EXIT_B', 'EXIT_A'];\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit deep and enter deep (A_S)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":148,"column":45},"line":148,"code":"    it('should exit deep and enter deep (A_S)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'A_S')\n        .actions.map((a) => a.type);\n      const expected = DBCAPQRS;\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit deep and enter deep (D_P)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":156,"column":45},"line":156,"code":"    it('should exit deep and enter deep (D_P)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'D_P')\n        .actions.map((a) => a.type);\n      const expected = DBCAPQRS;\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit deep and enter deep (A_P)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":164,"column":45},"line":164,"code":"    it('should exit deep and enter deep (A_P)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'A_P')\n        .actions.map((a) => a.type);\n      const expected = DBCAPQRS;\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exit deep and enter deep (D_S)","suites":["deep transitions","exiting super/substates"],"updatePoint":{"line":172,"column":45},"line":172,"code":"    it('should exit deep and enter deep (D_S)', () => {\n      const actual = deepMachine\n        .transition(deepMachine.initialState, 'D_S')\n        .actions.map((a) => a.type);\n      const expected = DBCAPQRS;\n      expect(actual).toEqual(expected);\n    });","file":"deep.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide invoke definitions","suites":["definition"],"updatePoint":{"line":4,"column":39},"line":4,"code":"  it('should provide invoke definitions', () => {\n    const invokeMachine = Machine({\n      id: 'invoke',\n      invoke: [{ src: 'foo' }, { src: 'bar' }],\n      initial: 'idle',\n      states: {\n        idle: {}\n      }\n    });\n\n    expect(invokeMachine.definition.invoke.length).toBe(2);\n  });","file":"definition.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the initial state value","suites":["deterministic machine","machine.initialState"],"updatePoint":{"line":93,"column":45},"line":93,"code":"    it('should return the initial state value', () => {\n      expect(lightMachine.initialState.value).toEqual('green');\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not have any history","suites":["deterministic machine","machine.initialState"],"updatePoint":{"line":97,"column":35},"line":97,"code":"    it('should not have any history', () => {\n      expect(lightMachine.initialState.history).not.toBeDefined();\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition states based on string event","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":103,"column":63},"line":103,"code":"    it('should properly transition states based on string event', () => {\n      expect(lightMachine.transition('green', 'TIMER').value).toEqual('yellow');\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition states based on event-like object","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":107,"column":68},"line":107,"code":"    it('should properly transition states based on event-like object', () => {\n      const event = {\n        type: 'TIMER'\n      };\n\n      expect(lightMachine.transition('green', event).value).toEqual('yellow');\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not transition states for illegal transitions","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":115,"column":60},"line":115,"code":"    it('should not transition states for illegal transitions', () => {\n      expect(lightMachine.transition('green', 'FAKE').value).toEqual('green');\n      expect(lightMachine.transition('green', 'FAKE').actions).toHaveLength(0);\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an error if not given an event","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":120,"column":51},"line":120,"code":"    it('should throw an error if not given an event', () => {\n      expect(() => lightMachine.transition('red', undefined as any)).toThrow();\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition to nested states as target","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":124,"column":52},"line":124,"code":"    it('should transition to nested states as target', () => {\n      expect(testMachine.transition('a', 'T').value).toEqual({ b: 'b1' });\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an error for transitions from invalid states","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":128,"column":65},"line":128,"code":"    it('should throw an error for transitions from invalid states', () => {\n      expect(() => testMachine.transition('fake', 'T')).toThrow();\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an error for transitions from invalid substates","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":136,"column":68},"line":136,"code":"    it('should throw an error for transitions from invalid substates', () => {\n      expect(() => testMachine.transition('a.fake', 'T')).toThrow();\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should use the machine.initialState when an undefined state is given","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":140,"column":76},"line":140,"code":"    it('should use the machine.initialState when an undefined state is given', () => {\n      expect(lightMachine.transition(undefined, 'TIMER').value).toEqual(\n        'yellow'\n      );\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should use the machine.initialState when an undefined state is given (unhandled event)","suites":["deterministic machine","machine.transition()"],"updatePoint":{"line":146,"column":94},"line":146,"code":"    it('should use the machine.initialState when an undefined state is given (unhandled event)', () => {\n      expect(lightMachine.transition(undefined, 'TIMER').value).toEqual(\n        'yellow'\n      );\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition a nested state","suites":["deterministic machine","machine.transition() with nested states"],"updatePoint":{"line":154,"column":49},"line":154,"code":"    it('should properly transition a nested state', () => {\n      expect(\n        lightMachine.transition('red.walk', 'PED_COUNTDOWN').value\n      ).toEqual({ red: 'wait' });\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition from initial nested states","suites":["deterministic machine","machine.transition() with nested states"],"updatePoint":{"line":160,"column":52},"line":160,"code":"    it('should transition from initial nested states', () => {\n      expect(lightMachine.transition('red', 'PED_COUNTDOWN').value).toEqual({\n        red: 'wait'\n      });\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition from deep initial nested states","suites":["deterministic machine","machine.transition() with nested states"],"updatePoint":{"line":166,"column":57},"line":166,"code":"    it('should transition from deep initial nested states', () => {\n      expect(lightMachine.transition('red', 'PED_COUNTDOWN').value).toEqual({\n        red: 'wait'\n      });\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should bubble up events that nested states cannot handle","suites":["deterministic machine","machine.transition() with nested states"],"updatePoint":{"line":172,"column":64},"line":172,"code":"    it('should bubble up events that nested states cannot handle', () => {\n      expect(lightMachine.transition('red.stop', 'TIMER').value).toEqual(\n        'green'\n      );\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not transition from illegal events","suites":["deterministic machine","machine.transition() with nested states"],"updatePoint":{"line":178,"column":49},"line":178,"code":"    it('should not transition from illegal events', () => {\n      expect(lightMachine.transition('red.walk', 'FAKE').value).toEqual({\n        red: 'walk'\n      });\n      expect(lightMachine.transition('red.walk', 'FAKE').actions).toHaveLength(\n        0\n      );\n\n      expect(deepMachine.transition('a1', 'FAKE').value).toEqual({\n        a1: { a2: { a3: 'a4' } }\n      });\n      expect(deepMachine.transition('a1', 'FAKE').actions).toHaveLength(0);\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition to the deepest initial state","suites":["deterministic machine","machine.transition() with nested states"],"updatePoint":{"line":192,"column":54},"line":192,"code":"    it('should transition to the deepest initial state', () => {\n      expect(lightMachine.transition('yellow', 'TIMER').value).toEqual({\n        red: 'walk'\n      });\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the equivalent state if no transition occurs","suites":["deterministic machine","machine.transition() with nested states"],"updatePoint":{"line":198,"column":66},"line":198,"code":"    it('should return the equivalent state if no transition occurs', () => {\n      const initialState = lightMachine.transition(\n        lightMachine.initialState,\n        'NOTHING'\n      );\n      const nextState = lightMachine.transition(initialState, 'NOTHING');\n\n      expect(initialState.value).toEqual(nextState.value);\n      expect(nextState.changed).toBe(false);\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition based on an event","suites":["deterministic machine","machine.transition() with array `.on` configs"],"updatePoint":{"line":211,"column":52},"line":211,"code":"    it('should properly transition based on an event', () => {\n      const machine = Machine({\n        initial: 'a',\n        states: {\n          a: {\n            on: [{ event: 'NEXT', target: 'pass' }]\n          },\n          pass: {}\n        }\n      });\n      expect(machine.transition('a', 'NEXT').value).toBe('pass');\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with substate nodes that have the same key","suites":["deterministic machine","state key names"],"updatePoint":{"line":241,"column":62},"line":241,"code":"    it('should work with substate nodes that have the same key', () => {\n      expect(machine.transition(machine.initialState, 'NEXT').value).toEqual(\n        'test'\n      );\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"undefined transitions should forbid events","suites":["deterministic machine","forbidden events"],"updatePoint":{"line":249,"column":50},"line":249,"code":"    it('undefined transitions should forbid events', () => {\n      const walkState = lightMachine.transition('red.walk', 'TIMER');\n\n      expect(walkState.value).toEqual({ red: 'walk' });\n    });","file":"deterministic.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have the origin (id) from the sending machine service","suites":["SCXML events"],"updatePoint":{"line":5,"column":66},"line":5,"code":"  it('should have the origin (id) from the sending machine service', (done) => {\n    const childMachine = Machine({\n      initial: 'active',\n      states: {\n        active: {\n          entry: sendParent('EVENT')\n        }\n      }\n    });\n\n    const parentMachine = Machine({\n      initial: 'active',\n      states: {\n        active: {\n          invoke: {\n            id: 'child',\n            src: childMachine\n          },\n          on: {\n            EVENT: {\n              target: 'success',\n              cond: (_: any, __: any, { _event }: any) => {\n                return !!(_event.origin && _event.origin.length > 0);\n              }\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    interpret(parentMachine)\n      .onDone(() => done())\n      .start();\n  });","file":"event.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have the origin (id) from the sending callback service","suites":["SCXML events"],"updatePoint":{"line":43,"column":67},"line":43,"code":"  it('should have the origin (id) from the sending callback service', () => {\n    const machine = Machine<{ childOrigin?: string }>({\n      initial: 'active',\n      context: {},\n      states: {\n        active: {\n          invoke: {\n            id: 'callback_child',\n            src: () => (send) => send({ type: 'EVENT' })\n          },\n          on: {\n            EVENT: {\n              target: 'success',\n              actions: assign({\n                childOrigin: (_, __, { _event }) => _event.origin\n              })\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    expect(service.state.context.childOrigin).toBe('callback_child');\n  });","file":"event.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"respond() should be able to respond to sender","suites":["SCXML events"],"updatePoint":{"line":73,"column":51},"line":73,"code":"  it('respond() should be able to respond to sender', (done) => {\n    const authServerMachine = Machine({\n      initial: 'waitingForCode',\n      states: {\n        waitingForCode: {\n          on: {\n            CODE: {\n              actions: respond('TOKEN', {\n                delay: 10\n              })\n            }\n          }\n        }\n      }\n    });\n\n    const authClientMachine = Machine({\n      initial: 'idle',\n      states: {\n        idle: {\n          on: { AUTH: 'authorizing' }\n        },\n        authorizing: {\n          invoke: {\n            id: 'auth-server',\n            src: authServerMachine\n          },\n          entry: send('CODE', {\n            to: 'auth-server'\n          }),\n          on: {\n            TOKEN: 'authorized'\n          }\n        },\n        authorized: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(authClientMachine)\n      .onDone(() => done())\n      .start();\n\n    service.send('AUTH');\n  });","file":"event.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"only take the transition of the most inner matching event","suites":["nested transitions"],"updatePoint":{"line":177,"column":63},"line":177,"code":"  it('only take the transition of the most inner matching event', () => {\n    const password = 'xstate123';\n    const state = authMachine.transition(authMachine.initialState, {\n      type: 'changePassword',\n      password\n    });\n\n    expect(state.value).toEqual({ passwordField: 'hidden' });\n    expect(state.context).toEqual({ password, email: '' });\n  });","file":"event.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should fallback to using wildcard transition definition (if specified)","suites":["event descriptors"],"updatePoint":{"line":4,"column":76},"line":4,"code":"  it('should fallback to using wildcard transition definition (if specified)', () => {\n    const machine = Machine({\n      initial: 'A',\n      states: {\n        A: {\n          on: {\n            FOO: 'B',\n            '*': 'C'\n          }\n        },\n        B: {},\n        C: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send('BAR');\n    expect(service.state.value).toBe('C');\n  });","file":"eventDescriptors.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not use wildcard transition over explicit one when using object `.on` config - even if wildcard comes first","suites":["event descriptors"],"updatePoint":{"line":24,"column":120},"line":24,"code":"  it('should not use wildcard transition over explicit one when using object `.on` config - even if wildcard comes first', () => {\n    const machine = Machine({\n      initial: 'A',\n      states: {\n        A: {\n          on: {\n            '*': 'fail',\n            NEXT: 'pass'\n          }\n        },\n        fail: {},\n        pass: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send('NEXT');\n    expect(service.state.value).toBe('pass');\n  });","file":"eventDescriptors.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should select wildcard over explicit event type for array `.on` config (according to document order)","suites":["event descriptors"],"updatePoint":{"line":44,"column":106},"line":44,"code":"  it('should select wildcard over explicit event type for array `.on` config (according to document order)', () => {\n    const machine = Machine({\n      initial: 'A',\n      states: {\n        A: {\n          on: [\n            { event: '*', target: 'pass' },\n            { event: 'NEXT', target: 'fail' }\n          ]\n        },\n        fail: {},\n        pass: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send('NEXT');\n    expect(service.state.value).toBe('pass');\n  });","file":"eventDescriptors.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go from  to  on ","suites":["Example 6.17"],"updatePoint":{"line":59,"column":25},"line":57,"code":"      it(`should go from ${fromState} to ${JSON.stringify(\n        toState\n      )} on ${eventTypes}`, () => {\n        const resultState = testMultiTransition(machine, fromState, eventTypes);\n\n        expect(resultState.value).toEqual(toState);\n      });","file":"examples/6.17.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go from  to  on ","suites":["Jump to ID"],"updatePoint":{"line":124,"column":25},"line":122,"code":"      it(`should go from ${fromState} to ${JSON.stringify(\n        toState\n      )} on ${eventTypes}`, () => {\n        const resultState = testMultiTransition(machine, fromState, eventTypes);\n\n        expect(resultState.value).toEqual(toState);\n      });","file":"examples/6.17.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should respect the history mechanism","suites":["Example 6.8"],"updatePoint":{"line":70,"column":42},"line":70,"code":"  it('should respect the history mechanism', () => {\n    const stateC = machine.transition('A.B', '1');\n    const stateF = machine.transition(stateC, '6');\n    const stateActual = machine.transition(stateF, '5');\n\n    expect(stateActual.value).toEqual({ A: 'C' });\n  });","file":"examples/6.8.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should emit the \"done.state.final.red\" event when all nested states are in their final states","suites":["final states"],"updatePoint":{"line":69,"column":99},"line":69,"code":"  it('should emit the \"done.state.final.red\" event when all nested states are in their final states', () => {\n    const redState = finalMachine.transition('yellow', 'TIMER');\n    expect(redState.value).toEqual({\n      red: {\n        crosswalk1: 'walk',\n        crosswalk2: 'walk'\n      }\n    });\n    const waitState = finalMachine.transition(redState, 'PED_WAIT');\n    expect(waitState.value).toEqual({\n      red: {\n        crosswalk1: 'wait',\n        crosswalk2: 'wait'\n      }\n    });\n    const stopState = finalMachine.transition(waitState, 'PED_STOP');\n    expect(stopState.value).toEqual({\n      red: {\n        crosswalk1: 'stop',\n        crosswalk2: 'stop'\n      }\n    });\n\n    expect(stopState.actions).toEqual([\n      { type: 'stopCrosswalk1', exec: undefined }\n    ]);\n\n    const stopState2 = finalMachine.transition(stopState, 'PED_STOP');\n\n    expect(stopState2.actions).toEqual([\n      { type: 'stopCrosswalk2', exec: undefined },\n      { type: 'prepareGreenLight', exec: undefined }\n    ]);\n\n    const greenState = finalMachine.transition(stopState, 'TIMER');\n    expect(greenState.actions).toHaveLength(0);\n  });","file":"final.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute final child state actions first","suites":["final states"],"updatePoint":{"line":107,"column":52},"line":107,"code":"  it('should execute final child state actions first', () => {\n    const nestedFinalMachine = Machine({\n      id: 'nestedFinal',\n      initial: 'foo',\n      states: {\n        foo: {\n          initial: 'bar',\n          onDone: { actions: 'fooAction' },\n          states: {\n            bar: {\n              initial: 'baz',\n              onDone: 'barFinal',\n              states: {\n                baz: {\n                  type: 'final',\n                  onEntry: 'bazAction'\n                }\n              }\n            },\n            barFinal: {\n              type: 'final',\n              onDone: { actions: 'barAction' }\n            }\n          }\n        }\n      }\n    });\n\n    const { initialState } = nestedFinalMachine;\n\n    expect(initialState.actions.map((a) => a.type)).toEqual([\n      'bazAction',\n      'barAction',\n      'fooAction'\n    ]);\n  });","file":"final.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call data expressions on nested final nodes","suites":["final states"],"updatePoint":{"line":144,"column":56},"line":144,"code":"  it('should call data expressions on nested final nodes', (done) => {\n    interface Ctx {\n      revealedSecret?: string;\n    }\n\n    const machine = Machine<Ctx>({\n      initial: 'secret',\n      context: {\n        revealedSecret: undefined\n      },\n      states: {\n        secret: {\n          initial: 'wait',\n          states: {\n            wait: {\n              on: {\n                REQUEST_SECRET: 'reveal'\n              }\n            },\n            reveal: {\n              type: 'final',\n              data: {\n                secret: () => 'the secret'\n              }\n            }\n          },\n          onDone: {\n            target: 'success',\n            actions: assign<Ctx, AnyEventObject>({\n              revealedSecret: (_, event) => {\n                return event.data.secret;\n              }\n            })\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    let _context: any;\n\n    const service = interpret(machine)\n      .onTransition((state) => (_context = state.context))\n      .onDone(() => {\n        expect(_context).toEqual({ revealedSecret: 'the secret' });\n        done();\n      })\n      .start();\n\n    service.send('REQUEST_SECRET');\n  });","file":"final.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should only call data expression once when entering root's final state","suites":["final states"],"updatePoint":{"line":198,"column":76},"line":198,"code":"  it(\"should only call data expression once when entering root's final state\", () => {\n    const spy = jest.fn();\n    const machine = Machine({\n      initial: 'start',\n      states: {\n        start: {\n          on: {\n            FINISH: 'end'\n          }\n        },\n        end: {\n          type: 'final',\n          data: spy\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send({ type: 'FINISH', value: 1 });\n    expect(spy).toBeCalledTimes(1);\n  });","file":"final.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition only if condition is met","suites":["guard conditions"],"updatePoint":{"line":70,"column":48},"line":70,"code":"  it('should transition only if condition is met', () => {\n    expect(\n      lightMachine.transition('green', 'TIMER', {\n        elapsed: 50\n      }).value\n    ).toEqual('green');\n\n    expect(\n      lightMachine.transition('green', 'TIMER', {\n        elapsed: 120\n      }).value\n    ).toEqual('yellow');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition if condition based on event is met","suites":["guard conditions"],"updatePoint":{"line":84,"column":58},"line":84,"code":"  it('should transition if condition based on event is met', () => {\n    expect(\n      lightMachine.transition('green', {\n        type: 'EMERGENCY',\n        isEmergency: true\n      }).value\n    ).toEqual('red');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not transition if condition based on event is not met","suites":["guard conditions"],"updatePoint":{"line":93,"column":66},"line":93,"code":"  it('should not transition if condition based on event is not met', () => {\n    expect(\n      lightMachine.transition('green', {\n        type: 'EMERGENCY'\n      }).value\n    ).toEqual('green');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not transition if no condition is met","suites":["guard conditions"],"updatePoint":{"line":101,"column":50},"line":101,"code":"  it('should not transition if no condition is met', () => {\n    const nextState = lightMachine.transition('green', 'TIMER', {\n      elapsed: 9000\n    });\n    expect(nextState.value).toEqual('green');\n    expect(nextState.actions).toEqual([]);\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with defined string transitions","suites":["guard conditions"],"updatePoint":{"line":109,"column":49},"line":109,"code":"  it('should work with defined string transitions', () => {\n    const nextState = lightMachine.transition('yellow', 'TIMER', {\n      elapsed: 150\n    });\n    expect(nextState.value).toEqual('red');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with guard objects","suites":["guard conditions"],"updatePoint":{"line":116,"column":36},"line":116,"code":"  it('should work with guard objects', () => {\n    const nextState = lightMachine.transition('yellow', 'TIMER_COND_OBJ', {\n      elapsed: 150\n    });\n    expect(nextState.value).toEqual('red');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with defined string transitions (condition not met)","suites":["guard conditions"],"updatePoint":{"line":123,"column":69},"line":123,"code":"  it('should work with defined string transitions (condition not met)', () => {\n    const nextState = lightMachine.transition('yellow', 'TIMER', {\n      elapsed: 10\n    });\n    expect(nextState.value).toEqual('yellow');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw if string transition is not defined","suites":["guard conditions"],"updatePoint":{"line":130,"column":54},"line":130,"code":"  it('should throw if string transition is not defined', () => {\n    expect(() => lightMachine.transition('red', 'BAD_COND')).toThrow();\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should guard against transition","suites":["guard conditions"],"updatePoint":{"line":210,"column":37},"line":210,"code":"  it('should guard against transition', () => {\n    expect(machine.transition({ A: 'A2', B: 'B0' }, 'T1').value).toEqual({\n      A: 'A2',\n      B: 'B0'\n    });\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow a matching transition","suites":["guard conditions"],"updatePoint":{"line":217,"column":40},"line":217,"code":"  it('should allow a matching transition', () => {\n    expect(machine.transition({ A: 'A2', B: 'B0' }, 'T2').value).toEqual({\n      A: 'A2',\n      B: 'B2'\n    });\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should check guards with interim states","suites":["guard conditions"],"updatePoint":{"line":224,"column":45},"line":224,"code":"  it('should check guards with interim states', () => {\n    expect(machine.transition({ A: 'A2', B: 'B0' }, 'A').value).toEqual({\n      A: 'A5',\n      B: 'B4'\n    });\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to check source state tags when checking","suites":["guard conditions"],"updatePoint":{"line":231,"column":61},"line":231,"code":"  it('should be able to check source state tags when checking', () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          on: {\n            MACRO: 'b'\n          }\n        },\n        b: {\n          entry: actions.raise('MICRO'),\n          tags: 'theTag',\n          on: {\n            MICRO: {\n              cond: (_ctx: any, _event: any, { state }: any) =>\n                state.hasTag('theTag'),\n              target: 'c'\n            }\n          }\n        },\n        c: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send('MACRO');\n\n    expect(service.state.value).toBe('c');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should evaluate custom guards","suites":["custom guards"],"updatePoint":{"line":303,"column":35},"line":303,"code":"  it('should evaluate custom guards', () => {\n    const passState = machine.transition(machine.initialState, {\n      type: 'EVENT',\n      value: 4\n    });\n\n    expect(passState.value).toEqual('active');\n\n    const failState = machine.transition(machine.initialState, {\n      type: 'EVENT',\n      value: 3\n    });\n\n    expect(failState.value).toEqual('inactive');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"guard predicates should be able to be referenced from a string","suites":["referencing guards"],"updatePoint":{"line":357,"column":68},"line":357,"code":"  it('guard predicates should be able to be referenced from a string', () => {\n    expect(stringGuard.cond!.predicate).toBeDefined();\n    expect(stringGuard.cond!.name).toEqual('string');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"guard predicates should be able to be referenced from a function","suites":["referencing guards"],"updatePoint":{"line":362,"column":70},"line":362,"code":"  it('guard predicates should be able to be referenced from a function', () => {\n    expect(functionGuard.cond!.predicate).toBeDefined();\n    expect(functionGuard.cond!.name).toEqual('guardFn');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"guard predicates should be able to be referenced from an object","suites":["referencing guards"],"updatePoint":{"line":367,"column":69},"line":367,"code":"  it('guard predicates should be able to be referenced from an object', () => {\n    expect(objectGuard.cond).toBeDefined();\n    expect(objectGuard.cond).toEqual({\n      type: 'object',\n      foo: 'bar'\n    });\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw for guards with missing predicates","suites":["referencing guards"],"updatePoint":{"line":375,"column":53},"line":375,"code":"  it('should throw for guards with missing predicates', () => {\n    const machine = Machine({\n      id: 'invalid-predicate',\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            EVENT: { target: 'inactive', cond: 'missing-predicate' }\n          }\n        },\n        inactive: {}\n      }\n    });\n\n    expect(() => {\n      machine.transition(machine.initialState, 'EVENT');\n    }).toThrow();\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow for a fallback target to be a simple string","suites":["guards - other"],"updatePoint":{"line":396,"column":62},"line":396,"code":"  it('should allow for a fallback target to be a simple string', () => {\n    const machine = Machine({\n      initial: 'a',\n      states: {\n        a: {\n          on: {\n            EVENT: [{ target: 'b', cond: () => false }, 'c']\n          }\n        },\n        b: {},\n        c: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send('EVENT');\n\n    expect(service.state.value).toBe('c');\n  });","file":"guards.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the most recently visited state","suites":["history states"],"updatePoint":{"line":37,"column":50},"line":37,"code":"  it('should go to the most recently visited state', () => {\n    const onSecondState = historyMachine.transition('on', 'SWITCH');\n    const offState = historyMachine.transition(onSecondState, 'POWER');\n\n    expect(historyMachine.transition(offState, 'POWER').value).toEqual({\n      on: 'second'\n    });\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the most recently visited state (explicit)","suites":["history states"],"updatePoint":{"line":46,"column":61},"line":46,"code":"  it('should go to the most recently visited state (explicit)', () => {\n    const onSecondState = historyMachine.transition('on', 'SWITCH');\n    const offState = historyMachine.transition(onSecondState, 'H_POWER');\n\n    expect(historyMachine.transition(offState, 'H_POWER').value).toEqual({\n      on: 'second'\n    });\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the initial state when no history present","suites":["history states"],"updatePoint":{"line":55,"column":60},"line":55,"code":"  it('should go to the initial state when no history present', () => {\n    expect(historyMachine.transition('off', 'POWER').value).toEqual({\n      on: 'first'\n    });\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the initial state when no history present (explicit)","suites":["history states"],"updatePoint":{"line":61,"column":71},"line":61,"code":"  it('should go to the initial state when no history present (explicit)', () => {\n    expect(historyMachine.transition('off', 'H_POWER').value).toEqual({\n      on: 'first'\n    });\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should dispose of previous histories","suites":["history states"],"updatePoint":{"line":67,"column":42},"line":67,"code":"  it('should dispose of previous histories', () => {\n    const onSecondState = historyMachine.transition('on', 'SWITCH');\n    const offState = historyMachine.transition(onSecondState, 'H_POWER');\n    const onState = historyMachine.transition(offState, 'H_POWER');\n    const nextState = historyMachine.transition(onState, 'H_POWER');\n    expect(nextState.history!.history).not.toBeDefined();\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the most recently visited state by a transient transition","suites":["history states"],"updatePoint":{"line":75,"column":76},"line":75,"code":"  it('should go to the most recently visited state by a transient transition', () => {\n    const machine = createMachine({\n      initial: 'idle',\n      states: {\n        idle: {\n          id: 'idle',\n          initial: 'absent',\n          states: {\n            absent: {\n              on: {\n                DEPLOY: '#deploy'\n              }\n            },\n            present: {\n              on: {\n                DEPLOY: '#deploy',\n                DESTROY: '#destroy'\n              }\n            },\n            hist: {\n              type: 'history'\n            }\n          }\n        },\n        deploy: {\n          id: 'deploy',\n          on: {\n            SUCCESS: 'idle.present',\n            FAILURE: 'idle.hist'\n          }\n        },\n        destroy: {\n          id: 'destroy',\n          always: [{ target: 'idle.absent' }]\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    service.send('DEPLOY');\n    service.send('SUCCESS');\n    service.send('DESTROY');\n    service.send('DEPLOY');\n    service.send('FAILURE');\n\n    expect(service.state.value).toEqual({ idle: 'absent' });\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the shallow history","suites":["deep history states","history"],"updatePoint":{"line":179,"column":40},"line":179,"code":"    it('should go to the shallow history', () => {\n      // on.second.B.P -> off\n      const stateOff = historyMachine.transition(state2BP, 'POWER');\n      expect(historyMachine.transition(stateOff, 'POWER').value).toEqual({\n        on: { second: 'A' }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the deep history (explicit)","suites":["deep history states","history"],"updatePoint":{"line":187,"column":48},"line":187,"code":"    it('should go to the deep history (explicit)', () => {\n      // on.second.B.P -> off\n      const stateOff = historyMachine.transition(state2BP, 'POWER');\n      expect(historyMachine.transition(stateOff, 'DEEP_POWER').value).toEqual({\n        on: { second: { B: 'P' } }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the deepest history","suites":["deep history states","history"],"updatePoint":{"line":195,"column":40},"line":195,"code":"    it('should go to the deepest history', () => {\n      // on.second.B.Q -> off\n      const stateOff = historyMachine.transition(state2BQ, 'POWER');\n      expect(historyMachine.transition(stateOff, 'DEEP_POWER').value).toEqual({\n        on: { second: { B: 'Q' } }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should ignore parallel state history","suites":["parallel history states","history"],"updatePoint":{"line":298,"column":44},"line":298,"code":"    it('should ignore parallel state history', () => {\n      const stateOff = historyMachine.transition(stateACDKL, 'POWER');\n      expect(historyMachine.transition(stateOff, 'POWER').value).toEqual({\n        on: { A: 'B', K: 'L' }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should remember first level state history","suites":["parallel history states","history"],"updatePoint":{"line":305,"column":49},"line":305,"code":"    it('should remember first level state history', () => {\n      const stateOff = historyMachine.transition(stateACDKL, 'POWER');\n      expect(historyMachine.transition(stateOff, 'DEEP_POWER').value).toEqual({\n        on: { A: { C: 'D' }, K: 'L' }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should re-enter each regions of parallel state correctly","suites":["parallel history states","history"],"updatePoint":{"line":312,"column":64},"line":312,"code":"    it('should re-enter each regions of parallel state correctly', () => {\n      const stateOff = historyMachine.transition(stateACEKMO, 'POWER');\n      expect(historyMachine.transition(stateOff, 'DEEP_POWER').value).toEqual({\n        on: { A: { C: 'E' }, K: { M: 'O' } }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should re-enter multiple history states","suites":["parallel history states","history"],"updatePoint":{"line":319,"column":47},"line":319,"code":"    it('should re-enter multiple history states', () => {\n      const stateOff = historyMachine.transition(stateACEKMO, 'POWER');\n      expect(\n        historyMachine.transition(stateOff, 'PARALLEL_HISTORY').value\n      ).toEqual({\n        on: { A: { C: 'D' }, K: { M: 'N' } }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should re-enter a parallel with partial history","suites":["parallel history states","history"],"updatePoint":{"line":328,"column":55},"line":328,"code":"    it('should re-enter a parallel with partial history', () => {\n      const stateOff = historyMachine.transition(stateACEKMO, 'POWER');\n      expect(\n        historyMachine.transition(stateOff, 'PARALLEL_SOME_HISTORY').value\n      ).toEqual({\n        on: { A: { C: 'D' }, K: { M: 'N' } }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should re-enter a parallel with full history","suites":["parallel history states","history"],"updatePoint":{"line":337,"column":52},"line":337,"code":"    it('should re-enter a parallel with full history', () => {\n      const stateOff = historyMachine.transition(stateACEKMO, 'POWER');\n      expect(\n        historyMachine.transition(stateOff, 'PARALLEL_DEEP_HISTORY').value\n      ).toEqual({\n        on: { A: { C: 'E' }, K: { M: 'O' } }\n      });\n    });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have history on transient transitions","suites":["transient history"],"updatePoint":{"line":363,"column":50},"line":363,"code":"  it('should have history on transient transitions', () => {\n    const nextState = transientMachine.transition('A', 'EVENT');\n    expect(nextState.value).toEqual('C');\n    expect(nextState.history).toBeDefined();\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition internally to the most recently visited state","suites":["internal transition with history"],"updatePoint":{"line":404,"column":69},"line":404,"code":"  it('should transition internally to the most recently visited state', () => {\n    // {\n    //   $current: 'first',\n    //   first: undefined,\n    //   second: {\n    //     $current: 'nested',\n    //     nested: undefined,\n    //     other: undefined\n    //   }\n    // }\n    const state2 = machine.transition(machine.initialState, 'NEXT');\n    // {\n    //   $current: 'second',\n    //   first: undefined,\n    //   second: {\n    //     $current: 'other',\n    //     nested: undefined,\n    //     other: undefined\n    //   }\n    // }\n    const state3 = machine.transition(state2, 'NEXT');\n    // {\n    //   $current: 'second',\n    //   first: undefined,\n    //   second: {\n    //     $current: 'other',\n    //     nested: undefined,\n    //     other: undefined\n    //   }\n    // }\n\n    expect(state3.value).toEqual({ second: 'other' });\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go to the most recently visited state","suites":["multistage history states"],"updatePoint":{"line":470,"column":50},"line":470,"code":"  it('should go to the most recently visited state', () => {\n    const onTurboState = pcWithTurboButtonMachine.transition(\n      'running',\n      'SWITCH_TURBO'\n    );\n    const offState = pcWithTurboButtonMachine.transition(onTurboState, 'POWER');\n    const loadingState = pcWithTurboButtonMachine.transition(offState, 'POWER');\n\n    expect(\n      pcWithTurboButtonMachine.transition(loadingState, 'STARTED').value\n    ).toEqual({ running: 'turbo' });\n  });","file":"history.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with ID + relative path","suites":["State node IDs"],"updatePoint":{"line":115,"column":41},"line":115,"code":"  it('should work with ID + relative path', () => {\n    const brokenMachine = Machine({\n      initial: 'foo',\n      on: {\n        ACTION: '#bar.qux.quux'\n      },\n      states: {\n        foo: {\n          id: 'foo'\n        },\n        bar: {\n          id: 'bar',\n          states: {\n            baz: {},\n            qux: {\n              states: {\n                quux: {\n                  id: '#bar.qux.quux'\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n\n    expect(brokenMachine.transition('foo', 'ACTION').value).toEqual({\n      bar: { qux: 'quux' }\n    });\n  });","file":"id.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the correct initial state","suites":["Initial states"],"updatePoint":{"line":40,"column":45},"line":40,"code":"  it('should return the correct initial state', () => {\n    expect(deepMachine.initialState.value).toEqual({ a: { b: 'c' } });\n  });","file":"initial.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the correct initial state (parallel)","suites":["Initial states"],"updatePoint":{"line":44,"column":56},"line":44,"code":"  it('should return the correct initial state (parallel)', () => {\n    expect(parallelDeepMachine.initialState.value).toEqual({\n      foo: { a: { b: 'c' } },\n      bar: { a: { b: 'c' } }\n    });\n  });","file":"initial.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the correct initial state (deep parallel)","suites":["Initial states"],"updatePoint":{"line":51,"column":61},"line":51,"code":"  it('should return the correct initial state (deep parallel)', () => {\n    expect(deepParallelMachine.initialState.value).toEqual({\n      one: {\n        foo: { a: { b: 'c' } },\n        bar: { a: { b: 'c' } }\n      }\n    });\n  });","file":"initial.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"parent state should enter child state without re-entering self","suites":["internal transitions"],"updatePoint":{"line":55,"column":68},"line":55,"code":"  it('parent state should enter child state without re-entering self', () => {\n    const nextState = wordMachine.transition(\n      wordMachine.initialState,\n      'RIGHT_CLICK'\n    );\n\n    expect(nextState.value).toEqual({ direction: 'right' });\n    expect(nextState.actions.length).toBe(0);\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"parent state should re-enter self upon transitioning to child state if internal is false","suites":["internal transitions"],"updatePoint":{"line":65,"column":94},"line":65,"code":"  it('parent state should re-enter self upon transitioning to child state if internal is false', () => {\n    const nextState = wordMachine.transition(\n      wordMachine.initialState,\n      'RIGHT_CLICK_EXTERNAL'\n    );\n\n    expect(nextState.value).toEqual({ direction: 'right' });\n    expect(nextState.actions.length).toBe(2);\n    expect(nextState.actions.map((a) => a.type)).toEqual([\n      'EXIT_DIRECTION',\n      'ENTER_DIRECTION'\n    ]);\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"parent state should only exit/reenter if there is an explicit self-transition","suites":["internal transitions"],"updatePoint":{"line":79,"column":83},"line":79,"code":"  it('parent state should only exit/reenter if there is an explicit self-transition', () => {\n    const resetState = wordMachine.transition('direction.center', 'RESET');\n\n    expect(resetState.value).toEqual({ direction: 'left' });\n    expect(resetState.actions.map((a) => a.type)).toEqual([\n      'EXIT_DIRECTION',\n      'ENTER_DIRECTION'\n    ]);\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"parent state should only exit/reenter if there is an explicit self-transition (to child)","suites":["internal transitions"],"updatePoint":{"line":89,"column":94},"line":89,"code":"  it('parent state should only exit/reenter if there is an explicit self-transition (to child)', () => {\n    const resetState = wordMachine.transition(\n      'direction.right',\n      'RESET_TO_CENTER'\n    );\n\n    expect(resetState.value).toEqual({ direction: 'center' });\n    expect(resetState.actions.map((a) => a.type)).toEqual([\n      'EXIT_DIRECTION',\n      'ENTER_DIRECTION'\n    ]);\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should listen to events declared at top state","suites":["internal transitions"],"updatePoint":{"line":102,"column":51},"line":102,"code":"  it('should listen to events declared at top state', () => {\n    const actualState = topLevelMachine.transition('Failure', 'CLICKED_CLOSE');\n\n    expect(actualState.value).toEqual('Hidden');\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with targetless transitions (in conditional array)","suites":["internal transitions"],"updatePoint":{"line":108,"column":68},"line":108,"code":"  it('should work with targetless transitions (in conditional array)', () => {\n    const sameState = topLevelMachine.transition('Hidden', 'TARGETLESS_ARRAY');\n\n    expect(sameState.actions.map((a) => a.type)).toEqual(['doSomething']);\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with targetless transitions (in object)","suites":["internal transitions"],"updatePoint":{"line":114,"column":57},"line":114,"code":"  it('should work with targetless transitions (in object)', () => {\n    const sameState = topLevelMachine.transition('Hidden', 'TARGETLESS_OBJECT');\n\n    expect(sameState.actions.map((a) => a.type)).toEqual(['doSomething']);\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work on parent with targetless transitions (in conditional array)","suites":["internal transitions"],"updatePoint":{"line":120,"column":78},"line":120,"code":"  it('should work on parent with targetless transitions (in conditional array)', () => {\n    const sameState = topLevelMachine.transition('Failure', 'TARGETLESS_ARRAY');\n\n    expect(sameState.actions.map((a) => a.type)).toEqual(['doSomethingParent']);\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with targetless transitions (in object)","suites":["internal transitions"],"updatePoint":{"line":126,"column":57},"line":126,"code":"  it('should work with targetless transitions (in object)', () => {\n    const sameState = topLevelMachine.transition(\n      'Failure',\n      'TARGETLESS_OBJECT'\n    );\n\n    expect(sameState.actions.map((a) => a.type)).toEqual(['doSomethingParent']);\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should maintain the child state when targetless transition is handled by parent","suites":["internal transitions"],"updatePoint":{"line":135,"column":85},"line":135,"code":"  it('should maintain the child state when targetless transition is handled by parent', () => {\n    const hiddenState = topLevelMachine.transition('Hidden', 'PARENT_EVENT');\n\n    expect(hiddenState.value).toEqual('Hidden');\n  });","file":"internalTransitions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"creates an interpreter","suites":["interpreter"],"updatePoint":{"line":52,"column":28},"line":52,"code":"  it('creates an interpreter', () => {\n    const service = interpret(idMachine);\n\n    expect(service).toBeInstanceOf(Interpreter);\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"immediately notifies the listener with the initial state and event","suites":["interpreter","initial state"],"updatePoint":{"line":59,"column":74},"line":59,"code":"    it('immediately notifies the listener with the initial state and event', (done) => {\n      const service = interpret(idMachine).onTransition(\n        (initialState, event) => {\n          expect(initialState).toBeInstanceOf(State);\n          expect(initialState.value).toEqual(idMachine.initialState.value);\n          expect(event.type).toEqual(actionTypes.init);\n          done();\n        }\n      );\n\n      service.start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":".initialState returns the initial state","suites":["interpreter","initial state"],"updatePoint":{"line":72,"column":47},"line":72,"code":"    it('.initialState returns the initial state', () => {\n      const service = interpret(idMachine);\n\n      expect(service.initialState.value).toEqual(idMachine.initialState.value);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"initial state should be cached","suites":["interpreter","initial state"],"updatePoint":{"line":78,"column":38},"line":78,"code":"    it('initial state should be cached', (done) => {\n      let entryCalled = 0;\n      let promiseSpawned = 0;\n\n      const machine = createMachine<any, any, any>({\n        initial: 'idle',\n        context: {\n          actor: undefined\n        },\n        states: {\n          idle: {\n            entry: assign({\n              actor: () => {\n                entryCalled++;\n                return spawn(\n                  new Promise(() => {\n                    promiseSpawned++;\n                  })\n                );\n              }\n            })\n          }\n        }\n      });\n\n      const service = interpret(machine);\n\n      expect(entryCalled).toEqual(0);\n      expect(promiseSpawned).toEqual(0);\n\n      const callInitialState = () => service.initialState;\n      callInitialState();\n      callInitialState();\n      callInitialState();\n\n      service.start();\n\n      expect(entryCalled).toEqual(1);\n\n      setTimeout(() => {\n        expect(promiseSpawned).toEqual(1);\n        done();\n      }, 100);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"executes actions from a restored state","suites":["interpreter","initial state"],"updatePoint":{"line":124,"column":46},"line":124,"code":"    it('executes actions from a restored state', (done) => {\n      const lightMachine = Machine(\n        {\n          id: 'light',\n          initial: 'green',\n          states: {\n            green: {\n              on: {\n                TIMER: {\n                  target: 'yellow',\n                  actions: 'report'\n                }\n              }\n            },\n            yellow: {\n              on: {\n                TIMER: {\n                  target: 'red'\n                }\n              }\n            },\n            red: {\n              on: {\n                TIMER: 'green'\n              }\n            }\n          }\n        },\n        {\n          actions: {\n            report: () => {\n              done();\n            }\n          }\n        }\n      );\n\n      const currentState = 'green';\n      const nextState = lightMachine.transition(currentState, 'TIMER');\n\n      // saves state and recreate it\n      const recreated = JSON.parse(JSON.stringify(nextState));\n      const previousState = State.create(recreated);\n\n      const service = interpret(lightMachine);\n      service.start(previousState);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should notify subscribers of the current state upon subscription (subscribe)","suites":["interpreter","subscribing"],"updatePoint":{"line":181,"column":84},"line":181,"code":"    it('should notify subscribers of the current state upon subscription (subscribe)', (done) => {\n      const service = interpret(machine).start();\n\n      service.subscribe((state) => {\n        expect(state.value).toBe('active');\n        done();\n      });\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should notify subscribers of the current state upon subscription (onTransition)","suites":["interpreter","subscribing"],"updatePoint":{"line":190,"column":87},"line":190,"code":"    it('should notify subscribers of the current state upon subscription (onTransition)', (done) => {\n      const service = interpret(machine).start();\n\n      service.onTransition((state) => {\n        expect(state.value).toBe('active');\n        done();\n      });\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"returns the next state for the given event without changing the interpreter state","suites":["interpreter",".nextState() method"],"updatePoint":{"line":201,"column":89},"line":201,"code":"    it('returns the next state for the given event without changing the interpreter state', () => {\n      let state: any;\n\n      const service = interpret(lightMachine, {\n        clock: new SimulatedClock()\n      })\n        .onTransition((s) => {\n          state = s;\n        })\n        .start();\n\n      const nextState = service.nextState('TIMER');\n      expect(nextState.value).toEqual('yellow');\n      expect(state.value).toEqual('green');\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can send an event after a delay","suites":["interpreter","send with delay"],"updatePoint":{"line":219,"column":39},"line":219,"code":"    it('can send an event after a delay', () => {\n      const currentStates: Array<AnyState> = [];\n\n      const service = interpret(lightMachine, {\n        clock: new SimulatedClock()\n      }).onTransition((state) => {\n        currentStates.push(state);\n\n        if (currentStates.length === 4) {\n          expect(currentStates.map((s) => s.value)).toEqual([\n            'green',\n            'yellow',\n            'red',\n            'green'\n          ]);\n        }\n      });\n      const clock = service.clock as SimulatedClock;\n      service.start();\n\n      clock.increment(5);\n      expect(currentStates[0]!.value).toEqual('green');\n\n      clock.increment(5);\n      expect(currentStates.map((s) => s.value)).toEqual(['green', 'yellow']);\n\n      clock.increment(5);\n      expect(currentStates.map((s) => s.value)).toEqual(['green', 'yellow']);\n\n      clock.increment(5);\n      expect(currentStates.map((s) => s.value)).toEqual([\n        'green',\n        'yellow',\n        'red'\n      ]);\n\n      clock.increment(5);\n      expect(currentStates.map((s) => s.value)).toEqual([\n        'green',\n        'yellow',\n        'red'\n      ]);\n\n      clock.increment(5);\n      expect(currentStates.map((s) => s.value)).toEqual([\n        'green',\n        'yellow',\n        'red',\n        'green'\n      ]);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can send an event after a delay (expression)","suites":["interpreter","send with delay"],"updatePoint":{"line":271,"column":52},"line":271,"code":"    it('can send an event after a delay (expression)', () => {\n      interface DelayExprMachineCtx {\n        initialDelay: number;\n      }\n\n      type DelayExpMachineEvents =\n        | { type: 'ACTIVATE'; wait: number }\n        | { type: 'FINISH' };\n\n      const delayExprMachine = Machine<\n        DelayExprMachineCtx,\n        DelayExpMachineEvents\n      >({\n        id: 'delayExpr',\n        context: {\n          initialDelay: 100\n        },\n        initial: 'idle',\n        states: {\n          idle: {\n            on: {\n              ACTIVATE: 'pending'\n            }\n          },\n          pending: {\n            onEntry: send('FINISH', {\n              delay: (ctx, e) =>\n                ctx.initialDelay +\n                ('wait' in e\n                  ? (e as Extract<DelayExpMachineEvents, { type: 'ACTIVATE' }>)\n                      .wait\n                  : 0)\n            }),\n            on: {\n              FINISH: 'finished'\n            }\n          },\n          finished: { type: 'final' }\n        }\n      });\n\n      let stopped = false;\n\n      const clock = new SimulatedClock();\n\n      const delayExprService = interpret(delayExprMachine, {\n        clock\n      })\n        .onDone(() => {\n          stopped = true;\n        })\n        .start();\n\n      delayExprService.send({\n        type: 'ACTIVATE',\n        wait: 50\n      });\n\n      clock.increment(101);\n\n      expect(stopped).toBe(false);\n\n      clock.increment(50);\n\n      expect(stopped).toBe(true);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can send an event after a delay (expression using _event)","suites":["interpreter","send with delay"],"updatePoint":{"line":338,"column":65},"line":338,"code":"    it('can send an event after a delay (expression using _event)', () => {\n      interface DelayExprMachineCtx {\n        initialDelay: number;\n      }\n\n      type DelayExpMachineEvents =\n        | {\n            type: 'ACTIVATE';\n            wait: number;\n          }\n        | {\n            type: 'FINISH';\n          };\n\n      const delayExprMachine = Machine<\n        DelayExprMachineCtx,\n        DelayExpMachineEvents\n      >({\n        id: 'delayExpr',\n        context: {\n          initialDelay: 100\n        },\n        initial: 'idle',\n        states: {\n          idle: {\n            on: {\n              ACTIVATE: 'pending'\n            }\n          },\n          pending: {\n            onEntry: send('FINISH', {\n              delay: (ctx, _, { _event }) =>\n                ctx.initialDelay +\n                (_event.data as Extract<\n                  DelayExpMachineEvents,\n                  { type: 'ACTIVATE' }\n                >).wait\n            }),\n            on: {\n              FINISH: 'finished'\n            }\n          },\n          finished: {\n            type: 'final'\n          }\n        }\n      });\n\n      let stopped = false;\n\n      const clock = new SimulatedClock();\n\n      const delayExprService = interpret(delayExprMachine, {\n        clock\n      })\n        .onDone(() => {\n          stopped = true;\n        })\n        .start();\n\n      delayExprService.send({\n        type: 'ACTIVATE',\n        wait: 50\n      });\n\n      clock.increment(101);\n\n      expect(stopped).toBe(false);\n\n      clock.increment(50);\n\n      expect(stopped).toBe(true);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can send an event after a delay (delayed transitions)","suites":["interpreter","send with delay"],"updatePoint":{"line":412,"column":61},"line":412,"code":"    it('can send an event after a delay (delayed transitions)', (done) => {\n      const clock = new SimulatedClock();\n      const letterMachine = Machine(\n        {\n          id: 'letter',\n          context: {\n            delay: 100\n          },\n          initial: 'a',\n          states: {\n            a: {\n              after: [\n                {\n                  delay: (ctx) => ctx.delay,\n                  target: 'b'\n                }\n              ]\n            },\n            b: {\n              after: {\n                someDelay: 'c'\n              }\n            },\n            c: {\n              onEntry: send(\n                { type: 'FIRE_DELAY', value: 200 },\n                { delay: 20 }\n              ) as EventObject,\n              on: {\n                FIRE_DELAY: 'd'\n              }\n            },\n            d: {\n              after: [\n                {\n                  delay: (ctx, e) => ctx.delay + (e as any).value,\n                  target: 'e'\n                }\n              ]\n            },\n            e: {\n              after: [\n                {\n                  delay: 'someDelay',\n                  target: 'f'\n                }\n              ]\n            },\n            f: {\n              type: 'final'\n            }\n          }\n        },\n        {\n          delays: {\n            someDelay: (ctx) => {\n              return ctx.delay + 50;\n            }\n          }\n        }\n      );\n\n      let state: any;\n\n      interpret(letterMachine, { clock })\n        .onTransition((s) => {\n          state = s;\n        })\n        .onDone(() => {\n          done();\n        })\n        .start();\n\n      expect(state.value).toEqual('a');\n      clock.increment(100);\n      expect(state.value).toEqual('b');\n      clock.increment(100 + 50);\n      expect(state.value).toEqual('c');\n      clock.increment(20);\n      expect(state.value).toEqual('d');\n      clock.increment(100 + 200);\n      expect(state.value).toEqual('e');\n      clock.increment(100 + 50);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should start activities","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":525,"column":31},"line":525,"code":"    it('should start activities', () => {\n      const service = interpret(activityMachine);\n\n      service.start();\n\n      expect(activityState).toEqual('on');\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should stop activities","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":533,"column":30},"line":533,"code":"    it('should stop activities', () => {\n      const service = interpret(activityMachine);\n\n      service.start();\n\n      expect(activityState).toEqual('on');\n\n      service.send('TURN_OFF');\n\n      expect(activityState).toEqual('off');\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should stop activities upon stopping the service","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":545,"column":56},"line":545,"code":"    it('should stop activities upon stopping the service', () => {\n      let stopActivityState: string;\n\n      const stopActivityMachine = Machine(\n        {\n          id: 'stopActivity',\n          initial: 'on',\n          states: {\n            on: {\n              activities: 'myActivity',\n              on: {\n                TURN_OFF: 'off'\n              }\n            },\n            off: {}\n          }\n        },\n        {\n          activities: {\n            myActivity: () => {\n              stopActivityState = 'on';\n              return () => (stopActivityState = 'off');\n            }\n          }\n        }\n      );\n\n      const stopActivityService = interpret(stopActivityMachine).start();\n\n      expect(stopActivityState!).toEqual('on');\n\n      stopActivityService.stop();\n\n      expect(stopActivityState!).toEqual('off');\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not restart activities from a compound state","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":581,"column":59},"line":581,"code":"    it('should not restart activities from a compound state', () => {\n      let activityActive = false;\n\n      const toggleMachine = Machine(\n        {\n          id: 'toggle',\n          initial: 'inactive',\n          states: {\n            inactive: {\n              on: { TOGGLE: 'active' }\n            },\n            active: {\n              activities: 'blink',\n              on: { TOGGLE: 'inactive' },\n              initial: 'A',\n              states: {\n                A: { on: { SWITCH: 'B' } },\n                B: { on: { SWITCH: 'A' } }\n              }\n            }\n          }\n        },\n        {\n          activities: {\n            blink: () => {\n              activityActive = true;\n\n              return () => {\n                activityActive = false;\n              };\n            }\n          }\n        }\n      );\n\n      const activeState = toggleMachine.transition(\n        toggleMachine.initialState,\n        'TOGGLE'\n      );\n      const bState = toggleMachine.transition(activeState, 'SWITCH');\n      let state: any;\n      interpret(toggleMachine)\n        .onTransition((s) => {\n          state = s;\n        })\n        .start(bState);\n\n      expect(state.activities.blink).toBeTruthy();\n      expect(activityActive).toBe(false);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can cancel a delayed event","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":633,"column":32},"line":633,"code":"  it('can cancel a delayed event', () => {\n    let currentState: AnyState;\n\n    const service = interpret(lightMachine, {\n      clock: new SimulatedClock()\n    }).onTransition((state) => (currentState = state));\n    const clock = service.clock as SimulatedClock;\n    service.start();\n\n    clock.increment(5);\n    service.send('KEEP_GOING');\n\n    expect(currentState!.value).toEqual('green');\n    clock.increment(10);\n    expect(currentState!.value).toEqual('green');\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an error if an event is sent to an uninitialized interpreter if { deferEvents: false }","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":650,"column":105},"line":650,"code":"  it('should throw an error if an event is sent to an uninitialized interpreter if { deferEvents: false }', () => {\n    const service = interpret(lightMachine, {\n      clock: new SimulatedClock(),\n      deferEvents: false\n    });\n\n    expect(() => service.send('SOME_EVENT'))\n      .toThrowErrorMatchingInlineSnapshot(`\n\"Event \\\\\"SOME_EVENT\\\\\" was sent to uninitialized service \\\\\"light\\\\\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: {\\\\\"type\\\\\":\\\\\"SOME_EVENT\\\\\"}\"\n`);\n\n    service.start();\n\n    expect(() => service.send('SOME_EVENT')).not.toThrow();\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not throw an error if an event is sent to an uninitialized interpreter if { deferEvents: true }","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":667,"column":108},"line":667,"code":"  it('should not throw an error if an event is sent to an uninitialized interpreter if { deferEvents: true }', () => {\n    const service = interpret(lightMachine, {\n      clock: new SimulatedClock(),\n      deferEvents: true\n    });\n\n    expect(() => service.send('SOME_EVENT')).not.toThrow();\n\n    service.start();\n\n    expect(() => service.send('SOME_EVENT')).not.toThrow();\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not throw an error if an event is sent to an uninitialized interpreter (default options)","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":680,"column":101},"line":680,"code":"  it('should not throw an error if an event is sent to an uninitialized interpreter (default options)', () => {\n    const service = interpret(lightMachine, {\n      clock: new SimulatedClock()\n    });\n\n    expect(() => service.send('SOME_EVENT')).not.toThrow();\n\n    service.start();\n\n    expect(() => service.send('SOME_EVENT')).not.toThrow();\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should defer events sent to an uninitialized service","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":692,"column":58},"line":692,"code":"  it('should defer events sent to an uninitialized service', (done) => {\n    const deferMachine = Machine({\n      id: 'defer',\n      initial: 'a',\n      states: {\n        a: {\n          on: { NEXT_A: 'b' }\n        },\n        b: {\n          on: { NEXT_B: 'c' }\n        },\n        c: {\n          type: 'final'\n        }\n      }\n    });\n\n    let state: any;\n    const deferService = interpret(deferMachine)\n      .onTransition((s) => {\n        state = s;\n      })\n      .onDone(() => done());\n\n    // uninitialized\n    deferService.send('NEXT_A');\n    deferService.send('NEXT_B');\n\n    expect(state).not.toBeDefined();\n\n    // initialized\n    deferService.start();\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an error if initial state sent to interpreter is invalid","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":726,"column":75},"line":726,"code":"  it('should throw an error if initial state sent to interpreter is invalid', () => {\n    const invalidMachine = {\n      id: 'fetchMachine',\n      initial: 'create',\n      states: {\n        edit: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                FETCH: 'pending'\n              }\n            },\n            pending: {}\n          }\n        }\n      }\n    };\n\n    expect(() => {\n      interpret(Machine(invalidMachine)).start();\n    }).toThrowErrorMatchingInlineSnapshot(\n      `\"Initial state 'create' not found on 'fetchMachine'\"`\n    );\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not update when stopped","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":752,"column":36},"line":752,"code":"  it('should not update when stopped', () => {\n    let state = lightMachine.initialState;\n    const service = interpret(lightMachine, {\n      clock: new SimulatedClock()\n    }).onTransition((s) => (state = s));\n\n    service.start();\n    service.send('TIMER'); // yellow\n    expect(state.value).toEqual('yellow');\n\n    service.stop();\n    try {\n      service.send('TIMER'); // red if interpreter is not stopped\n    } catch (e) {\n      expect(state.value).toEqual('yellow');\n    }\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to log (log action)","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":770,"column":40},"line":770,"code":"  it('should be able to log (log action)', () => {\n    const logs: any[] = [];\n\n    const logMachine = Machine<{ count: number }>({\n      id: 'log',\n      initial: 'x',\n      context: { count: 0 },\n      states: {\n        x: {\n          on: {\n            LOG: {\n              actions: [\n                assign({ count: (ctx) => ctx.count + 1 }),\n                log((ctx) => ctx)\n              ]\n            }\n          }\n        }\n      }\n    });\n\n    const service = interpret(logMachine, {\n      logger: (msg) => logs.push(msg)\n    }).start();\n\n    service.send('LOG');\n    service.send('LOG');\n\n    expect(logs.length).toBe(2);\n    expect(logs).toEqual([{ count: 1 }, { count: 2 }]);\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to log event origin (log action)","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":802,"column":53},"line":802,"code":"  it('should be able to log event origin (log action)', () => {\n    const logs: any[] = [];\n    const logAction = log((_ctx, event, meta) => ({\n      event: event.type,\n      origin: meta._event.origin\n    }));\n\n    const childMachine = Machine({\n      initial: 'bar',\n      states: {\n        bar: {}\n      },\n      on: {\n        PING: {\n          actions: [actions.respond('PONG')]\n        }\n      }\n    });\n\n    const parentMachine = Machine({\n      initial: 'foo',\n      states: {\n        foo: {\n          invoke: {\n            id: 'child',\n            src: childMachine\n          }\n        }\n      },\n      on: {\n        PING_CHILD: {\n          actions: [send('PING', { to: 'child' }), logAction]\n        },\n        '*': {\n          actions: [logAction]\n        }\n      }\n    });\n\n    const service = interpret(parentMachine, {\n      logger: (msg) => logs.push(msg)\n    }).start();\n\n    service.send('PING_CHILD');\n    service.send('PING_CHILD');\n\n    expect(logs.length).toBe(4);\n    expect(logs).toEqual([\n      { event: 'PING_CHILD', origin: undefined },\n      { event: 'PONG', origin: expect.stringMatching(/.+/) },\n      { event: 'PING_CHILD', origin: undefined },\n      { event: 'PONG', origin: expect.stringMatching(/.+/) }\n    ]);\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should receive correct _event (log action)","suites":["interpreter","activities (deprecated)"],"updatePoint":{"line":857,"column":48},"line":857,"code":"  it('should receive correct _event (log action)', () => {\n    const logs: any[] = [];\n    const logAction = log((_ctx, _ev, meta) => meta._event.data.type);\n\n    const parentMachine = Machine({\n      initial: 'foo',\n      states: {\n        foo: {\n          on: {\n            EXTERNAL_EVENT: {\n              actions: [raise('RAISED_EVENT'), logAction]\n            }\n          }\n        }\n      },\n      on: {\n        '*': {\n          actions: [logAction]\n        }\n      }\n    });\n\n    const service = interpret(parentMachine, {\n      logger: (msg) => logs.push(msg)\n    }).start();\n\n    service.send('EXTERNAL_EVENT');\n\n    expect(logs.length).toBe(2);\n    expect(logs).toEqual(['EXTERNAL_EVENT', 'RAISED_EVENT']);\n  });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve send event expressions","suites":["interpreter","send() event expressions"],"updatePoint":{"line":919,"column":45},"line":919,"code":"    it('should resolve send event expressions', (done) => {\n      interpret(machine)\n        .onDone(() => done())\n        .start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to raise event using special target","suites":["interpreter","send() event expressions"],"updatePoint":{"line":925,"column":58},"line":925,"code":"    it('should be able to raise event using special target', () => {\n      const raiseMachine = Machine({\n        initial: 'foo',\n        states: {\n          foo: {\n            entry: [send('EVENT_2'), send('EVENT_1', { to: '#_internal' })],\n            on: {\n              EVENT_1: 'pass',\n              EVENT_2: 'fail'\n            }\n          },\n          pass: {\n            type: 'final'\n          },\n          fail: {\n            type: 'final'\n          }\n        }\n      });\n\n      let state: AnyState;\n\n      interpret(raiseMachine)\n        .onTransition((s) => {\n          state = s;\n        })\n        .onDone(() => {\n          expect(state.value).toBe('pass');\n        })\n        .start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve sendParent event expressions","suites":["interpreter","sendParent() event expressions"],"updatePoint":{"line":1007,"column":51},"line":1007,"code":"    it('should resolve sendParent event expressions', (done) => {\n      interpret(parentMachine)\n        .onTransition((state) => {\n          if (state.matches('start')) {\n            expect(state.children).toHaveProperty('child');\n            expect(typeof state.children.child.send).toBe('function');\n          }\n        })\n        .onDone(() => done())\n        .start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should batch send events","suites":["interpreter","send() batch events"],"updatePoint":{"line":1051,"column":32},"line":1051,"code":"    it('should batch send events', (done) => {\n      let transitions = 0;\n      const evenCounts: number[] = [];\n      const oddCounts: number[] = [];\n      const countService = interpret(\n        countMachine.withConfig({\n          actions: {\n            evenAction: (ctx) => {\n              evenCounts.push(ctx.count);\n            },\n            oddAction: (ctx) => {\n              oddCounts.push(ctx.count);\n            }\n          }\n        })\n      )\n        .onTransition((state) => {\n          transitions++;\n\n          switch (transitions) {\n            // initial state\n            case 1:\n              expect(state.context).toEqual({ count: 0 });\n              break;\n            // transition with batched events\n            case 2:\n              expect(state.value).toEqual('even');\n              expect(state.context).toEqual({ count: 4 });\n              expect(state.actions.map((a) => a.type)).toEqual([\n                'evenAction',\n                'oddAction',\n                'evenAction',\n                'oddAction'\n              ]);\n\n              expect(evenCounts).toEqual([1, 3]);\n              expect(oddCounts).toEqual([2, 4]);\n              done();\n              break;\n          }\n        })\n        .start();\n\n      countService.send(['INC', 'INC', { type: 'INC' }, 'INC']);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state changed property should be true if any intermediate state is changed","suites":["interpreter","send() batch events"],"updatePoint":{"line":1097,"column":82},"line":1097,"code":"    it('state changed property should be true if any intermediate state is changed', (done) => {\n      let transitions = 0;\n\n      const countService = interpret(countMachine)\n        .onTransition((state) => {\n          transitions++;\n\n          if (transitions === 2) {\n            expect(state.changed).toBe(true);\n            done();\n          }\n        })\n        .start();\n\n      countService.send(['INC', 'bar']);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state changed property should be false if no intermediate state is changed","suites":["interpreter","send() batch events"],"updatePoint":{"line":1114,"column":82},"line":1114,"code":"    it('state changed property should be false if no intermediate state is changed', (done) => {\n      let transitions = 0;\n\n      const countService = interpret(countMachine)\n        .onTransition((state) => {\n          transitions++;\n          if (transitions === 2) {\n            expect(state.changed).toBe(false);\n            done();\n          }\n        })\n        .start();\n\n      countService.send(['foo', 'bar']);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state changed property should be true if a subsequent send call changes the state","suites":["interpreter","send() batch events"],"updatePoint":{"line":1130,"column":89},"line":1130,"code":"    it('state changed property should be true if a subsequent send call changes the state', (done) => {\n      let transitions = 0;\n\n      const countService = interpret(countMachineNoActions)\n        .onTransition((state) => {\n          transitions++;\n          if (transitions === 3) {\n            expect(state.changed).toBe(true);\n            done();\n          }\n        })\n        .start();\n\n      countService.send(['ODD']);\n      countService.send(['EVEN']);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state changed property should be false if a subsequent send call did not actually change the state","suites":["interpreter","send() batch events"],"updatePoint":{"line":1147,"column":106},"line":1147,"code":"    it('state changed property should be false if a subsequent send call did not actually change the state', (done) => {\n      let transitions = 0;\n\n      const countService = interpret(countMachineNoActions)\n        .onTransition((state) => {\n          transitions++;\n          if (transitions === 3) {\n            expect(state.changed).toBe(false);\n            done();\n          }\n        })\n        .start();\n\n      countService.send(['ODD']);\n      countService.send(['ODD']);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can send events with a string","suites":["interpreter","send()"],"updatePoint":{"line":1185,"column":37},"line":1185,"code":"    it('can send events with a string', (done) => {\n      const service = interpret(sendMachine)\n        .onDone(() => done())\n        .start();\n\n      service.send('ACTIVATE');\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can send events with an object","suites":["interpreter","send()"],"updatePoint":{"line":1193,"column":38},"line":1193,"code":"    it('can send events with an object', (done) => {\n      const service = interpret(sendMachine)\n        .onDone(() => done())\n        .start();\n\n      service.send({ type: 'ACTIVATE' });\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can send events with an object with payload","suites":["interpreter","send()"],"updatePoint":{"line":1201,"column":51},"line":1201,"code":"    it('can send events with an object with payload', (done) => {\n      const service = interpret(sendMachine)\n        .onDone(() => done())\n        .start();\n\n      service.send({ type: 'EVENT', id: 42 });\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can send events with a string and object payload","suites":["interpreter","send()"],"updatePoint":{"line":1209,"column":56},"line":1209,"code":"    it('can send events with a string and object payload', (done) => {\n      let state: any;\n      const service = interpret(sendMachine)\n        .onTransition((s) => {\n          state = s;\n        })\n        .onDone(() => {\n          expect(state.event).toEqual({ type: 'EVENT', id: 42 });\n          done();\n        })\n        .start();\n\n      service.send('EVENT', { id: 42 });\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should receive and process all events sent simultaneously","suites":["interpreter","send()"],"updatePoint":{"line":1224,"column":65},"line":1224,"code":"    it('should receive and process all events sent simultaneously', (done) => {\n      const toggleMachine = Machine({\n        id: 'toggle',\n        initial: 'inactive',\n        states: {\n          fail: {},\n          inactive: {\n            on: {\n              INACTIVATE: 'fail',\n              ACTIVATE: 'active'\n            }\n          },\n          active: {\n            on: {\n              INACTIVATE: 'success'\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      const toggleService = interpret(toggleMachine)\n        .onDone(() => {\n          done();\n        })\n        .start();\n\n      toggleService.send('ACTIVATE');\n      toggleService.send('INACTIVATE');\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should initialize the service","suites":["interpreter","start()"],"updatePoint":{"line":1273,"column":37},"line":1273,"code":"    it('should initialize the service', (done) => {\n      let state: any;\n      const startService = interpret(startMachine).onTransition((s) => {\n        state = s;\n        expect(s).toBeDefined();\n        expect(s.value).toEqual(startMachine.initialState.value);\n        done();\n      });\n\n      expect(state).not.toBeDefined();\n\n      startService.start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not reinitialize a started service","suites":["interpreter","start()"],"updatePoint":{"line":1287,"column":49},"line":1287,"code":"    it('should not reinitialize a started service', () => {\n      let stateCount = 0;\n      const startService = interpret(startMachine).onTransition(() => {\n        stateCount++;\n      });\n\n      startService.start();\n      expect(stateCount).toEqual(1);\n\n      startService.start();\n      expect(stateCount).toEqual(1);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to be initialized at a custom state","suites":["interpreter","start()"],"updatePoint":{"line":1300,"column":58},"line":1300,"code":"    it('should be able to be initialized at a custom state', (done) => {\n      const startService = interpret(startMachine).onTransition((state) => {\n        expect(state.matches('bar')).toBeTruthy();\n        done();\n      });\n\n      startService.start(State.from('bar'));\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to be initialized at a custom state value","suites":["interpreter","start()"],"updatePoint":{"line":1309,"column":64},"line":1309,"code":"    it('should be able to be initialized at a custom state value', (done) => {\n      const startService = interpret(startMachine).onTransition((state) => {\n        expect(state.matches('bar')).toBeTruthy();\n        done();\n      });\n\n      startService.start('bar');\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to resolve a custom initialized state","suites":["interpreter","start()"],"updatePoint":{"line":1318,"column":60},"line":1318,"code":"    it('should be able to resolve a custom initialized state', (done) => {\n      const startService = interpret(startMachine).onTransition((state) => {\n        expect(state.matches({ foo: 'one' })).toBeTruthy();\n        done();\n      });\n\n      startService.start(State.from('foo'));\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should cancel delayed events","suites":["interpreter","stop()"],"updatePoint":{"line":1329,"column":36},"line":1329,"code":"    it('should cancel delayed events', (done) => {\n      let called = false;\n      const delayedMachine = Machine({\n        id: 'delayed',\n        initial: 'foo',\n        states: {\n          foo: {\n            after: {\n              50: {\n                target: 'bar',\n                actions: () => {\n                  called = true;\n                }\n              }\n            }\n          },\n          bar: {}\n        }\n      });\n\n      const delayedService = interpret(delayedMachine).start();\n\n      delayedService.stop();\n\n      setTimeout(() => {\n        expect(called).toBe(false);\n        done();\n      }, 60);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not execute transitions after being stopped","suites":["interpreter","stop()"],"updatePoint":{"line":1359,"column":58},"line":1359,"code":"    it('should not execute transitions after being stopped', (done) => {\n      let called = false;\n\n      const testMachine = Machine({\n        initial: 'waiting',\n        states: {\n          waiting: {\n            on: {\n              TRIGGER: 'active'\n            }\n          },\n          active: {\n            entry: () => {\n              called = true;\n            }\n          }\n        }\n      });\n\n      const service = interpret(testMachine).start();\n\n      service.stop();\n\n      service.send('TRIGGER');\n\n      setTimeout(() => {\n        expect(called).toBeFalsy();\n        done();\n      }, 10);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"stopping a not-started interpreter should not crash","suites":["interpreter","stop()"],"updatePoint":{"line":1390,"column":59},"line":1390,"code":"    it('stopping a not-started interpreter should not crash', () => {\n      const service = interpret(\n        createMachine({\n          initial: 'a',\n          states: { a: {} }\n        })\n      );\n\n      expect(() => {\n        service.stop();\n      }).not.toThrow();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should remove transition listeners","suites":["interpreter","off()"],"updatePoint":{"line":1405,"column":42},"line":1405,"code":"    it('should remove transition listeners', () => {\n      const toggleMachine = Machine({\n        id: 'toggle',\n        initial: 'inactive',\n        states: {\n          inactive: {\n            on: { TOGGLE: 'active' }\n          },\n          active: {\n            on: { TOGGLE: 'inactive' }\n          }\n        }\n      });\n\n      const toggleService = interpret(toggleMachine).start();\n\n      let stateCount = 0;\n\n      const listener = () => stateCount++;\n\n      toggleService.onTransition(listener);\n\n      expect(stateCount).toEqual(1);\n\n      toggleService.send('TOGGLE');\n\n      expect(stateCount).toEqual(2);\n\n      toggleService.send('TOGGLE');\n\n      expect(stateCount).toEqual(3);\n\n      toggleService.off(listener);\n      toggleService.send('TOGGLE');\n\n      expect(stateCount).toEqual(3);\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not execute actions if execute is false","suites":["interpreter","options","execute"],"updatePoint":{"line":1446,"column":56},"line":1446,"code":"      it('should not execute actions if execute is false', (done) => {\n        let effect = false;\n\n        const machine = Machine({\n          id: 'noExecute',\n          initial: 'active',\n          states: {\n            active: {\n              type: 'final',\n              onEntry: () => {\n                effect = true;\n              }\n            }\n          }\n        });\n\n        interpret(machine, { execute: false })\n          .onDone(() => {\n            expect(effect).toBe(false);\n            done();\n          })\n          .start();\n      });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not execute actions if execute is true (default)","suites":["interpreter","options","execute"],"updatePoint":{"line":1470,"column":65},"line":1470,"code":"      it('should not execute actions if execute is true (default)', (done) => {\n        let effect = false;\n\n        const machine = Machine({\n          id: 'noExecute',\n          initial: 'active',\n          states: {\n            active: {\n              type: 'final',\n              onEntry: () => {\n                effect = true;\n              }\n            }\n          }\n        });\n\n        interpret(machine, { execute: true })\n          .onDone(() => {\n            expect(effect).toBe(true);\n            done();\n          })\n          .start();\n      });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"actions should be able to be executed manually with execute()","suites":["interpreter","options","execute"],"updatePoint":{"line":1494,"column":71},"line":1494,"code":"      it('actions should be able to be executed manually with execute()', (done) => {\n        let effect = false;\n\n        const machine = Machine({\n          id: 'noExecute',\n          initial: 'active',\n          context: {\n            value: true\n          },\n          states: {\n            active: {\n              type: 'final',\n              onEntry: (ctx) => {\n                effect = ctx.value;\n              }\n            }\n          }\n        });\n\n        const service = interpret(machine, { execute: false })\n          .onTransition((state) => {\n            setTimeout(() => {\n              service.execute(state);\n              expect(effect).toBe(true);\n              done();\n            }, 10);\n          })\n          .onDone(() => {\n            expect(effect).toBe(false);\n          })\n          .start();\n      });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"actions should be configurable with execute()","suites":["interpreter","options","execute"],"updatePoint":{"line":1527,"column":55},"line":1527,"code":"      it('actions should be configurable with execute()', (done) => {\n        let effect = false;\n\n        const machine = Machine({\n          id: 'noExecute',\n          initial: 'active',\n          context: {\n            value: true\n          },\n          states: {\n            active: {\n              type: 'final',\n              onEntry: 'doEffect'\n            }\n          }\n        });\n\n        const service = interpret(machine, { execute: false })\n          .onTransition((state) => {\n            setTimeout(() => {\n              service.execute(state, {\n                doEffect: (ctx) => {\n                  effect = ctx.value;\n                }\n              });\n              expect(effect).toBe(true);\n              done();\n            }, 10);\n          })\n          .onDone(() => {\n            expect(effect).toBe(false);\n          })\n          .start();\n      });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"uses the ID specified in the options","suites":["interpreter","options","id"],"updatePoint":{"line":1564,"column":46},"line":1564,"code":"      it('uses the ID specified in the options', () => {\n        const service = interpret(lightMachine, { id: 'custom-id' });\n\n        expect(service.id).toEqual('custom-id');\n      });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"uses the machine ID if not specified","suites":["interpreter","options","id"],"updatePoint":{"line":1570,"column":46},"line":1570,"code":"      it('uses the machine ID if not specified', () => {\n        const service = interpret(lightMachine);\n\n        expect(service.id).toEqual(lightMachine.id);\n      });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"devTools should not be connected by default","suites":["interpreter","options","devTools"],"updatePoint":{"line":1578,"column":53},"line":1578,"code":"      it('devTools should not be connected by default', () => {\n        const service = interpret(lightMachine);\n\n        expect(service.options.devTools).toBe(false);\n      });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition in correct order","suites":["interpreter","transient states"],"updatePoint":{"line":1587,"column":42},"line":1587,"code":"    it('should transition in correct order', () => {\n      const stateMachine = Machine({\n        id: 'transient',\n        initial: 'idle',\n        states: {\n          idle: { on: { START: 'transient' } },\n          transient: { always: 'next' },\n          next: { on: { FINISH: 'end' } },\n          end: { type: 'final' }\n        }\n      });\n\n      const stateValues: StateValue[] = [];\n      const service = interpret(stateMachine)\n        .onTransition((current) => stateValues.push(current.value))\n        .start();\n      service.send('START');\n\n      const expectedStateValues = ['idle', 'next'];\n      expect(stateValues.length).toEqual(expectedStateValues.length);\n      for (let i = 0; i < expectedStateValues.length; i++) {\n        expect(stateValues[i]).toEqual(expectedStateValues[i]);\n      }\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition in correct order when there is a condition","suites":["interpreter","transient states"],"updatePoint":{"line":1612,"column":68},"line":1612,"code":"    it('should transition in correct order when there is a condition', () => {\n      const stateMachine = Machine(\n        {\n          id: 'transient',\n          initial: 'idle',\n          states: {\n            idle: { on: { START: 'transient' } },\n            transient: {\n              always: [\n                { target: 'end', cond: 'alwaysFalse' },\n                { target: 'next' }\n              ]\n            },\n            next: { on: { FINISH: 'end' } },\n            end: { type: 'final' }\n          }\n        },\n        {\n          guards: {\n            alwaysFalse: () => false\n          }\n        }\n      );\n\n      const stateValues: StateValue[] = [];\n      const service = interpret(stateMachine)\n        .onTransition((current) => stateValues.push(current.value))\n        .start();\n      service.send('START');\n\n      const expectedStateValues = ['idle', 'next'];\n      expect(stateValues.length).toEqual(expectedStateValues.length);\n      for (let i = 0; i < expectedStateValues.length; i++) {\n        expect(stateValues[i]).toEqual(expectedStateValues[i]);\n      }\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be subscribable","suites":["interpreter","observable"],"updatePoint":{"line":1675,"column":30},"line":1675,"code":"    it('should be subscribable', (done) => {\n      let count: number;\n      const intervalService = interpret(intervalMachine).start();\n\n      expect(isObservable(intervalService)).toBeTruthy();\n\n      intervalService.subscribe(\n        (state) => (count = state.context.count),\n        undefined,\n        () => {\n          expect(count).toEqual(5);\n          done();\n        }\n      );\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be interoperable with RxJS, etc. via Symbol.observable","suites":["interpreter","observable"],"updatePoint":{"line":1691,"column":69},"line":1691,"code":"    it('should be interoperable with RxJS, etc. via Symbol.observable', (done) => {\n      let count = 0;\n      const intervalService = interpret(intervalMachine).start();\n\n      expect(() => {\n        const state$ = from(intervalService);\n\n        state$.subscribe(\n          () => {\n            count += 1;\n          },\n          undefined,\n          () => {\n            expect(count).toEqual(6);\n            done();\n          }\n        );\n      }).not.toThrow();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be unsubscribable","suites":["interpreter","observable"],"updatePoint":{"line":1711,"column":32},"line":1711,"code":"    it('should be unsubscribable', (done) => {\n      const countContext = { count: 0 };\n      const machine = Machine<typeof countContext>({\n        context: countContext,\n        initial: 'active',\n        states: {\n          active: {\n            always: {\n              target: 'finished',\n              cond: (ctx) => ctx.count >= 5\n            },\n            on: {\n              INC: {\n                actions: assign({ count: (ctx) => ctx.count + 1 })\n              }\n            }\n          },\n          finished: {\n            type: 'final'\n          }\n        }\n      });\n\n      let count: number;\n      const service = interpret(machine)\n        .onDone(() => {\n          expect(count).toEqual(2);\n          done();\n        })\n        .start();\n\n      const subscription = service.subscribe(\n        (state) => (count = state.context.count)\n      );\n\n      service.send('INC');\n      service.send('INC');\n      subscription.unsubscribe();\n      service.send('INC');\n      service.send('INC');\n      service.send('INC');\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"doesn't crash cryptically on undefined return from the service creator","suites":["interpreter","services"],"updatePoint":{"line":1756,"column":78},"line":1756,"code":"    it(\"doesn't crash cryptically on undefined return from the service creator\", () => {\n      const machine = Machine(\n        {\n          initial: 'initial',\n          states: {\n            initial: {\n              invoke: {\n                src: 'testService'\n              }\n            }\n          }\n        },\n        {\n          services: {\n            testService: (() => {\n              return void 0;\n            }) as any\n          }\n        }\n      );\n\n      const service = interpret(machine);\n      expect(() => service.start()).not.toThrow();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state.children should reference invoked child actors (machine)","suites":["interpreter","children"],"updatePoint":{"line":1783,"column":70},"line":1783,"code":"    it('state.children should reference invoked child actors (machine)', (done) => {\n      const childMachine = Machine({\n        initial: 'active',\n        states: {\n          active: {\n            on: {\n              FIRE: {\n                actions: sendParent('FIRED')\n              }\n            }\n          }\n        }\n      });\n\n      const parentMachine = Machine({\n        initial: 'active',\n        states: {\n          active: {\n            invoke: {\n              id: 'childActor',\n              src: childMachine\n            },\n            on: {\n              FIRED: 'success'\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      const service = interpret(parentMachine)\n        .onTransition((state) => {\n          if (state.matches('active') && state.children.childActor) {\n            state.children.childActor.send({ type: 'FIRE' });\n          }\n        })\n        .onDone(() => {\n          expect(service.state.children).not.toHaveProperty('childActor');\n          done();\n        });\n\n      service.start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state.children should reference invoked child actors (promise)","suites":["interpreter","children"],"updatePoint":{"line":1829,"column":70},"line":1829,"code":"    it('state.children should reference invoked child actors (promise)', (done) => {\n      const parentMachine = Machine({\n        initial: 'active',\n        states: {\n          active: {\n            invoke: {\n              id: 'childActor',\n              src: () =>\n                new Promise((res) => {\n                  setTimeout(() => {\n                    res(42);\n                  }, 100);\n                }),\n              onDone: {\n                target: 'success',\n                cond: (_, e) => e.data === 42\n              }\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      let subscribed = false;\n\n      const service = interpret(parentMachine)\n        .onTransition((state) => {\n          if (state.children.childActor && !subscribed) {\n            subscribed = true;\n            state.children.childActor.subscribe((data) => {\n              expect(data).toEqual(42);\n              done();\n            });\n          }\n        })\n        .onDone(() => {\n          expect(service.state.children).not.toHaveProperty('childActor');\n        });\n\n      service.start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state.children should reference invoked child actors (observable)","suites":["interpreter","children"],"updatePoint":{"line":1873,"column":73},"line":1873,"code":"    it('state.children should reference invoked child actors (observable)', (done) => {\n      const interval$ = interval(10);\n\n      const parentMachine = Machine({\n        initial: 'active',\n        states: {\n          active: {\n            invoke: {\n              id: 'childActor',\n              src: () =>\n                interval$.pipe(map((value) => ({ type: 'FIRED', value })))\n            },\n            on: {\n              FIRED: {\n                target: 'success',\n                cond: (_: unknown, e: AnyEventObject) => {\n                  return e.value === 3;\n                }\n              }\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      let subscribed = false;\n\n      const service = interpret(parentMachine)\n        .onTransition((state) => {\n          if (\n            state.matches('active') &&\n            state.children.childActor &&\n            !subscribed\n          ) {\n            subscribed = true;\n            state.children.childActor.subscribe((data) => {\n              if (data.value === 3) {\n                done();\n              }\n            });\n          }\n        })\n        .onDone(() => {\n          expect(service.state.children).not.toHaveProperty('childActor');\n        });\n\n      service.start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state.children should reference spawned actors","suites":["interpreter","children"],"updatePoint":{"line":1924,"column":54},"line":1924,"code":"    it('state.children should reference spawned actors', (done) => {\n      const childMachine = Machine({\n        initial: 'idle',\n        states: {\n          idle: {}\n        }\n      });\n\n      const formMachine = createMachine<any, any, any>({\n        id: 'form',\n        initial: 'idle',\n        context: {},\n        entry: assign({\n          firstNameRef: () => spawn(childMachine, 'child')\n        }),\n        states: {\n          idle: {}\n        }\n      });\n\n      interpret(formMachine)\n        .onTransition((state) => {\n          expect(state.children).toHaveProperty('child');\n          done();\n        })\n        .start();\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"stopped spawned actors should be cleaned up in parent","suites":["interpreter","children"],"updatePoint":{"line":1952,"column":61},"line":1952,"code":"    it('stopped spawned actors should be cleaned up in parent', (done) => {\n      const childMachine = Machine({\n        initial: 'idle',\n        states: {\n          idle: {}\n        }\n      });\n\n      const parentMachine = createMachine<any>({\n        id: 'form',\n        initial: 'present',\n        context: {},\n        entry: assign({\n          machineRef: () => spawn(childMachine, 'machineChild'),\n          promiseRef: () =>\n            spawn(\n              new Promise(() => {\n                // ...\n              }),\n              'promiseChild'\n            ),\n          observableRef: () => spawn(interval(1000), 'observableChild')\n        }),\n        states: {\n          present: {\n            on: {\n              NEXT: {\n                target: 'gone',\n                actions: [\n                  // TODO: type these correctly in TContext\n                  stop((ctx) => (ctx as any).machineRef),\n                  stop((ctx) => (ctx as any).promiseRef),\n                  stop((ctx) => (ctx as any).observableRef)\n                ]\n              }\n            }\n          },\n          gone: {\n            type: 'final'\n          }\n        }\n      });\n\n      const service = interpret(parentMachine)\n        .onDone(() => {\n          expect(service.children.get('machineChild')).toBeUndefined();\n          expect(service.children.get('promiseChild')).toBeUndefined();\n          expect(service.children.get('observableChild')).toBeUndefined();\n          done();\n        })\n        .start();\n\n      service.subscribe((state) => {\n        if (state.matches('present')) {\n          expect(state.children).toHaveProperty('machineChild');\n          expect(state.children).toHaveProperty('promiseChild');\n          expect(state.children).toHaveProperty('observableChild');\n\n          service.send('NEXT');\n        }\n      });\n    });","file":"interpreter.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve a String state","suites":["invalid or resolved states"],"updatePoint":{"line":24,"column":35},"line":24,"code":"  it('should resolve a String state', () => {\n    expect(machine.transition('A', 'E').value).toEqual({ A: 'A1', B: 'B1' });\n  });","file":"invalid.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve transitions from empty states","suites":["invalid or resolved states"],"updatePoint":{"line":28,"column":50},"line":28,"code":"  it('should resolve transitions from empty states', () => {\n    expect(machine.transition({ A: {}, B: {} }, 'E').value).toEqual({\n      A: 'A1',\n      B: 'B1'\n    });\n  });","file":"invalid.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow transitioning from valid states","suites":["invalid or resolved states"],"updatePoint":{"line":35,"column":50},"line":35,"code":"  it('should allow transitioning from valid states', () => {\n    machine.transition({ A: 'A1', B: 'B1' }, 'E');\n  });","file":"invalid.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reject transitioning from bad state configs","suites":["invalid or resolved states"],"updatePoint":{"line":39,"column":56},"line":39,"code":"  it('should reject transitioning from bad state configs', () => {\n    expect(() => machine.transition({ A: 'A3', B: 'B3' }, 'E')).toThrow();\n  });","file":"invalid.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve transitioning from partially valid states","suites":["invalid or resolved states"],"updatePoint":{"line":43,"column":62},"line":43,"code":"  it('should resolve transitioning from partially valid states', () => {\n    expect(machine.transition({ A: 'A1', B: {} }, 'E').value).toEqual({\n      A: 'A1',\n      B: 'B1'\n    });\n  });","file":"invalid.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve transitioning from regions that don't exist (remove region)","suites":["invalid or resolved states"],"updatePoint":{"line":50,"column":80},"line":50,"code":"  it(\"should resolve transitioning from regions that don't exist (remove region)\", () => {\n    expect(\n      machine.transition({ A: 'A1', B: 'B1', Z: 'Z1' }, 'E').value\n    ).toEqual({\n      A: 'A1',\n      B: 'B1'\n    });\n  });","file":"invalid.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should start services (external machines)","suites":["invoke"],"updatePoint":{"line":143,"column":47},"line":143,"code":"  it('should start services (external machines)', (done) => {\n    const childMachine = Machine({\n      id: 'child',\n      initial: 'init',\n      states: {\n        init: {\n          entry: [sendParent('INC'), sendParent('INC')]\n        }\n      }\n    });\n\n    const someParentMachine = Machine<{ count: number }>(\n      {\n        id: 'parent',\n        context: { count: 0 },\n        initial: 'start',\n        states: {\n          start: {\n            invoke: {\n              src: 'child',\n              id: 'someService',\n              autoForward: true\n            },\n            always: {\n              target: 'stop',\n              cond: (ctx) => ctx.count === 2\n            },\n            on: {\n              INC: {\n                actions: assign({ count: (ctx) => ctx.count + 1 })\n              }\n            }\n          },\n          stop: {\n            type: 'final'\n          }\n        }\n      },\n      {\n        services: {\n          child: childMachine\n        }\n      }\n    );\n\n    let count: number;\n\n    interpret(someParentMachine)\n      .onTransition((state) => {\n        count = state.context.count;\n      })\n      .onDone(() => {\n        // 1. The 'parent' machine will enter 'start' state\n        // 2. The 'child' service will be run with ID 'someService'\n        // 3. The 'child' machine will enter 'init' state\n        // 4. The 'entry' action will be executed, which sends 'INC' to 'parent' machine twice\n        // 5. The context will be updated to increment count to 2\n\n        expect(count).toEqual(2);\n        done();\n      })\n      .start();\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should forward events to services if autoForward: true","suites":["invoke"],"updatePoint":{"line":207,"column":60},"line":207,"code":"  it('should forward events to services if autoForward: true', () => {\n    const childMachine = Machine({\n      id: 'child',\n      initial: 'init',\n      states: {\n        init: {\n          on: {\n            FORWARD_DEC: {\n              actions: [sendParent('DEC'), sendParent('DEC'), sendParent('DEC')]\n            }\n          }\n        }\n      }\n    });\n\n    const someParentMachine = Machine<{ count: number }>(\n      {\n        id: 'parent',\n        context: { count: 0 },\n        initial: 'start',\n        states: {\n          start: {\n            invoke: {\n              src: 'child',\n              id: 'someService',\n              autoForward: true\n            },\n            always: {\n              target: 'stop',\n              cond: (ctx) => ctx.count === -3\n            },\n            on: {\n              DEC: { actions: assign({ count: (ctx) => ctx.count - 1 }) },\n              FORWARD_DEC: undefined\n            }\n          },\n          stop: {\n            type: 'final'\n          }\n        }\n      },\n      {\n        services: {\n          child: childMachine\n        }\n      }\n    );\n\n    let state: any;\n    const service = interpret(someParentMachine)\n      .onTransition((s) => {\n        state = s;\n      })\n      .onDone(() => {\n        // 1. The 'parent' machine will not do anything (inert transition)\n        // 2. The 'FORWARD_DEC' event will be forwarded to the 'child' machine (autoForward: true)\n        // 3. On the 'child' machine, the 'FORWARD_DEC' event sends the 'DEC' action to the 'parent' thrice\n        // 4. The context of the 'parent' machine will be updated from 2 to -1\n\n        expect(state.context).toEqual({ count: -3 });\n      })\n      .start();\n\n    service.send('FORWARD_DEC');\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should forward events to services if autoForward: true before processing them","suites":["invoke"],"updatePoint":{"line":273,"column":83},"line":273,"code":"  it('should forward events to services if autoForward: true before processing them', (done) => {\n    const actual: string[] = [];\n\n    const childMachine = Machine<{ count: number }>({\n      id: 'child',\n      context: { count: 0 },\n      initial: 'counting',\n      states: {\n        counting: {\n          on: {\n            INCREMENT: [\n              {\n                target: 'done',\n                cond: (ctx) => {\n                  actual.push('child got INCREMENT');\n                  return ctx.count >= 2;\n                },\n                actions: assign((ctx) => ({ count: ++ctx.count }))\n              },\n              {\n                target: undefined,\n                actions: assign((ctx) => ({ count: ++ctx.count }))\n              }\n            ]\n          }\n        },\n        done: {\n          type: 'final',\n          data: (ctx) => ({ countedTo: ctx.count })\n        }\n      },\n      on: {\n        START: {\n          actions: () => {\n            throw new Error('Should not receive START action here.');\n          }\n        }\n      }\n    });\n\n    const parentMachine = Machine<{ countedTo: number }>({\n      id: 'parent',\n      context: { countedTo: 0 },\n      initial: 'idle',\n      states: {\n        idle: {\n          on: {\n            START: 'invokeChild'\n          }\n        },\n        invokeChild: {\n          invoke: {\n            src: childMachine,\n            autoForward: true,\n            onDone: {\n              target: 'done',\n              actions: assign((_ctx, event) => ({\n                countedTo: event.data.countedTo\n              }))\n            }\n          },\n          on: {\n            INCREMENT: {\n              actions: () => {\n                actual.push('parent got INCREMENT');\n              }\n            }\n          }\n        },\n        done: {\n          type: 'final'\n        }\n      }\n    });\n\n    let state: any;\n    const service = interpret(parentMachine)\n      .onTransition((s) => {\n        state = s;\n      })\n      .onDone(() => {\n        expect(state.context).toEqual({ countedTo: 3 });\n        expect(actual).toEqual([\n          'child got INCREMENT',\n          'parent got INCREMENT',\n          'child got INCREMENT',\n          'parent got INCREMENT',\n          'child got INCREMENT',\n          'parent got INCREMENT'\n        ]);\n        done();\n      })\n      .start();\n\n    service.send('START');\n    service.send('INCREMENT');\n    service.send('INCREMENT');\n    service.send('INCREMENT');\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should forward events to services if autoForward: true before processing them (when sending batches)","suites":["invoke"],"updatePoint":{"line":373,"column":106},"line":373,"code":"  it('should forward events to services if autoForward: true before processing them (when sending batches)', (done) => {\n    const actual: string[] = [];\n\n    const childMachine = Machine<{ count: number }>({\n      id: 'child',\n      context: { count: 0 },\n      initial: 'counting',\n      states: {\n        counting: {\n          on: {\n            INCREMENT: [\n              {\n                target: 'done',\n                cond: (ctx) => {\n                  actual.push('child got INCREMENT');\n                  return ctx.count >= 2;\n                },\n                actions: assign((ctx) => ({ count: ++ctx.count }))\n              },\n              {\n                target: undefined,\n                actions: assign((ctx) => ({ count: ++ctx.count }))\n              }\n            ]\n          }\n        },\n        done: {\n          type: 'final',\n          data: (ctx) => ({ countedTo: ctx.count })\n        }\n      },\n      on: {\n        START: {\n          actions: () => {\n            throw new Error('Should not receive START action here.');\n          }\n        }\n      }\n    });\n\n    const parentMachine = Machine<{ countedTo: number }>({\n      id: 'parent',\n      context: { countedTo: 0 },\n      initial: 'idle',\n      states: {\n        idle: {\n          on: {\n            START: 'invokeChild'\n          }\n        },\n        invokeChild: {\n          invoke: {\n            src: childMachine,\n            autoForward: true,\n            onDone: {\n              target: 'done',\n              actions: assign((_ctx, event) => ({\n                countedTo: event.data.countedTo\n              }))\n            }\n          },\n          on: {\n            INCREMENT: {\n              actions: () => {\n                actual.push('parent got INCREMENT');\n              }\n            }\n          }\n        },\n        done: {\n          type: 'final'\n        }\n      }\n    });\n\n    let state: any;\n    const service = interpret(parentMachine)\n      .onTransition((s) => {\n        state = s;\n      })\n      .onDone(() => {\n        expect(state.context).toEqual({ countedTo: 3 });\n        expect(actual).toEqual([\n          'child got INCREMENT',\n          'parent got INCREMENT',\n          'child got INCREMENT',\n          'child got INCREMENT',\n          'parent got INCREMENT',\n          'parent got INCREMENT'\n        ]);\n        done();\n      })\n      .start();\n\n    service.send(['START']);\n    service.send(['INCREMENT']);\n    service.send(['INCREMENT', 'INCREMENT']);\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should start services (explicit machine, invoke = config)","suites":["invoke"],"updatePoint":{"line":472,"column":63},"line":472,"code":"  it('should start services (explicit machine, invoke = config)', (done) => {\n    interpret(fetcherMachine)\n      .onDone(() => {\n        done();\n      })\n      .start()\n      .send('GO_TO_WAITING');\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should start services (explicit machine, invoke = machine)","suites":["invoke"],"updatePoint":{"line":481,"column":64},"line":481,"code":"  it('should start services (explicit machine, invoke = machine)', (done) => {\n    interpret(fetcherMachine)\n      .onDone((_) => {\n        done();\n      })\n      .start()\n      .send('GO_TO_WAITING_MACHINE');\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should start services (machine as invoke config)","suites":["invoke"],"updatePoint":{"line":490,"column":54},"line":490,"code":"  it('should start services (machine as invoke config)', (done) => {\n    const machineInvokeMachine = Machine<\n      void,\n      { type: 'SUCCESS'; data: number }\n    >({\n      id: 'machine-invoke',\n      initial: 'pending',\n      states: {\n        pending: {\n          invoke: Machine({\n            id: 'child',\n            initial: 'sending',\n            states: {\n              sending: {\n                entry: sendParent({ type: 'SUCCESS', data: 42 })\n              }\n            }\n          }),\n          on: {\n            SUCCESS: {\n              target: 'success',\n              cond: (_, e) => {\n                return e.data === 42;\n              }\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    interpret(machineInvokeMachine)\n      .onDone(() => done())\n      .start();\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should start deeply nested service (machine as invoke config)","suites":["invoke"],"updatePoint":{"line":528,"column":67},"line":528,"code":"  it('should start deeply nested service (machine as invoke config)', (done) => {\n    const machineInvokeMachine = Machine<\n      void,\n      { type: 'SUCCESS'; data: number }\n    >({\n      id: 'parent',\n      initial: 'a',\n      states: {\n        a: {\n          initial: 'b',\n          states: {\n            b: {\n              invoke: Machine({\n                id: 'child',\n                initial: 'sending',\n                states: {\n                  sending: {\n                    entry: sendParent({ type: 'SUCCESS', data: 42 })\n                  }\n                }\n              })\n            }\n          }\n        },\n        success: {\n          id: 'success',\n          type: 'final'\n        }\n      },\n      on: {\n        SUCCESS: {\n          target: 'success',\n          cond: (_, e) => {\n            return e.data === 42;\n          }\n        }\n      }\n    });\n\n    interpret(machineInvokeMachine)\n      .onDone(() => done())\n      .start();\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should use the service overwritten by withConfig","suites":["invoke"],"updatePoint":{"line":572,"column":54},"line":572,"code":"  it('should use the service overwritten by withConfig', (done) => {\n    const childMachine = Machine({\n      id: 'child',\n      initial: 'init',\n      states: {\n        init: {}\n      }\n    });\n\n    const someParentMachine = Machine(\n      {\n        id: 'parent',\n        context: { count: 0 },\n        initial: 'start',\n        states: {\n          start: {\n            invoke: {\n              src: 'child',\n              id: 'someService',\n              autoForward: true\n            },\n            on: {\n              STOP: 'stop'\n            }\n          },\n          stop: {\n            type: 'final'\n          }\n        }\n      },\n      {\n        services: {\n          child: childMachine\n        }\n      }\n    );\n\n    interpret(\n      someParentMachine.withConfig({\n        services: {\n          child: Machine({\n            id: 'child',\n            initial: 'init',\n            states: {\n              init: {\n                entry: [sendParent('STOP')]\n              }\n            }\n          })\n        }\n      })\n    )\n      .onDone(() => {\n        done();\n      })\n      .start();\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not start services only once when using withContext","suites":["invoke"],"updatePoint":{"line":630,"column":64},"line":630,"code":"  it('should not start services only once when using withContext', () => {\n    let startCount = 0;\n\n    const startMachine = Machine({\n      id: 'start',\n      initial: 'active',\n      context: { foo: true },\n      states: {\n        active: {\n          invoke: {\n            src: () => () => {\n              startCount++;\n            }\n          }\n        }\n      }\n    });\n\n    const startService = interpret(startMachine.withContext({ foo: false }));\n\n    startService.start();\n\n    expect(startCount).toEqual(1);\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should communicate with the child machine (invoke on machine)","suites":["invoke","parent to child"],"updatePoint":{"line":669,"column":69},"line":669,"code":"    it('should communicate with the child machine (invoke on machine)', (done) => {\n      const mainMachine = Machine({\n        id: 'parent',\n        initial: 'one',\n        invoke: {\n          id: 'foo-child',\n          src: subMachine\n        },\n        states: {\n          one: {\n            entry: send('NEXT', { to: 'foo-child' }),\n            on: { NEXT: 'two' }\n          },\n          two: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(mainMachine)\n        .onDone(() => {\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should communicate with the child machine (invoke on created machine)","suites":["invoke","parent to child"],"updatePoint":{"line":695,"column":77},"line":695,"code":"    it('should communicate with the child machine (invoke on created machine)', (done) => {\n      interface MainMachineCtx {\n        machine: typeof subMachine;\n      }\n\n      const mainMachine = Machine<MainMachineCtx>({\n        id: 'parent',\n        initial: 'one',\n        context: {\n          machine: subMachine\n        },\n        invoke: {\n          id: 'foo-child',\n          src: (ctx) => ctx.machine\n        },\n        states: {\n          one: {\n            entry: send('NEXT', { to: 'foo-child' }),\n            on: { NEXT: 'two' }\n          },\n          two: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(mainMachine)\n        .onDone(() => {\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should communicate with the child machine (invoke on state)","suites":["invoke","parent to child"],"updatePoint":{"line":728,"column":67},"line":728,"code":"    it('should communicate with the child machine (invoke on state)', (done) => {\n      const mainMachine = Machine({\n        id: 'parent',\n        initial: 'one',\n        states: {\n          one: {\n            invoke: {\n              id: 'foo-child',\n              src: subMachine\n            },\n            entry: send('NEXT', { to: 'foo-child' }),\n            on: { NEXT: 'two' }\n          },\n          two: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(mainMachine)\n        .onDone(() => {\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition correctly if child invocation causes it to directly go to final state","suites":["invoke","parent to child"],"updatePoint":{"line":754,"column":95},"line":754,"code":"    it('should transition correctly if child invocation causes it to directly go to final state', (done) => {\n      const doneSubMachine = Machine({\n        id: 'child',\n        initial: 'one',\n        states: {\n          one: {\n            on: { NEXT: 'two' }\n          },\n          two: {\n            type: 'final'\n          }\n        }\n      });\n\n      const mainMachine = Machine({\n        id: 'parent',\n        initial: 'one',\n        states: {\n          one: {\n            invoke: {\n              id: 'foo-child',\n              src: doneSubMachine,\n              onDone: 'two'\n            },\n            entry: send('NEXT', { to: 'foo-child' })\n          },\n          two: {\n            on: { NEXT: 'three' }\n          },\n          three: {\n            type: 'final'\n          }\n        }\n      });\n\n      const expectedStateValue = 'two';\n      let currentState: AnyState;\n      interpret(mainMachine)\n        .onTransition((current) => (currentState = current))\n        .start();\n      setTimeout(() => {\n        expect(currentState.value).toEqual(expectedStateValue);\n        done();\n      }, 30);\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with invocations defined in orthogonal state nodes","suites":["invoke","parent to child"],"updatePoint":{"line":800,"column":70},"line":800,"code":"    it('should work with invocations defined in orthogonal state nodes', (done) => {\n      const pongMachine = Machine({\n        id: 'pong',\n        initial: 'active',\n        states: {\n          active: {\n            type: 'final',\n            data: { secret: 'pingpong' }\n          }\n        }\n      });\n\n      const pingMachine = Machine({\n        id: 'ping',\n        type: 'parallel',\n        states: {\n          one: {\n            initial: 'active',\n            states: {\n              active: {\n                invoke: {\n                  id: 'pong',\n                  src: pongMachine,\n                  onDone: {\n                    target: 'success',\n                    cond: (_, e) => e.data.secret === 'pingpong'\n                  }\n                }\n              },\n              success: {\n                type: 'final'\n              }\n            }\n          }\n        }\n      });\n\n      interpret(pingMachine)\n        .onDone(() => {\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not reinvoke root-level invocations","suites":["invoke","parent to child"],"updatePoint":{"line":844,"column":50},"line":844,"code":"    it('should not reinvoke root-level invocations', (done) => {\n      // https://github.com/statelyai/xstate/issues/2147\n\n      let invokeCount = 0;\n      let invokeDisposeCount = 0;\n      let actionsCount = 0;\n      let entryActionsCount = 0;\n\n      const machine = createMachine({\n        invoke: {\n          src: () => () => {\n            invokeCount++;\n\n            return () => {\n              invokeDisposeCount++;\n            };\n          }\n        },\n        entry: () => entryActionsCount++,\n        on: {\n          UPDATE: {\n            internal: true,\n            actions: () => {\n              actionsCount++;\n            }\n          }\n        }\n      });\n\n      const service = interpret(machine).start();\n      expect(entryActionsCount).toEqual(1);\n      expect(invokeCount).toEqual(1);\n      expect(invokeDisposeCount).toEqual(0);\n      expect(actionsCount).toEqual(0);\n\n      service.send('UPDATE');\n      expect(entryActionsCount).toEqual(1);\n      expect(invokeCount).toEqual(1);\n      expect(invokeDisposeCount).toEqual(0);\n      expect(actionsCount).toEqual(1);\n\n      service.send('UPDATE');\n      expect(entryActionsCount).toEqual(1);\n      expect(invokeCount).toEqual(1);\n      expect(invokeDisposeCount).toEqual(0);\n      expect(actionsCount).toEqual(2);\n      done();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"child should not invoke an actor when it transitions to an invoking state when it gets stopped by its parent","suites":["invoke","parent to child"],"updatePoint":{"line":893,"column":116},"line":893,"code":"    it('child should not invoke an actor when it transitions to an invoking state when it gets stopped by its parent', (done) => {\n      let invokeCount = 0;\n\n      const child = createMachine({\n        id: 'child',\n        initial: 'idle',\n        states: {\n          idle: {\n            invoke: {\n              src: () => {\n                invokeCount++;\n\n                if (invokeCount > 1) {\n                  // prevent a potential infinite loop\n                  throw new Error('This should be impossible.');\n                }\n\n                return (sendBack) => {\n                  // it's important for this test to send the event back when the parent is *not* currently processing an event\n                  // this ensures that the parent can process the received event immediately and can stop the child immediately\n                  setTimeout(() => sendBack({ type: 'STARTED' }));\n                };\n              }\n            },\n            on: {\n              STARTED: 'active'\n            }\n          },\n          active: {\n            invoke: {\n              src: () => {\n                return (sendBack) => {\n                  sendBack({ type: 'STOPPED' });\n                };\n              }\n            },\n            on: {\n              STOPPED: {\n                target: 'idle',\n                actions: forwardTo(SpecialTargets.Parent)\n              }\n            }\n          }\n        }\n      });\n      const parent = createMachine({\n        id: 'parent',\n        initial: 'idle',\n        states: {\n          idle: {\n            on: {\n              START: 'active'\n            }\n          },\n          active: {\n            invoke: { src: child },\n            on: {\n              STOPPED: 'done'\n            }\n          },\n          done: {\n            type: 'final'\n          }\n        }\n      });\n\n      const service = interpret(parent)\n        .onDone(() => {\n          expect(invokeCount).toBe(1);\n          done();\n        })\n        .start();\n\n      service.send('START');\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be invoked with a promise factory and resolve through onDone","suites":["invoke","with promises ()"],"updatePoint":{"line":1036,"column":77},"line":1036,"code":"      it('should be invoked with a promise factory and resolve through onDone', (done) => {\n        const service = interpret(invokePromiseMachine)\n          .onDone(() => {\n            expect(service.state._event.origin).toBeDefined();\n            done();\n          })\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be invoked with a promise factory and reject with ErrorExecution","suites":["invoke","with promises ()"],"updatePoint":{"line":1045,"column":81},"line":1045,"code":"      it('should be invoked with a promise factory and reject with ErrorExecution', (done) => {\n        interpret(invokePromiseMachine.withContext({ id: 31, succeed: false }))\n          .onDone(() => done())\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be invoked with a promise factory and ignore unhandled onError target","suites":["invoke","with promises ()"],"updatePoint":{"line":1051,"column":86},"line":1051,"code":"      it('should be invoked with a promise factory and ignore unhandled onError target', (done) => {\n        const doneSpy = jest.fn();\n        const stopSpy = jest.fn();\n\n        const promiseMachine = Machine({\n          id: 'invokePromise',\n          initial: 'pending',\n          states: {\n            pending: {\n              invoke: {\n                src: () =>\n                  createPromise(() => {\n                    throw new Error('test');\n                  }),\n                onDone: 'success'\n              }\n            },\n            success: {\n              type: 'final'\n            }\n          }\n        });\n\n        interpret(promiseMachine).onDone(doneSpy).onStop(stopSpy).start();\n\n        // assumes that error was ignored before the timeout is processed\n        setTimeout(() => {\n          expect(doneSpy).not.toHaveBeenCalled();\n          expect(stopSpy).not.toHaveBeenCalled();\n          done();\n        }, 10);\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be invoked with a promise factory and stop on unhandled onError target when on strict mode","suites":["invoke","with promises ()"],"updatePoint":{"line":1085,"column":107},"line":1085,"code":"      it('should be invoked with a promise factory and stop on unhandled onError target when on strict mode', (done) => {\n        const doneSpy = jest.fn();\n\n        const promiseMachine = Machine({\n          id: 'invokePromise',\n          initial: 'pending',\n          strict: true,\n          states: {\n            pending: {\n              invoke: {\n                src: () =>\n                  createPromise(() => {\n                    throw new Error('test');\n                  }),\n                onDone: 'success'\n              }\n            },\n            success: {\n              type: 'final'\n            }\n          }\n        });\n\n        interpret(promiseMachine)\n          .onDone(doneSpy)\n          .onStop(() => {\n            expect(doneSpy).not.toHaveBeenCalled();\n            done();\n          })\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be invoked with a promise factory and resolve through onDone for compound state nodes","suites":["invoke","with promises ()"],"updatePoint":{"line":1117,"column":102},"line":1117,"code":"      it('should be invoked with a promise factory and resolve through onDone for compound state nodes', (done) => {\n        const promiseMachine = Machine({\n          id: 'promise',\n          initial: 'parent',\n          states: {\n            parent: {\n              initial: 'pending',\n              states: {\n                pending: {\n                  invoke: {\n                    src: () => createPromise((resolve) => resolve()),\n                    onDone: 'success'\n                  }\n                },\n                success: {\n                  type: 'final'\n                }\n              },\n              onDone: 'success'\n            },\n            success: {\n              type: 'final'\n            }\n          }\n        });\n\n        interpret(promiseMachine)\n          .onDone(() => done())\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be invoked with a promise service and resolve through onDone for compound state nodes","suites":["invoke","with promises ()"],"updatePoint":{"line":1148,"column":102},"line":1148,"code":"      it('should be invoked with a promise service and resolve through onDone for compound state nodes', (done) => {\n        const promiseMachine = Machine(\n          {\n            id: 'promise',\n            initial: 'parent',\n            states: {\n              parent: {\n                initial: 'pending',\n                states: {\n                  pending: {\n                    invoke: {\n                      src: 'somePromise',\n                      onDone: 'success'\n                    }\n                  },\n                  success: {\n                    type: 'final'\n                  }\n                },\n                onDone: 'success'\n              },\n              success: {\n                type: 'final'\n              }\n            }\n          },\n          {\n            services: {\n              somePromise: () => createPromise((resolve) => resolve())\n            }\n          }\n        );\n\n        interpret(promiseMachine)\n          .onDone(() => done())\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should assign the resolved data when invoked with a promise factory","suites":["invoke","with promises ()"],"updatePoint":{"line":1186,"column":77},"line":1186,"code":"      it('should assign the resolved data when invoked with a promise factory', (done) => {\n        const promiseMachine = Machine<{ count: number }>({\n          id: 'promise',\n          context: { count: 0 },\n          initial: 'pending',\n          states: {\n            pending: {\n              invoke: {\n                src: () => createPromise((resolve) => resolve({ count: 1 })),\n                onDone: {\n                  target: 'success',\n                  actions: assign({ count: (_, e) => e.data.count })\n                }\n              }\n            },\n            success: {\n              type: 'final'\n            }\n          }\n        });\n\n        let state: any;\n        interpret(promiseMachine)\n          .onTransition((s) => {\n            state = s;\n          })\n          .onDone(() => {\n            expect(state.context.count).toEqual(1);\n            done();\n          })\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should assign the resolved data when invoked with a promise service","suites":["invoke","with promises ()"],"updatePoint":{"line":1219,"column":77},"line":1219,"code":"      it('should assign the resolved data when invoked with a promise service', (done) => {\n        const promiseMachine = Machine<{ count: number }>(\n          {\n            id: 'promise',\n            context: { count: 0 },\n            initial: 'pending',\n            states: {\n              pending: {\n                invoke: {\n                  src: 'somePromise',\n                  onDone: {\n                    target: 'success',\n                    actions: assign({ count: (_, e) => e.data.count })\n                  }\n                }\n              },\n              success: {\n                type: 'final'\n              }\n            }\n          },\n          {\n            services: {\n              somePromise: () =>\n                createPromise((resolve) => resolve({ count: 1 }))\n            }\n          }\n        );\n\n        let state: any;\n        interpret(promiseMachine)\n          .onTransition((s) => {\n            state = s;\n          })\n          .onDone(() => {\n            expect(state.context.count).toEqual(1);\n            done();\n          })\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide the resolved data when invoked with a promise factory","suites":["invoke","with promises ()"],"updatePoint":{"line":1260,"column":78},"line":1260,"code":"      it('should provide the resolved data when invoked with a promise factory', (done) => {\n        let count = 0;\n\n        const promiseMachine = Machine({\n          id: 'promise',\n          context: { count: 0 },\n          initial: 'pending',\n          states: {\n            pending: {\n              invoke: {\n                src: () => createPromise((resolve) => resolve({ count: 1 })),\n                onDone: {\n                  target: 'success',\n                  actions: (_, e) => {\n                    count = e.data.count;\n                  }\n                }\n              }\n            },\n            success: {\n              type: 'final'\n            }\n          }\n        });\n\n        interpret(promiseMachine)\n          .onDone(() => {\n            expect(count).toEqual(1);\n            done();\n          })\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide the resolved data when invoked with a promise service","suites":["invoke","with promises ()"],"updatePoint":{"line":1293,"column":78},"line":1293,"code":"      it('should provide the resolved data when invoked with a promise service', (done) => {\n        let count = 0;\n\n        const promiseMachine = Machine(\n          {\n            id: 'promise',\n            initial: 'pending',\n            states: {\n              pending: {\n                invoke: {\n                  src: 'somePromise',\n                  onDone: {\n                    target: 'success',\n                    actions: (_, e) => {\n                      count = e.data.count;\n                    }\n                  }\n                }\n              },\n              success: {\n                type: 'final'\n              }\n            }\n          },\n          {\n            services: {\n              somePromise: () =>\n                createPromise((resolve) => resolve({ count: 1 }))\n            }\n          }\n        );\n\n        interpret(promiseMachine)\n          .onDone(() => {\n            expect(count).toEqual(1);\n            done();\n          })\n          .start();\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to specify a Promise as a service","suites":["invoke","with promises ()"],"updatePoint":{"line":1333,"column":58},"line":1333,"code":"      it('should be able to specify a Promise as a service', (done) => {\n        interface BeginEvent {\n          type: 'BEGIN';\n          payload: boolean;\n        }\n        const promiseMachine = Machine<{ foo: boolean }, BeginEvent>(\n          {\n            id: 'promise',\n            initial: 'pending',\n            context: {\n              foo: true\n            },\n            states: {\n              pending: {\n                on: {\n                  BEGIN: 'first'\n                }\n              },\n              first: {\n                invoke: {\n                  src: 'somePromise',\n                  onDone: 'last'\n                }\n              },\n              last: {\n                type: 'final'\n              }\n            }\n          },\n          {\n            services: {\n              somePromise: (ctx, e: BeginEvent) => {\n                return createPromise((resolve, reject) => {\n                  ctx.foo && e.payload ? resolve() : reject();\n                });\n              }\n            }\n          }\n        );\n\n        interpret(promiseMachine)\n          .onDone(() => done())\n          .start()\n          .send({\n            type: 'BEGIN',\n            payload: true\n          });\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to specify a callback as a service","suites":["invoke","with callbacks"],"updatePoint":{"line":1385,"column":57},"line":1385,"code":"    it('should be able to specify a callback as a service', (done) => {\n      interface BeginEvent {\n        type: 'BEGIN';\n        payload: boolean;\n      }\n      interface CallbackEvent {\n        type: 'CALLBACK';\n        data: number;\n      }\n      const callbackMachine = Machine<\n        {\n          foo: boolean;\n        },\n        BeginEvent | CallbackEvent\n      >(\n        {\n          id: 'callback',\n          initial: 'pending',\n          context: {\n            foo: true\n          },\n          states: {\n            pending: {\n              on: {\n                BEGIN: 'first'\n              }\n            },\n            first: {\n              invoke: {\n                src: 'someCallback'\n              },\n              on: {\n                CALLBACK: {\n                  target: 'last',\n                  cond: (_, e) => e.data === 42\n                }\n              }\n            },\n            last: {\n              type: 'final'\n            }\n          }\n        },\n        {\n          services: {\n            someCallback: (ctx, e) => (cb: (ev: CallbackEvent) => void) => {\n              if (ctx.foo && 'payload' in e) {\n                cb({\n                  type: 'CALLBACK',\n                  data: 40\n                });\n                cb({\n                  type: 'CALLBACK',\n                  data: 41\n                });\n                cb({\n                  type: 'CALLBACK',\n                  data: 42\n                });\n              }\n            }\n          }\n        }\n      );\n\n      interpret(callbackMachine)\n        .onDone(() => done())\n        .start()\n        .send({\n          type: 'BEGIN',\n          payload: true\n        });\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition correctly if callback function sends an event","suites":["invoke","with callbacks"],"updatePoint":{"line":1459,"column":71},"line":1459,"code":"    it('should transition correctly if callback function sends an event', () => {\n      const callbackMachine = Machine(\n        {\n          id: 'callback',\n          initial: 'pending',\n          context: { foo: true },\n          states: {\n            pending: {\n              on: { BEGIN: 'first' }\n            },\n            first: {\n              invoke: {\n                src: 'someCallback'\n              },\n              on: { CALLBACK: 'intermediate' }\n            },\n            intermediate: {\n              on: { NEXT: 'last' }\n            },\n            last: {\n              type: 'final'\n            }\n          }\n        },\n        {\n          services: {\n            someCallback: () => (cb) => {\n              cb('CALLBACK');\n            }\n          }\n        }\n      );\n\n      const expectedStateValues = ['pending', 'first', 'intermediate'];\n      const stateValues: StateValue[] = [];\n      interpret(callbackMachine)\n        .onTransition((current) => stateValues.push(current.value))\n        .start()\n        .send('BEGIN');\n      for (let i = 0; i < expectedStateValues.length; i++) {\n        expect(stateValues[i]).toEqual(expectedStateValues[i]);\n      }\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition correctly if callback function invoked from start and sends an event","suites":["invoke","with callbacks"],"updatePoint":{"line":1503,"column":94},"line":1503,"code":"    it('should transition correctly if callback function invoked from start and sends an event', () => {\n      const callbackMachine = Machine(\n        {\n          id: 'callback',\n          initial: 'idle',\n          context: { foo: true },\n          states: {\n            idle: {\n              invoke: {\n                src: 'someCallback'\n              },\n              on: { CALLBACK: 'intermediate' }\n            },\n            intermediate: {\n              on: { NEXT: 'last' }\n            },\n            last: {\n              type: 'final'\n            }\n          }\n        },\n        {\n          services: {\n            someCallback: () => (cb) => {\n              cb('CALLBACK');\n            }\n          }\n        }\n      );\n\n      const expectedStateValues = ['idle', 'intermediate'];\n      const stateValues: StateValue[] = [];\n      interpret(callbackMachine)\n        .onTransition((current) => stateValues.push(current.value))\n        .start()\n        .send('BEGIN');\n      for (let i = 0; i < expectedStateValues.length; i++) {\n        expect(stateValues[i]).toEqual(expectedStateValues[i]);\n      }\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition correctly if transient transition happens before current state invokes callback function and sends an event","suites":["invoke","with callbacks"],"updatePoint":{"line":1545,"column":133},"line":1545,"code":"    it('should transition correctly if transient transition happens before current state invokes callback function and sends an event', () => {\n      const callbackMachine = Machine(\n        {\n          id: 'callback',\n          initial: 'pending',\n          context: { foo: true },\n          states: {\n            pending: {\n              on: { BEGIN: 'first' }\n            },\n            first: {\n              always: 'second'\n            },\n            second: {\n              invoke: {\n                src: 'someCallback'\n              },\n              on: { CALLBACK: 'third' }\n            },\n            third: {\n              on: { NEXT: 'last' }\n            },\n            last: {\n              type: 'final'\n            }\n          }\n        },\n        {\n          services: {\n            someCallback: () => (cb) => {\n              cb('CALLBACK');\n            }\n          }\n        }\n      );\n\n      const expectedStateValues = ['pending', 'second', 'third'];\n      const stateValues: StateValue[] = [];\n      interpret(callbackMachine)\n        .onTransition((current) => stateValues.push(current.value))\n        .start()\n        .send('BEGIN');\n      for (let i = 0; i < expectedStateValues.length; i++) {\n        expect(stateValues[i]).toEqual(expectedStateValues[i]);\n      }\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should treat a callback source as an event stream","suites":["invoke","with callbacks"],"updatePoint":{"line":1592,"column":57},"line":1592,"code":"    it('should treat a callback source as an event stream', (done) => {\n      interpret(intervalMachine)\n        .onDone(() => done())\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should dispose of the callback (if disposal function provided)","suites":["invoke","with callbacks"],"updatePoint":{"line":1598,"column":70},"line":1598,"code":"    it('should dispose of the callback (if disposal function provided)', (done) => {\n      let state: any;\n      const service = interpret(intervalMachine)\n        .onTransition((s) => {\n          state = s;\n        })\n        .onDone(() => {\n          // if intervalService isn't disposed after skipping, 'INC' event will\n          // keep being sent\n          expect(state.context.count).toEqual(0);\n          done();\n        })\n        .start();\n\n      // waits 50 milliseconds before going to final state.\n      service.send('SKIP');\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"callback should be able to receive messages from parent","suites":["invoke","with callbacks"],"updatePoint":{"line":1616,"column":63},"line":1616,"code":"    it('callback should be able to receive messages from parent', (done) => {\n      const pingPongMachine = Machine({\n        id: 'ping-pong',\n        initial: 'active',\n        states: {\n          active: {\n            invoke: {\n              id: 'child',\n              src: () => (callback, onReceive) => {\n                onReceive((e) => {\n                  if (e.type === 'PING') {\n                    callback('PONG');\n                  }\n                });\n              }\n            },\n            entry: send('PING', { to: 'child' }),\n            on: {\n              PONG: 'done'\n            }\n          },\n          done: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(pingPongMachine)\n        .onDone(() => done())\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call onError upon error (sync)","suites":["invoke","with callbacks"],"updatePoint":{"line":1648,"column":45},"line":1648,"code":"    it('should call onError upon error (sync)', (done) => {\n      const errorMachine = Machine({\n        id: 'error',\n        initial: 'safe',\n        states: {\n          safe: {\n            invoke: {\n              src: () => () => {\n                throw new Error('test');\n              },\n              onError: {\n                target: 'failed',\n                cond: (_, e) => {\n                  return e.data instanceof Error && e.data.message === 'test';\n                }\n              }\n            }\n          },\n          failed: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(errorMachine)\n        .onDone(() => done())\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition correctly upon error (sync)","suites":["invoke","with callbacks"],"updatePoint":{"line":1677,"column":53},"line":1677,"code":"    it('should transition correctly upon error (sync)', () => {\n      const errorMachine = Machine({\n        id: 'error',\n        initial: 'safe',\n        states: {\n          safe: {\n            invoke: {\n              src: () => () => {\n                throw new Error('test');\n              },\n              onError: 'failed'\n            }\n          },\n          failed: {\n            on: { RETRY: 'safe' }\n          }\n        }\n      });\n\n      const expectedStateValue = 'failed';\n      const service = interpret(errorMachine).start();\n      expect(service.state.value).toEqual(expectedStateValue);\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call onError upon error (async)","suites":["invoke","with callbacks"],"updatePoint":{"line":1701,"column":46},"line":1701,"code":"    it('should call onError upon error (async)', (done) => {\n      const errorMachine = Machine({\n        id: 'asyncError',\n        initial: 'safe',\n        states: {\n          safe: {\n            invoke: {\n              src: () => async () => {\n                await true;\n                throw new Error('test');\n              },\n              onError: {\n                target: 'failed',\n                cond: (_, e) => {\n                  return e.data instanceof Error && e.data.message === 'test';\n                }\n              }\n            }\n          },\n          failed: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(errorMachine)\n        .onDone(() => done())\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call onDone when resolved (async)","suites":["invoke","with callbacks"],"updatePoint":{"line":1731,"column":48},"line":1731,"code":"    it('should call onDone when resolved (async)', (done) => {\n      let state: any;\n\n      const asyncWithDoneMachine = Machine<{ result?: any }>({\n        id: 'async',\n        initial: 'fetch',\n        context: { result: undefined },\n        states: {\n          fetch: {\n            invoke: {\n              src: () => async () => {\n                await true;\n                return 42;\n              },\n              onDone: {\n                target: 'success',\n                actions: assign((_, { data: result }) => ({ result }))\n              }\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(asyncWithDoneMachine)\n        .onTransition((s) => {\n          state = s;\n        })\n        .onDone(() => {\n          expect(state.context.result).toEqual(42);\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call onError only on the state which has invoked failed service","suites":["invoke","with callbacks"],"updatePoint":{"line":1768,"column":78},"line":1768,"code":"    it('should call onError only on the state which has invoked failed service', () => {\n      let errorHandlersCalled = 0;\n\n      const errorMachine = Machine({\n        initial: 'start',\n        states: {\n          start: {\n            on: {\n              FETCH: 'fetch'\n            }\n          },\n          fetch: {\n            type: 'parallel',\n            states: {\n              first: {\n                invoke: {\n                  src: () => () => {\n                    throw new Error('test');\n                  },\n                  onError: {\n                    target: 'failed',\n                    cond: () => {\n                      errorHandlersCalled++;\n                      return false;\n                    }\n                  }\n                }\n              },\n              second: {\n                invoke: {\n                  src: () => () => {\n                    // empty\n                  },\n                  onError: {\n                    target: 'failed',\n                    cond: () => {\n                      errorHandlersCalled++;\n                      return false;\n                    }\n                  }\n                }\n              },\n              failed: {\n                type: 'final'\n              }\n            }\n          }\n        }\n      });\n\n      interpret(errorMachine).start().send('FETCH');\n\n      expect(errorHandlersCalled).toEqual(1);\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to be stringified","suites":["invoke","with callbacks"],"updatePoint":{"line":1823,"column":40},"line":1823,"code":"    it('should be able to be stringified', () => {\n      const waitingState = fetcherMachine.transition(\n        fetcherMachine.initialState,\n        'GO_TO_WAITING'\n      );\n\n      expect(() => {\n        JSON.stringify(waitingState);\n      }).not.toThrow();\n\n      expect(typeof waitingState.actions[0].activity!.src).toBe('string');\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw error if unhandled (sync)","suites":["invoke","with callbacks"],"updatePoint":{"line":1836,"column":46},"line":1836,"code":"    it('should throw error if unhandled (sync)', () => {\n      const errorMachine = Machine({\n        id: 'asyncError',\n        initial: 'safe',\n        states: {\n          safe: {\n            invoke: {\n              src: () => () => {\n                throw new Error('test');\n              }\n            }\n          },\n          failed: {\n            type: 'final'\n          }\n        }\n      });\n\n      const service = interpret(errorMachine);\n      expect(() => service.start()).toThrow();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should stop machine if unhandled error and on strict mode (async)","suites":["invoke","with callbacks"],"updatePoint":{"line":1858,"column":73},"line":1858,"code":"    it('should stop machine if unhandled error and on strict mode (async)', (done) => {\n      const errorMachine = Machine({\n        id: 'asyncError',\n        initial: 'safe',\n        // if not in strict mode we have no way to know if there\n        // was an error with processing rejected promise\n        strict: true,\n        states: {\n          safe: {\n            invoke: {\n              src: () => async () => {\n                await true;\n                throw new Error('test');\n              }\n            }\n          },\n          failed: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(errorMachine)\n        .onStop(() => done())\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should ignore error if unhandled error and not on strict mode (async)","suites":["invoke","with callbacks"],"updatePoint":{"line":1885,"column":77},"line":1885,"code":"    it('should ignore error if unhandled error and not on strict mode (async)', (done) => {\n      const doneSpy = jest.fn();\n      const stopSpy = jest.fn();\n\n      const errorMachine = Machine({\n        id: 'asyncError',\n        initial: 'safe',\n        // if not in strict mode we have no way to know if there\n        // was an error with processing rejected promise\n        strict: false,\n        states: {\n          safe: {\n            invoke: {\n              src: () => async () => {\n                await true;\n                throw new Error('test');\n              }\n            }\n          },\n          failed: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(errorMachine).onDone(doneSpy).onStop(stopSpy).start();\n\n      // assumes that error was ignored before the timeout is processed\n      setTimeout(() => {\n        expect(doneSpy).not.toHaveBeenCalled();\n        expect(stopSpy).not.toHaveBeenCalled();\n        done();\n      }, 20);\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"ends on the completed state","suites":["invoke","with callbacks","sub invoke race condition"],"updatePoint":{"line":1956,"column":37},"line":1956,"code":"      it('ends on the completed state', (done) => {\n        const events: EventObject[] = [];\n        let state: any;\n        const service = interpret(anotherParentMachine)\n          .onTransition((s) => {\n            state = s;\n          })\n          .onEvent((e) => {\n            events.push(e);\n          })\n          .onDone(() => {\n            expect(events.map((e) => e.type)).toEqual([\n              actionTypes.init,\n              'STOPCHILD',\n              doneInvoke('invoked.child').type\n            ]);\n            expect(state.value).toEqual('completed');\n            done();\n          })\n          .start();\n\n        service.send('STOPCHILD');\n      });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with an infinite observable","suites":["invoke","with observables"],"updatePoint":{"line":1985,"column":47},"line":1985,"code":"    it('should work with an infinite observable', (done) => {\n      interface Events {\n        type: 'COUNT';\n        value: number;\n      }\n      const obsMachine = Machine<{ count: number | undefined }, Events>({\n        id: 'obs',\n        initial: 'counting',\n        context: { count: undefined },\n        states: {\n          counting: {\n            invoke: {\n              src: () =>\n                infinite$.pipe(\n                  map((value) => {\n                    return { type: 'COUNT', value };\n                  })\n                )\n            },\n            always: {\n              target: 'counted',\n              cond: (ctx) => ctx.count === 5\n            },\n            on: {\n              COUNT: { actions: assign({ count: (_, e) => e.value }) }\n            }\n          },\n          counted: {\n            type: 'final'\n          }\n        }\n      });\n\n      const service = interpret(obsMachine)\n        .onDone(() => {\n          expect(service.state._event.origin).toBeDefined();\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a finite observable","suites":["invoke","with observables"],"updatePoint":{"line":2026,"column":44},"line":2026,"code":"    it('should work with a finite observable', (done) => {\n      interface Ctx {\n        count: number | undefined;\n      }\n      interface Events {\n        type: 'COUNT';\n        value: number;\n      }\n      const obsMachine = Machine<Ctx, Events>({\n        id: 'obs',\n        initial: 'counting',\n        context: {\n          count: undefined\n        },\n        states: {\n          counting: {\n            invoke: {\n              src: () =>\n                infinite$.pipe(\n                  take(5),\n                  map((value) => {\n                    return {\n                      type: 'COUNT',\n                      value\n                    };\n                  })\n                ),\n              onDone: {\n                target: 'counted',\n                cond: (ctx) => ctx.count === 4\n              }\n            },\n            on: {\n              COUNT: {\n                actions: assign({\n                  count: (_, e) => e.value\n                })\n              }\n            }\n          },\n          counted: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(obsMachine)\n        .onDone(() => {\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should receive an emitted error","suites":["invoke","with observables"],"updatePoint":{"line":2079,"column":39},"line":2079,"code":"    it('should receive an emitted error', (done) => {\n      interface Ctx {\n        count: number | undefined;\n      }\n      interface Events {\n        type: 'COUNT';\n        value: number;\n      }\n      const obsMachine = Machine<Ctx, Events>({\n        id: 'obs',\n        initial: 'counting',\n        context: { count: undefined },\n        states: {\n          counting: {\n            invoke: {\n              src: () =>\n                infinite$.pipe(\n                  map((value) => {\n                    if (value === 5) {\n                      throw new Error('some error');\n                    }\n\n                    return { type: 'COUNT', value };\n                  })\n                ),\n              onError: {\n                target: 'success',\n                cond: (ctx, e) => {\n                  expect(e.data.message).toEqual('some error');\n                  return ctx.count === 4 && e.data.message === 'some error';\n                }\n              }\n            },\n            on: {\n              COUNT: { actions: assign({ count: (_, e) => e.value }) }\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(obsMachine)\n        .onDone(() => {\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a behavior","suites":["invoke","with behaviors"],"updatePoint":{"line":2131,"column":35},"line":2131,"code":"    it('should work with a behavior', (done) => {\n      const countBehavior: Behavior<EventObject, number> = {\n        transition: (count, event) => {\n          if (event.type === 'INC') {\n            return count + 1;\n          } else {\n            return count - 1;\n          }\n        },\n        initialState: 0\n      };\n\n      const countMachine = createMachine({\n        invoke: {\n          id: 'count',\n          src: () => countBehavior\n        },\n        on: {\n          INC: {\n            actions: forwardTo('count')\n          }\n        }\n      });\n\n      const countService = interpret(countMachine)\n        .onTransition((state) => {\n          if (state.children['count']?.getSnapshot() === 2) {\n            done();\n          }\n        })\n        .start();\n\n      countService.send('INC');\n      countService.send('INC');\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"behaviors should have reference to the parent","suites":["invoke","with behaviors"],"updatePoint":{"line":2167,"column":53},"line":2167,"code":"    it('behaviors should have reference to the parent', (done) => {\n      const pongBehavior: Behavior<EventObject, undefined> = {\n        transition: (_, event, { parent }) => {\n          if (event.type === 'PING') {\n            parent?.send({ type: 'PONG' });\n          }\n\n          return undefined;\n        },\n        initialState: undefined\n      };\n\n      const pingMachine = createMachine({\n        initial: 'waiting',\n        states: {\n          waiting: {\n            entry: send('PING', { to: 'ponger' }),\n            invoke: {\n              id: 'ponger',\n              src: () => pongBehavior\n            },\n            on: {\n              PONG: 'success'\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      });\n\n      const pingService = interpret(pingMachine).onDone(() => {\n        done();\n      });\n      pingService.start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a reducer","suites":["invoke","with reducers"],"updatePoint":{"line":2206,"column":34},"line":2206,"code":"    it('should work with a reducer', (done) => {\n      const countReducer = (count: number, event: { type: 'INC' }): number => {\n        if (event.type === 'INC') {\n          return count + 1;\n        } else {\n          return count - 1;\n        }\n      };\n\n      const countMachine = createMachine({\n        invoke: {\n          id: 'count',\n          src: () => fromReducer(countReducer, 0)\n        },\n        on: {\n          INC: {\n            actions: forwardTo('count')\n          }\n        }\n      });\n\n      const countService = interpret(countMachine)\n        .onTransition((state) => {\n          if (state.children['count']?.getSnapshot() === 2) {\n            done();\n          }\n        })\n        .start();\n\n      countService.send('INC');\n      countService.send('INC');\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should schedule events in a FIFO queue","suites":["invoke","with reducers"],"updatePoint":{"line":2239,"column":46},"line":2239,"code":"    it('should schedule events in a FIFO queue', (done) => {\n      type CountEvents = { type: 'INC' } | { type: 'DOUBLE' };\n\n      const countReducer = (\n        count: number,\n        event: { type: 'INC' } | { type: 'DOUBLE' },\n        { self }: ActorContext<CountEvents, any>\n      ): number => {\n        if (event.type === 'INC') {\n          self.send({ type: 'DOUBLE' });\n          return count + 1;\n        }\n        if (event.type === 'DOUBLE') {\n          return count * 2;\n        }\n\n        return count;\n      };\n\n      const countMachine = createMachine({\n        invoke: {\n          id: 'count',\n          src: () => fromReducer(countReducer, 0)\n        },\n        on: {\n          INC: {\n            actions: forwardTo('count')\n          }\n        }\n      });\n\n      const countService = interpret(countMachine)\n        .onTransition((state) => {\n          if (state.children['count']?.getSnapshot() === 2) {\n            done();\n          }\n        })\n        .start();\n\n      countService.send('INC');\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should create invocations from machines in nested states","suites":["invoke","nested invoked machine"],"updatePoint":{"line":2327,"column":64},"line":2327,"code":"    it('should create invocations from machines in nested states', (done) => {\n      interpret(pingMachine)\n        .onDone(() => done())\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should start all services at once","suites":["invoke","multiple simultaneous services"],"updatePoint":{"line":2380,"column":41},"line":2380,"code":"    it('should start all services at once', (done) => {\n      let state: any;\n      const service = interpret(multiple)\n        .onTransition((s) => {\n          state = s;\n        })\n        .onDone(() => {\n          expect(state.context).toEqual({ one: 'one', two: 'two' });\n          done();\n        });\n\n      service.start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should run services in parallel","suites":["invoke","multiple simultaneous services"],"updatePoint":{"line":2444,"column":39},"line":2444,"code":"    it('should run services in parallel', (done) => {\n      let state: any;\n      const service = interpret(parallel)\n        .onTransition((s) => {\n          state = s;\n        })\n        .onDone(() => {\n          expect(state.context).toEqual({ one: 'one', two: 'two' });\n          done();\n        });\n\n      service.start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not invoke a service if it gets stopped immediately by transitioning away in microstep","suites":["invoke","multiple simultaneous services"],"updatePoint":{"line":2458,"column":101},"line":2458,"code":"    it('should not invoke a service if it gets stopped immediately by transitioning away in microstep', (done) => {\n      // Since an invocation will be canceled when the state machine leaves the\n      // invoking state, it does not make sense to start an invocation in a state\n      // that will be exited immediately\n      let serviceCalled = false;\n      const transientMachine = Machine({\n        id: 'transient',\n        initial: 'active',\n        states: {\n          active: {\n            invoke: {\n              id: 'doNotInvoke',\n              src: () => async () => {\n                serviceCalled = true;\n              }\n            },\n            always: 'inactive'\n          },\n          inactive: {\n            after: { 10: 'complete' }\n          },\n          complete: {\n            type: 'final'\n          }\n        }\n      });\n\n      const service = interpret(transientMachine);\n\n      service\n        .onDone(() => {\n          expect(serviceCalled).toBe(false);\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should invoke a service if other service gets stopped in subsequent microstep (#1180)","suites":["invoke","multiple simultaneous services"],"updatePoint":{"line":2495,"column":93},"line":2495,"code":"    it('should invoke a service if other service gets stopped in subsequent microstep (#1180)', (done) => {\n      const machine = createMachine({\n        initial: 'running',\n        states: {\n          running: {\n            type: 'parallel',\n            states: {\n              one: {\n                initial: 'active',\n                on: {\n                  STOP_ONE: '.idle'\n                },\n                states: {\n                  idle: {},\n                  active: {\n                    invoke: {\n                      id: 'active',\n                      src: () => () => {\n                        /* ... */\n                      }\n                    },\n                    on: {\n                      NEXT: {\n                        actions: raise('STOP_ONE')\n                      }\n                    }\n                  }\n                }\n              },\n              two: {\n                initial: 'idle',\n                on: {\n                  NEXT: '.active'\n                },\n                states: {\n                  idle: {},\n                  active: {\n                    invoke: {\n                      id: 'post',\n                      src: () => Promise.resolve(42),\n                      onDone: '#done'\n                    }\n                  }\n                }\n              }\n            }\n          },\n          done: {\n            id: 'done',\n            type: 'final'\n          }\n        }\n      });\n\n      const service = interpret(machine)\n        .onDone(() => done())\n        .start();\n\n      service.send('NEXT');\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"handles escalated errors","suites":["invoke","error handling"],"updatePoint":{"line":2558,"column":32},"line":2558,"code":"    it('handles escalated errors', (done) => {\n      const child = Machine({\n        initial: 'die',\n\n        states: {\n          die: {\n            entry: escalate('oops')\n          }\n        }\n      });\n\n      const parent = Machine({\n        initial: 'one',\n\n        states: {\n          one: {\n            invoke: {\n              id: 'child',\n              src: child,\n              onError: {\n                target: 'two',\n                cond: (_, event) => event.data === 'oops'\n              }\n            }\n          },\n          two: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(parent)\n        .onDone(() => {\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"handles escalated errors as an expression","suites":["invoke","error handling"],"updatePoint":{"line":2596,"column":49},"line":2596,"code":"    it('handles escalated errors as an expression', (done) => {\n      interface ChildContext {\n        id: number;\n      }\n\n      const child = Machine<ChildContext>({\n        initial: 'die',\n        context: { id: 42 },\n        states: {\n          die: {\n            entry: escalate((ctx) => ctx.id)\n          }\n        }\n      });\n\n      const parent = Machine({\n        initial: 'one',\n\n        states: {\n          one: {\n            invoke: {\n              id: 'child',\n              src: child,\n              onError: {\n                target: 'two',\n                cond: (_, event) => {\n                  expect(event.data).toEqual(42);\n                  return true;\n                }\n              }\n            }\n          },\n          two: {\n            type: 'final'\n          }\n        }\n      });\n\n      interpret(parent)\n        .onDone(() => {\n          done();\n        })\n        .start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"invoke `src` should accept invoke source definition","suites":["invoke","error handling"],"updatePoint":{"line":2642,"column":57},"line":2642,"code":"  it('invoke `src` should accept invoke source definition', (done) => {\n    const machine = createMachine(\n      {\n        initial: 'searching',\n        states: {\n          searching: {\n            invoke: {\n              src: {\n                type: 'search',\n                endpoint: 'example.com'\n              },\n              onDone: 'success'\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      },\n      {\n        services: {\n          search: async (_, __, meta) => {\n            expect(meta.src.endpoint).toEqual('example.com');\n\n            return await 42;\n          }\n        }\n      }\n    );\n\n    interpret(machine)\n      .onDone(() => done())\n      .start();\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should show meta data","suites":["invoke","meta data"],"updatePoint":{"line":2678,"column":29},"line":2678,"code":"    it('should show meta data', () => {\n      const machine = createMachine({\n        invoke: {\n          src: 'someSource',\n          meta: {\n            url: 'stately.ai'\n          }\n        }\n      });\n\n      expect(machine.invoke[0].meta).toEqual({ url: 'stately.ai' });\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"meta data should be available in the invoke source function","suites":["invoke","meta data"],"updatePoint":{"line":2691,"column":67},"line":2691,"code":"    it('meta data should be available in the invoke source function', () => {\n      expect.assertions(1);\n      const machine = createMachine({\n        invoke: {\n          src: (_ctx, _e, { meta }) => {\n            expect(meta).toEqual({ url: 'stately.ai' });\n            return Promise.resolve();\n          },\n          meta: {\n            url: 'stately.ai'\n          }\n        }\n      });\n\n      interpret(machine).start();\n    });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"invoke generated ID should be predictable based on the state node where it is defined","suites":["invoke","meta data"],"updatePoint":{"line":2709,"column":91},"line":2709,"code":"  it('invoke generated ID should be predictable based on the state node where it is defined', (done) => {\n    const machine = createMachine(\n      {\n        initial: 'a',\n        states: {\n          a: {\n            invoke: {\n              src: 'someSrc',\n              onDone: {\n                cond: (_, e) => {\n                  // invoke ID should not be 'someSrc'\n                  const expectedType = 'done.invoke.(machine).a:invocation[0]';\n                  expect(e.type).toEqual(expectedType);\n                  return e.type === expectedType;\n                },\n                target: 'b'\n              }\n            }\n          },\n          b: {\n            type: 'final'\n          }\n        }\n      },\n      {\n        services: {\n          someSrc: () => Promise.resolve()\n        }\n      }\n    );\n\n    interpret(machine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"invoke config defined as %s should register unique and predictable child in state","suites":["invoke","meta data"],"line":2747,"code":"  it.each([\n    ['src with string reference', { src: 'someSrc' }],\n    ['machine', createMachine({ id: 'someId' })],\n    [\n      'src containing a machine directly',\n      { src: createMachine({ id: 'someId' }) }\n    ],\n    [\n      'src containing a callback actor directly',\n      {\n        src: () => () => {\n          /* ... */\n        }\n      }\n    ],\n    [\n      'src containing a parametrized invokee with id parameter',\n      {\n        src: {\n          type: 'someSrc',\n          id: 'h4sh'\n        }\n      }\n    ]\n  ])(\n    'invoke config defined as %s should register unique and predictable child in state',\n    (_type, invokeConfig) => {\n      const machine = createMachine(\n        {\n          id: 'machine',\n          initial: 'a',\n          states: {\n            a: {\n              invoke: invokeConfig\n            }\n          }\n        },\n        {\n          services: {\n            someSrc: () => () => {\n              /* ... */\n            }\n          }\n        }\n      );\n\n      expect(\n        machine.initialState.children['machine.a:invocation[0]']\n      ).toBeDefined();\n    }\n  );","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"done.invoke events should only select onDone transition on the invoking state when invokee is referenced using a string","suites":["invoke","meta data"],"updatePoint":{"line":2800,"column":125},"line":2800,"code":"  it('done.invoke events should only select onDone transition on the invoking state when invokee is referenced using a string', (done) => {\n    let counter = 0;\n    let invoked = false;\n\n    const createSingleState = (): any => ({\n      initial: 'fetch',\n      states: {\n        fetch: {\n          invoke: {\n            src: 'fetchSmth',\n            onDone: {\n              actions: 'handleSuccess'\n            }\n          }\n        }\n      }\n    });\n\n    const testMachine = createMachine(\n      {\n        type: 'parallel',\n        states: {\n          first: createSingleState(),\n          second: createSingleState()\n        }\n      },\n      {\n        actions: {\n          handleSuccess: () => {\n            ++counter;\n          }\n        },\n        services: {\n          fetchSmth: () => {\n            if (invoked) {\n              // create a promise that won't ever resolve for the second invoking state\n              return new Promise(() => {});\n            }\n            invoked = true;\n            return Promise.resolve(42);\n          }\n        }\n      }\n    );\n\n    interpret(testMachine).start();\n\n    // check within a macrotask so all promise-induced microtasks have a chance to resolve first\n    setTimeout(() => {\n      expect(counter).toEqual(1);\n      done();\n    }, 0);\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"done.invoke events should have unique names when invokee is a machine with an id property","suites":["invoke","meta data"],"updatePoint":{"line":2854,"column":95},"line":2854,"code":"  it('done.invoke events should have unique names when invokee is a machine with an id property', (done) => {\n    const actual: string[] = [];\n\n    const childMachine = createMachine({\n      id: 'child',\n      initial: 'a',\n      states: {\n        a: {\n          invoke: {\n            src: () => Promise.resolve(42),\n            onDone: 'b'\n          }\n        },\n        b: {\n          type: 'final'\n        }\n      }\n    });\n\n    const createSingleState = (): any => ({\n      initial: 'fetch',\n      states: {\n        fetch: {\n          invoke: childMachine\n        }\n      }\n    });\n\n    const testMachine = createMachine({\n      type: 'parallel',\n      states: {\n        first: createSingleState(),\n        second: createSingleState()\n      },\n      on: {\n        '*': {\n          actions: (_ctx, ev) => {\n            actual.push(ev.type);\n          }\n        }\n      }\n    });\n\n    interpret(testMachine).start();\n\n    // check within a macrotask so all promise-induced microtasks have a chance to resolve first\n    setTimeout(() => {\n      expect(actual).toEqual([\n        'done.invoke.(machine).first.fetch:invocation[0]',\n        'done.invoke.(machine).second.fetch:invocation[0]'\n      ]);\n      done();\n    }, 0);\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide data params to a service creator","suites":["services option"],"updatePoint":{"line":2911,"column":53},"line":2911,"code":"  it('should provide data params to a service creator', (done) => {\n    const machine = createMachine(\n      {\n        initial: 'pending',\n        context: {\n          count: 42\n        },\n        states: {\n          pending: {\n            invoke: {\n              src: 'stringService',\n              data: {\n                staticVal: 'hello',\n                newCount: (ctx: any) => ctx.count * 2\n              },\n              onDone: 'success'\n            }\n          },\n          success: {\n            type: 'final'\n          }\n        }\n      },\n      {\n        services: {\n          stringService: (ctx, _, { data }) => {\n            expect(ctx).toEqual({ count: 42 });\n\n            expect(data).toEqual({ newCount: 84, staticVal: 'hello' });\n\n            return new Promise<void>((res) => {\n              res();\n            });\n          }\n        }\n      }\n    );\n\n    const service = interpret(machine).onDone(() => {\n      done();\n    });\n\n    service.start();\n  });","file":"invoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should serialize the machine","suites":["json"],"updatePoint":{"line":10,"column":34},"line":10,"code":"  it('should serialize the machine', () => {\n    const machine = createMachine<{ [key: string]: any }>({\n      initial: 'foo',\n      version: '1.0.0',\n      context: {\n        number: 0,\n        string: 'hello'\n      },\n      invoke: [{ id: 'invokeId', src: 'invokeSrc', autoForward: true }],\n      states: {\n        testActions: {\n          invoke: [{ id: 'invokeId', src: 'invokeSrc', autoForward: true }],\n          entry: [\n            'stringActionType',\n            {\n              type: 'objectActionType'\n            },\n            {\n              type: 'objectActionTypeWithExec',\n              exec: () => {\n                return true;\n              },\n              other: 'any'\n            },\n            function actionFunction() {\n              return true;\n            },\n            assign({\n              number: 10,\n              string: 'test',\n              evalNumber: () => 42\n            }),\n            assign((ctx) => ({\n              ...ctx\n            }))\n          ],\n          on: {\n            TO_FOO: {\n              target: ['foo', 'bar'],\n              cond: (ctx) => !!ctx.string\n            }\n          },\n          after: {\n            1000: 'bar'\n          }\n        },\n        foo: {},\n        bar: {},\n        testHistory: {\n          type: 'history',\n          history: 'deep'\n        },\n        testFinal: {\n          type: 'final',\n          data: {\n            something: 'else'\n          }\n        },\n        testParallel: {\n          type: 'parallel',\n          states: {\n            one: {\n              initial: 'inactive',\n              states: {\n                inactive: {}\n              }\n            },\n            two: {\n              initial: 'inactive',\n              states: {\n                inactive: {}\n              }\n            }\n          }\n        }\n      }\n    });\n\n    const json = JSON.parse(JSON.stringify(machine.definition));\n\n    try {\n      validate(json);\n    } catch (err: any) {\n      throw new Error(JSON.stringify(JSON.parse(err.message), null, 2));\n    }\n\n    expect(validate.errors).toBeNull();\n  });","file":"json.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should detect an invalid machine","suites":["json"],"updatePoint":{"line":99,"column":38},"line":99,"code":"  it('should detect an invalid machine', () => {\n    const invalidMachineConfig = {\n      id: 'something',\n      key: 'something',\n      type: 'invalid type',\n      states: {}\n    };\n\n    validate(invalidMachineConfig);\n    expect(validate.errors).not.toBeNull();\n  });","file":"json.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not double-serialize invoke transitions","suites":["json"],"updatePoint":{"line":111,"column":52},"line":111,"code":"  it('should not double-serialize invoke transitions', () => {\n    const machine = createMachine({\n      initial: 'active',\n      states: {\n        active: {\n          invoke: {\n            src: 'someSrc',\n            onDone: 'foo',\n            onError: 'bar'\n          },\n          on: {\n            EVENT: 'foo'\n          }\n        },\n        foo: {},\n        bar: {}\n      }\n    });\n\n    const machineJSON = JSON.stringify(machine);\n\n    const machineObject = JSON.parse(machineJSON);\n\n    const revivedMachine = createMachine(machineObject);\n\n    expect(revivedMachine.states.active.transitions).toMatchInlineSnapshot(`\n      Array [\n        Object {\n          \"actions\": Array [],\n          \"cond\": undefined,\n          \"event\": \"done.invoke.(machine).active:invocation[0]\",\n          \"eventType\": \"done.invoke.(machine).active:invocation[0]\",\n          \"internal\": false,\n          \"source\": \"#(machine).active\",\n          \"target\": Array [\n            \"#(machine).foo\",\n          ],\n          \"toJSON\": [Function],\n        },\n        Object {\n          \"actions\": Array [],\n          \"cond\": undefined,\n          \"event\": \"error.platform.(machine).active:invocation[0]\",\n          \"eventType\": \"error.platform.(machine).active:invocation[0]\",\n          \"internal\": false,\n          \"source\": \"#(machine).active\",\n          \"target\": Array [\n            \"#(machine).bar\",\n          ],\n          \"toJSON\": [Function],\n        },\n        Object {\n          \"actions\": Array [],\n          \"cond\": undefined,\n          \"event\": \"EVENT\",\n          \"eventType\": \"EVENT\",\n          \"internal\": false,\n          \"source\": \"#(machine).active\",\n          \"target\": Array [\n            \"#(machine).foo\",\n          ],\n          \"toJSON\": [Function],\n        },\n      ]\n    `);\n\n    // 1. onDone\n    // 2. onError\n    // 3. EVENT\n    expect(revivedMachine.states.active.transitions.length).toBe(3);\n  });","file":"json.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly register machine states","suites":["machine","machine.states"],"updatePoint":{"line":90,"column":47},"line":90,"code":"    it('should properly register machine states', () => {\n      expect(Object.keys(lightMachine.states)).toEqual([\n        'green',\n        'yellow',\n        'red'\n      ]);\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the set of events accepted by machine","suites":["machine","machine.events"],"updatePoint":{"line":100,"column":59},"line":100,"code":"    it('should return the set of events accepted by machine', () => {\n      expect(lightMachine.events).toEqual([\n        'TIMER',\n        'POWER_OUTAGE',\n        'PED_COUNTDOWN'\n      ]);\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return a State instance","suites":["machine","machine.initialState"],"updatePoint":{"line":110,"column":38},"line":110,"code":"    it('should return a State instance', () => {\n      expect(lightMachine.initialState).toBeInstanceOf(State);\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the initial state","suites":["machine","machine.initialState"],"updatePoint":{"line":114,"column":39},"line":114,"code":"    it('should return the initial state', () => {\n      expect(lightMachine.initialState.value).toEqual('green');\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not retain previous history","suites":["machine","machine.history"],"updatePoint":{"line":120,"column":42},"line":120,"code":"    it('should not retain previous history', () => {\n      const next = lightMachine.transition(lightMachine.initialState, 'TIMER');\n      const following = lightMachine.transition(next, 'TIMER');\n      expect(following!.history!.history).not.toBeDefined();\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state node config should reference original machine config","suites":["machine","machine.config"],"updatePoint":{"line":128,"column":66},"line":128,"code":"    it('state node config should reference original machine config', () => {\n      const machine = Machine({\n        initial: 'one',\n        states: {\n          one: {\n            initial: 'deep',\n            states: {\n              deep: {}\n            }\n          }\n        }\n      });\n\n      const oneState = machine.getStateNodeByPath(['one']);\n\n      expect(oneState.config).toBe(machine.config.states!.one);\n\n      const deepState = machine.getStateNodeByPath(['one', 'deep']);\n\n      expect(deepState.config).toBe(machine.config.states!.one.states!.deep);\n\n      deepState.config.meta = 'testing meta';\n\n      expect(machine.config.states!.one.states!.deep.meta).toEqual(\n        'testing meta'\n      );\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should override guards and actions","suites":["machine","machine.withConfig"],"updatePoint":{"line":158,"column":42},"line":158,"code":"    it('should override guards and actions', () => {\n      const differentMachine = configMachine.withConfig({\n        actions: {\n          entryAction: () => {\n            throw new Error('new entry');\n          }\n        },\n        guards: { someCondition: () => true }\n      });\n\n      expect(differentMachine.context).toEqual({ foo: 'bar' });\n\n      const service = interpret(differentMachine);\n\n      expect(() => service.start()).toThrowErrorMatchingInlineSnapshot(\n        `\"new entry\"`\n      );\n\n      expect(differentMachine.transition('foo', 'EVENT').value).toEqual('bar');\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not override context if not defined","suites":["machine","machine.withConfig"],"updatePoint":{"line":179,"column":50},"line":179,"code":"    it('should not override context if not defined', () => {\n      const differentMachine = configMachine.withConfig({});\n\n      expect(differentMachine.initialState.context).toEqual(\n        configMachine.context\n      );\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should override context (second argument)","suites":["machine","machine.withConfig"],"updatePoint":{"line":187,"column":49},"line":187,"code":"    it('should override context (second argument)', () => {\n      const differentMachine = configMachine.withConfig(\n        {},\n        { foo: 'different' }\n      );\n\n      expect(differentMachine.initialState.context).toEqual({\n        foo: 'different'\n      });\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow for lazy context to be used with `withConfig`","suites":["machine","machine.withConfig"],"updatePoint":{"line":198,"column":66},"line":198,"code":"    it('should allow for lazy context to be used with `withConfig`', () => {\n      const machine = createMachine({\n        context: { foo: { prop: 'bar' } }\n      });\n      const copiedMachine = machine.withConfig({}, () => ({\n        foo: { prop: 'baz' }\n      }));\n      expect(copiedMachine.initialState.context).toEqual({\n        foo: { prop: 'baz' }\n      });\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should lazily create context for all interpreter instances created from the same machine template created by `withConfig`","suites":["machine","machine.withConfig"],"updatePoint":{"line":210,"column":129},"line":210,"code":"    it('should lazily create context for all interpreter instances created from the same machine template created by `withConfig`', () => {\n      const machine = createMachine({\n        context: { foo: { prop: 'bar' } }\n      });\n\n      const copiedMachine = machine.withConfig({}, () => ({\n        foo: { prop: 'baz' }\n      }));\n\n      const a = interpret(copiedMachine).start();\n      const b = interpret(copiedMachine).start();\n\n      expect(a.state.context.foo).not.toBe(b.state.context.foo);\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"context from a function should be lazily evaluated","suites":["machine","machine function context"],"updatePoint":{"line":227,"column":58},"line":227,"code":"    it('context from a function should be lazily evaluated', () => {\n      const testMachineConfig = {\n        initial: 'active',\n        context: () => ({\n          foo: { bar: 'baz' }\n        }),\n        states: {\n          active: {}\n        }\n      };\n\n      const testMachine1 = Machine(testMachineConfig);\n      const testMachine2 = Machine(testMachineConfig);\n\n      expect(testMachine1.initialState.context).not.toBe(\n        testMachine2.initialState.context\n      );\n\n      expect(testMachine1.initialState.context).toEqual({\n        foo: { bar: 'baz' }\n      });\n\n      expect(testMachine2.initialState.context).toEqual({\n        foo: { bar: 'baz' }\n      });\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve the state value","suites":["machine","machine.resolveState()"],"updatePoint":{"line":295,"column":38},"line":295,"code":"    it('should resolve the state value', () => {\n      const tempState = State.from<any>('foo');\n\n      const resolvedState = resolveMachine.resolveState(tempState);\n\n      expect(resolvedState.value).toEqual({\n        foo: { one: { a: 'aa', b: 'bb' } }\n      });\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve the state configuration (implicit via events)","suites":["machine","machine.resolveState()"],"updatePoint":{"line":305,"column":68},"line":305,"code":"    it('should resolve the state configuration (implicit via events)', () => {\n      const tempState = State.from<any>('foo');\n\n      const resolvedState = resolveMachine.resolveState(tempState);\n\n      expect(resolvedState.nextEvents.sort()).toEqual(['TO_BAR', 'TO_TWO']);\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve .done","suites":["machine","machine.resolveState()"],"updatePoint":{"line":313,"column":28},"line":313,"code":"    it('should resolve .done', () => {\n      const machine = createMachine({\n        initial: 'foo',\n        states: {\n          foo: {\n            on: { NEXT: 'bar' }\n          },\n          bar: {\n            type: 'final'\n          }\n        }\n      });\n      const tempState = State.from<any>('bar');\n\n      const resolvedState = machine.resolveState(tempState);\n\n      expect(resolvedState.done).toBe(true);\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve from a state config object","suites":["machine","machine.resolveState()"],"updatePoint":{"line":332,"column":49},"line":332,"code":"    it('should resolve from a state config object', () => {\n      const machine = createMachine({\n        initial: 'foo',\n        states: {\n          foo: {\n            on: { NEXT: 'bar' }\n          },\n          bar: {\n            type: 'final'\n          }\n        }\n      });\n\n      const barState = machine.transition(undefined, 'NEXT');\n\n      const jsonBarState = JSON.parse(JSON.stringify(barState));\n\n      expect(machine.resolveState(jsonBarState).matches('bar')).toBeTruthy();\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should terminate on a resolved final state","suites":["machine","machine.resolveState()"],"updatePoint":{"line":352,"column":50},"line":352,"code":"    it('should terminate on a resolved final state', (done) => {\n      const machine = createMachine({\n        initial: 'foo',\n        states: {\n          foo: {\n            on: { NEXT: 'bar' }\n          },\n          bar: {\n            type: 'final'\n          }\n        }\n      });\n\n      const nextState = machine.transition(undefined, 'NEXT');\n\n      const persistedState = JSON.stringify(nextState);\n\n      const service = interpret(machine).onDone(() => {\n        // Should reach done state immediately\n        done();\n      });\n\n      service.start(JSON.parse(persistedState!));\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow a version to be specified","suites":["machine","versioning"],"updatePoint":{"line":379,"column":46},"line":379,"code":"    it('should allow a version to be specified', () => {\n      const versionMachine = Machine({\n        id: 'version',\n        version: '1.0.4',\n        states: {}\n      });\n\n      expect(versionMachine.version).toEqual('1.0.4');\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should show the version on state nodes","suites":["machine","versioning"],"updatePoint":{"line":389,"column":46},"line":389,"code":"    it('should show the version on state nodes', () => {\n      const versionMachine = Machine({\n        id: 'version',\n        version: '1.0.4',\n        states: {\n          foo: {\n            id: 'foo'\n          }\n        }\n      });\n\n      const fooStateNode = versionMachine.getStateNodeById('foo');\n\n      expect(fooStateNode.version).toEqual('1.0.4');\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should represent the ID","suites":["machine","id"],"updatePoint":{"line":407,"column":31},"line":407,"code":"    it('should represent the ID', () => {\n      const idMachine = Machine({\n        id: 'some-id',\n        initial: 'idle',\n        states: { idle: {} }\n      });\n\n      expect(idMachine.id).toEqual('some-id');\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should represent the ID (state node)","suites":["machine","id"],"updatePoint":{"line":417,"column":44},"line":417,"code":"    it('should represent the ID (state node)', () => {\n      const idMachine = Machine({\n        id: 'some-id',\n        initial: 'idle',\n        states: {\n          idle: {\n            id: 'idle'\n          }\n        }\n      });\n\n      expect(idMachine.getStateNode('idle').id).toEqual('idle');\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should use the key as the ID if no ID is provided","suites":["machine","id"],"updatePoint":{"line":431,"column":57},"line":431,"code":"    it('should use the key as the ID if no ID is provided', () => {\n      const noIDMachine = Machine({\n        key: 'some-key',\n        initial: 'idle',\n        states: { idle: {} }\n      });\n\n      expect(noIDMachine.id).toEqual('some-key');\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should use the key as the ID if no ID is provided (state node)","suites":["machine","id"],"updatePoint":{"line":441,"column":70},"line":441,"code":"    it('should use the key as the ID if no ID is provided (state node)', () => {\n      const noStateNodeIDMachine = Machine({\n        id: 'some-id',\n        initial: 'idle',\n        states: { idle: {} }\n      });\n\n      expect(noStateNodeIDMachine.getStateNode('idle').id).toEqual(\n        'some-id.idle'\n      );\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should support combinatorial machines (single-state)","suites":["machine","combinatorial machines"],"updatePoint":{"line":455,"column":60},"line":455,"code":"    it('should support combinatorial machines (single-state)', () => {\n      const testMachine = createMachine<{ value: number }>({\n        context: { value: 42 },\n        on: {\n          INC: {\n            actions: assign({ value: (ctx) => ctx.value + 1 })\n          }\n        }\n      });\n\n      const state = testMachine.initialState;\n\n      expect(state.value).toEqual({});\n\n      const nextState = testMachine.transition(state, 'INC');\n\n      expect(nextState.context.value).toEqual(43);\n    });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should list transitions","suites":["StateNode"],"updatePoint":{"line":477,"column":29},"line":477,"code":"  it('should list transitions', () => {\n    const greenNode = lightMachine.states.green;\n\n    const transitions = greenNode.transitions;\n\n    expect(transitions.map((t) => t.eventType)).toEqual([\n      'TIMER',\n      'POWER_OUTAGE',\n      'FORBIDDEN_EVENT'\n    ]);\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the first mapping found of a state","suites":["mapState()"],"updatePoint":{"line":4,"column":54},"line":4,"code":"  it('should return the first mapping found of a state', () => {\n    const mapping = mapState(\n      {\n        a: 'state a',\n        b: 'state b'\n      },\n      'b'\n    );\n\n    expect(mapping).toBe('state b');\n  });","file":"mapState.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined for unmapped states","suites":["mapState()"],"updatePoint":{"line":16,"column":49},"line":16,"code":"  it('should return undefined for unmapped states', () => {\n    const mapping = mapState(\n      {\n        a: 'state a',\n        b: 'state b'\n      },\n      'c'\n    );\n\n    expect(mapping).not.toBeDefined();\n  });","file":"mapState.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should prioritize returning equivalent state mapping","suites":["mapState()"],"updatePoint":{"line":28,"column":58},"line":28,"code":"  it('should prioritize returning equivalent state mapping', () => {\n    const mapping = mapState(\n      {\n        a: 'state a',\n        b: 'state b',\n        'b.b1': 'st b.b1'\n      },\n      'b.b1'\n    );\n\n    expect(mapping).toBe('st b.b1');\n  });","file":"mapState.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return superstate mapping when substate is not found","suites":["mapState()"],"updatePoint":{"line":41,"column":65},"line":41,"code":"  it('should return superstate mapping when substate is not found', () => {\n    const mapping = mapState(\n      {\n        a: 'state a',\n        b: 'state b',\n        'b.b1': 'st b.b1'\n      },\n      'b.foo'\n    );\n\n    expect(mapping).toBe('state b');\n  });","file":"mapState.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return superstate mapping when deep substate is not found","suites":["mapState()"],"updatePoint":{"line":54,"column":70},"line":54,"code":"  it('should return superstate mapping when deep substate is not found', () => {\n    const mapping = mapState(\n      {\n        a: 'state a',\n        b: 'state b',\n        'b.b1': 'state b.b1'\n      },\n      'b.b1.foo'\n    );\n\n    expect(mapping).toBe('state b.b1');\n  });","file":"mapState.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should match a value from a pattern with the state (simple)","suites":["matchState()"],"updatePoint":{"line":11,"column":65},"line":11,"code":"  it('should match a value from a pattern with the state (simple)', () => {\n    const simpleState = State.from('a', undefined);\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          ['b', () => false],\n          ['a', () => true],\n          [{ a: 'b' }, () => false]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should match a value from a pattern with the state value","suites":["matchState()"],"updatePoint":{"line":27,"column":62},"line":27,"code":"  it('should match a value from a pattern with the state value', () => {\n    expect(\n      matchState(\n        'a',\n        [\n          ['b', () => false],\n          ['a', () => true],\n          [{ a: 'b' }, () => false]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should match a value from a pattern with the state (compound)","suites":["matchState()"],"updatePoint":{"line":41,"column":67},"line":41,"code":"  it('should match a value from a pattern with the state (compound)', () => {\n    const simpleState = State.from({ a: 'b' }, undefined);\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          ['b', () => false],\n          [{ a: { b: 'c' } }, () => false],\n          [{ a: 'b' }, () => true],\n          ['a', () => false]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should match a value from a pattern with the state (compound, ancestor)","suites":["matchState()"],"updatePoint":{"line":58,"column":77},"line":58,"code":"  it('should match a value from a pattern with the state (compound, ancestor)', () => {\n    const simpleState = State.from({ a: 'b' }, undefined);\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          ['b', () => false],\n          [{ a: { b: 'c' } }, () => false],\n          ['a', () => true],\n          [{ a: 'b' }, () => false]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should match a value from a pattern with the state (parallel)","suites":["matchState()"],"updatePoint":{"line":75,"column":67},"line":75,"code":"  it('should match a value from a pattern with the state (parallel)', () => {\n    const simpleState = State.from(\n      { a: 'b', c: { d: 'e', f: 'g' } },\n      undefined\n    );\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          [{ a: {}, b: {} }, () => false],\n          [{ a: { b: 'c' } }, () => false],\n          ['a', () => true],\n          [{ a: 'b' }, () => false]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          [{ a: {}, b: {} }, () => false],\n          [{ a: { b: 'c' } }, () => false],\n          [{ a: 'b', c: 'e' }, () => false],\n          [{ a: 'b' }, () => true]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          [{ a: {}, b: {} }, () => false],\n          [{ a: { b: 'c' } }, () => false],\n          [{ a: 'b', c: 'e' }, () => false],\n          [{ a: 'b', c: {} }, () => true]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          [{ a: {}, b: {} }, () => false],\n          [{ a: { b: 'c' } }, () => false],\n          [{ a: 'b', c: 'e' }, () => false],\n          [{ a: 'b', c: { d: 'e' } }, () => true]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          [{ a: {}, b: {} }, () => false],\n          [{ a: { b: 'c' } }, () => false],\n          [{ a: 'b', c: 'e' }, () => false],\n          [{ a: 'b', c: { d: 'e', f: 'g' } }, () => true]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          [{ a: {}, b: {} }, () => false],\n          [{ a: { b: 'c' } }, () => false],\n          [{ a: 'b', c: 'e' }, () => false],\n          [{ c: {} }, () => true]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          [{ a: {}, b: {} }, () => false],\n          [{ a: { b: 'c' } }, () => false],\n          [{ a: 'b', c: 'e' }, () => false],\n          [{ c: { d: 'e' } }, () => true]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchState(\n        simpleState,\n        [\n          [{ a: {}, b: {} }, () => false],\n          [{ a: { b: 'c' } }, () => false],\n          [{ a: 'b', c: 'e' }, () => false],\n          [{ c: { d: 'e', f: 'g' } }, () => true]\n        ],\n        (_) => false\n      )\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should fallback to default if no pattern matched","suites":["matchState()"],"updatePoint":{"line":186,"column":54},"line":186,"code":"  it('should fallback to default if no pattern matched', () => {\n    const simpleState = State.from('a', undefined);\n\n    expect(\n      matchState(simpleState, [['b', () => false]], (_) => true)\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if two states are equivalent","suites":["matchesState()"],"updatePoint":{"line":196,"column":53},"line":196,"code":"  it('should return true if two states are equivalent', () => {\n    expect(matchesState('a', 'a')).toBeTruthy();\n\n    expect(matchesState('b.b1', 'b.b1')).toBeTruthy();\n\n    expect(matchesState('B.bar', { A: 'foo' })).toBe(false);\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if two state values are equivalent","suites":["matchesState()"],"updatePoint":{"line":204,"column":59},"line":204,"code":"  it('should return true if two state values are equivalent', () => {\n    expect(matchesState({ a: 'b' }, { a: 'b' })).toBeTruthy();\n    expect(matchesState({ a: { b: 'c' } }, { a: { b: 'c' } })).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if two parallel states are equivalent","suites":["matchesState()"],"updatePoint":{"line":209,"column":62},"line":209,"code":"  it('should return true if two parallel states are equivalent', () => {\n    expect(\n      matchesState(\n        { a: { b1: 'foo', b2: 'bar' } },\n        { a: { b1: 'foo', b2: 'bar' } }\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchesState(\n        { a: { b1: 'foo', b2: 'bar' }, b: { b3: 'baz', b4: 'quo' } },\n        { a: { b1: 'foo', b2: 'bar' }, b: { b3: 'baz', b4: 'quo' } }\n      )\n    ).toBeTruthy();\n\n    expect(\n      matchesState({ a: 'foo', b: 'bar' }, { a: 'foo', b: 'bar' })\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if a state is a substate of a superstate","suites":["matchesState()"],"updatePoint":{"line":229,"column":65},"line":229,"code":"  it('should return true if a state is a substate of a superstate', () => {\n    expect(matchesState('b', 'b.b1')).toBeTruthy();\n\n    expect(matchesState('foo.bar', 'foo.bar.baz.quo')).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if a state value is a substate of a superstate value","suites":["matchesState()"],"updatePoint":{"line":235,"column":77},"line":235,"code":"  it('should return true if a state value is a substate of a superstate value', () => {\n    expect(matchesState('b', { b: 'b1' })).toBeTruthy();\n\n    expect(\n      matchesState({ foo: 'bar' }, { foo: { bar: { baz: 'quo' } } })\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if a parallel state value is a substate of a superstate value","suites":["matchesState()"],"updatePoint":{"line":243,"column":86},"line":243,"code":"  it('should return true if a parallel state value is a substate of a superstate value', () => {\n    expect(matchesState('b', { b: 'b1', c: 'c1' })).toBeTruthy();\n\n    expect(\n      matchesState(\n        { foo: 'bar', fooAgain: 'barAgain' },\n        { foo: { bar: { baz: 'quo' } }, fooAgain: { barAgain: 'baz' } }\n      )\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if two states are not equivalent","suites":["matchesState()"],"updatePoint":{"line":254,"column":58},"line":254,"code":"  it('should return false if two states are not equivalent', () => {\n    expect(!matchesState('a', 'b')).toBeTruthy();\n\n    expect(!matchesState('a.a1', 'b.b1')).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if parent state is more specific than child state","suites":["matchesState()"],"updatePoint":{"line":260,"column":75},"line":260,"code":"  it('should return false if parent state is more specific than child state', () => {\n    expect(!matchesState('a.b.c', 'a.b')).toBeTruthy();\n\n    expect(!matchesState({ a: { b: { c: 'd' } } }, { a: 'b' })).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if two state values are not equivalent","suites":["matchesState()"],"updatePoint":{"line":266,"column":64},"line":266,"code":"  it('should return false if two state values are not equivalent', () => {\n    expect(!matchesState({ a: 'a1' }, { b: 'b1' })).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if a state is not a substate of a superstate","suites":["matchesState()"],"updatePoint":{"line":270,"column":70},"line":270,"code":"  it('should return false if a state is not a substate of a superstate', () => {\n    expect(!matchesState('a', 'b.b1')).toBeTruthy();\n\n    expect(!matchesState('foo.false.baz', 'foo.bar.baz.quo')).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if a state value is not a substate of a superstate value","suites":["matchesState()"],"updatePoint":{"line":276,"column":82},"line":276,"code":"  it('should return false if a state value is not a substate of a superstate value', () => {\n    expect(!matchesState('a', { b: 'b1' })).toBeTruthy();\n\n    expect(\n      !matchesState({ foo: { false: 'baz' } }, { foo: { bar: { baz: 'quo' } } })\n    ).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should mix/match string state values and object state values","suites":["matchesState()"],"updatePoint":{"line":284,"column":66},"line":284,"code":"  it('should mix/match string state values and object state values', () => {\n    expect(matchesState('a.b.c', { a: { b: 'c' } })).toBeTruthy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute matchesState on a State given the parent state value","suites":["matches() method"],"updatePoint":{"line":290,"column":73},"line":290,"code":"  it('should execute matchesState on a State given the parent state value', () => {\n    const machine = Machine({\n      initial: 'foo',\n      states: {\n        foo: {\n          initial: 'bar',\n          states: {\n            bar: {\n              initial: 'baz',\n              states: {\n                baz: {}\n              }\n            }\n          }\n        }\n      }\n    });\n\n    expect(machine.initialState.matches('foo')).toBeTruthy();\n    expect(machine.initialState.matches({ foo: 'bar' })).toBeTruthy();\n    expect(machine.initialState.matches('fake')).toBeFalsy();\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should compile with typed matches (createMachine)","suites":["matches() method"],"updatePoint":{"line":313,"column":55},"line":313,"code":"  it('should compile with typed matches (createMachine)', () => {\n    interface TestContext {\n      count?: number;\n      user?: { name: string };\n    }\n\n    type TestState =\n      | {\n          value: 'loading';\n          context: { count: number; user: undefined };\n        }\n      | {\n          value: 'loaded';\n          context: { user: { name: string } };\n        };\n\n    const machine = createMachine<TestContext, any, TestState>({\n      initial: 'loading',\n      states: {\n        loading: {\n          initial: 'one',\n          states: {\n            one: {},\n            two: {}\n          }\n        },\n        loaded: {}\n      }\n    });\n\n    const init = machine.initialState;\n\n    if (init.matches('loaded')) {\n      const name = init.context.user.name;\n\n      // never called - it's okay if the name is undefined\n      expect(name).toBeTruthy();\n    } else if (init.matches('loading')) {\n      // Make sure init isn't \"never\" - if it is, tests should fail to compile\n      expect(init).toBeTruthy();\n    }\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should compile with conditional matches even without a specified Typestate","suites":["matches() method"],"updatePoint":{"line":356,"column":80},"line":356,"code":"  it('should compile with conditional matches even without a specified Typestate', () => {\n    const toggleMachine = createMachine<{ foo: number }>({\n      id: 'toggle',\n      context: {\n        foo: 0\n      },\n      initial: 'a',\n      states: {\n        a: { on: { TOGGLE: 'b' } },\n        b: { on: { TOGGLE: 'a' } }\n      }\n    });\n\n    const state = toggleMachine.initialState;\n\n    if (state.matches('a') || state.matches('b')) {\n      // This should be a `number` type\n      state.context.foo;\n\n      // Make sure state isn't \"never\" - if it is, tests should fail to compile\n      expect(state).toBeTruthy();\n    }\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should compile with a typestate value that is a union","suites":["matches() method"],"updatePoint":{"line":380,"column":59},"line":380,"code":"  it('should compile with a typestate value that is a union', (done) => {\n    interface MachineContext {\n      countObject:\n        | {\n            count: number;\n          }\n        | undefined;\n    }\n\n    type MachineEvent = { type: 'TOGGLE' };\n\n    type MachineTypestate =\n      | {\n          value: 'active' | { other: 'one' };\n          context: MachineContext & { countObject: { count: number } };\n        }\n      | {\n          value: 'inactive';\n          context: MachineContext;\n        };\n\n    const machine = createMachine<\n      MachineContext,\n      MachineEvent,\n      MachineTypestate\n    >({\n      initial: 'active',\n      context: {\n        countObject: { count: 0 }\n      },\n      states: {\n        inactive: {\n          entry: assign({\n            countObject: undefined\n          }),\n          on: { TOGGLE: 'active' }\n        },\n        active: {\n          entry: assign({\n            countObject: (ctx) => ({\n              count: (ctx.countObject?.count ?? 0) + 1\n            })\n          }),\n          on: { TOGGLE: 'other' }\n        },\n        other: {\n          on: { TOGGLE: 'active' },\n          initial: 'one',\n          states: {\n            one: {}\n          }\n        }\n      }\n    });\n\n    const state = machine.initialState;\n\n    if (state.matches('active')) {\n      expect(state.context.countObject.count).toBe(1);\n      done();\n    }\n  });","file":"match.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"states should aggregate meta data","suites":["state meta data"],"updatePoint":{"line":75,"column":39},"line":75,"code":"  it('states should aggregate meta data', () => {\n    const yellowState = lightMachine.transition('green', 'TIMER');\n    expect(yellowState.meta).toEqual({\n      'light.yellow': {\n        yellowData: 'yellow data'\n      }\n    });\n    expect('light.green' in yellowState.meta).toBeFalsy();\n    expect('light' in yellowState.meta).toBeFalsy();\n  });","file":"meta.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"states should aggregate meta data (deep)","suites":["state meta data"],"updatePoint":{"line":86,"column":46},"line":86,"code":"  it('states should aggregate meta data (deep)', () => {\n    expect(lightMachine.transition('yellow', 'TIMER').meta).toEqual({\n      'light.red': {\n        redData: {\n          nested: {\n            array: [1, 2, 3],\n            red: 'data'\n          }\n        }\n      },\n      'light.red.walk': {\n        walkData: 'walk data'\n      }\n    });\n  });","file":"meta.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"services started from a persisted state should calculate meta data","suites":["state meta data"],"updatePoint":{"line":103,"column":72},"line":103,"code":"  it('services started from a persisted state should calculate meta data', (done) => {\n    const machine = createMachine({\n      id: 'test',\n      initial: 'first',\n      states: {\n        first: {\n          meta: {\n            name: 'first state'\n          }\n        },\n        second: {\n          meta: {\n            name: 'second state'\n          }\n        }\n      }\n    });\n\n    const service = interpret(machine).onTransition((state) => {\n      expect(state.meta).toEqual({\n        'test.second': {\n          name: 'second state'\n        }\n      });\n      done();\n    });\n    service.start('second');\n  });","file":"meta.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should show meta data in transitions","suites":["transition meta data"],"updatePoint":{"line":134,"column":42},"line":134,"code":"  it('should show meta data in transitions', () => {\n    const machine = createMachine({\n      initial: 'inactive',\n      states: {\n        inactive: {\n          on: {\n            EVENT: {\n              target: 'active',\n              meta: {\n                description: 'Going from inactive to active'\n              }\n            }\n          }\n        },\n        active: {}\n      }\n    });\n\n    const nextState = machine.transition(undefined, 'EVENT');\n\n    expect(nextState.transitions.map((t) => t.meta)).toMatchInlineSnapshot(`\n      Array [\n        Object {\n          \"description\": \"Going from inactive to active\",\n        },\n      ]\n    `);\n  });","file":"meta.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state node should have its description","suites":["state description"],"updatePoint":{"line":165,"column":44},"line":165,"code":"  it('state node should have its description', () => {\n    const machine = createMachine({\n      initial: 'test',\n      states: {\n        test: {\n          description: 'This is a test'\n        }\n      }\n    });\n\n    expect(machine.states.test.description).toEqual('This is a test');\n  });","file":"meta.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"state node should have its description","suites":["transition description"],"updatePoint":{"line":180,"column":44},"line":180,"code":"  it('state node should have its description', () => {\n    const machine = createMachine({\n      on: {\n        EVENT: {\n          description: 'This is a test'\n        }\n      }\n    });\n\n    expect(machine.on['EVENT'][0].description).toEqual('This is a test');\n  });","file":"meta.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"model.assign updates context and is typed correctly","suites":["createModel"],"updatePoint":{"line":15,"column":57},"line":15,"code":"  it('model.assign updates context and is typed correctly', () => {\n    type UserEvent =\n      | {\n          type: 'updateName';\n          value: string;\n        }\n      | { type: 'updateAge'; value: number }\n      | { type: 'anotherEvent' };\n\n    interface UserContext {\n      name: string;\n      age: number;\n    }\n\n    const userModel = createModel<UserContext, UserEvent>({\n      name: 'David',\n      age: 30\n    });\n\n    // Example of an externally-defined assign action\n    const assignName = userModel.assign(\n      {\n        name: (_, event) => {\n          return event.value;\n        }\n      },\n      'updateName'\n    );\n\n    const machine = createMachine<UserContext, UserEvent>({\n      context: userModel.initialContext,\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            updateName: {\n              // pre-defined assign action\n              actions: assignName\n            },\n            updateAge: {\n              // inline assign action\n              actions: userModel.assign((_, e) => {\n                return {\n                  age: e.value\n                };\n              })\n            }\n          }\n        }\n      }\n    });\n\n    const updatedState = machine.transition(undefined, {\n      type: 'updateName',\n      value: 'Anyone'\n    });\n\n    expect(updatedState.context.name).toEqual('Anyone');\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"model.reset resets the context to its initial value","suites":["createModel"],"updatePoint":{"line":75,"column":57},"line":75,"code":"  it('model.reset resets the context to its initial value', () => {\n    type UserEvent =\n      | {\n          type: 'updateName';\n          value: string;\n        }\n      | { type: 'updateAge'; value: number }\n      | { type: 'reset' };\n\n    interface UserContext {\n      name: string;\n      age: number;\n    }\n\n    const userModel = createModel<UserContext, UserEvent>({\n      name: 'David',\n      age: 30\n    });\n\n    // Example of an externally-defined assign action\n    const assignName = userModel.assign(\n      {\n        name: (_, event) => {\n          return event.value;\n        }\n      },\n      'updateName'\n    );\n\n    const machine = createMachine<UserContext, UserEvent>({\n      context: userModel.initialContext,\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            updateName: {\n              // pre-defined assign action\n              actions: assignName\n            },\n            updateAge: {\n              // inline assign action\n              actions: userModel.assign((_, e) => {\n                return {\n                  age: e.value\n                };\n              })\n            },\n            reset: {\n              actions: userModel.reset()\n            }\n          }\n        }\n      }\n    });\n\n    const updatedState = machine.transition(undefined, {\n      type: 'updateName',\n      value: 'Anyone'\n    });\n\n    expect(updatedState.context.name).toEqual('Anyone');\n\n    const resetState = machine.transition(undefined, {\n      type: 'reset'\n    });\n\n    expect(resetState.context).toEqual(userModel.initialContext);\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can model events","suites":["createModel"],"updatePoint":{"line":144,"column":22},"line":144,"code":"  it('can model events', () => {\n    const userModel = createModel(\n      {\n        name: 'David',\n        age: 30\n      },\n      {\n        events: {\n          updateName: (value: string) => ({ value }),\n          updateAge: (value: number) => {\n            const payload = {\n              value\n            };\n            (payload as any).type = 'this should be overwritten';\n            return payload;\n          },\n          anotherEvent: () => ({})\n        }\n      }\n    );\n\n    // Example of an externally-defined assign action\n    const assignName = userModel.assign(\n      {\n        name: (_, event) => {\n          return event.value;\n        }\n      },\n      'updateName'\n    );\n\n    const machine = userModel.createMachine({\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            updateName: {\n              // pre-defined assign action\n              actions: [assignName]\n            },\n            updateAge: {\n              // inline assign action\n              actions: userModel.assign((_, e) => {\n                return {\n                  age: e.value\n                };\n              })\n            }\n          }\n        }\n      }\n    });\n\n    let updatedState = machine.transition(\n      undefined,\n      userModel.events.updateName('Anyone')\n    );\n\n    expect(updatedState.context.name).toEqual('Anyone');\n\n    updatedState = machine.transition(\n      updatedState,\n      userModel.events.updateAge(42)\n    );\n\n    expect(updatedState.context.age).toEqual(42);\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"can model actions","suites":["createModel"],"updatePoint":{"line":212,"column":23},"line":212,"code":"  it('can model actions', () => {\n    const userModel = createModel(\n      {\n        name: 'David',\n        age: 30\n      },\n      {\n        actions: {\n          greet: (message: string) => ({ message })\n        }\n      }\n    );\n\n    userModel.createMachine({\n      context: userModel.initialContext,\n      initial: 'active',\n      entry: { type: 'greet', message: 'hello' },\n      exit: { type: 'greet', message: 'goodbye' },\n      states: {\n        active: {\n          entry: [userModel.actions.greet('hello')]\n        }\n      }\n    });\n\n    userModel.createMachine({\n      context: userModel.initialContext,\n      // @ts-expect-error\n      entry: { type: 'greet' } // missing message\n    });\n\n    userModel.createMachine({\n      context: userModel.initialContext,\n      // @ts-expect-error\n      entry: { type: 'fake' } // wrong message\n    });\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"works with built-in actions","suites":["createModel"],"updatePoint":{"line":250,"column":33},"line":250,"code":"  it('works with built-in actions', () => {\n    const model = createModel(\n      {},\n      {\n        events: {\n          SAMPLE: () => ({})\n        },\n        actions: {\n          custom: () => ({})\n        }\n      }\n    );\n\n    model.createMachine({\n      context: model.initialContext,\n      entry: [\n        model.actions.custom(),\n        // raise('SAMPLE'),\n        send('SAMPLE'),\n        sendParent('SOMETHING'),\n        sendUpdate(),\n        // respond('SOMETHING'),\n        log('something'),\n        cancel('something'),\n        stop('something'),\n        model.assign({}),\n        choose([])\n      ],\n      exit: [\n        model.actions.custom(),\n        // raise('SAMPLE'),\n        send('SAMPLE'),\n        sendParent('SOMETHING'),\n        sendUpdate(),\n        // respond('SOMETHING'),\n        log('something'),\n        cancel('something'),\n        stop('something'),\n        model.assign({}),\n        choose([])\n      ],\n      on: {\n        SAMPLE: {\n          actions: [\n            model.actions.custom(),\n            // raise('SAMPLE'),\n            send('SAMPLE'),\n            sendParent('SOMETHING'),\n            sendUpdate(),\n            // respond('SOMETHING'),\n            log('something'),\n            cancel('something'),\n            stop('something'),\n            model.assign({}),\n            choose([])\n          ]\n        }\n      },\n      initial: 'someState',\n      states: {\n        someState: {\n          entry: [\n            model.actions.custom(),\n            // raise('SAMPLE'),\n            send('SAMPLE'),\n            sendParent('SOMETHING'),\n            sendUpdate(),\n            // respond('SOMETHING'),\n            log('something'),\n            cancel('something'),\n            stop('something'),\n            model.assign({}),\n            choose([])\n          ],\n          exit: [\n            model.actions.custom(),\n            // raise('SAMPLE'),\n            send('SAMPLE'),\n            sendParent('SOMETHING'),\n            sendUpdate(),\n            // respond('SOMETHING'),\n            log('something'),\n            cancel('something'),\n            stop('something'),\n            model.assign({}),\n            choose([])\n          ]\n        }\n      }\n    });\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should strongly type action implementations","suites":["createModel"],"updatePoint":{"line":342,"column":49},"line":342,"code":"  it('should strongly type action implementations', () => {\n    const model = createModel(\n      {},\n      {\n        events: {\n          SAMPLE: () => ({})\n        },\n        actions: {\n          custom: (param: string) => ({ param })\n        }\n      }\n    );\n\n    model.createMachine(\n      {\n        context: {}\n      },\n      {\n        actions: {\n          custom: (_ctx, _e, { action }) => {\n            action.param.toUpperCase();\n\n            // @ts-expect-error\n            action.param.whatever();\n\n            // @ts-expect-error\n            action.unknown;\n          }\n        }\n      }\n    );\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should strongly type action implementations with model.createMachine(...)","suites":["createModel"],"updatePoint":{"line":375,"column":79},"line":375,"code":"  it('should strongly type action implementations with model.createMachine(...)', () => {\n    const model = createModel(\n      {},\n      {\n        events: {\n          SAMPLE: () => ({})\n        },\n        actions: {\n          custom: (param: string) => ({ param })\n        }\n      }\n    );\n\n    model.createMachine(\n      {\n        context: {}\n      },\n      {\n        actions: {\n          custom: (_ctx, _e, { action }) => {\n            action.param.toUpperCase();\n\n            // @ts-expect-error\n            action.param.whatever();\n\n            // @ts-expect-error\n            action.unknown;\n          }\n        }\n      }\n    );\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should disallow string actions for non-simple actions","suites":["createModel"],"updatePoint":{"line":408,"column":59},"line":408,"code":"  it('should disallow string actions for non-simple actions', () => {\n    const model = createModel(\n      {},\n      {\n        events: {\n          SAMPLE: () => ({})\n        },\n        actions: {\n          simple: () => ({}),\n          custom: (param: string) => ({ param })\n        }\n      }\n    );\n\n    model.createMachine({\n      entry: ['simple', { type: 'custom', param: 'something' }],\n\n      // @ts-expect-error\n      exit: ['custom'],\n      initial: 'test',\n      states: {\n        test: {\n          entry: ['simple', { type: 'custom', param: 'something' }],\n\n          // @ts-expect-error\n          exit: ['custom']\n        }\n      }\n    });\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should typecheck `createMachine` for model without creators","suites":["createModel"],"updatePoint":{"line":439,"column":65},"line":439,"code":"  it('should typecheck `createMachine` for model without creators', () => {\n    const toggleModel = createModel(\n      { count: 0 },\n      {\n        events: {\n          TOGGLE: () => ({})\n        }\n      }\n    );\n\n    toggleModel.createMachine({\n      id: 'machine',\n      initial: 'inactive',\n      states: {\n        inactive: {\n          on: { TOGGLE: 'active' }\n        },\n        active: {\n          on: { TOGGLE: 'inactive' }\n        }\n      }\n    });\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"model.createMachine(...) should provide the initial context","suites":["createModel"],"updatePoint":{"line":463,"column":65},"line":463,"code":"  it('model.createMachine(...) should provide the initial context', () => {\n    const toggleModel = createModel({ count: 0 });\n\n    const machine = toggleModel.createMachine({});\n\n    expect(machine.initialState.context.count).toBe(0);\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow using events if creators have not been configured","suites":["createModel"],"updatePoint":{"line":471,"column":72},"line":471,"code":"  it('should not allow using events if creators have not been configured', () => {\n    const model = createModel({ count: 0 });\n\n    // this is a type test for something that is not available at runtime so we suppress runtime error with try/catch\n    try {\n      // this should not end up being `any`\n      // @ts-expect-error\n      model.events.test();\n    } catch (err) {}\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow using actions if creators have not been configured","suites":["createModel"],"updatePoint":{"line":482,"column":73},"line":482,"code":"  it('should not allow using actions if creators have not been configured', () => {\n    const model = createModel({ count: 0 });\n\n    // this is a type test for something that is not available at runtime so we suppress runtime error with try/catch\n    try {\n      // this should not end up being `any`\n      // @ts-expect-error\n      model.actions.test();\n    } catch (err) {}\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow for the action type to be explicitly given when creators have not been configured","suites":["createModel"],"updatePoint":{"line":493,"column":100},"line":493,"code":"  it('should allow for the action type to be explicitly given when creators have not been configured', () => {\n    const model = createModel<\n      { count: number },\n      { type: 'EV' },\n      { type: 'fooAction' }\n    >({ count: 0 });\n\n    model.createMachine({\n      context: model.initialContext,\n      initial: 'a',\n      states: {\n        a: {\n          entry: 'fooAction'\n        },\n        b: {\n          // @ts-expect-error\n          entry: 'barAction'\n        }\n      }\n    });\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow any action if actions are not specified","suites":["createModel"],"updatePoint":{"line":515,"column":58},"line":515,"code":"  it('should allow any action if actions are not specified', () => {\n    const model = createModel(\n      {},\n      {\n        events: {}\n      }\n    );\n\n    model.createMachine({\n      entry: 'someAction',\n      exit: { type: 'someObjectAction' },\n      on: {\n        // @ts-expect-error\n        UNEXPECTED_EVENT: {}\n      }\n    });\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should infer context correctly when actions are not specified","suites":["createModel"],"updatePoint":{"line":533,"column":67},"line":533,"code":"  it('should infer context correctly when actions are not specified', () => {\n    const model = createModel(\n      { foo: 100 },\n      {\n        events: {\n          BAR: () => ({})\n        }\n      }\n    );\n\n    model.createMachine({\n      entry: (ctx) => {\n        // @ts-expect-error assert indirectly that `ctx` is not `any` or `unknown`\n        ctx.other;\n      },\n      exit: assign({\n        foo: (ctx) => {\n          // @ts-expect-error assert indirectly that `ctx` is not `any` or `unknown`\n          ctx.other;\n          return ctx.foo;\n        }\n      })\n    });\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should keep the context type on the state after using `state.matches`","suites":["createModel"],"updatePoint":{"line":558,"column":75},"line":558,"code":"  it('should keep the context type on the state after using `state.matches`', () => {\n    const model = createModel<{ count: number }, { type: 'INC' }>({ count: 0 });\n\n    const machine = model.createMachine({\n      context: model.initialContext,\n      states: {\n        a: {}\n      }\n    });\n\n    if (machine.initialState.matches('a')) {\n      machine.initialState.context.count;\n      // @ts-expect-error\n      machine.initialState.context.unknown;\n    }\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"ContextFrom accepts a model type","suites":["createModel"],"updatePoint":{"line":575,"column":38},"line":575,"code":"  it('ContextFrom accepts a model type', () => {\n    const model = createModel(\n      { count: 3 },\n      {\n        events: {}\n      }\n    );\n\n    const val = ({} as unknown) as ContextFrom<typeof model>;\n\n    // expect no type error here\n    // with previous ContextFrom behavior, this will not compile\n    val.count;\n\n    // @ts-expect-error (sanity check)\n    val.unknown;\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"EventFrom accepts a model type","suites":["createModel"],"updatePoint":{"line":593,"column":36},"line":593,"code":"  it('EventFrom accepts a model type', () => {\n    const model = createModel(\n      { count: 3 },\n      {\n        events: {\n          INC: () => ({})\n        }\n      }\n    );\n\n    const val = ({} as unknown) as EventFrom<typeof model>;\n\n    // expect no type error here\n    // with previous EventFrom behavior, this will not compile\n    val.type;\n\n    // @ts-expect-error (sanity check)\n    val.count;\n  });","file":"model.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should enter initial states of parallel states","suites":["multiple","transitions to parallel states"],"updatePoint":{"line":144,"column":54},"line":144,"code":"    it('should enter initial states of parallel states', () => {\n      expect(stateInitial.value).toEqual({\n        para: { A: 'B', K: 'L', P: 'Q' }\n      });\n    });","file":"multiple.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should enter specific states in one region","suites":["multiple","transitions to parallel states"],"updatePoint":{"line":150,"column":50},"line":150,"code":"    it('should enter specific states in one region', () => {\n      expect(stateM.value).toEqual({ para: { A: 'B', K: 'M', P: 'Q' } });\n    });","file":"multiple.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should enter specific states in all regions","suites":["multiple","transitions to parallel states"],"updatePoint":{"line":154,"column":51},"line":154,"code":"    it('should enter specific states in all regions', () => {\n      const stateCMR = machine.transition(stateSimple, 'DEEP_CMR');\n      expect(stateCMR.value).toEqual({ para: { A: 'C', K: 'M', P: 'R' } });\n    });","file":"multiple.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should enter specific states in some regions","suites":["multiple","transitions to parallel states"],"updatePoint":{"line":159,"column":52},"line":159,"code":"    it('should enter specific states in some regions', () => {\n      const stateMR = machine.transition(stateSimple, 'DEEP_MR');\n      expect(stateMR.value).toEqual({ para: { A: 'B', K: 'M', P: 'R' } });\n    });","file":"multiple.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reject two targets in the same region","suites":["multiple","transitions to parallel states"],"line":164,"code":"    it.skip('should reject two targets in the same region', () => {","file":"multiple.test.ts","skipped":true,"dir":"packages/core/test"},{"name":"should reject targets inside and outside a region","suites":["multiple","transitions to parallel states"],"line":170,"code":"    it.skip('should reject targets inside and outside a region', () => {","file":"multiple.test.ts","skipped":true,"dir":"packages/core/test"},{"name":"should reject two targets in different regions","suites":["multiple","transitions to parallel states"],"line":176,"code":"    it.skip('should reject two targets in different regions', () => {","file":"multiple.test.ts","skipped":true,"dir":"packages/core/test"},{"name":"should reject two targets in different regions at different levels","suites":["multiple","transitions to parallel states"],"line":182,"code":"    it.skip('should reject two targets in different regions at different levels', () => {","file":"multiple.test.ts","skipped":true,"dir":"packages/core/test"},{"name":"should reject two deep targets in different regions at top level","suites":["multiple","transitions to parallel states"],"line":188,"code":"    it.skip('should reject two deep targets in different regions at top level', () => {","file":"multiple.test.ts","skipped":true,"dir":"packages/core/test"},{"name":"should reject two deep targets in different regions at different levels","suites":["multiple","transitions to parallel states"],"line":194,"code":"    it.skip('should reject two deep targets in different regions at different levels', () => {","file":"multiple.test.ts","skipped":true,"dir":"packages/core/test"},{"name":"should specify the correct document order for each state node","suites":["document order"],"updatePoint":{"line":5,"column":67},"line":5,"code":"  it('should specify the correct document order for each state node', () => {\n    const machine = Machine({\n      id: 'order',\n      initial: 'one',\n      states: {\n        one: {\n          initial: 'two',\n          states: {\n            two: {},\n            three: {\n              initial: 'four',\n              states: {\n                four: {},\n                five: {\n                  initial: 'six',\n                  states: {\n                    six: {}\n                  }\n                }\n              }\n            }\n          }\n        },\n        seven: {\n          type: 'parallel',\n          states: {\n            eight: {\n              initial: 'nine',\n              states: {\n                nine: {},\n                ten: {\n                  initial: 'eleven',\n                  states: {\n                    eleven: {},\n                    twelve: {}\n                  }\n                }\n              }\n            },\n            thirteen: {\n              type: 'parallel',\n              states: {\n                fourteen: {},\n                fifteen: {}\n              }\n            }\n          }\n        }\n      }\n    });\n\n    function dfs(\n      node: AnyStateMachine\n    ): StateNode<any, any, any, any, any, any>[] {\n      return flatten([\n        node as any,\n        ...Object.keys(node.states).map((key) => dfs(node.states[key] as any))\n      ]);\n    }\n\n    const allStateNodeOrders = dfs(machine).map((sn) => [sn.key, sn.order]);\n\n    expect(allStateNodeOrders).toEqual([\n      ['order', 0],\n      ['one', 1],\n      ['two', 2],\n      ['three', 3],\n      ['four', 4],\n      ['five', 5],\n      ['six', 6],\n      ['seven', 7],\n      ['eight', 8],\n      ['nine', 9],\n      ['ten', 10],\n      ['eleven', 11],\n      ['twelve', 12],\n      ['thirteen', 13],\n      ['fourteen', 14],\n      ['fifteen', 15]\n    ]);\n  });","file":"order.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have initial parallel states","suites":["parallel states"],"updatePoint":{"line":496,"column":41},"line":496,"code":"  it('should have initial parallel states', () => {\n    const { initialState } = wordMachine;\n\n    expect(initialState.value).toEqual({\n      bold: 'off',\n      italics: 'off',\n      underline: 'off',\n      list: 'none'\n    });\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should go from  to  on ","suites":["parallel states"],"updatePoint":{"line":551,"column":25},"line":549,"code":"      it(`should go from ${fromState} to ${JSON.stringify(\n        toState\n      )} on ${eventTypes}`, () => {\n        const resultState = testMultiTransition(\n          wordMachine,\n          fromState,\n          eventTypes\n        );\n\n        expect(resultState.value).toEqual(toState);\n      });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have all parallel states represented in the state value","suites":["parallel states"],"updatePoint":{"line":563,"column":68},"line":563,"code":"  it('should have all parallel states represented in the state value', () => {\n    const nextState = wakMachine.transition(wakMachine.initialState, 'WAK1');\n\n    expect(nextState.value).toEqual({ wak1: 'wak1sonB', wak2: 'wak2sonA' });\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have all parallel states represented in the state value (2)","suites":["parallel states"],"updatePoint":{"line":569,"column":72},"line":569,"code":"  it('should have all parallel states represented in the state value (2)', () => {\n    const nextState = wakMachine.transition(wakMachine.initialState, 'WAK2');\n\n    expect(nextState.value).toEqual({ wak1: 'wak1sonA', wak2: 'wak2sonB' });\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with regions without states","suites":["parallel states"],"updatePoint":{"line":575,"column":45},"line":575,"code":"  it('should work with regions without states', () => {\n    expect(flatParallelMachine.initialState.value).toEqual({\n      foo: {},\n      bar: {},\n      baz: 'one'\n    });\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with regions without states","suites":["parallel states"],"updatePoint":{"line":583,"column":45},"line":583,"code":"  it('should work with regions without states', () => {\n    const nextState = flatParallelMachine.transition(\n      flatParallelMachine.initialState,\n      'E'\n    );\n    expect(nextState.value).toEqual({\n      foo: {},\n      bar: {},\n      baz: 'two'\n    });\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition to relative substate","suites":["parallel states"],"updatePoint":{"line":595,"column":53},"line":595,"code":"  it('should properly transition to relative substate', () => {\n    const nextState = composerMachine.transition(\n      composerMachine.initialState,\n      'singleClickActivity'\n    );\n\n    expect(nextState.value).toEqual({\n      ReadOnly: {\n        StructureEdit: {\n          SelectionStatus: 'SelectedActivity',\n          ClipboardStatus: 'Empty'\n        }\n      }\n    });\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition according to onEntry events on an initial state","suites":["parallel states"],"updatePoint":{"line":611,"column":80},"line":611,"code":"  it('should properly transition according to onEntry events on an initial state', () => {\n    expect(raisingParallelMachine.initialState.value).toEqual({\n      OUTER1: 'C',\n      OUTER2: {\n        INNER1: 'OFF',\n        INNER2: 'OFF'\n      }\n    });\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition when raising events for a parallel state","suites":["parallel states"],"updatePoint":{"line":621,"column":73},"line":621,"code":"  it('should properly transition when raising events for a parallel state', () => {\n    const nextState = raisingParallelMachine.transition(\n      raisingParallelMachine.initialState,\n      'EVENT_OUTER1_B'\n    );\n\n    expect(nextState.value).toEqual({\n      OUTER1: 'B',\n      OUTER2: {\n        INNER1: 'ON',\n        INNER2: 'ON'\n      }\n    });\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition when in a simple nested state","suites":["parallel states","transitions with nested parallel states"],"updatePoint":{"line":698,"column":64},"line":698,"code":"    it('should properly transition when in a simple nested state', () => {\n      const nextState = nestedParallelState.transition(\n        simpleNextState,\n        'EVENT_STATE_NTJ0_WORK'\n      );\n\n      expect(nextState.value).toEqual({\n        OUTER1: {\n          STATE_ON: {\n            STATE_NTJ0: 'STATE_WORKING_0',\n            STATE_NTJ1: 'STATE_IDLE_1'\n          }\n        },\n        OUTER2: 'STATE_ON_SIMPLE'\n      });\n    });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly transition when in a complex nested state","suites":["parallel states","transitions with nested parallel states"],"updatePoint":{"line":715,"column":65},"line":715,"code":"    it('should properly transition when in a complex nested state', () => {\n      const nextState = nestedParallelState.transition(\n        complexNextState,\n        'EVENT_STATE_NTJ0_WORK'\n      );\n\n      expect(nextState.value).toEqual({\n        OUTER1: {\n          STATE_ON: {\n            STATE_NTJ0: 'STATE_WORKING_0',\n            STATE_NTJ1: 'STATE_IDLE_1'\n          }\n        },\n        OUTER2: {\n          STATE_ON_COMPLEX: {\n            STATE_INNER1: 'STATE_OFF',\n            STATE_INNER2: 'STATE_OFF'\n          }\n        }\n      });\n    });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should represent the flat nested parallel states in the state value","suites":["parallel states","nested flat parallel states"],"updatePoint":{"line":761,"column":75},"line":761,"code":"    it('should represent the flat nested parallel states in the state value', () => {\n      const result = machine.transition(machine.initialState, 'to-B');\n\n      expect(result.value).toEqual({\n        B: {\n          C: {},\n          D: {}\n        }\n      });\n    });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should properly evaluate deep flat parallel states","suites":["parallel states","deep flat parallel states"],"updatePoint":{"line":774,"column":58},"line":774,"code":"    it('should properly evaluate deep flat parallel states', () => {\n      const state1 = deepFlatParallelMachine.transition(\n        deepFlatParallelMachine.initialState,\n        'a'\n      );\n      const state2 = deepFlatParallelMachine.transition(state1, 'c');\n      const state3 = deepFlatParallelMachine.transition(state2, 'b');\n      expect(state3.value).toEqual({\n        V: {\n          B: {\n            BB: {\n              BBB_A: {},\n              BBB_B: {}\n            }\n          }\n        },\n        X: {}\n      });\n    });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not overlap resolved state configuration in state resolution","suites":["parallel states","deep flat parallel states"],"updatePoint":{"line":794,"column":75},"line":794,"code":"    it('should not overlap resolved state configuration in state resolution', () => {\n      const machine = Machine({\n        id: 'pipeline',\n        type: 'parallel',\n        states: {\n          foo: {\n            on: {\n              UPDATE: {\n                actions: () => {\n                  /* do nothing */\n                }\n              }\n            }\n          },\n          bar: {\n            on: {\n              UPDATE: '.baz'\n            },\n            initial: 'idle',\n            states: {\n              idle: {},\n              baz: {}\n            }\n          }\n        }\n      });\n\n      expect(() => {\n        machine.transition(machine.initialState, 'UPDATE');\n      }).not.toThrow();\n    });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"regions should be able to transition to orthogonal regions","suites":["parallel states","other"],"updatePoint":{"line":829,"column":66},"line":829,"code":"    it('regions should be able to transition to orthogonal regions', () => {\n      const testMachine = Machine({\n        id: 'app',\n        type: 'parallel',\n        states: {\n          Pages: {\n            id: 'Pages',\n            initial: 'About',\n            states: {\n              About: {\n                id: 'About',\n                on: {\n                  dashboard: '#Dashboard'\n                }\n              },\n              Dashboard: {\n                id: 'Dashboard',\n                on: {\n                  about: '#About'\n                }\n              }\n            }\n          },\n          Menu: {\n            id: 'Menu',\n            initial: 'Closed',\n            states: {\n              Closed: {\n                id: 'Closed',\n                on: {\n                  toggle: '#Opened'\n                }\n              },\n              Opened: {\n                id: 'Opened',\n                on: {\n                  toggle: '#Closed',\n                  'go to dashboard': '#Dashboard'\n                }\n              }\n            }\n          }\n        }\n      });\n\n      const openMenuState = testMachine.transition(\n        testMachine.initialState,\n        'toggle'\n      );\n\n      const dashboardState = testMachine.transition(\n        openMenuState,\n        'go to dashboard'\n      );\n\n      expect(\n        dashboardState.matches({ Menu: 'Opened', Pages: 'Dashboard' })\n      ).toBe(true);\n    });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should calculate the entry set for external transitions in parallel states","suites":["parallel states","other"],"updatePoint":{"line":890,"column":82},"line":890,"code":"    it('should calculate the entry set for external transitions in parallel states', () => {\n      const testMachine = Machine<{ log: string[] }>({\n        id: 'test',\n        context: { log: [] },\n        type: 'parallel',\n        states: {\n          foo: {\n            initial: 'foobar',\n            states: {\n              foobar: {\n                on: {\n                  GOTO_FOOBAZ: 'foobaz'\n                }\n              },\n              foobaz: {\n                entry: assign({ log: (ctx) => [...ctx.log, 'entered foobaz'] }),\n                on: {\n                  GOTO_FOOBAZ: 'foobaz'\n                }\n              }\n            }\n          },\n          bar: {}\n        }\n      });\n\n      const run1 = testMachine.transition(\n        testMachine.initialState,\n        'GOTO_FOOBAZ'\n      );\n      const run2 = testMachine.transition(run1, 'GOTO_FOOBAZ');\n\n      expect(run2.context.log.length).toBe(2);\n    });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should raise a \"done.state.*\" event when all child states reach final state","suites":["parallel states","other"],"updatePoint":{"line":926,"column":81},"line":926,"code":"  it('should raise a \"done.state.*\" event when all child states reach final state', (done) => {\n    const machine = createMachine({\n      id: 'test',\n      initial: 'p',\n      states: {\n        p: {\n          type: 'parallel',\n          states: {\n            a: {\n              initial: 'idle',\n              states: {\n                idle: {\n                  on: {\n                    FINISH: 'finished'\n                  }\n                },\n                finished: {\n                  type: 'final'\n                }\n              }\n            },\n            b: {\n              initial: 'idle',\n              states: {\n                idle: {\n                  on: {\n                    FINISH: 'finished'\n                  }\n                },\n                finished: {\n                  type: 'final'\n                }\n              }\n            },\n            c: {\n              initial: 'idle',\n              states: {\n                idle: {\n                  on: {\n                    FINISH: 'finished'\n                  }\n                },\n                finished: {\n                  type: 'final'\n                }\n              }\n            }\n          },\n          onDone: 'success'\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(machine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n\n    service.send('FINISH');\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should raise a \"done.state.*\" event when a pseudostate of a history type is directly on a parallel state","suites":["parallel states","other"],"updatePoint":{"line":991,"column":110},"line":991,"code":"  it('should raise a \"done.state.*\" event when a pseudostate of a history type is directly on a parallel state', () => {\n    const machine = createMachine({\n      initial: 'parallelSteps',\n      states: {\n        parallelSteps: {\n          type: 'parallel',\n          states: {\n            hist: {\n              type: 'history'\n            },\n            one: {\n              initial: 'wait_one',\n              states: {\n                wait_one: {\n                  on: {\n                    finish_one: {\n                      target: 'done'\n                    }\n                  }\n                },\n                done: {\n                  type: 'final'\n                }\n              }\n            },\n            two: {\n              initial: 'wait_two',\n              states: {\n                wait_two: {\n                  on: {\n                    finish_two: {\n                      target: 'done'\n                    }\n                  }\n                },\n                done: {\n                  type: 'final'\n                }\n              }\n            }\n          },\n          onDone: 'finished'\n        },\n        finished: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    service.send({ type: 'finish_one' });\n    service.send({ type: 'finish_two' });\n\n    expect(service.state.value).toBe('finished');\n  });","file":"parallel.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should produce a partial state machine with a binary toggle","suites":["patterns","toggle pattern"],"updatePoint":{"line":6,"column":67},"line":6,"code":"    it('should produce a partial state machine with a binary toggle', () => {\n      expect(toggle('on', 'off', 'SWITCH')).toEqual({\n        on: { on: { SWITCH: 'off' } },\n        off: { on: { SWITCH: 'on' } }\n      });\n    });","file":"patterns.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with an array","suites":["patterns","sequence pattern"],"updatePoint":{"line":15,"column":33},"line":15,"code":"    it('should work with an array', () => {\n      const seq = ['one', 'two', 'three', 'last'];\n\n      const sequenceMachine = Machine({\n        id: 'sequence',\n        ...sequence(seq)\n      });\n\n      expect(sequenceMachine.transition(seq[0], 'NEXT').value).toEqual(seq[1]);\n\n      expect(sequenceMachine.transition(seq[1], 'PREV').value).toEqual(seq[0]);\n\n      expect(\n        sequenceMachine.transition(seq[seq.length - 1], 'NEXT').value\n      ).toEqual(seq[seq.length - 1]);\n\n      expect(sequenceMachine.transition(seq[0], 'PREV').value).toEqual(seq[0]);\n    });","file":"patterns.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should customize the next/prev events","suites":["patterns","sequence pattern"],"updatePoint":{"line":34,"column":45},"line":34,"code":"    it('should customize the next/prev events', () => {\n      const seq = ['one', 'two', 'three', 'last'];\n\n      const sequenceMachine = Machine({\n        id: 'sequence',\n        ...sequence(seq, {\n          nextEvent: 'FORWARD',\n          prevEvent: 'BACK'\n        })\n      });\n\n      expect(sequenceMachine.transition(seq[0], 'NEXT').value).toEqual(seq[0]);\n\n      expect(sequenceMachine.transition(seq[1], 'PREV').value).toEqual(seq[1]);\n\n      expect(sequenceMachine.transition(seq[0], 'FORWARD').value).toEqual(\n        seq[1]\n      );\n\n      expect(sequenceMachine.transition(seq[1], 'BACK').value).toEqual(seq[0]);\n    });","file":"patterns.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow next/prev events to be undefined","suites":["patterns","sequence pattern"],"updatePoint":{"line":56,"column":53},"line":56,"code":"    it('should allow next/prev events to be undefined', () => {\n      const seq = ['one', 'two', 'three', 'last'];\n\n      const sequenceMachine = Machine({\n        id: 'sequence',\n        ...sequence(seq, {\n          nextEvent: 'FORWARD',\n          prevEvent: undefined\n        })\n      });\n\n      expect(sequenceMachine.transition(seq[0], 'FORWARD').value).toEqual(\n        seq[1]\n      );\n\n      expect(sequenceMachine.transition(seq[1], 'BACK').value).toEqual(seq[1]);\n\n      const backSequenceMachine = Machine({\n        id: 'backSequence',\n        ...sequence(seq, {\n          nextEvent: undefined,\n          prevEvent: 'BACK'\n        })\n      });\n\n      expect(backSequenceMachine.transition(seq[0], 'FORWARD').value).toEqual(\n        seq[0]\n      );\n\n      expect(backSequenceMachine.transition(seq[1], 'BACK').value).toEqual(\n        seq[0]\n      );\n    });","file":"patterns.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to use `hasTag` immediately","suites":["rehydration","using persisted state"],"updatePoint":{"line":5,"column":50},"line":5,"code":"    it('should be able to use `hasTag` immediately', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            tags: 'foo'\n          }\n        }\n      });\n\n      const persistedState = JSON.stringify(machine.initialState);\n      const restoredState = State.create(JSON.parse(persistedState));\n\n      const service = interpret(machine).start(restoredState);\n\n      expect(service.state.hasTag('foo')).toBe(true);\n    });","file":"rehydration.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call exit actions when machine gets stopped immediately","suites":["rehydration","using persisted state"],"updatePoint":{"line":23,"column":70},"line":23,"code":"    it('should call exit actions when machine gets stopped immediately', () => {\n      const actual: string[] = [];\n      const machine = createMachine({\n        exit: () => actual.push('root'),\n        initial: 'a',\n        states: {\n          a: {\n            exit: () => actual.push('a')\n          }\n        }\n      });\n\n      const persistedState = JSON.stringify(machine.initialState);\n      const restoredState = State.create(JSON.parse(persistedState));\n\n      interpret(machine).start(restoredState).stop();\n\n      expect(actual).toEqual(['a', 'root']);\n    });","file":"rehydration.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should get correct result back from `can` immediately","suites":["rehydration","using persisted state"],"updatePoint":{"line":43,"column":61},"line":43,"code":"    it('should get correct result back from `can` immediately', () => {\n      const machine = createMachine({\n        on: {\n          FOO: {\n            actions: () => {}\n          }\n        }\n      });\n\n      const persistedState = JSON.stringify(interpret(machine).start().state);\n      const restoredState = JSON.parse(persistedState);\n      const service = interpret(machine).start(restoredState);\n\n      expect(service.state.can('FOO')).toBe(true);\n    });","file":"rehydration.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to use `hasTag` immediately","suites":["rehydration","using state value"],"updatePoint":{"line":61,"column":50},"line":61,"code":"    it('should be able to use `hasTag` immediately', () => {\n      const machine = createMachine({\n        initial: 'inactive',\n        states: {\n          inactive: {\n            on: { NEXT: 'active' }\n          },\n          active: {\n            tags: 'foo'\n          }\n        }\n      });\n\n      const service = interpret(machine);\n\n      service.start('active');\n\n      expect(service.state.hasTag('foo')).toBe(true);\n    });","file":"rehydration.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call exit actions when machine gets stopped immediately","suites":["rehydration","using state value"],"updatePoint":{"line":81,"column":70},"line":81,"code":"    it('should call exit actions when machine gets stopped immediately', () => {\n      const actual: string[] = [];\n      const machine = createMachine({\n        exit: () => actual.push('root'),\n        initial: 'inactive',\n        states: {\n          inactive: {\n            on: { NEXT: 'active' }\n          },\n          active: {\n            exit: () => actual.push('active')\n          }\n        }\n      });\n\n      interpret(machine).start('active').stop();\n\n      expect(actual).toEqual(['active', 'root']);\n    });","file":"rehydration.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve parallel states with flat child states","suites":["machine.resolve()"],"updatePoint":{"line":61,"column":59},"line":61,"code":"  it('should resolve parallel states with flat child states', () => {\n    const unresolvedStateValue = { p1: { s1: { p2: 's4' }, s2: { p4: 's8' } } };\n\n    const resolvedStateValue = flatParallelMachine.resolve(\n      unresolvedStateValue\n    );\n    expect(resolvedStateValue).toEqual({\n      p1: { s1: { p2: { s3: 's3.1', s4: {} } }, s2: { p4: { s7: {}, s8: {} } } }\n    });\n  });","file":"resolve.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should process event only once","suites":["scheduler"],"updatePoint":{"line":4,"column":36},"line":4,"code":"  it('should process event only once', () => {\n    let calledCount = 0;\n    const scheduler = new Scheduler();\n    scheduler.initialize(); // TODO: refactor (use .start())\n    scheduler.schedule(() => {\n      calledCount++;\n    });\n\n    const expectedCount = 1;\n    expect(calledCount).toEqual(expectedCount);\n  });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should process more than one event","suites":["scheduler"],"updatePoint":{"line":16,"column":40},"line":16,"code":"  it('should process more than one event', () => {\n    let calledCount = 0;\n    const scheduler = new Scheduler();\n    scheduler.initialize(); // TODO: refactor (use .start())\n    scheduler.schedule(() => {\n      calledCount++;\n      scheduler.schedule(() => {\n        calledCount++;\n      });\n    });\n\n    const expectedCount = 2;\n    expect(calledCount).toEqual(expectedCount);\n  });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should process events in the same order they were hit","suites":["scheduler"],"updatePoint":{"line":31,"column":59},"line":31,"code":"  it('should process events in the same order they were hit', () => {\n    const order: number[] = [];\n    const scheduler = new Scheduler();\n    scheduler.initialize(); // TODO: refactor (use .start())\n    scheduler.schedule(() => {\n      order.push(1);\n      scheduler.schedule(() => {\n        order.push(2);\n      });\n      scheduler.schedule(() => {\n        order.push(3);\n        scheduler.schedule(() => {\n          order.push(5);\n        });\n      });\n      scheduler.schedule(() => {\n        order.push(4);\n      });\n    });\n\n    const expectedOrder = [1, 2, 3, 4, 5];\n    expect(order.length).toEqual(expectedOrder.length);\n    for (let i = 0; i < expectedOrder.length; i++) {\n      expect(order[i]).toEqual(expectedOrder[i]);\n    }\n  });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should recover if error is thrown while processing event","suites":["scheduler"],"updatePoint":{"line":58,"column":62},"line":58,"code":"  it('should recover if error is thrown while processing event', () => {\n    let calledCount = 0;\n    const scheduler = new Scheduler();\n    scheduler.initialize(); // TODO: refactor (use .start())\n    expect(() =>\n      scheduler.schedule(() => {\n        calledCount++;\n        throw Error('Test');\n      })\n    ).toThrowErrorMatchingInlineSnapshot(`\"Test\"`);\n    scheduler.schedule(() => {\n      calledCount++;\n    });\n\n    const expectedCount = 2;\n    expect(calledCount).toEqual(expectedCount);\n  });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should recover if error is thrown while processing the queue","suites":["scheduler"],"updatePoint":{"line":76,"column":66},"line":76,"code":"  it('should recover if error is thrown while processing the queue', () => {\n    let calledCount = 0;\n    const scheduler = new Scheduler();\n    scheduler.initialize(); // TODO: refactor (use .start())\n    expect(() =>\n      scheduler.schedule(() => {\n        calledCount++;\n        scheduler.schedule(() => {\n          calledCount++;\n          throw Error('Test');\n        });\n      })\n    ).toThrowErrorMatchingInlineSnapshot(`\"Test\"`);\n    scheduler.schedule(() => {\n      calledCount++;\n    });\n\n    const expectedCount = 3;\n    expect(calledCount).toEqual(expectedCount);\n  });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should stop processing events if error condition is met","suites":["scheduler"],"updatePoint":{"line":97,"column":61},"line":97,"code":"  it('should stop processing events if error condition is met', () => {\n    let calledCount = 0;\n    const scheduler = new Scheduler();\n    scheduler.initialize(); // TODO: refactor (use .start())\n    expect(() =>\n      scheduler.schedule(() => {\n        calledCount++;\n        scheduler.schedule(() => {\n          calledCount++;\n          throw Error('Test');\n        });\n        scheduler.schedule(() => {\n          calledCount++;\n        });\n      })\n    ).toThrowErrorMatchingInlineSnapshot(`\"Test\"`);\n\n    const expectedCount = 2;\n    expect(calledCount).toEqual(expectedCount);\n  });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should discard not processed events in the case of error condition","suites":["scheduler"],"updatePoint":{"line":118,"column":72},"line":118,"code":"  it('should discard not processed events in the case of error condition', () => {\n    let calledCount = 0;\n    const scheduler = new Scheduler();\n    scheduler.initialize(); // TODO: refactor (use .start())\n    expect(() =>\n      scheduler.schedule(() => {\n        calledCount++;\n        scheduler.schedule(() => {\n          calledCount++;\n          throw Error('Test');\n        });\n        scheduler.schedule(() => {\n          calledCount++;\n        });\n      })\n    ).toThrowErrorMatchingInlineSnapshot(`\"Test\"`);\n    scheduler.schedule(() => {\n      calledCount++;\n    });\n\n    const expectedCount = 3;\n    expect(calledCount).toEqual(expectedCount);\n  });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to defer events","suites":["scheduler","deferred events"],"updatePoint":{"line":143,"column":38},"line":143,"code":"    it('should be able to defer events', () => {\n      let calledCount = 0;\n      const scheduler = new Scheduler({\n        deferEvents: true\n      });\n      scheduler.schedule(() => {\n        calledCount++;\n      });\n\n      const expectedCount = 0;\n      expect(calledCount).toEqual(expectedCount);\n      scheduler.initialize(); // TODO: refactor (use .start())\n      const expectedFinalCount = 1;\n      expect(calledCount).toEqual(expectedFinalCount);\n    });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should process initialization before other events","suites":["scheduler","deferred events"],"updatePoint":{"line":159,"column":57},"line":159,"code":"    it('should process initialization before other events', () => {\n      const callOrder: number[] = [];\n      const scheduler = new Scheduler({\n        deferEvents: true\n      });\n      scheduler.schedule(() => {\n        callOrder.push(2);\n      });\n      scheduler.schedule(() => {\n        callOrder.push(3);\n      });\n      scheduler.initialize(() => {\n        callOrder.push(1);\n      });\n\n      const expectedOrder = [1, 2, 3];\n      expect(callOrder.length).toEqual(expectedOrder.length);\n      for (let i = 0; i < expectedOrder.length; i++) {\n        expect(callOrder[i]).toEqual(expectedOrder[i]);\n      }\n    });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not defer events after initialization","suites":["scheduler","deferred events"],"updatePoint":{"line":181,"column":52},"line":181,"code":"    it('should not defer events after initialization', () => {\n      const scheduler = new Scheduler({\n        deferEvents: true\n      });\n      scheduler.initialize(); // TODO: refactor (use .start())\n      let calledCount = 0;\n      scheduler.schedule(() => {\n        calledCount++;\n      });\n\n      const expectedCount = 1;\n      expect(calledCount).toEqual(expectedCount);\n    });","file":"scheduler.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should infer types from provided schema","suites":["schema"],"updatePoint":{"line":38,"column":45},"line":38,"code":"  it('should infer types from provided schema', () => {\n    const noop = (_: any) => void 0;\n\n    const m = createMachine({\n      schema: {\n        context: fromJSONSchema({\n          type: 'object',\n          properties: {\n            foo: { type: 'string' },\n            bar: { type: 'number' },\n            baz: {\n              type: 'object',\n              properties: {\n                one: { type: 'string' }\n              }\n            }\n          }\n        }),\n        events: createSchema<{ type: 'FOO' } | { type: 'BAR' }>()\n      },\n      context: { foo: '', bar: 0, baz: { one: '' } },\n      initial: 'active',\n      states: {\n        active: {\n          entry: ['asdf']\n        }\n      }\n    });\n\n    noop(m.context.foo);\n    noop(m.context.baz.one);\n    m.transition('active', 'BAR');\n\n    // @ts-expect-error\n    noop(m.context.something);\n\n    // @ts-expect-error\n    m.transition('active', 'INVALID');\n  });","file":"schema.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"schema should be present in the machine definition","suites":["schema"],"updatePoint":{"line":78,"column":56},"line":78,"code":"  it('schema should be present in the machine definition', () => {\n    const schema = {\n      context: fromJSONSchema({\n        type: 'object',\n        properties: {\n          foo: { type: 'string' }\n        }\n      })\n    };\n\n    const m = createMachine({\n      schema,\n      context: { foo: '' },\n      initial: 'active',\n      states: {\n        active: {}\n      }\n    });\n\n    expect(m.schema).toEqual(schema);\n  });","file":"schema.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"/","suites":["scxml"],"updatePoint":{"line":444,"column":38},"line":444,"code":"      it(`${testGroupName}/${testName}`, async () => {\n        const machine = toMachine(scxmlDefinition, {\n          delimiter: '$'\n        });\n\n        // console.dir(machine.config, { depth: null });\n        await runTestToCompletion(machine, scxmlTest);\n      });","file":"scxml.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with built files","suites":["smoke test"],"updatePoint":{"line":4,"column":34},"line":4,"code":"  it('should work with built files', () => {\n    expect(() => {\n      return Machine({\n        id: 'light',\n        initial: 'green',\n        context: {\n          canTurnGreen: true\n        },\n        states: {\n          green: {\n            after: {\n              1000: 'yellow'\n            }\n          },\n          yellow: {\n            after: {\n              1000: [{ target: 'red' }]\n            }\n          },\n          red: {\n            after: [{ delay: 1000, target: 'green' }]\n          }\n        }\n      });\n    }).not.toThrow();\n  });","file":"smoke.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should indicate that it is not changed if initial state","suites":["State",".changed"],"updatePoint":{"line":119,"column":63},"line":119,"code":"    it('should indicate that it is not changed if initial state', () => {\n      expect(machine.initialState.changed).not.toBeDefined();\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"states from external transitions with entry actions should be changed","suites":["State",".changed"],"updatePoint":{"line":123,"column":77},"line":123,"code":"    it('states from external transitions with entry actions should be changed', () => {\n      const changedState = machine.transition(machine.initialState, 'EXTERNAL');\n      expect(changedState.changed).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"states from internal transitions with no actions should be unchanged","suites":["State",".changed"],"updatePoint":{"line":128,"column":76},"line":128,"code":"    it('states from internal transitions with no actions should be unchanged', () => {\n      const changedState = machine.transition(machine.initialState, 'EXTERNAL');\n      const unchangedState = machine.transition(changedState, 'INERT');\n      expect(unchangedState.changed).toBe(false);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"states from internal transitions with actions should be changed","suites":["State",".changed"],"updatePoint":{"line":134,"column":71},"line":134,"code":"    it('states from internal transitions with actions should be changed', () => {\n      const changedState = machine.transition(machine.initialState, 'INTERNAL');\n      expect(changedState.changed).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"normal state transitions should be changed (initial state)","suites":["State",".changed"],"updatePoint":{"line":139,"column":66},"line":139,"code":"    it('normal state transitions should be changed (initial state)', () => {\n      const changedState = machine.transition(machine.initialState, 'TO_TWO');\n      expect(changedState.changed).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"normal state transitions should be changed","suites":["State",".changed"],"updatePoint":{"line":144,"column":50},"line":144,"code":"    it('normal state transitions should be changed', () => {\n      const twoState = machine.transition(machine.initialState, 'TO_TWO');\n      const changedState = machine.transition(twoState, 'FOO_EVENT');\n      expect(changedState.changed).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"normal state transitions with unknown event should be unchanged","suites":["State",".changed"],"updatePoint":{"line":150,"column":71},"line":150,"code":"    it('normal state transitions with unknown event should be unchanged', () => {\n      const twoState = machine.transition(machine.initialState, 'TO_TWO');\n      const changedState = machine.transition(twoState, 'UNKNOWN_EVENT' as any);\n      expect(changedState.changed).toBe(false);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should report entering a final state as changed","suites":["State",".changed"],"updatePoint":{"line":156,"column":55},"line":156,"code":"    it('should report entering a final state as changed', () => {\n      const finalMachine = Machine({\n        id: 'final',\n        initial: 'one',\n        states: {\n          one: {\n            on: {\n              DONE: 'two'\n            }\n          },\n\n          two: {\n            type: 'final'\n          }\n        }\n      });\n\n      const twoState = finalMachine.transition('one', 'DONE');\n\n      expect(twoState.changed).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should report any internal transition assignments as changed","suites":["State",".changed"],"updatePoint":{"line":178,"column":68},"line":178,"code":"    it('should report any internal transition assignments as changed', () => {\n      const assignMachine = Machine<{ count: number }>({\n        id: 'assign',\n        initial: 'same',\n        context: {\n          count: 0\n        },\n        states: {\n          same: {\n            on: {\n              EVENT: {\n                actions: assign({ count: (ctx) => ctx.count + 1 })\n              }\n            }\n          }\n        }\n      });\n\n      const { initialState } = assignMachine;\n      const changedState = assignMachine.transition(initialState, 'EVENT');\n      expect(changedState.changed).toBe(true);\n      expect(initialState.value).toEqual(changedState.value);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not escape targetless child state nodes","suites":["State",".changed"],"updatePoint":{"line":202,"column":54},"line":202,"code":"    it('should not escape targetless child state nodes', () => {\n      interface Ctx {\n        value: string;\n      }\n      type ToggleEvents =\n        | {\n            type: 'CHANGE';\n            value: string;\n          }\n        | {\n            type: 'SAVE';\n          };\n      const toggleMachine = Machine<Ctx, ToggleEvents>({\n        id: 'input',\n        context: {\n          value: ''\n        },\n        type: 'parallel',\n        states: {\n          edit: {\n            on: {\n              CHANGE: {\n                actions: assign({\n                  value: (_, e) => {\n                    return e.value;\n                  }\n                })\n              }\n            }\n          },\n          validity: {\n            initial: 'invalid',\n            states: {\n              invalid: {},\n              valid: {}\n            },\n            on: {\n              CHANGE: [\n                {\n                  target: '.valid',\n                  cond: () => true\n                },\n                {\n                  target: '.invalid'\n                }\n              ]\n            }\n          }\n        }\n      });\n\n      const nextState = toggleMachine.transition(toggleMachine.initialState, {\n        type: 'CHANGE',\n        value: 'whatever'\n      });\n\n      expect(nextState.changed).toBe(true);\n      expect(nextState.value).toEqual({\n        edit: {},\n        validity: 'valid'\n      });\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"returns the next possible events for the current state","suites":["State",".nextEvents"],"updatePoint":{"line":267,"column":62},"line":267,"code":"    it('returns the next possible events for the current state', () => {\n      expect(machine.initialState.nextEvents.sort()).toEqual([\n        'EXTERNAL',\n        'INERT',\n        'INTERNAL',\n        'MACHINE_EVENT',\n        'TO_FINAL',\n        'TO_THREE',\n        'TO_TWO',\n        'TO_TWO_MAYBE'\n      ]);\n\n      expect(\n        machine.transition(machine.initialState, 'TO_TWO').nextEvents.sort()\n      ).toEqual(['DEEP_EVENT', 'FOO_EVENT', 'MACHINE_EVENT']);\n\n      expect(\n        machine.transition(machine.initialState, 'TO_THREE').nextEvents.sort()\n      ).toEqual(['MACHINE_EVENT', 'P31', 'P32', 'THREE_EVENT']);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"returns events when transitioned from StateValue","suites":["State",".nextEvents"],"updatePoint":{"line":288,"column":56},"line":288,"code":"    it('returns events when transitioned from StateValue', () => {\n      const A = machine.transition(machine.initialState, 'TO_THREE');\n      const B = machine.transition(A.value, 'TO_THREE');\n\n      expect(B.nextEvents.sort()).toEqual([\n        'MACHINE_EVENT',\n        'P31',\n        'P32',\n        'THREE_EVENT'\n      ]);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"returns no next events if there are none","suites":["State",".nextEvents"],"updatePoint":{"line":300,"column":48},"line":300,"code":"    it('returns no next events if there are none', () => {\n      const noEventsMachine = Machine({\n        id: 'no-events',\n        initial: 'idle',\n        states: {\n          idle: {\n            on: {}\n          }\n        }\n      });\n\n      expect(noEventsMachine.initialState.nextEvents).toEqual([]);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to create a state from a JSON config","suites":["State","State.create()"],"updatePoint":{"line":316,"column":59},"line":316,"code":"    it('should be able to create a state from a JSON config', () => {\n      const { initialState } = machine;\n      const jsonInitialState = JSON.parse(JSON.stringify(initialState));\n\n      const stateFromConfig = State.create(jsonInitialState) as StateFrom<\n        typeof machine\n      >;\n\n      expect(machine.transition(stateFromConfig, 'TO_TWO').value).toEqual({\n        two: { deep: 'foo' }\n      });\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should preserve state.nextEvents using machine.resolveState","suites":["State","State.create()"],"updatePoint":{"line":329,"column":67},"line":329,"code":"    it('should preserve state.nextEvents using machine.resolveState', () => {\n      const { initialState } = machine;\n      const { nextEvents } = initialState;\n      const jsonInitialState = JSON.parse(JSON.stringify(initialState));\n\n      const stateFromConfig = State.create(jsonInitialState) as StateFrom<\n        typeof machine\n      >;\n\n      expect(machine.resolveState(stateFromConfig).nextEvents.sort()).toEqual(\n        nextEvents.sort()\n      );\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should create an inert instance of the given State","suites":["State","State.inert()"],"updatePoint":{"line":345,"column":58},"line":345,"code":"    it('should create an inert instance of the given State', () => {\n      const { initialState } = machine;\n\n      expect(State.inert(initialState, undefined).actions).toEqual([]);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should create an inert instance of the given stateValue and context","suites":["State","State.inert()"],"updatePoint":{"line":351,"column":75},"line":351,"code":"    it('should create an inert instance of the given stateValue and context', () => {\n      const { initialState } = machine;\n      const inertState = State.inert(initialState.value, { foo: 'bar' });\n\n      expect(inertState.actions).toEqual([]);\n      expect(inertState.context).toEqual({ foo: 'bar' });\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should preserve the given State if there are no actions","suites":["State","State.inert()"],"updatePoint":{"line":359,"column":63},"line":359,"code":"    it('should preserve the given State if there are no actions', () => {\n      const naturallyInertState = State.from('foo');\n\n      expect(State.inert(naturallyInertState, undefined)).toEqual(\n        naturallyInertState\n      );\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"the .event prop should be the event (string) that caused the transition","suites":["State",".event"],"updatePoint":{"line":369,"column":79},"line":369,"code":"    it('the .event prop should be the event (string) that caused the transition', () => {\n      const { initialState } = machine;\n\n      const nextState = machine.transition(initialState, 'TO_TWO');\n\n      expect(nextState.event).toEqual({ type: 'TO_TWO' });\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"the .event prop should be the event (object) that caused the transition","suites":["State",".event"],"updatePoint":{"line":377,"column":79},"line":377,"code":"    it('the .event prop should be the event (object) that caused the transition', () => {\n      const { initialState } = machine;\n\n      const nextState = machine.transition(initialState, {\n        type: 'TO_TWO',\n        foo: 'bar'\n      });\n\n      expect(nextState.event).toEqual({ type: 'TO_TWO', foo: 'bar' });\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"the ._event prop should be the initial event for the initial state","suites":["State",".event"],"updatePoint":{"line":388,"column":74},"line":388,"code":"    it('the ._event prop should be the initial event for the initial state', () => {\n      const { initialState } = machine;\n\n      expect(initialState._event).toEqual(initEvent);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"the ._event prop should be the SCXML event (string) that caused the transition","suites":["State","._event"],"updatePoint":{"line":396,"column":86},"line":396,"code":"    it('the ._event prop should be the SCXML event (string) that caused the transition', () => {\n      const { initialState } = machine;\n\n      const nextState = machine.transition(initialState, 'TO_TWO');\n\n      expect(nextState._event).toEqual(toSCXMLEvent('TO_TWO'));\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"the ._event prop should be the SCXML event (object) that caused the transition","suites":["State","._event"],"updatePoint":{"line":404,"column":86},"line":404,"code":"    it('the ._event prop should be the SCXML event (object) that caused the transition', () => {\n      const { initialState } = machine;\n\n      const nextState = machine.transition(initialState, {\n        type: 'TO_TWO',\n        foo: 'bar'\n      });\n\n      expect(nextState._event).toEqual(\n        toSCXMLEvent({ type: 'TO_TWO', foo: 'bar' })\n      );\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"the ._event prop should be the initial SCXML event for the initial state","suites":["State","._event"],"updatePoint":{"line":417,"column":80},"line":417,"code":"    it('the ._event prop should be the initial SCXML event for the initial state', () => {\n      const { initialState } = machine;\n\n      expect(initialState._event).toEqual(toSCXMLEvent(initEvent));\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"the ._event prop should be the SCXML event (SCXML metadata) that caused the transition","suites":["State","._event"],"updatePoint":{"line":423,"column":94},"line":423,"code":"    it('the ._event prop should be the SCXML event (SCXML metadata) that caused the transition', () => {\n      const { initialState } = machine;\n\n      const nextState = machine.transition(\n        initialState,\n        toSCXMLEvent(\n          {\n            type: 'TO_TWO',\n            foo: 'bar'\n          },\n          {\n            sendid: 'test'\n          }\n        )\n      );\n\n      expect(nextState._event).toEqual(\n        toSCXMLEvent(\n          { type: 'TO_TWO', foo: 'bar' },\n          {\n            sendid: 'test'\n          }\n        )\n      );\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"_sessionid should be null for non-invoked machines","suites":["State","._event","_sessionid"],"updatePoint":{"line":450,"column":60},"line":450,"code":"      it('_sessionid should be null for non-invoked machines', () => {\n        const testMachine = Machine({\n          initial: 'active',\n          states: {\n            active: {}\n          }\n        });\n\n        expect(testMachine.initialState._sessionid).toBeNull();\n      });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"_sessionid should be the service sessionId for invoked machines","suites":["State","._event","_sessionid"],"updatePoint":{"line":461,"column":73},"line":461,"code":"      it('_sessionid should be the service sessionId for invoked machines', (done) => {\n        const testMachine = Machine({\n          initial: 'active',\n          states: {\n            active: {\n              on: {\n                TOGGLE: 'inactive'\n              }\n            },\n            inactive: {\n              type: 'final'\n            }\n          }\n        });\n\n        const service = interpret(testMachine);\n\n        service\n          .onTransition((state) => {\n            expect(state._sessionid).toEqual(service.sessionId);\n          })\n          .onDone(() => {\n            done();\n          })\n          .start();\n\n        service.send('TOGGLE');\n      });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"_sessionid should persist through states (manual)","suites":["State","._event","_sessionid"],"updatePoint":{"line":490,"column":59},"line":490,"code":"      it('_sessionid should persist through states (manual)', () => {\n        const testMachine = Machine({\n          initial: 'active',\n          states: {\n            active: {\n              on: {\n                TOGGLE: 'inactive'\n              }\n            },\n            inactive: {\n              type: 'final'\n            }\n          }\n        });\n\n        const { initialState } = testMachine;\n\n        initialState._sessionid = 'somesessionid';\n\n        const nextState = testMachine.transition(initialState, 'TOGGLE');\n\n        expect(nextState._sessionid).toEqual('somesessionid');\n      });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have no transitions for the initial state","suites":["State",".transitions"],"updatePoint":{"line":519,"column":56},"line":519,"code":"    it('should have no transitions for the initial state', () => {\n      expect(initialState.transitions).toHaveLength(0);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have transitions for the sent event","suites":["State",".transitions"],"updatePoint":{"line":523,"column":50},"line":523,"code":"    it('should have transitions for the sent event', () => {\n      expect(\n        machine.transition(initialState, 'TO_TWO').transitions\n      ).toContainEqual(expect.objectContaining({ eventType: 'TO_TWO' }));\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have condition in the transition","suites":["State",".transitions"],"updatePoint":{"line":529,"column":47},"line":529,"code":"    it('should have condition in the transition', () => {\n      expect(\n        machine.transition(initialState, 'TO_TWO_MAYBE').transitions\n      ).toContainEqual(\n        expect.objectContaining({\n          eventType: 'TO_TWO_MAYBE',\n          cond: expect.objectContaining({ name: 'maybe' })\n        })\n      );\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should keep reference to state instance after destructuring","suites":["State","State.prototype.matches"],"updatePoint":{"line":542,"column":67},"line":542,"code":"    it('should keep reference to state instance after destructuring', () => {\n      const { initialState } = machine;\n      const { matches } = initialState;\n\n      expect(matches('one')).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return all state paths as strings","suites":["State","State.prototype.toStrings"],"updatePoint":{"line":551,"column":48},"line":551,"code":"    it('should return all state paths as strings', () => {\n      const twoState = machine.transition('one', 'TO_TWO');\n\n      expect(twoState.toStrings()).toEqual(['two', 'two.deep', 'two.deep.foo']);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should respect `delimiter` option for deeply nested states","suites":["State","State.prototype.toStrings"],"updatePoint":{"line":557,"column":66},"line":557,"code":"    it('should respect `delimiter` option for deeply nested states', () => {\n      const twoState = machine.transition('one', 'TO_TWO');\n\n      expect(twoState.toStrings(undefined, ':')).toEqual([\n        'two',\n        'two:deep',\n        'two:deep:foo'\n      ]);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should keep reference to state instance after destructuring","suites":["State","State.prototype.toStrings"],"updatePoint":{"line":567,"column":67},"line":567,"code":"    it('should keep reference to state instance after destructuring', () => {\n      const { initialState } = machine;\n      const { toStrings } = initialState;\n\n      expect(toStrings()).toEqual(['one']);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should show that a machine has not reached its final state","suites":["State",".done"],"updatePoint":{"line":576,"column":66},"line":576,"code":"    it('should show that a machine has not reached its final state', () => {\n      expect(machine.initialState.done).toBeFalsy();\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should show that a machine has reached its final state","suites":["State",".done"],"updatePoint":{"line":580,"column":62},"line":580,"code":"    it('should show that a machine has reached its final state', () => {\n      expect(machine.transition(undefined, 'TO_FINAL').done).toBeTruthy();\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true for a simple event that results in a transition to a different state","suites":["State",".can"],"updatePoint":{"line":586,"column":95},"line":586,"code":"    it('should return true for a simple event that results in a transition to a different state', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              NEXT: 'b'\n            }\n          },\n          b: {}\n        }\n      });\n\n      expect(machine.initialState.can('NEXT')).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true for an event object that results in a transition to a different state","suites":["State",".can"],"updatePoint":{"line":602,"column":96},"line":602,"code":"    it('should return true for an event object that results in a transition to a different state', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              NEXT: 'b'\n            }\n          },\n          b: {}\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'NEXT' })).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true for an event object that results in a new action","suites":["State",".can"],"updatePoint":{"line":618,"column":75},"line":618,"code":"    it('should return true for an event object that results in a new action', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              NEXT: {\n                actions: 'newAction'\n              }\n            }\n          }\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'NEXT' })).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true for an event object that results in a context change","suites":["State",".can"],"updatePoint":{"line":635,"column":79},"line":635,"code":"    it('should return true for an event object that results in a context change', () => {\n      const machine = createMachine({\n        initial: 'a',\n        context: { count: 0 },\n        states: {\n          a: {\n            on: {\n              NEXT: {\n                actions: assign({ count: 1 })\n              }\n            }\n          }\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'NEXT' })).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true for an external self-transition without actions","suites":["State",".can"],"updatePoint":{"line":653,"column":74},"line":653,"code":"    it('should return true for an external self-transition without actions', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              EV: 'a'\n            }\n          }\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'EV' })).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true for an external self-transition with reentry action","suites":["State",".can"],"updatePoint":{"line":668,"column":78},"line":668,"code":"    it('should return true for an external self-transition with reentry action', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            entry: () => {},\n            on: {\n              EV: 'a'\n            }\n          }\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'EV' })).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true for an external self-transition with transition action","suites":["State",".can"],"updatePoint":{"line":684,"column":81},"line":684,"code":"    it('should return true for an external self-transition with transition action', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              EV: {\n                target: 'a',\n                actions: () => {}\n              }\n            }\n          }\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'EV' })).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true for a targetless transition with actions","suites":["State",".can"],"updatePoint":{"line":702,"column":67},"line":702,"code":"    it('should return true for a targetless transition with actions', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              EV: {\n                actions: () => {}\n              }\n            }\n          }\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'EV' })).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false for a forbidden transition","suites":["State",".can"],"updatePoint":{"line":719,"column":54},"line":719,"code":"    it('should return false for a forbidden transition', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              EV: undefined\n            }\n          }\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'EV' })).toBe(false);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false for an unknown event","suites":["State",".can"],"updatePoint":{"line":734,"column":48},"line":734,"code":"    it('should return false for an unknown event', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              NEXT: 'b'\n            }\n          },\n          b: {}\n        }\n      });\n\n      expect(machine.initialState.can({ type: 'UNKNOWN' })).toBe(false);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true when a guarded transition allows the transition","suites":["State",".can"],"updatePoint":{"line":750,"column":74},"line":750,"code":"    it('should return true when a guarded transition allows the transition', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              CHECK: {\n                target: 'b',\n                cond: () => true\n              }\n            }\n          },\n          b: {}\n        }\n      });\n\n      expect(\n        machine.initialState.can({\n          type: 'CHECK'\n        })\n      ).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false when a guarded transition disallows the transition","suites":["State",".can"],"updatePoint":{"line":773,"column":78},"line":773,"code":"    it('should return false when a guarded transition disallows the transition', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              CHECK: {\n                target: 'b',\n                cond: () => false\n              }\n            }\n          },\n          b: {}\n        }\n      });\n\n      expect(\n        machine.initialState.can({\n          type: 'CHECK'\n        })\n      ).toBe(false);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not spawn actors when determining if an event is accepted","suites":["State",".can"],"updatePoint":{"line":796,"column":72},"line":796,"code":"    it('should not spawn actors when determining if an event is accepted', () => {\n      let spawned = false;\n      const machine = createMachine({\n        context: {},\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              SPAWN: {\n                actions: assign(() => ({\n                  ref: spawn(() => {\n                    spawned = true;\n                  })\n                }))\n              }\n            }\n          },\n          b: {}\n        }\n      });\n\n      const service = interpret(machine).start();\n      service.state.can('SPAWN');\n      expect(spawned).toBe(false);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false for states created without a machine","suites":["State",".can"],"updatePoint":{"line":822,"column":64},"line":822,"code":"    it('should return false for states created without a machine', () => {\n      const state = State.from('test');\n\n      expect(state.can({ type: 'ANY_EVENT' })).toEqual(false);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not execute assignments","suites":["State",".can"],"updatePoint":{"line":828,"column":38},"line":828,"code":"    it('should not execute assignments', () => {\n      let executed = false;\n      const machine = createMachine({\n        context: {},\n        on: {\n          EVENT: {\n            actions: assign((ctx) => {\n              // Side-effect just for testing\n              executed = true;\n              return ctx;\n            })\n          }\n        }\n      });\n\n      const { initialState } = machine;\n\n      expect(initialState.can('EVENT')).toBeTruthy();\n\n      expect(executed).toBeFalsy();\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true when non-first parallel region changes value","suites":["State",".can"],"updatePoint":{"line":850,"column":71},"line":850,"code":"    it('should return true when non-first parallel region changes value', () => {\n      const machine = createMachine({\n        type: 'parallel',\n        states: {\n          a: {\n            initial: 'a1',\n            states: {\n              a1: {\n                id: 'foo',\n                on: {\n                  // first region doesn't change value here\n                  EVENT: { target: ['#foo', '#bar'] }\n                }\n              }\n            }\n          },\n          b: {\n            initial: 'b1',\n            states: {\n              b1: {},\n              b2: {\n                id: 'bar'\n              }\n            }\n          }\n        }\n      });\n\n      expect(machine.initialState.can('EVENT')).toBeTruthy();\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true when transition targets a state that is already part of the current configuration but the final state value changes","suites":["State",".can"],"updatePoint":{"line":881,"column":142},"line":881,"code":"    it('should return true when transition targets a state that is already part of the current configuration but the final state value changes', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            id: 'foo',\n            initial: 'a1',\n            states: {\n              a1: {\n                on: {\n                  NEXT: 'a2'\n                }\n              },\n              a2: {\n                on: {\n                  NEXT: '#foo'\n                }\n              }\n            }\n          }\n        }\n      });\n\n      const nextState = machine.transition(undefined, { type: 'NEXT' });\n\n      expect(nextState.can({ type: 'NEXT' })).toBeTruthy();\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to check a tag after recreating a persisted state","suites":["State",".hasTag"],"updatePoint":{"line":911,"column":72},"line":911,"code":"    it('should be able to check a tag after recreating a persisted state', () => {\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            tags: 'foo'\n          }\n        }\n      });\n\n      const persistedState = JSON.stringify(machine.initialState);\n      const restoredState = State.create(JSON.parse(persistedState));\n\n      expect(restoredState.hasTag('foo')).toBe(true);\n    });","file":"state.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition if string state path matches current state value","suites":["transition \"in\" check"],"updatePoint":{"line":94,"column":72},"line":94,"code":"  it('should transition if string state path matches current state value', () => {\n    expect(\n      machine.transition(\n        {\n          a: 'a1',\n          b: {\n            b2: {\n              foo: 'foo2',\n              bar: 'bar1'\n            }\n          }\n        },\n        'EVENT1'\n      ).value\n    ).toEqual({\n      a: 'a2',\n      b: {\n        b2: {\n          foo: 'foo2',\n          bar: 'bar1'\n        }\n      }\n    });\n  });","file":"stateIn.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transition if state node ID matches current state value","suites":["transition \"in\" check"],"updatePoint":{"line":119,"column":68},"line":119,"code":"  it('should transition if state node ID matches current state value', () => {\n    expect(\n      machine.transition(\n        {\n          a: 'a1',\n          b: {\n            b2: {\n              foo: 'foo2',\n              bar: 'bar1'\n            }\n          }\n        },\n        'EVENT3'\n      ).value\n    ).toEqual({\n      a: 'a2',\n      b: {\n        b2: {\n          foo: 'foo2',\n          bar: 'bar1'\n        }\n      }\n    });\n  });","file":"stateIn.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not transition if string state path does not match current state value","suites":["transition \"in\" check"],"updatePoint":{"line":144,"column":83},"line":144,"code":"  it('should not transition if string state path does not match current state value', () => {\n    expect(machine.transition({ a: 'a1', b: 'b1' }, 'EVENT1').value).toEqual({\n      a: 'a1',\n      b: 'b1'\n    });\n  });","file":"stateIn.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not transition if state value matches current state value","suites":["transition \"in\" check"],"updatePoint":{"line":151,"column":70},"line":151,"code":"  it('should not transition if state value matches current state value', () => {\n    expect(\n      machine.transition(\n        {\n          a: 'a1',\n          b: {\n            b2: {\n              foo: 'foo2',\n              bar: 'bar1'\n            }\n          }\n        },\n        'EVENT2'\n      ).value\n    ).toEqual({\n      a: 'a2',\n      b: {\n        b2: {\n          foo: 'foo2',\n          bar: 'bar1'\n        }\n      }\n    });\n  });","file":"stateIn.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"matching should be relative to grandparent (match)","suites":["transition \"in\" check"],"updatePoint":{"line":176,"column":56},"line":176,"code":"  it('matching should be relative to grandparent (match)', () => {\n    expect(\n      machine.transition(\n        { a: 'a1', b: { b2: { foo: 'foo1', bar: 'bar1' } } },\n        'EVENT_DEEP'\n      ).value\n    ).toEqual({\n      a: 'a1',\n      b: {\n        b2: {\n          foo: 'foo2',\n          bar: 'bar1'\n        }\n      }\n    });\n  });","file":"stateIn.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"matching should be relative to grandparent (no match)","suites":["transition \"in\" check"],"updatePoint":{"line":193,"column":59},"line":193,"code":"  it('matching should be relative to grandparent (no match)', () => {\n    expect(\n      machine.transition(\n        { a: 'a1', b: { b2: { foo: 'foo1', bar: 'bar2' } } },\n        'EVENT_DEEP'\n      ).value\n    ).toEqual({\n      a: 'a1',\n      b: {\n        b2: {\n          foo: 'foo1',\n          bar: 'bar2'\n        }\n      }\n    });\n  });","file":"stateIn.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work to forbid events","suites":["transition \"in\" check"],"updatePoint":{"line":210,"column":34},"line":210,"code":"  it('should work to forbid events', () => {\n    const walkState = lightMachine.transition('red.walk', 'TIMER');\n\n    expect(walkState.value).toEqual({ red: 'walk' });\n\n    const waitState = lightMachine.transition('red.wait', 'TIMER');\n\n    expect(waitState.value).toEqual({ red: 'wait' });\n\n    const stopState = lightMachine.transition('red.stop', 'TIMER');\n\n    expect(stopState.value).toEqual('green');\n  });","file":"stateIn.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw for unacceptable events","suites":["strict mode"],"updatePoint":{"line":64,"column":42},"line":64,"code":"  it('should throw for unacceptable events', () => {\n    expect(() => {\n      lightMachine.transition('green', 'FOO');\n    }).toThrow();\n  });","file":"strict.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not throw for built-in events","suites":["strict mode"],"updatePoint":{"line":70,"column":42},"line":70,"code":"  it('should not throw for built-in events', () => {\n    expect(() => {\n      lightMachine.transition('red.wait', 'PED_COUNTDOWN');\n    }).not.toThrow();\n  });","file":"strict.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"supports tagging states","suites":["tags"],"updatePoint":{"line":4,"column":29},"line":4,"code":"  it('supports tagging states', () => {\n    const machine = createMachine({\n      initial: 'green',\n      states: {\n        green: {\n          tags: ['go']\n        },\n        yellow: {\n          tags: ['go'],\n          on: {\n            TIMER: 'red'\n          }\n        },\n        red: {\n          tags: ['stop']\n        }\n      }\n    });\n\n    expect(machine.initialState.hasTag('go')).toBeTruthy();\n    expect(machine.transition('yellow', 'TIMER').hasTag('go')).toBeFalsy();\n  });","file":"tags.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"supports tags in compound states","suites":["tags"],"updatePoint":{"line":27,"column":38},"line":27,"code":"  it('supports tags in compound states', () => {\n    const machine = createMachine({\n      initial: 'red',\n      states: {\n        green: {\n          tags: ['go']\n        },\n        yellow: {},\n        red: {\n          tags: ['stop'],\n          initial: 'walk',\n          states: {\n            walk: {\n              tags: ['crosswalkLight']\n            },\n            wait: {\n              tags: ['crosswalkLight']\n            }\n          }\n        }\n      }\n    });\n\n    expect(machine.initialState.hasTag('go')).toBeFalsy();\n    expect(machine.initialState.hasTag('stop')).toBeTruthy();\n    expect(machine.initialState.hasTag('crosswalkLight')).toBeTruthy();\n  });","file":"tags.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"supports tags in parallel states","suites":["tags"],"updatePoint":{"line":55,"column":38},"line":55,"code":"  it('supports tags in parallel states', () => {\n    const machine = createMachine({\n      type: 'parallel',\n      states: {\n        foo: {\n          initial: 'active',\n          states: {\n            active: {\n              tags: 'yes'\n            },\n            inactive: {\n              tags: 'no'\n            }\n          }\n        },\n        bar: {\n          initial: 'active',\n          states: {\n            active: {\n              tags: 'yes',\n              on: {\n                DEACTIVATE: 'inactive'\n              }\n            },\n            inactive: {\n              tags: 'no'\n            }\n          }\n        }\n      }\n    });\n\n    let state = machine.initialState;\n\n    expect(state.tags).toEqual(new Set(['yes']));\n    state = machine.transition(state, 'DEACTIVATE');\n    expect(state.tags).toEqual(new Set(['yes', 'no']));\n  });","file":"tags.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"sets tags correctly after not selecting any transition","suites":["tags"],"updatePoint":{"line":94,"column":60},"line":94,"code":"  it('sets tags correctly after not selecting any transition', () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          tags: 'myTag'\n        }\n      }\n    });\n\n    const state = machine.transition(machine.initialState, {\n      type: 'UNMATCHED'\n    });\n    expect(state.hasTag('myTag')).toBeTruthy();\n  });","file":"tags.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"tags can be single (not array)","suites":["tags"],"updatePoint":{"line":110,"column":36},"line":110,"code":"  it('tags can be single (not array)', () => {\n    const machine = createMachine({\n      initial: 'green',\n      states: {\n        green: {\n          tags: 'go'\n        }\n      }\n    });\n\n    expect(machine.initialState.hasTag('go')).toBeTruthy();\n  });","file":"tags.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"stringifies to an array","suites":["tags"],"updatePoint":{"line":123,"column":29},"line":123,"code":"  it('stringifies to an array', () => {\n    const machine = createMachine({\n      initial: 'green',\n      states: {\n        green: {\n          tags: ['go', 'light']\n        }\n      }\n    });\n\n    const jsonState = machine.initialState.toJSON();\n\n    expect(jsonState.tags).toEqual(['go', 'light']);\n  });","file":"tags.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should choose the first candidate target that matches the cond (D)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":54,"column":72},"line":54,"code":"  it('should choose the first candidate target that matches the cond (D)', () => {\n    const nextState = updateMachine.transition('G', 'UPDATE_BUTTON_CLICKED', {\n      data: false\n    });\n    expect(nextState.value).toEqual('D');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should choose the first candidate target that matches the cond (B)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":61,"column":72},"line":61,"code":"  it('should choose the first candidate target that matches the cond (B)', () => {\n    const nextState = updateMachine.transition('G', 'UPDATE_BUTTON_CLICKED', {\n      data: true,\n      status: 'Y'\n    });\n    expect(nextState.value).toEqual('B');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should choose the first candidate target that matches the cond (C)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":69,"column":72},"line":69,"code":"  it('should choose the first candidate target that matches the cond (C)', () => {\n    const nextState = updateMachine.transition('G', 'UPDATE_BUTTON_CLICKED', {\n      data: true,\n      status: 'X'\n    });\n    expect(nextState.value).toEqual('C');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should choose the final candidate without a cond if none others match","suites":["transient states (eventless transitions)"],"updatePoint":{"line":77,"column":75},"line":77,"code":"  it('should choose the final candidate without a cond if none others match', () => {\n    const nextState = updateMachine.transition('G', 'UPDATE_BUTTON_CLICKED', {\n      data: true,\n      status: 'other'\n    });\n    expect(nextState.value).toEqual('F');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should carry actions from previous transitions within same step","suites":["transient states (eventless transitions)"],"updatePoint":{"line":85,"column":69},"line":85,"code":"  it('should carry actions from previous transitions within same step', () => {\n    const machine = Machine({\n      initial: 'A',\n      states: {\n        A: {\n          onExit: 'exit_A',\n          on: {\n            TIMER: {\n              target: 'T',\n              actions: ['timer']\n            }\n          }\n        },\n        T: {\n          on: {\n            '': [{ target: 'B' }]\n          }\n        },\n        B: {\n          onEntry: 'enter_B'\n        }\n      }\n    });\n\n    const state = machine.transition('A', 'TIMER');\n\n    expect(state.actions.map((a) => a.type)).toEqual([\n      'exit_A',\n      'timer',\n      'enter_B'\n    ]);\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute all internal events one after the other","suites":["transient states (eventless transitions)"],"updatePoint":{"line":118,"column":60},"line":118,"code":"  it('should execute all internal events one after the other', () => {\n    const machine = Machine({\n      type: 'parallel',\n      states: {\n        A: {\n          initial: 'A1',\n          states: {\n            A1: {\n              on: {\n                E: 'A2'\n              }\n            },\n            A2: {\n              onEntry: raise('INT1')\n            }\n          }\n        },\n\n        B: {\n          initial: 'B1',\n          states: {\n            B1: {\n              on: {\n                E: 'B2'\n              }\n            },\n            B2: {\n              onEntry: raise('INT2')\n            }\n          }\n        },\n\n        C: {\n          initial: 'C1',\n          states: {\n            C1: {\n              on: {\n                INT1: 'C2',\n                INT2: 'C3'\n              }\n            },\n            C2: {\n              on: {\n                INT2: 'C4'\n              }\n            },\n            C3: {\n              on: {\n                INT1: 'C4'\n              }\n            },\n            C4: {}\n          }\n        }\n      }\n    });\n\n    const state = machine.transition(machine.initialState, 'E');\n\n    expect(state.value).toEqual({ A: 'A2', B: 'B2', C: 'C4' });\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute all eventless transitions in the same microstep","suites":["transient states (eventless transitions)"],"updatePoint":{"line":180,"column":68},"line":180,"code":"  it('should execute all eventless transitions in the same microstep', () => {\n    const machine = Machine({\n      type: 'parallel',\n      states: {\n        A: {\n          initial: 'A1',\n          states: {\n            A1: {\n              on: {\n                E: 'A2' // the external event\n              }\n            },\n            A2: {\n              on: {\n                '': 'A3'\n              }\n            },\n            A3: {\n              on: {\n                '': {\n                  target: 'A4',\n                  in: 'B.B3'\n                }\n              }\n            },\n            A4: {}\n          }\n        },\n\n        B: {\n          initial: 'B1',\n          states: {\n            B1: {\n              on: {\n                E: 'B2'\n              }\n            },\n            B2: {\n              on: {\n                '': {\n                  target: 'B3',\n                  in: 'A.A2'\n                }\n              }\n            },\n            B3: {\n              on: {\n                '': {\n                  target: 'B4',\n                  in: 'A.A3'\n                }\n              }\n            },\n            B4: {}\n          }\n        }\n      }\n    });\n\n    const state = machine.transition(machine.initialState, 'E');\n\n    expect(state.value).toEqual({ A: 'A4', B: 'B4' });\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should execute all eventless transitions in the same microstep (with `always`)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":244,"column":84},"line":244,"code":"  it('should execute all eventless transitions in the same microstep (with `always`)', () => {\n    const machine = Machine({\n      type: 'parallel',\n      states: {\n        A: {\n          initial: 'A1',\n          states: {\n            A1: {\n              on: {\n                E: 'A2' // the external event\n              }\n            },\n            A2: {\n              always: 'A3'\n            },\n            A3: {\n              always: {\n                target: 'A4',\n                in: 'B.B3'\n              }\n            },\n            A4: {}\n          }\n        },\n\n        B: {\n          initial: 'B1',\n          states: {\n            B1: {\n              on: {\n                E: 'B2'\n              }\n            },\n            B2: {\n              always: {\n                target: 'B3',\n                in: 'A.A2'\n              }\n            },\n            B3: {\n              always: {\n                target: 'B4',\n                in: 'A.A3'\n              }\n            },\n            B4: {}\n          }\n        }\n      }\n    });\n\n    const state = machine.transition(machine.initialState, 'E');\n\n    expect(state.value).toEqual({ A: 'A4', B: 'B4' });\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should check for automatic transitions even after microsteps are done","suites":["transient states (eventless transitions)"],"updatePoint":{"line":300,"column":75},"line":300,"code":"  it('should check for automatic transitions even after microsteps are done', () => {\n    const machine = Machine({\n      type: 'parallel',\n      states: {\n        A: {\n          initial: 'A1',\n          states: {\n            A1: {\n              on: {\n                A: 'A2'\n              }\n            },\n            A2: {}\n          }\n        },\n        B: {\n          initial: 'B1',\n          states: {\n            B1: {\n              on: {\n                '': {\n                  target: 'B2',\n                  cond: (_xs, _e, { state: s }) => s.matches('A.A2')\n                }\n              }\n            },\n            B2: {}\n          }\n        },\n        C: {\n          initial: 'C1',\n          states: {\n            C1: {\n              on: {\n                '': {\n                  target: 'C2',\n                  in: 'A.A2'\n                }\n              }\n            },\n            C2: {}\n          }\n        }\n      }\n    });\n\n    let state = machine.initialState; // A1, B1, C1\n    state = machine.transition(state, 'A'); // A2, B2, C2\n    expect(state.value).toEqual({ A: 'A2', B: 'B2', C: 'C2' });\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should check for automatic transitions even after microsteps are done (with `always`)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":351,"column":91},"line":351,"code":"  it('should check for automatic transitions even after microsteps are done (with `always`)', () => {\n    const machine = Machine({\n      type: 'parallel',\n      states: {\n        A: {\n          initial: 'A1',\n          states: {\n            A1: {\n              on: {\n                A: 'A2'\n              }\n            },\n            A2: {}\n          }\n        },\n        B: {\n          initial: 'B1',\n          states: {\n            B1: {\n              always: {\n                target: 'B2',\n                cond: (_xs, _e, { state: s }) => s.matches('A.A2')\n              }\n            },\n            B2: {}\n          }\n        },\n        C: {\n          initial: 'C1',\n          states: {\n            C1: {\n              always: {\n                target: 'C2',\n                in: 'A.A2'\n              }\n            },\n            C2: {}\n          }\n        }\n      }\n    });\n\n    let state = machine.initialState; // A1, B1, C1\n    state = machine.transition(state, 'A'); // A2, B2, C2\n    expect(state.value).toEqual({ A: 'A2', B: 'B2', C: 'C2' });\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should determine the resolved initial state from the transient state","suites":["transient states (eventless transitions)"],"updatePoint":{"line":398,"column":74},"line":398,"code":"  it('should determine the resolved initial state from the transient state', () => {\n    expect(greetingMachine.initialState.value).toEqual('morning');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should select eventless transition before processing raised events","suites":["transient states (eventless transitions)"],"updatePoint":{"line":420,"column":72},"line":420,"code":"  it('should select eventless transition before processing raised events', () => {\n    const machine = Machine({\n      initial: 'a',\n      states: {\n        a: {\n          on: {\n            FOO: 'b'\n          }\n        },\n        b: {\n          entry: raise('BAR'),\n          on: {\n            '': 'c',\n            BAR: 'd'\n          }\n        },\n        c: {\n          on: {\n            BAR: 'e'\n          }\n        },\n        d: {},\n        e: {}\n      }\n    });\n\n    const state = machine.transition('a', 'FOO');\n    expect(state.value).toBe('e');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should select eventless transition before processing raised events (with `always`)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":450,"column":88},"line":450,"code":"  it('should select eventless transition before processing raised events (with `always`)', () => {\n    const machine = Machine({\n      initial: 'a',\n      states: {\n        a: {\n          on: {\n            FOO: 'b'\n          }\n        },\n        b: {\n          entry: raise('BAR'),\n          always: 'c',\n          on: {\n            BAR: 'd'\n          }\n        },\n        c: {\n          on: {\n            BAR: 'e'\n          }\n        },\n        d: {},\n        e: {}\n      }\n    });\n\n    const state = machine.transition('a', 'FOO');\n    expect(state.value).toBe('e');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should select eventless transition for array `.on` config","suites":["transient states (eventless transitions)"],"updatePoint":{"line":480,"column":63},"line":480,"code":"  it('should select eventless transition for array `.on` config', () => {\n    const machine = Machine({\n      initial: 'a',\n      states: {\n        a: {\n          on: { FOO: 'b' }\n        },\n        b: {\n          on: [{ event: '', target: 'pass' }]\n        },\n        pass: {}\n      }\n    });\n\n    const state = machine.transition('a', 'FOO');\n    expect(state.value).toBe('pass');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not select wildcard for eventless transition","suites":["transient states (eventless transitions)"],"updatePoint":{"line":498,"column":57},"line":498,"code":"  it('should not select wildcard for eventless transition', () => {\n    const machine = Machine({\n      initial: 'a',\n      states: {\n        a: {\n          on: { FOO: 'b' }\n        },\n        b: {\n          on: { '*': 'fail' }\n        },\n        fail: {}\n      }\n    });\n\n    const state = machine.transition('a', 'FOO');\n    expect(state.value).toBe('b');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not select wildcard for eventless transition (array `.on`)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":516,"column":71},"line":516,"code":"  it('should not select wildcard for eventless transition (array `.on`)', () => {\n    const machine = Machine({\n      initial: 'a',\n      states: {\n        a: {\n          on: { FOO: 'b' }\n        },\n        b: {\n          on: [\n            { event: '*', target: 'fail' },\n            { event: '', target: 'pass' }\n          ]\n        },\n        fail: {},\n        pass: {}\n      }\n    });\n\n    const state = machine.transition('a', 'FOO');\n    expect(state.value).toBe('pass');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not select wildcard for eventless transition (with `always`)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":538,"column":73},"line":538,"code":"  it('should not select wildcard for eventless transition (with `always`)', () => {\n    const machine = Machine({\n      initial: 'a',\n      states: {\n        a: {\n          on: { FOO: 'b' }\n        },\n        b: {\n          always: 'pass',\n          on: [{ event: '*', target: 'fail' }]\n        },\n        fail: {},\n        pass: {}\n      }\n    });\n\n    const state = machine.transition('a', 'FOO');\n    expect(state.value).toBe('pass');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with transient transition on root","suites":["transient states (eventless transitions)"],"updatePoint":{"line":558,"column":51},"line":558,"code":"  it('should work with transient transition on root', (done) => {\n    const machine = createMachine<any, any, any>({\n      id: 'machine',\n      initial: 'first',\n      context: { count: 0 },\n      states: {\n        first: {\n          on: {\n            ADD: {\n              actions: assign({ count: (ctx) => ctx.count + 1 })\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      },\n      on: {\n        '': [\n          {\n            target: '.success',\n            cond: (ctx) => {\n              return ctx.count > 0;\n            }\n          }\n        ]\n      }\n    });\n\n    const service = interpret(machine).onDone(() => {\n      done();\n    });\n\n    service.start();\n\n    service.send('ADD');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with transient transition on root (with `always`)","suites":["transient states (eventless transitions)"],"updatePoint":{"line":596,"column":67},"line":596,"code":"  it('should work with transient transition on root (with `always`)', (done) => {\n    const machine = createMachine<any, any, any>({\n      id: 'machine',\n      initial: 'first',\n      context: { count: 0 },\n      states: {\n        first: {\n          on: {\n            ADD: {\n              actions: assign({ count: (ctx) => ctx.count + 1 })\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      },\n\n      always: [\n        {\n          target: '.success',\n          cond: (ctx) => {\n            return ctx.count > 0;\n          }\n        }\n      ]\n    });\n\n    const service = interpret(machine).onDone(() => {\n      done();\n    });\n\n    service.start();\n\n    service.send('ADD');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"shouldn't crash when invoking a machine with initial transient transition depending on custom data","suites":["transient states (eventless transitions)"],"updatePoint":{"line":633,"column":104},"line":633,"code":"  it(\"shouldn't crash when invoking a machine with initial transient transition depending on custom data\", () => {\n    const timerMachine = Machine({\n      initial: 'initial',\n      states: {\n        initial: {\n          always: [\n            {\n              target: `finished`,\n              cond: (ctx) => ctx.duration < 1000\n            },\n            {\n              target: `active`\n            }\n          ]\n        },\n        active: {},\n        finished: { type: 'final' }\n      }\n    });\n\n    const machine = Machine({\n      initial: 'active',\n      context: {\n        customDuration: 3000\n      },\n      states: {\n        active: {\n          invoke: {\n            src: timerMachine,\n            data: {\n              duration: (context: any) => context.customDuration\n            }\n          }\n        }\n      }\n    });\n\n    const service = interpret(machine);\n    expect(() => service.start()).not.toThrow();\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be taken even in absence of other transitions","suites":["transient states (eventless transitions)"],"updatePoint":{"line":674,"column":58},"line":674,"code":"  it('should be taken even in absence of other transitions', () => {\n    let shouldMatch = false;\n\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          always: {\n            target: 'b',\n            // TODO: in v5 remove `shouldMatch` and replace this guard with:\n            // cond: (ctx, ev) => ev.type === 'WHATEVER'\n            cond: () => shouldMatch\n          }\n        },\n        b: {}\n      }\n    });\n    const service = interpret(machine).start();\n\n    shouldMatch = true;\n    service.send({ type: 'WHATEVER' });\n\n    expect(service.state.value).toBe('b');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should select subsequent transient transitions even in absence of other transitions","suites":["transient states (eventless transitions)"],"updatePoint":{"line":699,"column":89},"line":699,"code":"  it('should select subsequent transient transitions even in absence of other transitions', () => {\n    let shouldMatch = false;\n\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          always: {\n            target: 'b',\n            // TODO: in v5 remove `shouldMatch` and replace this guard with:\n            // cond: (ctx, ev) => ev.type === 'WHATEVER'\n            cond: () => shouldMatch\n          }\n        },\n        b: {\n          always: {\n            target: 'c',\n            cond: () => true\n          }\n        },\n        c: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    shouldMatch = true;\n    service.send({ type: 'WHATEVER' });\n\n    expect(service.state.value).toBe('c');\n  });","file":"transient.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not require implementations when creating machine using `createMachine`","suites":["typegen types"],"updatePoint":{"line":7,"column":84},"line":7,"code":"  it('should not require implementations when creating machine using `createMachine`', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'fooAction';\n        delays: 'barDelay';\n        guards: 'bazGuard';\n        services: 'qwertyService';\n      };\n    }\n    createMachine({\n      tsTypes: {} as TypesMeta\n    });\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not require implementations when creating machine using `model.createMachine`","suites":["typegen types"],"updatePoint":{"line":21,"column":90},"line":21,"code":"  it('should not require implementations when creating machine using `model.createMachine`', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'fooAction';\n        delays: 'barDelay';\n        guards: 'bazGuard';\n        services: 'qwertyService';\n      };\n    }\n\n    const model = createModel({});\n\n    model.createMachine({\n      tsTypes: {} as TypesMeta\n    });\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should limit event type provided to an action","suites":["typegen types"],"updatePoint":{"line":38,"column":51},"line":38,"code":"  it('should limit event type provided to an action', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingActions: {\n        myAction: 'FOO' | 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        context: { foo: 100 },\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        actions: {\n          myAction: (_ctx, event) => {\n            event.type === 'FOO';\n            event.type === 'BAR';\n            // @ts-expect-error\n            event.type === 'BAZ';\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should limit event type provided to a delay","suites":["typegen types"],"updatePoint":{"line":72,"column":49},"line":72,"code":"  it('should limit event type provided to a delay', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingDelays: {\n        myDelay: 'FOO' | 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        context: { foo: 100 },\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        delays: {\n          myDelay: (_ctx, event) => {\n            event.type === 'FOO';\n            event.type === 'BAR';\n            // @ts-expect-error\n            event.type === 'BAZ';\n\n            return 42;\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should limit event type provided to a guard","suites":["typegen types"],"updatePoint":{"line":108,"column":49},"line":108,"code":"  it('should limit event type provided to a guard', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingGuards: {\n        myGuard: 'FOO' | 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        context: { foo: 100 },\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        guards: {\n          myGuard: (_ctx, event) => {\n            event.type === 'FOO';\n            event.type === 'BAR';\n            // @ts-expect-error\n            event.type === 'BAZ';\n\n            return true;\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should limit event type provided to a service","suites":["typegen types"],"updatePoint":{"line":144,"column":51},"line":144,"code":"  it('should limit event type provided to a service', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingServices: {\n        myService: 'FOO' | 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        context: { foo: 100 },\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        services: {\n          myService: (_ctx, event) => {\n            event.type === 'FOO';\n            event.type === 'BAR';\n            // @ts-expect-error\n            event.type === 'BAZ';\n\n            return () => {};\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow an unknown action","suites":["typegen types"],"updatePoint":{"line":180,"column":40},"line":180,"code":"  it('should not allow an unknown action', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingActions: {\n        myAction: 'FOO' | 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        context: { foo: 100 },\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        actions: {\n          // @ts-expect-error\n          unknownAction: () => {}\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow an unknown delay","suites":["typegen types"],"updatePoint":{"line":210,"column":39},"line":210,"code":"  it('should not allow an unknown delay', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingDelays: {\n        myDelay: 'FOO' | 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        context: { foo: 100 },\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        delays: {\n          // @ts-expect-error\n          unknownDelay: () => 42\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow an unknown guard","suites":["typegen types"],"updatePoint":{"line":240,"column":39},"line":240,"code":"  it('should not allow an unknown guard', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingGuards: {\n        myGuard: 'FOO' | 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        context: { foo: 100 },\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        guards: {\n          // @ts-expect-error\n          unknownGuard: () => true\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow an unknown service","suites":["typegen types"],"updatePoint":{"line":270,"column":41},"line":270,"code":"  it('should not allow an unknown service', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingServices: {\n        myService: 'FOO' | 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        context: { foo: 100 },\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        services: {\n          // @ts-expect-error\n          unknownService: () => () => {}\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow valid string `matches`","suites":["typegen types"],"updatePoint":{"line":300,"column":41},"line":300,"code":"  it('should allow valid string `matches`', () => {\n    interface TypesMeta extends TypegenMeta {\n      matchesStates: 'a' | 'b' | 'c';\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      context: { foo: 100 },\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n      },\n      initial: 'a',\n      states: {\n        a: {}\n      }\n    });\n\n    machine.initialState.matches('a');\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow valid object `matches`","suites":["typegen types"],"updatePoint":{"line":320,"column":41},"line":320,"code":"  it('should allow valid object `matches`', () => {\n    interface TypesMeta extends TypegenMeta {\n      matchesStates: 'a' | { a: 'b' } | { a: 'c' };\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      context: { foo: 100 },\n      initial: 'a',\n      states: {\n        a: {}\n      }\n    });\n\n    machine.initialState.matches({ a: 'c' });\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow invalid string `matches`","suites":["typegen types"],"updatePoint":{"line":337,"column":47},"line":337,"code":"  it('should not allow invalid string `matches`', () => {\n    interface TypesMeta extends TypegenMeta {\n      matchesStates: 'a' | 'b' | 'c';\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      context: { foo: 100 },\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n      },\n      initial: 'a',\n      states: {\n        a: {}\n      }\n    });\n\n    // @ts-expect-error\n    machine.initialState.matches('d');\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow invalid object `matches`","suites":["typegen types"],"updatePoint":{"line":358,"column":47},"line":358,"code":"  it('should not allow invalid object `matches`', () => {\n    interface TypesMeta extends TypegenMeta {\n      matchesStates: 'a' | { a: 'b' } | { a: 'c' };\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      context: { foo: 100 },\n      initial: 'a',\n      states: {\n        a: {}\n      }\n    });\n\n    // @ts-expect-error\n    machine.initialState.matches({ a: 'd' });\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow a valid tag with `hasTag`","suites":["typegen types"],"updatePoint":{"line":376,"column":44},"line":376,"code":"  it('should allow a valid tag with `hasTag`', () => {\n    interface TypesMeta extends TypegenMeta {\n      tags: 'a' | 'b' | 'c';\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      context: { foo: 100 },\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n      },\n      initial: 'a',\n      states: {\n        a: {}\n      }\n    });\n\n    machine.initialState.hasTag('a');\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow an invalid tag with `hasTag`","suites":["typegen types"],"updatePoint":{"line":396,"column":51},"line":396,"code":"  it('should not allow an invalid tag with `hasTag`', () => {\n    interface TypesMeta extends TypegenMeta {\n      tags: 'a' | 'b' | 'c';\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      context: { foo: 100 },\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n      },\n      initial: 'a',\n      states: {\n        a: {}\n      }\n    });\n\n    // @ts-expect-error\n    machine.initialState.hasTag('d');\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"`withConfig` should require all missing implementations ","suites":["typegen types"],"updatePoint":{"line":417,"column":62},"line":417,"code":"  it('`withConfig` should require all missing implementations ', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'myAction';\n        delays: 'myDelay';\n        guards: never;\n        services: never;\n      };\n      eventsCausingActions: {\n        myAction: 'FOO';\n        myDelay: 'BAR';\n      };\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n      }\n    });\n\n    // @ts-expect-error\n    machine.withConfig({});\n    machine.withConfig({\n      // @ts-expect-error\n      actions: {}\n    });\n    // @ts-expect-error\n    machine.withConfig({\n      actions: {\n        myAction: () => {}\n      }\n    });\n    machine.withConfig({\n      actions: {\n        myAction: () => {}\n      },\n      delays: {\n        myDelay: () => 42\n      }\n    });\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow to create a service out of a machine without any missing implementations","suites":["typegen types"],"updatePoint":{"line":460,"column":91},"line":460,"code":"  it('should allow to create a service out of a machine without any missing implementations', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: never;\n        delays: never;\n        guards: never;\n        services: never;\n      };\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta\n    });\n\n    interpret(machine);\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow to create a service out of a machine with missing implementations","suites":["typegen types"],"updatePoint":{"line":477,"column":88},"line":477,"code":"  it('should not allow to create a service out of a machine with missing implementations', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'myAction';\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingActions: {\n        myAction: 'FOO';\n      };\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n      }\n    });\n\n    // @ts-expect-error\n    interpret(machine);\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow to create a service out of a machine with implementations provided through `withConfig`","suites":["typegen types"],"updatePoint":{"line":501,"column":106},"line":501,"code":"  it('should allow to create a service out of a machine with implementations provided through `withConfig`', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'myAction';\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingActions: {\n        myAction: 'FOO';\n      };\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n      }\n    });\n\n    interpret(\n      machine.withConfig({\n        actions: {\n          myAction: () => {}\n        }\n      })\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not require all implementations when creating machine","suites":["typegen types"],"updatePoint":{"line":530,"column":66},"line":530,"code":"  it('should not require all implementations when creating machine', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'fooAction';\n        delays: 'barDelay';\n        guards: 'bazGuard';\n        services: 'qwertyService';\n      };\n      eventsCausingActions: { fooAction: 'FOO' };\n      eventsCausingDelays: { barDelay: 'BAR' };\n      eventsCausingGuards: { bazGuard: 'BAR' };\n      eventsCausingServices: { qwertyService: 'BAR' };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        actions: {\n          fooAction: () => {}\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow to override already provided implementation using `withConfig`","suites":["typegen types"],"updatePoint":{"line":559,"column":81},"line":559,"code":"  it('should allow to override already provided implementation using `withConfig`', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'fooAction';\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingActions: { fooAction: 'FOO' };\n      eventsCausingDelays: { barDelay: 'BAR' };\n    }\n\n    const machine = createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' } | { type: 'BAZ' }\n        }\n      },\n      {\n        delays: {\n          barDelay: () => 42\n        }\n      }\n    );\n\n    machine.withConfig({\n      actions: {\n        fooAction: () => {}\n      },\n      delays: {\n        barDelay: () => 100\n      }\n    });\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should preserve provided action type for the meta object","suites":["typegen types"],"updatePoint":{"line":595,"column":62},"line":595,"code":"  it('should preserve provided action type for the meta object', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: {\n        myAction: 'FOO' | 'BAR';\n      };\n    }\n\n    const model = createModel(\n      { foo: 100 },\n      {\n        actions: {\n          myAction: (x: number) => ({ x })\n        },\n        events: {\n          FOO: () => ({}),\n          BAR: () => ({}),\n          BAZ: () => ({})\n        }\n      }\n    );\n\n    model.createMachine(\n      {\n        tsTypes: {} as TypesMeta\n      },\n      {\n        actions: {\n          myAction: (_ctx, _ev, { action }) => {\n            action.type === 'myAction';\n            ((_accept: number) => {})(action.x);\n            // @ts-expect-error\n            ((_accept: string) => {})(action.x);\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should include init event in the provided parameter type if necessary","suites":["typegen types"],"updatePoint":{"line":633,"column":75},"line":633,"code":"  it('should include init event in the provided parameter type if necessary', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: {\n        myAction: 'xstate.init';\n      };\n      internalEvents: {\n        'xstate.init': { type: 'xstate.init' };\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' }\n        }\n      },\n      {\n        actions: {\n          myAction: (_ctx, event) => {\n            event.type === 'xstate.init';\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should include generated dynamic internal event in the provided parameter if schema.services is not provided","suites":["typegen types"],"updatePoint":{"line":660,"column":114},"line":660,"code":"  it('should include generated dynamic internal event in the provided parameter if schema.services is not provided', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: {\n        myAction: 'done.invoke.myService' | 'FOO';\n      };\n      internalEvents: {\n        'done.invoke.myService': {\n          type: 'done.invoke.myService';\n          data: unknown;\n          __tip: 'Declare the type.';\n        };\n      };\n      invokeSrcNameMap: {\n        myService: 'done.invoke.myService';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' }\n        }\n      },\n      {\n        actions: {\n          myAction: (_ctx, event) => {\n            if (event.type === 'FOO') {\n              return;\n            }\n            event.type === 'done.invoke.myService';\n            event.data;\n            // indirectly check that it's not any\n            // @ts-expect-error\n            ((_accept: string) => {})(event.data);\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should use an event generated based on schema.services for a dynamic internal event over the generated fallback","suites":["typegen types"],"updatePoint":{"line":701,"column":117},"line":701,"code":"  it('should use an event generated based on schema.services for a dynamic internal event over the generated fallback', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: {\n        myAction: 'done.invoke.myService' | 'FOO';\n      };\n      internalEvents: {\n        'done.invoke.myService': {\n          type: 'done.invoke.myService';\n          data: unknown;\n          __tip: 'Declare the type.';\n        };\n      };\n      invokeSrcNameMap: {\n        myService: 'done.invoke.myService';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' },\n          services: {\n            myService: {\n              data: {} as string\n            }\n          }\n        }\n      },\n      {\n        actions: {\n          myAction: (_ctx, event) => {\n            if (event.type === 'FOO') {\n              return;\n            }\n            event.type === 'done.invoke.myService';\n            event.data;\n            ((_accept: string) => {})(event.data);\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow a promise service returning the explicitly declared data in the given schema.services","suites":["typegen types"],"updatePoint":{"line":745,"column":104},"line":745,"code":"  it('should allow a promise service returning the explicitly declared data in the given schema.services', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: {\n        myService: 'FOO';\n      };\n      internalEvents: {\n        'done.invoke.myService': {\n          type: 'done.invoke.myService';\n          data: unknown;\n          __tip: 'Declare the type.';\n        };\n      };\n      invokeSrcNameMap: {\n        myService: 'done.invoke.myService';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' },\n          services: {\n            myService: {\n              data: {} as string\n            }\n          }\n        }\n      },\n      {\n        services: {\n          myService: (_ctx) => Promise.resolve('foo')\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow a promise service returning a different type than the explicitly declared one in the given schema.services","suites":["typegen types"],"updatePoint":{"line":782,"column":129},"line":782,"code":"  it('should not allow a promise service returning a different type than the explicitly declared one in the given schema.services', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: {\n        myService: 'FOO';\n      };\n      internalEvents: {\n        'done.invoke.myService': {\n          type: 'done.invoke.myService';\n          data: unknown;\n          __tip: 'Declare the type.';\n        };\n      };\n      invokeSrcNameMap: {\n        myService: 'done.invoke.myService';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' },\n          services: {\n            myService: {\n              data: {} as string\n            }\n          }\n        }\n      },\n      {\n        services: {\n          // @ts-expect-error\n          myService: (_ctx) => Promise.resolve(42)\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow a machine service returning the explicitly declared data in the given schema.services","suites":["typegen types"],"updatePoint":{"line":820,"column":104},"line":820,"code":"  it('should allow a machine service returning the explicitly declared data in the given schema.services', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: {\n        myService: 'FOO';\n      };\n      internalEvents: {\n        'done.invoke.myService': {\n          type: 'done.invoke.myService';\n          data: unknown;\n          __tip: 'Declare the type.';\n        };\n      };\n      invokeSrcNameMap: {\n        myService: 'done.invoke.myService';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' },\n          services: {\n            myService: {\n              data: {} as { foo: string }\n            }\n          }\n        }\n      },\n      {\n        services: {\n          myService: (_ctx) => createMachine<{ foo: string }>({})\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow a machine service returning a different type than the explicitly declared one in the given schema.services","suites":["typegen types"],"updatePoint":{"line":857,"column":129},"line":857,"code":"  it('should not allow a machine service returning a different type than the explicitly declared one in the given schema.services', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: {\n        myService: 'FOO';\n      };\n      internalEvents: {\n        'done.invoke.myService': {\n          type: 'done.invoke.myService';\n          data: unknown;\n          __tip: 'Declare the type.';\n        };\n      };\n      invokeSrcNameMap: {\n        myService: 'done.invoke.myService';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' },\n          services: {\n            myService: {\n              data: {} as { foo: string }\n            }\n          }\n        }\n      },\n      {\n        services: {\n          // @ts-expect-error\n          myService: (_ctx) => createMachine<{ foo: number }>({})\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should infer an action object with narrowed event type","suites":["typegen types"],"updatePoint":{"line":895,"column":60},"line":895,"code":"  it('should infer an action object with narrowed event type', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: {\n        actionName: 'BAR';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR'; value: string }\n        }\n      },\n      {\n        actions: {\n          actionName: assign((_context, event) => {\n            ((_accept: 'BAR') => {})(event.type);\n            return {};\n          })\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept a machine as a service","suites":["typegen types"],"updatePoint":{"line":920,"column":42},"line":920,"code":"  it('should accept a machine as a service', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: {\n        fooService: 'FOO';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR'; value: string }\n        }\n      },\n      {\n        services: {\n          fooService: createMachine({})\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to send all of the parent event types back to the parent from an invoked callback","suites":["typegen types"],"updatePoint":{"line":942,"column":102},"line":942,"code":"  it('should be able to send all of the parent event types back to the parent from an invoked callback', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: {\n        fooService: 'FOO';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' }\n        }\n      },\n      {\n        services: {\n          fooService: (_context, event) => (send) => {\n            ((_accept: 'FOO') => {})(event.type);\n\n            send({ type: 'BAR' });\n            send({ type: 'FOO' });\n            // @ts-expect-error\n            send({ type: 'BAZ' });\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"It should tighten service types when using model.createMachine","suites":["typegen types"],"updatePoint":{"line":971,"column":68},"line":971,"code":"  it('It should tighten service types when using model.createMachine', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: {\n        myAction: 'done.invoke.myService';\n      };\n      eventsCausingServices: {\n        myService: never;\n      };\n      internalEvents: {\n        'done.invoke.myService': {\n          type: 'done.invoke.myService';\n          data: unknown;\n        };\n      };\n      invokeSrcNameMap: {\n        myService: 'done.invoke.myService';\n      };\n    }\n\n    const model = createModel({}, {});\n\n    model.createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          services: {} as {\n            myService: {\n              data: boolean;\n            };\n          }\n        }\n      },\n      {\n        actions: {\n          myAction: (_ctx, event) => {\n            ((_accept: boolean) => {})(event.data);\n          }\n        },\n        services: {\n          // @ts-expect-error\n          myService: () => Promise.resolve('')\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not provide a loose type for `onReceive`'s argument as a default","suites":["typegen types"],"updatePoint":{"line":1017,"column":77},"line":1017,"code":"  it(\"should not provide a loose type for `onReceive`'s argument as a default\", () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: {\n        fooService: 'FOO';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' }\n        }\n      },\n      {\n        services: {\n          fooService: (_ctx, _ev) => (_send, onReceive) => {\n            onReceive((event) => {\n              ((_accept: string) => {})(event.type);\n              // @ts-expect-error\n              event.unknown;\n            });\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow specifying `onReceive`'s argument type manually","suites":["typegen types"],"updatePoint":{"line":1045,"column":66},"line":1045,"code":"  it(\"should allow specifying `onReceive`'s argument type manually\", () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: {\n        fooService: 'FOO';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          events: {} as { type: 'FOO' } | { type: 'BAR' }\n        }\n      },\n      {\n        services: {\n          fooService: (_ctx, _ev) => (_send, onReceive) => {\n            onReceive((_event: { type: 'TEST' }) => {});\n            // @ts-expect-error\n            onReceive((_event: { type: number }) => {});\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should error correctly for implementations called in response to internal events when there is no explicit event type","suites":["typegen types"],"updatePoint":{"line":1071,"column":123},"line":1071,"code":"  it('should error correctly for implementations called in response to internal events when there is no explicit event type', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: {\n        myAction: 'done.invoke.invocation';\n      };\n      eventsCausingServices: {\n        myInvocation: 'xstate.init';\n      };\n      internalEvents: {\n        'xstate.init': { type: 'xstate.init' };\n      };\n      invokeSrcNameMap: {\n        myInvocation: 'done.invoke.invocation';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          services: {\n            myInvocation: {} as {\n              data: string;\n            }\n          }\n        }\n      },\n      {\n        services: {\n          // @ts-expect-error\n          myInvocation: () => {\n            return Promise.resolve(1);\n          }\n        },\n        actions: {\n          myAction: (_context, event) => {\n            ((_accept: 'done.invoke.invocation') => {})(event.type);\n            ((_accept: string) => {})(event.data);\n            // @ts-expect-error\n            ((_accept: number) => {})(event.data);\n          }\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"shouldn't end up with `any` context after calling `state.matches`","suites":["typegen types"],"updatePoint":{"line":1117,"column":71},"line":1117,"code":"  it(\"shouldn't end up with `any` context after calling `state.matches`\", () => {\n    interface TypesMeta extends TypegenMeta {\n      matchesStates: 'a' | 'b' | 'c';\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n\n      schema: {\n        context: {} as {\n          foo: string;\n        }\n      }\n    });\n\n    if (machine.initialState.matches('a')) {\n      // @ts-expect-error\n      machine.initialState.context.val;\n    }\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"shouldn't end up with `never` within a branch after two `state.matches` calls","suites":["typegen types"],"updatePoint":{"line":1138,"column":83},"line":1138,"code":"  it(\"shouldn't end up with `never` within a branch after two `state.matches` calls\", () => {\n    interface TypesMeta extends TypegenMeta {\n      matchesStates: 'a' | 'a.b';\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      schema: {\n        context: {} as {\n          foo: string;\n        }\n      }\n    });\n\n    const state = machine.initialState;\n\n    if (state.matches('a') && state.matches('a.b')) {\n      ((_accept: string) => {})(state.context.foo);\n    }\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be possible to pass typegen-less machines to functions expecting a machine argument that do not utilize the typegen information","suites":["typegen types"],"updatePoint":{"line":1159,"column":140},"line":1159,"code":"  it('should be possible to pass typegen-less machines to functions expecting a machine argument that do not utilize the typegen information', () => {\n    const machine = createMachine({});\n\n    function acceptMachine<TContext, TEvent extends { type: string }>(\n      machine: StateMachine<TContext, any, TEvent>\n    ) {\n      return machine;\n    }\n\n    acceptMachine(machine);\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should error on a provided action where there are no inferred actions","suites":["typegen types"],"updatePoint":{"line":1171,"column":75},"line":1171,"code":"  it('should error on a provided action where there are no inferred actions', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: never;\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          context: {} as {\n            foo: string;\n          }\n        }\n      },\n      {\n        // @ts-expect-error\n        actions: {\n          testAction: () => {}\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should error on a provided delay where there are no inferred delays","suites":["typegen types"],"updatePoint":{"line":1194,"column":73},"line":1194,"code":"  it('should error on a provided delay where there are no inferred delays', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingDelays: never;\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          context: {} as {\n            foo: string;\n          }\n        }\n      },\n      {\n        // @ts-expect-error\n        delays: {\n          testDelay: () => {}\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should error on a provided guard where there are no inferred guards","suites":["typegen types"],"updatePoint":{"line":1217,"column":73},"line":1217,"code":"  it('should error on a provided guard where there are no inferred guards', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingGuards: never;\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          context: {} as {\n            foo: string;\n          }\n        }\n      },\n      {\n        // @ts-expect-error\n        guards: {\n          testGuard: () => {}\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should error on a provided service where there are no declared services","suites":["typegen types"],"updatePoint":{"line":1240,"column":77},"line":1240,"code":"  it('should error on a provided service where there are no declared services', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingServices: never;\n      invokeSrcNameMap: never;\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          context: {} as {\n            foo: string;\n          }\n        }\n      },\n      {\n        // @ts-expect-error\n        services: {\n          testService: () => Promise.resolve(42)\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to provide events that use string unions as their type","suites":["typegen types"],"updatePoint":{"line":1264,"column":75},"line":1264,"code":"  it('should be able to provide events that use string unions as their type', () => {\n    interface TypesMeta extends TypegenMeta {\n      eventsCausingActions: {\n        increment: 'INC';\n        decrement: 'DEC';\n      };\n    }\n\n    createMachine(\n      {\n        tsTypes: {} as TypesMeta,\n        schema: {\n          context: {} as {\n            count: number;\n          },\n          events: {} as { type: 'INC' | 'DEC'; value: number }\n        }\n      },\n      {\n        actions: {\n          increment: assign((ctx, ev) => {\n            return {\n              count: ctx.count + ev.value\n            };\n          })\n        }\n      }\n    );\n  });","file":"typegenTypes.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return context of a machine","suites":["ContextFrom"],"updatePoint":{"line":14,"column":40},"line":14,"code":"  it('should return context of a machine', () => {\n    const machine = createMachine({\n      schema: {\n        context: {} as { counter: number }\n      }\n    });\n\n    type MachineContext = ContextFrom<typeof machine>;\n\n    const acceptMachineContext = (_event: MachineContext) => {};\n\n    acceptMachineContext({ counter: 100 });\n    acceptMachineContext({\n      counter: 100,\n      // @ts-expect-error\n      other: 'unknown'\n    });\n    const obj = { completely: 'invalid' };\n    // @ts-expect-error\n    acceptMachineContext(obj);\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return context of a typegened machine","suites":["ContextFrom"],"updatePoint":{"line":36,"column":50},"line":36,"code":"  it('should return context of a typegened machine', () => {\n    const machine = createMachine({\n      tsTypes: {} as TypegenMeta,\n      schema: {\n        context: {} as { counter: number }\n      }\n    });\n\n    type MachineContext = ContextFrom<typeof machine>;\n\n    const acceptMachineContext = (_event: MachineContext) => {};\n\n    acceptMachineContext({ counter: 100 });\n    acceptMachineContext({\n      counter: 100,\n      // @ts-expect-error\n      other: 'unknown'\n    });\n    const obj = { completely: 'invalid' };\n    // @ts-expect-error\n    acceptMachineContext(obj);\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return events for a machine","suites":["EventFrom"],"updatePoint":{"line":61,"column":40},"line":61,"code":"  it('should return events for a machine', () => {\n    const machine = createMachine({\n      schema: {\n        events: {} as\n          | { type: 'UPDATE_NAME'; value: string }\n          | { type: 'UPDATE_AGE'; value: number }\n          | { type: 'ANOTHER_EVENT' }\n      }\n    });\n\n    type MachineEvent = EventFrom<typeof machine>;\n\n    const acceptMachineEvent = (_event: MachineEvent) => {};\n\n    acceptMachineEvent({ type: 'UPDATE_NAME', value: 'test' });\n    acceptMachineEvent({ type: 'UPDATE_AGE', value: 12 });\n    acceptMachineEvent({ type: 'ANOTHER_EVENT' });\n    acceptMachineEvent({\n      // @ts-expect-error\n      type: 'UNKNOWN_EVENT'\n    });\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return events for a typegened machine","suites":["EventFrom"],"updatePoint":{"line":84,"column":50},"line":84,"code":"  it('should return events for a typegened machine', () => {\n    const machine = createMachine({\n      tsTypes: {} as TypegenMeta,\n      schema: {\n        events: {} as\n          | { type: 'UPDATE_NAME'; value: string }\n          | { type: 'UPDATE_AGE'; value: number }\n          | { type: 'ANOTHER_EVENT' }\n      }\n    });\n\n    type MachineEvent = EventFrom<typeof machine>;\n\n    const acceptMachineEvent = (_event: MachineEvent) => {};\n\n    acceptMachineEvent({ type: 'UPDATE_NAME', value: 'test' });\n    acceptMachineEvent({ type: 'UPDATE_AGE', value: 12 });\n    acceptMachineEvent({ type: 'ANOTHER_EVENT' });\n    acceptMachineEvent({\n      // @ts-expect-error\n      type: 'UNKNOWN_EVENT'\n    });\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return events for an interpreter","suites":["EventFrom"],"updatePoint":{"line":108,"column":45},"line":108,"code":"  it('should return events for an interpreter', () => {\n    const machine = createMachine({\n      schema: {\n        events: {} as\n          | { type: 'UPDATE_NAME'; value: string }\n          | { type: 'UPDATE_AGE'; value: number }\n          | { type: 'ANOTHER_EVENT' }\n      }\n    });\n\n    const service = interpret(machine);\n\n    type InterpreterEvent = EventFrom<typeof service>;\n\n    const acceptInterpreterEvent = (_event: InterpreterEvent) => {};\n\n    acceptInterpreterEvent({ type: 'UPDATE_NAME', value: 'test' });\n    acceptInterpreterEvent({ type: 'UPDATE_AGE', value: 12 });\n    acceptInterpreterEvent({ type: 'ANOTHER_EVENT' });\n    acceptInterpreterEvent({\n      // @ts-expect-error\n      type: 'UNKNOWN_EVENT'\n    });\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return events for createModel","suites":["EventFrom"],"updatePoint":{"line":133,"column":42},"line":133,"code":"  it('should return events for createModel', () => {\n    const userModel = createModel(\n      {},\n      {\n        events: {\n          updateName: (value: string) => ({ value }),\n          updateAge: (value: number) => ({ value }),\n          anotherEvent: () => ({})\n        }\n      }\n    );\n\n    type UserModelEvent = EventFrom<typeof userModel>;\n\n    const acceptUserModelEvent = (_event: UserModelEvent) => {};\n\n    acceptUserModelEvent({ type: 'updateName', value: 'test' });\n    acceptUserModelEvent({ type: 'updateAge', value: 12 });\n    acceptUserModelEvent({ type: 'anotherEvent' });\n    acceptUserModelEvent({\n      // @ts-expect-error\n      type: 'eventThatDoesNotExist'\n    });\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should narrow events down to the specified types","suites":["EventFrom"],"updatePoint":{"line":158,"column":54},"line":158,"code":"  it('should narrow events down to the specified types', () => {\n    const userModel = createModel(\n      {},\n      {\n        events: {\n          updateName: (value: string) => ({ value }),\n          updateAge: (value: number) => ({ value }),\n          anotherEvent: () => ({})\n        }\n      }\n    );\n\n    type UserModelEventSubset = EventFrom<\n      typeof userModel,\n      'updateName' | 'updateAge'\n    >;\n\n    const acceptUserModelEventSubset = (\n      _userModelEventSubset: UserModelEventSubset\n    ) => {};\n\n    acceptUserModelEventSubset({ type: 'updateName', value: 'test' });\n    acceptUserModelEventSubset({ type: 'updateAge', value: 12 });\n    // @ts-expect-error\n    acceptUserModelEventSubset({ type: 'anotherEvent' });\n    // @ts-expect-error\n    acceptUserModelEventSubset({ type: 'eventThatDoesNotExist' });\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return options for a typegen-less machine","suites":["MachineOptionsFrom"],"updatePoint":{"line":189,"column":54},"line":189,"code":"  it('should return options for a typegen-less machine', () => {\n    const machine = createMachine({\n      context: {\n        count: 100\n      },\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR'; value: string }\n      }\n    });\n\n    const acceptMachineOptions = (\n      _options: MachineOptionsFrom<typeof machine>\n    ) => {};\n\n    acceptMachineOptions({\n      actions: {\n        foo: () => {}\n      }\n    });\n    acceptMachineOptions({\n      actions: {\n        foo: assign(() => ({}))\n      }\n    });\n    acceptMachineOptions({\n      actions: {\n        foo: assign((ctx) => {\n          ((_accept: number) => {})(ctx.count);\n          return {};\n        })\n      }\n    });\n    acceptMachineOptions({\n      actions: {\n        foo: assign((_ctx, ev) => {\n          ((_accept: 'FOO' | 'BAR') => {})(ev.type);\n          return {};\n        })\n      }\n    });\n    // @ts-expect-error\n    acceptMachineOptions(100);\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return optional options for a typegen-based machine by default","suites":["MachineOptionsFrom"],"updatePoint":{"line":233,"column":75},"line":233,"code":"  it('should return optional options for a typegen-based machine by default', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'myAction';\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingActions: {\n        myAction: 'FOO';\n      };\n    }\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      context: {\n        count: 100\n      },\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR'; value: string }\n      }\n    });\n\n    const acceptMachineOptions = (\n      _options: MachineOptionsFrom<typeof machine>\n    ) => {};\n\n    acceptMachineOptions({\n      actions: {\n        // @ts-expect-error\n        foo: () => {}\n      }\n    });\n    acceptMachineOptions({\n      actions: {}\n    });\n    acceptMachineOptions({\n      actions: {\n        myAction: assign((ctx, ev) => {\n          ((_accept: number) => {})(ctx.count);\n          ((_accept: 'FOO') => {})(ev.type);\n          return {};\n        })\n      }\n    });\n    // @ts-expect-error\n    acceptMachineOptions(100);\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return required options for a typegen-based machine with a flag","suites":["MachineOptionsFrom"],"updatePoint":{"line":281,"column":76},"line":281,"code":"  it('should return required options for a typegen-based machine with a flag', () => {\n    interface TypesMeta extends TypegenMeta {\n      missingImplementations: {\n        actions: 'myAction';\n        delays: never;\n        guards: never;\n        services: never;\n      };\n      eventsCausingActions: {\n        myAction: 'FOO';\n      };\n    }\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta,\n      context: {\n        count: 100\n      },\n      schema: {\n        events: {} as { type: 'FOO' } | { type: 'BAR'; value: string }\n      }\n    });\n\n    const acceptMachineOptions = (\n      _options: MachineOptionsFrom<typeof machine, true>\n    ) => {};\n\n    acceptMachineOptions({\n      actions: {\n        // @ts-expect-error\n        foo: () => {}\n      }\n    });\n    acceptMachineOptions({\n      // @ts-expect-error\n      actions: {}\n    });\n    acceptMachineOptions({\n      actions: {\n        myAction: assign((ctx, ev) => {\n          ((_accept: number) => {})(ctx.count);\n          ((_accept: 'FOO') => {})(ev.type);\n          return {};\n        })\n      }\n    });\n    // @ts-expect-error\n    acceptMachineOptions(100);\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return possible state values from a typegened machine","suites":["StateValueFrom"],"updatePoint":{"line":332,"column":66},"line":332,"code":"  it('should return possible state values from a typegened machine', () => {\n    interface TypesMeta extends TypegenMeta {\n      matchesStates: 'a' | 'b' | 'c';\n    }\n\n    const machine = createMachine({\n      tsTypes: {} as TypesMeta\n    });\n\n    function matches(_value: StateValueFrom<typeof machine>) {}\n\n    matches('a');\n    matches('b');\n    // @ts-expect-error\n    matches('unknown');\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return any from a typegenless machine","suites":["StateValueFrom"],"updatePoint":{"line":349,"column":50},"line":349,"code":"  it('should return any from a typegenless machine', () => {\n    const machine = createMachine({});\n\n    function matches(_value: StateValueFrom<typeof machine>) {}\n\n    matches('just anything');\n  });","file":"typeHelpers.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a StateSchema defined","suites":["StateSchema"],"updatePoint":{"line":98,"column":44},"line":98,"code":"  it('should work with a StateSchema defined', () => {\n    expect(true).toBeTruthy();\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a parallel StateSchema defined","suites":["Parallel StateSchema"],"updatePoint":{"line":148,"column":53},"line":148,"code":"  it('should work with a parallel StateSchema defined', () => {\n    expect(true).toBeTruthy();\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with a parallel StateSchema defined","suites":["Nested parallel stateSchema"],"updatePoint":{"line":207,"column":53},"line":207,"code":"  it('should work with a parallel StateSchema defined', () => {\n    expect(true).toBeTruthy();\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with all the ways to raise events","suites":["Raise events"],"updatePoint":{"line":213,"column":51},"line":213,"code":"  it('should work with all the ways to raise events', () => {\n    interface GreetingStateSchema {\n      states: {\n        pending: {};\n        morning: {};\n        lunchTime: {};\n        afternoon: {};\n        evening: {};\n        night: {};\n      };\n    }\n\n    type GreetingEvent =\n      | { type: 'DECIDE'; aloha?: boolean }\n      | { type: 'MORNING' }\n      | { type: 'LUNCH_TIME' }\n      | { type: 'AFTERNOON' }\n      | { type: 'EVENING' }\n      | { type: 'NIGHT' }\n      | { type: 'ALOHA' };\n\n    interface GreetingContext {\n      hour: number;\n    }\n\n    const greetingContext: GreetingContext = { hour: 10 };\n\n    const raiseGreetingMachine = Machine<\n      GreetingContext,\n      GreetingStateSchema,\n      GreetingEvent\n    >({\n      key: 'greeting',\n      context: greetingContext,\n      initial: 'pending',\n      states: {\n        pending: {\n          on: {\n            DECIDE: [\n              {\n                actions: raise({\n                  type: 'ALOHA'\n                }) as any /* TODO: FIX */,\n                cond: (_ctx, ev) => !!ev.aloha\n              },\n              {\n                actions: raise({\n                  type: 'MORNING'\n                }) as any /* TODO: FIX */,\n                cond: (ctx) => ctx.hour < 12\n              },\n              {\n                actions: raise({\n                  type: 'AFTERNOON'\n                }) as any /* TODO: FIX */,\n                cond: (ctx) => ctx.hour < 18\n              },\n              {\n                actions: raise({ type: 'EVENING' }) as any /* TODO: FIX */,\n                cond: (ctx) => ctx.hour < 22\n              }\n            ]\n          }\n        },\n        morning: {},\n        lunchTime: {},\n        afternoon: {},\n        evening: {},\n        night: {}\n      },\n      on: {\n        MORNING: '.morning',\n        LUNCH_TIME: '.lunchTime',\n        AFTERNOON: '.afternoon',\n        EVENING: '.evening',\n        NIGHT: '.night'\n      }\n    });\n\n    noop(raiseGreetingMachine);\n    expect(true).toBeTruthy();\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should preserve typestate for the service returned by Interpreter.start() and a servcie's .state getter.","suites":["Typestates"],"updatePoint":{"line":347,"column":110},"line":347,"code":"  it(\"should preserve typestate for the service returned by Interpreter.start() and a servcie's .state getter.\", () => {\n    const service = interpret(machine);\n    const startedService = service.start();\n\n    const idle: Idle = startedService.state.matches('idle')\n      ? startedService.state.context\n      : { result: none, error: none };\n    expect(idle).toEqual({ result: none, error: none });\n\n    const running: Running = startedService.state.matches('running')\n      ? startedService.state.context\n      : { result: none, error: none };\n    expect(running).toEqual({ result: none, error: none });\n\n    const succeeded: Succeeded = startedService.state.matches('succeeded')\n      ? startedService.state.context\n      : { result: 12, error: none };\n    expect(succeeded).toEqual({ result: 12, error: none });\n\n    const failed: Failed = startedService.state.matches('failed')\n      ? startedService.state.context\n      : { result: none, error: 'oops' };\n    expect(failed).toEqual({ result: none, error: 'oops' });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should preserve typestate for state node returned by StateNode.withConfig.","suites":["Typestates"],"updatePoint":{"line":372,"column":80},"line":372,"code":"  it('should preserve typestate for state node returned by StateNode.withConfig.', () => {\n    const machine2 = machine.withConfig({});\n    const service = interpret(machine2);\n    service.start();\n\n    const idle: Idle = service.state.matches('idle')\n      ? service.state.context\n      : { result: none, error: none };\n    expect(idle).toEqual({ result: none, error: none });\n\n    const running: Running = service.state.matches('running')\n      ? service.state.context\n      : { result: none, error: none };\n    expect(running).toEqual({ result: none, error: none });\n\n    const succeeded: Succeeded = service.state.matches('succeeded')\n      ? service.state.context\n      : { result: 12, error: none };\n    expect(succeeded).toEqual({ result: 12, error: none });\n\n    const failed: Failed = service.state.matches('failed')\n      ? service.state.context\n      : { result: none, error: 'oops' };\n    expect(failed).toEqual({ result: none, error: 'oops' });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should infer context type from `config.context` when there is no `schema.context`","suites":["context"],"updatePoint":{"line":400,"column":87},"line":400,"code":"  it('should infer context type from `config.context` when there is no `schema.context`', () => {\n    createMachine(\n      {\n        context: {\n          foo: 'test'\n        }\n      },\n      {\n        actions: {\n          someAction: (ctx) => {\n            ((_accept: string) => {})(ctx.foo);\n            // @ts-expect-error\n            ((_accept: number) => {})(ctx.foo);\n          }\n        }\n      }\n    );\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not use actions as possible inference sites","suites":["context"],"updatePoint":{"line":419,"column":56},"line":419,"code":"  it('should not use actions as possible inference sites', () => {\n    createMachine(\n      {\n        schema: {\n          context: {} as {\n            count: number;\n          }\n        },\n        entry: (_ctx: any) => {}\n      },\n      {\n        actions: {\n          someAction: (ctx) => {\n            ((_accept: number) => {})(ctx.count);\n            // @ts-expect-error\n            ((_accept: string) => {})(ctx.count);\n          }\n        }\n      }\n    );\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should work with generic context","suites":["context"],"updatePoint":{"line":441,"column":38},"line":441,"code":"  it('should work with generic context', () => {\n    function createMachineWithExtras<TContext>(\n      context: TContext\n    ): StateMachine<TContext, any, any> {\n      return createMachine({ context });\n    }\n\n    createMachineWithExtras({ counter: 42 });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not widen literal types defined in `schema.context` based on `config.context`","suites":["context"],"updatePoint":{"line":451,"column":90},"line":451,"code":"  it('should not widen literal types defined in `schema.context` based on `config.context`', () => {\n    createMachine({\n      schema: {\n        context: {} as {\n          literalTest: 'foo' | 'bar';\n        }\n      },\n      context: {\n        // @ts-expect-error\n        literalTest: 'anything'\n      }\n    });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not use actions as possible inference sites 1","suites":["events"],"updatePoint":{"line":467,"column":58},"line":467,"code":"  it('should not use actions as possible inference sites 1', () => {\n    const machine = createMachine({\n      schema: {\n        events: {} as {\n          type: 'FOO';\n        }\n      },\n      entry: raise('FOO')\n    });\n\n    const service = interpret(machine).start();\n\n    service.send({ type: 'FOO' });\n    // @ts-expect-error\n    service.send({ type: 'UNKNOWN' });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not use actions as possible inference sites 2","suites":["events"],"updatePoint":{"line":484,"column":58},"line":484,"code":"  it('should not use actions as possible inference sites 2', () => {\n    const machine = createMachine({\n      schema: {\n        events: {} as {\n          type: 'FOO';\n        }\n      },\n      entry: (_ctx, _ev: any) => {}\n    });\n\n    const service = interpret(machine).start();\n\n    service.send({ type: 'FOO' });\n    // @ts-expect-error\n    service.send({ type: 'UNKNOWN' });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"event type should be inferrable from a simple state machine typr","suites":["events"],"updatePoint":{"line":501,"column":70},"line":501,"code":"  it('event type should be inferrable from a simple state machine typr', () => {\n    const toggleMachine = createMachine<\n      {\n        count: number;\n      },\n      {\n        type: 'TOGGLE';\n      }\n    >({});\n\n    function acceptMachine<TContext, TEvent extends { type: string }>(\n      _machine: StateMachine<TContext, any, TEvent>\n    ) {}\n\n    acceptMachine(toggleMachine);\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should infer inline function parameters when narrowing transition actions based on the event type","suites":["events"],"updatePoint":{"line":518,"column":103},"line":518,"code":"  it('should infer inline function parameters when narrowing transition actions based on the event type', () => {\n    createMachine({\n      schema: {\n        context: {} as {\n          count: number;\n        },\n        events: {} as\n          | { type: 'EVENT_WITH_FLAG'; flag: boolean }\n          | {\n              type: 'EVENT_WITHOUT_FLAG';\n            }\n      },\n      on: {\n        EVENT_WITH_FLAG: {\n          actions: (_context, event) => {\n            ((_accept: 'EVENT_WITH_FLAG') => {})(event.type);\n            ((_accept: boolean) => {})(event.flag);\n            // @ts-expect-error\n            ((_accept: 'is not any') => {})(event);\n          }\n        }\n      }\n    });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should infer inline function parameters when for a wildcard transition","suites":["events"],"updatePoint":{"line":543,"column":76},"line":543,"code":"  it('should infer inline function parameters when for a wildcard transition', () => {\n    createMachine({\n      schema: {\n        context: {} as {\n          count: number;\n        },\n        events: {} as\n          | { type: 'EVENT_WITH_FLAG'; flag: boolean }\n          | {\n              type: 'EVENT_WITHOUT_FLAG';\n            }\n      },\n      on: {\n        '*': {\n          actions: (_context, event) => {\n            ((_accept: 'EVENT_WITH_FLAG' | 'EVENT_WITHOUT_FLAG') => {})(\n              event.type\n            );\n            // @ts-expect-error\n            ((_accept: 'is not any') => {})(event);\n          }\n        }\n      }\n    });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be convertable to Rx observable","suites":["interpreter"],"updatePoint":{"line":571,"column":44},"line":571,"code":"  it('should be convertable to Rx observable', () => {\n    const state$ = from(\n      interpret(\n        createMachine({\n          schema: {\n            context: {} as { count: number }\n          }\n        })\n      )\n    );\n\n    state$.subscribe((state) => {\n      ((_val: number) => {})(state.context.count);\n      // @ts-expect-error\n      ((_val: string) => {})(state.context.count);\n    });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"spawned actor ref should be compatible with the result of ActorRefFrom","suites":["spawn"],"updatePoint":{"line":591,"column":76},"line":591,"code":"  it('spawned actor ref should be compatible with the result of ActorRefFrom', () => {\n    const createChild = () => createMachine({});\n\n    function createParent(_deps: {\n      spawnChild: () => ActorRefFrom<typeof createChild>;\n    }) {}\n\n    createParent({\n      spawnChild: () => spawn(createChild())\n    });\n  });","file":"types.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should wait for a condition to be true and return the emitted value","suites":["waitFor"],"updatePoint":{"line":6,"column":73},"line":6,"code":"  it('should wait for a condition to be true and return the emitted value', async () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          on: { NEXT: 'b' }\n        },\n        b: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    setTimeout(() => service.send('NEXT'), 10);\n\n    const state = await waitFor(service, (s) => s.matches('b'));\n\n    expect(state.value).toEqual('b');\n  });","file":"waitFor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an error after a timeout","suites":["waitFor"],"updatePoint":{"line":26,"column":43},"line":26,"code":"  it('should throw an error after a timeout', async () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          on: { NEXT: 'b' }\n        },\n        b: {\n          on: { NEXT: 'c' }\n        },\n        c: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    try {\n      await waitFor(service, (state) => state.matches('c'), { timeout: 10 });\n    } catch (e) {\n      expect(e).toBeInstanceOf(Error);\n    }\n  });","file":"waitFor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not reject immediately when passing Infinity as timeout","suites":["waitFor"],"updatePoint":{"line":49,"column":68},"line":49,"code":"  it('should not reject immediately when passing Infinity as timeout', async () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          on: { NEXT: 'b' }\n        },\n        b: {\n          on: { NEXT: 'c' }\n        },\n        c: {}\n      }\n    });\n    const service = interpret(machine).start();\n    const result = await Promise.race([\n      waitFor(service, (state) => state.matches('c'), {\n        timeout: Infinity\n      }),\n      new Promise((res) => setTimeout(res, 10)).then(() => 'timeout')\n    ]);\n\n    expect(result).toBe('timeout');\n    service.stop();\n  });","file":"waitFor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an error when reaching a final state that does not match the predicate","suites":["waitFor"],"updatePoint":{"line":74,"column":89},"line":74,"code":"  it('should throw an error when reaching a final state that does not match the predicate', async () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          on: { NEXT: 'b' }\n        },\n        b: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    setTimeout(() => {\n      service.send('NEXT');\n    }, 10);\n\n    await expect(\n      waitFor(service, (state) => state.matches('never'))\n    ).rejects.toMatchInlineSnapshot(\n      `[Error: Actor terminated without satisfying predicate]`\n    );\n  });","file":"waitFor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve correctly when the predicate immediately matches the current state","suites":["waitFor"],"updatePoint":{"line":100,"column":87},"line":100,"code":"  it('should resolve correctly when the predicate immediately matches the current state', async () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    await expect(\n      waitFor(service, (state) => state.matches('a'))\n    ).resolves.toHaveProperty('value', 'a');\n  });","file":"waitFor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should internally unsubscribe when the predicate immediately matches the current state","suites":["waitFor"],"updatePoint":{"line":115,"column":92},"line":115,"code":"  it('should internally unsubscribe when the predicate immediately matches the current state', async () => {\n    let count = 0;\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          on: {\n            NEXT: 'b'\n          }\n        },\n        b: {}\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    await waitFor(service, (state) => {\n      count++;\n      return state.matches('a');\n    });\n\n    service.send({ type: 'NEXT' });\n\n    expect(count).toBe(1);\n  });","file":"waitFor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should immediately resolve for an actor in its final state that matches the predicate","suites":["waitFor"],"updatePoint":{"line":141,"column":91},"line":141,"code":"  it('should immediately resolve for an actor in its final state that matches the predicate', async () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          on: {\n            NEXT: 'b'\n          }\n        },\n        b: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send({ type: 'NEXT' });\n\n    await expect(\n      waitFor(service, (state) => state.matches('b'))\n    ).resolves.toHaveProperty('value', 'b');\n  });","file":"waitFor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should immediately reject for an actor in its final state that does not match the predicate","suites":["waitFor"],"updatePoint":{"line":164,"column":97},"line":164,"code":"  it('should immediately reject for an actor in its final state that does not match the predicate', async () => {\n    const machine = createMachine({\n      initial: 'a',\n      states: {\n        a: {\n          on: {\n            NEXT: 'b'\n          }\n        },\n        b: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(machine).start();\n    service.send({ type: 'NEXT' });\n\n    await expect(\n      waitFor(service, (state) => state.matches('a'))\n    ).rejects.toMatchInlineSnapshot(\n      `[Error: Actor terminated without satisfying predicate]`\n    );\n  });","file":"waitFor.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"analyzes transition counts","suites":["@xstate/analytics"],"updatePoint":{"line":64,"column":32},"line":64,"code":"  it('analyzes transition counts', () => {\n    let analysis: any = {};\n\n    const service = interpret(lightMachine);\n\n    service.subscribe(\n      createAnalyzer((a) => {\n        analysis = a;\n      })\n    );\n\n    service.start();\n\n    service.send('TIMER');\n    service.send('TIMER');\n\n    expect(analysis).toMatchInlineSnapshot(`\n      Object {\n        \"count\": 3,\n        \"transitions\": Object {\n          \"\": Object {\n            \"{\\\\\"type\\\\\":\\\\\"xstate.init\\\\\"}\": Object {\n              \"count\": 1,\n              \"currentWeight\": 1,\n              \"relativeWeight\": 1,\n              \"state\": \"{\\\\\"value\\\\\":\\\\\"green\\\\\"}\",\n              \"weight\": 0.3333333333333333,\n            },\n          },\n          \"{\\\\\"value\\\\\":\\\\\"green\\\\\"}\": Object {\n            \"{\\\\\"type\\\\\":\\\\\"TIMER\\\\\"}\": Object {\n              \"count\": 1,\n              \"currentWeight\": 1,\n              \"relativeWeight\": 1,\n              \"state\": \"{\\\\\"value\\\\\":\\\\\"yellow\\\\\"}\",\n              \"weight\": 0.3333333333333333,\n            },\n          },\n          \"{\\\\\"value\\\\\":\\\\\"yellow\\\\\"}\": Object {\n            \"{\\\\\"type\\\\\":\\\\\"TIMER\\\\\"}\": Object {\n              \"count\": 1,\n              \"currentWeight\": 1,\n              \"relativeWeight\": 1,\n              \"state\": \"{\\\\\"value\\\\\":{\\\\\"red\\\\\":\\\\\"walk\\\\\"}}\",\n              \"weight\": 0.3333333333333333,\n            },\n          },\n        },\n      }\n    `);\n  });","file":"analytics.test.ts","skipped":false,"dir":"packages/xstate-analytics/test"},{"name":"should return back the config object","suites":["@xstate/fsm"],"updatePoint":{"line":70,"column":42},"line":70,"code":"  it('should return back the config object', () => {\n    expect(lightFSM.config).toBe(lightConfig);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should have the correct initial state","suites":["@xstate/fsm"],"updatePoint":{"line":73,"column":43},"line":73,"code":"  it('should have the correct initial state', () => {\n    const { initialState } = lightFSM;\n\n    expect(initialState.value).toEqual('green');\n    expect(initialState.actions).toEqual([{ type: 'enterGreen' }]);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should have initial context updated by initial assign actions","suites":["@xstate/fsm"],"updatePoint":{"line":79,"column":67},"line":79,"code":"  it('should have initial context updated by initial assign actions', () => {\n    const { initialState } = createMachine({\n      initial: 'init',\n      context: {\n        count: 0\n      },\n      states: {\n        init: {\n          entry: assign({\n            count: () => 1\n          })\n        }\n      }\n    });\n\n    expect(initialState.context).toEqual({ count: 1 });\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should have initial actions computed without assign actions","suites":["@xstate/fsm"],"updatePoint":{"line":96,"column":65},"line":96,"code":"  it('should have initial actions computed without assign actions', () => {\n    const { initialState } = createMachine({\n      initial: 'init',\n      context: {\n        count: 0\n      },\n      states: {\n        init: {\n          entry: [\n            { type: 'foo' },\n            assign({\n              count: () => 1\n            })\n          ]\n        }\n      }\n    });\n\n    expect(initialState.actions).toEqual([{ type: 'foo' }]);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should transition correctly","suites":["@xstate/fsm"],"updatePoint":{"line":116,"column":33},"line":116,"code":"  it('should transition correctly', () => {\n    const nextState = lightFSM.transition('green', 'TIMER');\n    expect(nextState.value).toEqual('yellow');\n    expect(nextState.actions.map((action) => action.type)).toEqual([\n      'exitGreen',\n      'g-y 1',\n      'g-y 2'\n    ]);\n    expect(nextState.context).toEqual({\n      count: 2,\n      foo: 'static++',\n      go: false\n    });\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should stay on the same state for undefined transitions","suites":["@xstate/fsm"],"updatePoint":{"line":131,"column":61},"line":131,"code":"  it('should stay on the same state for undefined transitions', () => {\n    const nextState = lightFSM.transition('green', 'FAKE' as any);\n    expect(nextState.value).toBe('green');\n    expect(nextState.actions).toEqual([]);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should throw an error for undefined states","suites":["@xstate/fsm"],"updatePoint":{"line":137,"column":48},"line":137,"code":"  it('should throw an error for undefined states', () => {\n    expect(() => {\n      lightFSM.transition('unknown', 'TIMER');\n    }).toThrow();\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should throw an error for undefined next state config","suites":["@xstate/fsm"],"updatePoint":{"line":143,"column":59},"line":143,"code":"  it('should throw an error for undefined next state config', () => {\n    const invalidState = 'blue';\n    const testConfig = {\n      id: 'test',\n      initial: 'green',\n      states: {\n        green: {\n          on: {\n            TARGET_INVALID: invalidState\n          }\n        },\n        yellow: {}\n      }\n    };\n    const testMachine = createMachine(testConfig);\n    expect(() => {\n      testMachine.transition('green', 'TARGET_INVALID');\n    }).toThrow(\n      `State '${invalidState}' not found on machine ${testConfig.id ?? ''}`\n    );\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should work with guards","suites":["@xstate/fsm"],"updatePoint":{"line":165,"column":29},"line":165,"code":"  it('should work with guards', () => {\n    const yellowState = lightFSM.transition('yellow', 'EMERGENCY');\n    expect(yellowState.value).toEqual('yellow');\n\n    const redState = lightFSM.transition('yellow', {\n      type: 'EMERGENCY',\n      value: 2\n    });\n    expect(redState.value).toEqual('red');\n    expect(redState.context.count).toBe(0);\n\n    const yellowOneState = lightFSM.transition('yellow', 'INC');\n    const redOneState = lightFSM.transition(yellowOneState, {\n      type: 'EMERGENCY',\n      value: 1\n    });\n\n    expect(redOneState.value).toBe('red');\n    expect(redOneState.context.count).toBe(1);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should be changed if state changes","suites":["@xstate/fsm"],"updatePoint":{"line":186,"column":40},"line":186,"code":"  it('should be changed if state changes', () => {\n    expect(lightFSM.transition('green', 'TIMER').changed).toBe(true);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should be changed if any actions occur","suites":["@xstate/fsm"],"updatePoint":{"line":190,"column":44},"line":190,"code":"  it('should be changed if any actions occur', () => {\n    expect(lightFSM.transition('yellow', 'INC').changed).toBe(true);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should not be changed on unknown transitions","suites":["@xstate/fsm"],"updatePoint":{"line":194,"column":50},"line":194,"code":"  it('should not be changed on unknown transitions', () => {\n    expect(lightFSM.transition('yellow', 'UNKNOWN' as any).changed).toBe(false);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should match initialState","suites":["@xstate/fsm"],"updatePoint":{"line":198,"column":31},"line":198,"code":"  it('should match initialState', () => {\n    const { initialState } = lightFSM;\n\n    expect(initialState.matches('green')).toBeTruthy();\n\n    if (initialState.matches('green')) {\n      expect(initialState.context.go).toBeTruthy();\n    }\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should match transition states","suites":["@xstate/fsm"],"updatePoint":{"line":208,"column":36},"line":208,"code":"  it('should match transition states', () => {\n    const { initialState } = lightFSM;\n    const nextState = lightFSM.transition(initialState, 'TIMER');\n\n    expect(nextState.matches('yellow')).toBeTruthy();\n\n    if (nextState.matches('yellow')) {\n      expect(nextState.context.go).toBeFalsy();\n    }\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"listeners should immediately get the initial state","suites":["interpreter"],"updatePoint":{"line":231,"column":56},"line":231,"code":"  it('listeners should immediately get the initial state', (done) => {\n    const toggleService = interpret(toggleMachine).start();\n\n    toggleService.subscribe((state) => {\n      if (state.matches('active')) {\n        done();\n      }\n    });\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"listeners should subscribe to state changes","suites":["interpreter"],"updatePoint":{"line":241,"column":49},"line":241,"code":"  it('listeners should subscribe to state changes', (done) => {\n    const toggleService = interpret(toggleMachine).start();\n\n    toggleService.subscribe((state) => {\n      if (state.matches('inactive')) {\n        done();\n      }\n    });\n\n    toggleService.send('TOGGLE');\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should execute actions","suites":["interpreter"],"updatePoint":{"line":253,"column":28},"line":253,"code":"  it('should execute actions', (done) => {\n    let executed = false;\n\n    const actionMachine = createMachine({\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            TOGGLE: {\n              target: 'inactive',\n              actions: () => {\n                executed = true;\n              }\n            }\n          }\n        },\n        inactive: {}\n      }\n    });\n\n    const actionService = interpret(actionMachine).start();\n\n    actionService.subscribe(() => {\n      if (executed) {\n        done();\n      }\n    });\n\n    actionService.send('TOGGLE');\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should execute initial entry action","suites":["interpreter"],"updatePoint":{"line":284,"column":41},"line":284,"code":"  it('should execute initial entry action', () => {\n    let executed = false;\n\n    const machine = createMachine({\n      initial: 'foo',\n      states: {\n        foo: {\n          entry: () => {\n            executed = true;\n          }\n        }\n      }\n    });\n\n    interpret(machine).start();\n    expect(executed).toBe(true);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should lookup string actions in options","suites":["interpreter"],"updatePoint":{"line":302,"column":45},"line":302,"code":"  it('should lookup string actions in options', () => {\n    let executed = false;\n\n    const machine = createMachine(\n      {\n        initial: 'foo',\n        states: {\n          foo: {\n            entry: 'testAction'\n          }\n        }\n      },\n      {\n        actions: {\n          testAction: () => {\n            executed = true;\n          }\n        }\n      }\n    );\n\n    interpret(machine).start();\n\n    expect(executed).toBe(true);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should reveal the current state","suites":["interpreter"],"updatePoint":{"line":328,"column":37},"line":328,"code":"  it('should reveal the current state', () => {\n    const machine = createMachine({\n      initial: 'test',\n      context: { foo: 'bar' },\n      states: {\n        test: {}\n      }\n    });\n    const service = interpret(machine);\n\n    service.start();\n\n    expect(service.state.value).toEqual('test');\n    expect(service.state.context).toEqual({ foo: 'bar' });\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should reveal the current state after transition","suites":["interpreter"],"updatePoint":{"line":344,"column":54},"line":344,"code":"  it('should reveal the current state after transition', (done) => {\n    const machine = createMachine({\n      initial: 'test',\n      context: { foo: 'bar' },\n      states: {\n        test: {\n          on: { CHANGE: 'success' }\n        },\n        success: {}\n      }\n    });\n    const service = interpret(machine);\n\n    service.start();\n\n    service.subscribe(() => {\n      if (service.state.value === 'success') {\n        done();\n      }\n    });\n\n    service.send('CHANGE');\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should not re-execute exit/entry actions for transitions with undefined targets","suites":["interpreter"],"updatePoint":{"line":368,"column":85},"line":368,"code":"  it('should not re-execute exit/entry actions for transitions with undefined targets', () => {\n    const machine = createMachine({\n      initial: 'test',\n      states: {\n        test: {\n          entry: ['entry'],\n          exit: ['exit'],\n          on: {\n            EVENT: {\n              // undefined target\n              actions: ['action']\n            }\n          }\n        }\n      }\n    });\n\n    const { initialState } = machine;\n\n    expect(initialState.actions.map((a) => a.type)).toEqual(['entry']);\n\n    const nextState = machine.transition(initialState, 'EVENT');\n\n    expect(nextState.actions.map((a) => a.type)).toEqual(['action']);\n  });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should start the service with initial state by default","suites":["interpreter","`start` method"],"updatePoint":{"line":395,"column":62},"line":395,"code":"    it('should start the service with initial state by default', () => {\n      const machine = createMachine({\n        initial: 'foo',\n        states: {\n          foo: {\n            on: {\n              NEXT: 'bar'\n            }\n          },\n          bar: {}\n        }\n      });\n\n      const service = interpret(machine).start();\n\n      expect(service.state.value).toBe('foo');\n    });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should rehydrate the state if the state if provided","suites":["interpreter","`start` method"],"updatePoint":{"line":413,"column":59},"line":413,"code":"    it('should rehydrate the state if the state if provided', () => {\n      const machine = createMachine({\n        initial: 'foo',\n        states: {\n          foo: {\n            on: {\n              NEXT: 'bar'\n            }\n          },\n          bar: {\n            on: {\n              NEXT: 'baz'\n            }\n          },\n          baz: {}\n        }\n      });\n\n      const service = interpret(machine).start('bar');\n      expect(service.state.value).toBe('bar');\n\n      service.send('NEXT');\n      expect(service.state.matches('baz')).toBe(true);\n    });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should rehydrate the state and the context if both are provided","suites":["interpreter","`start` method"],"updatePoint":{"line":438,"column":71},"line":438,"code":"    it('should rehydrate the state and the context if both are provided', () => {\n      const machine = createMachine({\n        initial: 'foo',\n        states: {\n          foo: {\n            on: {\n              NEXT: 'bar'\n            }\n          },\n          bar: {\n            on: {\n              NEXT: 'baz'\n            }\n          },\n          baz: {}\n        }\n      });\n\n      const context = { hello: 'world' };\n      const service = interpret(machine).start({ value: 'bar', context });\n      expect(service.state.value).toBe('bar');\n      expect(service.state.context).toBe(context);\n\n      service.send('NEXT');\n      expect(service.state.matches('baz')).toBe(true);\n    });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should execute initial actions when re-starting a service","suites":["interpreter","`start` method"],"updatePoint":{"line":465,"column":65},"line":465,"code":"    it('should execute initial actions when re-starting a service', () => {\n      let entryActionCalled = false;\n      const machine = createMachine({\n        initial: 'test',\n        states: {\n          test: {\n            entry: () => (entryActionCalled = true)\n          }\n        }\n      });\n\n      const service = interpret(machine).start();\n      service.stop();\n\n      entryActionCalled = false;\n\n      service.start();\n\n      expect(entryActionCalled).toBe(true);\n    });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should execute initial actions when re-starting a service that transitioned to a different state","suites":["interpreter","`start` method"],"updatePoint":{"line":486,"column":104},"line":486,"code":"    it('should execute initial actions when re-starting a service that transitioned to a different state', () => {\n      let entryActionCalled = false;\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            entry: () => (entryActionCalled = true),\n            on: {\n              NEXT: 'b'\n            }\n          },\n          b: {}\n        }\n      });\n\n      const service = interpret(machine).start();\n      service.send({ type: 'NEXT' });\n      service.stop();\n\n      entryActionCalled = false;\n\n      service.start();\n\n      expect(entryActionCalled).toBe(true);\n    });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should not execute actions of the last known non-initial state when re-starting a service","suites":["interpreter","`start` method"],"updatePoint":{"line":512,"column":97},"line":512,"code":"    it('should not execute actions of the last known non-initial state when re-starting a service', () => {\n      let entryActionCalled = false;\n      const machine = createMachine({\n        initial: 'a',\n        states: {\n          a: {\n            on: {\n              NEXT: 'b'\n            }\n          },\n          b: {\n            entry: () => (entryActionCalled = true)\n          }\n        }\n      });\n\n      const service = interpret(machine).start();\n      service.send({ type: 'NEXT' });\n      service.stop();\n\n      entryActionCalled = false;\n\n      service.start();\n\n      expect(entryActionCalled).toBe(false);\n    });","file":"fsm.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should allow matches to be called multiple times in a single branch of code","suites":["matches"],"updatePoint":{"line":4,"column":81},"line":4,"code":"  it('should allow matches to be called multiple times in a single branch of code', () => {\n    const machine = createMachine<{ count: number }>({\n      initial: 'a',\n      states: { a: {} }\n    });\n    const state = machine.initialState;\n\n    if (state.matches('idle')) {\n      ((_accept: number) => {})(state.context.count);\n      // @ts-expect-error\n      ((_accept: string) => {})(state.context.count);\n    } else if (state.matches('latest')) {\n      ((_accept: number) => {})(state.context.count);\n      // @ts-expect-error\n      ((_accept: string) => {})(state.context.count);\n    }\n  });","file":"types.test.ts","skipped":false,"dir":"packages/xstate-fsm/test"},{"name":"should return an array of all nodes","suites":["@xstate/graph","getNodes()"],"updatePoint":{"line":129,"column":43},"line":129,"code":"    it('should return an array of all nodes', () => {\n      const nodes = getStateNodes(lightMachine);\n      expect(nodes.every((node) => node instanceof StateNode)).toBe(true);\n      expect(nodes.map((node) => node.id).sort()).toEqual([\n        'light.green',\n        'light.red',\n        'light.red.flashing',\n        'light.red.stop',\n        'light.red.wait',\n        'light.red.walk',\n        'light.yellow'\n      ]);\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return an array of all nodes (parallel)","suites":["@xstate/graph","getNodes()"],"updatePoint":{"line":143,"column":54},"line":143,"code":"    it('should return an array of all nodes (parallel)', () => {\n      const nodes = getStateNodes(parallelMachine);\n      expect(nodes.every((node) => node instanceof StateNode)).toBe(true);\n      expect(nodes.map((node) => node.id).sort()).toEqual([\n        'p.a',\n        'p.a.a1',\n        'p.a.a2',\n        'p.a.a3',\n        'p.b',\n        'p.b.b1',\n        'p.b.b2',\n        'p.b.b3'\n      ]);\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return a mapping of shortest paths to all states","suites":["@xstate/graph","getShortestPaths()"],"updatePoint":{"line":160,"column":63},"line":160,"code":"    it('should return a mapping of shortest paths to all states', () => {\n      const paths = getShortestPaths(lightMachine) as any;\n\n      expect(paths).toMatchSnapshot('shortest paths');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return a mapping of shortest paths to all states (parallel)","suites":["@xstate/graph","getShortestPaths()"],"updatePoint":{"line":166,"column":74},"line":166,"code":"    it('should return a mapping of shortest paths to all states (parallel)', () => {\n      const paths = getShortestPaths(parallelMachine) as any;\n      expect(paths).toMatchSnapshot('shortest paths parallel');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"the initial state should have a zero-length path","suites":["@xstate/graph","getShortestPaths()"],"updatePoint":{"line":171,"column":56},"line":171,"code":"    it('the initial state should have a zero-length path', () => {\n      expect(\n        getShortestPaths(lightMachine)[\n          JSON.stringify(lightMachine.initialState.value)\n        ].paths[0].segments\n      ).toHaveLength(0);\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should represent conditional paths based on context","suites":["@xstate/graph","getShortestPaths()"],"updatePoint":{"line":183,"column":59},"line":183,"code":"    it('should represent conditional paths based on context', () => {\n      // explicit type arguments could be removed once davidkpiano/xstate#652 gets resolved\n      const paths = getShortestPaths<CondMachineCtx, CondMachineEvents>(\n        condMachine.withContext({\n          id: 'foo'\n        }),\n        {\n          events: {\n            EVENT: [\n              {\n                type: 'EVENT',\n                id: 'whatever'\n              }\n            ],\n            STATE: [\n              {\n                type: 'STATE'\n              }\n            ]\n          }\n        }\n      );\n\n      expect(paths).toMatchSnapshot('shortest paths conditional');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return a mapping of arrays of simple paths to all states","suites":["@xstate/graph","getSimplePaths()"],"updatePoint":{"line":211,"column":71},"line":211,"code":"    it('should return a mapping of arrays of simple paths to all states', () => {\n      const paths = getSimplePaths(lightMachine) as any;\n\n      expect(paths).toMatchSnapshot('simple paths');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return a mapping of simple paths to all states (parallel)","suites":["@xstate/graph","getSimplePaths()"],"updatePoint":{"line":225,"column":72},"line":225,"code":"    it('should return a mapping of simple paths to all states (parallel)', () => {\n      const paths = getSimplePaths(parallelMachine);\n      expect(paths).toMatchSnapshot('simple paths parallel');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return multiple paths for equivalent transitions","suites":["@xstate/graph","getSimplePaths()"],"updatePoint":{"line":230,"column":63},"line":230,"code":"    it('should return multiple paths for equivalent transitions', () => {\n      const paths = getSimplePaths(equivMachine);\n      expect(paths).toMatchSnapshot('simple paths equal transitions');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return a single empty path for the initial state","suites":["@xstate/graph","getSimplePaths()"],"updatePoint":{"line":235,"column":63},"line":235,"code":"    it('should return a single empty path for the initial state', () => {\n      expect(getSimplePaths(lightMachine)['\"green\"'].paths).toHaveLength(1);\n      expect(\n        getSimplePaths(lightMachine)['\"green\"'].paths[0].segments\n      ).toHaveLength(0);\n      expect(getSimplePaths(equivMachine)['\"a\"'].paths).toHaveLength(1);\n      expect(\n        getSimplePaths(equivMachine)['\"a\"'].paths[0].segments\n      ).toHaveLength(0);\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return value-based paths","suites":["@xstate/graph","getSimplePaths()"],"updatePoint":{"line":246,"column":39},"line":246,"code":"    it('should return value-based paths', () => {\n      interface Ctx {\n        count: number;\n      }\n      interface Events {\n        type: 'INC';\n        value: number;\n      }\n      const countMachine = Machine<Ctx, Events>({\n        id: 'count',\n        initial: 'start',\n        context: {\n          count: 0\n        },\n        states: {\n          start: {\n            always: {\n              target: 'finish',\n              cond: (ctx) => ctx.count === 3\n            },\n            on: {\n              INC: {\n                actions: assign({\n                  count: (ctx) => ctx.count + 1\n                })\n              }\n            }\n          },\n          finish: {}\n        }\n      });\n\n      const paths = getSimplePaths(countMachine, {\n        events: {\n          INC: [{ type: 'INC', value: 1 }]\n        }\n      });\n\n      expect(paths).toMatchSnapshot('simple paths context');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return an array of shortest paths to all states","suites":["@xstate/graph","getSimplePathsAsArray()"],"updatePoint":{"line":289,"column":62},"line":289,"code":"    it('should return an array of shortest paths to all states', () => {\n      const pathsArray = getSimplePathsAsArray(lightMachine);\n\n      expect(Array.isArray(pathsArray)).toBeTruthy();\n      expect(pathsArray).toMatchSnapshot('simple paths array');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should return a path to the last entered state by the event sequence","suites":["@xstate/graph","getPathFromEvents()"],"updatePoint":{"line":298,"column":76},"line":298,"code":"    it('should return a path to the last entered state by the event sequence', () => {\n      const path = getPathFromEvents(lightMachine, [\n        { type: 'TIMER' },\n        { type: 'TIMER' },\n        { type: 'TIMER' },\n        { type: 'POWER_OUTAGE' }\n      ]);\n\n      expect(path).toMatchSnapshot('path from events');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should throw when an invalid event sequence is provided","suites":["@xstate/graph","getPathFromEvents()"],"updatePoint":{"line":309,"column":63},"line":309,"code":"    it('should throw when an invalid event sequence is provided', () => {\n      expect(() =>\n        getPathFromEvents(lightMachine, [\n          { type: 'TIMER' },\n          { type: 'INVALID_EVENT' }\n        ])\n      ).toThrow();\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should map adjacencies","suites":["@xstate/graph","getAdjacencyMap"],"updatePoint":{"line":320,"column":30},"line":320,"code":"    it('should map adjacencies', () => {\n      interface Ctx {\n        count: number;\n        other: string;\n      }\n      type Events = { type: 'INC'; value: number } | { type: 'DEC' };\n\n      const counterMachine = Machine<Ctx, Events>({\n        id: 'counter',\n        initial: 'empty',\n        context: {\n          count: 0,\n          other: 'something'\n        },\n        states: {\n          empty: {\n            always: {\n              target: 'full',\n              cond: (ctx) => ctx.count === 5\n            },\n            on: {\n              INC: {\n                actions: assign({\n                  count: (ctx, e) => ctx.count + e.value\n                })\n              },\n              DEC: {\n                actions: assign({\n                  count: (ctx) => ctx.count - 1\n                })\n              }\n            }\n          },\n          full: {}\n        }\n      });\n\n      // explicit type arguments could be removed once davidkpiano/xstate#652 gets resolved\n      const adj = getAdjacencyMap<Ctx, Events>(counterMachine, {\n        filter: (state) => state.context.count >= 0 && state.context.count <= 5,\n        stateSerializer: (state) => {\n          const ctx = {\n            count: state.context.count\n          };\n          return JSON.stringify(state.value) + ' | ' + JSON.stringify(ctx);\n        },\n        events: {\n          INC: [{ type: 'INC', value: 1 }]\n        }\n      });\n\n      expect(adj).toHaveProperty('\"full\" | {\"count\":5}');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should get events via function","suites":["@xstate/graph","getAdjacencyMap"],"updatePoint":{"line":374,"column":38},"line":374,"code":"    it('should get events via function', () => {\n      const machine = createMachine<\n        { count: number },\n        { type: 'EVENT'; value: number }\n      >({\n        initial: 'first',\n        context: {\n          count: 0\n        },\n        states: {\n          first: {\n            on: {\n              EVENT: {\n                target: 'second',\n                actions: assign({\n                  count: (_, event) => event.value\n                })\n              }\n            }\n          },\n          second: {}\n        }\n      });\n\n      const adj = getAdjacencyMap(machine, {\n        events: {\n          EVENT: (state) => [{ type: 'EVENT', value: state.context.count + 10 }]\n        }\n      });\n\n      expect(adj).toHaveProperty('\"second\" | {\"count\":10}');\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should represent a statechart as a directed graph","suites":["@xstate/graph","toDirectedGraph"],"updatePoint":{"line":409,"column":57},"line":409,"code":"    it('should represent a statechart as a directed graph', () => {\n      const machine = createMachine({\n        id: 'light',\n        initial: 'green',\n        states: {\n          green: { on: { TIMER: 'yellow' } },\n          yellow: { on: { TIMER: 'red' } },\n          red: {\n            initial: 'walk',\n            states: {\n              walk: { on: { COUNTDOWN: 'wait' } },\n              wait: { on: { COUNTDOWN: 'stop' } },\n              stop: { on: { COUNTDOWN: 'finished' } },\n              finished: { type: 'final' }\n            },\n            onDone: 'green'\n          }\n        }\n      });\n\n      const digraph = toDirectedGraph(machine);\n\n      expect(digraph).toMatchSnapshot();\n    });","file":"graph.test.ts","skipped":false,"dir":"packages/xstate-graph/test"},{"name":"should update the context without modifying previous contexts","suites":["@xstate/immer"],"updatePoint":{"line":5,"column":67},"line":5,"code":"  it('should update the context without modifying previous contexts', () => {\n    const context = {\n      count: 0\n    };\n    const countMachine = createMachine<typeof context>({\n      id: 'count',\n      context,\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            INC: {\n              actions: assign<typeof context>((ctx) => ctx.count++)\n            }\n          }\n        }\n      }\n    });\n\n    const zeroState = countMachine.initialState;\n    const oneState = countMachine.transition(zeroState, 'INC');\n    const twoState = countMachine.transition(zeroState, 'INC');\n\n    expect(zeroState.context).toEqual({ count: 0 });\n    expect(oneState.context).toEqual({ count: 1 });\n    expect(twoState.context).toEqual({ count: 1 });\n  });","file":"immer.test.ts","skipped":false,"dir":"packages/xstate-immer/test"},{"name":"should perform multiple updates correctly","suites":["@xstate/immer"],"updatePoint":{"line":33,"column":47},"line":33,"code":"  it('should perform multiple updates correctly', () => {\n    const context = {\n      count: 0\n    };\n    const countMachine = createMachine<typeof context>(\n      {\n        id: 'count',\n        context,\n        initial: 'active',\n        states: {\n          active: {\n            on: {\n              INC_TWICE: {\n                actions: ['increment', 'increment']\n              }\n            }\n          }\n        }\n      },\n      {\n        actions: {\n          increment: assign<typeof context>((ctx) => ctx.count++)\n        }\n      }\n    );\n\n    const zeroState = countMachine.initialState;\n    const twoState = countMachine.transition(zeroState, 'INC_TWICE');\n\n    expect(zeroState.context).toEqual({ count: 0 });\n    expect(twoState.context).toEqual({ count: 2 });\n  });","file":"immer.test.ts","skipped":false,"dir":"packages/xstate-immer/test"},{"name":"should perform deep updates correctly","suites":["@xstate/immer"],"updatePoint":{"line":66,"column":43},"line":66,"code":"  it('should perform deep updates correctly', () => {\n    const context = {\n      foo: {\n        bar: {\n          baz: [1, 2, 3]\n        }\n      }\n    };\n    const countMachine = createMachine<typeof context>(\n      {\n        id: 'count',\n        context,\n        initial: 'active',\n        states: {\n          active: {\n            on: {\n              INC_TWICE: {\n                actions: ['pushBaz', 'pushBaz']\n              }\n            }\n          }\n        }\n      },\n      {\n        actions: {\n          pushBaz: assign<typeof context>((ctx) => ctx.foo.bar.baz.push(0))\n        }\n      }\n    );\n\n    const zeroState = countMachine.initialState;\n    const twoState = countMachine.transition(zeroState, 'INC_TWICE');\n\n    expect(zeroState.context.foo.bar.baz).toEqual([1, 2, 3]);\n    expect(twoState.context.foo.bar.baz).toEqual([1, 2, 3, 0, 0]);\n  });","file":"immer.test.ts","skipped":false,"dir":"packages/xstate-immer/test"},{"name":"should create updates","suites":["@xstate/immer"],"updatePoint":{"line":103,"column":27},"line":103,"code":"  it('should create updates', () => {\n    const context = {\n      foo: {\n        bar: {\n          baz: [1, 2, 3]\n        }\n      }\n    };\n\n    const bazUpdater = createUpdater<\n      typeof context,\n      ImmerUpdateEvent<'UPDATE_BAZ', number>\n    >('UPDATE_BAZ', (ctx, { input }) => {\n      ctx.foo.bar.baz.push(input);\n    });\n\n    const countMachine = createMachine<typeof context>({\n      id: 'count',\n      context,\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            [bazUpdater.type]: {\n              actions: bazUpdater.action\n            }\n          }\n        }\n      }\n    });\n\n    const zeroState = countMachine.initialState;\n\n    const twoState = countMachine.transition(zeroState, bazUpdater.update(4));\n\n    expect(zeroState.context.foo.bar.baz).toEqual([1, 2, 3]);\n    expect(twoState.context.foo.bar.baz).toEqual([1, 2, 3, 4]);\n  });","file":"immer.test.ts","skipped":false,"dir":"packages/xstate-immer/test"},{"name":"should create updates (form example)","suites":["@xstate/immer"],"updatePoint":{"line":142,"column":42},"line":142,"code":"  it('should create updates (form example)', (done) => {\n    interface FormContext {\n      name: string;\n      age: number | undefined;\n    }\n\n    type NameUpdateEvent = ImmerUpdateEvent<'UPDATE_NAME', string>;\n    type AgeUpdateEvent = ImmerUpdateEvent<'UPDATE_AGE', number>;\n\n    const nameUpdater = createUpdater<FormContext, NameUpdateEvent>(\n      'UPDATE_NAME',\n      (ctx, { input }) => {\n        ctx.name = input;\n      }\n    );\n\n    const ageUpdater = createUpdater<FormContext, AgeUpdateEvent>(\n      'UPDATE_AGE',\n      (ctx, { input }) => {\n        ctx.age = input;\n      }\n    );\n\n    type FormEvent =\n      | NameUpdateEvent\n      | AgeUpdateEvent\n      | {\n          type: 'SUBMIT';\n        };\n\n    const formMachine = createMachine<FormContext, FormEvent>({\n      initial: 'editing',\n      context: {\n        name: '',\n        age: undefined\n      },\n      states: {\n        editing: {\n          on: {\n            [nameUpdater.type]: { actions: nameUpdater.action },\n            [ageUpdater.type]: { actions: ageUpdater.action },\n            SUBMIT: 'submitting'\n          }\n        },\n        submitting: {\n          on: {\n            '': {\n              target: 'success',\n              cond: (ctx) => {\n                return ctx.name === 'David' && ctx.age === 0;\n              }\n            }\n          }\n        },\n        success: {\n          type: 'final'\n        }\n      }\n    });\n\n    const service = interpret(formMachine)\n      .onDone(() => {\n        done();\n      })\n      .start();\n\n    service.send(nameUpdater.update('David'));\n    service.send(ageUpdater.update(0));\n\n    service.send('SUBMIT');\n  });","file":"immer.test.ts","skipped":false,"dir":"packages/xstate-immer/test"},{"name":"should handle circular structures in context","suites":["@xstate/inspect"],"updatePoint":{"line":49,"column":50},"line":49,"code":"  it('should handle circular structures in context', (done) => {\n    const circularStructure = {\n      get cycle() {\n        return circularStructure;\n      }\n    };\n\n    const machine = createMachine({\n      initial: 'active',\n      context: circularStructure,\n      states: {\n        active: {}\n      }\n    });\n\n    const devTools = createDevTools();\n\n    devTools.onRegister(() => {\n      done();\n    });\n\n    inspect({\n      iframe: false,\n      devTools\n    });\n\n    const service = interpret(machine).start();\n\n    // The devTools will notify the listeners:\n    // 1. the built-in service listener\n    // 2. the test listener that calls done() above\n    // with the service. The built-in service listener is responsible for\n    // stringifying the service's machine definition (which contains a circular structure)\n    // and will throw an error if circular structures are not handled.\n    expect(() => devTools.register(service)).not.toThrow();\n  });","file":"inspect.test.ts","skipped":false,"dir":"packages/xstate-inspect/test"},{"name":"should handle circular structures in events","suites":["@xstate/inspect"],"updatePoint":{"line":86,"column":49},"line":86,"code":"  it('should handle circular structures in events', (done) => {\n    const circularStructure = {\n      get cycle() {\n        return circularStructure;\n      }\n    };\n\n    const machine = createMachine({\n      initial: 'active',\n      states: {\n        active: {}\n      }\n    });\n\n    const devTools = createDevTools();\n\n    devTools.onRegister((inspectedService) => {\n      inspectedService.onTransition((state) => {\n        if (state.event.type === 'CIRCULAR') {\n          done();\n        }\n      });\n    });\n\n    inspect({\n      iframe: false,\n      devTools\n    });\n\n    const service = interpret(machine).start();\n\n    service.send({\n      type: 'CIRCULAR',\n      value: circularStructure\n    });\n\n    expect(() => devTools.register(service)).not.toThrow();\n  });","file":"inspect.test.ts","skipped":false,"dir":"packages/xstate-inspect/test"},{"name":"should accept a serializer","suites":["@xstate/inspect"],"updatePoint":{"line":125,"column":32},"line":125,"code":"  it('should accept a serializer', () => {\n    expect.assertions(2);\n    const machine = createMachine({\n      initial: 'active',\n      context: {\n        map: new Map(),\n        deep: {\n          map: new Map()\n        }\n      },\n      states: {\n        active: {}\n      }\n    });\n\n    const devTools = createDevTools();\n\n    inspect({\n      iframe: false,\n      devTools,\n      serialize: (_key, value) => {\n        if (value instanceof Map) {\n          return 'map';\n        }\n\n        return value;\n      }\n    })?.subscribe((state) => {\n      if (state.event.type === 'service.register') {\n        expect(JSON.parse(state.event.machine).context).toEqual({\n          map: 'map',\n          deep: {\n            map: 'map'\n          }\n        });\n      }\n\n      if (\n        state.event.type === 'service.event' &&\n        JSON.parse(state.event.event).name === 'TEST'\n      ) {\n        expect(JSON.parse(state.event.event).data).toEqual({\n          type: 'TEST',\n          serialized: 'map',\n          deep: {\n            serialized: 'map'\n          }\n        });\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    devTools.register(service);\n\n    service.send({\n      type: 'TEST',\n      serialized: new Map(), // test value to serialize\n      deep: {\n        serialized: new Map()\n      }\n    });\n  });","file":"inspect.test.ts","skipped":false,"dir":"packages/xstate-inspect/test"},{"name":"should not crash when registering machine with very deep context when serializer manages to replace it","suites":["@xstate/inspect"],"updatePoint":{"line":189,"column":108},"line":189,"code":"  it('should not crash when registering machine with very deep context when serializer manages to replace it', (done) => {\n    type DeepObject = { nested?: DeepObject };\n\n    const deepObj: DeepObject = {};\n\n    let current = deepObj;\n    for (let i = 0; i < 20_000; i += 1) {\n      current.nested = {};\n      current = current.nested;\n    }\n\n    const machine = createMachine({\n      initial: 'active',\n      context: deepObj,\n      states: {\n        active: {}\n      }\n    });\n\n    const devTools = createDevTools();\n\n    inspect({\n      iframe: false,\n      devTools,\n      serialize: (key, value) => {\n        if (key === 'nested') {\n          return '[very deep]';\n        }\n\n        return value;\n      }\n    });\n\n    const service = interpret(machine).start();\n\n    devTools.onRegister(() => {\n      done();\n    });\n\n    expect(() => devTools.register(service)).not.toThrow();\n  });","file":"inspect.test.ts","skipped":false,"dir":"packages/xstate-inspect/test"},{"name":"should successfully serialize value with unsafe toJSON when serializer manages to replace it","suites":["@xstate/inspect"],"updatePoint":{"line":231,"column":98},"line":231,"code":"  it('should successfully serialize value with unsafe toJSON when serializer manages to replace it', () => {\n    const machine = createMachine({\n      context: {},\n      on: {\n        EV: {\n          actions: assign({\n            value: (_ctx, ev: any) => ev.value\n          })\n        }\n      }\n    });\n\n    const devTools = createDevTools();\n    const iframeMock = createIframeMock();\n\n    inspect({\n      iframe: iframeMock.iframe,\n      devTools,\n      serialize(_key, value) {\n        if (value && typeof value === 'object' && 'unsafe' in value) {\n          return {\n            ...value,\n            unsafe: '[unsafe]'\n          };\n        }\n        return value;\n      }\n    });\n\n    iframeMock.initConnection();\n\n    const service = interpret(machine).start();\n    devTools.register(service);\n\n    iframeMock.flushMessages();\n\n    service.send({\n      type: 'EV',\n      value: {\n        unsafe: {\n          get toJSON() {\n            throw new Error('oops');\n          }\n        }\n      }\n    });\n\n    expect(iframeMock.flushMessages()).toMatchInlineSnapshot(`\n      Array [\n        Object {\n          \"event\": \"{\\\\\"name\\\\\":\\\\\"EV\\\\\",\\\\\"data\\\\\":{\\\\\"type\\\\\":\\\\\"EV\\\\\",\\\\\"value\\\\\":{\\\\\"unsafe\\\\\":\\\\\"[unsafe]\\\\\"}},\\\\\"$$type\\\\\":\\\\\"scxml\\\\\",\\\\\"type\\\\\":\\\\\"external\\\\\"}\",\n          \"sessionId\": \"x:9\",\n          \"type\": \"service.event\",\n        },\n        Object {\n          \"sessionId\": \"x:9\",\n          \"state\": \"{\\\\\"actions\\\\\":[],\\\\\"activities\\\\\":{},\\\\\"meta\\\\\":{},\\\\\"events\\\\\":[],\\\\\"value\\\\\":{},\\\\\"context\\\\\":{\\\\\"value\\\\\":{\\\\\"unsafe\\\\\":\\\\\"[unsafe]\\\\\"}},\\\\\"_event\\\\\":{\\\\\"name\\\\\":\\\\\"EV\\\\\",\\\\\"data\\\\\":{\\\\\"type\\\\\":\\\\\"EV\\\\\",\\\\\"value\\\\\":{\\\\\"unsafe\\\\\":\\\\\"[unsafe]\\\\\"}},\\\\\"$$type\\\\\":\\\\\"scxml\\\\\",\\\\\"type\\\\\":\\\\\"external\\\\\"},\\\\\"_sessionid\\\\\":\\\\\"x:9\\\\\",\\\\\"event\\\\\":{\\\\\"type\\\\\":\\\\\"EV\\\\\",\\\\\"value\\\\\":{\\\\\"unsafe\\\\\":\\\\\"[unsafe]\\\\\"}},\\\\\"transitions\\\\\":[{\\\\\"actions\\\\\":[{\\\\\"type\\\\\":\\\\\"xstate.assign\\\\\",\\\\\"assignment\\\\\":{}}],\\\\\"event\\\\\":\\\\\"EV\\\\\",\\\\\"source\\\\\":\\\\\"#(machine)\\\\\",\\\\\"internal\\\\\":true,\\\\\"eventType\\\\\":\\\\\"EV\\\\\"}],\\\\\"children\\\\\":{},\\\\\"done\\\\\":false,\\\\\"tags\\\\\":{},\\\\\"changed\\\\\":true}\",\n          \"type\": \"service.state\",\n        },\n      ]\n    `);\n\n    // this is important because this moves the previous `state` to `state.history` (this was the case in v4)\n    // and serializing a `state` with a `state.history` containing unsafe value should still work\n    service.send({ type: 'UNKNOWN' });\n\n    expect(iframeMock.flushMessages()).toMatchInlineSnapshot(`\n      Array [\n        Object {\n          \"event\": \"{\\\\\"name\\\\\":\\\\\"UNKNOWN\\\\\",\\\\\"data\\\\\":{\\\\\"type\\\\\":\\\\\"UNKNOWN\\\\\"},\\\\\"$$type\\\\\":\\\\\"scxml\\\\\",\\\\\"type\\\\\":\\\\\"external\\\\\"}\",\n          \"sessionId\": \"x:9\",\n          \"type\": \"service.event\",\n        },\n        Object {\n          \"sessionId\": \"x:9\",\n          \"state\": \"{\\\\\"actions\\\\\":[],\\\\\"activities\\\\\":{},\\\\\"meta\\\\\":{},\\\\\"events\\\\\":[],\\\\\"value\\\\\":{},\\\\\"context\\\\\":{\\\\\"value\\\\\":{\\\\\"unsafe\\\\\":\\\\\"[unsafe]\\\\\"}},\\\\\"_event\\\\\":{\\\\\"name\\\\\":\\\\\"UNKNOWN\\\\\",\\\\\"data\\\\\":{\\\\\"type\\\\\":\\\\\"UNKNOWN\\\\\"},\\\\\"$$type\\\\\":\\\\\"scxml\\\\\",\\\\\"type\\\\\":\\\\\"external\\\\\"},\\\\\"_sessionid\\\\\":\\\\\"x:9\\\\\",\\\\\"event\\\\\":{\\\\\"type\\\\\":\\\\\"UNKNOWN\\\\\"},\\\\\"transitions\\\\\":[],\\\\\"children\\\\\":{},\\\\\"done\\\\\":false,\\\\\"tags\\\\\":{},\\\\\"changed\\\\\":false}\",\n          \"type\": \"service.state\",\n        },\n      ]\n    `);\n  });","file":"inspect.test.ts","skipped":false,"dir":"packages/xstate-inspect/test"},{"name":"should only send events once to the inspector after restarting a service","suites":["@xstate/inspect"],"updatePoint":{"line":313,"column":78},"line":313,"code":"  it('should only send events once to the inspector after restarting a service', () => {\n    const machine = createMachine({});\n\n    const devTools = createDevTools();\n    const iframeMock = createIframeMock();\n\n    inspect({\n      iframe: iframeMock.iframe,\n      devTools\n    });\n\n    iframeMock.initConnection();\n\n    const service = interpret(machine).start();\n    devTools.register(service);\n\n    service.stop();\n    service.start();\n    devTools.register(service);\n\n    iframeMock.flushMessages();\n\n    service.send({ type: 'EV' });\n\n    expect(\n      iframeMock\n        .flushMessages()\n        .filter((message: any) => message.type === 'service.event')\n    ).toHaveLength(1);\n  });","file":"inspect.test.ts","skipped":false,"dir":"packages/xstate-inspect/test"},{"name":"/","suites":["toSCXML"],"updatePoint":{"line":24,"column":38},"line":24,"code":"      it(`${testGroupName}/${testName}`, () => {\n        expect(xml2js(toSCXML(machine))).toEqual(\n          xml2js(scxmlDefinition, {\n            ignoreComment: true,\n            ignoreDeclaration: true\n          })\n        );\n      });","file":"fixtures.test.ts","skipped":false,"dir":"packages/xstate-scxml/test"},{"name":"/ (sanity)","suites":["scxml"],"updatePoint":{"line":116,"column":47},"line":116,"code":"      it(`${testGroupName}/${testName} (sanity)`, async () => {\n        await runTestToCompletion(originalMachine, scxmlTest);\n      });","file":"scxml.test.ts","skipped":false,"dir":"packages/xstate-scxml/test"},{"name":"/","suites":["scxml"],"updatePoint":{"line":120,"column":38},"line":120,"code":"      it(`${testGroupName}/${testName}`, async () => {\n        const machine = toMachine(scxmlDefinition, {\n          delimiter: '$'\n        });\n\n        await runTestToCompletion(machine, scxmlTest);\n      }, 2000);","file":"scxml.test.ts","skipped":false,"dir":"packages/xstate-scxml/test"},{"name":"converts a simple transition","suites":["scxml"],"updatePoint":{"line":236,"column":34},"line":236,"code":"  it('converts a simple transition', () => {\n    const transition = lightMachine.states.green.on.TIMER;\n\n    const scxml = transitionToSCXML(transition[0]);\n\n    expect(scxml).toEqual(\n      xml2js(`<transition event=\"TIMER\" target=\"light.yellow\" />`).elements[0]\n    );\n  });","file":"scxml.test.ts","skipped":false,"dir":"packages/xstate-scxml/test"},{"name":"converts a full transition","suites":["scxml"],"updatePoint":{"line":246,"column":32},"line":246,"code":"  it('converts a full transition', () => {\n    const machine = Machine({\n      initial: 'test',\n      states: {\n        test: {\n          id: 'test',\n          on: {\n            SOME_EVENT: {\n              target: 'next',\n              internal: true,\n              cond: () => true,\n              in: '#test',\n              actions: ['foo', 'bar']\n            }\n          }\n        },\n        next: {\n          id: 'next'\n        }\n      }\n    });\n\n    const scxml = transitionToSCXML(machine.states.test.on.SOME_EVENT[0]);\n\n    expect(scxml).toEqual(\n      xml2js(\n        `<transition event=\"SOME_EVENT\" target=\"next\" type=\"internal\" cond=\"${\n          scxml.attributes!.cond\n        }\" />`\n      ).elements[0]\n    );\n  });","file":"scxml.test.ts","skipped":false,"dir":"packages/xstate-scxml/test"},{"name":"should work with a component","suites":["useMachine function for fsm"],"updatePoint":{"line":5,"column":34},"line":5,"code":"  it('should work with a component', async () => {\n    const { getByText, getByTestId, findByText } = render(UseFsm);\n    const button = getByText('Fetch');\n    await fireEvent.click(button);\n    await findByText('Loading...');\n    await findByText(/Success/);\n    const dataEl = getByTestId('data');\n    expect(dataEl.textContent).toBe('some data');\n  });","file":"useFsm.test.ts","skipped":false,"dir":"packages/xstate-svelte/test"},{"name":"should work with a component","suites":["useMachine function"],"updatePoint":{"line":16,"column":34},"line":16,"code":"  it('should work with a component', async () => {\n    const { getByText, findByText, getByTestId } = render(UseMachine);\n    const button = getByText('Fetch');\n    await fireEvent.click(button);\n    await findByText('Loading...');\n    await findByText(/Success/);\n    const dataEl = getByTestId('data');\n    expect(dataEl.textContent).toBe('some data');\n  });","file":"useMachine.test.ts","skipped":false,"dir":"packages/xstate-svelte/test"},{"name":"should work with a component with rehydrated state","suites":["useMachine function"],"updatePoint":{"line":26,"column":56},"line":26,"code":"  it('should work with a component with rehydrated state', async () => {\n    const { findByText, getByTestId } = render(UseMachine, {\n      persistedState: persistedFetchState\n    });\n    await findByText(/Success/);\n    const dataEl = getByTestId('data');\n    expect(dataEl.textContent).toBe('persisted data');\n  });","file":"useMachine.test.ts","skipped":false,"dir":"packages/xstate-svelte/test"},{"name":"should work with a component with rehydrated state config","suites":["useMachine function"],"updatePoint":{"line":35,"column":63},"line":35,"code":"  it('should work with a component with rehydrated state config', async () => {\n    const { findByText, getByTestId } = render(UseMachine, {\n      persistedState: persistedFetchStateConfig\n    });\n    await findByText(/Success/);\n    const dataEl = getByTestId('data');\n    expect(dataEl.textContent).toBe('persisted data');\n  });","file":"useMachine.test.ts","skipped":false,"dir":"packages/xstate-svelte/test"},{"name":"only reassigns when selected values change","suites":["useSelector"],"updatePoint":{"line":6,"column":48},"line":6,"code":"  it('only reassigns when selected values change', async () => {\n    const { getByTestId } = render(UseSelector);\n    const countBtn = getByTestId('count');\n    const anotherBtn = getByTestId('another');\n    const withSelector = getByTestId('withSelector');\n    const withoutSelector = getByTestId('withoutSelector');\n\n    expect(withSelector.textContent).toBe('0');\n    expect(withoutSelector.textContent).toBe('0');\n\n    await fireEvent.click(countBtn);\n    expect(withSelector.textContent).toBe('1');\n    expect(withoutSelector.textContent).toBe('1');\n\n    await fireEvent.click(anotherBtn);\n    expect(withSelector.textContent).toBe('1');\n    expect(withoutSelector.textContent).toBe('2');\n  });","file":"useSelector.test.ts","skipped":false,"dir":"packages/xstate-svelte/test"},{"name":"should work with a custom comparison function","suites":["useSelector"],"updatePoint":{"line":25,"column":51},"line":25,"code":"  it('should work with a custom comparison function', async () => {\n    const { getByTestId } = render(UseSelectorCustomFn);\n\n    const nameEl = getByTestId('name');\n    const sendUpperButton = getByTestId('sendUpper');\n    const sendOtherButton = getByTestId('sendOther');\n\n    expect(nameEl.textContent).toEqual('david');\n\n    await fireEvent.click(sendUpperButton);\n\n    // unchanged due to comparison function\n    expect(nameEl.textContent).toEqual('david');\n\n    await fireEvent.click(sendOtherButton);\n\n    expect(nameEl.textContent).toEqual('other');\n\n    await fireEvent.click(sendUpperButton);\n\n    expect(nameEl.textContent).toEqual('DAVID');\n  });","file":"useSelector.test.ts","skipped":false,"dir":"packages/xstate-svelte/test"},{"name":"should throw if the target does not match the last entered state","suites":["testing a model (getPlanFromEvents)","reaches state  ()"],"updatePoint":{"line":215,"column":70},"line":215,"code":"  it('should throw if the target does not match the last entered state', () => {\n    expect(() => {\n      dieHardModel.getPlanFromEvents([{ type: 'FILL_5' }], {\n        target: 'success'\n      });\n    }).toThrow();\n  });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"reaches the target state","suites":["path.test()","reaches state  ()"],"updatePoint":{"line":235,"column":38},"line":235,"code":"          it(`reaches the target state`, () => {\n            const testJugs = new Jugs();\n            return path.test({ jugs: testJugs });\n          });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"should show an error path trace","suites":["error path trace","should return trace for failed state"],"updatePoint":{"line":274,"column":43},"line":274,"code":"        it('should show an error path trace', async () => {\n          try {\n            await path.test(undefined);\n          } catch (err) {\n            expect(err.message).toEqual(expect.stringContaining('test error'));\n            expect(stripAnsi(err.message)).toMatchSnapshot('error path trace');\n            return;\n          }\n\n          throw new Error('Should have failed');\n        });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"reports state node coverage","suites":["coverage"],"updatePoint":{"line":291,"column":33},"line":291,"code":"  it('reports state node coverage', () => {\n    const coverage = dieHardModel.getCoverage();\n\n    expect(coverage.stateNodes['dieHard.pending']).toBeGreaterThan(0);\n    expect(coverage.stateNodes['dieHard.success']).toBeGreaterThan(0);\n  });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"tests missing state node coverage","suites":["coverage"],"updatePoint":{"line":298,"column":39},"line":298,"code":"  it('tests missing state node coverage', async () => {\n    const machine = Machine({\n      id: 'missing',\n      initial: 'first',\n      states: {\n        first: {\n          on: { NEXT: 'third' },\n          meta: {\n            test: () => true\n          }\n        },\n        second: {\n          meta: {\n            test: () => true\n          }\n        },\n        third: {\n          initial: 'one',\n          states: {\n            one: {\n              meta: {\n                test: () => true\n              }\n            },\n            two: {\n              meta: {\n                test: () => true\n              }\n            },\n            three: {\n              meta: {\n                test: () => true\n              }\n            }\n          },\n          meta: {\n            test: () => true\n          }\n        }\n      }\n    });\n\n    const testModel = createModel(machine).withEvents({\n      NEXT: () => {\n        /* ... */\n      }\n    });\n    const plans = testModel.getShortestPathPlans();\n\n    for (const plan of plans) {\n      for (const path of plan.paths) {\n        await path.test(undefined);\n      }\n    }\n\n    try {\n      testModel.testCoverage();\n    } catch (err) {\n      expect(err.message).toEqual(expect.stringContaining('missing.second'));\n      expect(err.message).toEqual(expect.stringContaining('missing.third.two'));\n      expect(err.message).toEqual(\n        expect.stringContaining('missing.third.three')\n      );\n    }\n  });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"skips filtered states (filter option)","suites":["coverage"],"updatePoint":{"line":364,"column":43},"line":364,"code":"  it('skips filtered states (filter option)', async () => {\n    const TestBug = Machine({\n      id: 'testbug',\n      initial: 'idle',\n      context: {\n        retries: 0\n      },\n      states: {\n        idle: {\n          on: {\n            START: 'passthrough'\n          },\n          meta: {\n            test: () => {\n              /* ... */\n            }\n          }\n        },\n        passthrough: {\n          on: {\n            '': 'end'\n          }\n        },\n        end: {\n          type: 'final',\n          meta: {\n            test: () => {\n              /* ... */\n            }\n          }\n        }\n      }\n    });\n\n    const testModel = createModel(TestBug).withEvents({\n      START: () => {\n        /* ... */\n      }\n    });\n\n    const testPlans = testModel.getShortestPathPlans();\n\n    const promises: any[] = [];\n    testPlans.forEach((plan) => {\n      plan.paths.forEach(() => {\n        promises.push(plan.test(undefined));\n      });\n    });\n\n    await Promise.all(promises);\n\n    expect(() => {\n      testModel.testCoverage({\n        filter: (stateNode) => {\n          return !!stateNode.meta;\n        }\n      });\n    }).not.toThrow();\n  });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"should allow for representing many cases","suites":["events"],"updatePoint":{"line":426,"column":46},"line":426,"code":"  it('should allow for representing many cases', async () => {\n    type Events =\n      | { type: 'CLICK_BAD' }\n      | { type: 'CLICK_GOOD' }\n      | { type: 'CLOSE' }\n      | { type: 'ESC' }\n      | { type: 'SUBMIT'; value: string };\n    const feedbackMachine = Machine<void, Events>({\n      id: 'feedback',\n      initial: 'question',\n      states: {\n        question: {\n          on: {\n            CLICK_GOOD: 'thanks',\n            CLICK_BAD: 'form',\n            CLOSE: 'closed',\n            ESC: 'closed'\n          },\n          meta: {\n            test: () => {\n              // ...\n            }\n          }\n        },\n        form: {\n          on: {\n            SUBMIT: [\n              {\n                target: 'thanks',\n                cond: (_, e) => !!e.value.length\n              },\n              {\n                target: '.invalid'\n              }\n            ],\n            CLOSE: 'closed',\n            ESC: 'closed'\n          },\n          meta: {\n            test: () => {\n              // ...\n            }\n          },\n          initial: 'valid',\n          states: {\n            valid: {\n              meta: {\n                test: () => {\n                  // noop\n                }\n              }\n            },\n            invalid: {\n              meta: {\n                test: () => {\n                  // noop\n                }\n              }\n            }\n          }\n        },\n        thanks: {\n          on: {\n            CLOSE: 'closed',\n            ESC: 'closed'\n          },\n          meta: {\n            test: () => {\n              // ...\n            }\n          }\n        },\n        closed: {\n          type: 'final',\n          meta: {\n            test: () => {\n              // ...\n            }\n          }\n        }\n      }\n    });\n\n    const testModel = createModel(feedbackMachine).withEvents({\n      CLICK_BAD: () => {\n        /* ... */\n      },\n      CLICK_GOOD: () => {\n        /* ... */\n      },\n      CLOSE: () => {\n        /* ... */\n      },\n      SUBMIT: {\n        cases: [{ value: 'something' }, { value: '' }]\n      }\n    });\n\n    const testPlans = testModel.getShortestPathPlans();\n\n    for (const plan of testPlans) {\n      await plan.test(undefined);\n    }\n\n    return testModel.testCoverage();\n  });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"should not throw an error for unimplemented events","suites":["events"],"updatePoint":{"line":533,"column":56},"line":533,"code":"  it('should not throw an error for unimplemented events', () => {\n    const testMachine = Machine({\n      initial: 'idle',\n      states: {\n        idle: {\n          on: { ACTIVATE: 'active' }\n        },\n        active: {}\n      }\n    });\n\n    const testModel = createModel(testMachine);\n\n    const testPlans = testModel.getShortestPathPlans();\n\n    expect(async () => {\n      for (const plan of testPlans) {\n        await plan.test(undefined);\n      }\n    }).not.toThrow();\n  });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"should limit states with filter option","suites":["state limiting"],"updatePoint":{"line":557,"column":44},"line":557,"code":"  it('should limit states with filter option', () => {\n    const machine = Machine<{ count: number }>({\n      initial: 'counting',\n      context: { count: 0 },\n      states: {\n        counting: {\n          on: {\n            INC: {\n              actions: assign({\n                count: (ctx) => ctx.count + 1\n              })\n            }\n          }\n        }\n      }\n    });\n\n    const testModel = createModel(machine);\n    const testPlans = testModel.getShortestPathPlans({\n      filter: (state) => {\n        return state.context.count < 5;\n      }\n    });\n\n    expect(testPlans).toHaveLength(5);\n  });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"should give a description for every plan","suites":["plan description"],"updatePoint":{"line":638,"column":46},"line":638,"code":"  it('should give a description for every plan', () => {\n    const planDescriptions = testPlans.map((plan) => plan.description);\n\n    expect(planDescriptions).toMatchInlineSnapshot(`\n      Array [\n        \"reaches state: \\\\\"#test.atomic\\\\\" ({\\\\\"count\\\\\":0})\",\n        \"reaches state: \\\\\"#test.compound.child\\\\\" ({\\\\\"count\\\\\":0})\",\n        \"reaches state: \\\\\"#test.final\\\\\" ({\\\\\"count\\\\\":0})\",\n        \"reaches state: \\\\\"child with meta\\\\\" ({\\\\\"count\\\\\":0})\",\n        \"reaches states: \\\\\"#test.parallel.one\\\\\", \\\\\"two description\\\\\" ({\\\\\"count\\\\\":0})\",\n        \"reaches state: \\\\\"noMetaDescription\\\\\" ({\\\\\"count\\\\\":0})\",\n      ]\n    `);\n  });","file":"index.test.ts","skipped":false,"dir":"packages/xstate-test/test"},{"name":"initial invoked actor should be immediately available","suites":["useActor composable function"],"updatePoint":{"line":10,"column":59},"line":10,"code":"  it('initial invoked actor should be immediately available', async () => {\n    const { getByTestId } = render(UseActor);\n\n    const machineStateEl = getByTestId('machine-state');\n    const actorStateEl = getByTestId('actor-state');\n\n    expect(machineStateEl.textContent).toBe('active');\n    expect(actorStateEl.textContent).toBe('active');\n  });","file":"useActor.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"invoked actor in a standalone component should be able to receive events","suites":["useActor composable function"],"updatePoint":{"line":20,"column":78},"line":20,"code":"  it('invoked actor in a standalone component should be able to receive events', async () => {\n    const childMachine = createMachine({\n      id: 'childMachine',\n      initial: 'active',\n      states: {\n        active: {\n          on: {\n            FINISH: { actions: sendParent('FINISH') }\n          }\n        }\n      }\n    });\n    const machine = createMachine({\n      initial: 'active',\n      invoke: {\n        id: 'child',\n        src: childMachine\n      },\n      states: {\n        active: {\n          on: { FINISH: 'success' }\n        },\n        success: {}\n      }\n    });\n\n    const serviceMachine = interpret(machine).start();\n\n    const { getByTestId } = render(UseActorComponentProp, {\n      props: { actor: serviceMachine.state.children.child }\n    });\n\n    const actorStateEl = getByTestId('actor-state');\n    expect(actorStateEl.textContent).toBe('active');\n\n    await waitFor(() => expect(serviceMachine.state.value).toBe('success'));\n  });","file":"useActor.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"actor should provide snapshot value immediately","suites":["useActor composable function"],"updatePoint":{"line":58,"column":53},"line":58,"code":"  it('actor should provide snapshot value immediately', () => {\n    const { getByTestId } = render(UseActorSimple);\n\n    const stateEl = getByTestId('state');\n    expect(stateEl.textContent).toEqual('42');\n  });","file":"useActor.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"should update snapshot value when actor changes","suites":["useActor composable function"],"updatePoint":{"line":65,"column":53},"line":65,"code":"  it('should update snapshot value when actor changes', async () => {\n    const { getByTestId } = render(UseActorCreateSimple);\n\n    const stateEl = getByTestId('state');\n    const button = getByTestId('button');\n\n    expect(stateEl.textContent).toEqual('42');\n    await fireEvent.click(button);\n    expect(stateEl.textContent).toEqual('100');\n  });","file":"useActor.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"should work ","suites":["UseFSM composable function"],"updatePoint":{"line":5,"column":18},"line":5,"code":"  it('should work ', async () => {\n    const { getByText, getByTestId } = render(UseFSM as any);\n    const button = getByText('Fetch');\n    fireEvent.click(button);\n    await waitFor(() => getByText('Loading...'));\n    await waitFor(() => getByText(/Success/));\n    const dataEl = getByTestId('data');\n    expect(dataEl.textContent).toBe('some data');\n  });","file":"useFSM.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"observer should be called with initial state","suites":["useInterpret composable function"],"updatePoint":{"line":5,"column":50},"line":5,"code":"  it('observer should be called with initial state', async () => {\n    const { getByTestId } = render(UseInterpret);\n\n    const buttonEl = getByTestId('button');\n    await waitFor(() => expect(buttonEl.textContent).toBe('Turn on'));\n  });","file":"useInterpret.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"observer should be called with next state","suites":["useInterpret composable function"],"updatePoint":{"line":12,"column":47},"line":12,"code":"  it('observer should be called with next state', async () => {\n    const { getByTestId } = render(UseInterpret);\n\n    const buttonEl = getByTestId('button');\n\n    await waitFor(() => expect(buttonEl.textContent).toBe('Turn on'));\n    await fireEvent.click(buttonEl);\n    await waitFor(() => expect(buttonEl.textContent).toBe('Turn off'));\n  });","file":"useInterpret.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"should work with a component ","suites":["useMachine composition function"],"updatePoint":{"line":41,"column":35},"line":41,"code":"  it('should work with a component ', async () => {\n    const { getByText, getByTestId } = render(UseMachine as any);\n    const button = getByText('Fetch');\n    fireEvent.click(button);\n    await waitFor(() => getByText('Loading...'));\n    await waitFor(() => getByText(/Success/));\n    const dataEl = getByTestId('data');\n    expect(dataEl.textContent).toBe('some data');\n  });","file":"useMachine.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"should work with a component with rehydrated state","suites":["useMachine composition function"],"updatePoint":{"line":51,"column":56},"line":51,"code":"  it('should work with a component with rehydrated state', async () => {\n    const { getByText, getByTestId } = render(UseMachine as any, {\n      props: { persistedState: persistedFetchState }\n    });\n    await waitFor(() => getByText(/Success/));\n    const dataEl = getByTestId('data');\n    expect(dataEl.textContent).toBe('persisted data');\n  });","file":"useMachine.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"should work with a component with rehydrated state config","suites":["useMachine composition function"],"updatePoint":{"line":60,"column":63},"line":60,"code":"  it('should work with a component with rehydrated state config', async () => {\n    const persistedFetchStateConfig = JSON.parse(\n      JSON.stringify(persistedFetchState)\n    );\n    const { getByText, getByTestId } = render(UseMachine as any, {\n      props: { persistedState: persistedFetchStateConfig }\n    });\n    await waitFor(() => getByText(/Success/));\n    const dataEl = getByTestId('data');\n    expect(dataEl.textContent).toBe('persisted data');\n  });","file":"useMachine.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"should not crash without optional `options` parameter being provided","suites":["useMachine composition function"],"updatePoint":{"line":72,"column":74},"line":72,"code":"  it('should not crash without optional `options` parameter being provided', async () => {\n    expect(() => {\n      render(UseMachineNoExtraOptions as any);\n    }).not.toThrow();\n  });","file":"useMachine.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"only rerenders for selected values","suites":["useSelector"],"updatePoint":{"line":6,"column":40},"line":6,"code":"  it('only rerenders for selected values', async () => {\n    const { getByTestId, emitted } = render(UseSelector);\n\n    const countButton = getByTestId('count');\n    const otherButton = getByTestId('other');\n    const incrementEl = getByTestId('increment');\n\n    await fireEvent.click(incrementEl);\n    expect(countButton.textContent).toBe('1');\n\n    await fireEvent.click(otherButton);\n    await fireEvent.click(otherButton);\n    await fireEvent.click(otherButton);\n    await fireEvent.click(otherButton);\n\n    await fireEvent.click(incrementEl);\n    expect(countButton.textContent).toBe('2');\n\n    expect((emitted() as any).rerender.length).toBe(3);\n  });","file":"useSelector.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"should work with a custom comparison function","suites":["useSelector"],"updatePoint":{"line":27,"column":51},"line":27,"code":"  it('should work with a custom comparison function', async () => {\n    const { getByTestId } = render(useSelectorCustomFn);\n\n    const nameEl = getByTestId('name');\n    const sendUpperButton = getByTestId('sendUpper');\n    const sendOtherButton = getByTestId('sendOther');\n\n    expect(nameEl.textContent).toEqual('david');\n\n    await fireEvent.click(sendUpperButton);\n\n    // unchanged due to comparison function\n    expect(nameEl.textContent).toEqual('david');\n\n    await fireEvent.click(sendOtherButton);\n\n    expect(nameEl.textContent).toEqual('other');\n\n    await fireEvent.click(sendUpperButton);\n\n    expect(nameEl.textContent).toEqual('DAVID');\n  });","file":"useSelector.test.ts","skipped":false,"dir":"packages/xstate-vue/test"},{"name":"should be able to spawn an actor from a behavior","suites":["useSpawn"],"updatePoint":{"line":5,"column":54},"line":5,"code":"  it('should be able to spawn an actor from a behavior', async () => {\n    const { getByTestId } = render(UseSpawn);\n    const button = getByTestId('count');\n\n    expect(button.textContent).toEqual('0');\n\n    await fireEvent.click(button);\n\n    expect(button.textContent).toEqual('1');\n  });","file":"useSpawn.test.ts","skipped":false,"dir":"packages/xstate-vue/test"}]}