{"repo":"remix-run/remix","url":"https://github.com/remix-run/remix","branch":"main","configs":[{"package":"create-remix","lang":"ts","dir":"packages/create-remix/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/architect","lang":"ts","dir":"packages/remix-architect/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/dev","lang":"ts","dir":"packages/remix-dev/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/express","lang":"ts","dir":"packages/remix-express/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/netlify","lang":"ts","dir":"packages/remix-netlify/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/node","lang":"ts","dir":"packages/remix-node/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/react","lang":"js","dir":"packages/remix-react/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@remix-run/server-runtime","lang":"ts","dir":"packages/remix-server-runtime/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/vercel","lang":"ts","dir":"packages/remix-vercel/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"handles requests","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":88,"column":24},"line":88,"code":"    it(\"handles requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"/foo/bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: /foo/bar\");\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles null body","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":104,"column":25},"line":104,"code":"    it(\"handles null body\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 200 });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"/foo/bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles status codes","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":119,"column":28},"line":119,"code":"    it(\"handles status codes\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 204 });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"/foo/bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(204);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"sets headers","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":134,"column":20},"line":134,"code":"    it(\"sets headers\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let headers = new Headers();\n        headers.append(\"X-Time-Of-Year\", \"most wonderful\");\n        headers.append(\n          \"Set-Cookie\",\n          \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n\n        return new Response(null, { headers });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"/\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.headers[\"x-time-of-year\"]).toBe(\"most wonderful\");\n          expect(res.cookies).toEqual([\n            \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\",\n            \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\",\n            \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\",\n          ]);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles empty headers","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":174,"column":29},"line":174,"code":"    it(\"handles empty headers\", () => {\n      expect(createRemixHeaders({}, undefined)).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles simple headers","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":183,"column":30},"line":183,"code":"    it(\"handles simple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar\" }, undefined))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles multiple headers","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":196,"column":32},"line":196,"code":"    it(\"handles multiple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar\", \"x-bar\": \"baz\" }, undefined))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n            \"x-bar\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles headers with multiple values","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":211,"column":44},"line":211,"code":"    it(\"handles headers with multiple values\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar, baz\" }, undefined))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar, baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles headers with multiple values and multiple headers","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":224,"column":65},"line":224,"code":"    it(\"handles headers with multiple values and multiple headers\", () => {\n      expect(\n        createRemixHeaders({ \"x-foo\": \"bar, baz\", \"x-bar\": \"baz\" }, undefined)\n      ).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar, baz\",\n            \"x-bar\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles cookies","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":240,"column":23},"line":240,"code":"    it(\"handles cookies\", () => {\n      expect(\n        createRemixHeaders({ \"x-something-else\": \"true\" }, [\n          \"__session=some_value\",\n          \"__other=some_other_value\",\n        ])\n      ).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-something-else\",\n            \"true\",\n            \"cookie\",\n            \"__session=some_value; __other=some_other_value\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"creates a request with the correct headers","suites":["architect createRemixRequest"],"updatePoint":{"line":262,"column":48},"line":262,"code":"  it(\"creates a request with the correct headers\", () => {\n    expect(\n      createRemixRequest(\n        createMockEvent({\n          cookies: [\"__session=value\"],\n        })\n      )\n    ).toMatchInlineSnapshot(`\n      NodeRequest {\n        \"agent\": undefined,\n        \"compress\": true,\n        \"counter\": 0,\n        \"follow\": 20,\n        \"highWaterMark\": 16384,\n        \"insecureHTTPParser\": false,\n        \"size\": 0,\n        Symbol(Body internals): Object {\n          \"body\": null,\n          \"boundary\": null,\n          \"disturbed\": false,\n          \"error\": null,\n          \"size\": 0,\n          \"type\": null,\n        },\n        Symbol(Request internals): Object {\n          \"credentials\": \"same-origin\",\n          \"headers\": Headers {\n            Symbol(query): Array [\n              \"accept\",\n              \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n              \"accept-encoding\",\n              \"gzip, deflate\",\n              \"accept-language\",\n              \"en-US,en;q=0.9\",\n              \"cookie\",\n              \"__session=value\",\n              \"host\",\n              \"localhost:3333\",\n              \"upgrade-insecure-requests\",\n              \"1\",\n              \"user-agent\",\n              \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15\",\n            ],\n            Symbol(context): null,\n          },\n          \"method\": \"GET\",\n          \"parsedURL\": \"https://localhost:3333/\",\n          \"redirect\": \"follow\",\n          \"signal\": AbortSignal {},\n        },\n      }\n    `);\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles regular responses","suites":["sendRemixResponse"],"updatePoint":{"line":318,"column":31},"line":318,"code":"  it(\"handles regular responses\", async () => {\n    let response = new NodeResponse(\"anything\");\n    let result = await sendRemixResponse(response);\n    expect(result.body).toBe(\"anything\");\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles resource routes with regular data","suites":["sendRemixResponse"],"updatePoint":{"line":324,"column":47},"line":324,"code":"  it(\"handles resource routes with regular data\", async () => {\n    let json = JSON.stringify({ foo: \"bar\" });\n    let response = new NodeResponse(json, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"content-length\": json.length.toString(),\n      },\n    });\n\n    let result = await sendRemixResponse(response);\n\n    expect(result.body).toMatch(json);\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles resource routes with binary data","suites":["sendRemixResponse"],"updatePoint":{"line":338,"column":46},"line":338,"code":"  it(\"handles resource routes with binary data\", async () => {\n    let image = await fsp.readFile(path.join(__dirname, \"554828.jpeg\"));\n\n    let response = new NodeResponse(image, {\n      headers: {\n        \"content-type\": \"image/jpeg\",\n        \"content-length\": image.length.toString(),\n      },\n    });\n\n    let result = await sendRemixResponse(response);\n\n    expect(result.body).toMatch(image.toString(\"base64\"));\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"prints help info","suites":["remix CLI","the --help flag"],"updatePoint":{"line":89,"column":24},"line":89,"code":"    it(\"prints help info\", async () => {\n      let { stdout } = await execRemix([\"--help\"]);\n      expect(stdout.trim()).toMatchInlineSnapshot(`\n        \"R E M I X\n\n          Usage:\n            $ remix create <projectDir> --template <template>\n            $ remix init [projectDir]\n            $ remix build [projectDir]\n            $ remix dev [projectDir]\n            $ remix routes [projectDir]\n            $ remix watch [projectDir]\n            $ remix setup [remixPlatform]\n            $ remix codemod <codemod> [projectDir]\n\n          Options:\n            --help, -h          Print this help message and exit\n            --version, -v       Print the CLI version and exit\n            --no-color          Disable ANSI colors in console output\n          \\`create\\` Options:\n            --template          The template to use\n            --no-install        Skip installing dependencies after creation\n            --no-typescript     Convert the template to JavaScript\n            --remix-version     The version of Remix to use\n          \\`build\\` Options:\n            --sourcemap         Generate source maps for production\n          \\`dev\\` Options:\n            --debug             Attach Node.js inspector\n            --port, -p          Choose the port from which to run your app\n          \\`init\\` Options:\n            --no-delete         Skip deleting the \\`remix.init\\` script\n          \\`routes\\` Options:\n            --json              Print the routes as JSON\n          \\`codemod\\` Options:\n            --dry               Dry run (no changes are made to files)\n            --force             Bypass Git safety checks\n\n          Values:\n            - projectDir        The Remix project directory\n            - template          The project template to use\n            - remixPlatform     \\`node\\` or \\`cloudflare\\`\n\n          Creating a new project:\n\n            Remix projects are created from templates. A template can be:\n\n            - a file path to a directory of files\n            - a file path to a tarball\n            - the name of a :username/:repo on GitHub\n            - the URL of a tarball\n\n            $ remix create my-app --template /path/to/remix-template\n            $ remix create my-app --template /path/to/remix-template.tar.gz\n            $ remix create my-app --template remix-run/grunge-stack\n            $ remix create my-app --template :username/:repo\n            $ remix create my-app --template https://github.com/:username/:repo\n            $ remix create my-app --template https://github.com/:username/:repo/tree/:branch\n            $ remix create my-app --template https://github.com/:username/:repo/archive/refs/tags/:tag.tar.gz\n            $ remix create my-app --template https://example.com/remix-template.tar.gz\n\n            To create a new project from a template in a private GitHub repo,\n            pass the \\`token\\` flag with a personal access token with access to that repo.\n\n          Initialize a project::\n\n            Remix project templates may contain a \\`remix.init\\` directory\n            with a script that initializes the project. This script automatically\n            runs during \\`remix create\\`, but if you ever need to run it manually\n            (e.g. to test it out) you can:\n\n            $ remix init\n\n          Build your project:\n\n            $ remix build\n            $ remix build --sourcemap\n            $ remix build my-app\n\n          Run your project locally in development:\n\n            $ remix dev\n            $ remix dev my-app\n            $ remix dev --debug\n\n          Start your server separately and watch for changes:\n\n            # custom server start command, for example:\n            $ remix watch\n\n            # in a separate tab:\n            $ node --inspect --require ./node_modules/dotenv/config --require ./mocks ./build/server.js\n\n          Show all routes in your app:\n\n            $ remix routes\n            $ remix routes my-app\n            $ remix routes --json\"\n      `);\n    });","file":"cli-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"prints the current version","suites":["remix CLI","the --version flag"],"updatePoint":{"line":191,"column":34},"line":191,"code":"    it(\"prints the current version\", async () => {\n      let { stdout } = await execRemix([\"--version\"]);\n      expect(!!semver.valid(stdout.trim())).toBe(true);\n    });","file":"cli-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows you to go through the prompts","suites":["remix CLI","create prompts"],"updatePoint":{"line":198,"column":44},"line":198,"code":"    it(\"allows you to go through the prompts\", async () => {\n      let projectDir = path.join(TEMP_DIR, \"my-app\");\n\n      let proc = childProcess.spawn(\n        \"node\",\n        [\n          \"--require\",\n          require.resolve(\"esbuild-register\"),\n          \"--require\",\n          path.join(__dirname, \"./msw.ts\"),\n          path.resolve(__dirname, \"../cli.ts\"),\n          \"create\",\n        ],\n        { stdio: [null, null, null] }\n      );\n\n      await interactWithShell(proc, [\n        { question: /Where.*create.*app/i, type: [projectDir, ENTER] },\n        { question: /What type of app/i, answer: /basics/i },\n        { question: /Where.*deploy/i, answer: /express/i },\n        { question: /typescript or javascript/i, answer: /typescript/i },\n        { question: /install/i, type: [\"n\", ENTER] },\n      ]);\n    });","file":"cli-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows you to go through the prompts and convert to JS","suites":["remix CLI","create prompts"],"updatePoint":{"line":223,"column":62},"line":223,"code":"    it(\"allows you to go through the prompts and convert to JS\", async () => {\n      let projectDir = path.join(TEMP_DIR, \"my-js-app\");\n\n      let proc = childProcess.spawn(\n        \"node\",\n        [\n          \"--require\",\n          require.resolve(\"esbuild-register\"),\n          \"--require\",\n          path.join(__dirname, \"./msw.ts\"),\n          path.resolve(__dirname, \"../cli.ts\"),\n          \"create\",\n        ],\n        { stdio: [null, null, null] }\n      );\n\n      await interactWithShell(proc, [\n        { question: /Where.*create.*app/i, type: [projectDir, ENTER] },\n        { question: /What type of app/i, answer: /basics/i },\n        { question: /Where.*deploy/i, answer: /express/i },\n        { question: /typescript or javascript/i, answer: /javascript/i },\n        { question: /install/i, type: [\"n\", ENTER] },\n      ]);\n\n      expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeFalsy();\n      expect(\n        fse.existsSync(path.join(projectDir, \"app/root.jsx\"))\n      ).toBeTruthy();\n      expect(\n        fse.existsSync(path.join(projectDir, \"tsconfig.json\"))\n      ).toBeFalsy();\n      expect(\n        fse.existsSync(path.join(projectDir, \"jsconfig.json\"))\n      ).toBeTruthy();\n    });","file":"cli-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces `remix` magic imports","suites":[],"updatePoint":{"line":17,"column":34},"line":17,"code":"it(\"replaces `remix` magic imports\", async () => {\n  await withApp(FIXTURE, async (projectDir) => {\n    await git.initialCommit(projectDir);\n    let result = await cli.run([\"codemod\", CODEMOD, projectDir]);\n    let stderr = stripAnsi(result.stderr);\n    expect(result.exitCode).toBe(0);\n\n    let successes = [\n      `✔ Found codemod: ${CODEMOD}`,\n      \"✔ No Remix server adapter detected\",\n      \"✔ Detected Remix server runtime: node\",\n      \"✔ Removed magic `remix` package from dependencies\",\n      \"✔ Removed `remix setup` from postinstall script\",\n      \"✔ Replaced magic `remix` imports | 24/24 files\",\n    ];\n    for (let success of successes) {\n      expect(stderr).toContain(success);\n    }\n\n    expect(result.stdout).toContain(\n      \"👉 To update your lockfile, run `yarn install`\"\n    );\n\n    let pkg = await NpmCliPackageJson.load(projectDir);\n    let packageJson = pkg.content;\n\n    // check that `remix` dependency was removed\n    expect(packageJson.dependencies).not.toContain(\"remix\");\n    expect(packageJson.devDependencies).not.toContain(\"remix\");\n\n    // check that Remix packages were standardized\n    expect(packageJson.dependencies).toEqual(\n      expect.objectContaining({\n        \"@remix-run/node\": \"1.3.4\",\n        \"@remix-run/react\": \"1.3.4\",\n        \"@remix-run/serve\": \"1.3.4\",\n      })\n    );\n    expect(packageJson.devDependencies).toEqual(\n      expect.objectContaining({\n        \"@remix-run/dev\": \"1.3.4\",\n      })\n    );\n\n    // check that postinstall was removed\n    expect(packageJson.scripts).not.toContain(\"postinstall\");\n\n    // check that `from \"remix\"` magic imports were removed\n    let config = await readConfig(projectDir);\n    let files = await glob(\"**/*.{js,jsx,ts,tsx}\", {\n      cwd: config.appDirectory,\n      absolute: true,\n    });\n    let remixMagicImports = shell.grep(\"-l\", /from ('remix'|\"remix\")/, files);\n    expect(remixMagicImports.code).toBe(0);\n    expect(remixMagicImports.stdout.trim()).toBe(\"\");\n    expect(remixMagicImports.stderr).toBeNull();\n\n    // check that imports look good for a specific file\n    let loginRoute = eol.normalize(\n      fs.readFileSync(path.join(projectDir, \"app/routes/login.tsx\"), \"utf8\")\n    );\n    expect(loginRoute).toContain(\n      [\n        \"import {\",\n        \"  type ActionFunction,\",\n        \"  type LoaderFunction,\",\n        \"  type MetaFunction,\",\n        \"  json,\",\n        \"  redirect,\",\n        '} from \"@remix-run/node\";',\n        'import { Form, Link, useActionData, useSearchParams } from \"@remix-run/react\";',\n      ].join(\"\\n\")\n    );\n  });\n});","file":"codemod-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"checks that project is a clean git repository","suites":[],"updatePoint":{"line":10,"column":49},"line":10,"code":"it(\"checks that project is a clean git repository\", async () => {\n  await withApp(FIXTURE, async (projectDir) => {\n    // ensure project is a git repository\n    let error1 = await cli.shouldError([\n      \"codemod\",\n      \"some-codemod-name\",\n      projectDir,\n    ]);\n    expect(error1.exitCode).not.toBe(0);\n    expect(error1.stderr).toContain(`${projectDir} is not a git repository`);\n    expect(error1.stdout).toContain(\n      \"To override this safety check, use the --force flag\"\n    );\n\n    // initialize git repo in project\n    await git.initialCommit(projectDir);\n\n    // make some uncommitted changes\n    fs.appendFileSync(path.join(projectDir, \"package.json\"), \"change\");\n\n    // ensure project has no uncommitted changes\n    let error2 = await cli.shouldError([\n      \"codemod\",\n      \"some-codemod-name\",\n      projectDir,\n    ]);\n    expect(error2.exitCode).not.toBe(0);\n    expect(error2.stderr).toContain(`${projectDir} has uncommitted changes`);\n    expect(error2.stdout).toContain(\n      \"Stash or commit your changes before running codemods\"\n    );\n    expect(error2.stdout).toContain(\n      \"To override this safety check, use the --force flag\"\n    );\n  });\n});","file":"codemod-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"checks that the specified codemod exists","suites":[],"updatePoint":{"line":47,"column":44},"line":47,"code":"it(\"checks that the specified codemod exists\", async () => {\n  await withApp(FIXTURE, async (projectDir) => {\n    await git.initialCommit(projectDir);\n\n    let codemodName = \"invalid-codemod-name\";\n    let error = await cli.shouldError([\"codemod\", codemodName, projectDir]);\n    expect(error.exitCode).toBe(1);\n    expect(error.stderr).toContain(`Unrecognized codemod: ${codemodName}`);\n  });\n});","file":"codemod-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for examples in the examples repo","suites":["the create command"],"updatePoint":{"line":134,"column":45},"line":134,"code":"  it(\"works for examples in the examples repo\", async () => {\n    let projectDir = await getProjectDir(\"example\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"examples/basic\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getSuccessMessage(path.join(\"<TEMP_DIR>\", \"example\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for templates in the remix org","suites":["the create command"],"updatePoint":{"line":151,"column":42},"line":151,"code":"  it(\"works for templates in the remix org\", async () => {\n    let projectDir = await getProjectDir(\"template\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"grunge-stack\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"template\"))\n    );\n\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for GitHub username/repo combo","suites":["the create command"],"updatePoint":{"line":172,"column":42},"line":172,"code":"  it(\"works for GitHub username/repo combo\", async () => {\n    let projectDir = await getProjectDir(\"repo\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"remix-fake-tester-username/remix-fake-tester-repo\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"repo\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"fails for private GitHub username/repo combo without a token","suites":["the create command"],"updatePoint":{"line":191,"column":66},"line":191,"code":"  it(\"fails for private GitHub username/repo combo without a token\", async () => {\n    let projectDir = await getProjectDir(\"repo\");\n    await expect(() =>\n      run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        \"private-org/private-repo\",\n        \"--no-install\",\n        \"--typescript\",\n      ])\n    ).rejects.toMatchInlineSnapshot(\n      `[Error: 🚨 The template could not be verified. Please double check that the template is a valid GitHub repository and try again.]`\n    );\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"succeeds for private GitHub username/repo combo with a valid token","suites":["the create command"],"updatePoint":{"line":207,"column":72},"line":207,"code":"  it(\"succeeds for private GitHub username/repo combo with a valid token\", async () => {\n    let projectDir = await getProjectDir(\"repo\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"private-org/private-repo\",\n      \"--no-install\",\n      \"--typescript\",\n      \"--token\",\n      \"valid-token\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"repo\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for remote tarballs","suites":["the create command"],"updatePoint":{"line":228,"column":31},"line":228,"code":"  it(\"works for remote tarballs\", async () => {\n    let projectDir = await getProjectDir(\"remote-tarball\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"https://example.com/remix-stack.tar.gz\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"remote-tarball\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"fails for private github release tarballs","suites":["the create command"],"updatePoint":{"line":247,"column":47},"line":247,"code":"  it(\"fails for private github release tarballs\", async () => {\n    let projectDir = await getProjectDir(\"private-release-tarball\");\n    await expect(() =>\n      run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        \"https://github.com/private-org/private-repo/releases/download/v0.0.1/stack.tar.gz\",\n        \"--no-install\",\n        \"--typescript\",\n      ])\n    ).rejects.toMatchInlineSnapshot(\n      `[Error: 🚨 The template file could not be verified. Please double check the URL and try again.]`\n    );\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"succeeds for private github release tarballs when including token","suites":["the create command"],"updatePoint":{"line":263,"column":71},"line":263,"code":"  it(\"succeeds for private github release tarballs when including token\", async () => {\n    let projectDir = await getProjectDir(\"private-release-tarball-with-token\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"https://github.com/private-org/private-repo/releases/download/v0.0.1/stack.tar.gz\",\n      \"--no-install\",\n      \"--typescript\",\n      \"--token\",\n      \"valid-token\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(\n          path.join(\"<TEMP_DIR>\", \"private-release-tarball-with-token\")\n        )\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for different branches","suites":["the create command"],"updatePoint":{"line":286,"column":34},"line":286,"code":"  it(\"works for different branches\", async () => {\n    let projectDir = await getProjectDir(\"diff-branch\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"https://github.com/fake-remix-tester/nested-dir/tree/dev/stack\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"diff-branch\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for a path to a tarball on disk","suites":["the create command"],"updatePoint":{"line":305,"column":43},"line":305,"code":"  it(\"works for a path to a tarball on disk\", async () => {\n    let projectDir = await getProjectDir(\"local-tarball\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"arc.tar.gz\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getSuccessMessage(path.join(\"<TEMP_DIR>\", \"local-tarball\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for a file URL to a tarball on disk","suites":["the create command"],"updatePoint":{"line":322,"column":47},"line":322,"code":"  it(\"works for a file URL to a tarball on disk\", async () => {\n    let projectDir = await getProjectDir(\"file-url-tarball\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      pathToFileURL(path.join(__dirname, \"fixtures\", \"arc.tar.gz\")).toString(),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getSuccessMessage(path.join(\"<TEMP_DIR>\", \"file-url-tarball\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"converts a template to JavaScript","suites":["the create command"],"updatePoint":{"line":339,"column":39},"line":339,"code":"  it(\"converts a template to JavaScript\", async () => {\n    let projectDir = await getProjectDir(\"template-to-js\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"blues-stack\",\n      \"--no-install\",\n      \"--no-typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"template-to-js\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeFalsy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.jsx\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"tsconfig.json\"))).toBeFalsy();\n    expect(fse.existsSync(path.join(projectDir, \"jsconfig.json\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for a file path to a directory on disk","suites":["the create command"],"updatePoint":{"line":360,"column":50},"line":360,"code":"  it(\"works for a file path to a directory on disk\", async () => {\n    let projectDir = await getProjectDir(\"local-directory\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures/stack\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"local-directory\"))\n    );\n\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for a file URL to a directory on disk","suites":["the create command"],"updatePoint":{"line":380,"column":49},"line":380,"code":"  it(\"works for a file URL to a directory on disk\", async () => {\n    let projectDir = await getProjectDir(\"file-url-directory\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      pathToFileURL(path.join(__dirname, \"fixtures/stack\")).toString(),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"file-url-directory\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"prioritizes built-in templates when validating input","suites":["the create command"],"updatePoint":{"line":399,"column":58},"line":399,"code":"  it(\"prioritizes built-in templates when validating input\", async () => {\n    let projectDir = await getProjectDir(\"built-in-template\");\n\n    // create a local directory in our cwd with the same name as our chosen\n    // template and give it a package.json so we can check it against the one in\n    // our template\n    let dupedDir = path.join(process.cwd(), \"express\");\n    await fse.mkdir(dupedDir);\n    await fse.writeFile(\n      path.join(dupedDir, \"package.json\"),\n      '{ \"name\": \"dummy\" }'\n    );\n\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"express\",\n      \"--install\",\n      \"--typescript\",\n    ]);\n\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    let pkgJSON = JSON.parse(\n      fse.readFileSync(path.join(projectDir, \"package.json\"), \"utf-8\")\n    );\n    expect(pkgJSON.name).not.toBe(\"dummy\");\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"runs remix.init script when installing dependencies","suites":["the create command"],"updatePoint":{"line":428,"column":57},"line":428,"code":"  it(\"runs remix.init script when installing dependencies\", async () => {\n    let projectDir = await getProjectDir(\"remix-init-auto\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      \"💿 Running remix.init script\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"remix-init-auto\"))\n    );\n    expect(output).toContain(`💿 Running remix.init script`);\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"test.txt\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeFalsy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"runs remix.init script when using index.ts","suites":["the create command"],"updatePoint":{"line":449,"column":48},"line":449,"code":"  it(\"runs remix.init script when using index.ts\", async () => {\n    let projectDir = await getProjectDir(\"remix-init-ts\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"stack-init-ts.tar.gz\"),\n      \"--install\",\n      \"--typescript\",\n    ]);\n    expect(output).toContain(\n      `Running init script on ${projectDir.replace(TEMP_DIR, \"<TEMP_DIR>\")}`\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeFalsy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"runs remix.init script when using `remix init`","suites":["the create command"],"updatePoint":{"line":467,"column":52},"line":467,"code":"  it(\"runs remix.init script when using `remix init`\", async () => {\n    let projectDir = await getProjectDir(\"remix-init-manual\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"remix-init-manual\"))\n    );\n\n    output = \"\";\n    process.chdir(projectDir);\n    await run([\"init\"]);\n\n    expect(output).toBe(\"\");\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"test.txt\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeFalsy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"It keeps the `remix.init` script when using the `--no-delete` flag","suites":["the create command"],"updatePoint":{"line":494,"column":72},"line":494,"code":"  it(\"It keeps the `remix.init` script when using the `--no-delete` flag\", async () => {\n    let projectDir = await getProjectDir(\"remix-init-manual\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"remix-init-manual\"))\n    );\n\n    output = \"\";\n    process.chdir(projectDir);\n    await run([\"init\", \"--no-delete\"]);\n\n    expect(output).toBe(\"\");\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"throws an error when invalid remix.init script when automatically ran","suites":["the create command"],"updatePoint":{"line":518,"column":75},"line":518,"code":"  it(\"throws an error when invalid remix.init script when automatically ran\", async () => {\n    let projectDir = await getProjectDir(\"invalid-remix-init-manual\");\n    await expect(\n      run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        path.join(__dirname, \"fixtures\", \"failing-remix-init.tar.gz\"),\n        \"--install\",\n        \"--typescript\",\n      ])\n    ).rejects.toThrowError(`🚨 Oops, remix.init failed`);\n\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    // we should keep remix.init around if the init script fails\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"throws an error when invalid remix.init script when manually ran","suites":["the create command"],"updatePoint":{"line":537,"column":70},"line":537,"code":"  it(\"throws an error when invalid remix.init script when manually ran\", async () => {\n    let projectDir = await getProjectDir(\"invalid-remix-init-manual\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"failing-remix-init.tar.gz\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"invalid-remix-init-manual\"))\n    );\n\n    process.chdir(projectDir);\n    await expect(run([\"init\"])).rejects.toThrowError(\n      `🚨 Oops, remix.init failed`\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    // we should keep remix.init around if the init script fails\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"recognizes when Yarn was used to run the command","suites":["the create command"],"updatePoint":{"line":563,"column":54},"line":563,"code":"  it(\"recognizes when Yarn was used to run the command\", async () => {\n    let originalUserAgent = process.env.npm_config_user_agent;\n    process.env.npm_config_user_agent = yarnUserAgent;\n\n    let projectDir = await getProjectDir(\"yarn-create\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--install\",\n      \"--typescript\",\n    ]);\n\n    expect(execSync).toBeCalledWith(\"yarn install\", expect.anything());\n    process.env.npm_config_user_agent = originalUserAgent;\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"recognizes when pnpm was used to run the command","suites":["the create command"],"updatePoint":{"line":581,"column":54},"line":581,"code":"  it(\"recognizes when pnpm was used to run the command\", async () => {\n    let originalUserAgent = process.env.npm_config_user_agent;\n    process.env.npm_config_user_agent = pnpmUserAgent;\n\n    let projectDir = await getProjectDir(\"pnpm-create\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--install\",\n      \"--typescript\",\n    ]);\n\n    expect(execSync).toBeCalledWith(\"pnpm install\", expect.anything());\n    process.env.npm_config_user_agent = originalUserAgent;\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"prompts to run the install command for the preferred package manager","suites":["the create command"],"updatePoint":{"line":599,"column":74},"line":599,"code":"  it(\"prompts to run the install command for the preferred package manager\", async () => {\n    let originalUserAgent = process.env.npm_config_user_agent;\n    process.env.npm_config_user_agent = pnpmUserAgent;\n\n    let projectDir = await getProjectDir(\"pnpm-prompt-install\");\n    let mockPrompt = jest.mocked(inquirer.prompt);\n    mockPrompt.mockImplementationOnce(() => {\n      return Promise.resolve({\n        install: false,\n      }) as unknown as ReturnType<typeof inquirer.prompt>;\n    });\n\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"grunge-stack\",\n      \"--typescript\",\n    ]);\n\n    let mockPromptCalls = mockPrompt.mock.calls;\n    let lastCallArgs = mockPromptCalls[mockPromptCalls.length - 1][0];\n    let lastCallUnknown = lastCallArgs as Array<unknown>;\n    expect(lastCallUnknown[lastCallUnknown.length - 1]).toHaveProperty(\n      \"message\",\n      \"Do you want me to run `pnpm install`?\"\n    );\n    process.env.npm_config_user_agent = originalUserAgent;\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"suggests to run the init command with the preferred package manager","suites":["the create command"],"updatePoint":{"line":629,"column":73},"line":629,"code":"  it(\"suggests to run the init command with the preferred package manager\", async () => {\n    let originalUserAgent = process.env.npm_config_user_agent;\n    process.env.npm_config_user_agent = pnpmUserAgent;\n\n    let projectDir = await getProjectDir(\"pnpm-suggest-install\");\n    let mockPrompt = jest.mocked(inquirer.prompt);\n    mockPrompt.mockImplementationOnce(() => {\n      return Promise.resolve({\n        install: false,\n      }) as unknown as ReturnType<typeof inquirer.prompt>;\n    });\n\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"grunge-stack\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n\n    expect(output).toContain(getOptOutOfInstallMessage(\"pnpm exec remix init\"));\n    process.env.npm_config_user_agent = originalUserAgent;\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when a github repo is not accessible (403)","suites":["the create command","errors"],"updatePoint":{"line":655,"column":61},"line":655,"code":"    it(\"identifies when a github repo is not accessible (403)\", async () => {\n      let projectDir = await getProjectDir(\"repo\");\n      await expect(async () => {\n        try {\n          let res = await run([\n            \"create\",\n            projectDir,\n            \"--template\",\n            \"error-username/403\",\n            \"--no-install\",\n            \"--typescript\",\n          ]);\n          return res;\n        } catch (err) {\n          throw err;\n        }\n      }).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template could not be verified because you do not have access to the repository. Please double check the access rights of this repo and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when a github repo does not exist (404)","suites":["the create command","errors"],"updatePoint":{"line":676,"column":58},"line":676,"code":"    it(\"identifies when a github repo does not exist (404)\", async () => {\n      let projectDir = await getProjectDir(\"repo\");\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"error-username/404\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template could not be verified. Please double check that the template is a valid GitHub repository and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when something unknown goes wrong with the repo request (4xx)","suites":["the create command","errors"],"updatePoint":{"line":692,"column":80},"line":692,"code":"    it(\"identifies when something unknown goes wrong with the repo request (4xx)\", async () => {\n      let projectDir = await getProjectDir(\"repo\");\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"error-username/400\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template could not be verified. The server returned a response with a 400 status. Please double check that the template is a valid GitHub repository and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when a remote tarball does not exist (404)","suites":["the create command","errors"],"updatePoint":{"line":708,"column":61},"line":708,"code":"    it(\"identifies when a remote tarball does not exist (404)\", async () => {\n      let projectDir = await getProjectDir(\"remote-tarball\");\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"https://example.com/error/404/remix-stack.tar.gz\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template file could not be verified. Please double check the URL and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when a remote tarball does not exist (4xx)","suites":["the create command","errors"],"updatePoint":{"line":724,"column":61},"line":724,"code":"    it(\"identifies when a remote tarball does not exist (4xx)\", async () => {\n      let projectDir = await getProjectDir(\"remote-tarball\");\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"https://example.com/error/400/remix-stack.tar.gz\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template file could not be verified. The server returned a response with a 400 status. Please double check the URL and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows creating an app in a dir if it's empty","suites":["the create command","errors"],"updatePoint":{"line":740,"column":53},"line":740,"code":"    it(\"allows creating an app in a dir if it's empty\", async () => {\n      let projectDir = await getProjectDir(\"other-empty-dir\");\n      await run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        \"grunge-stack\",\n        \"--no-install\",\n        \"--typescript\",\n      ]);\n\n      expect(\n        fse.existsSync(path.join(projectDir, \"package.json\"))\n      ).toBeTruthy();\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"doesn't allow creating an app in a dir if it's not empty","suites":["the create command","errors"],"updatePoint":{"line":756,"column":64},"line":756,"code":"    it(\"doesn't allow creating an app in a dir if it's not empty\", async () => {\n      let projectDir = await getProjectDir(\"not-empty-dir\");\n      fse.mkdirSync(projectDir);\n      fse.createFileSync(path.join(projectDir, \"some-file.txt\"));\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"grunge-stack\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The project directory must be empty to create a new project. Please clear the contents of the directory or choose a different path.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows creating an app in the current dir if it's empty","suites":["the create command","errors"],"updatePoint":{"line":774,"column":63},"line":774,"code":"    it(\"allows creating an app in the current dir if it's empty\", async () => {\n      let projectDir = await getProjectDir(\"empty-dir\");\n      let cwd = process.cwd();\n      fse.mkdirSync(projectDir);\n      process.chdir(projectDir);\n      await run([\n        \"create\",\n        \".\",\n        \"--template\",\n        \"grunge-stack\",\n        \"--no-install\",\n        \"--typescript\",\n      ]);\n      process.chdir(cwd);\n\n      expect(\n        fse.existsSync(path.join(projectDir, \"package.json\"))\n      ).toBeTruthy();\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"doesn't allow creating an app in the current dir if it's not empty","suites":["the create command","errors"],"updatePoint":{"line":794,"column":74},"line":794,"code":"    it(\"doesn't allow creating an app in the current dir if it's not empty\", async () => {\n      let projectDir = await getProjectDir(\"not-empty-dir\");\n      let cwd = process.cwd();\n      fse.mkdirSync(projectDir);\n      fse.createFileSync(path.join(projectDir, \"some-file.txt\"));\n      process.chdir(projectDir);\n      await expect(() =>\n        run([\n          \"create\",\n          \".\",\n          \"--template\",\n          \"grunge-stack\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The project directory must be empty to create a new project. Please clear the contents of the directory or choose a different path.]`\n      );\n      process.chdir(cwd);\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"uses the proxy from env var","suites":["the create command","supports proxy usage"],"updatePoint":{"line":823,"column":35},"line":823,"code":"    it(\"uses the proxy from env var\", async () => {\n      let projectDir = await getProjectDir(\"template\");\n      let err: Error | undefined;\n      let prevProxy = process.env.HTTPS_PROXY;\n      try {\n        process.env.HTTPS_PROXY = \"http://127.0.0.1:33128\";\n        await run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"grunge-stack\",\n          \"--no-install\",\n          \"--typescript\",\n        ]);\n      } catch (e) {\n        err = e;\n      } finally {\n        process.env.HTTPS_PROXY = prevProxy;\n      }\n      expect(err?.message).toMatch(\"127.0.0.1:33\");\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"returns an array of routes","suites":["defineRoutes"],"updatePoint":{"line":4,"column":32},"line":4,"code":"  it(\"returns an array of routes\", () => {\n    let routes = defineRoutes((route) => {\n      route(\"/\", \"routes/home.js\");\n      route(\"inbox\", \"routes/inbox.js\", () => {\n        route(\"/\", \"routes/inbox/index.js\", { index: true });\n        route(\":messageId\", \"routes/inbox/$messageId.js\");\n        route(\"archive\", \"routes/inbox/archive.js\");\n      });\n    });\n\n    expect(routes).toMatchInlineSnapshot(`\n      Object {\n        \"routes/home\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/home.js\",\n          \"id\": \"routes/home\",\n          \"index\": undefined,\n          \"parentId\": undefined,\n          \"path\": \"/\",\n        },\n        \"routes/inbox\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/inbox.js\",\n          \"id\": \"routes/inbox\",\n          \"index\": undefined,\n          \"parentId\": undefined,\n          \"path\": \"inbox\",\n        },\n        \"routes/inbox/$messageId\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/inbox/$messageId.js\",\n          \"id\": \"routes/inbox/$messageId\",\n          \"index\": undefined,\n          \"parentId\": \"routes/inbox\",\n          \"path\": \":messageId\",\n        },\n        \"routes/inbox/archive\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/inbox/archive.js\",\n          \"id\": \"routes/inbox/archive\",\n          \"index\": undefined,\n          \"parentId\": \"routes/inbox\",\n          \"path\": \"archive\",\n        },\n        \"routes/inbox/index\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/inbox/index.js\",\n          \"id\": \"routes/inbox/index\",\n          \"index\": true,\n          \"parentId\": \"routes/inbox\",\n          \"path\": \"/\",\n        },\n      }\n    `);\n  });","file":"defineRoutes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works with async data","suites":["defineRoutes"],"updatePoint":{"line":60,"column":27},"line":60,"code":"  it(\"works with async data\", async () => {\n    // Read everything *before* calling defineRoutes.\n    let fakeDirectory = await Promise.resolve([\"one.md\", \"two.md\"]);\n    let routes = defineRoutes((route) => {\n      for (let file of fakeDirectory) {\n        route(file.replace(/\\.md$/, \"\"), file);\n      }\n    });\n\n    expect(routes).toMatchInlineSnapshot(`\n      Object {\n        \"one\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"one.md\",\n          \"id\": \"one\",\n          \"index\": undefined,\n          \"parentId\": undefined,\n          \"path\": \"one\",\n        },\n        \"two\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"two.md\",\n          \"id\": \"two\",\n          \"index\": undefined,\n          \"parentId\": undefined,\n          \"path\": \"two\",\n        },\n      }\n    `);\n  });","file":"defineRoutes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"validateEmail returns false for non-emails","suites":[],"updatePoint":{"line":3,"column":48},"line":3,"code":"test(\"validateEmail returns false for non-emails\", () => {\n  expect(validateEmail(undefined)).toBe(false);\n  expect(validateEmail(null)).toBe(false);\n  expect(validateEmail(\"\")).toBe(false);\n  expect(validateEmail(\"not-an-email\")).toBe(false);\n  expect(validateEmail(\"n@\")).toBe(false);\n});","file":"fixtures/replace-remix-magic-imports/app/utils.test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"validateEmail returns true for emails","suites":[],"updatePoint":{"line":11,"column":43},"line":11,"code":"test(\"validateEmail returns true for emails\", () => {\n  expect(validateEmail(\"kody@example.com\")).toBe(true);\n});","file":"fixtures/replace-remix-magic-imports/app/utils.test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"runs successfully when ran programmatically","suites":["`convert-to-javascript` migration"],"updatePoint":{"line":110,"column":49},"line":110,"code":"  it(\"runs successfully when ran programmatically\", async () => {\n    let projectDir = makeApp();\n\n    await convertToJavaScript(projectDir, { force: true });\n\n    await checkMigrationRanSuccessfully(projectDir);\n\n    expect(output).not.toContain(\"✅ Your JavaScript looks good!\");\n    expect(output).not.toContain(\"successfully migrated\");\n  });","file":"migrations/convert-to-javascript-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"generates a config","suites":["readConfig"],"updatePoint":{"line":14,"column":24},"line":14,"code":"  it(\"generates a config\", async () => {\n    expect(config).toMatchInlineSnapshot(\n      {\n        rootDirectory: expect.any(String),\n        appDirectory: expect.any(String),\n        cacheDirectory: expect.any(String),\n        devServerPort: expect.any(Number),\n        serverBuildPath: expect.any(String),\n        assetsBuildDirectory: expect.any(String),\n        relativeAssetsBuildDirectory: expect.any(String),\n        tsconfigPath: expect.any(String),\n        future: {\n          v2_meta: expect.any(Boolean),\n        },\n      },\n      `\n      Object {\n        \"appDirectory\": Any<String>,\n        \"assetsBuildDirectory\": Any<String>,\n        \"cacheDirectory\": Any<String>,\n        \"devServerBroadcastDelay\": 0,\n        \"devServerPort\": Any<Number>,\n        \"entryClientFile\": \"entry.client.tsx\",\n        \"entryServerFile\": \"entry.server.tsx\",\n        \"future\": Object {\n          \"v2_meta\": Any<Boolean>,\n        },\n        \"mdx\": undefined,\n        \"publicPath\": \"/build/\",\n        \"relativeAssetsBuildDirectory\": Any<String>,\n        \"rootDirectory\": Any<String>,\n        \"routes\": Object {\n          \"root\": Object {\n            \"file\": \"root.tsx\",\n            \"id\": \"root\",\n            \"path\": \"\",\n          },\n        },\n        \"serverBuildPath\": Any<String>,\n        \"serverBuildTarget\": undefined,\n        \"serverBuildTargetEntryModule\": \"export * from \\\\\"@remix-run/dev/server-build\\\\\";\",\n        \"serverDependenciesToBundle\": Array [],\n        \"serverEntryPoint\": undefined,\n        \"serverMode\": \"production\",\n        \"serverModuleFormat\": \"cjs\",\n        \"serverPlatform\": \"node\",\n        \"tsconfigPath\": Any<String>,\n        \"watchPaths\": Array [],\n      }\n    `\n    );\n  });","file":"readConfig-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"returns the same devServerPort value across reloads","suites":["readConfig"],"updatePoint":{"line":67,"column":57},"line":67,"code":"  it(\"returns the same devServerPort value across reloads\", async () => {\n    let newConfig = await readConfig(remixRoot);\n    expect(newConfig.devServerPort).toBe(config.devServerPort);\n  });","file":"readConfig-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"\"\" -> \"\"","suites":["createRoutePath","creates proper route paths"],"updatePoint":{"line":42,"column":37},"line":42,"code":"      it(`\"${input}\" -> \"${expected}\"`, () => {\n        expect(createRoutePath(input)).toBe(expected);\n      });","file":"routesConvention-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces single-specifier imports","suites":[],"updatePoint":{"line":4,"column":37},"line":4,"code":"it(\"replaces single-specifier imports\", async () => {\n  let code = [\n    'import { json } from \"remix\"',\n    'import type { GetLoadContextFunction } from \"remix\"',\n    'import { type LinkProps } from \"remix\"',\n  ].join(\"\\n\");\n  let transform = replaceRemixMagicImports({\n    runtime: \"node\",\n    adapter: \"express\",\n  });\n  let result = eol.normalize(transform(code, \"fake.tsx\"));\n  expect(result).toBe(\n    [\n      'import { type GetLoadContextFunction } from \"@remix-run/express\";',\n      'import { json } from \"@remix-run/node\";',\n      'import { type LinkProps } from \"@remix-run/react\";',\n    ].join(\"\\n\")\n  );\n});","file":"transform-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces single-kind, multi-specifier imports","suites":[],"updatePoint":{"line":24,"column":49},"line":24,"code":"it(\"replaces single-kind, multi-specifier imports\", async () => {\n  let code = [\n    'import { json, createRequestHandler, Form } from \"remix\"',\n    'import type { ActionFunction, GetLoadContextFunction, LinkProps } from \"remix\"',\n    'import { type Cookie, type RequestHandler, type NavLinkProps } from \"remix\"',\n  ].join(\"\\n\");\n  let transform = replaceRemixMagicImports({\n    runtime: \"node\",\n    adapter: \"express\",\n  });\n  let result = eol.normalize(transform(code, \"fake.tsx\"));\n  expect(result).toBe(\n    [\n      'import { type GetLoadContextFunction, type RequestHandler, createRequestHandler } from \"@remix-run/express\";',\n      'import { type ActionFunction, type Cookie, json } from \"@remix-run/node\";',\n      'import { type LinkProps, type NavLinkProps, Form } from \"@remix-run/react\";',\n    ].join(\"\\n\")\n  );\n});","file":"transform-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces multi-kind, multi-specifier imports","suites":[],"updatePoint":{"line":44,"column":48},"line":44,"code":"it(\"replaces multi-kind, multi-specifier imports\", async () => {\n  let code = [\n    'import { json, type ActionFunction, createRequestHandler, type GetLoadContextFunction, Form, type LinkProps } from \"remix\"',\n  ].join(\"\\n\");\n  let transform = replaceRemixMagicImports({\n    runtime: \"node\",\n    adapter: \"express\",\n  });\n  let result = eol.normalize(transform(code, \"fake.tsx\"));\n  expect(result).toBe(\n    [\n      'import { type GetLoadContextFunction, createRequestHandler } from \"@remix-run/express\";',\n      'import { type ActionFunction, json } from \"@remix-run/node\";',\n      'import { type LinkProps, Form } from \"@remix-run/react\";',\n    ].join(\"\\n\")\n  );\n});","file":"transform-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces runtime-specific and adapter-specific imports","suites":[],"updatePoint":{"line":62,"column":58},"line":62,"code":"it(\"replaces runtime-specific and adapter-specific imports\", async () => {\n  let code = [\n    'import { json, createCloudflareKVSessionStorage, createRequestHandler, createPagesFunctionHandler, Form } from \"remix\"',\n    'import type { ActionFunction, GetLoadContextFunction, createPagesFunctionHandlerParams, LinkProps } from \"remix\"',\n  ].join(\"\\n\");\n  let transform = replaceRemixMagicImports({\n    runtime: \"cloudflare\",\n    adapter: \"cloudflare-pages\",\n  });\n  let result = eol.normalize(transform(code, \"fake.tsx\"));\n  expect(result).toBe(\n    [\n      'import { type ActionFunction, createCloudflareKVSessionStorage, json } from \"@remix-run/cloudflare\";',\n      \"\", // recast adds a newline here https://github.com/benjamn/recast/issues/39\n      \"import {\",\n      \"  type GetLoadContextFunction,\",\n      \"  type createPagesFunctionHandlerParams,\",\n      \"  createPagesFunctionHandler,\",\n      \"  createRequestHandler,\",\n      '} from \"@remix-run/cloudflare-pages\";',\n      \"\", // recast adds a newline here https://github.com/benjamn/recast/issues/39\n      'import { type LinkProps, Form } from \"@remix-run/react\";',\n    ].join(\"\\n\")\n  );\n});","file":"transform-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"handles requests","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":54,"column":24},"line":54,"code":"    it(\"handles requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/foo/bar\");\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"URL: /foo/bar\");\n      expect(res.headers[\"x-powered-by\"]).toBe(\"Express\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles null body","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":67,"column":25},"line":67,"code":"    it(\"handles null body\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 200 });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.status).toBe(200);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles body as stream","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":79,"column":30},"line":79,"code":"    it(\"handles body as stream\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let stream = Readable.from(\"hello world\");\n        return new NodeResponse(stream, { status: 200 }) as unknown as Response;\n      });\n\n      let request = supertest(createApp());\n      // note: vercel's createServerWithHelpers requires a x-now-bridge-request-id\n      let res = await request.get(\"/\").set({ \"x-now-bridge-request-id\": \"2\" });\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"hello world\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles status codes","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":93,"column":28},"line":93,"code":"    it(\"handles status codes\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 204 });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.status).toBe(204);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"sets headers","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":104,"column":20},"line":104,"code":"    it(\"sets headers\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let headers = new Headers({ \"X-Time-Of-Year\": \"most wonderful\" });\n        headers.append(\n          \"Set-Cookie\",\n          \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        return new Response(null, { headers });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.headers[\"x-time-of-year\"]).toBe(\"most wonderful\");\n      expect(res.headers[\"set-cookie\"]).toEqual([\n        \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\",\n        \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\",\n        \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\",\n      ]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles empty headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":137,"column":29},"line":137,"code":"    it(\"handles empty headers\", () => {\n      expect(createRemixHeaders({})).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles simple headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":146,"column":30},"line":146,"code":"    it(\"handles simple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar\" })).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles multiple headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":158,"column":32},"line":158,"code":"    it(\"handles multiple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar\", \"x-bar\": \"baz\" }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n            \"x-bar\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles headers with multiple values","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":173,"column":44},"line":173,"code":"    it(\"handles headers with multiple values\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar, baz\" }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar, baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles headers with multiple values and multiple headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":186,"column":65},"line":186,"code":"    it(\"handles headers with multiple values and multiple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar, baz\", \"x-bar\": \"baz\" }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar, baz\",\n            \"x-bar\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles multiple set-cookie headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":201,"column":43},"line":201,"code":"    it(\"handles multiple set-cookie headers\", () => {\n      expect(\n        createRemixHeaders({\n          \"set-cookie\": [\n            \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n            \"__other=some_other_value; Path=/; Secure; HttpOnly; MaxAge=3600; SameSite=Lax\",\n          ],\n        })\n      ).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"set-cookie\",\n            \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n            \"set-cookie\",\n            \"__other=some_other_value; Path=/; Secure; HttpOnly; MaxAge=3600; SameSite=Lax\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"creates a request with the correct headers","suites":["express createRemixRequest"],"updatePoint":{"line":225,"column":48},"line":225,"code":"  it(\"creates a request with the correct headers\", async () => {\n    let expressRequest = createRequest({\n      url: \"/foo/bar\",\n      method: \"GET\",\n      protocol: \"http\",\n      hostname: \"localhost\",\n      headers: {\n        \"Cache-Control\": \"max-age=300, s-maxage=3600\",\n        Host: \"localhost:3000\",\n      },\n    });\n    let expressResponse = createResponse();\n\n    expect(createRemixRequest(expressRequest, expressResponse))\n      .toMatchInlineSnapshot(`\n      NodeRequest {\n        \"agent\": undefined,\n        \"compress\": true,\n        \"counter\": 0,\n        \"follow\": 20,\n        \"highWaterMark\": 16384,\n        \"insecureHTTPParser\": false,\n        \"size\": 0,\n        Symbol(Body internals): Object {\n          \"body\": null,\n          \"boundary\": null,\n          \"disturbed\": false,\n          \"error\": null,\n          \"size\": 0,\n          \"type\": null,\n        },\n        Symbol(Request internals): Object {\n          \"credentials\": \"same-origin\",\n          \"headers\": Headers {\n            Symbol(query): Array [\n              \"cache-control\",\n              \"max-age=300, s-maxage=3600\",\n              \"host\",\n              \"localhost:3000\",\n            ],\n            Symbol(context): null,\n          },\n          \"method\": \"GET\",\n          \"parsedURL\": \"http://localhost:3000/foo/bar\",\n          \"redirect\": \"follow\",\n          \"signal\": AbortSignal {},\n        },\n      }\n    `);\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles requests","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":61,"column":24},"line":61,"code":"    it(\"handles requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000/foo/bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: /foo/bar\");\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles null body","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":77,"column":25},"line":77,"code":"    it(\"handles null body\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 200 });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles status codes","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":92,"column":28},"line":92,"code":"    it(\"handles status codes\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 204 });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(204);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"sets headers","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":107,"column":20},"line":107,"code":"    it(\"sets headers\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let headers = new Headers({ \"X-Time-Of-Year\": \"most wonderful\" });\n        headers.append(\n          \"Set-Cookie\",\n          \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n\n        return new Response(null, { headers });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000\" }))\n        .expectResolve((res) => {\n          expect(res.multiValueHeaders[\"x-time-of-year\"]).toEqual([\n            \"most wonderful\",\n          ]);\n          expect(res.multiValueHeaders[\"set-cookie\"]).toEqual([\n            \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\",\n            \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\",\n            \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\",\n          ]);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles empty headers","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":147,"column":29},"line":147,"code":"    it(\"handles empty headers\", () => {\n      expect(createRemixHeaders({})).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles simple headers","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":156,"column":30},"line":156,"code":"    it(\"handles simple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": [\"bar\"] })).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles multiple headers","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":168,"column":32},"line":168,"code":"    it(\"handles multiple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": [\"bar\"], \"x-bar\": [\"baz\"] }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n            \"x-bar\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles headers with multiple values","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":183,"column":44},"line":183,"code":"    it(\"handles headers with multiple values\", () => {\n      expect(createRemixHeaders({ \"x-foo\": [\"bar\", \"baz\"] }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n            \"x-foo\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles headers with multiple values and multiple headers","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":198,"column":65},"line":198,"code":"    it(\"handles headers with multiple values and multiple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": [\"bar\", \"baz\"], \"x-bar\": [\"baz\"] }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n            \"x-foo\",\n            \"baz\",\n            \"x-bar\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles cookies","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":215,"column":23},"line":215,"code":"    it(\"handles cookies\", () => {\n      expect(\n        createRemixHeaders({\n          Cookie: [\n            \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n            \"__other=some_other_value; Path=/; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT; SameSite=Lax\",\n          ],\n\n          \"x-something-else\": [\"true\"],\n        })\n      ).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"cookie\",\n            \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n            \"cookie\",\n            \"__other=some_other_value; Path=/; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT; SameSite=Lax\",\n            \"x-something-else\",\n            \"true\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"creates a request with the correct headers","suites":["netlify createRemixRequest"],"updatePoint":{"line":243,"column":48},"line":243,"code":"  it(\"creates a request with the correct headers\", () => {\n    expect(\n      createRemixRequest(\n        createMockEvent({\n          multiValueHeaders: {\n            Cookie: [\"__session=value\", \"__other=value\"],\n          },\n        })\n      )\n    ).toMatchInlineSnapshot(`\n      NodeRequest {\n        \"agent\": undefined,\n        \"compress\": true,\n        \"counter\": 0,\n        \"follow\": 20,\n        \"highWaterMark\": 16384,\n        \"insecureHTTPParser\": false,\n        \"size\": 0,\n        Symbol(Body internals): Object {\n          \"body\": null,\n          \"boundary\": null,\n          \"disturbed\": false,\n          \"error\": null,\n          \"size\": 0,\n          \"type\": null,\n        },\n        Symbol(Request internals): Object {\n          \"credentials\": \"same-origin\",\n          \"headers\": Headers {\n            Symbol(query): Array [\n              \"cookie\",\n              \"__session=value\",\n              \"cookie\",\n              \"__other=value\",\n            ],\n            Symbol(context): null,\n          },\n          \"method\": \"GET\",\n          \"parsedURL\": \"http://localhost:3000/\",\n          \"redirect\": \"follow\",\n          \"signal\": AbortSignal {},\n        },\n      }\n    `);\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles regular responses","suites":["sendRemixResponse"],"updatePoint":{"line":291,"column":31},"line":291,"code":"  it(\"handles regular responses\", async () => {\n    let response = new NodeResponse(\"anything\");\n    let result = await sendRemixResponse(response);\n    expect(result.body).toBe(\"anything\");\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles resource routes with regular data","suites":["sendRemixResponse"],"updatePoint":{"line":297,"column":47},"line":297,"code":"  it(\"handles resource routes with regular data\", async () => {\n    let json = JSON.stringify({ foo: \"bar\" });\n    let response = new NodeResponse(json, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"content-length\": json.length.toString(),\n      },\n    });\n\n    let result = await sendRemixResponse(response);\n\n    expect(result.body).toMatch(json);\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles resource routes with binary data","suites":["sendRemixResponse"],"updatePoint":{"line":311,"column":46},"line":311,"code":"  it(\"handles resource routes with binary data\", async () => {\n    let image = await fsp.readFile(path.join(__dirname, \"554828.jpeg\"));\n\n    let response = new NodeResponse(image, {\n      headers: {\n        \"content-type\": \"image/jpeg\",\n        \"content-length\": image.length.toString(),\n      },\n    });\n\n    let result = await sendRemixResponse(response);\n\n    expect(result.body).toMatch(image.toString(\"base64\"));\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"clones","suites":["Request"],"updatePoint":{"line":72,"column":12},"line":72,"code":"  it(\"clones\", async () => {\n    let body = new PassThrough();\n    test.source.forEach((chunk) => body.write(chunk));\n    body.end();\n\n    let req = new Request(\"http://test.com\", {\n      method: \"post\",\n      body,\n      headers: {\n        \"Content-Type\": \"multipart/form-data; boundary=\" + test.boundary,\n      },\n    });\n\n    let cloned = req.clone();\n    let formData = await req.formData();\n    let clonedFormData = await cloned.formData();\n\n    expect(formData.get(\"file_name_0\")).toBe(\"super alpha file\");\n    expect(clonedFormData.get(\"file_name_0\")).toBe(\"super alpha file\");\n    expect(formData.get(\"file_name_1\")).toBe(\"super beta file\");\n    expect(clonedFormData.get(\"file_name_1\")).toBe(\"super beta file\");\n    let file = formData.get(\"upload_file_0\") as File;\n    expect(file.name).toBe(\"1k_a.dat\");\n    expect(file.size).toBe(1023);\n    file = clonedFormData.get(\"upload_file_0\") as File;\n    expect(file.name).toBe(\"1k_a.dat\");\n    expect(file.size).toBe(1023);\n\n    file = formData.get(\"upload_file_1\") as File;\n    expect(file.name).toBe(\"1k_b.dat\");\n    expect(file.size).toBe(1023);\n    file = clonedFormData.get(\"upload_file_1\") as File;\n    expect(file.name).toBe(\"1k_b.dat\");\n    expect(file.size).toBe(1023);\n  });","file":"fetch-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can read file as text","suites":["NodeOnDiskFile"],"updatePoint":{"line":21,"column":27},"line":21,"code":"  it(\"can read file as text\", async () => {\n    expect(await file.text()).toBe(contents);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can get an arrayBuffer","suites":["NodeOnDiskFile"],"updatePoint":{"line":25,"column":28},"line":25,"code":"  it(\"can get an arrayBuffer\", async () => {\n    let buffer = await file.arrayBuffer();\n    expect(buffer.byteLength).toBe(size);\n    expect(buffer).toEqual(Buffer.from(contents));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can use stream","suites":["NodeOnDiskFile"],"updatePoint":{"line":31,"column":20},"line":31,"code":"  it(\"can use stream\", async () => {\n    expect(await readableStreamToString(file.stream() as any)).toBe(contents);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file and change type","suites":["NodeOnDiskFile"],"updatePoint":{"line":35,"column":36},"line":35,"code":"  it(\"can slice file and change type\", async () => {\n    let sliced = await file.slice(1, 5, \"text/rofl\");\n    expect(sliced.type).toBe(\"text/rofl\");\n    expect(await sliced.text()).toBe(contents.slice(1, 5));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file and get text","suites":["NodeOnDiskFile"],"updatePoint":{"line":41,"column":33},"line":41,"code":"  it(\"can slice file and get text\", async () => {\n    let sliced = await file.slice(1, 5);\n    expect(await sliced.text()).toBe(contents.slice(1, 5));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file twice and get text","suites":["NodeOnDiskFile"],"updatePoint":{"line":46,"column":39},"line":46,"code":"  it(\"can slice file twice and get text\", async () => {\n    let sliced = (await file.slice(1, 5)).slice(1, 2);\n    expect(await sliced.text()).toBe(contents.slice(1, 5).slice(1, 2));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can sice file and get an arrayBuffer","suites":["NodeOnDiskFile"],"updatePoint":{"line":51,"column":42},"line":51,"code":"  it(\"can sice file and get an arrayBuffer\", async () => {\n    let sliced = await file.slice(1, 5);\n    let slicedRes = contents.slice(1, 5);\n    let buffer = await sliced.arrayBuffer();\n    expect(buffer.byteLength).toBe(slicedRes.length);\n    expect(buffer).toEqual(Buffer.from(slicedRes));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file and use stream","suites":["NodeOnDiskFile"],"updatePoint":{"line":59,"column":35},"line":59,"code":"  it(\"can slice file and use stream\", async () => {\n    let sliced = await file.slice(1, 5);\n    let slicedRes = contents.slice(1, 5);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with negative start and no end","suites":["NodeOnDiskFile"],"updatePoint":{"line":66,"column":51},"line":66,"code":"  it(\"can slice file with negative start and no end\", async () => {\n    let sliced = await file.slice(-2);\n    let slicedRes = contents.slice(-2);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with negative start and negative end","suites":["NodeOnDiskFile"],"updatePoint":{"line":73,"column":57},"line":73,"code":"  it(\"can slice file with negative start and negative end\", async () => {\n    let sliced = await file.slice(-3, -1);\n    let slicedRes = contents.slice(-3, -1);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with negative start and negative end twice","suites":["NodeOnDiskFile"],"updatePoint":{"line":80,"column":63},"line":80,"code":"  it(\"can slice file with negative start and negative end twice\", async () => {\n    let sliced = await file.slice(-3, -1).slice(1, -1);\n    let slicedRes = contents.slice(-3, -1).slice(1, -1);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with start and negative end","suites":["NodeOnDiskFile"],"updatePoint":{"line":87,"column":48},"line":87,"code":"  it(\"can slice file with start and negative end\", async () => {\n    let sliced = await file.slice(1, -2);\n    let slicedRes = contents.slice(1, -2);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with negaive start and end","suites":["NodeOnDiskFile"],"updatePoint":{"line":94,"column":47},"line":94,"code":"  it(\"can slice file with negaive start and end\", async () => {\n    let sliced = await file.slice(-3, 1);\n    let slicedRes = contents.slice(-3, 1);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice oob","suites":["NodeOnDiskFile"],"updatePoint":{"line":101,"column":19},"line":101,"code":"  it(\"can slice oob\", async () => {\n    let sliced = await file.slice(0, 10000);\n    let slicedRes = contents.slice(0, 10000);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"persists session data across requests","suites":["File session storage"],"updatePoint":{"line":22,"column":43},"line":22,"code":"  it(\"persists session data across requests\", async () => {\n    let { getSession, commitSession } = createFileSessionStorage({\n      dir,\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n    let setCookie = await commitSession(session);\n    session = await getSession(getCookieFromSetCookie(setCookie));\n\n    expect(session.get(\"user\")).toEqual(\"mjackson\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"returns an empty session for cookies that are not signed properly","suites":["File session storage"],"updatePoint":{"line":35,"column":71},"line":35,"code":"  it(\"returns an empty session for cookies that are not signed properly\", async () => {\n    let { getSession, commitSession } = createFileSessionStorage({\n      dir,\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n\n    expect(session.get(\"user\")).toBe(\"mjackson\");\n\n    let setCookie = await commitSession(session);\n    session = await getSession(\n      // Tamper with the cookie...\n      getCookieFromSetCookie(setCookie).slice(0, -1)\n    );\n\n    expect(session.get(\"user\")).toBeUndefined();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"doesn't destroy the entire session directory when destroying an empty file session","suites":["File session storage"],"updatePoint":{"line":54,"column":88},"line":54,"code":"  it(\"doesn't destroy the entire session directory when destroying an empty file session\", async () => {\n    let { getSession, destroySession } = createFileSessionStorage({\n      dir,\n      cookie: { secrets: [\"secret1\"] },\n    });\n\n    let session = await getSession();\n\n    await expect(destroySession(session)).resolves.not.toThrowError();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"unsigns old session cookies using the old secret and encodes new cookies using the new secret","suites":["File session storage","when a new secret shows up in the rotation"],"updatePoint":{"line":66,"column":101},"line":66,"code":"    it(\"unsigns old session cookies using the old secret and encodes new cookies using the new secret\", async () => {\n      let { getSession, commitSession } = createFileSessionStorage({\n        dir,\n        cookie: { secrets: [\"secret1\"] },\n      });\n      let session = await getSession();\n      session.set(\"user\", \"mjackson\");\n      let setCookie = await commitSession(session);\n      session = await getSession(getCookieFromSetCookie(setCookie));\n\n      expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n      // A new secret enters the rotation...\n      let storage = createFileSessionStorage({\n        dir,\n        cookie: { secrets: [\"secret2\", \"secret1\"] },\n      });\n      getSession = storage.getSession;\n      commitSession = storage.commitSession;\n\n      // Old cookies should still work with the old secret.\n      session = await getSession(getCookieFromSetCookie(setCookie));\n      expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n      // New cookies should be signed using the new secret.\n      let setCookie2 = await commitSession(session);\n      expect(setCookie2).not.toEqual(setCookie);\n    });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"returns `true` for Cookie objects","suites":["isCookie"],"updatePoint":{"line":23,"column":39},"line":23,"code":"  it(\"returns `true` for Cookie objects\", () => {\n    expect(isCookie(createCookie(\"my-cookie\"))).toBe(true);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns `false` for non-Cookie objects","suites":["isCookie"],"updatePoint":{"line":27,"column":44},"line":27,"code":"  it(\"returns `false` for non-Cookie objects\", () => {\n    expect(isCookie({})).toBe(false);\n    expect(isCookie([])).toBe(false);\n    expect(isCookie(\"\")).toBe(false);\n    expect(isCookie(true)).toBe(false);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes empty string values","suites":["cookies"],"updatePoint":{"line":36,"column":43},"line":36,"code":"  it(\"parses/serializes empty string values\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n    let setCookie = await cookie.serialize(\"\");\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toMatchInlineSnapshot(`\"\"`);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes unsigned string values","suites":["cookies"],"updatePoint":{"line":44,"column":46},"line":44,"code":"  it(\"parses/serializes unsigned string values\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n    let setCookie = await cookie.serialize(\"hello world\");\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toEqual(\"hello world\");\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes unsigned boolean values","suites":["cookies"],"updatePoint":{"line":52,"column":47},"line":52,"code":"  it(\"parses/serializes unsigned boolean values\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n    let setCookie = await cookie.serialize(true);\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toBe(true);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes signed string values","suites":["cookies"],"updatePoint":{"line":60,"column":44},"line":60,"code":"  it(\"parses/serializes signed string values\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize(\"hello michael\");\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toMatchInlineSnapshot(`\"hello michael\"`);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes string values containing utf8 characters","suites":["cookies"],"updatePoint":{"line":70,"column":64},"line":70,"code":"  it(\"parses/serializes string values containing utf8 characters\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n    let setCookie = await cookie.serialize(\"日本語\");\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toBe(\"日本語\");\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"fails to parses signed string values with invalid signature","suites":["cookies"],"updatePoint":{"line":78,"column":65},"line":78,"code":"  it(\"fails to parses signed string values with invalid signature\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize(\"hello michael\");\n    let cookie2 = createCookie(\"my-cookie\", {\n      secrets: [\"secret2\"],\n    });\n    let value = await cookie2.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toBe(null);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes signed object values","suites":["cookies"],"updatePoint":{"line":91,"column":44},"line":91,"code":"  it(\"parses/serializes signed object values\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize({ hello: \"mjackson\" });\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toMatchInlineSnapshot(`\n      Object {\n        \"hello\": \"mjackson\",\n      }\n    `);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"fails to parse signed object values with invalid signature","suites":["cookies"],"updatePoint":{"line":105,"column":64},"line":105,"code":"  it(\"fails to parse signed object values with invalid signature\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize({ hello: \"mjackson\" });\n    let cookie2 = createCookie(\"my-cookie\", {\n      secrets: [\"secret2\"],\n    });\n    let value = await cookie2.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toBeNull();\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"supports secret rotation","suites":["cookies"],"updatePoint":{"line":118,"column":30},"line":118,"code":"  it(\"supports secret rotation\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize({ hello: \"mjackson\" });\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toMatchInlineSnapshot(`\n      Object {\n        \"hello\": \"mjackson\",\n      }\n    `);\n\n    // A new secret enters the rotation...\n    cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret2\", \"secret1\"],\n    });\n\n    // cookie should still be able to parse old cookies.\n    let oldValue = await cookie.parse(getCookieFromSetCookie(setCookie));\n    expect(oldValue).toMatchObject(value);\n\n    // New Set-Cookie should be different, it uses a differet secret.\n    let setCookie2 = await cookie.serialize(value);\n    expect(setCookie).not.toEqual(setCookie2);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"makes the default path of cookies to be /","suites":["cookies"],"updatePoint":{"line":145,"column":47},"line":145,"code":"  it(\"makes the default path of cookies to be /\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n\n    let setCookie = await cookie.serialize(\"hello world\");\n    expect(setCookie).toContain(\"Path=/\");\n\n    let cookie2 = createCookie(\"my-cookie2\");\n\n    let setCookie2 = await cookie2.serialize(\"hello world\", {\n      path: \"/about\",\n    });\n    expect(setCookie2).toContain(\"Path=/about\");\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"warns against using `expires` when creating the cookie instance","suites":["cookies","warnings when providing options you may not want to"],"updatePoint":{"line":162,"column":71},"line":162,"code":"    it(\"warns against using `expires` when creating the cookie instance\", async () => {\n      createCookie(\"my-cookie\", { expires: new Date(Date.now() + 60_000) });\n      expect(spy.console).toHaveBeenCalledTimes(1);\n      expect(spy.console).toHaveBeenCalledWith(\n        'The \"my-cookie\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use `commitSession(session, { expires })` if using a session storage object, or `cookie.serialize(\"value\", { expires })` if you\\'re using the cookie directly.'\n      );\n    });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"removes _data from request.url","suites":["loaders"],"updatePoint":{"line":7,"column":36},"line":7,"code":"  it(\"removes _data from request.url\", async () => {\n    let loader = async ({ request }) => {\n      return new URL(request.url).search;\n    };\n\n    let routeId = \"routes/random\";\n    let build = {\n      routes: {\n        [routeId]: {\n          id: routeId,\n          path: \"/random\",\n          module: {\n            loader,\n          },\n        },\n      },\n      entry: { module: {} },\n    } as unknown as ServerBuild;\n\n    let handler = createRequestHandler(build, {});\n\n    let request = new Request(\n      \"http://example.com/random?_data=routes/random&foo=bar\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    let res = await handler(request);\n    expect(await res.json()).toMatchInlineSnapshot(`\"?foo=bar\"`);\n  });","file":"data-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets header for throw responses","suites":["loaders"],"updatePoint":{"line":41,"column":37},"line":41,"code":"  it(\"sets header for throw responses\", async () => {\n    let loader = async ({ request }) => {\n      throw new Response(\"null\", {\n        headers: {\n          \"Content-type\": \"application/json\",\n        },\n      });\n    };\n\n    let routeId = \"routes/random\";\n    let build = {\n      routes: {\n        [routeId]: {\n          id: routeId,\n          path: \"/random\",\n          module: {\n            loader,\n          },\n        },\n      },\n      entry: { module: {} },\n    } as unknown as ServerBuild;\n\n    let handler = createRequestHandler(build, {});\n\n    let request = new Request(\n      \"http://example.com/random?_data=routes/random&foo=bar\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    let res = await handler(request);\n    expect(await res.headers.get(\"X-Remix-Catch\")).toBeTruthy();\n  });","file":"data-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"removes index from request.url","suites":["loaders"],"updatePoint":{"line":79,"column":36},"line":79,"code":"  it(\"removes index from request.url\", async () => {\n    let loader = async ({ request }) => {\n      return new URL(request.url).search;\n    };\n\n    let routeId = \"routes/random\";\n    let build = {\n      routes: {\n        [routeId]: {\n          id: routeId,\n          path: \"/random\",\n          module: {\n            loader,\n          },\n        },\n      },\n      entry: { module: {} },\n    } as unknown as ServerBuild;\n\n    let handler = createRequestHandler(build, {});\n\n    let request = new Request(\n      \"http://example.com/random?_data=routes/random&index&foo=bar\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    let res = await handler(request);\n    expect(await res.json()).toMatchInlineSnapshot(`\"?foo=bar\"`);\n  });","file":"data-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"removes index from request.url and keeps other values","suites":["loaders"],"updatePoint":{"line":113,"column":59},"line":113,"code":"  it(\"removes index from request.url and keeps other values\", async () => {\n    let loader = async ({ request }) => {\n      return new URL(request.url).search;\n    };\n\n    let routeId = \"routes/random\";\n    let build = {\n      routes: {\n        [routeId]: {\n          id: routeId,\n          path: \"/random\",\n          module: {\n            loader,\n          },\n        },\n      },\n      entry: { module: {} },\n    } as unknown as ServerBuild;\n\n    let handler = createRequestHandler(build, {});\n\n    let request = new Request(\n      \"http://example.com/random?_data=routes/random&index&foo=bar&index=test\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    let res = await handler(request);\n    expect(await res.json()).toMatchInlineSnapshot(`\"?foo=bar&index=test\"`);\n  });","file":"data-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"can use a custom upload handler","suites":["parseMultipartFormData"],"updatePoint":{"line":16,"column":37},"line":16,"code":"  it(\"can use a custom upload handler\", async () => {\n    let formData = new NodeFormData();\n    formData.set(\"a\", \"value\");\n    formData.set(\"blob\", new Blob([\"blob\".repeat(1000)]), \"blob.txt\");\n    formData.set(\"file\", new File([\"file\".repeat(1000)], \"file.txt\"));\n\n    let req = new NodeRequest(\"https://test.com\", {\n      method: \"post\",\n      body: formData,\n    });\n\n    let parsedFormData = await parseMultipartFormData(\n      req,\n      async ({ filename, data, contentType }) => {\n        let chunks = [];\n        for await (let chunk of data) {\n          chunks.push(chunk);\n        }\n        if (filename) {\n          return new File(chunks, filename, { type: contentType });\n        }\n\n        return await new Blob(chunks, { type: contentType }).text();\n      }\n    );\n\n    expect(parsedFormData.get(\"a\")).toBe(\"value\");\n    let blob = parsedFormData.get(\"blob\") as Blob;\n    expect(await blob.text()).toBe(\"blob\".repeat(1000));\n    let file = parsedFormData.get(\"file\") as File;\n    expect(file.name).toBe(\"file.txt\");\n    expect(await file.text()).toBe(\"file\".repeat(1000));\n  });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"can return undefined","suites":["parseMultipartFormData"],"updatePoint":{"line":50,"column":26},"line":50,"code":"  it(\"can return undefined\", async () => {\n    let formData = new NodeFormData();\n    formData.set(\"a\", \"value\");\n    formData.set(\"blob\", new Blob([\"blob\".repeat(1000)]), \"blob.txt\");\n    formData.set(\"file\", new File([\"file\".repeat(1000)], \"file.txt\"));\n\n    let req = new NodeRequest(\"https://test.com\", {\n      method: \"post\",\n      body: formData,\n    });\n\n    let parsedFormData = await parseMultipartFormData(\n      req,\n      async () => undefined\n    );\n\n    expect(parsedFormData.get(\"a\")).toBe(null);\n    expect(parsedFormData.get(\"blob\")).toBe(null);\n    expect(parsedFormData.get(\"file\")).toBe(null);\n  });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"can throw errors in upload handlers","suites":["parseMultipartFormData"],"updatePoint":{"line":71,"column":41},"line":71,"code":"  it(\"can throw errors in upload handlers\", async () => {\n    let formData = new NodeFormData();\n    formData.set(\"blob\", new Blob([\"blob\"]), \"blob.txt\");\n\n    let req = new NodeRequest(\"https://test.com\", {\n      method: \"post\",\n      body: formData,\n    });\n\n    let error: Error;\n    try {\n      await parseMultipartFormData(req, async () => {\n        throw new CustomError();\n      });\n      throw new Error(\"should have thrown\");\n    } catch (err) {\n      error = err;\n    }\n    expect(error).toBeInstanceOf(CustomError);\n    expect(error.message).toBe(\"test error\");\n  });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"when controller errors","suites":["parseMultipartFormData","stream should propagate events"],"updatePoint":{"line":94,"column":30},"line":94,"code":"    it(\"when controller errors\", async () => {\n      let formData = new NodeFormData();\n      formData.set(\"a\", \"value\");\n      formData.set(\"blob\", new Blob([\"blob\".repeat(1000)]), \"blob.txt\");\n      formData.set(\"file\", new File([\"file\".repeat(1000)], \"file.txt\"));\n\n      let underlyingRequest = new NodeRequest(\"https://test.com\", {\n        method: \"post\",\n        body: formData,\n      });\n      let underlyingBody = await underlyingRequest.text();\n\n      let encoder = new TextEncoder();\n      let body = new ReadableStream({\n        start(controller) {\n          controller.enqueue(\n            encoder.encode(underlyingBody.slice(0, underlyingBody.length / 2))\n          );\n          controller.error(new CustomError());\n        },\n      });\n\n      let req = new NodeRequest(\"https://test.com\", {\n        method: \"post\",\n        body,\n        headers: underlyingRequest.headers,\n      });\n\n      let error: Error;\n      try {\n        await parseMultipartFormData(req, async () => undefined);\n        throw new Error(\"should have thrown\");\n      } catch (err) {\n        error = err;\n      }\n\n      expect(error).toBeInstanceOf(CustomError);\n      expect(error.message).toBe(\"test error\");\n    });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"when controller is closed","suites":["parseMultipartFormData","stream should propagate events"],"updatePoint":{"line":134,"column":33},"line":134,"code":"    it(\"when controller is closed\", async () => {\n      let formData = new NodeFormData();\n      formData.set(\"a\", \"value\");\n      formData.set(\"blob\", new Blob([\"blob\".repeat(1000)]), \"blob.txt\");\n      formData.set(\"file\", new File([\"file\".repeat(1000)], \"file.txt\"));\n\n      let underlyingRequest = new NodeRequest(\"https://test.com\", {\n        method: \"post\",\n        body: formData,\n      });\n      let underlyingBody = await underlyingRequest.text();\n\n      let encoder = new TextEncoder();\n      let body = new ReadableStream({\n        start(controller) {\n          controller.enqueue(\n            encoder.encode(underlyingBody.slice(0, underlyingBody.length / 2))\n          );\n          controller.close();\n        },\n      });\n\n      let req = new NodeRequest(\"https://test.com\", {\n        method: \"post\",\n        body,\n        headers: underlyingRequest.headers,\n      });\n\n      let error: Error;\n      try {\n        await parseMultipartFormData(req, async () => undefined);\n        throw new Error(\"should have thrown\");\n      } catch (err) {\n        error = err;\n      }\n\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message).toMatch(\"malformed multipart-form data\");\n    });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"retains request headers when stripping body off for loaders","suites":["createRequestHandler"],"updatePoint":{"line":5,"column":65},"line":5,"code":"  it(\"retains request headers when stripping body off for loaders\", async () => {\n    // @ts-expect-error\n    let handler = createRequestHandler({\n      routes: {\n        root: {\n          id: \"routes/test\",\n          path: \"/test\",\n          module: {\n            loader: ({ request }) => json(request.headers.get(\"X-Foo\")),\n          } as any,\n        },\n      },\n      assets: {} as any,\n      entry: { module: {} as any },\n    });\n\n    let response = await handler(\n      new Request(\"http://.../test\", {\n        headers: {\n          \"X-Foo\": \"bar\",\n        },\n        signal: new AbortController().signal,\n      })\n    );\n\n    expect(await response.json()).toBe(\"bar\");\n  });","file":"handler-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with angle brackets should escape","suites":["escapeHtml"],"updatePoint":{"line":9,"column":41},"line":9,"code":"  test(\"with angle brackets should escape\", () => {\n    let evilObj = { evil: \"<script></script>\" };\n    expect(escapeHtml(JSON.stringify(evilObj))).toBe(\n      '{\"evil\":\"\\\\u003cscript\\\\u003e\\\\u003c/script\\\\u003e\"}'\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with angle brackets should parse back","suites":["escapeHtml"],"updatePoint":{"line":16,"column":45},"line":16,"code":"  test(\"with angle brackets should parse back\", () => {\n    let evilObj = { evil: \"<script></script>\" };\n    expect(JSON.parse(escapeHtml(JSON.stringify(evilObj)))).toMatchObject(\n      evilObj\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with ampersands should escape","suites":["escapeHtml"],"updatePoint":{"line":23,"column":37},"line":23,"code":"  test(\"with ampersands should escape\", () => {\n    let evilObj = { evil: \"&\" };\n    expect(escapeHtml(JSON.stringify(evilObj))).toBe('{\"evil\":\"\\\\u0026\"}');\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with ampersands should parse back","suites":["escapeHtml"],"updatePoint":{"line":28,"column":41},"line":28,"code":"  test(\"with ampersands should parse back\", () => {\n    let evilObj = { evil: \"&\" };\n    expect(JSON.parse(escapeHtml(JSON.stringify(evilObj)))).toMatchObject(\n      evilObj\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with \"LINE SEPARATOR\" and \"PARAGRAPH SEPARATOR\" should escape","suites":["escapeHtml"],"updatePoint":{"line":35,"column":69},"line":35,"code":"  test('with \"LINE SEPARATOR\" and \"PARAGRAPH SEPARATOR\" should escape', () => {\n    let evilObj = { evil: \"\\u2028\\u2029\" };\n    expect(escapeHtml(JSON.stringify(evilObj))).toBe(\n      '{\"evil\":\"\\\\u2028\\\\u2029\"}'\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with \"LINE SEPARATOR\" and \"PARAGRAPH SEPARATOR\" should parse back","suites":["escapeHtml"],"updatePoint":{"line":42,"column":73},"line":42,"code":"  test('with \"LINE SEPARATOR\" and \"PARAGRAPH SEPARATOR\" should parse back', () => {\n    let evilObj = { evil: \"\\u2028\\u2029\" };\n    expect(JSON.parse(escapeHtml(JSON.stringify(evilObj)))).toMatchObject(\n      evilObj\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"escaped line terminators should work","suites":["escapeHtml"],"updatePoint":{"line":49,"column":44},"line":49,"code":"  test(\"escaped line terminators should work\", () => {\n    expect(() => {\n      vm.runInNewContext(\n        \"(\" + escapeHtml(JSON.stringify({ evil: \"\\u2028\\u2029\" })) + \")\"\n      );\n    }).not.toThrow();\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets the Content-Type header","suites":["json"],"updatePoint":{"line":6,"column":34},"line":6,"code":"  it(\"sets the Content-Type header\", () => {\n    let response = json({});\n    expect(response.headers.get(\"Content-Type\")).toEqual(\n      \"application/json; charset=utf-8\"\n    );\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"preserves existing headers, including Content-Type","suites":["json"],"updatePoint":{"line":13,"column":56},"line":13,"code":"  it(\"preserves existing headers, including Content-Type\", () => {\n    let response = json(\n      {},\n      {\n        headers: {\n          \"Content-Type\": \"application/json; charset=iso-8859-1\",\n          \"X-Remix\": \"is awesome\",\n        },\n      }\n    );\n\n    expect(response.headers.get(\"Content-Type\")).toEqual(\n      \"application/json; charset=iso-8859-1\"\n    );\n    expect(response.headers.get(\"X-Remix\")).toEqual(\"is awesome\");\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"encodes the response body","suites":["json"],"updatePoint":{"line":30,"column":31},"line":30,"code":"  it(\"encodes the response body\", async () => {\n    let response = json({ hello: \"remix\" });\n    expect(await response.json()).toEqual({ hello: \"remix\" });\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"accepts status as a second parameter","suites":["json"],"updatePoint":{"line":35,"column":42},"line":35,"code":"  it(\"accepts status as a second parameter\", () => {\n    let response = json({}, 201);\n    expect(response.status).toEqual(201);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"infers input type","suites":["json"],"updatePoint":{"line":40,"column":23},"line":40,"code":"  it(\"infers input type\", async () => {\n    let response = json({ hello: \"remix\" });\n    isEqual<typeof response, TypedResponse<{ hello: string }>>(true);\n    let result = await response.json();\n    expect(result).toMatchObject({ hello: \"remix\" });\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"disallows unserializables","suites":["json"],"updatePoint":{"line":47,"column":31},"line":47,"code":"  it(\"disallows unserializables\", () => {\n    // @ts-expect-error\n    expect(() => json(124n)).toThrow();\n    // @ts-expect-error\n    expect(() => json({ field: 124n })).toThrow();\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets the status to 302 by default","suites":["redirect"],"updatePoint":{"line":56,"column":39},"line":56,"code":"  it(\"sets the status to 302 by default\", () => {\n    let response = redirect(\"/login\");\n    expect(response.status).toEqual(302);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets the status to 302 when only headers are given","suites":["redirect"],"updatePoint":{"line":61,"column":56},"line":61,"code":"  it(\"sets the status to 302 when only headers are given\", () => {\n    let response = redirect(\"/login\", {\n      headers: {\n        \"X-Remix\": \"is awesome\",\n      },\n    });\n    expect(response.status).toEqual(302);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets the Location header","suites":["redirect"],"updatePoint":{"line":70,"column":30},"line":70,"code":"  it(\"sets the Location header\", () => {\n    let response = redirect(\"/login\");\n    expect(response.headers.get(\"Location\")).toEqual(\"/login\");\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"preserves existing headers, but not Location","suites":["redirect"],"updatePoint":{"line":75,"column":50},"line":75,"code":"  it(\"preserves existing headers, but not Location\", () => {\n    let response = redirect(\"/login\", {\n      headers: {\n        Location: \"/\",\n        \"X-Remix\": \"is awesome\",\n      },\n    });\n\n    expect(response.headers.get(\"Location\")).toEqual(\"/login\");\n    expect(response.headers.get(\"X-Remix\")).toEqual(\"is awesome\");\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"accepts status as a second parameter","suites":["redirect"],"updatePoint":{"line":87,"column":42},"line":87,"code":"  it(\"accepts status as a second parameter\", () => {\n    let response = redirect(\"/profile\", 301);\n    expect(response.status).toEqual(301);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"allows through  request to ","suites":["server","createRequestHandler"],"updatePoint":{"line":72,"column":51},"line":72,"code":"      it(`allows through ${method} request to ${to}`, async () => {\n        let handler = createRequestHandler(build);\n        let response = await handler(\n          new Request(`http://localhost:3000${to}`, {\n            method,\n          })\n        );\n\n        expect(await response.text()).toContain(method);\n      });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"strips body for HEAD requests","suites":["server","createRequestHandler"],"updatePoint":{"line":84,"column":37},"line":84,"code":"    it(\"strips body for HEAD requests\", async () => {\n      let handler = createRequestHandler(build);\n      let response = await handler(\n        new Request(\"http://localhost:3000/\", {\n          method: \"HEAD\",\n        })\n      );\n\n      expect(await response.text()).toBe(\"\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls resource route loader","suites":["shared server runtime","resource routes"],"updatePoint":{"line":107,"column":37},"line":107,"code":"    test(\"calls resource route loader\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceLoader = jest.fn(() => {\n        return \"resource\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/resource\": {\n          loader: resourceLoader,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"resource\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(resourceLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls sub resource route loader","suites":["shared server runtime","resource routes"],"updatePoint":{"line":137,"column":41},"line":137,"code":"    test(\"calls sub resource route loader\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceLoader = jest.fn(() => {\n        return \"resource\";\n      });\n      let subResourceLoader = jest.fn(() => {\n        return \"sub\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/resource\": {\n          loader: resourceLoader,\n          path: \"resource\",\n        },\n        \"routes/resource.sub\": {\n          loader: subResourceLoader,\n          path: \"resource/sub\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource/sub`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"sub\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(resourceLoader.mock.calls.length).toBe(0);\n      expect(subResourceLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route loader allows thrown responses","suites":["shared server runtime","resource routes"],"updatePoint":{"line":175,"column":55},"line":175,"code":"    test(\"resource route loader allows thrown responses\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceLoader = jest.fn(() => {\n        throw new Response(\"resource\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/resource\": {\n          loader: resourceLoader,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.text()).toBe(\"resource\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(resourceLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route loader responds with generic error when thrown","suites":["shared server runtime","resource routes"],"updatePoint":{"line":205,"column":71},"line":205,"code":"    test(\"resource route loader responds with generic error when thrown\", async () => {\n      let error = new Error(\"should be logged when resource loader throws\");\n      let loader = jest.fn(() => {\n        throw error;\n      });\n      let build = mockServerBuild({\n        \"routes/resource\": {\n          loader,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(await result.text()).toBe(\n        \"Unexpected Server Error\\n\\nError: should be logged when resource loader throws\"\n      );\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route loader responds with detailed error when thrown in development","suites":["shared server runtime","resource routes"],"updatePoint":{"line":228,"column":87},"line":228,"code":"    test(\"resource route loader responds with detailed error when thrown in development\", async () => {\n      let error = new Error(\"should be logged when resource loader throws\");\n      let loader = jest.fn(() => {\n        throw error;\n      });\n      let build = mockServerBuild({\n        \"routes/resource\": {\n          loader,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect((await result.text()).includes(error.message)).toBe(true);\n      expect(spy.console.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls resource route action","suites":["shared server runtime","resource routes"],"updatePoint":{"line":250,"column":37},"line":250,"code":"    test(\"calls resource route action\", async () => {\n      let rootAction = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceAction = jest.fn(() => {\n        return \"resource\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          action: rootAction,\n        },\n        \"routes/resource\": {\n          action: resourceAction,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"resource\");\n      expect(rootAction.mock.calls.length).toBe(0);\n      expect(resourceAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls sub resource route action","suites":["shared server runtime","resource routes"],"updatePoint":{"line":280,"column":41},"line":280,"code":"    test(\"calls sub resource route action\", async () => {\n      let rootAction = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceAction = jest.fn(() => {\n        return \"resource\";\n      });\n      let subResourceAction = jest.fn(() => {\n        return \"sub\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          action: rootAction,\n        },\n        \"routes/resource\": {\n          action: resourceAction,\n          path: \"resource\",\n        },\n        \"routes/resource.sub\": {\n          action: subResourceAction,\n          path: \"resource/sub\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource/sub`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"sub\");\n      expect(rootAction.mock.calls.length).toBe(0);\n      expect(resourceAction.mock.calls.length).toBe(0);\n      expect(subResourceAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route action allows thrown responses","suites":["shared server runtime","resource routes"],"updatePoint":{"line":318,"column":55},"line":318,"code":"    test(\"resource route action allows thrown responses\", async () => {\n      let rootAction = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceAction = jest.fn(() => {\n        throw new Response(\"resource\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          action: rootAction,\n        },\n        \"routes/resource\": {\n          action: resourceAction,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.text()).toBe(\"resource\");\n      expect(rootAction.mock.calls.length).toBe(0);\n      expect(resourceAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route action responds with generic error when thrown","suites":["shared server runtime","resource routes"],"updatePoint":{"line":348,"column":71},"line":348,"code":"    test(\"resource route action responds with generic error when thrown\", async () => {\n      let error = new Error(\"should be logged when resource loader throws\");\n      let action = jest.fn(() => {\n        throw error;\n      });\n      let build = mockServerBuild({\n        \"routes/resource\": {\n          action,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(await result.text()).toBe(\n        \"Unexpected Server Error\\n\\nError: should be logged when resource loader throws\"\n      );\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route action responds with detailed error when thrown in development","suites":["shared server runtime","resource routes"],"updatePoint":{"line":371,"column":87},"line":371,"code":"    test(\"resource route action responds with detailed error when thrown in development\", async () => {\n      let message = \"should be logged when resource loader throws\";\n      let action = jest.fn(() => {\n        throw new Error(message);\n      });\n      let build = mockServerBuild({\n        \"routes/resource\": {\n          action,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect((await result.text()).includes(message)).toBe(true);\n      expect(spy.console.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request that does not match loader surfaces error for boundary","suites":["shared server runtime","data requests"],"updatePoint":{"line":395,"column":77},"line":395,"code":"    test(\"data request that does not match loader surfaces error for boundary\", async () => {\n      let build = mockServerBuild({\n        root: {\n          default: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?_data=routes/index`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect((await result.json()).message).toBeTruthy();\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls loader","suites":["shared server runtime","data requests"],"updatePoint":{"line":417,"column":35},"line":417,"code":"    test(\"data request calls loader\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          loader: indexLoader,\n          index: true,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?_data=routes/index`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"index\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls loader and responds with generic message and error header","suites":["shared server runtime","data requests"],"updatePoint":{"line":448,"column":86},"line":448,"code":"    test(\"data request calls loader and responds with generic message and error header\", async () => {\n      let rootLoader = jest.fn(() => {\n        throw new Error(\"test\");\n      });\n      let testAction = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=root`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.json()).message).toBe(\"Unexpected Server Error\");\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(testAction.mock.calls.length).toBe(0);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls loader and responds with detailed info and error header in development mode","suites":["shared server runtime","data requests"],"updatePoint":{"line":480,"column":104},"line":480,"code":"    test(\"data request calls loader and responds with detailed info and error header in development mode\", async () => {\n      let message =\n        \"data request loader error logged to console once in dev mode\";\n      let rootLoader = jest.fn(() => {\n        throw new Error(message);\n      });\n      let testAction = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/test?_data=root`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.json()).message).toBe(message);\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(testAction.mock.calls.length).toBe(0);\n      expect(spy.console.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls loader and responds with catch header","suites":["shared server runtime","data requests"],"updatePoint":{"line":515,"column":66},"line":515,"code":"    test(\"data request calls loader and responds with catch header\", async () => {\n      let rootLoader = jest.fn(() => {\n        throw new Response(\"test\", { status: 400 });\n      });\n      let testAction = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=root`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(await result.text()).toBe(\"test\");\n      expect(result.headers.get(\"X-Remix-Catch\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(testAction.mock.calls.length).toBe(0);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls action","suites":["shared server runtime","data requests"],"updatePoint":{"line":547,"column":35},"line":547,"code":"    test(\"data request calls action\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=routes/test`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"test\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls action and responds with generic message and error header","suites":["shared server runtime","data requests"],"updatePoint":{"line":578,"column":86},"line":578,"code":"    test(\"data request calls action and responds with generic message and error header\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(\"test\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=routes/test`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.json()).message).toBe(\"Unexpected Server Error\");\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls action and responds with detailed info and error header in development mode","suites":["shared server runtime","data requests"],"updatePoint":{"line":610,"column":104},"line":610,"code":"    test(\"data request calls action and responds with detailed info and error header in development mode\", async () => {\n      let message =\n        \"data request action error logged to console once in dev mode\";\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(message);\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/test?_data=routes/test`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.json()).message).toBe(message);\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(spy.console.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls action and responds with catch header","suites":["shared server runtime","data requests"],"updatePoint":{"line":645,"column":66},"line":645,"code":"    test(\"data request calls action and responds with catch header\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Response(\"test\", { status: 400 });\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=routes/test`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(await result.text()).toBe(\"test\");\n      expect(result.headers.get(\"X-Remix-Catch\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls layout action","suites":["shared server runtime","data requests"],"updatePoint":{"line":677,"column":42},"line":677,"code":"    test(\"data request calls layout action\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let rootAction = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          action: rootAction,\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?_data=root`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"root\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(rootAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls index action","suites":["shared server runtime","data requests"],"updatePoint":{"line":708,"column":41},"line":708,"code":"    test(\"data request calls index action\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          action: indexAction,\n          index: true,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index&_data=routes/index`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"index\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"not found document request for no matches and no CatchBoundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":741,"column":72},"line":741,"code":"    test(\"not found document request for no matches and no CatchBoundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(404);\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch!.status).toBe(404);\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(null);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets root as catch boundary for not found document request","suites":["shared server runtime","document requests"],"updatePoint":{"line":772,"column":68},"line":772,"code":"    test(\"sets root as catch boundary for not found document request\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(404);\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch!.status).toBe(404);\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\"root\");\n      expect(entryContext.routeData).toEqual({});\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown loader responses bubble up","suites":["shared server runtime","document requests"],"updatePoint":{"line":803,"column":43},"line":803,"code":"    test(\"thrown loader responses bubble up\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(indexLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch!.status).toBe(400);\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\"root\");\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown loader responses catch deep","suites":["shared server runtime","document requests"],"updatePoint":{"line":846,"column":44},"line":846,"code":"    test(\"thrown loader responses catch deep\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          CatchBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(indexLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch!.status).toBe(400);\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\"routes/index\");\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown action responses bubble up","suites":["shared server runtime","document requests"],"updatePoint":{"line":890,"column":43},"line":890,"code":"    test(\"thrown action responses bubble up\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      // Should not call root loader since it is the boundary route\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch!.status).toBe(400);\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\"root\");\n      expect(entryContext.routeData).toEqual({});\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown action responses bubble up for index routes","suites":["shared server runtime","document requests"],"updatePoint":{"line":937,"column":60},"line":937,"code":"    test(\"thrown action responses bubble up for index routes\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(indexAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      // Should not call root loader since it is the boundary route\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch!.status).toBe(400);\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\"root\");\n      expect(entryContext.routeData).toEqual({});\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown action responses catch deep","suites":["shared server runtime","document requests"],"updatePoint":{"line":984,"column":44},"line":984,"code":"    test(\"thrown action responses catch deep\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n          CatchBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch!.status).toBe(400);\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\"routes/test\");\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown action responses catch deep for index routes","suites":["shared server runtime","document requests"],"updatePoint":{"line":1033,"column":61},"line":1033,"code":"    test(\"thrown action responses catch deep for index routes\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n          CatchBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(indexAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch!.status).toBe(400);\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\"routes/index\");\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown loader response after thrown action response bubble up action throw to deepest loader boundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":1082,"column":111},"line":1082,"code":"    test(\"thrown loader response after thrown action response bubble up action throw to deepest loader boundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let layoutLoader = jest.fn(() => {\n        throw new Response(\"layout\", { status: 401 });\n      });\n      let testAction = jest.fn(() => {\n        throw new Response(\"action\", { status: 400 });\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/__layout\": {\n          parentId: \"root\",\n          default: {},\n          loader: layoutLoader,\n          CatchBoundary: {},\n        },\n        \"routes/__layout/test\": {\n          parentId: \"routes/__layout\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch.data).toBe(\"action\");\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\n        \"routes/__layout\"\n      );\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown loader response after thrown index action response bubble up action throw to deepest loader boundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":1141,"column":117},"line":1141,"code":"    test(\"thrown loader response after thrown index action response bubble up action throw to deepest loader boundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let layoutLoader = jest.fn(() => {\n        throw new Response(\"layout\", { status: 401 });\n      });\n      let indexAction = jest.fn(() => {\n        throw new Response(\"action\", { status: 400 });\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/__layout\": {\n          parentId: \"root\",\n          default: {},\n          loader: layoutLoader,\n          CatchBoundary: {},\n        },\n        \"routes/__layout/index\": {\n          parentId: \"routes/__layout\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(indexAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.catch).toBeTruthy();\n      expect(entryContext.appState.catch.data).toBe(\"action\");\n      expect(entryContext.appState.catchBoundaryRouteId).toBe(\n        \"routes/__layout\"\n      );\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"loader errors bubble up","suites":["shared server runtime","document requests"],"updatePoint":{"line":1200,"column":33},"line":1200,"code":"    test(\"loader errors bubble up\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        throw new Error(\"index\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(indexLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"index\");\n      expect(entryContext.appState.loaderBoundaryRouteId).toBe(\"root\");\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"loader errors catch deep","suites":["shared server runtime","document requests"],"updatePoint":{"line":1243,"column":34},"line":1243,"code":"    test(\"loader errors catch deep\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        throw new Error(\"index\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          ErrorBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(indexLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"index\");\n      expect(entryContext.appState.loaderBoundaryRouteId).toBe(\"routes/index\");\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"action errors bubble up","suites":["shared server runtime","document requests"],"updatePoint":{"line":1287,"column":33},"line":1287,"code":"    test(\"action errors bubble up\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(\"test\");\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      // Should not call root loader since it is the boundary route\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"test\");\n      expect(entryContext.appState.loaderBoundaryRouteId).toBe(\"root\");\n      expect(entryContext.routeData).toEqual({});\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"action errors bubble up for index routes","suites":["shared server runtime","document requests"],"updatePoint":{"line":1334,"column":50},"line":1334,"code":"    test(\"action errors bubble up for index routes\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        throw new Error(\"index\");\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(indexAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      // Should not call root loader since it is the boundary route\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"index\");\n      expect(entryContext.appState.loaderBoundaryRouteId).toBe(\"root\");\n      expect(entryContext.routeData).toEqual({});\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"action errors catch deep","suites":["shared server runtime","document requests"],"updatePoint":{"line":1381,"column":34},"line":1381,"code":"    test(\"action errors catch deep\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(\"test\");\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n          ErrorBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"test\");\n      expect(entryContext.appState.loaderBoundaryRouteId).toBe(\"routes/test\");\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"action errors catch deep for index routes","suites":["shared server runtime","document requests"],"updatePoint":{"line":1430,"column":51},"line":1430,"code":"    test(\"action errors catch deep for index routes\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        throw new Error(\"index\");\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n          ErrorBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(indexAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"index\");\n      expect(entryContext.appState.loaderBoundaryRouteId).toBe(\"routes/index\");\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"loader errors after action error bubble up action error to deepest loader boundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":1479,"column":92},"line":1479,"code":"    test(\"loader errors after action error bubble up action error to deepest loader boundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let layoutLoader = jest.fn(() => {\n        throw new Error(\"layout\");\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(\"action\");\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/__layout\": {\n          parentId: \"root\",\n          default: {},\n          loader: layoutLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/__layout/test\": {\n          parentId: \"routes/__layout\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(testAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"action\");\n      expect(entryContext.appState.loaderBoundaryRouteId).toBe(\n        \"routes/__layout\"\n      );\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"loader errors after index action error bubble up action error to deepest loader boundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":1538,"column":98},"line":1538,"code":"    test(\"loader errors after index action error bubble up action error to deepest loader boundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let layoutLoader = jest.fn(() => {\n        throw new Error(\"layout\");\n      });\n      let indexAction = jest.fn(() => {\n        throw new Error(\"action\");\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/__layout\": {\n          parentId: \"root\",\n          default: {},\n          loader: layoutLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/__layout/index\": {\n          parentId: \"routes/__layout\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(indexAction.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(rootLoader.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(\n        1 * DATA_CALL_MULTIPIER\n      );\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[0][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"action\");\n      expect(entryContext.appState.loaderBoundaryRouteId).toBe(\n        \"routes/__layout\"\n      );\n      expect(entryContext.routeData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls handleDocumentRequest again with new error when handleDocumentRequest throws","suites":["shared server runtime","document requests"],"updatePoint":{"line":1597,"column":92},"line":1597,"code":"    test(\"calls handleDocumentRequest again with new error when handleDocumentRequest throws\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let calledBefore = false;\n      let ogHandleDocumentRequest = build.entry.module.default;\n      build.entry.module.default = jest.fn(function () {\n        if (!calledBefore) {\n          throw new Error(\"thrown\");\n        }\n        calledBefore = true;\n        return ogHandleDocumentRequest.call(null, arguments);\n      }) as any;\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(2 * DATA_CALL_MULTIPIER);\n      let entryContext = calls[1][3];\n      expect(entryContext.appState.error).toBeTruthy();\n      expect(entryContext.appState.error.message).toBe(\"thrown\");\n      expect(entryContext.appState.trackBoundaries).toBe(false);\n      expect(entryContext.routeData).toEqual({});\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns generic message if handleDocumentRequest throws a second time","suites":["shared server runtime","document requests"],"updatePoint":{"line":1643,"column":79},"line":1643,"code":"    test(\"returns generic message if handleDocumentRequest throws a second time\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let lastThrownError;\n      build.entry.module.default = jest.fn(function () {\n        lastThrownError = new Error(\"rofl\");\n        throw lastThrownError;\n      }) as any;\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(await result.text()).toBe(\n        \"Unexpected Server Error\\n\\nError: rofl\"\n      );\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(2 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns more detailed message if handleDocumentRequest throws a second time in development mode","suites":["shared server runtime","document requests"],"updatePoint":{"line":1683,"column":105},"line":1683,"code":"    test(\"returns more detailed message if handleDocumentRequest throws a second time in development mode\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let errorMessage =\n        \"thrown from handleDocumentRequest and expected to be logged in console only once\";\n      let lastThrownError;\n      build.entry.module.default = jest.fn(function () {\n        lastThrownError = new Error(errorMessage);\n        throw lastThrownError;\n      }) as any;\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.text()).includes(errorMessage)).toBe(true);\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(2 * DATA_CALL_MULTIPIER);\n      expect(spy.console.mock.calls.length).toBe(1 * DATA_CALL_MULTIPIER);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"has an empty id by default","suites":["Session"],"updatePoint":{"line":35,"column":32},"line":35,"code":"  it(\"has an empty id by default\", () => {\n    expect(createSession().id).toEqual(\"\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"correctly stores and retrieves values","suites":["Session"],"updatePoint":{"line":39,"column":43},"line":39,"code":"  it(\"correctly stores and retrieves values\", () => {\n    let session = createSession();\n\n    session.set(\"user\", \"mjackson\");\n    session.flash(\"error\", \"boom\");\n\n    expect(session.has(\"user\")).toBe(true);\n    expect(session.get(\"user\")).toBe(\"mjackson\");\n    // Normal values should remain in the session after get()\n    expect(session.has(\"user\")).toBe(true);\n    expect(session.get(\"user\")).toBe(\"mjackson\");\n\n    expect(session.has(\"error\")).toBe(true);\n    expect(session.get(\"error\")).toBe(\"boom\");\n    // Flash values disappear after the first get()\n    expect(session.has(\"error\")).toBe(false);\n    expect(session.get(\"error\")).toBeUndefined();\n\n    session.unset(\"user\");\n\n    expect(session.has(\"user\")).toBe(false);\n    expect(session.get(\"user\")).toBeUndefined();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns `true` for Session objects","suites":["isSession"],"updatePoint":{"line":65,"column":40},"line":65,"code":"  it(\"returns `true` for Session objects\", () => {\n    expect(isSession(createSession())).toBe(true);\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns `false` for non-Session objects","suites":["isSession"],"updatePoint":{"line":69,"column":45},"line":69,"code":"  it(\"returns `false` for non-Session objects\", () => {\n    expect(isSession({})).toBe(false);\n    expect(isSession([])).toBe(false);\n    expect(isSession(\"\")).toBe(false);\n    expect(isSession(true)).toBe(false);\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"persists session data across requests","suites":["In-memory session storage"],"updatePoint":{"line":78,"column":43},"line":78,"code":"  it(\"persists session data across requests\", async () => {\n    let { getSession, commitSession } = createMemorySessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n    let setCookie = await commitSession(session);\n    session = await getSession(getCookieFromSetCookie(setCookie));\n\n    expect(session.get(\"user\")).toEqual(\"mjackson\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"persists session data across requests","suites":["Cookie session storage"],"updatePoint":{"line":92,"column":43},"line":92,"code":"  it(\"persists session data across requests\", async () => {\n    let { getSession, commitSession } = createCookieSessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n    let setCookie = await commitSession(session);\n    session = await getSession(getCookieFromSetCookie(setCookie));\n\n    expect(session.get(\"user\")).toEqual(\"mjackson\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns an empty session for cookies that are not signed properly","suites":["Cookie session storage"],"updatePoint":{"line":104,"column":71},"line":104,"code":"  it(\"returns an empty session for cookies that are not signed properly\", async () => {\n    let { getSession, commitSession } = createCookieSessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n\n    expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n    let setCookie = await commitSession(session);\n    session = await getSession(\n      // Tamper with the session cookie...\n      getCookieFromSetCookie(setCookie).slice(0, -1)\n    );\n\n    expect(session.get(\"user\")).toBeUndefined();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"\"makes the default path of cookies to be /","suites":["Cookie session storage"],"updatePoint":{"line":122,"column":48},"line":122,"code":"  it('\"makes the default path of cookies to be /', async () => {\n    let { getSession, commitSession } = createCookieSessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n    let setCookie = await commitSession(session);\n    expect(setCookie).toContain(\"Path=/\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"throws an error when the cookie size exceeds 4096 bytes","suites":["Cookie session storage"],"updatePoint":{"line":132,"column":61},"line":132,"code":"  it(\"throws an error when the cookie size exceeds 4096 bytes\", async () => {\n    let { getSession, commitSession } = createCookieSessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    let longString = new Array(4097).fill(\"a\").join(\"\");\n    session.set(\"over4096bytes\", longString);\n    await expect(() => commitSession(session)).rejects.toThrow();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"warns against using `expires` when creating the session","suites":["Cookie session storage","warnings when providing options you may not want to"],"updatePoint":{"line":145,"column":63},"line":145,"code":"    it(\"warns against using `expires` when creating the session\", async () => {\n      createCookieSessionStorage({\n        cookie: {\n          secrets: [\"secret1\"],\n          expires: new Date(Date.now() + 60_000),\n        },\n      });\n\n      expect(spy.console).toHaveBeenCalledTimes(1);\n      expect(spy.console).toHaveBeenCalledWith(\n        'The \"__session\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use `commitSession(session, { expires })` if using a session storage object, or `cookie.serialize(\"value\", { expires })` if you\\'re using the cookie directly.'\n      );\n    });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"warns when not passing secrets when creating the session","suites":["Cookie session storage","warnings when providing options you may not want to"],"updatePoint":{"line":159,"column":64},"line":159,"code":"    it(\"warns when not passing secrets when creating the session\", async () => {\n      createCookieSessionStorage({ cookie: {} });\n\n      expect(spy.console).toHaveBeenCalledTimes(1);\n      expect(spy.console).toHaveBeenCalledWith(\n        'The \"__session\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/api/remix#signing-cookies for more information.'\n      );\n    });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"unsigns old session cookies using the old secret and encodes new cookies using the new secret","suites":["Cookie session storage","when a new secret shows up in the rotation"],"updatePoint":{"line":170,"column":101},"line":170,"code":"    it(\"unsigns old session cookies using the old secret and encodes new cookies using the new secret\", async () => {\n      let { getSession, commitSession } = createCookieSessionStorage({\n        cookie: { secrets: [\"secret1\"] },\n      });\n      let session = await getSession();\n      session.set(\"user\", \"mjackson\");\n      let setCookie = await commitSession(session);\n      session = await getSession(getCookieFromSetCookie(setCookie));\n\n      expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n      // A new secret enters the rotation...\n      let storage = createCookieSessionStorage({\n        cookie: { secrets: [\"secret2\", \"secret1\"] },\n      });\n      getSession = storage.getSession;\n      commitSession = storage.commitSession;\n\n      // Old cookies should still work with the old secret.\n      session = await storage.getSession(getCookieFromSetCookie(setCookie));\n      expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n      // New cookies should be signed using the new secret.\n      let setCookie2 = await storage.commitSession(session);\n      expect(setCookie2).not.toEqual(setCookie);\n    });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"handles requests","suites":["vercel createRequestHandler","basic requests"],"updatePoint":{"line":56,"column":24},"line":56,"code":"    it(\"handles requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      let request = supertest(createApp());\n      // note: vercel's createServerWithHelpers requires a x-now-bridge-request-id\n      let res = await request\n        .get(\"/foo/bar\")\n        .set({ \"x-now-bridge-request-id\": \"2\" });\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"URL: /foo/bar\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles null body","suites":["vercel createRequestHandler","basic requests"],"updatePoint":{"line":71,"column":25},"line":71,"code":"    it(\"handles null body\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 200 });\n      });\n\n      let request = supertest(createApp());\n      // note: vercel's createServerWithHelpers requires a x-now-bridge-request-id\n      let res = await request.get(\"/\").set({ \"x-now-bridge-request-id\": \"2\" });\n\n      expect(res.status).toBe(200);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles body as stream","suites":["vercel createRequestHandler","basic requests"],"updatePoint":{"line":84,"column":30},"line":84,"code":"    it(\"handles body as stream\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let stream = Readable.from(\"hello world\");\n        return new NodeResponse(stream, { status: 200 }) as unknown as Response;\n      });\n\n      let request = supertest(createApp());\n      // note: vercel's createServerWithHelpers requires a x-now-bridge-request-id\n      let res = await request.get(\"/\").set({ \"x-now-bridge-request-id\": \"2\" });\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"hello world\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles status codes","suites":["vercel createRequestHandler","basic requests"],"updatePoint":{"line":98,"column":28},"line":98,"code":"    it(\"handles status codes\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 204 });\n      });\n\n      let request = supertest(createApp());\n      // note: vercel's createServerWithHelpers requires a x-now-bridge-request-id\n      let res = await request.get(\"/\").set({ \"x-now-bridge-request-id\": \"2\" });\n\n      expect(res.status).toBe(204);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"sets headers","suites":["vercel createRequestHandler","basic requests"],"updatePoint":{"line":110,"column":20},"line":110,"code":"    it(\"sets headers\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let headers = new Headers({ \"X-Time-Of-Year\": \"most wonderful\" });\n        headers.append(\n          \"Set-Cookie\",\n          \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        return new Response(null, { headers });\n      });\n\n      let request = supertest(createApp());\n      // note: vercel's createServerWithHelpers requires a x-now-bridge-request-id\n      let res = await request.get(\"/\").set({ \"x-now-bridge-request-id\": \"2\" });\n\n      expect(res.headers[\"x-time-of-year\"]).toBe(\"most wonderful\");\n      expect(res.headers[\"set-cookie\"]).toEqual([\n        \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\",\n        \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\",\n        \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\",\n      ]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles empty headers","suites":["vercel createRemixHeaders","creates fetch headers from vercel headers"],"updatePoint":{"line":144,"column":29},"line":144,"code":"    it(\"handles empty headers\", () => {\n      expect(createRemixHeaders({})).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles simple headers","suites":["vercel createRemixHeaders","creates fetch headers from vercel headers"],"updatePoint":{"line":153,"column":30},"line":153,"code":"    it(\"handles simple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar\" })).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles multiple headers","suites":["vercel createRemixHeaders","creates fetch headers from vercel headers"],"updatePoint":{"line":165,"column":32},"line":165,"code":"    it(\"handles multiple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar\", \"x-bar\": \"baz\" }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar\",\n            \"x-bar\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles headers with multiple values","suites":["vercel createRemixHeaders","creates fetch headers from vercel headers"],"updatePoint":{"line":180,"column":44},"line":180,"code":"    it(\"handles headers with multiple values\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar, baz\" }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar, baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles headers with multiple values and multiple headers","suites":["vercel createRemixHeaders","creates fetch headers from vercel headers"],"updatePoint":{"line":193,"column":65},"line":193,"code":"    it(\"handles headers with multiple values and multiple headers\", () => {\n      expect(createRemixHeaders({ \"x-foo\": \"bar, baz\", \"x-bar\": \"baz\" }))\n        .toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"x-foo\",\n            \"bar, baz\",\n            \"x-bar\",\n            \"baz\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles multiple set-cookie headers","suites":["vercel createRemixHeaders","creates fetch headers from vercel headers"],"updatePoint":{"line":208,"column":43},"line":208,"code":"    it(\"handles multiple set-cookie headers\", () => {\n      expect(\n        createRemixHeaders({\n          \"set-cookie\": [\n            \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n            \"__other=some_other_value; Path=/; Secure; HttpOnly; MaxAge=3600; SameSite=Lax\",\n          ],\n        })\n      ).toMatchInlineSnapshot(`\n        Headers {\n          Symbol(query): Array [\n            \"set-cookie\",\n            \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n            \"set-cookie\",\n            \"__other=some_other_value; Path=/; Secure; HttpOnly; MaxAge=3600; SameSite=Lax\",\n          ],\n          Symbol(context): null,\n        }\n      `);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"creates a request with the correct headers","suites":["vercel createRemixRequest"],"updatePoint":{"line":232,"column":48},"line":232,"code":"  it(\"creates a request with the correct headers\", async () => {\n    let request = createRequest({\n      method: \"GET\",\n      url: \"/foo/bar\",\n      headers: {\n        \"x-forwarded-host\": \"localhost:3000\",\n        \"x-forwarded-proto\": \"http\",\n        \"Cache-Control\": \"max-age=300, s-maxage=3600\",\n      },\n    }) as VercelRequest;\n    let response = createResponse() as unknown as VercelResponse;\n\n    expect(createRemixRequest(request, response)).toMatchInlineSnapshot(`\n      NodeRequest {\n        \"agent\": undefined,\n        \"compress\": true,\n        \"counter\": 0,\n        \"follow\": 20,\n        \"highWaterMark\": 16384,\n        \"insecureHTTPParser\": false,\n        \"size\": 0,\n        Symbol(Body internals): Object {\n          \"body\": null,\n          \"boundary\": null,\n          \"disturbed\": false,\n          \"error\": null,\n          \"size\": 0,\n          \"type\": null,\n        },\n        Symbol(Request internals): Object {\n          \"credentials\": \"same-origin\",\n          \"headers\": Headers {\n            Symbol(query): Array [\n              \"cache-control\",\n              \"max-age=300, s-maxage=3600\",\n              \"x-forwarded-host\",\n              \"localhost:3000\",\n              \"x-forwarded-proto\",\n              \"http\",\n            ],\n            Symbol(context): null,\n          },\n          \"method\": \"GET\",\n          \"parsedURL\": \"http://localhost:3000/foo/bar\",\n          \"redirect\": \"follow\",\n          \"signal\": AbortSignal {},\n        },\n      }\n    `);\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"}]}