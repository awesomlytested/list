{"repo":"apollographql/apollo-client","url":"https://github.com/apollographql/apollo-client","branch":"main","configs":[{"package":"@apollo/client","lang":"ts","dir":"src/__tests__","framework":"jest","pattern":"**/*.{js,ts}"}],"tests":[{"name":"will throw an error if cache is not passed in","suites":["ApolloClient","constructor"],"updatePoint":{"line":33,"column":53},"line":33,"code":"    it('will throw an error if cache is not passed in', () => {\n      expect(() => {\n        new ApolloClient({ link: ApolloLink.empty() } as any);\n      }).toThrowErrorMatchingSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create an `HttpLink` instance if `uri` is provided","suites":["ApolloClient","constructor"],"updatePoint":{"line":39,"column":65},"line":39,"code":"    it('should create an `HttpLink` instance if `uri` is provided', () => {\n      const uri = 'http://localhost:4000';\n      const client = new ApolloClient({\n        cache: new InMemoryCache(),\n        uri,\n      });\n\n      expect(client.link).toBeDefined();\n      expect((client.link as HttpLink).options.uri).toEqual(uri);\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"should accept `link` over `uri` if both are provided","suites":["ApolloClient","constructor"],"updatePoint":{"line":50,"column":60},"line":50,"code":"    it('should accept `link` over `uri` if both are provided', () => {\n      const uri1 = 'http://localhost:3000';\n      const uri2 = 'http://localhost:4000';\n      const client = new ApolloClient({\n        cache: new InMemoryCache(),\n        uri: uri1,\n        link: new HttpLink({ uri: uri2 })\n      });\n      expect((client.link as HttpLink).options.uri).toEqual(uri2);\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create an empty Link if `uri` and `link` are not provided","suites":["ApolloClient","constructor"],"updatePoint":{"line":61,"column":72},"line":61,"code":"    it('should create an empty Link if `uri` and `link` are not provided', () => {\n      const client = new ApolloClient({\n        cache: new InMemoryCache(),\n      });\n      expect(client.link).toBeDefined();\n      expect(client.link instanceof ApolloLink).toBeTruthy();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will read some data from the store","suites":["ApolloClient","readQuery"],"updatePoint":{"line":71,"column":42},"line":71,"code":"    it('will read some data from the store', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache().restore({\n          ROOT_QUERY: {\n            a: 1,\n            b: 2,\n            c: 3,\n          },\n        }),\n      });\n\n      expect(\n        client.readQuery({\n          query: gql`\n            {\n              a\n            }\n          `,\n        }),\n      ).toEqual({ a: 1 });\n      expect(\n        client.readQuery({\n          query: gql`\n            {\n              b\n              c\n            }\n          `,\n        }),\n      ).toEqual({ b: 2, c: 3 });\n      expect(\n        client.readQuery({\n          query: gql`\n            {\n              a\n              b\n              c\n            }\n          `,\n        }),\n      ).toEqual({ a: 1, b: 2, c: 3 });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will read some deeply nested data from the store","suites":["ApolloClient","readQuery"],"updatePoint":{"line":115,"column":56},"line":115,"code":"    it('will read some deeply nested data from the store', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache().restore({\n          ROOT_QUERY: {\n            a: 1,\n            b: 2,\n            c: 3,\n            d: makeReference('foo'),\n          },\n          foo: {\n            __typename: 'Foo',\n            e: 4,\n            f: 5,\n            g: 6,\n            h: makeReference('bar'),\n          },\n          bar: {\n            __typename: 'Bar',\n            i: 7,\n            j: 8,\n            k: 9,\n          },\n        }),\n      });\n\n      expect(\n        client.readQuery({\n          query: gql`\n            {\n              a\n              d {\n                e\n              }\n            }\n          `,\n        }),\n      ).toEqual({ a: 1, d: { e: 4, __typename: 'Foo' } });\n      expect(\n        client.readQuery({\n          query: gql`\n            {\n              a\n              d {\n                e\n                h {\n                  i\n                }\n              }\n            }\n          `,\n        }),\n      ).toEqual({\n        a: 1,\n        d: { __typename: 'Foo', e: 4, h: { i: 7, __typename: 'Bar' } },\n      });\n      expect(\n        client.readQuery({\n          query: gql`\n            {\n              a\n              b\n              c\n              d {\n                e\n                f\n                g\n                h {\n                  i\n                  j\n                  k\n                }\n              }\n            }\n          `,\n        }),\n      ).toEqual({\n        a: 1,\n        b: 2,\n        c: 3,\n        d: {\n          __typename: 'Foo',\n          e: 4,\n          f: 5,\n          g: 6,\n          h: { __typename: 'Bar', i: 7, j: 8, k: 9 },\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will read some data from the store with variables","suites":["ApolloClient","readQuery"],"updatePoint":{"line":205,"column":57},"line":205,"code":"    it('will read some data from the store with variables', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache().restore({\n          ROOT_QUERY: {\n            'field({\"literal\":true,\"value\":42})': 1,\n            'field({\"literal\":false,\"value\":42})': 2,\n          },\n        }),\n      });\n\n      expect(\n        client.readQuery({\n          query: gql`\n            query($literal: Boolean, $value: Int) {\n              a: field(literal: true, value: 42)\n              b: field(literal: $literal, value: $value)\n            }\n          `,\n          variables: {\n            literal: false,\n            value: 42,\n          },\n        }),\n      ).toEqual({ a: 1, b: 2 });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will read some data from the store with default values","suites":["ApolloClient","readQuery"],"updatePoint":{"line":233,"column":60},"line":233,"code":"  it('will read some data from the store with default values', () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache().restore({\n        ROOT_QUERY: {\n          'field({\"literal\":true,\"value\":-1})': 1,\n          'field({\"literal\":false,\"value\":42})': 2,\n        },\n      }),\n    });\n\n    expect(\n      client.readQuery({\n        query: gql`\n          query($literal: Boolean, $value: Int = -1) {\n            a: field(literal: $literal, value: $value)\n          }\n        `,\n        variables: {\n          literal: false,\n          value: 42,\n        },\n      }),\n    ).toEqual({ a: 2 });\n\n    expect(\n      client.readQuery({\n        query: gql`\n          query($literal: Boolean, $value: Int = -1) {\n            a: field(literal: $literal, value: $value)\n          }\n        `,\n        variables: {\n          literal: true,\n        },\n      }),\n    ).toEqual({ a: 1 });\n  });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will throw an error when there is no fragment","suites":["ApolloClient","readFragment"],"updatePoint":{"line":273,"column":53},"line":273,"code":"    it('will throw an error when there is no fragment', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      expect(() => {\n        client.readFragment({\n          id: 'x',\n          fragment: gql`\n            query {\n              a\n              b\n              c\n            }\n          `,\n        });\n      }).toThrowError(\n        'Found a query operation. No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n      expect(() => {\n        client.readFragment({\n          id: 'x',\n          fragment: gql`\n            schema {\n              query: Query\n            }\n          `,\n        });\n      }).toThrowError(\n        'Found 0 fragments. `fragmentName` must be provided when there is not exactly 1 fragment.',\n      );\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will throw an error when there is more than one fragment but no fragment name","suites":["ApolloClient","readFragment"],"updatePoint":{"line":307,"column":85},"line":307,"code":"    it('will throw an error when there is more than one fragment but no fragment name', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      expect(() => {\n        client.readFragment({\n          id: 'x',\n          fragment: gql`\n            fragment a on A {\n              a\n            }\n\n            fragment b on B {\n              b\n            }\n          `,\n        });\n      }).toThrowError(\n        'Found 2 fragments. `fragmentName` must be provided when there is not exactly 1 fragment.',\n      );\n      expect(() => {\n        client.readFragment({\n          id: 'x',\n          fragment: gql`\n            fragment a on A {\n              a\n            }\n\n            fragment b on B {\n              b\n            }\n\n            fragment c on C {\n              c\n            }\n          `,\n        });\n      }).toThrowError(\n        'Found 3 fragments. `fragmentName` must be provided when there is not exactly 1 fragment.',\n      );\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will read some deeply nested data from the store at any id","suites":["ApolloClient","readFragment"],"updatePoint":{"line":351,"column":66},"line":351,"code":"    it('will read some deeply nested data from the store at any id', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache().restore({\n          ROOT_QUERY: {\n            __typename: 'Foo',\n            a: 1,\n            b: 2,\n            c: 3,\n            d: makeReference('foo'),\n          },\n          foo: {\n            __typename: 'Foo',\n            e: 4,\n            f: 5,\n            g: 6,\n            h: makeReference('bar'),\n          },\n          bar: {\n            __typename: 'Bar',\n            i: 7,\n            j: 8,\n            k: 9,\n          },\n        }),\n      });\n\n      expect(\n        client.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment fragmentFoo on Foo {\n              e\n              h {\n                i\n              }\n            }\n          `,\n        }),\n      ).toEqual({ __typename: 'Foo', e: 4, h: { __typename: 'Bar', i: 7 } });\n      expect(\n        client.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment fragmentFoo on Foo {\n              e\n              f\n              g\n              h {\n                i\n                j\n                k\n              }\n            }\n          `,\n        }),\n      ).toEqual({\n        __typename: 'Foo',\n        e: 4,\n        f: 5,\n        g: 6,\n        h: { __typename: 'Bar', i: 7, j: 8, k: 9 },\n      });\n      expect(\n        client.readFragment({\n          id: 'bar',\n          fragment: gql`\n            fragment fragmentBar on Bar {\n              i\n            }\n          `,\n        }),\n      ).toEqual({ __typename: 'Bar', i: 7 });\n      expect(\n        client.readFragment({\n          id: 'bar',\n          fragment: gql`\n            fragment fragmentBar on Bar {\n              i\n              j\n              k\n            }\n          `,\n        }),\n      ).toEqual({ __typename: 'Bar', i: 7, j: 8, k: 9 });\n      expect(\n        client.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment fragmentFoo on Foo {\n              e\n              f\n              g\n              h {\n                i\n                j\n                k\n              }\n            }\n\n            fragment fragmentBar on Bar {\n              i\n              j\n              k\n            }\n          `,\n          fragmentName: 'fragmentFoo',\n        }),\n      ).toEqual({\n        __typename: 'Foo',\n        e: 4,\n        f: 5,\n        g: 6,\n        h: { __typename: 'Bar', i: 7, j: 8, k: 9 },\n      });\n      expect(\n        client.readFragment({\n          id: 'bar',\n          fragment: gql`\n            fragment fragmentFoo on Foo {\n              e\n              f\n              g\n              h {\n                i\n                j\n                k\n              }\n            }\n\n            fragment fragmentBar on Bar {\n              i\n              j\n              k\n            }\n          `,\n          fragmentName: 'fragmentBar',\n        }),\n      ).toEqual({ __typename: 'Bar', i: 7, j: 8, k: 9 });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will read some data from the store with variables","suites":["ApolloClient","readFragment"],"updatePoint":{"line":492,"column":57},"line":492,"code":"    it('will read some data from the store with variables', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache().restore({\n          foo: {\n            __typename: 'Foo',\n            'field({\"literal\":true,\"value\":42})': 1,\n            'field({\"literal\":false,\"value\":42})': 2,\n          },\n        }),\n      });\n\n      expect(\n        client.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment foo on Foo {\n              a: field(literal: true, value: 42)\n              b: field(literal: $literal, value: $value)\n            }\n          `,\n          variables: {\n            literal: false,\n            value: 42,\n          },\n        }),\n      ).toEqual({ __typename: 'Foo', a: 1, b: 2 });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will return null when an id that can’t be found is provided","suites":["ApolloClient","readFragment"],"updatePoint":{"line":521,"column":67},"line":521,"code":"    it('will return null when an id that can’t be found is provided', () => {\n      const client1 = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n      const client2 = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache().restore({\n          bar: { __typename: 'Foo', a: 1, b: 2, c: 3 },\n        }),\n      });\n      const client3 = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache().restore({\n          foo: { __typename: 'Foo', a: 1, b: 2, c: 3 },\n        }),\n      });\n\n      expect(\n        client1.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment fooFragment on Foo {\n              a\n              b\n              c\n            }\n          `,\n        }),\n      ).toBe(null);\n      expect(\n        client2.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment fooFragment on Foo {\n              a\n              b\n              c\n            }\n          `,\n        }),\n      ).toBe(null);\n      expect(\n        client3.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment fooFragment on Foo {\n              a\n              b\n              c\n            }\n          `,\n        }),\n      ).toEqual({ __typename: 'Foo', a: 1, b: 2, c: 3 });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will write some data to the store","suites":["ApolloClient","writeQuery"],"updatePoint":{"line":579,"column":41},"line":579,"code":"    it('will write some data to the store', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      client.writeQuery({\n        data: { a: 1 },\n        query: gql`\n          {\n            a\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          a: 1,\n        },\n      });\n\n      client.writeQuery({\n        data: { b: 2, c: 3 },\n        query: gql`\n          {\n            b\n            c\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          a: 1,\n          b: 2,\n          c: 3,\n        },\n      });\n\n      client.writeQuery({\n        data: { a: 4, b: 5, c: 6 },\n        query: gql`\n          {\n            a\n            b\n            c\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          a: 4,\n          b: 5,\n          c: 6,\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will write some deeply nested data to the store","suites":["ApolloClient","writeQuery"],"updatePoint":{"line":641,"column":55},"line":641,"code":"    it('will write some deeply nested data to the store', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache({\n          typePolicies: {\n            Query: {\n              fields: {\n                d: {\n                  // Silence \"Cache data may be lost...\"  warnings by\n                  // unconditionally favoring the incoming data.\n                  merge: false,\n                },\n              },\n            },\n          },\n        }),\n      });\n\n      client.writeQuery({\n        data: { a: 1, d: { __typename: 'D', e: 4 } },\n        query: gql`\n          {\n            a\n            d {\n              e\n            }\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n\n      client.writeQuery({\n        data: { a: 1, d: { __typename: 'D', h: { __typename: 'H', i: 7 } } },\n        query: gql`\n          {\n            a\n            d {\n              h {\n                i\n              }\n            }\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n\n      client.writeQuery({\n        data: {\n          a: 1,\n          b: 2,\n          c: 3,\n          d: {\n            __typename: 'D',\n            e: 4,\n            f: 5,\n            g: 6,\n            h: {\n              __typename: 'H',\n              i: 7,\n              j: 8,\n              k: 9,\n            },\n          },\n        },\n        query: gql`\n          {\n            a\n            b\n            c\n            d {\n              e\n              f\n              g\n              h {\n                i\n                j\n                k\n              }\n            }\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will write some data to the store with variables","suites":["ApolloClient","writeQuery"],"updatePoint":{"line":729,"column":56},"line":729,"code":"    it('will write some data to the store with variables', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      client.writeQuery({\n        data: {\n          a: 1,\n          b: 2,\n        },\n        query: gql`\n          query($literal: Boolean, $value: Int) {\n            a: field(literal: true, value: 42)\n            b: field(literal: $literal, value: $value)\n          }\n        `,\n        variables: {\n          literal: false,\n          value: 42,\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          'field({\"literal\":true,\"value\":42})': 1,\n          'field({\"literal\":false,\"value\":42})': 2,\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will write some data to the store with default values for variables","suites":["ApolloClient","writeQuery"],"updatePoint":{"line":761,"column":75},"line":761,"code":"    it('will write some data to the store with default values for variables', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      client.writeQuery({\n        data: {\n          a: 2,\n        },\n        query: gql`\n          query($literal: Boolean, $value: Int = -1) {\n            a: field(literal: $literal, value: $value)\n          }\n        `,\n        variables: {\n          literal: true,\n          value: 42,\n        },\n      });\n\n      client.writeQuery({\n        data: {\n          a: 1,\n        },\n        query: gql`\n          query($literal: Boolean, $value: Int = -1) {\n            a: field(literal: $literal, value: $value)\n          }\n        `,\n        variables: {\n          literal: false,\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          'field({\"literal\":true,\"value\":42})': 2,\n          'field({\"literal\":false,\"value\":-1})': 1,\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will throw an error when there is no fragment","suites":["ApolloClient","writeFragment"],"updatePoint":{"line":838,"column":53},"line":838,"code":"    it('will throw an error when there is no fragment', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      expect(() => {\n        client.writeFragment({\n          data: {},\n          id: 'x',\n          fragment: gql`\n            query {\n              a\n              b\n              c\n            }\n          `,\n        });\n      }).toThrowError(\n        'Found a query operation. No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n      expect(() => {\n        client.writeFragment({\n          data: {},\n          id: 'x',\n          fragment: gql`\n            schema {\n              query: Query\n            }\n          `,\n        });\n      }).toThrowError(\n        'Found 0 fragments. `fragmentName` must be provided when there is not exactly 1 fragment.',\n      );\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will throw an error when there is more than one fragment but no fragment name","suites":["ApolloClient","writeFragment"],"updatePoint":{"line":874,"column":85},"line":874,"code":"    it('will throw an error when there is more than one fragment but no fragment name', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      expect(() => {\n        client.writeFragment({\n          data: {},\n          id: 'x',\n          fragment: gql`\n            fragment a on A {\n              a\n            }\n\n            fragment b on B {\n              b\n            }\n          `,\n        });\n      }).toThrowError(\n        'Found 2 fragments. `fragmentName` must be provided when there is not exactly 1 fragment.',\n      );\n      expect(() => {\n        client.writeFragment({\n          data: {},\n          id: 'x',\n          fragment: gql`\n            fragment a on A {\n              a\n            }\n\n            fragment b on B {\n              b\n            }\n\n            fragment c on C {\n              c\n            }\n          `,\n        });\n      }).toThrowError(\n        'Found 3 fragments. `fragmentName` must be provided when there is not exactly 1 fragment.',\n      );\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will write some deeply nested data into the store at any id","suites":["ApolloClient","writeFragment"],"updatePoint":{"line":920,"column":67},"line":920,"code":"    it('will write some deeply nested data into the store at any id', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache({ dataIdFromObject: (o: any) => o.id }),\n      });\n\n      client.writeFragment({\n        data: {\n          __typename: 'Foo',\n          e: 4,\n          h: { __typename: 'Bar', id: 'bar', i: 7 },\n        },\n        id: 'foo',\n        fragment: gql`\n          fragment fragmentFoo on Foo {\n            e\n            h {\n              i\n            }\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n\n      client.writeFragment({\n        data: {\n          __typename: 'Foo',\n          f: 5,\n          g: 6,\n          h: { __typename: 'Bar', id: 'bar', j: 8, k: 9 },\n        },\n        id: 'foo',\n        fragment: gql`\n          fragment fragmentFoo on Foo {\n            f\n            g\n            h {\n              j\n              k\n            }\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n\n      client.writeFragment({\n        data: { __typename: 'Bar', i: 10 },\n        id: 'bar',\n        fragment: gql`\n          fragment fragmentBar on Bar {\n            i\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n\n      client.writeFragment({\n        data: { __typename: 'Bar', j: 11, k: 12 },\n        id: 'bar',\n        fragment: gql`\n          fragment fragmentBar on Bar {\n            j\n            k\n          }\n        `,\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n\n      client.writeFragment({\n        data: {\n          __typename: 'Foo',\n          e: 4,\n          f: 5,\n          g: 6,\n          h: { __typename: 'Bar', id: 'bar', i: 7, j: 8, k: 9 },\n        },\n        id: 'foo',\n        fragment: gql`\n          fragment fooFragment on Foo {\n            e\n            f\n            g\n            h {\n              i\n              j\n              k\n            }\n          }\n\n          fragment barFragment on Bar {\n            i\n            j\n            k\n          }\n        `,\n        fragmentName: 'fooFragment',\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n\n      client.writeFragment({\n        data: { __typename: 'Bar', i: 10, j: 11, k: 12 },\n        id: 'bar',\n        fragment: gql`\n          fragment fooFragment on Foo {\n            e\n            f\n            g\n            h {\n              i\n              j\n              k\n            }\n          }\n\n          fragment barFragment on Bar {\n            i\n            j\n            k\n          }\n        `,\n        fragmentName: 'barFragment',\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will write some data to the store with variables","suites":["ApolloClient","writeFragment"],"updatePoint":{"line":1051,"column":56},"line":1051,"code":"    it('will write some data to the store with variables', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      client.writeFragment({\n        data: {\n          __typename: 'Foo',\n          a: 1,\n          b: 2,\n        },\n        id: 'foo',\n        fragment: gql`\n          fragment foo on Foo {\n            a: field(literal: true, value: 42)\n            b: field(literal: $literal, value: $value)\n          }\n        `,\n        variables: {\n          literal: false,\n          value: 42,\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        __META: {\n          extraRootIds: ['foo'],\n        },\n        foo: {\n          __typename: 'Foo',\n          'field({\"literal\":true,\"value\":42})': 1,\n          'field({\"literal\":false,\"value\":42})': 2,\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"with TypedDocumentNode","suites":["ApolloClient","writeFragment","change will call observable next","using writeQuery"],"updatePoint":{"line":1181,"column":34},"line":1181,"code":"        it('with TypedDocumentNode', async () => {\n          const client = newClient();\n\n          // This is defined manually for the purpose of the test, but\n          // eventually this could be generated with graphql-code-generator\n          const typedQuery: TypedDocumentNode<Data, { testVar: string }> = query;\n\n          // The result and variables are being typed automatically, based on the query object we pass,\n          // and type inference is done based on the TypeDocumentNode object.\n          const result = await client.query({ query: typedQuery, variables: { testVar: 'foo' } });\n\n          // Just try to access it, if something will break, TS will throw an error\n          // during the test\n          result.data?.people.friends[0].id;\n        });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will write data locally which will then be read back","suites":["ApolloClient","write then read"],"updatePoint":{"line":1428,"column":60},"line":1428,"code":"    it('will write data locally which will then be read back', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache({\n          dataIdFromObject(object) {\n            if (typeof object.__typename === 'string') {\n              return object.__typename.toLowerCase();\n            }\n          },\n        }).restore({\n          foo: {\n            __typename: 'Foo',\n            a: 1,\n            b: 2,\n            c: 3,\n            bar: makeReference('bar'),\n          },\n          bar: {\n            __typename: 'Bar',\n            d: 4,\n            e: 5,\n            f: 6,\n          },\n        }),\n      });\n\n      expect(\n        client.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment x on Foo {\n              a\n              b\n              c\n              bar {\n                d\n                e\n                f\n              }\n            }\n          `,\n        }),\n      ).toEqual({\n        __typename: 'Foo',\n        a: 1,\n        b: 2,\n        c: 3,\n        bar: { d: 4, e: 5, f: 6, __typename: 'Bar' },\n      });\n\n      client.writeFragment({\n        id: 'foo',\n        fragment: gql`\n          fragment x on Foo {\n            a\n          }\n        `,\n        data: { __typename: 'Foo', a: 7 },\n      });\n\n      expect(\n        client.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment x on Foo {\n              a\n              b\n              c\n              bar {\n                d\n                e\n                f\n              }\n            }\n          `,\n        }),\n      ).toEqual({\n        __typename: 'Foo',\n        a: 7,\n        b: 2,\n        c: 3,\n        bar: { __typename: 'Bar', d: 4, e: 5, f: 6 },\n      });\n\n      client.writeFragment({\n        id: 'foo',\n        fragment: gql`\n          fragment x on Foo {\n            bar {\n              d\n            }\n          }\n        `,\n        data: { __typename: 'Foo', bar: { __typename: 'Bar', d: 8 } },\n      });\n\n      expect(\n        client.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment x on Foo {\n              a\n              b\n              c\n              bar {\n                d\n                e\n                f\n              }\n            }\n          `,\n        }),\n      ).toEqual({\n        __typename: 'Foo',\n        a: 7,\n        b: 2,\n        c: 3,\n        bar: { __typename: 'Bar', d: 8, e: 5, f: 6 },\n      });\n\n      client.writeFragment({\n        id: 'bar',\n        fragment: gql`\n          fragment y on Bar {\n            e\n          }\n        `,\n        data: { __typename: 'Bar', e: 9 },\n      });\n\n      expect(\n        client.readFragment({\n          id: 'foo',\n          fragment: gql`\n            fragment x on Foo {\n              a\n              b\n              c\n              bar {\n                d\n                e\n                f\n              }\n            }\n          `,\n        }),\n      ).toEqual({\n        __typename: 'Foo',\n        a: 7,\n        b: 2,\n        c: 3,\n        bar: { __typename: 'Bar', d: 8, e: 9, f: 6 },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will write data to a specific id","suites":["ApolloClient","write then read"],"updatePoint":{"line":1585,"column":40},"line":1585,"code":"    it('will write data to a specific id', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache({\n          dataIdFromObject: (o: any) => o.key,\n        }),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                key\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: {\n            __typename: 'foo',\n            c: 3,\n            d: 4,\n            bar: { key: 'foobar', __typename: 'bar', e: 5, f: 6 },\n          },\n        },\n      });\n\n      expect(\n        client.readQuery({\n          query: gql`\n            {\n              a\n              b\n              foo {\n                c\n                d\n                bar {\n                  key\n                  e\n                  f\n                }\n              }\n            }\n          `,\n        }),\n      ).toEqual({\n        a: 1,\n        b: 2,\n        foo: {\n          __typename: 'foo',\n          c: 3,\n          d: 4,\n          bar: { __typename: 'bar', key: 'foobar', e: 5, f: 6 },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will not use a default id getter if __typename is not present","suites":["ApolloClient","write then read"],"updatePoint":{"line":1653,"column":69},"line":1653,"code":"    it('will not use a default id getter if __typename is not present', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache({\n          addTypename: false,\n        }),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                id\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: { c: 3, d: 4, bar: { id: 'foobar', e: 5, f: 6 } },\n        },\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            g\n            h\n            bar {\n              i\n              j\n              foo {\n                _id\n                k\n                l\n              }\n            }\n          }\n        `,\n        data: {\n          g: 8,\n          h: 9,\n          bar: { i: 10, j: 11, foo: { _id: 'barfoo', k: 12, l: 13 } },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          a: 1,\n          b: 2,\n          g: 8,\n          h: 9,\n          bar: {\n            i: 10,\n            j: 11,\n            foo: {\n              _id: 'barfoo',\n              k: 12,\n              l: 13,\n            },\n          },\n          foo: {\n            c: 3,\n            d: 4,\n            bar: {\n              id: 'foobar',\n              e: 5,\n              f: 6,\n            },\n          },\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will not use a default id getter if id and _id are not present","suites":["ApolloClient","write then read"],"updatePoint":{"line":1736,"column":70},"line":1736,"code":"    it('will not use a default id getter if id and _id are not present', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: {\n            __typename: 'foo',\n            c: 3,\n            d: 4,\n            bar: { __typename: 'bar', e: 5, f: 6 },\n          },\n        },\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            g\n            h\n            bar {\n              i\n              j\n              foo {\n                k\n                l\n              }\n            }\n          }\n        `,\n        data: {\n          g: 8,\n          h: 9,\n          bar: {\n            __typename: 'bar',\n            i: 10,\n            j: 11,\n            foo: { __typename: 'foo', k: 12, l: 13 },\n          },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will use a default id getter if __typename and id are present","suites":["ApolloClient","write then read"],"updatePoint":{"line":1799,"column":69},"line":1799,"code":"    it('will use a default id getter if __typename and id are present', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                id\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: {\n            __typename: 'foo',\n            c: 3,\n            d: 4,\n            bar: { __typename: 'bar', id: 'foobar', e: 5, f: 6 },\n          },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will use a default id getter if __typename and _id are present","suites":["ApolloClient","write then read"],"updatePoint":{"line":1836,"column":70},"line":1836,"code":"    it('will use a default id getter if __typename and _id are present', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                _id\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: {\n            __typename: 'foo',\n            c: 3,\n            d: 4,\n            bar: { __typename: 'bar', _id: 'foobar', e: 5, f: 6 },\n          },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will not use a default id getter if id is present and __typename is not present","suites":["ApolloClient","write then read"],"updatePoint":{"line":1873,"column":87},"line":1873,"code":"    it('will not use a default id getter if id is present and __typename is not present', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache({\n          addTypename: false,\n        }),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                id\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: { c: 3, d: 4, bar: { id: 'foobar', e: 5, f: 6 } },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          a: 1,\n          b: 2,\n          foo: {\n            c: 3,\n            d: 4,\n            bar: {\n              id: 'foobar',\n              e: 5,\n              f: 6,\n            },\n          },\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will not use a default id getter if _id is present but __typename is not present","suites":["ApolloClient","write then read"],"updatePoint":{"line":1922,"column":88},"line":1922,"code":"    it('will not use a default id getter if _id is present but __typename is not present', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache({\n          addTypename: false,\n        }),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                _id\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: { c: 3, d: 4, bar: { _id: 'foobar', e: 5, f: 6 } },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          a: 1,\n          b: 2,\n          foo: {\n            c: 3,\n            d: 4,\n            bar: {\n              _id: 'foobar',\n              e: 5,\n              f: 6,\n            },\n          },\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will not use a default id getter if either _id or id is present when __typename is not also present","suites":["ApolloClient","write then read"],"updatePoint":{"line":1971,"column":107},"line":1971,"code":"    it('will not use a default id getter if either _id or id is present when __typename is not also present', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache({\n          addTypename: false,\n        }),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                id\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: {\n            c: 3,\n            d: 4,\n            bar: { __typename: 'bar', id: 'foobar', e: 5, f: 6 },\n          },\n        },\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            g\n            h\n            bar {\n              i\n              j\n              foo {\n                _id\n                k\n                l\n              }\n            }\n          }\n        `,\n        data: {\n          g: 8,\n          h: 9,\n          bar: { i: 10, j: 11, foo: { _id: 'barfoo', k: 12, l: 13 } },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"will use a default id getter if one is not specified and __typename is present along with either _id or id","suites":["ApolloClient","write then read"],"updatePoint":{"line":2032,"column":114},"line":2032,"code":"    it('will use a default id getter if one is not specified and __typename is present along with either _id or id', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            a\n            b\n            foo {\n              c\n              d\n              bar {\n                id\n                e\n                f\n              }\n            }\n          }\n        `,\n        data: {\n          a: 1,\n          b: 2,\n          foo: {\n            __typename: 'foo',\n            c: 3,\n            d: 4,\n            bar: { __typename: 'bar', id: 'foobar', e: 5, f: 6 },\n          },\n        },\n      });\n\n      client.writeQuery({\n        query: gql`\n          {\n            g\n            h\n            bar {\n              i\n              j\n              foo {\n                _id\n                k\n                l\n              }\n            }\n          }\n        `,\n        data: {\n          g: 8,\n          h: 9,\n          bar: {\n            __typename: 'bar',\n            i: 10,\n            j: 11,\n            foo: { __typename: 'foo', _id: 'barfoo', k: 12, l: 13 },\n          },\n        },\n      });\n\n      expect((client.cache as InMemoryCache).extract()).toMatchSnapshot();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set `defaultOptions` using options passed into the constructor","suites":["ApolloClient","defaultOptions"],"updatePoint":{"line":2178,"column":77},"line":2178,"code":"    it('should set `defaultOptions` using options passed into the constructor', () => {\n      const defaultOptions: DefaultOptions = {\n        query: {\n          fetchPolicy: 'no-cache',\n        },\n      };\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n        defaultOptions,\n      });\n      expect(client.defaultOptions).toEqual(defaultOptions);\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use default options (unless overridden) when querying","suites":["ApolloClient","defaultOptions"],"updatePoint":{"line":2192,"column":68},"line":2192,"code":"    it('should use default options (unless overridden) when querying', async () => {\n      const defaultOptions: DefaultOptions = {\n        query: {\n          fetchPolicy: 'no-cache',\n        },\n      };\n\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n        defaultOptions,\n      });\n\n      let queryOptions: QueryOptions = {\n        query: gql`\n          {\n            a\n          }\n        `,\n      };\n\n      // @ts-ignore\n      const queryManager = client.queryManager;\n      const _query = queryManager.query;\n      queryManager.query = options => {\n        queryOptions = options;\n        return _query(options);\n      };\n\n      try {\n        await client.query({\n          query: gql`\n            {\n              a\n            }\n          `,\n        });\n      } catch (error) {\n        // Swallow errors caused by mocking; not part of this test\n      }\n\n      expect(queryOptions.fetchPolicy).toEqual(\n        defaultOptions.query!.fetchPolicy,\n      );\n\n      client.stop();\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be able to set all default query options","suites":["ApolloClient","defaultOptions"],"updatePoint":{"line":2240,"column":55},"line":2240,"code":"    it('should be able to set all default query options', () => {\n      new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n        defaultOptions: {\n          query: {\n            query: {kind: Kind.DOCUMENT, definitions: []},\n            variables: {foo: 'bar'},\n            errorPolicy: 'none',\n            context: undefined,\n            fetchPolicy: 'cache-first',\n            pollInterval: 100,\n            notifyOnNetworkStatusChange: true,\n            returnPartialData: true,\n            partialRefetch: true,\n          },\n        },\n      });\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove all data from the store","suites":["ApolloClient","clearStore"],"updatePoint":{"line":2262,"column":45},"line":2262,"code":"    it('should remove all data from the store', async () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n      interface Data {\n        a: number;\n      }\n      client.writeQuery<Data>({\n        data: { a: 1 },\n        query: gql`\n          {\n            a\n          }\n        `,\n      });\n\n      expect((client.cache as any).data.data).toEqual({\n        ROOT_QUERY: {\n          __typename: \"Query\",\n          a: 1,\n        },\n      });\n\n      await client.clearStore();\n      expect((client.cache as any).data.data).toEqual({});\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"should override default link with newly set link","suites":["ApolloClient","setLink"],"updatePoint":{"line":2292,"column":56},"line":2292,"code":"    it('should override default link with newly set link', async () => {\n      const client = new ApolloClient({\n        cache: new InMemoryCache()\n      });\n      expect(client.link).toBeDefined();\n\n      const newLink = new ApolloLink(operation => {\n        return new Observable(observer => {\n          observer.next({\n            data: {\n              widgets: [\n                { name: 'Widget 1'},\n                { name: 'Widget 2' }\n              ]\n            }\n          });\n          observer.complete();\n        });\n      });\n\n      client.setLink(newLink);\n\n      const { data } = await client.query({ query: gql`{ widgets }` });\n      expect(data.widgets).toBeDefined();\n      expect(data.widgets.length).toBe(2);\n    });","file":"ApolloClient.ts","skipped":false,"dir":"src/__tests__"},{"name":"can be loaded via require","suites":["client"],"updatePoint":{"line":27,"column":31},"line":27,"code":"  it('can be loaded via require', () => {\n    /* tslint:disable */\n    const ApolloClientRequire = require('../').ApolloClient;\n    /* tslint:enable */\n\n    const client = new ApolloClientRequire({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    expect(client.queryManager).toBeDefined();\n    expect(client.cache).toBeDefined();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"can allow passing in a link","suites":["client"],"updatePoint":{"line":41,"column":33},"line":41,"code":"  it('can allow passing in a link', () => {\n    const link = ApolloLink.empty();\n    const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache(),\n    });\n\n    expect(client.link).toBeInstanceOf(ApolloLink);\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw an error if query option is missing or not wrapped with a \"gql\" tag","suites":["client"],"updatePoint":{"line":51,"column":86},"line":51,"code":"  it('should throw an error if query option is missing or not wrapped with a \"gql\" tag', () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    expect(() => {\n      client.query(gql`\n        {\n          a\n        }\n      ` as any);\n    }).toThrowError(\n      'query option is required. You must specify your GraphQL document in the query option.',\n    );\n    expect(() => {\n      client.query({ query: '{ a }' } as any);\n    }).toThrowError('You must wrap the query string in a \"gql\" tag.');\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw an error if mutation option is missing","suites":["client"],"updatePoint":{"line":71,"column":57},"line":71,"code":"  it('should throw an error if mutation option is missing', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    return await expect(\n      client.mutate({\n        query: gql`\n          {\n            a\n          }\n        `,\n      } as any),\n    ).rejects.toThrow(\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not warn when receiving multiple results from apollo-link network interface","suites":["client"],"updatePoint":{"line":662,"column":88},"line":662,"code":"  it('should not warn when receiving multiple results from apollo-link network interface', () => {\n    const query = gql`\n      query people {\n        allPeople(first: 1) {\n          people {\n            name\n          }\n        }\n      }\n    `;\n\n    const data = {\n      allPeople: {\n        people: [\n          {\n            name: 'Luke Skywalker',\n          },\n        ],\n      },\n    };\n\n    const link = ApolloLink.from([() => Observable.of({ data }, { data })]);\n\n    const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache({ addTypename: false }),\n    });\n\n    return client.query({ query }).then((result: ExecutionResult) => {\n      expect(result.data).toEqual(data);\n    });\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send operationName along with the query to the server","suites":["client"],"updatePoint":{"line":1291,"column":66},"line":1291,"code":"  it('should send operationName along with the query to the server', () => {\n    const query = gql`\n      query myQueryName {\n        fortuneCookie\n      }\n    `;\n    const data = {\n      fortuneCookie: 'The waiter spit in your food',\n    };\n    const link = ApolloLink.from([\n      request => {\n        expect(request.operationName).toBe('myQueryName');\n        return Observable.of({ data });\n      },\n    ]);\n    const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache({ addTypename: false }),\n    });\n\n    return client.query({ query }).then(actualResult => {\n      expect(actualResult.data).toEqual(data);\n    });\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send operationName along with the mutation to the server","suites":["client"],"updatePoint":{"line":1316,"column":69},"line":1316,"code":"  it('should send operationName along with the mutation to the server', () => {\n    const mutation = gql`\n      mutation myMutationName {\n        fortuneCookie\n      }\n    `;\n    const data = {\n      fortuneCookie: 'The waiter spit in your food',\n    };\n    const link = ApolloLink.from([\n      request => {\n        expect(request.operationName).toBe('myMutationName');\n        return Observable.of({ data });\n      },\n    ]);\n    const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache({ addTypename: false }),\n    });\n\n    return client.mutate({ mutation }).then(actualResult => {\n      expect(actualResult.data).toEqual(data);\n    });\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"deduplicates queries if query context.queryDeduplication is set to true","suites":["client"],"updatePoint":{"line":1433,"column":77},"line":1433,"code":"  it('deduplicates queries if query context.queryDeduplication is set to true', () => {\n    const queryDoc = gql`\n      query {\n        author {\n          name\n        }\n      }\n    `;\n    const data = {\n      author: {\n        name: 'Jonas',\n      },\n    };\n    const data2 = {\n      author: {\n        name: 'Dhaivat',\n      },\n    };\n\n    // we have two responses for identical queries, but only the first should be requested.\n    // the second one should never make it through to the network interface.\n    const link = mockSingleLink(\n      {\n        request: { query: queryDoc },\n        result: { data },\n        delay: 10,\n      },\n      {\n        request: { query: queryDoc },\n        result: { data: data2 },\n      },\n    );\n    const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache({ addTypename: false }),\n      queryDeduplication: false,\n    });\n\n    // Both queries need to be deduplicated, otherwise only one gets tracked\n    const q1 = client.query({ query: queryDoc, context: { queryDeduplication: true } });\n    const q2 = client.query({ query: queryDoc, context: { queryDeduplication: true } });\n\n    // if deduplication happened, result2.data will equal data.\n    return Promise.all([q1, q2]).then(([result1, result2]) => {\n      expect(result1.data).toEqual(data);\n      expect(result2.data).toEqual(data);\n    });\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"does not deduplicate queries if query context.queryDeduplication is set to false","suites":["client"],"updatePoint":{"line":1482,"column":86},"line":1482,"code":"  it('does not deduplicate queries if query context.queryDeduplication is set to false', () => {\n    const queryDoc = gql`\n      query {\n        author {\n          name\n        }\n      }\n    `;\n    const data = {\n      author: {\n        name: 'Jonas',\n      },\n    };\n    const data2 = {\n      author: {\n        name: 'Dhaivat',\n      },\n    };\n\n    // we have two responses for identical queries, and both should be requested.\n    // the second one should make it through to the network interface.\n    const link = mockSingleLink(\n      {\n        request: { query: queryDoc },\n        result: { data },\n        delay: 10,\n      },\n      {\n        request: { query: queryDoc },\n        result: { data: data2 },\n      },\n    );\n    const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache({ addTypename: false }),\n    });\n\n    // The first query gets tracked in the dedup logic, the second one ignores it and runs anyways\n    const q1 = client.query({ query: queryDoc });\n    const q2 = client.query({ query: queryDoc, context: { queryDeduplication: false } });\n\n    // if deduplication happened, result2.data will equal data.\n    return Promise.all([q1, q2]).then(([result1, result2]) => {\n      expect(result1.data).toEqual(data);\n      expect(result2.data).toEqual(data2);\n    });\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"errors when returnPartialData is used on query","suites":["client","deprecated options"],"updatePoint":{"line":1582,"column":54},"line":1582,"code":"    it('errors when returnPartialData is used on query', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n      expect(() => {\n        client.query({ query, returnPartialData: true } as QueryOptions);\n      }).toThrowError(/returnPartialData/);\n    });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"errors when returnPartialData is used on watchQuery","suites":["client","deprecated options"],"updatePoint":{"line":1592,"column":59},"line":1592,"code":"    it('errors when returnPartialData is used on watchQuery', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n      expect(() => {\n        client.query({ query, returnPartialData: true } as QueryOptions);\n      }).toThrowError(/returnPartialData/);\n    });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"warns when used with client.query","suites":["client","cache-and-network fetchPolicy"],"updatePoint":{"line":1687,"column":41},"line":1687,"code":"    it('warns when used with client.query', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n      });\n\n      checkCacheAndNetworkError(\n        () => client.query({\n          query,\n          fetchPolicy: 'cache-and-network' as FetchPolicy,\n        }),\n      );\n    });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"warns when used with client.query with defaultOptions","suites":["client","cache-and-network fetchPolicy"],"updatePoint":{"line":1701,"column":61},"line":1701,"code":"    it('warns when used with client.query with defaultOptions', () => {\n      const client = new ApolloClient({\n        link: ApolloLink.empty(),\n        cache: new InMemoryCache(),\n        defaultOptions: {\n          query: {\n            fetchPolicy: 'cache-and-network' as FetchPolicy,\n          },\n        },\n      });\n\n      checkCacheAndNetworkError(() => client.query({\n        query,\n        // This undefined value should be ignored in favor of\n        // defaultOptions.query.fetchPolicy.\n        fetchPolicy: void 0,\n      }));\n    });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"has a clearStore method which calls QueryManager","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2228,"column":54},"line":2228,"code":"  it('has a clearStore method which calls QueryManager', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    // @ts-ignore\n    const spy = jest.spyOn(client.queryManager, 'clearStore');\n    await client.clearStore();\n    expect(spy).toHaveBeenCalled();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"has an onClearStore method which takes a callback to be called after clearStore","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2240,"column":85},"line":2240,"code":"  it('has an onClearStore method which takes a callback to be called after clearStore', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    const onClearStore = jest.fn();\n    client.onClearStore(onClearStore);\n\n    await client.clearStore();\n\n    expect(onClearStore).toHaveBeenCalled();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"onClearStore returns a method that unsubscribes the callback","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2254,"column":66},"line":2254,"code":"  it('onClearStore returns a method that unsubscribes the callback', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    const onClearStore = jest.fn();\n    const unsubscribe = client.onClearStore(onClearStore);\n\n    unsubscribe();\n\n    await client.clearStore();\n    expect(onClearStore).not.toHaveBeenCalled();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"has a resetStore method which calls QueryManager","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2269,"column":54},"line":2269,"code":"  it('has a resetStore method which calls QueryManager', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    // @ts-ignore\n    const spy = jest.spyOn(client.queryManager, 'clearStore');\n    await client.resetStore();\n    expect(spy).toHaveBeenCalled();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"has an onResetStore method which takes a callback to be called after resetStore","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2281,"column":85},"line":2281,"code":"  it('has an onResetStore method which takes a callback to be called after resetStore', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    const onResetStore = jest.fn();\n    client.onResetStore(onResetStore);\n\n    await client.resetStore();\n\n    expect(onResetStore).toHaveBeenCalled();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"onResetStore returns a method that unsubscribes the callback","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2295,"column":66},"line":2295,"code":"  it('onResetStore returns a method that unsubscribes the callback', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    const onResetStore = jest.fn();\n    const unsubscribe = client.onResetStore(onResetStore);\n\n    unsubscribe();\n\n    await client.resetStore();\n    expect(onResetStore).not.toHaveBeenCalled();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"resetStore waits until all onResetStore callbacks are called","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2310,"column":66},"line":2310,"code":"  it('resetStore waits until all onResetStore callbacks are called', async () => {\n    const delay = (time: number) => new Promise(r => setTimeout(r, time));\n\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    let count = 0;\n    const onResetStoreOne = jest.fn(async () => {\n      expect(count).toEqual(0);\n      await delay(10).then(() => count++);\n      expect(count).toEqual(1);\n    });\n\n    const onResetStoreTwo = jest.fn(async () => {\n      expect(count).toEqual(0);\n      await delay(11).then(() => count++);\n      expect(count).toEqual(2);\n    });\n\n    client.onResetStore(onResetStoreOne);\n    client.onResetStore(onResetStoreTwo);\n\n    expect(count).toEqual(0);\n    await client.resetStore();\n    expect(count).toEqual(2);\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"has a reFetchObservableQueries method which calls QueryManager","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2431,"column":68},"line":2431,"code":"  it('has a reFetchObservableQueries method which calls QueryManager', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    // @ts-ignore\n    const spy = jest.spyOn(client.queryManager, 'reFetchObservableQueries');\n    await client.reFetchObservableQueries();\n    expect(spy).toHaveBeenCalled();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"has a refetchQueries method which calls QueryManager","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2443,"column":58},"line":2443,"code":"  it('has a refetchQueries method which calls QueryManager', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    const spy = jest.spyOn(client['queryManager'], 'refetchQueries');\n    spy.mockImplementation(() => new Map);\n\n    const options = { include: ['Author1'] };\n    await client.refetchQueries(options);\n\n    expect(spy).toHaveBeenCalledWith(options);\n    spy.mockRestore();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"has a getObservableQueries method which calls QueryManager","suites":["client","network-only fetchPolicy"],"updatePoint":{"line":2459,"column":64},"line":2459,"code":"  it('has a getObservableQueries method which calls QueryManager', async () => {\n    const client = new ApolloClient({\n      link: ApolloLink.empty(),\n      cache: new InMemoryCache(),\n    });\n\n    // @ts-ignore\n    const spy = jest.spyOn(client.queryManager, 'getObservableQueries');\n    await client.getObservableQueries();\n    expect(spy).toHaveBeenCalled();\n  });","file":"client.ts","skipped":false,"dir":"src/__tests__"},{"name":"completeness","suites":["exports of public entry points"],"updatePoint":{"line":76,"column":18},"line":76,"code":"  it(\"completeness\", () => {\n    const { join } = require(\"path\").posix;\n    entryPoints.forEach((info: Record<string, any>) => {\n      const id = join(\"@apollo/client\", ...info.dirs);\n      expect(testedIds).toContain(id);\n    });\n  });","file":"exports.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw an error if the result has errors on it","suites":["GraphQL Subscriptions"],"updatePoint":{"line":181,"column":58},"line":181,"code":"  it('should throw an error if the result has errors on it', () => {\n    const link = mockObservableLink();\n    const queryManager = new QueryManager({\n      link,\n      cache: new InMemoryCache({ addTypename: false }),\n    });\n\n    const obs = queryManager.startGraphQLSubscription(options);\n\n    const promises = [];\n    for (let i = 0; i < 2; i += 1) {\n      promises.push(\n        new Promise<void>((resolve, reject) => {\n          obs.subscribe({\n            next(result) {\n              reject('Should have hit the error block');\n            },\n            error(error) {\n              expect(error).toMatchSnapshot();\n              resolve();\n            },\n          });\n        }),\n      );\n    }\n\n    const errorResult = {\n      result: {\n        data: null,\n        errors: [\n          {\n            message: 'This is an error',\n            locations: [\n              {\n                column: 3,\n                line: 2,\n              },\n            ],\n            path: ['result'],\n          } as any,\n        ],\n      },\n    };\n\n    link.simulateResult(errorResult);\n    return Promise.all(promises);\n  });","file":"graphqlSubscriptions.ts","skipped":false,"dir":"src/__tests__"},{"name":"should call complete handler when the subscription completes","suites":["GraphQL Subscriptions"],"updatePoint":{"line":229,"column":66},"line":229,"code":"  it('should call complete handler when the subscription completes', () => {\n    const link = mockObservableLink();\n    const client = new ApolloClient({\n      link,\n      cache: new InMemoryCache({ addTypename: false }),\n    });\n\n    return new Promise<void>(resolve => {\n      client.subscribe(defaultOptions).subscribe({\n        complete() {\n          resolve();\n        },\n      });\n      setTimeout(() => link.simulateComplete(), 100);\n    });\n  });","file":"graphqlSubscriptions.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not add __typename to @export-ed objects (#4691)","suites":["@client @export tests"],"updatePoint":{"line":590,"column":61},"line":590,"code":"  it('should not add __typename to @export-ed objects (#4691)', () => {\n    const query = gql`\n      query GetListItems($where: LessonFilter) {\n        currentFilter @client @export(as: \"where\") {\n          title_contains\n          enabled\n        }\n        lessonCollection(where: $where) {\n          items {\n            title\n            slug\n          }\n        }\n      }\n    `;\n\n    const expectedServerQuery = gql`\n      query GetListItems($where: LessonFilter) {\n        lessonCollection(where: $where) {\n          items {\n            title\n            slug\n            __typename\n          }\n          __typename\n        }\n      }\n    `;\n\n    const currentFilter = {\n      title_contains: 'full',\n      enabled: true,\n    };\n\n    const data = {\n      lessonCollection: {\n        __typename: 'LessonCollection',\n        items: [\n          {\n            __typename: 'ListItem',\n            title: 'full title',\n            slug: 'slug-title',\n          },\n        ],\n      },\n    };\n\n    const client = new ApolloClient({\n      link: new ApolloLink(request => {\n        expect(request.variables.where).toEqual(currentFilter);\n        expect(print(request.query)).toBe(print(expectedServerQuery));\n        return Observable.of({ data });\n      }),\n      cache: new InMemoryCache({\n        addTypename: true,\n      }),\n      resolvers: {\n        Query: {\n          currentFilter() {\n            return currentFilter;\n          },\n        },\n      },\n    });\n\n    return client.query({ query }).then(result => {\n      expect(result.data).toEqual({\n        currentFilter,\n        ...data,\n      });\n    });\n  });","file":"local-state/export.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not impact normal non-@client use","suites":["General functionality"],"updatePoint":{"line":23,"column":46},"line":23,"code":"  it('should not impact normal non-@client use', () => {\n    const query = gql`\n      {\n        field\n      }\n    `;\n\n    const link = new ApolloLink(() => Observable.of({ data: { field: 1 } }));\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      link,\n      resolvers: {\n        Query: {\n          count: () => 0,\n        },\n      },\n    });\n\n    return client.query({ query }).then(({ data }) => {\n      expect({ ...data }).toMatchObject({ field: 1 });\n    });\n  });","file":"local-state/general.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not interfere with server introspection queries","suites":["General functionality"],"updatePoint":{"line":46,"column":60},"line":46,"code":"  it('should not interfere with server introspection queries', () => {\n    const query = gql`\n      ${getIntrospectionQuery()}\n    `;\n\n    const error = new GraphQLError('no introspection result found');\n    const link = new ApolloLink(() => Observable.of({ errors: [error] }));\n\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      link,\n      resolvers: {\n        Query: {\n          count: () => 0,\n        },\n      },\n    });\n\n    return client\n      .query({ query })\n      .then(() => {\n        throw new global.Error('should not call');\n      })\n      .catch((error: GraphQLError) =>\n        expect(error.message).toMatch(/no introspection/),\n      );\n  });","file":"local-state/general.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support returning default values from resolvers","suites":["General functionality"],"updatePoint":{"line":74,"column":60},"line":74,"code":"  it('should support returning default values from resolvers', () => {\n    const query = gql`\n      {\n        field @client\n      }\n    `;\n\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      link: ApolloLink.empty(),\n      resolvers: {\n        Query: {\n          field: () => 1,\n        },\n      },\n    });\n\n    return client.query({ query }).then(({ data }) => {\n      expect({ ...data }).toMatchObject({ field: 1 });\n    });\n  });","file":"local-state/general.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cache data for future lookups","suites":["General functionality"],"updatePoint":{"line":96,"column":42},"line":96,"code":"  it('should cache data for future lookups', () => {\n    const query = gql`\n      {\n        field @client\n      }\n    `;\n\n    let count = 0;\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      link: ApolloLink.empty(),\n      resolvers: {\n        Query: {\n          field: () => {\n            count += 1;\n            return 1;\n          },\n        },\n      },\n    });\n\n    return client\n      .query({ query })\n      .then(({ data }) => {\n        expect({ ...data }).toMatchObject({ field: 1 });\n        expect(count).toBe(1);\n      })\n      .then(() =>\n        client.query({ query }).then(({ data }) => {\n          expect({ ...data }).toMatchObject({ field: 1 });\n          expect(count).toBe(1);\n        }),\n      );\n  });","file":"local-state/general.ts","skipped":false,"dir":"src/__tests__"},{"name":"should honour `fetchPolicy` settings","suites":["General functionality"],"updatePoint":{"line":131,"column":42},"line":131,"code":"  it('should honour `fetchPolicy` settings', () => {\n    const query = gql`\n      {\n        field @client\n      }\n    `;\n\n    let count = 0;\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      link: ApolloLink.empty(),\n      resolvers: {\n        Query: {\n          field: () => {\n            count += 1;\n            return 1;\n          },\n        },\n      },\n    });\n\n    return client\n      .query({ query })\n      .then(({ data }) => {\n        expect({ ...data }).toMatchObject({ field: 1 });\n        expect(count).toBe(1);\n      })\n      .then(() =>\n        client\n          .query({ query, fetchPolicy: 'network-only' })\n          .then(({ data }) => {\n            expect({ ...data }).toMatchObject({ field: 1 });\n            expect(count).toBe(2);\n          }),\n      );\n  });","file":"local-state/general.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with a custom fragment matcher","suites":["General functionality"],"updatePoint":{"line":168,"column":48},"line":168,"code":"  it('should work with a custom fragment matcher', () => {\n    const query = gql`\n      {\n        foo {\n          ... on Bar {\n            bar @client\n          }\n          ... on Baz {\n            baz @client\n          }\n        }\n      }\n    `;\n\n    const link = new ApolloLink(() =>\n      Observable.of({\n        data: { foo: [{ __typename: 'Bar' }, { __typename: 'Baz' }] },\n      }),\n    );\n\n    const resolvers = {\n      Bar: {\n        bar: () => 'Bar',\n      },\n      Baz: {\n        baz: () => 'Baz',\n      },\n    };\n\n    const fragmentMatcher = (\n      { __typename }: { __typename: string },\n      typeCondition: string,\n    ) => __typename === typeCondition;\n\n    const client = new ApolloClient({\n      cache: new InMemoryCache({\n        possibleTypes: {\n          Foo: ['Bar', 'Baz'],\n        },\n      }),\n      link,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    return client.query({ query }).then(({ data }) => {\n      expect(data).toMatchObject({ foo: [{ bar: 'Bar' }, { baz: 'Baz' }] });\n    });\n  });","file":"local-state/general.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be able to write to the cache using a local mutation","suites":["Cache manipulation"],"updatePoint":{"line":245,"column":65},"line":245,"code":"  it('should be able to write to the cache using a local mutation', () => {\n    const query = gql`\n      {\n        field @client\n      }\n    `;\n\n    const mutation = gql`\n      mutation start {\n        start @client\n      }\n    `;\n\n    const resolvers = {\n      Mutation: {\n        start: (_1: any, _2: any, { cache }: { cache: InMemoryCache }) => {\n          cache.writeQuery({ query, data: { field: 1 } });\n          return { start: true };\n        },\n      },\n    };\n\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      link: ApolloLink.empty(),\n      resolvers,\n    });\n\n    return client\n      .mutate({ mutation })\n      .then(() => client.query({ query }))\n      .then(({ data }) => {\n        expect({ ...data }).toMatchObject({ field: 1 });\n      });\n  });","file":"local-state/general.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support writing to the cache with a local mutation using variables","suites":["Cache manipulation"],"updatePoint":{"line":333,"column":79},"line":333,"code":"  it('should support writing to the cache with a local mutation using variables', () => {\n    const query = gql`\n      {\n        field @client\n      }\n    `;\n\n    const mutation = gql`\n      mutation start($id: ID!) {\n        start(field: $id) @client {\n          field\n        }\n      }\n    `;\n\n    const resolvers = {\n      Mutation: {\n        start: (\n          _1: any,\n          variables: { field: string },\n          { cache }: { cache: ApolloCache<any> },\n        ) => {\n          cache.writeQuery({ query, data: { field: variables.field } });\n          return {\n            __typename: 'Field',\n            field: variables.field,\n          };\n        },\n      },\n    };\n\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      link: ApolloLink.empty(),\n      resolvers,\n    });\n\n    return client\n      .mutate({ mutation, variables: { id: '1234' } })\n      .then(({ data }) => {\n        expect({ ...data }).toEqual({\n          start: { field: '1234', __typename: 'Field' },\n        });\n      })\n      .then(() => client.query({ query }))\n      .then(({ data }) => {\n        expect({ ...data }).toMatchObject({ field: '1234' });\n      });\n  });","file":"local-state/general.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle nested asynchronous @client resolvers (issue #4841)","suites":["Basic resolver capabilities"],"updatePoint":{"line":433,"column":71},"line":433,"code":"  it('should handle nested asynchronous @client resolvers (issue #4841)', () => {\n    const query = gql`\n      query DeveloperTicketComments($id: ID) {\n        developer(id: $id) @client {\n          id\n          handle\n          tickets @client {\n            id\n            comments @client {\n              id\n            }\n          }\n        }\n      }\n    `;\n\n    function randomDelay(range: number) {\n      return new Promise(resolve =>\n        setTimeout(resolve, Math.round(Math.random() * range)),\n      );\n    }\n\n    function uuid() {\n      return Math.random()\n        .toString(36)\n        .slice(2);\n    }\n\n    const developerId = uuid();\n\n    function times<T>(n: number, thunk: () => T): Promise<T[]> {\n      const result: T[] = [];\n      for (let i = 0; i < n; ++i) {\n        result.push(thunk());\n      }\n      return Promise.all(result);\n    }\n\n    const ticketsPerDev = 5;\n    const commentsPerTicket = 5;\n\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      resolvers: {\n        Query: {\n          async developer(_, { id }) {\n            await randomDelay(50);\n            expect(id).toBe(developerId);\n            return {\n              __typename: 'Developer',\n              id,\n              handle: '@benjamn',\n            };\n          },\n        },\n        Developer: {\n          async tickets(developer) {\n            await randomDelay(50);\n            expect(developer.__typename).toBe('Developer');\n            return times(ticketsPerDev, () => ({\n              __typename: 'Ticket',\n              id: uuid(),\n            }));\n          },\n        },\n        Ticket: {\n          async comments(ticket) {\n            await randomDelay(50);\n            expect(ticket.__typename).toBe('Ticket');\n            return times(commentsPerTicket, () => ({\n              __typename: 'Comment',\n              id: uuid(),\n            }));\n          },\n        },\n      },\n    });\n\n    function check(result: ApolloQueryResult<any>) {\n      return new Promise<void>(resolve => {\n        expect(result.data.developer.id).toBe(developerId);\n        expect(result.data.developer.handle).toBe('@benjamn');\n        expect(result.data.developer.tickets.length).toBe(ticketsPerDev);\n        const commentIds = new Set<string>();\n        result.data.developer.tickets.forEach((ticket: any) => {\n          expect(ticket.__typename).toBe('Ticket');\n          expect(ticket.comments.length).toBe(commentsPerTicket);\n          ticket.comments.forEach((comment: any) => {\n            expect(comment.__typename).toBe('Comment');\n            commentIds.add(comment.id);\n          });\n        });\n        expect(commentIds.size).toBe(ticketsPerDev * commentsPerTicket);\n        resolve();\n      });\n    }\n\n    return Promise.all([\n      new Promise((resolve, reject) => {\n        client\n          .watchQuery({\n            query,\n            variables: {\n              id: developerId,\n            },\n          })\n          .subscribe({\n            next(result) {\n              check(result).then(resolve, reject);\n            },\n            error: reject,\n          });\n      }),\n      client\n        .query({\n          query,\n          variables: {\n            id: developerId,\n          },\n        })\n        .then(check),\n    ]);\n  });","file":"local-state/resolvers.ts","skipped":false,"dir":"src/__tests__"},{"name":"should let you write to the cache with a mutation","suites":["Writing cache data from resolvers"],"updatePoint":{"line":608,"column":55},"line":608,"code":"  it('should let you write to the cache with a mutation', () => {\n    const query = gql`\n      {\n        field @client\n      }\n    `;\n\n    const mutation = gql`\n      mutation start {\n        start @client\n      }\n    `;\n\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      link: ApolloLink.empty(),\n      resolvers: {\n        Mutation: {\n          start(_data, _args, { cache }) {\n            cache.writeQuery({ query, data: { field: 1 } });\n            return { start: true };\n          },\n        },\n      },\n    });\n\n    return client\n      .mutate({ mutation })\n      .then(() => client.query({ query }))\n      .then(({ data }) => {\n        expect({ ...data }).toMatchObject({ field: 1 });\n      });\n  });","file":"local-state/resolvers.ts","skipped":false,"dir":"src/__tests__"},{"name":"should let you write to the cache with a mutation using an ID","suites":["Writing cache data from resolvers"],"updatePoint":{"line":642,"column":67},"line":642,"code":"  it('should let you write to the cache with a mutation using an ID', () => {\n    const query = gql`\n      {\n        obj @client {\n          field\n        }\n      }\n    `;\n\n    const mutation = gql`\n      mutation start {\n        start @client\n      }\n    `;\n\n    const cache = new InMemoryCache();\n\n    const client = new ApolloClient({\n      cache,\n      link: ApolloLink.empty(),\n      resolvers: {\n        Mutation: {\n          start() {\n            cache.writeQuery({\n              query,\n              data: {\n                obj: { field: 1, id: 'uniqueId', __typename: 'Object' },\n              },\n            });\n\n            cache.modify({\n              id: 'Object:uniqueId',\n              fields: {\n                field(value) {\n                  expect(value).toBe(1);\n                  return 2;\n                },\n              },\n            });\n\n            return { start: true };\n          },\n        },\n      },\n    });\n\n    return client\n      .mutate({ mutation })\n      .then(() => client.query({ query }))\n      .then(({ data }: any) => {\n        expect(data.obj.field).toEqual(2);\n      });\n  });","file":"local-state/resolvers.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not overwrite __typename when writing to the cache with an id","suites":["Writing cache data from resolvers"],"updatePoint":{"line":696,"column":74},"line":696,"code":"  it('should not overwrite __typename when writing to the cache with an id', () => {\n    const query = gql`\n      {\n        obj @client {\n          field {\n            field2\n          }\n          id\n        }\n      }\n    `;\n\n    const mutation = gql`\n      mutation start {\n        start @client\n      }\n    `;\n\n    const cache = new InMemoryCache();\n\n    const client = new ApolloClient({\n      cache,\n      link: ApolloLink.empty(),\n      resolvers: {\n        Mutation: {\n          start() {\n            cache.writeQuery({\n              query,\n              data: {\n                obj: {\n                  field: { field2: 1, __typename: 'Field' },\n                  id: 'uniqueId',\n                  __typename: 'Object',\n                },\n              },\n            });\n            cache.modify({\n              id: 'Object:uniqueId',\n              fields: {\n                field(value: { field2: number }) {\n                  expect(value.field2).toBe(1);\n                  return { ...value, field2: 2 };\n                },\n              },\n            })\n            return { start: true };\n          },\n        },\n      },\n    });\n\n    return client\n      .mutate({ mutation })\n      .then(() => client.query({ query }))\n      .then(({ data }: any) => {\n        expect(data.obj.__typename).toEqual('Object');\n        expect(data.obj.field.__typename).toEqual('Field');\n      })\n      .catch(e => console.log(e));\n  });","file":"local-state/resolvers.ts","skipped":false,"dir":"src/__tests__"},{"name":"should allow client-only virtual resolvers (#4731)","suites":["Force local resolvers"],"updatePoint":{"line":1171,"column":56},"line":1171,"code":"  it('should allow client-only virtual resolvers (#4731)', function() {\n    const query = gql`\n      query UserData {\n        userData @client {\n          firstName\n          lastName\n          fullName\n        }\n      }\n    `;\n\n    const client = new ApolloClient({\n      cache: new InMemoryCache(),\n      resolvers: {\n        Query: {\n          userData() {\n            return {\n              __typename: 'User',\n              firstName: 'Ben',\n              lastName: 'Newman',\n            };\n          },\n        },\n        User: {\n          fullName(data) {\n            return data.firstName + ' ' + data.lastName;\n          },\n        },\n      },\n    });\n\n    return client.query({ query }).then(result => {\n      expect(result.data).toEqual({\n        userData: {\n          __typename: 'User',\n          firstName: 'Ben',\n          lastName: 'Newman',\n          fullName: 'Ben Newman',\n        },\n      });\n    });\n  });","file":"local-state/resolvers.ts","skipped":false,"dir":"src/__tests__"},{"name":"mutation update function receives result from cache","suites":["mutation results","InMemoryCache type/field policies"],"updatePoint":{"line":515,"column":59},"line":515,"code":"    it('mutation update function receives result from cache', () => {\n      let timeReadCount = 0;\n      let timeMergeCount = 0;\n\n      const client = new ApolloClient({\n        link,\n        cache: new InMemoryCache({\n          typePolicies: {\n            MutationPayload: {\n              fields: {\n                time: {\n                  read(ms: number = Date.now()) {\n                    ++timeReadCount;\n                    return new Date(ms);\n                  },\n                  merge(existing, incoming: number) {\n                    ++timeMergeCount;\n                    expect(existing).toBeUndefined();\n                    return incoming;\n                  },\n                },\n              },\n            },\n          },\n        }),\n      });\n\n      return client.mutate({\n        mutation,\n        update(cache, {\n          data: {\n            doSomething: {\n              __typename,\n              time,\n            },\n          },\n        }) {\n          expect(__typename).toBe(\"MutationPayload\");\n          expect(time).toBeInstanceOf(Date);\n          expect(time.getTime()).toBe(startTime);\n          expect(timeReadCount).toBe(1);\n          expect(timeMergeCount).toBe(1);\n          expect(cache.extract()).toEqual({\n            ROOT_MUTATION: {\n              __typename: \"Mutation\",\n              doSomething: {\n                __typename: \"MutationPayload\",\n                time: startTime,\n              },\n            },\n          });\n        },\n      }).then(({\n        data: {\n          doSomething: {\n            __typename,\n            time,\n          },\n        },\n      }) => {\n        expect(__typename).toBe(\"MutationPayload\");\n        expect(time).toBeInstanceOf(Date);\n        expect(time.getTime()).toBe(startTime);\n        expect(timeReadCount).toBe(1);\n        expect(timeMergeCount).toBe(1);\n\n        // The contents of the ROOT_MUTATION object exist only briefly, for the\n        // duration of the mutation update, and are removed after the mutation\n        // write is finished.\n        expect(client.cache.extract()).toEqual({\n          ROOT_MUTATION: {\n            __typename: \"Mutation\",\n          },\n        });\n      });\n    });","file":"mutationResults.ts","skipped":false,"dir":"src/__tests__"},{"name":"mutations can preserve ROOT_MUTATION cache data with keepRootFields: true","suites":["mutation results","InMemoryCache type/field policies"],"updatePoint":{"line":592,"column":81},"line":592,"code":"    it('mutations can preserve ROOT_MUTATION cache data with keepRootFields: true', () => {\n      let timeReadCount = 0;\n      let timeMergeCount = 0;\n\n      const client = new ApolloClient({\n        link,\n        cache: new InMemoryCache({\n          typePolicies: {\n            MutationPayload: {\n              fields: {\n                time: {\n                  read(ms: number = Date.now()) {\n                    ++timeReadCount;\n                    return new Date(ms);\n                  },\n                  merge(existing, incoming: number) {\n                    ++timeMergeCount;\n                    expect(existing).toBeUndefined();\n                    return incoming;\n                  },\n                },\n              },\n            },\n          },\n        }),\n      });\n\n      return client.mutate({\n        mutation,\n        keepRootFields: true,\n        update(cache, {\n          data: {\n            doSomething: {\n              __typename,\n              time,\n            },\n          },\n        }) {\n          expect(__typename).toBe(\"MutationPayload\");\n          expect(time).toBeInstanceOf(Date);\n          expect(time.getTime()).toBe(startTime);\n          expect(timeReadCount).toBe(1);\n          expect(timeMergeCount).toBe(1);\n          expect(cache.extract()).toEqual({\n            ROOT_MUTATION: {\n              __typename: \"Mutation\",\n              doSomething: {\n                __typename: \"MutationPayload\",\n                time: startTime,\n              },\n            },\n          });\n        },\n      }).then(({\n        data: {\n          doSomething: {\n            __typename,\n            time,\n          },\n        },\n      }) => {\n        expect(__typename).toBe(\"MutationPayload\");\n        expect(time).toBeInstanceOf(Date);\n        expect(time.getTime()).toBe(startTime);\n        expect(timeReadCount).toBe(1);\n        expect(timeMergeCount).toBe(1);\n\n        expect(client.cache.extract()).toEqual({\n          ROOT_MUTATION: {\n            __typename: \"Mutation\",\n            doSomething: {\n              __typename: \"MutationPayload\",\n              time: startTime,\n            },\n          },\n        });\n      });\n    });","file":"mutationResults.ts","skipped":false,"dir":"src/__tests__"},{"name":"mutation update function runs even when fetchPolicy is \"no-cache\"","suites":["mutation results","InMemoryCache type/field policies"],"updatePoint":{"line":671,"column":73},"line":671,"code":"    it('mutation update function runs even when fetchPolicy is \"no-cache\"', async () => {\n      let timeReadCount = 0;\n      let timeMergeCount = 0;\n      let mutationUpdateCount = 0;\n\n      const client = new ApolloClient({\n        link,\n        cache: new InMemoryCache({\n          typePolicies: {\n            MutationPayload: {\n              fields: {\n                time: {\n                  read(ms: number = Date.now()) {\n                    ++timeReadCount;\n                    return new Date(ms);\n                  },\n                  merge(existing, incoming: number) {\n                    ++timeMergeCount;\n                    expect(existing).toBeUndefined();\n                    return incoming;\n                  },\n                },\n              },\n            },\n          },\n        }),\n      });\n\n      return client.mutate({\n        mutation,\n        fetchPolicy: \"no-cache\",\n        update(cache, {\n          data: {\n            doSomething: {\n              __typename,\n              time,\n            },\n          },\n        }) {\n          expect(++mutationUpdateCount).toBe(1);\n          expect(__typename).toBe(\"MutationPayload\");\n          expect(time).not.toBeInstanceOf(Date);\n          expect(time).toBe(startTime);\n          expect(timeReadCount).toBe(0);\n          expect(timeMergeCount).toBe(0);\n          expect(cache.extract()).toEqual({});\n        },\n      }).then(({\n        data: {\n          doSomething: {\n            __typename,\n            time,\n          },\n        },\n      }) => {\n        expect(__typename).toBe(\"MutationPayload\");\n        expect(time).not.toBeInstanceOf(Date);\n        expect(time).toBe(+startTime);\n        expect(timeReadCount).toBe(0);\n        expect(timeMergeCount).toBe(0);\n        expect(mutationUpdateCount).toBe(1);\n        expect(client.cache.extract()).toEqual({});\n      });\n    });","file":"mutationResults.ts","skipped":false,"dir":"src/__tests__"},{"name":"can refetch no-cache queries","suites":["client.refetchQueries"],"updatePoint":{"line":1018,"column":34},"line":1018,"code":"  it(\"can refetch no-cache queries\", () => {\n    // TODO The options.updateCache function won't work for these queries, but\n    // the options.include array should work, at least.\n  });","file":"refetchQueries.ts","skipped":false,"dir":"src/__tests__"},{"name":"empties all result caches after eviction - query","suites":["resultCache cleaning"],"updatePoint":{"line":167,"column":54},"line":167,"code":"  it(`empties all result caches after eviction - query`, async () => {\n    await client.query({\n      query,\n      variables: { id: 1 },\n    });\n  });","file":"resultCacheCleaning.ts","skipped":false,"dir":"src/__tests__"},{"name":"empties all result caches after eviction - watchQuery","suites":["resultCache cleaning"],"updatePoint":{"line":174,"column":59},"line":174,"code":"  it(`empties all result caches after eviction - watchQuery`, async () => {\n    return new Promise<void>((r) => {\n      const observable = client.watchQuery({\n        query,\n        variables: { id: 1 },\n      });\n      const unsubscribe = observable.subscribe(() => {\n        unsubscribe.unsubscribe();\n        r();\n      });\n    });\n  });","file":"resultCacheCleaning.ts","skipped":false,"dir":"src/__tests__"}]}