{"repo":"remix-run/remix","url":"https://github.com/remix-run/remix","branch":"main","configs":[{"package":"create-remix","lang":"ts","dir":"packages/create-remix/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/architect","lang":"ts","dir":"packages/remix-architect/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/dev","lang":"ts","dir":"packages/remix-dev/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/express","lang":"ts","dir":"packages/remix-express/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/netlify","lang":"ts","dir":"packages/remix-netlify/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/node","lang":"ts","dir":"packages/remix-node/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/react","lang":"js","dir":"packages/remix-react/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@remix-run/server-runtime","lang":"ts","dir":"packages/remix-server-runtime/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@remix-run/vercel","lang":"ts","dir":"packages/remix-vercel/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should detect binary contentType correctly","suites":["architect isBinaryType"],"updatePoint":{"line":4,"column":48},"line":4,"code":"  it(\"should detect binary contentType correctly\", () => {\n    expect(isBinaryType(undefined)).toBe(false);\n    expect(isBinaryType(null)).toBe(false);\n    expect(isBinaryType(\"text/html; charset=utf-8\")).toBe(false);\n    expect(isBinaryType(\"application/octet-stream\")).toBe(true);\n    expect(isBinaryType(\"application/octet-stream; charset=test\")).toBe(true);\n  });","file":"binaryTypes-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles requests","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":84,"column":24},"line":84,"code":"    it(\"handles requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"/foo/bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: /foo/bar\");\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles root // requests","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":100,"column":32},"line":100,"code":"    it(\"handles root // requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"//\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: //\");\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles nested // requests","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":116,"column":34},"line":116,"code":"    it(\"handles nested // requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"//foo//bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: //foo//bar\");\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles null body","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":132,"column":25},"line":132,"code":"    it(\"handles null body\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 200 });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"/foo/bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles status codes","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":147,"column":28},"line":147,"code":"    it(\"handles status codes\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 204 });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"/foo/bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(204);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"sets headers","suites":["architect createRequestHandler","basic requests"],"updatePoint":{"line":162,"column":20},"line":162,"code":"    it(\"sets headers\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let headers = new Headers();\n        headers.append(\"X-Time-Of-Year\", \"most wonderful\");\n        headers.append(\n          \"Set-Cookie\",\n          \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n\n        return new Response(null, { headers });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawPath: \"/\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.headers[\"x-time-of-year\"]).toBe(\"most wonderful\");\n          expect(res.cookies).toEqual([\n            \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\",\n            \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\",\n            \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\",\n          ]);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles empty headers","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":202,"column":29},"line":202,"code":"    it(\"handles empty headers\", () => {\n      let headers = createRemixHeaders({});\n      expect(headers.raw()).toMatchInlineSnapshot(`Object {}`);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles simple headers","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":207,"column":30},"line":207,"code":"    it(\"handles simple headers\", () => {\n      let headers = createRemixHeaders({ \"x-foo\": \"bar\" });\n      expect(headers.get(\"x-foo\")).toBe(\"bar\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles multiple headers","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":212,"column":32},"line":212,"code":"    it(\"handles multiple headers\", () => {\n      let headers = createRemixHeaders({ \"x-foo\": \"bar\", \"x-bar\": \"baz\" });\n      expect(headers.get(\"x-foo\")).toBe(\"bar\");\n      expect(headers.get(\"x-bar\")).toBe(\"baz\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles headers with multiple values","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":218,"column":44},"line":218,"code":"    it(\"handles headers with multiple values\", () => {\n      let headers = createRemixHeaders({\n        \"x-foo\": \"bar, baz\",\n        \"x-bar\": \"baz\",\n      });\n      expect(headers.getAll(\"x-foo\")).toEqual([\"bar, baz\"]);\n      expect(headers.get(\"x-bar\")).toBe(\"baz\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles multiple request cookies","suites":["architect createRemixHeaders","creates fetch headers from architect headers"],"updatePoint":{"line":227,"column":40},"line":227,"code":"    it(\"handles multiple request cookies\", () => {\n      let headers = createRemixHeaders({}, [\n        \"__session=some_value\",\n        \"__other=some_other_value\",\n      ]);\n      expect(headers.getAll(\"cookie\")).toEqual([\n        \"__session=some_value; __other=some_other_value\",\n      ]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"creates a request with the correct headers","suites":["architect createRemixRequest"],"updatePoint":{"line":240,"column":48},"line":240,"code":"  it(\"creates a request with the correct headers\", () => {\n    let remixRequest = createRemixRequest(\n      createMockEvent({ cookies: [\"__session=value\"] })\n    );\n\n    expect(remixRequest.method).toBe(\"GET\");\n    expect(remixRequest.headers.get(\"cookie\")).toBe(\"__session=value\");\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles regular responses","suites":["sendRemixResponse"],"updatePoint":{"line":251,"column":31},"line":251,"code":"  it(\"handles regular responses\", async () => {\n    let response = new NodeResponse(\"anything\");\n    let result = await sendRemixResponse(response);\n    expect(result.body).toBe(\"anything\");\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles resource routes with regular data","suites":["sendRemixResponse"],"updatePoint":{"line":257,"column":47},"line":257,"code":"  it(\"handles resource routes with regular data\", async () => {\n    let json = JSON.stringify({ foo: \"bar\" });\n    let response = new NodeResponse(json, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"content-length\": json.length.toString(),\n      },\n    });\n\n    let result = await sendRemixResponse(response);\n\n    expect(result.body).toMatch(json);\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"handles resource routes with binary data","suites":["sendRemixResponse"],"updatePoint":{"line":271,"column":46},"line":271,"code":"  it(\"handles resource routes with binary data\", async () => {\n    let image = await fsp.readFile(path.join(__dirname, \"554828.jpeg\"));\n\n    let response = new NodeResponse(image, {\n      headers: {\n        \"content-type\": \"image/jpeg\",\n        \"content-length\": image.length.toString(),\n      },\n    });\n\n    let result = await sendRemixResponse(response);\n\n    expect(result.body).toMatch(image.toString(\"base64\"));\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-architect/__tests__"},{"name":"prints help info","suites":["remix CLI","the --help flag"],"updatePoint":{"line":89,"column":24},"line":89,"code":"    it(\"prints help info\", async () => {\n      let { stdout } = await execRemix([\"--help\"]);\n      expect(stdout.trim()).toMatchInlineSnapshot(`\n        \"R E M I X\n\n          Usage:\n            $ remix create <projectDir> --template <template>\n            $ remix init [projectDir]\n            $ remix build [projectDir]\n            $ remix dev [projectDir]\n            $ remix routes [projectDir]\n            $ remix watch [projectDir]\n            $ remix setup [remixPlatform]\n            $ remix codemod <codemod> [projectDir]\n\n          Options:\n            --help, -h          Print this help message and exit\n            --version, -v       Print the CLI version and exit\n            --no-color          Disable ANSI colors in console output\n          \\`create\\` Options:\n            --template          The template to use\n            --no-install        Skip installing dependencies after creation\n            --no-typescript     Convert the template to JavaScript\n            --remix-version     The version of Remix to use\n          \\`build\\` Options:\n            --sourcemap         Generate source maps for production\n          \\`dev\\` Options:\n            --debug             Attach Node.js inspector\n            --port, -p          Choose the port from which to run your app\n\n            [v2_dev]\n            --command, -c       Command used to run your app server\n            --scheme            Scheme for the dev server. Default: http\n            --host              Host for the dev server. Default: localhost\n            --port              Port for the dev server. Default: any open port\n            --no-restart        Do not restart the app server when rebuilds occur.\n            --tls-key           Path to TLS key (key.pem)\n            --tls-cert          Path to TLS certificate (cert.pem)\n          \\`init\\` Options:\n            --no-delete         Skip deleting the \\`remix.init\\` script\n          \\`routes\\` Options:\n            --json              Print the routes as JSON\n          \\`codemod\\` Options:\n            --dry               Dry run (no changes are made to files)\n            --force             Bypass Git safety checks\n\n          Values:\n            - projectDir        The Remix project directory\n            - template          The project template to use\n            - remixPlatform     \\`node\\` or \\`cloudflare\\`\n\n          Creating a new project:\n\n            Remix projects are created from templates. A template can be:\n\n            - a file path to a directory of files\n            - a file path to a tarball\n            - the name of a :username/:repo on GitHub\n            - the URL of a tarball\n\n            $ remix create my-app --template /path/to/remix-template\n            $ remix create my-app --template /path/to/remix-template.tar.gz\n            $ remix create my-app --template remix-run/grunge-stack\n            $ remix create my-app --template :username/:repo\n            $ remix create my-app --template https://github.com/:username/:repo\n            $ remix create my-app --template https://github.com/:username/:repo/tree/:branch\n            $ remix create my-app --template https://github.com/:username/:repo/archive/refs/tags/:tag.tar.gz\n            $ remix create my-app --template https://example.com/remix-template.tar.gz\n\n            To create a new project from a template in a private GitHub repo,\n            pass the \\`token\\` flag with a personal access token with access to that repo.\n\n          Initialize a project::\n\n            Remix project templates may contain a \\`remix.init\\` directory\n            with a script that initializes the project. This script automatically\n            runs during \\`remix create\\`, but if you ever need to run it manually\n            (e.g. to test it out) you can:\n\n            $ remix init\n\n          Build your project:\n\n            $ remix build\n            $ remix build --sourcemap\n            $ remix build my-app\n\n          Run your project locally in development:\n\n            $ remix dev\n            $ remix dev my-app\n            $ remix dev --debug\n\n          Start your server separately and watch for changes:\n\n            # custom server start command, for example:\n            $ remix watch\n\n            # in a separate tab:\n            $ node --inspect --require ./node_modules/dotenv/config --require ./mocks ./build/server.js\n\n          Show all routes in your app:\n\n            $ remix routes\n            $ remix routes my-app\n            $ remix routes --json\n\n          Reveal the used entry point:\n\n            $ remix reveal entry.client\n            $ remix reveal entry.server\n            $ remix reveal entry.client --no-typescript\n            $ remix reveal entry.server --no-typescript\"\n      `);\n    });","file":"cli-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"prints the current version","suites":["remix CLI","the --version flag"],"updatePoint":{"line":207,"column":34},"line":207,"code":"    it(\"prints the current version\", async () => {\n      let { stdout } = await execRemix([\"--version\"]);\n      expect(!!semver.valid(stdout.trim())).toBe(true);\n    });","file":"cli-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows you to go through the prompts","suites":["remix CLI","create prompts"],"updatePoint":{"line":214,"column":44},"line":214,"code":"    it(\"allows you to go through the prompts\", async () => {\n      let projectDir = path.join(TEMP_DIR, \"my-app\");\n\n      let proc = childProcess.spawn(\n        \"node\",\n        [\n          \"--require\",\n          require.resolve(\"esbuild-register\"),\n          \"--require\",\n          path.join(__dirname, \"./msw.ts\"),\n          path.resolve(__dirname, \"../cli.ts\"),\n          \"create\",\n        ],\n        { stdio: [null, null, null] }\n      );\n\n      await interactWithShell(proc, [\n        { question: /Where.*create.*app/i, type: [projectDir, ENTER] },\n        { question: /What type of app/i, answer: /basics/i },\n        { question: /Where.*deploy/i, answer: /express/i },\n        { question: /typescript or javascript/i, answer: /typescript/i },\n        { question: /install/i, type: [\"n\", ENTER] },\n      ]);\n    });","file":"cli-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows you to go through the prompts and convert to JS","suites":["remix CLI","create prompts"],"updatePoint":{"line":239,"column":62},"line":239,"code":"    it(\"allows you to go through the prompts and convert to JS\", async () => {\n      let projectDir = path.join(TEMP_DIR, \"my-js-app\");\n\n      let proc = childProcess.spawn(\n        \"node\",\n        [\n          \"--require\",\n          require.resolve(\"esbuild-register\"),\n          \"--require\",\n          path.join(__dirname, \"./msw.ts\"),\n          path.resolve(__dirname, \"../cli.ts\"),\n          \"create\",\n        ],\n        { stdio: [null, null, null] }\n      );\n\n      await interactWithShell(proc, [\n        { question: /Where.*create.*app/i, type: [projectDir, ENTER] },\n        { question: /What type of app/i, answer: /basics/i },\n        { question: /Where.*deploy/i, answer: /express/i },\n        { question: /typescript or javascript/i, answer: /javascript/i },\n        { question: /install/i, type: [\"n\", ENTER] },\n      ]);\n\n      expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeFalsy();\n      expect(\n        fse.existsSync(path.join(projectDir, \"app/root.jsx\"))\n      ).toBeTruthy();\n    });","file":"cli-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces `remix` magic imports","suites":[],"updatePoint":{"line":17,"column":34},"line":17,"code":"it(\"replaces `remix` magic imports\", async () => {\n  await withApp(FIXTURE, async (projectDir) => {\n    await git.initialCommit(projectDir);\n    let result = await cli.run([\"codemod\", CODEMOD, projectDir]);\n    let stderr = stripAnsi(result.stderr);\n    expect(result.exitCode).toBe(0);\n\n    let successes = [\n      `✔ Found codemod: ${CODEMOD}`,\n      \"✔ No Remix server adapter detected\",\n      \"✔ Detected Remix server runtime: node\",\n      \"✔ Removed magic `remix` package from dependencies\",\n      \"✔ Removed `remix setup` from postinstall script\",\n      \"✔ Replaced magic `remix` imports | 24/24 files\",\n    ];\n    for (let success of successes) {\n      expect(stderr).toContain(success);\n    }\n\n    expect(result.stdout).toContain(\n      \"👉 To update your lockfile, run `yarn install`\"\n    );\n\n    let pkg = await NpmCliPackageJson.load(projectDir);\n    let packageJson = pkg.content;\n\n    // check that `remix` dependency was removed\n    expect(packageJson.dependencies).not.toContain(\"remix\");\n    expect(packageJson.devDependencies).not.toContain(\"remix\");\n\n    // check that Remix packages were standardized\n    expect(packageJson.dependencies).toEqual(\n      expect.objectContaining({\n        \"@remix-run/node\": \"1.3.4\",\n        \"@remix-run/react\": \"1.3.4\",\n        \"@remix-run/serve\": \"1.3.4\",\n      })\n    );\n    expect(packageJson.devDependencies).toEqual(\n      expect.objectContaining({\n        \"@remix-run/dev\": \"1.3.4\",\n      })\n    );\n\n    // check that postinstall was removed\n    expect(packageJson.scripts).not.toContain(\"postinstall\");\n\n    // check that `from \"remix\"` magic imports were removed\n    let config = await readConfig(projectDir);\n    let files = await glob(\"**/*.{js,jsx,ts,tsx}\", {\n      cwd: config.appDirectory,\n      absolute: true,\n    });\n    let remixMagicImports = shell.grep(\"-l\", /from ('remix'|\"remix\")/, files);\n    expect(remixMagicImports.code).toBe(0);\n    expect(remixMagicImports.stdout.trim()).toBe(\"\");\n    expect(remixMagicImports.stderr).toBeNull();\n\n    // check that imports look good for a specific file\n    let loginRoute = eol.normalize(\n      fs.readFileSync(path.join(projectDir, \"app/routes/login.tsx\"), \"utf8\")\n    );\n    expect(loginRoute).toContain(\n      [\n        \"import {\",\n        \"  type ActionFunction,\",\n        \"  type LoaderFunction,\",\n        \"  type MetaFunction,\",\n        \"  json,\",\n        \"  redirect,\",\n        '} from \"@remix-run/node\";',\n        'import { Form, Link, useActionData, useSearchParams } from \"@remix-run/react\";',\n      ].join(\"\\n\")\n    );\n  });\n});","file":"codemod-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"checks that project is a clean git repository","suites":[],"updatePoint":{"line":12,"column":49},"line":12,"code":"it(\"checks that project is a clean git repository\", async () => {\n  await withApp(FIXTURE, async (projectDir) => {\n    // ensure project is a git repository\n    let error1 = await cli.shouldError([\n      \"codemod\",\n      \"some-codemod-name\",\n      projectDir,\n    ]);\n    expect(error1.exitCode).not.toBe(0);\n    expect(error1.stderr).toContain(`${projectDir} is not a git repository`);\n    expect(error1.stdout).toContain(\n      \"To override this safety check, use the --force flag\"\n    );\n\n    // initialize git repo in project\n    await git.initialCommit(projectDir);\n\n    // make some uncommitted changes\n    fs.appendFileSync(path.join(projectDir, \"package.json\"), \"change\");\n\n    // ensure project has no uncommitted changes\n    let error2 = await cli.shouldError([\n      \"codemod\",\n      \"some-codemod-name\",\n      projectDir,\n    ]);\n    expect(error2.exitCode).not.toBe(0);\n    expect(error2.stderr).toContain(`${projectDir} has uncommitted changes`);\n    expect(error2.stdout).toContain(\n      \"Stash or commit your changes before running codemods\"\n    );\n    expect(error2.stdout).toContain(\n      \"To override this safety check, use the --force flag\"\n    );\n  });\n});","file":"codemod-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"checks that the specified codemod exists","suites":[],"updatePoint":{"line":49,"column":44},"line":49,"code":"it(\"checks that the specified codemod exists\", async () => {\n  await withApp(FIXTURE, async (projectDir) => {\n    await git.initialCommit(projectDir);\n\n    let codemodName = \"invalid-codemod-name\";\n    let error = await cli.shouldError([\"codemod\", codemodName, projectDir]);\n    expect(error.exitCode).toBe(1);\n    expect(error.stderr).toContain(`Unrecognized codemod: ${codemodName}`);\n  });\n});","file":"codemod-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for examples in the examples repo","suites":["the create command"],"updatePoint":{"line":134,"column":45},"line":134,"code":"  it(\"works for examples in the examples repo\", async () => {\n    let projectDir = await getProjectDir(\"example\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"examples/basic\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getSuccessMessage(path.join(\"<TEMP_DIR>\", \"example\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for templates in the remix org","suites":["the create command"],"updatePoint":{"line":151,"column":42},"line":151,"code":"  it(\"works for templates in the remix org\", async () => {\n    let projectDir = await getProjectDir(\"template\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"grunge-stack\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"template\"))\n    );\n\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for GitHub username/repo combo","suites":["the create command"],"updatePoint":{"line":172,"column":42},"line":172,"code":"  it(\"works for GitHub username/repo combo\", async () => {\n    let projectDir = await getProjectDir(\"repo\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"remix-fake-tester-username/remix-fake-tester-repo\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"repo\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"fails for private GitHub username/repo combo without a token","suites":["the create command"],"updatePoint":{"line":191,"column":66},"line":191,"code":"  it(\"fails for private GitHub username/repo combo without a token\", async () => {\n    let projectDir = await getProjectDir(\"repo\");\n    await expect(() =>\n      run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        \"private-org/private-repo\",\n        \"--no-install\",\n        \"--typescript\",\n      ])\n    ).rejects.toMatchInlineSnapshot(\n      `[Error: 🚨 The template could not be verified. Please double check that the template is a valid GitHub repository and try again.]`\n    );\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"succeeds for private GitHub username/repo combo with a valid token","suites":["the create command"],"updatePoint":{"line":207,"column":72},"line":207,"code":"  it(\"succeeds for private GitHub username/repo combo with a valid token\", async () => {\n    let projectDir = await getProjectDir(\"repo\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"private-org/private-repo\",\n      \"--no-install\",\n      \"--typescript\",\n      \"--token\",\n      \"valid-token\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"repo\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for remote tarballs","suites":["the create command"],"updatePoint":{"line":228,"column":31},"line":228,"code":"  it(\"works for remote tarballs\", async () => {\n    let projectDir = await getProjectDir(\"remote-tarball\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"https://example.com/remix-stack.tar.gz\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"remote-tarball\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"fails for private github release tarballs","suites":["the create command"],"updatePoint":{"line":247,"column":47},"line":247,"code":"  it(\"fails for private github release tarballs\", async () => {\n    let projectDir = await getProjectDir(\"private-release-tarball\");\n    await expect(() =>\n      run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        \"https://github.com/private-org/private-repo/releases/download/v0.0.1/stack.tar.gz\",\n        \"--no-install\",\n        \"--typescript\",\n      ])\n    ).rejects.toMatchInlineSnapshot(\n      `[Error: 🚨 The template file could not be verified. Please double check the URL and try again.]`\n    );\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"succeeds for private github release tarballs when including token","suites":["the create command"],"updatePoint":{"line":263,"column":71},"line":263,"code":"  it(\"succeeds for private github release tarballs when including token\", async () => {\n    let projectDir = await getProjectDir(\"private-release-tarball-with-token\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"https://github.com/private-org/private-repo/releases/download/v0.0.1/stack.tar.gz\",\n      \"--no-install\",\n      \"--typescript\",\n      \"--token\",\n      \"valid-token\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(\n          path.join(\"<TEMP_DIR>\", \"private-release-tarball-with-token\")\n        )\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for different branches","suites":["the create command"],"updatePoint":{"line":286,"column":34},"line":286,"code":"  it(\"works for different branches\", async () => {\n    let projectDir = await getProjectDir(\"diff-branch\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"https://github.com/fake-remix-tester/nested-dir/tree/dev/stack\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"diff-branch\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for a path to a tarball on disk","suites":["the create command"],"updatePoint":{"line":305,"column":43},"line":305,"code":"  it(\"works for a path to a tarball on disk\", async () => {\n    let projectDir = await getProjectDir(\"local-tarball\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"arc.tar.gz\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getSuccessMessage(path.join(\"<TEMP_DIR>\", \"local-tarball\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for a file URL to a tarball on disk","suites":["the create command"],"updatePoint":{"line":322,"column":47},"line":322,"code":"  it(\"works for a file URL to a tarball on disk\", async () => {\n    let projectDir = await getProjectDir(\"file-url-tarball\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      pathToFileURL(path.join(__dirname, \"fixtures\", \"arc.tar.gz\")).toString(),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getSuccessMessage(path.join(\"<TEMP_DIR>\", \"file-url-tarball\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"converts a template to JavaScript","suites":["the create command"],"updatePoint":{"line":339,"column":39},"line":339,"code":"  it(\"converts a template to JavaScript\", async () => {\n    let projectDir = await getProjectDir(\"template-to-js\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"blues-stack\",\n      \"--no-install\",\n      \"--no-typescript\",\n    ]);\n    expect(output.trim()).toContain(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"template-to-js\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeFalsy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.jsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for a file path to a directory on disk","suites":["the create command"],"updatePoint":{"line":358,"column":50},"line":358,"code":"  it(\"works for a file path to a directory on disk\", async () => {\n    let projectDir = await getProjectDir(\"local-directory\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures/stack\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"local-directory\"))\n    );\n\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works for a file URL to a directory on disk","suites":["the create command"],"updatePoint":{"line":378,"column":49},"line":378,"code":"  it(\"works for a file URL to a directory on disk\", async () => {\n    let projectDir = await getProjectDir(\"file-url-directory\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      pathToFileURL(path.join(__dirname, \"fixtures/stack\")).toString(),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"file-url-directory\"))\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"prioritizes built-in templates when validating input","suites":["the create command"],"updatePoint":{"line":397,"column":58},"line":397,"code":"  it(\"prioritizes built-in templates when validating input\", async () => {\n    let projectDir = await getProjectDir(\"built-in-template\");\n\n    // create a local directory in our cwd with the same name as our chosen\n    // template and give it a package.json so we can check it against the one in\n    // our template\n    let dupedDir = path.join(process.cwd(), \"express\");\n    await fse.mkdir(dupedDir);\n    await fse.writeFile(\n      path.join(dupedDir, \"package.json\"),\n      '{ \"name\": \"dummy\" }'\n    );\n\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"express\",\n      \"--install\",\n      \"--typescript\",\n    ]);\n\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    let pkgJSON = JSON.parse(\n      fse.readFileSync(path.join(projectDir, \"package.json\"), \"utf-8\")\n    );\n    expect(pkgJSON.name).not.toBe(\"dummy\");\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"runs remix.init script when installing dependencies","suites":["the create command"],"updatePoint":{"line":426,"column":57},"line":426,"code":"  it(\"runs remix.init script when installing dependencies\", async () => {\n    let projectDir = await getProjectDir(\"remix-init-auto\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      \"💿 Running remix.init script\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"remix-init-auto\"))\n    );\n    expect(output).toContain(`💿 Running remix.init script`);\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"test.txt\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeFalsy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"runs remix.init script when using index.ts","suites":["the create command"],"updatePoint":{"line":447,"column":48},"line":447,"code":"  it(\"runs remix.init script when using index.ts\", async () => {\n    let projectDir = await getProjectDir(\"remix-init-ts\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"stack-init-ts.tar.gz\"),\n      \"--install\",\n      \"--typescript\",\n    ]);\n    expect(output).toContain(\n      `Running init script on ${projectDir.replace(TEMP_DIR, \"<TEMP_DIR>\")}`\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeFalsy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"runs remix.init script when using `remix init`","suites":["the create command"],"updatePoint":{"line":465,"column":52},"line":465,"code":"  it(\"runs remix.init script when using `remix init`\", async () => {\n    let projectDir = await getProjectDir(\"remix-init-manual\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"remix-init-manual\"))\n    );\n\n    output = \"\";\n    process.chdir(projectDir);\n    await run([\"init\"]);\n\n    expect(output).toBe(\"\");\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"test.txt\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeFalsy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"It keeps the `remix.init` script when using the `--no-delete` flag","suites":["the create command"],"updatePoint":{"line":492,"column":72},"line":492,"code":"  it(\"It keeps the `remix.init` script when using the `--no-delete` flag\", async () => {\n    let projectDir = await getProjectDir(\"remix-init-manual\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"remix-init-manual\"))\n    );\n\n    output = \"\";\n    process.chdir(projectDir);\n    await run([\"init\", \"--no-delete\"]);\n\n    expect(output).toBe(\"\");\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"throws an error when invalid remix.init script when automatically ran","suites":["the create command"],"updatePoint":{"line":516,"column":75},"line":516,"code":"  it(\"throws an error when invalid remix.init script when automatically ran\", async () => {\n    let projectDir = await getProjectDir(\"invalid-remix-init-manual\");\n    await expect(\n      run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        path.join(__dirname, \"fixtures\", \"failing-remix-init.tar.gz\"),\n        \"--install\",\n        \"--typescript\",\n      ])\n    ).rejects.toThrowError(`🚨 Oops, remix.init failed`);\n\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    // we should keep remix.init around if the init script fails\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"throws an error when invalid remix.init script when manually ran","suites":["the create command"],"updatePoint":{"line":535,"column":70},"line":535,"code":"  it(\"throws an error when invalid remix.init script when manually ran\", async () => {\n    let projectDir = await getProjectDir(\"invalid-remix-init-manual\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"failing-remix-init.tar.gz\"),\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n    expect(output.trim()).toBe(\n      getOptOutOfInstallMessage() +\n        \"\\n\\n\" +\n        getSuccessMessage(path.join(\"<TEMP_DIR>\", \"invalid-remix-init-manual\"))\n    );\n\n    process.chdir(projectDir);\n    await expect(run([\"init\"])).rejects.toThrowError(\n      `🚨 Oops, remix.init failed`\n    );\n    expect(fse.existsSync(path.join(projectDir, \"package.json\"))).toBeTruthy();\n    expect(fse.existsSync(path.join(projectDir, \"app/root.tsx\"))).toBeTruthy();\n    // we should keep remix.init around if the init script fails\n    expect(fse.existsSync(path.join(projectDir, \"remix.init\"))).toBeTruthy();\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"recognizes when Yarn was used to run the command","suites":["the create command"],"updatePoint":{"line":561,"column":54},"line":561,"code":"  it(\"recognizes when Yarn was used to run the command\", async () => {\n    let originalUserAgent = process.env.npm_config_user_agent;\n    process.env.npm_config_user_agent = yarnUserAgent;\n\n    let projectDir = await getProjectDir(\"yarn-create\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--install\",\n      \"--typescript\",\n    ]);\n\n    expect(execSync).toBeCalledWith(\"yarn install\", expect.anything());\n    process.env.npm_config_user_agent = originalUserAgent;\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"recognizes when pnpm was used to run the command","suites":["the create command"],"updatePoint":{"line":579,"column":54},"line":579,"code":"  it(\"recognizes when pnpm was used to run the command\", async () => {\n    let originalUserAgent = process.env.npm_config_user_agent;\n    process.env.npm_config_user_agent = pnpmUserAgent;\n\n    let projectDir = await getProjectDir(\"pnpm-create\");\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      path.join(__dirname, \"fixtures\", \"successful-remix-init.tar.gz\"),\n      \"--install\",\n      \"--typescript\",\n    ]);\n\n    expect(execSync).toBeCalledWith(\"pnpm install\", expect.anything());\n    process.env.npm_config_user_agent = originalUserAgent;\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"prompts to run the install command for the preferred package manager","suites":["the create command"],"updatePoint":{"line":597,"column":74},"line":597,"code":"  it(\"prompts to run the install command for the preferred package manager\", async () => {\n    let originalUserAgent = process.env.npm_config_user_agent;\n    process.env.npm_config_user_agent = pnpmUserAgent;\n\n    let projectDir = await getProjectDir(\"pnpm-prompt-install\");\n    let mockPrompt = jest.mocked(inquirer.prompt);\n    mockPrompt.mockImplementationOnce(() => {\n      return Promise.resolve({\n        install: false,\n      }) as unknown as ReturnType<typeof inquirer.prompt>;\n    });\n\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"grunge-stack\",\n      \"--typescript\",\n    ]);\n\n    let mockPromptCalls = mockPrompt.mock.calls;\n    let lastCallArgs = mockPromptCalls[mockPromptCalls.length - 1][0];\n    let lastCallUnknown = lastCallArgs as Array<unknown>;\n    expect(lastCallUnknown[lastCallUnknown.length - 1]).toHaveProperty(\n      \"message\",\n      \"Do you want me to run `pnpm install`?\"\n    );\n    process.env.npm_config_user_agent = originalUserAgent;\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"suggests to run the init command with the preferred package manager","suites":["the create command"],"updatePoint":{"line":627,"column":73},"line":627,"code":"  it(\"suggests to run the init command with the preferred package manager\", async () => {\n    let originalUserAgent = process.env.npm_config_user_agent;\n    process.env.npm_config_user_agent = pnpmUserAgent;\n\n    let projectDir = await getProjectDir(\"pnpm-suggest-install\");\n    let mockPrompt = jest.mocked(inquirer.prompt);\n    mockPrompt.mockImplementationOnce(() => {\n      return Promise.resolve({\n        install: false,\n      }) as unknown as ReturnType<typeof inquirer.prompt>;\n    });\n\n    await run([\n      \"create\",\n      projectDir,\n      \"--template\",\n      \"grunge-stack\",\n      \"--no-install\",\n      \"--typescript\",\n    ]);\n\n    expect(output).toContain(getOptOutOfInstallMessage(\"pnpm exec remix init\"));\n    process.env.npm_config_user_agent = originalUserAgent;\n  });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when a github repo is not accessible (403)","suites":["the create command","errors"],"updatePoint":{"line":653,"column":61},"line":653,"code":"    it(\"identifies when a github repo is not accessible (403)\", async () => {\n      let projectDir = await getProjectDir(\"repo\");\n      await expect(async () => {\n        try {\n          let res = await run([\n            \"create\",\n            projectDir,\n            \"--template\",\n            \"error-username/403\",\n            \"--no-install\",\n            \"--typescript\",\n          ]);\n          return res;\n        } catch (error: unknown) {\n          throw error;\n        }\n      }).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template could not be verified because you do not have access to the repository. Please double check the access rights of this repo and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when a github repo does not exist (404)","suites":["the create command","errors"],"updatePoint":{"line":674,"column":58},"line":674,"code":"    it(\"identifies when a github repo does not exist (404)\", async () => {\n      let projectDir = await getProjectDir(\"repo\");\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"error-username/404\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template could not be verified. Please double check that the template is a valid GitHub repository and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when something unknown goes wrong with the repo request (4xx)","suites":["the create command","errors"],"updatePoint":{"line":690,"column":80},"line":690,"code":"    it(\"identifies when something unknown goes wrong with the repo request (4xx)\", async () => {\n      let projectDir = await getProjectDir(\"repo\");\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"error-username/400\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template could not be verified. The server returned a response with a 400 status. Please double check that the template is a valid GitHub repository and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when a remote tarball does not exist (404)","suites":["the create command","errors"],"updatePoint":{"line":706,"column":61},"line":706,"code":"    it(\"identifies when a remote tarball does not exist (404)\", async () => {\n      let projectDir = await getProjectDir(\"remote-tarball\");\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"https://example.com/error/404/remix-stack.tar.gz\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template file could not be verified. Please double check the URL and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"identifies when a remote tarball does not exist (4xx)","suites":["the create command","errors"],"updatePoint":{"line":722,"column":61},"line":722,"code":"    it(\"identifies when a remote tarball does not exist (4xx)\", async () => {\n      let projectDir = await getProjectDir(\"remote-tarball\");\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"https://example.com/error/400/remix-stack.tar.gz\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The template file could not be verified. The server returned a response with a 400 status. Please double check the URL and try again.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows creating an app in a dir if it's empty","suites":["the create command","errors"],"updatePoint":{"line":738,"column":53},"line":738,"code":"    it(\"allows creating an app in a dir if it's empty\", async () => {\n      let projectDir = await getProjectDir(\"other-empty-dir\");\n      await run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        \"grunge-stack\",\n        \"--no-install\",\n        \"--typescript\",\n      ]);\n\n      expect(\n        fse.existsSync(path.join(projectDir, \"package.json\"))\n      ).toBeTruthy();\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"doesn't allow creating an app in a dir if it's not empty","suites":["the create command","errors"],"updatePoint":{"line":754,"column":64},"line":754,"code":"    it(\"doesn't allow creating an app in a dir if it's not empty\", async () => {\n      let projectDir = await getProjectDir(\"not-empty-dir\");\n      fse.mkdirSync(projectDir);\n      fse.createFileSync(path.join(projectDir, \"some-file.txt\"));\n      await expect(() =>\n        run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"grunge-stack\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The project directory must be empty to create a new project. Please clear the contents of the directory or choose a different path.]`\n      );\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows creating an app in the current dir if it's empty","suites":["the create command","errors"],"updatePoint":{"line":772,"column":63},"line":772,"code":"    it(\"allows creating an app in the current dir if it's empty\", async () => {\n      let projectDir = await getProjectDir(\"empty-dir\");\n      let cwd = process.cwd();\n      fse.mkdirSync(projectDir);\n      process.chdir(projectDir);\n      await run([\n        \"create\",\n        \".\",\n        \"--template\",\n        \"grunge-stack\",\n        \"--no-install\",\n        \"--typescript\",\n      ]);\n      process.chdir(cwd);\n\n      expect(\n        fse.existsSync(path.join(projectDir, \"package.json\"))\n      ).toBeTruthy();\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"doesn't allow creating an app in the current dir if it's not empty","suites":["the create command","errors"],"updatePoint":{"line":792,"column":74},"line":792,"code":"    it(\"doesn't allow creating an app in the current dir if it's not empty\", async () => {\n      let projectDir = await getProjectDir(\"not-empty-dir\");\n      let cwd = process.cwd();\n      fse.mkdirSync(projectDir);\n      fse.createFileSync(path.join(projectDir, \"some-file.txt\"));\n      process.chdir(projectDir);\n      await expect(() =>\n        run([\n          \"create\",\n          \".\",\n          \"--template\",\n          \"grunge-stack\",\n          \"--no-install\",\n          \"--typescript\",\n        ])\n      ).rejects.toMatchInlineSnapshot(\n        `[Error: 🚨 The project directory must be empty to create a new project. Please clear the contents of the directory or choose a different path.]`\n      );\n      process.chdir(cwd);\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"uses the proxy from env var","suites":["the create command","supports proxy usage"],"updatePoint":{"line":821,"column":35},"line":821,"code":"    it(\"uses the proxy from env var\", async () => {\n      let projectDir = await getProjectDir(\"template\");\n      let error: Error | undefined;\n      let prevProxy = process.env.HTTPS_PROXY;\n      try {\n        process.env.HTTPS_PROXY = \"http://127.0.0.1:33128\";\n        await run([\n          \"create\",\n          projectDir,\n          \"--template\",\n          \"grunge-stack\",\n          \"--no-install\",\n          \"--typescript\",\n        ]);\n      } catch (err) {\n        error = err;\n      } finally {\n        process.env.HTTPS_PROXY = prevProxy;\n      }\n      expect(error?.message).toMatch(\"127.0.0.1:33\");\n    });","file":"create-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"side-effect require","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":7,"column":29},"line":7,"code":"    test(\"side-effect require\", () => {\n      let code = dedent`\n        require(\"./foo.css\");\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"side-effect import","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":17,"column":28},"line":17,"code":"    test(\"side-effect import\", () => {\n      let code = dedent`\n        import \"./foo.css\";\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"import \\\\\"./foo.css?__remix_sideEffect__\\\\\";\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"side-effect import with JSX","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":27,"column":37},"line":27,"code":"    test(\"side-effect import with JSX\", () => {\n      let code = dedent`\n        import \"./foo.css\";\n        \n        export const Foo = () => <div />;\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"jsx\", code))\n        .toMatchInlineSnapshot(`\n        \"import \\\\\"./foo.css?__remix_sideEffect__\\\\\";\n\n        export const Foo = () => <div />;\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"side-effect import in TypeScript","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":42,"column":42},"line":42,"code":"    test(\"side-effect import in TypeScript\", () => {\n      let code = dedent`\n        require(\"./foo.css\");\n        \n        export const foo: string = 'foo' satisfies string;\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"ts\", code))\n        .toMatchInlineSnapshot(`\n        \"require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\n\n        export const foo: string = ('foo' satisfies string);\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"side-effect import in TypeScript with JSX","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":57,"column":51},"line":57,"code":"    test(\"side-effect import in TypeScript with JSX\", () => {\n      let code = dedent`\n        require(\"./foo.css\");\n        \n        export const foo: string = 'foo' satisfies string;\n        export const Bar = () => <div>{foo}</div>;\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"tsx\", code))\n        .toMatchInlineSnapshot(`\n        \"require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\n\n        export const foo: string = ('foo' satisfies string);\n        export const Bar = () => <div>{foo}</div>;\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"conditional side-effect require","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":74,"column":41},"line":74,"code":"    test(\"conditional side-effect require\", () => {\n      let code = dedent`\n        if (process.env.NODE_ENV === \"production\") {\n          require(\"./foo.min.css\");\n        } else {\n          require(\"./foo.css\");\n        }\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code))\n        .toMatchInlineSnapshot(`\n        \"if (process.env.NODE_ENV === \\\\\"production\\\\\") {\n          require(\\\\\"./foo.min.css?__remix_sideEffect__\\\\\");\n        } else {\n          require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\n        }\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"conditional side-effect require via ternary","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":93,"column":53},"line":93,"code":"    test(\"conditional side-effect require via ternary\", () => {\n      let code = dedent`\n        process.env.NODE_ENV === \"production\" ? require(\"./foo.min.css\") : require(\"./foo.css\");\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"process.env.NODE_ENV === \\\\\"production\\\\\" ? require(\\\\\"./foo.min.css?__remix_sideEffect__\\\\\") : require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"conditional side-effect require via && operator","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":103,"column":57},"line":103,"code":"    test(\"conditional side-effect require via && operator\", () => {\n      let code = dedent`\n        process.env.NODE_ENV === \"development\" && require(\"./debug.css\");\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"process.env.NODE_ENV === \\\\\"development\\\\\" && require(\\\\\"./debug.css?__remix_sideEffect__\\\\\");\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"conditional side-effect require via || operator","suites":["addSuffixToCssSideEffectImports","adds suffix"],"updatePoint":{"line":113,"column":57},"line":113,"code":"    test(\"conditional side-effect require via || operator\", () => {\n      let code = dedent`\n        process.env.NODE_ENV === \"production\" || require(\"./debug.css\");\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"process.env.NODE_ENV === \\\\\"production\\\\\" || require(\\\\\"./debug.css?__remix_sideEffect__\\\\\");\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores non side-effect require of CSS","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":125,"column":48},"line":125,"code":"    test(\"ignores non side-effect require of CSS\", () => {\n      let code = dedent`\n        const href = require(\"./foo.css\");\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"const href = require(\\\\\"./foo.css\\\\\");\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores default import of CSS","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":135,"column":39},"line":135,"code":"    test(\"ignores default import of CSS\", () => {\n      let code = dedent`\n        import href from \"./foo.css\";\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"import href from \\\\\"./foo.css\\\\\";\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores named import of CSS","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":145,"column":37},"line":145,"code":"    test(\"ignores named import of CSS\", () => {\n      let code = dedent`\n        import { foo } from \"./foo.css\";\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"import { foo } from \\\\\"./foo.css\\\\\";\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores namespace import of CSS","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":155,"column":41},"line":155,"code":"    test(\"ignores namespace import of CSS\", () => {\n      let code = dedent`\n        import * as foo from \"./foo.css\";\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"import * as foo from \\\\\"./foo.css\\\\\";\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores conditional non side-effect require of CSS","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":165,"column":60},"line":165,"code":"    test(\"ignores conditional non side-effect require of CSS\", () => {\n      let code = dedent`\n        const href = process.env.NODE_ENV === \"production\" ?\n          require(\"./foo.min.css\") :\n          require(\"./foo.css\");\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code))\n        .toMatchInlineSnapshot(`\n        \"const href = process.env.NODE_ENV === \\\\\"production\\\\\" ?\n        require(\\\\\"./foo.min.css\\\\\") :\n        require(\\\\\"./foo.css\\\\\");\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores conditional non side-effect require of CSS via logical operators","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":180,"column":82},"line":180,"code":"    test(\"ignores conditional non side-effect require of CSS via logical operators\", () => {\n      let code = dedent`\n        const href = (process.env.NODE_ENV === \"production\" && require(\"./foo.min.css\")) || require(\"./foo.css\");\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"const href = process.env.NODE_ENV === \\\\\"production\\\\\" && require(\\\\\"./foo.min.css\\\\\") || require(\\\\\"./foo.css\\\\\");\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores side-effect require of non-CSS","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":190,"column":48},"line":190,"code":"    test(\"ignores side-effect require of non-CSS\", () => {\n      let code = dedent`\n        require(\"./foo\");\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"require(\\\\\"./foo\\\\\");\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores side-effect import of non-CSS","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":200,"column":47},"line":200,"code":"    test(\"ignores side-effect import of non-CSS\", () => {\n      let code = dedent`\n        import \"./foo\";\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code)).toMatchInlineSnapshot(\n        `\"import \\\\\"./foo\\\\\";\"`\n      );\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"ignores dynamic import","suites":["addSuffixToCssSideEffectImports","doesn't add suffix"],"updatePoint":{"line":210,"column":32},"line":210,"code":"    test(\"ignores dynamic import\", () => {\n      let code = dedent`\n        export const foo = async () => {\n          await import(\"./foo.css\");\n        }\n      `;\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code))\n        .toMatchInlineSnapshot(`\n        \"export const foo = async () => {\n          await import(\\\\\"./foo.css\\\\\");\n        };\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"JS language features","suites":["addSuffixToCssSideEffectImports","parser support for language features"],"updatePoint":{"line":286,"column":30},"line":286,"code":"    test(\"JS language features\", () => {\n      let code = languageFeaturesFixture({ ts: false, jsx: false });\n\n      expect(addSuffixToCssSideEffectImports(\"js\", code))\n        .toMatchInlineSnapshot(`\n        \"require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\n\n        // JS\n        const topLevelAwait = await Promise.resolve('top level await');\n        function classDecorator(target) {\n          return target;\n        }\n        function methodDecorator(target) {\n          return target;\n        }\n        @classDecorator class\n        ExampleClass {\n          #privateField;\n          #privateFieldWithInitializer = 'private field with initializer';\n          #privateMethod() {\n            return 'private method';\n          }\n          @methodDecorator\n          decoratedMethod() {\n            return 'decorated method';\n          }\n        }\n        const numericSeparator = 1_000_000;\n        const nullishCoalescing = null ?? 'nullish coalescing';\n        const optionalChaining = ['optional', 'chaining']?.join?.(' ');\n        let optionalCatchBinding;\n        try {\n          optionalCatchBinding = error();\n        } catch {\n          optionalCatchBinding = 'optional catch binding';\n        }\n        export async function* asyncGenerator() {\n          yield await Promise.resolve('async generator');\n        }\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"JSX language features","suites":["addSuffixToCssSideEffectImports","parser support for language features"],"updatePoint":{"line":328,"column":31},"line":328,"code":"    test(\"JSX language features\", () => {\n      let code = languageFeaturesFixture({ ts: false, jsx: true });\n\n      expect(addSuffixToCssSideEffectImports(\"jsx\", code))\n        .toMatchInlineSnapshot(`\n        \"require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\n\n        // JSX\n        const ExampleComponent = () => <div>JSX element</div>;\n\n        // JS\n        const topLevelAwait = await Promise.resolve('top level await');\n        function classDecorator(target) {\n          return target;\n        }\n        function methodDecorator(target) {\n          return target;\n        }\n        @classDecorator class\n        ExampleClass {\n          #privateField;\n          #privateFieldWithInitializer = 'private field with initializer';\n          #privateMethod() {\n            return 'private method';\n          }\n          @methodDecorator\n          decoratedMethod() {\n            return 'decorated method';\n          }\n        }\n        const numericSeparator = 1_000_000;\n        const nullishCoalescing = null ?? 'nullish coalescing';\n        const optionalChaining = ['optional', 'chaining']?.join?.(' ');\n        let optionalCatchBinding;\n        try {\n          optionalCatchBinding = error();\n        } catch {\n          optionalCatchBinding = 'optional catch binding';\n        }\n        export async function* asyncGenerator() {\n          yield await Promise.resolve('async generator');\n        }\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"TS language features","suites":["addSuffixToCssSideEffectImports","parser support for language features"],"updatePoint":{"line":373,"column":30},"line":373,"code":"    test(\"TS language features\", () => {\n      let code = languageFeaturesFixture({ ts: true, jsx: false });\n\n      expect(addSuffixToCssSideEffectImports(\"tsx\", code))\n        .toMatchInlineSnapshot(`\n        \"require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\n\n        // TS\n        const exampleSatisfies = ('satisfies' satisfies string);\n        enum ExampleEnum {\n          Foo,\n          Bar,\n          Baz,\n        }\n\n        // JS\n        const topLevelAwait = await Promise.resolve('top level await');\n        function classDecorator(target) {\n          return target;\n        }\n        function methodDecorator(target) {\n          return target;\n        }\n        @classDecorator class\n        ExampleClass {\n          #privateField;\n          #privateFieldWithInitializer = 'private field with initializer';\n          #privateMethod() {\n            return 'private method';\n          }\n          @methodDecorator\n          decoratedMethod() {\n            return 'decorated method';\n          }\n        }\n        const numericSeparator = 1_000_000;\n        const nullishCoalescing = null ?? 'nullish coalescing';\n        const optionalChaining = ['optional', 'chaining']?.join?.(' ');\n        let optionalCatchBinding;\n        try {\n          optionalCatchBinding = error();\n        } catch {\n          optionalCatchBinding = 'optional catch binding';\n        }\n        export async function* asyncGenerator() {\n          yield await Promise.resolve('async generator');\n        }\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"TSX language features","suites":["addSuffixToCssSideEffectImports","parser support for language features"],"updatePoint":{"line":423,"column":31},"line":423,"code":"    test(\"TSX language features\", () => {\n      let code = languageFeaturesFixture({ ts: true, jsx: true });\n\n      expect(addSuffixToCssSideEffectImports(\"tsx\", code))\n        .toMatchInlineSnapshot(`\n        \"require(\\\\\"./foo.css?__remix_sideEffect__\\\\\");\n\n        // TS\n        const exampleSatisfies = ('satisfies' satisfies string);\n        enum ExampleEnum {\n          Foo,\n          Bar,\n          Baz,\n        }\n\n        // JSX\n        const ExampleComponent = () => <div>JSX element</div>;\n\n        // JS\n        const topLevelAwait = await Promise.resolve('top level await');\n        function classDecorator(target) {\n          return target;\n        }\n        function methodDecorator(target) {\n          return target;\n        }\n        @classDecorator class\n        ExampleClass {\n          #privateField;\n          #privateFieldWithInitializer = 'private field with initializer';\n          #privateMethod() {\n            return 'private method';\n          }\n          @methodDecorator\n          decoratedMethod() {\n            return 'decorated method';\n          }\n        }\n        const numericSeparator = 1_000_000;\n        const nullishCoalescing = null ?? 'nullish coalescing';\n        const optionalChaining = ['optional', 'chaining']?.join?.(' ');\n        let optionalCatchBinding;\n        try {\n          optionalCatchBinding = error();\n        } catch {\n          optionalCatchBinding = 'optional catch binding';\n        }\n        export async function* asyncGenerator() {\n          yield await Promise.resolve('async generator');\n        }\"\n      `);\n    });","file":"cssSideEffectImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"returns an array of routes","suites":["defineRoutes"],"updatePoint":{"line":4,"column":32},"line":4,"code":"  it(\"returns an array of routes\", () => {\n    let routes = defineRoutes((route) => {\n      route(\"/\", \"routes/home.js\");\n      route(\"inbox\", \"routes/inbox.js\", () => {\n        route(\"/\", \"routes/inbox/index.js\", { index: true });\n        route(\":messageId\", \"routes/inbox/$messageId.js\");\n        route(\"archive\", \"routes/inbox/archive.js\");\n      });\n    });\n\n    expect(routes).toMatchInlineSnapshot(`\n      Object {\n        \"routes/home\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/home.js\",\n          \"id\": \"routes/home\",\n          \"index\": undefined,\n          \"parentId\": \"root\",\n          \"path\": \"/\",\n        },\n        \"routes/inbox\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/inbox.js\",\n          \"id\": \"routes/inbox\",\n          \"index\": undefined,\n          \"parentId\": \"root\",\n          \"path\": \"inbox\",\n        },\n        \"routes/inbox/$messageId\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/inbox/$messageId.js\",\n          \"id\": \"routes/inbox/$messageId\",\n          \"index\": undefined,\n          \"parentId\": \"routes/inbox\",\n          \"path\": \":messageId\",\n        },\n        \"routes/inbox/archive\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/inbox/archive.js\",\n          \"id\": \"routes/inbox/archive\",\n          \"index\": undefined,\n          \"parentId\": \"routes/inbox\",\n          \"path\": \"archive\",\n        },\n        \"routes/inbox/index\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/inbox/index.js\",\n          \"id\": \"routes/inbox/index\",\n          \"index\": true,\n          \"parentId\": \"routes/inbox\",\n          \"path\": \"/\",\n        },\n      }\n    `);\n  });","file":"defineRoutes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"works with async data","suites":["defineRoutes"],"updatePoint":{"line":60,"column":27},"line":60,"code":"  it(\"works with async data\", async () => {\n    // Read everything *before* calling defineRoutes.\n    let fakeDirectory = await Promise.resolve([\"one.md\", \"two.md\"]);\n    let routes = defineRoutes((route) => {\n      for (let file of fakeDirectory) {\n        route(file.replace(/\\.md$/, \"\"), file);\n      }\n    });\n\n    expect(routes).toMatchInlineSnapshot(`\n      Object {\n        \"one\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"one.md\",\n          \"id\": \"one\",\n          \"index\": undefined,\n          \"parentId\": \"root\",\n          \"path\": \"one\",\n        },\n        \"two\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"two.md\",\n          \"id\": \"two\",\n          \"index\": undefined,\n          \"parentId\": \"root\",\n          \"path\": \"two\",\n        },\n      }\n    `);\n  });","file":"defineRoutes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"allows multiple routes with the same route module","suites":["defineRoutes"],"updatePoint":{"line":91,"column":55},"line":91,"code":"  it(\"allows multiple routes with the same route module\", () => {\n    let routes = defineRoutes((route) => {\n      route(\"/user/:id\", \"routes/index.tsx\", { id: \"user-by-id\" });\n      route(\"/user\", \"routes/index.tsx\", { id: \"user\" });\n      route(\"/other\", \"routes/other-route.tsx\");\n    });\n\n    expect(routes).toMatchInlineSnapshot(`\n      Object {\n        \"routes/other-route\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/other-route.tsx\",\n          \"id\": \"routes/other-route\",\n          \"index\": undefined,\n          \"parentId\": \"root\",\n          \"path\": \"/other\",\n        },\n        \"user\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/index.tsx\",\n          \"id\": \"user\",\n          \"index\": undefined,\n          \"parentId\": \"root\",\n          \"path\": \"/user\",\n        },\n        \"user-by-id\": Object {\n          \"caseSensitive\": undefined,\n          \"file\": \"routes/index.tsx\",\n          \"id\": \"user-by-id\",\n          \"index\": undefined,\n          \"parentId\": \"root\",\n          \"path\": \"/user/:id\",\n        },\n      }\n    `);\n  });","file":"defineRoutes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"throws an error on route id collisions","suites":["defineRoutes"],"updatePoint":{"line":128,"column":44},"line":128,"code":"  it(\"throws an error on route id collisions\", () => {\n    // Two conflicting custom id's\n    let defineNonUniqueRoutes = () => {\n      defineRoutes((route) => {\n        route(\"/user/:id\", \"routes/user.tsx\", { id: \"user\" });\n        route(\"/user\", \"routes/user.tsx\", { id: \"user\" });\n        route(\"/other\", \"routes/other-route.tsx\");\n      });\n    };\n\n    expect(defineNonUniqueRoutes).toThrowErrorMatchingInlineSnapshot(\n      `\"Unable to define routes with duplicate route id: \\\\\"user\\\\\"\"`\n    );\n\n    // Custom id conflicting with a later-defined auto-generated id\n    defineNonUniqueRoutes = () => {\n      defineRoutes((route) => {\n        route(\"/user/:id\", \"routes/user.tsx\", { id: \"routes/user\" });\n        route(\"/user\", \"routes/user.tsx\");\n      });\n    };\n\n    expect(defineNonUniqueRoutes).toThrowErrorMatchingInlineSnapshot(\n      `\"Unable to define routes with duplicate route id: \\\\\"routes/user\\\\\"\"`\n    );\n\n    // Custom id conflicting with an earlier-defined auto-generated id\n    defineNonUniqueRoutes = () => {\n      defineRoutes((route) => {\n        route(\"/user\", \"routes/user.tsx\");\n        route(\"/user/:id\", \"routes/user.tsx\", { id: \"routes/user\" });\n      });\n    };\n\n    expect(defineNonUniqueRoutes).toThrowErrorMatchingInlineSnapshot(\n      `\"Unable to define routes with duplicate route id: \\\\\"routes/user\\\\\"\"`\n    );\n  });","file":"defineRoutes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"validateEmail returns false for non-emails","suites":[],"updatePoint":{"line":3,"column":48},"line":3,"code":"test(\"validateEmail returns false for non-emails\", () => {\n  expect(validateEmail(undefined)).toBe(false);\n  expect(validateEmail(null)).toBe(false);\n  expect(validateEmail(\"\")).toBe(false);\n  expect(validateEmail(\"not-an-email\")).toBe(false);\n  expect(validateEmail(\"n@\")).toBe(false);\n});","file":"fixtures/replace-remix-magic-imports/app/utils.test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"validateEmail returns true for emails","suites":[],"updatePoint":{"line":11,"column":43},"line":11,"code":"test(\"validateEmail returns true for emails\", () => {\n  expect(validateEmail(\"kody@example.com\")).toBe(true);\n});","file":"fixtures/replace-remix-magic-imports/app/utils.test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"\"\" -> \"\"","suites":["flatRoutes","creates proper route paths"],"updatePoint":{"line":89,"column":37},"line":89,"code":"      it(`\"${input}\" -> \"${expected}\"`, () => {\n        if (input.endsWith(\"/route\") || input.endsWith(\"/index\")) {\n          input = input.replace(/\\/(route|index)$/, \"\");\n        }\n        let routeInfo = manifest[path.posix.join(\"routes\", input)];\n        expect(routeInfo.path).toBe(expected);\n      });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"should error when using `/` in a route segment","suites":["flatRoutes","creates proper route paths"],"updatePoint":{"line":104,"column":58},"line":104,"code":"      test(\"should error when using `/` in a route segment\", () => {\n        let regex = new RegExp(\n          /Route segment (\".*?\") for (\".*?\") cannot contain \"\\/\"/\n        );\n        expect(() => getRouteSegments(invalid)).toThrow(regex);\n      });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"should error when using `*` in a route segment","suites":["flatRoutes","creates proper route paths"],"updatePoint":{"line":119,"column":58},"line":119,"code":"      test(\"should error when using `*` in a route segment\", () => {\n        let regex = new RegExp(\n          /Route segment (\".*?\") for (\".*?\") cannot contain \"\\*\"/\n        );\n        expect(() => getRouteSegments(invalid)).toThrow(regex);\n      });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"should error when using `:` in a route segment","suites":["flatRoutes","creates proper route paths"],"updatePoint":{"line":133,"column":58},"line":133,"code":"      test(\"should error when using `:` in a route segment\", () => {\n        let regex = new RegExp(\n          /Route segment (\".*?\") for (\".*?\") cannot contain \":\"/\n        );\n        expect(() => getRouteSegments(invalid)).toThrow(regex);\n      });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"hierarchy for  - ","suites":["flatRoutes","should return the correct route hierarchy"],"updatePoint":{"line":640,"column":49},"line":640,"code":"      test(`hierarchy for ${file} - ${route.path}`, () => {\n        expect(routes).toContainEqual(route);\n      });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"same number of segments and the same dynamic segment index","suites":["flatRoutes","doesn't warn when there's not a route collision"],"updatePoint":{"line":653,"column":68},"line":653,"code":"    test(\"same number of segments and the same dynamic segment index\", () => {\n      let testFiles = [\n        path.join(APP_DIR, \"routes\", \"_user.$username.tsx\"),\n        path.join(APP_DIR, \"routes\", \"sneakers.$sneakerId.tsx\"),\n      ];\n\n      let routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      let routes = Object.values(routeManifest);\n\n      expect(routes).toHaveLength(testFiles.length);\n      expect(consoleError).not.toHaveBeenCalled();\n    });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"index files","suites":["flatRoutes","warns when there's a route collision"],"updatePoint":{"line":675,"column":21},"line":675,"code":"    test(\"index files\", () => {\n      let testFiles = [\n        path.join(\"routes\", \"_dashboard._index.tsx\"),\n        path.join(\"routes\", \"_landing._index.tsx\"),\n        path.join(\"routes\", \"_index.tsx\"),\n      ];\n\n      // route manifest uses the full path\n      let fullPaths = testFiles.map((file) => path.join(APP_DIR, file));\n\n      // this is for the expected error message,\n      // which uses the relative path from the app directory internally\n      let normalizedTestFiles = testFiles.map((file) => normalizeSlashes(file));\n\n      let routeManifest = flatRoutesUniversal(APP_DIR, fullPaths);\n\n      let routes = Object.values(routeManifest);\n\n      expect(routes).toHaveLength(1);\n      expect(consoleError).toHaveBeenCalledWith(\n        getRoutePathConflictErrorMessage(\"/\", normalizedTestFiles)\n      );\n    });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"folder/route.tsx matching folder.tsx","suites":["flatRoutes","warns when there's a route collision"],"updatePoint":{"line":699,"column":46},"line":699,"code":"    test(\"folder/route.tsx matching folder.tsx\", () => {\n      let testFiles = [\n        path.join(\"routes\", \"dashboard\", \"route.tsx\"),\n        path.join(\"routes\", \"dashboard.tsx\"),\n      ];\n\n      // route manifest uses the full path\n      let fullPaths = testFiles.map((file) => path.join(APP_DIR, file));\n\n      // this is for the expected error message,\n      // which uses the relative path from the app directory internally\n      let normalizedTestFiles = testFiles.map((file) => normalizeSlashes(file));\n\n      let routeManifest = flatRoutesUniversal(APP_DIR, fullPaths);\n\n      let routes = Object.values(routeManifest);\n\n      expect(routes).toHaveLength(1);\n      expect(consoleError).toHaveBeenCalledWith(\n        getRouteIdConflictErrorMessage(\n          path.posix.join(\"routes\", \"dashboard\"),\n          normalizedTestFiles\n        )\n      );\n    });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"same path, different param name","suites":["flatRoutes","warns when there's a route collision"],"line":725,"code":"    test.skip(\"same path, different param name\", () => {","file":"flat-routes-test.ts","skipped":true,"dir":"packages/remix-dev/__tests__"},{"name":"pathless layouts should not collide","suites":["flatRoutes","warns when there's a route collision"],"updatePoint":{"line":741,"column":45},"line":741,"code":"    test(\"pathless layouts should not collide\", () => {\n      let testFiles = [\n        path.join(APP_DIR, \"routes\", \"_a.tsx\"),\n        path.join(APP_DIR, \"routes\", \"_a._index.tsx\"),\n        path.join(APP_DIR, \"routes\", \"_a.a.tsx\"),\n        path.join(APP_DIR, \"routes\", \"_b.tsx\"),\n        path.join(APP_DIR, \"routes\", \"_b.b.tsx\"),\n      ];\n\n      let routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      let routes = Object.values(routeManifest);\n\n      expect(consoleError).not.toHaveBeenCalled();\n      expect(routes).toHaveLength(5);\n\n      // When using folders and route.tsx files\n      testFiles = [\n        path.join(APP_DIR, \"routes\", \"_a\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"_a._index\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"_a.a\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"_b\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"_b.b\", \"route.tsx\"),\n      ];\n\n      routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      routes = Object.values(routeManifest);\n\n      expect(consoleError).not.toHaveBeenCalled();\n      expect(routes).toHaveLength(5);\n    });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"nested pathless layouts should not collide","suites":["flatRoutes","warns when there's a route collision"],"updatePoint":{"line":774,"column":52},"line":774,"code":"    test(\"nested pathless layouts should not collide\", () => {\n      let testFiles = [\n        path.join(APP_DIR, \"routes\", \"nested._a.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._a._index.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._a.a.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b.b.tsx\"),\n      ];\n\n      let routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      let routes = Object.values(routeManifest);\n\n      expect(consoleError).not.toHaveBeenCalled();\n      expect(routes).toHaveLength(5);\n\n      // When using folders and route.tsx files\n      testFiles = [\n        path.join(APP_DIR, \"routes\", \"nested._a\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._a._index\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._a.a\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b.b\", \"route.tsx\"),\n      ];\n\n      routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      routes = Object.values(routeManifest);\n\n      expect(consoleError).not.toHaveBeenCalled();\n      expect(routes).toHaveLength(5);\n    });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"legit collisions without nested pathless layouts should collide (paths)","suites":["flatRoutes","warns when there's a route collision"],"updatePoint":{"line":807,"column":81},"line":807,"code":"    test(\"legit collisions without nested pathless layouts should collide (paths)\", () => {\n      let testFiles = [\n        path.join(APP_DIR, \"routes\", \"nested._a.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._a.a.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b.a.tsx\"),\n      ];\n\n      let routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      let routes = Object.values(routeManifest);\n\n      expect(consoleError).toHaveBeenCalledWith(\n        getRoutePathConflictErrorMessage(\"/nested/a\", [\n          \"routes/nested._a.a.tsx\",\n          \"routes/nested._b.a.tsx\",\n        ])\n      );\n      expect(routes).toHaveLength(3);\n\n      // When using folders and route.tsx files\n      consoleError.mockClear();\n      testFiles = [\n        path.join(APP_DIR, \"routes\", \"nested._a\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._a.a\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b.a\", \"route.tsx\"),\n      ];\n\n      routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      routes = Object.values(routeManifest);\n\n      expect(consoleError).toHaveBeenCalledWith(\n        getRoutePathConflictErrorMessage(\"/nested/a\", [\n          \"routes/nested._a.a/route.tsx\",\n          \"routes/nested._b.a/route.tsx\",\n        ])\n      );\n      expect(routes).toHaveLength(3);\n    });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"legit collisions without nested pathless layouts should collide (index routes)","suites":["flatRoutes","warns when there's a route collision"],"updatePoint":{"line":849,"column":88},"line":849,"code":"    test(\"legit collisions without nested pathless layouts should collide (index routes)\", () => {\n      let testFiles = [\n        path.join(APP_DIR, \"routes\", \"nested._a.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._a._index.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b._index.tsx\"),\n      ];\n\n      let routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      let routes = Object.values(routeManifest);\n\n      expect(consoleError).toHaveBeenCalledWith(\n        getRoutePathConflictErrorMessage(\"/nested\", [\n          \"routes/nested._a._index.tsx\",\n          \"routes/nested._b._index.tsx\",\n        ])\n      );\n      expect(routes).toHaveLength(3);\n\n      // When using folders and route.tsx files\n      consoleError.mockClear();\n      testFiles = [\n        path.join(APP_DIR, \"routes\", \"nested._a\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._a._index\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b\", \"route.tsx\"),\n        path.join(APP_DIR, \"routes\", \"nested._b._index\", \"route.tsx\"),\n      ];\n\n      routeManifest = flatRoutesUniversal(APP_DIR, testFiles);\n\n      routes = Object.values(routeManifest);\n\n      expect(consoleError).toHaveBeenCalledWith(\n        getRoutePathConflictErrorMessage(\"/nested\", [\n          \"routes/nested._a._index/route.tsx\",\n          \"routes/nested._b._index/route.tsx\",\n        ])\n      );\n      expect(routes).toHaveLength(3);\n    });","file":"flat-routes-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"generates a config","suites":["readConfig"],"updatePoint":{"line":14,"column":24},"line":14,"code":"  it(\"generates a config\", async () => {\n    expect(config).toMatchInlineSnapshot(\n      {\n        rootDirectory: expect.any(String),\n        appDirectory: expect.any(String),\n        cacheDirectory: expect.any(String),\n        devServerPort: expect.any(Number),\n        serverBuildPath: expect.any(String),\n        assetsBuildDirectory: expect.any(String),\n        relativeAssetsBuildDirectory: expect.any(String),\n        entryClientFilePath: expect.any(String),\n        entryServerFilePath: expect.any(String),\n        tsconfigPath: expect.any(String),\n        future: {\n          unstable_postcss: expect.any(Boolean),\n          unstable_tailwind: expect.any(Boolean),\n          v2_errorBoundary: expect.any(Boolean),\n          v2_headers: expect.any(Boolean),\n          v2_meta: expect.any(Boolean),\n          v2_normalizeFormMethod: expect.any(Boolean),\n          v2_routeConvention: expect.any(Boolean),\n        },\n      },\n      `\n      Object {\n        \"appDirectory\": Any<String>,\n        \"assetsBuildDirectory\": Any<String>,\n        \"cacheDirectory\": Any<String>,\n        \"devServerBroadcastDelay\": 0,\n        \"devServerPort\": Any<Number>,\n        \"entryClientFile\": \"entry.client.tsx\",\n        \"entryClientFilePath\": Any<String>,\n        \"entryServerFile\": \"entry.server.tsx\",\n        \"entryServerFilePath\": Any<String>,\n        \"future\": Object {\n          \"unstable_postcss\": Any<Boolean>,\n          \"unstable_tailwind\": Any<Boolean>,\n          \"v2_dev\": false,\n          \"v2_errorBoundary\": Any<Boolean>,\n          \"v2_headers\": Any<Boolean>,\n          \"v2_meta\": Any<Boolean>,\n          \"v2_normalizeFormMethod\": Any<Boolean>,\n          \"v2_routeConvention\": Any<Boolean>,\n        },\n        \"mdx\": undefined,\n        \"postcss\": false,\n        \"publicPath\": \"/build/\",\n        \"relativeAssetsBuildDirectory\": Any<String>,\n        \"rootDirectory\": Any<String>,\n        \"routes\": Object {\n          \"root\": Object {\n            \"file\": \"root.tsx\",\n            \"id\": \"root\",\n            \"path\": \"\",\n          },\n        },\n        \"serverBuildPath\": Any<String>,\n        \"serverBuildTarget\": \"node-cjs\",\n        \"serverBuildTargetEntryModule\": \"export * from \\\\\"@remix-run/dev/server-build\\\\\";\",\n        \"serverConditions\": undefined,\n        \"serverDependenciesToBundle\": Array [],\n        \"serverEntryPoint\": undefined,\n        \"serverMainFields\": Array [\n          \"main\",\n          \"module\",\n        ],\n        \"serverMinify\": false,\n        \"serverMode\": \"production\",\n        \"serverModuleFormat\": \"cjs\",\n        \"serverPlatform\": \"node\",\n        \"tailwind\": false,\n        \"tsconfigPath\": Any<String>,\n        \"watchPaths\": Array [],\n      }\n    `\n    );\n  });","file":"readConfig-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"returns the same devServerPort value across reloads","suites":["readConfig"],"updatePoint":{"line":92,"column":57},"line":92,"code":"  it(\"returns the same devServerPort value across reloads\", async () => {\n    let newConfig = await readConfig(remixRoot);\n    expect(newConfig.devServerPort).toBe(config.devServerPort);\n  });","file":"readConfig-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"generates a \"\" specific entry.server.tsx file in the app directory","suites":["the reveal command"],"updatePoint":{"line":73,"column":84},"line":73,"code":"    it(`generates a \"${runtime}\" specific entry.server.tsx file in the app directory`, async () => {\n      let projectDir = await getProjectDir(`entry.server.${runtime}`);\n      await run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        pathToFileURL(path.join(__dirname, \"fixtures\", runtime)).toString(),\n        \"--no-install\",\n        \"--typescript\",\n      ]);\n\n      let entryClientFile = path.join(projectDir, \"app\", \"entry.client.tsx\");\n      let entryServerFile = path.join(projectDir, \"app\", \"entry.server.tsx\");\n\n      expect(fse.existsSync(entryServerFile)).toBeFalsy();\n      expect(fse.existsSync(entryClientFile)).toBeFalsy();\n\n      await run([\"reveal\", \"entry.server\", projectDir]);\n      await run([\"reveal\", \"entry.client\", projectDir]);\n\n      expect(fse.existsSync(entryServerFile)).toBeTruthy();\n      expect(fse.existsSync(entryClientFile)).toBeTruthy();\n    });","file":"reveal-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"generates a \"\" specific entry.server.jsx file in the app directory","suites":["the reveal command"],"updatePoint":{"line":97,"column":84},"line":97,"code":"    it(`generates a \"${runtime}\" specific entry.server.jsx file in the app directory`, async () => {\n      let projectDir = await getProjectDir(`entry.server.${runtime}-js`);\n      await run([\n        \"create\",\n        projectDir,\n        \"--template\",\n        pathToFileURL(path.join(__dirname, \"fixtures\", runtime)).toString(),\n        \"--no-install\",\n        \"--typescript\",\n      ]);\n\n      let entryClientFile = path.join(projectDir, \"app\", \"entry.client.jsx\");\n      let entryServerFile = path.join(projectDir, \"app\", \"entry.server.jsx\");\n\n      expect(fse.existsSync(entryServerFile)).toBeFalsy();\n      expect(fse.existsSync(entryClientFile)).toBeFalsy();\n\n      await run([\"reveal\", \"entry.server\", projectDir, \"--no-typescript\"]);\n      await run([\"reveal\", \"entry.client\", projectDir, \"--no-typescript\"]);\n\n      expect(fse.existsSync(entryServerFile)).toBeTruthy();\n      expect(fse.existsSync(entryClientFile)).toBeTruthy();\n    });","file":"reveal-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"\"\" -> \"\"","suites":["createRoutePath","creates proper route paths"],"updatePoint":{"line":85,"column":37},"line":85,"code":"      it(`\"${input}\" -> \"${expected}\"`, () => {\n        expect(createRoutePath(input)).toBe(expected);\n      });","file":"routesConvention-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"will only work when starting and ending a segment with parenthesis","suites":["createRoutePath","creates proper route paths","optional segments"],"updatePoint":{"line":91,"column":76},"line":91,"code":"      it(\"will only work when starting and ending a segment with parenthesis\", () => {\n        let [input, expected] = [\"(routes.sub)/$\", \"(routes/sub)/*\"];\n        expect(createRoutePath(input)).toBe(expected);\n      });","file":"routesConvention-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"throws error on optional to splat routes","suites":["createRoutePath","creates proper route paths","optional segments"],"updatePoint":{"line":96,"column":50},"line":96,"code":"      it(\"throws error on optional to splat routes\", () => {\n        expect(() => createRoutePath(\"(routes)/($)\")).toThrow(\"Splat\");\n        expect(() => createRoutePath(\"($)\")).toThrow(\"Splat\");\n      });","file":"routesConvention-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"throws errors on optional index without brackets routes","suites":["createRoutePath","creates proper route paths","optional segments"],"updatePoint":{"line":101,"column":65},"line":101,"code":"      it(\"throws errors on optional index without brackets routes\", () => {\n        expect(() => createRoutePath(\"(nested)/(index)\")).toThrow(\"index\");\n        expect(() => createRoutePath(\"(flat).(index)\")).toThrow(\"index\");\n        expect(() => createRoutePath(\"(index)\")).toThrow(\"index\");\n      });","file":"routesConvention-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"creates a route manifest from the routes directory","suites":["defineConventionalRoutes"],"updatePoint":{"line":111,"column":56},"line":111,"code":"  it(\"creates a route manifest from the routes directory\", () => {\n    let routes = defineConventionalRoutes(\n      path.join(__dirname, \"fixtures/replace-remix-magic-imports/app\")\n    );\n    let keys = Object.keys(routes);\n    expect(keys).toHaveLength(14);\n    expect(keys.filter((key) => routes[key].parentId).length).toBe(14);\n    expect(keys.filter((key) => routes[key].index).length).toBe(4);\n  });","file":"routesConvention-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces single-specifier imports","suites":[],"updatePoint":{"line":4,"column":37},"line":4,"code":"it(\"replaces single-specifier imports\", async () => {\n  let code = [\n    'import { json } from \"remix\"',\n    'import type { GetLoadContextFunction } from \"remix\"',\n    'import { type LinkProps } from \"remix\"',\n  ].join(\"\\n\");\n  let transform = replaceRemixMagicImports({\n    runtime: \"node\",\n    adapter: \"express\",\n  });\n  let result = eol.normalize(transform(code, \"fake.tsx\"));\n  expect(result).toBe(\n    [\n      'import { type GetLoadContextFunction } from \"@remix-run/express\";',\n      'import { json } from \"@remix-run/node\";',\n      'import { type LinkProps } from \"@remix-run/react\";',\n    ].join(\"\\n\")\n  );\n});","file":"transform-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces single-kind, multi-specifier imports","suites":[],"updatePoint":{"line":24,"column":49},"line":24,"code":"it(\"replaces single-kind, multi-specifier imports\", async () => {\n  let code = [\n    'import { json, createRequestHandler, Form } from \"remix\"',\n    'import type { ActionFunction, GetLoadContextFunction, LinkProps } from \"remix\"',\n    'import { type Cookie, type RequestHandler, type NavLinkProps } from \"remix\"',\n  ].join(\"\\n\");\n  let transform = replaceRemixMagicImports({\n    runtime: \"node\",\n    adapter: \"express\",\n  });\n  let result = eol.normalize(transform(code, \"fake.tsx\"));\n  expect(result).toBe(\n    [\n      'import { type GetLoadContextFunction, type RequestHandler, createRequestHandler } from \"@remix-run/express\";',\n      'import { type ActionFunction, type Cookie, json } from \"@remix-run/node\";',\n      'import { type LinkProps, type NavLinkProps, Form } from \"@remix-run/react\";',\n    ].join(\"\\n\")\n  );\n});","file":"transform-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces multi-kind, multi-specifier imports","suites":[],"updatePoint":{"line":44,"column":48},"line":44,"code":"it(\"replaces multi-kind, multi-specifier imports\", async () => {\n  let code = [\n    'import { json, type ActionFunction, createRequestHandler, type GetLoadContextFunction, Form, type LinkProps } from \"remix\"',\n  ].join(\"\\n\");\n  let transform = replaceRemixMagicImports({\n    runtime: \"node\",\n    adapter: \"express\",\n  });\n  let result = eol.normalize(transform(code, \"fake.tsx\"));\n  expect(result).toBe(\n    [\n      'import { type GetLoadContextFunction, createRequestHandler } from \"@remix-run/express\";',\n      'import { type ActionFunction, json } from \"@remix-run/node\";',\n      'import { type LinkProps, Form } from \"@remix-run/react\";',\n    ].join(\"\\n\")\n  );\n});","file":"transform-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"replaces runtime-specific and adapter-specific imports","suites":[],"updatePoint":{"line":62,"column":58},"line":62,"code":"it(\"replaces runtime-specific and adapter-specific imports\", async () => {\n  let code = [\n    'import { json, createWorkersKVSessionStorage, createRequestHandler, createPagesFunctionHandler, Form } from \"remix\"',\n    'import type { ActionFunction, GetLoadContextFunction, createPagesFunctionHandlerParams, LinkProps } from \"remix\"',\n  ].join(\"\\n\");\n  let transform = replaceRemixMagicImports({\n    runtime: \"cloudflare\",\n    adapter: \"cloudflare-pages\",\n  });\n  let result = eol.normalize(transform(code, \"fake.tsx\"));\n  expect(result).toBe(\n    [\n      'import { type ActionFunction, createWorkersKVSessionStorage, json } from \"@remix-run/cloudflare\";',\n      \"\", // recast adds a newline here https://github.com/benjamn/recast/issues/39\n      \"import {\",\n      \"  type GetLoadContextFunction,\",\n      \"  type createPagesFunctionHandlerParams,\",\n      \"  createPagesFunctionHandler,\",\n      \"  createRequestHandler,\",\n      '} from \"@remix-run/cloudflare-pages\";',\n      \"\", // recast adds a newline here https://github.com/benjamn/recast/issues/39\n      'import { type LinkProps, Form } from \"@remix-run/react\";',\n    ].join(\"\\n\")\n  );\n});","file":"transform-replaceRemixMagicImports-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"useJavascript converts app code from TS to JS","suites":[],"updatePoint":{"line":21,"column":49},"line":21,"code":"it(\"useJavascript converts app code from TS to JS\", async () => {\n  let projectDir = makeApp();\n  await useJavascript.convert(projectDir);\n\n  let config = await readConfig(projectDir);\n\n  // no remix.env.d.ts\n  let remixEnvD = path.join(config.appDirectory, \"remix.env.d.ts\");\n  expect(fs.existsSync(remixEnvD)).toBeFalsy();\n\n  // no TS files within app directory\n  let TSFiles = glob.sync(\"**/*.{d.ts,ts,tsx}\", {\n    cwd: config.appDirectory, // todo: normalize this?\n  });\n  expect(TSFiles).toHaveLength(0);\n\n  // ensure ESM imports in app directory\n  let rootRoute = await fs.readFile(\n    path.join(projectDir, \"app\", \"root.jsx\"),\n    \"utf-8\"\n  );\n  expect(rootRoute).not.toContain('require(\"@remix-run/react\")');\n});","file":"useJavascript-test.ts","skipped":false,"dir":"packages/remix-dev/__tests__"},{"name":"handles requests","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":54,"column":24},"line":54,"code":"    it(\"handles requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/foo/bar\");\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"URL: /foo/bar\");\n      expect(res.headers[\"x-powered-by\"]).toBe(\"Express\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles root // URLs","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":67,"column":28},"line":67,"code":"    it(\"handles root // URLs\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(\"URL: \" + new URL(req.url).pathname);\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"//\");\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"URL: //\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles nested // URLs","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":79,"column":30},"line":79,"code":"    it(\"handles nested // URLs\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(\"URL: \" + new URL(req.url).pathname);\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"//foo//bar\");\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"URL: //foo//bar\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles null body","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":91,"column":25},"line":91,"code":"    it(\"handles null body\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 200 });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.status).toBe(200);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles body as stream","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":103,"column":30},"line":103,"code":"    it(\"handles body as stream\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let stream = Readable.from(\"hello world\");\n        return new NodeResponse(stream, { status: 200 }) as unknown as Response;\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"hello world\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles status codes","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":115,"column":28},"line":115,"code":"    it(\"handles status codes\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 204 });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.status).toBe(204);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"sets headers","suites":["express createRequestHandler","basic requests"],"updatePoint":{"line":126,"column":20},"line":126,"code":"    it(\"sets headers\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let headers = new Headers({ \"X-Time-Of-Year\": \"most wonderful\" });\n        headers.append(\n          \"Set-Cookie\",\n          \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        return new Response(null, { headers });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.headers[\"x-time-of-year\"]).toBe(\"most wonderful\");\n      expect(res.headers[\"set-cookie\"]).toEqual([\n        \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\",\n        \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\",\n        \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\",\n      ]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles empty headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":159,"column":29},"line":159,"code":"    it(\"handles empty headers\", () => {\n      let headers = createRemixHeaders({});\n      expect(headers.raw()).toMatchInlineSnapshot(`Object {}`);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles simple headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":164,"column":30},"line":164,"code":"    it(\"handles simple headers\", () => {\n      let headers = createRemixHeaders({ \"x-foo\": \"bar\" });\n      expect(headers.get(\"x-foo\")).toBe(\"bar\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles multiple headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":169,"column":32},"line":169,"code":"    it(\"handles multiple headers\", () => {\n      let headers = createRemixHeaders({ \"x-foo\": \"bar\", \"x-bar\": \"baz\" });\n      expect(headers.get(\"x-foo\")).toBe(\"bar\");\n      expect(headers.get(\"x-bar\")).toBe(\"baz\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles headers with multiple values","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":175,"column":44},"line":175,"code":"    it(\"handles headers with multiple values\", () => {\n      let headers = createRemixHeaders({\n        \"x-foo\": [\"bar\", \"baz\"],\n        \"x-bar\": \"baz\",\n      });\n      expect(headers.getAll(\"x-foo\")).toEqual([\"bar\", \"baz\"]);\n      expect(headers.get(\"x-bar\")).toBe(\"baz\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"handles multiple set-cookie headers","suites":["express createRemixHeaders","creates fetch headers from express headers"],"updatePoint":{"line":184,"column":43},"line":184,"code":"    it(\"handles multiple set-cookie headers\", () => {\n      let headers = createRemixHeaders({\n        \"set-cookie\": [\n          \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n          \"__other=some_other_value; Path=/; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT; SameSite=Lax\",\n        ],\n      });\n      expect(headers.getAll(\"set-cookie\")).toEqual([\n        \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n        \"__other=some_other_value; Path=/; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT; SameSite=Lax\",\n      ]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"creates a request with the correct headers","suites":["express createRemixRequest"],"updatePoint":{"line":200,"column":48},"line":200,"code":"  it(\"creates a request with the correct headers\", async () => {\n    let expressRequest = createRequest({\n      url: \"/foo/bar\",\n      method: \"GET\",\n      protocol: \"http\",\n      hostname: \"localhost\",\n      headers: {\n        \"Cache-Control\": \"max-age=300, s-maxage=3600\",\n        Host: \"localhost:3000\",\n      },\n    });\n    let expressResponse = createResponse();\n\n    let remixRequest = createRemixRequest(expressRequest, expressResponse);\n\n    expect(remixRequest.method).toBe(\"GET\");\n    expect(remixRequest.headers.get(\"cache-control\")).toBe(\n      \"max-age=300, s-maxage=3600\"\n    );\n    expect(remixRequest.headers.get(\"host\")).toBe(\"localhost:3000\");\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-express/__tests__"},{"name":"should detect binary contentType correctly","suites":["architect isBinaryType"],"updatePoint":{"line":4,"column":48},"line":4,"code":"  it(\"should detect binary contentType correctly\", () => {\n    expect(isBinaryType(undefined)).toBe(false);\n    expect(isBinaryType(null)).toBe(false);\n    expect(isBinaryType(\"text/html; charset=utf-8\")).toBe(false);\n    expect(isBinaryType(\"application/octet-stream\")).toBe(true);\n    expect(isBinaryType(\"application/octet-stream; charset=test\")).toBe(true);\n  });","file":"binaryTypes.test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles requests","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":59,"column":24},"line":59,"code":"    it(\"handles requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000/foo/bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: /foo/bar\");\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles root // requests","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":75,"column":32},"line":75,"code":"    it(\"handles root // requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000//\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: //\");\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles nested // requests","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":91,"column":34},"line":91,"code":"    it(\"handles nested // requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000//foo//bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: //foo//bar\");\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles root // requests (development)","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":107,"column":46},"line":107,"code":"    it(\"handles root // requests (development)\", async () => {\n      let oldEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = \"development\";\n\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ path: \"//\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: //\");\n        });\n\n      process.env.NODE_ENV = oldEnv;\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles nested // requests (development)","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":128,"column":48},"line":128,"code":"    it(\"handles nested // requests (development)\", async () => {\n      let oldEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = \"development\";\n\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ path: \"//foo//bar\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n          expect(res.body).toBe(\"URL: //foo//bar\");\n        });\n\n      process.env.NODE_ENV = oldEnv;\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles null body","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":149,"column":25},"line":149,"code":"    it(\"handles null body\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 200 });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(200);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles status codes","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":164,"column":28},"line":164,"code":"    it(\"handles status codes\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 204 });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000\" }))\n        .expectResolve((res) => {\n          expect(res.statusCode).toBe(204);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"sets headers","suites":["netlify createRequestHandler","basic requests"],"updatePoint":{"line":179,"column":20},"line":179,"code":"    it(\"sets headers\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let headers = new Headers({ \"X-Time-Of-Year\": \"most wonderful\" });\n        headers.append(\n          \"Set-Cookie\",\n          \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n\n        return new Response(null, { headers });\n      });\n\n      // We don't have a real app to test, but it doesn't matter. We won't ever\n      // call through to the real createRequestHandler\n      // @ts-expect-error\n      await lambdaTester(createRequestHandler({ build: undefined }))\n        .event(createMockEvent({ rawUrl: \"http://localhost:3000\" }))\n        .expectResolve((res) => {\n          expect(res.multiValueHeaders[\"x-time-of-year\"]).toEqual([\n            \"most wonderful\",\n          ]);\n          expect(res.multiValueHeaders[\"set-cookie\"]).toEqual([\n            \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\",\n            \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\",\n            \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\",\n          ]);\n        });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles empty headers","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":219,"column":29},"line":219,"code":"    it(\"handles empty headers\", () => {\n      let headers = createRemixHeaders({});\n      expect(headers.raw()).toMatchInlineSnapshot(`Object {}`);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles simple headers","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":224,"column":30},"line":224,"code":"    it(\"handles simple headers\", () => {\n      let headers = createRemixHeaders({ \"x-foo\": [\"bar\"] });\n      expect(headers.get(\"x-foo\")).toBe(\"bar\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles multiple headers","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":229,"column":32},"line":229,"code":"    it(\"handles multiple headers\", () => {\n      let headers = createRemixHeaders({ \"x-foo\": [\"bar\"], \"x-bar\": [\"baz\"] });\n      expect(headers.get(\"x-foo\")).toBe(\"bar\");\n      expect(headers.get(\"x-bar\")).toBe(\"baz\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles headers with multiple values","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":235,"column":44},"line":235,"code":"    it(\"handles headers with multiple values\", () => {\n      let headers = createRemixHeaders({\n        \"x-foo\": [\"bar\", \"baz\"],\n        \"x-bar\": [\"baz\"],\n      });\n      expect(headers.getAll(\"x-foo\")).toEqual([\"bar\", \"baz\"]);\n      expect(headers.get(\"x-bar\")).toBe(\"baz\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles multiple set-cookie headers","suites":["netlify createRemixHeaders","creates fetch headers from netlify headers"],"updatePoint":{"line":244,"column":43},"line":244,"code":"    it(\"handles multiple set-cookie headers\", () => {\n      let headers = createRemixHeaders({\n        \"set-cookie\": [\n          \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n          \"__other=some_other_value; Path=/; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT; SameSite=Lax\",\n        ],\n      });\n      expect(headers.getAll(\"set-cookie\")).toEqual([\n        \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n        \"__other=some_other_value; Path=/; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT; SameSite=Lax\",\n      ]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"creates a request with the correct headers","suites":["netlify createRemixRequest"],"updatePoint":{"line":260,"column":48},"line":260,"code":"  it(\"creates a request with the correct headers\", () => {\n    let remixRequest = createRemixRequest(\n      createMockEvent({ multiValueHeaders: { Cookie: [\"__session=value\"] } })\n    );\n\n    expect(remixRequest.method).toBe(\"GET\");\n    expect(remixRequest.headers.get(\"cookie\")).toBe(\"__session=value\");\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles regular responses","suites":["sendRemixResponse"],"updatePoint":{"line":271,"column":31},"line":271,"code":"  it(\"handles regular responses\", async () => {\n    let response = new NodeResponse(\"anything\");\n    let result = await sendRemixResponse(response);\n    expect(result.body).toBe(\"anything\");\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles resource routes with regular data","suites":["sendRemixResponse"],"updatePoint":{"line":277,"column":47},"line":277,"code":"  it(\"handles resource routes with regular data\", async () => {\n    let json = JSON.stringify({ foo: \"bar\" });\n    let response = new NodeResponse(json, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"content-length\": json.length.toString(),\n      },\n    });\n\n    let result = await sendRemixResponse(response);\n\n    expect(result.body).toMatch(json);\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"handles resource routes with binary data","suites":["sendRemixResponse"],"updatePoint":{"line":291,"column":46},"line":291,"code":"  it(\"handles resource routes with binary data\", async () => {\n    let image = await fsp.readFile(path.join(__dirname, \"554828.jpeg\"));\n\n    let response = new NodeResponse(image, {\n      headers: {\n        \"content-type\": \"image/jpeg\",\n        \"content-length\": image.length.toString(),\n      },\n    });\n\n    let result = await sendRemixResponse(response);\n\n    expect(result.body).toMatch(image.toString(\"base64\"));\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-netlify/__tests__"},{"name":"clones","suites":["Request"],"updatePoint":{"line":72,"column":12},"line":72,"code":"  it(\"clones\", async () => {\n    let encoder = new TextEncoder();\n    let body = new ReadableStream({\n      start(controller) {\n        test.source.forEach((chunk) => {\n          controller.enqueue(encoder.encode(chunk));\n        });\n        controller.close();\n      },\n    });\n\n    let req = new Request(\"http://test.com\", {\n      method: \"post\",\n      body,\n      headers: {\n        \"Content-Type\": \"multipart/form-data; boundary=\" + test.boundary,\n      },\n    });\n\n    let cloned = req.clone();\n    let formData = await req.formData();\n    let clonedFormData = await cloned.formData();\n\n    expect(formData.get(\"file_name_0\")).toBe(\"super alpha file\");\n    expect(clonedFormData.get(\"file_name_0\")).toBe(\"super alpha file\");\n    expect(formData.get(\"file_name_1\")).toBe(\"super beta file\");\n    expect(clonedFormData.get(\"file_name_1\")).toBe(\"super beta file\");\n    let file = formData.get(\"upload_file_0\") as File;\n    expect(file.name).toBe(\"1k_a.dat\");\n    expect(file.size).toBe(1023);\n    file = clonedFormData.get(\"upload_file_0\") as File;\n    expect(file.name).toBe(\"1k_a.dat\");\n    expect(file.size).toBe(1023);\n\n    file = formData.get(\"upload_file_1\") as File;\n    expect(file.name).toBe(\"1k_b.dat\");\n    expect(file.size).toBe(1023);\n    file = clonedFormData.get(\"upload_file_1\") as File;\n    expect(file.name).toBe(\"1k_b.dat\");\n    expect(file.size).toBe(1023);\n\n    expect(cloned instanceof Request).toBeTruthy();\n  });","file":"fetch-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can read file as text","suites":["NodeOnDiskFile"],"updatePoint":{"line":21,"column":27},"line":21,"code":"  it(\"can read file as text\", async () => {\n    expect(await file.text()).toBe(contents);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can get an arrayBuffer","suites":["NodeOnDiskFile"],"updatePoint":{"line":25,"column":28},"line":25,"code":"  it(\"can get an arrayBuffer\", async () => {\n    let buffer = await file.arrayBuffer();\n    expect(buffer.byteLength).toBe(size);\n    expect(buffer).toEqual(Buffer.from(contents));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can use stream","suites":["NodeOnDiskFile"],"updatePoint":{"line":31,"column":20},"line":31,"code":"  it(\"can use stream\", async () => {\n    expect(await readableStreamToString(file.stream() as any)).toBe(contents);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file and change type","suites":["NodeOnDiskFile"],"updatePoint":{"line":35,"column":36},"line":35,"code":"  it(\"can slice file and change type\", async () => {\n    let sliced = await file.slice(1, 5, \"text/rofl\");\n    expect(sliced.type).toBe(\"text/rofl\");\n    expect(await sliced.text()).toBe(contents.slice(1, 5));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file and get text","suites":["NodeOnDiskFile"],"updatePoint":{"line":41,"column":33},"line":41,"code":"  it(\"can slice file and get text\", async () => {\n    let sliced = await file.slice(1, 5);\n    expect(await sliced.text()).toBe(contents.slice(1, 5));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file twice and get text","suites":["NodeOnDiskFile"],"updatePoint":{"line":46,"column":39},"line":46,"code":"  it(\"can slice file twice and get text\", async () => {\n    let sliced = (await file.slice(1, 5)).slice(1, 2);\n    expect(await sliced.text()).toBe(contents.slice(1, 5).slice(1, 2));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can sice file and get an arrayBuffer","suites":["NodeOnDiskFile"],"updatePoint":{"line":51,"column":42},"line":51,"code":"  it(\"can sice file and get an arrayBuffer\", async () => {\n    let sliced = await file.slice(1, 5);\n    let slicedRes = contents.slice(1, 5);\n    let buffer = await sliced.arrayBuffer();\n    expect(buffer.byteLength).toBe(slicedRes.length);\n    expect(buffer).toEqual(Buffer.from(slicedRes));\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file and use stream","suites":["NodeOnDiskFile"],"updatePoint":{"line":59,"column":35},"line":59,"code":"  it(\"can slice file and use stream\", async () => {\n    let sliced = await file.slice(1, 5);\n    let slicedRes = contents.slice(1, 5);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with negative start and no end","suites":["NodeOnDiskFile"],"updatePoint":{"line":66,"column":51},"line":66,"code":"  it(\"can slice file with negative start and no end\", async () => {\n    let sliced = await file.slice(-2);\n    let slicedRes = contents.slice(-2);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with negative start and negative end","suites":["NodeOnDiskFile"],"updatePoint":{"line":73,"column":57},"line":73,"code":"  it(\"can slice file with negative start and negative end\", async () => {\n    let sliced = await file.slice(-3, -1);\n    let slicedRes = contents.slice(-3, -1);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with negative start and negative end twice","suites":["NodeOnDiskFile"],"updatePoint":{"line":80,"column":63},"line":80,"code":"  it(\"can slice file with negative start and negative end twice\", async () => {\n    let sliced = await file.slice(-3, -1).slice(1, -1);\n    let slicedRes = contents.slice(-3, -1).slice(1, -1);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with start and negative end","suites":["NodeOnDiskFile"],"updatePoint":{"line":87,"column":48},"line":87,"code":"  it(\"can slice file with start and negative end\", async () => {\n    let sliced = await file.slice(1, -2);\n    let slicedRes = contents.slice(1, -2);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice file with negaive start and end","suites":["NodeOnDiskFile"],"updatePoint":{"line":94,"column":47},"line":94,"code":"  it(\"can slice file with negaive start and end\", async () => {\n    let sliced = await file.slice(-3, 1);\n    let slicedRes = contents.slice(-3, 1);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"can slice oob","suites":["NodeOnDiskFile"],"updatePoint":{"line":101,"column":19},"line":101,"code":"  it(\"can slice oob\", async () => {\n    let sliced = await file.slice(0, 10000);\n    let slicedRes = contents.slice(0, 10000);\n    expect(sliced.size).toBe(slicedRes.length);\n    expect(await sliced.text()).toBe(slicedRes);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"returns the file path properly","suites":["NodeOnDiskFile"],"updatePoint":{"line":108,"column":36},"line":108,"code":"  it(\"returns the file path properly\", async () => {\n    expect(file.getFilePath()).toEqual(filepath);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"removes the file properly","suites":["NodeOnDiskFile"],"updatePoint":{"line":112,"column":31},"line":112,"code":"  it(\"removes the file properly\", async () => {\n    let newFilePath = `${filepath}-copy`;\n    fs.copyFileSync(filepath, newFilePath);\n\n    let copiedFile = (file = new NodeOnDiskFile(newFilePath, \"text/plain\"));\n    expect(fs.existsSync(copiedFile.getFilePath())).toBe(true);\n    await copiedFile.remove();\n    expect(fs.existsSync(copiedFile.getFilePath())).toBe(false);\n  });","file":"fileUploadHandler-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"persists session data across requests","suites":["File session storage"],"updatePoint":{"line":22,"column":43},"line":22,"code":"  it(\"persists session data across requests\", async () => {\n    let { getSession, commitSession } = createFileSessionStorage({\n      dir,\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n    let setCookie = await commitSession(session);\n    session = await getSession(getCookieFromSetCookie(setCookie));\n\n    expect(session.get(\"user\")).toEqual(\"mjackson\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"returns an empty session for cookies that are not signed properly","suites":["File session storage"],"updatePoint":{"line":35,"column":71},"line":35,"code":"  it(\"returns an empty session for cookies that are not signed properly\", async () => {\n    let { getSession, commitSession } = createFileSessionStorage({\n      dir,\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n\n    expect(session.get(\"user\")).toBe(\"mjackson\");\n\n    let setCookie = await commitSession(session);\n    session = await getSession(\n      // Tamper with the cookie...\n      getCookieFromSetCookie(setCookie).slice(0, -1)\n    );\n\n    expect(session.get(\"user\")).toBeUndefined();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"doesn't destroy the entire session directory when destroying an empty file session","suites":["File session storage"],"updatePoint":{"line":54,"column":88},"line":54,"code":"  it(\"doesn't destroy the entire session directory when destroying an empty file session\", async () => {\n    let { getSession, destroySession } = createFileSessionStorage({\n      dir,\n      cookie: { secrets: [\"secret1\"] },\n    });\n\n    let session = await getSession();\n\n    await expect(destroySession(session)).resolves.not.toThrowError();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"unsigns old session cookies using the old secret and encodes new cookies using the new secret","suites":["File session storage","when a new secret shows up in the rotation"],"updatePoint":{"line":66,"column":101},"line":66,"code":"    it(\"unsigns old session cookies using the old secret and encodes new cookies using the new secret\", async () => {\n      let { getSession, commitSession } = createFileSessionStorage({\n        dir,\n        cookie: { secrets: [\"secret1\"] },\n      });\n      let session = await getSession();\n      session.set(\"user\", \"mjackson\");\n      let setCookie = await commitSession(session);\n      session = await getSession(getCookieFromSetCookie(setCookie));\n\n      expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n      // A new secret enters the rotation...\n      let storage = createFileSessionStorage({\n        dir,\n        cookie: { secrets: [\"secret2\", \"secret1\"] },\n      });\n      getSession = storage.getSession;\n      commitSession = storage.commitSession;\n\n      // Old cookies should still work with the old secret.\n      session = await getSession(getCookieFromSetCookie(setCookie));\n      expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n      // New cookies should be signed using the new secret.\n      let setCookie2 = await commitSession(session);\n      expect(setCookie2).not.toEqual(setCookie);\n    });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-node/__tests__"},{"name":"returns `true` for Cookie objects","suites":["isCookie"],"updatePoint":{"line":23,"column":39},"line":23,"code":"  it(\"returns `true` for Cookie objects\", () => {\n    expect(isCookie(createCookie(\"my-cookie\"))).toBe(true);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns `false` for non-Cookie objects","suites":["isCookie"],"updatePoint":{"line":27,"column":44},"line":27,"code":"  it(\"returns `false` for non-Cookie objects\", () => {\n    expect(isCookie({})).toBe(false);\n    expect(isCookie([])).toBe(false);\n    expect(isCookie(\"\")).toBe(false);\n    expect(isCookie(true)).toBe(false);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes empty string values","suites":["cookies"],"updatePoint":{"line":36,"column":43},"line":36,"code":"  it(\"parses/serializes empty string values\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n    let setCookie = await cookie.serialize(\"\");\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toMatchInlineSnapshot(`\"\"`);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes unsigned string values","suites":["cookies"],"updatePoint":{"line":44,"column":46},"line":44,"code":"  it(\"parses/serializes unsigned string values\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n    let setCookie = await cookie.serialize(\"hello world\");\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toEqual(\"hello world\");\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes unsigned boolean values","suites":["cookies"],"updatePoint":{"line":52,"column":47},"line":52,"code":"  it(\"parses/serializes unsigned boolean values\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n    let setCookie = await cookie.serialize(true);\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toBe(true);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes signed string values","suites":["cookies"],"updatePoint":{"line":60,"column":44},"line":60,"code":"  it(\"parses/serializes signed string values\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize(\"hello michael\");\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toMatchInlineSnapshot(`\"hello michael\"`);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes string values containing utf8 characters","suites":["cookies"],"updatePoint":{"line":70,"column":64},"line":70,"code":"  it(\"parses/serializes string values containing utf8 characters\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n    let setCookie = await cookie.serialize(\"日本語\");\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toBe(\"日本語\");\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"fails to parses signed string values with invalid signature","suites":["cookies"],"updatePoint":{"line":78,"column":65},"line":78,"code":"  it(\"fails to parses signed string values with invalid signature\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize(\"hello michael\");\n    let cookie2 = createCookie(\"my-cookie\", {\n      secrets: [\"secret2\"],\n    });\n    let value = await cookie2.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toBe(null);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"parses/serializes signed object values","suites":["cookies"],"updatePoint":{"line":91,"column":44},"line":91,"code":"  it(\"parses/serializes signed object values\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize({ hello: \"mjackson\" });\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toMatchInlineSnapshot(`\n      Object {\n        \"hello\": \"mjackson\",\n      }\n    `);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"fails to parse signed object values with invalid signature","suites":["cookies"],"updatePoint":{"line":105,"column":64},"line":105,"code":"  it(\"fails to parse signed object values with invalid signature\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize({ hello: \"mjackson\" });\n    let cookie2 = createCookie(\"my-cookie\", {\n      secrets: [\"secret2\"],\n    });\n    let value = await cookie2.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toBeNull();\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"supports secret rotation","suites":["cookies"],"updatePoint":{"line":118,"column":30},"line":118,"code":"  it(\"supports secret rotation\", async () => {\n    let cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret1\"],\n    });\n    let setCookie = await cookie.serialize({ hello: \"mjackson\" });\n    let value = await cookie.parse(getCookieFromSetCookie(setCookie));\n\n    expect(value).toMatchInlineSnapshot(`\n      Object {\n        \"hello\": \"mjackson\",\n      }\n    `);\n\n    // A new secret enters the rotation...\n    cookie = createCookie(\"my-cookie\", {\n      secrets: [\"secret2\", \"secret1\"],\n    });\n\n    // cookie should still be able to parse old cookies.\n    let oldValue = await cookie.parse(getCookieFromSetCookie(setCookie));\n    expect(oldValue).toMatchObject(value);\n\n    // New Set-Cookie should be different, it uses a differet secret.\n    let setCookie2 = await cookie.serialize(value);\n    expect(setCookie).not.toEqual(setCookie2);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"makes the default secrets to be an empty array","suites":["cookies"],"updatePoint":{"line":145,"column":52},"line":145,"code":"  it(\"makes the default secrets to be an empty array\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n\n    expect(cookie.isSigned).toBe(false);\n\n    let cookie2 = createCookie(\"my-cookie2\", {\n      secrets: undefined,\n    });\n\n    expect(cookie2.isSigned).toBe(false);\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"makes the default path of cookies to be /","suites":["cookies"],"updatePoint":{"line":157,"column":47},"line":157,"code":"  it(\"makes the default path of cookies to be /\", async () => {\n    let cookie = createCookie(\"my-cookie\");\n\n    let setCookie = await cookie.serialize(\"hello world\");\n    expect(setCookie).toContain(\"Path=/\");\n\n    let cookie2 = createCookie(\"my-cookie2\");\n\n    let setCookie2 = await cookie2.serialize(\"hello world\", {\n      path: \"/about\",\n    });\n    expect(setCookie2).toContain(\"Path=/about\");\n  });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"warns against using `expires` when creating the cookie instance","suites":["cookies","warnings when providing options you may not want to"],"updatePoint":{"line":174,"column":71},"line":174,"code":"    it(\"warns against using `expires` when creating the cookie instance\", async () => {\n      createCookie(\"my-cookie\", { expires: new Date(Date.now() + 60_000) });\n      expect(spy.console).toHaveBeenCalledTimes(1);\n      expect(spy.console).toHaveBeenCalledWith(\n        'The \"my-cookie\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use `commitSession(session, { expires })` if using a session storage object, or `cookie.serialize(\"value\", { expires })` if you\\'re using the cookie directly.'\n      );\n    });","file":"cookies-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"removes _data from request.url","suites":["loaders"],"updatePoint":{"line":7,"column":36},"line":7,"code":"  it(\"removes _data from request.url\", async () => {\n    let loader = async ({ request }) => {\n      return new URL(request.url).search;\n    };\n\n    let routeId = \"routes/random\";\n    let build = {\n      routes: {\n        [routeId]: {\n          id: routeId,\n          path: \"/random\",\n          module: {\n            loader,\n          },\n        },\n      },\n      entry: { module: {} },\n      future: {},\n    } as unknown as ServerBuild;\n\n    let handler = createRequestHandler(build);\n\n    let request = new Request(\n      \"http://example.com/random?_data=routes/random&foo=bar\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    let res = await handler(request);\n    expect(await res.json()).toMatchInlineSnapshot(`\"?foo=bar\"`);\n  });","file":"data-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets header for throw responses","suites":["loaders"],"updatePoint":{"line":42,"column":37},"line":42,"code":"  it(\"sets header for throw responses\", async () => {\n    let loader = async ({ request }) => {\n      throw new Response(\"null\", {\n        headers: {\n          \"Content-type\": \"application/json\",\n        },\n      });\n    };\n\n    let routeId = \"routes/random\";\n    let build = {\n      routes: {\n        [routeId]: {\n          id: routeId,\n          path: \"/random\",\n          module: {\n            loader,\n          },\n        },\n      },\n      entry: { module: {} },\n      future: {},\n    } as unknown as ServerBuild;\n\n    let handler = createRequestHandler(build);\n\n    let request = new Request(\n      \"http://example.com/random?_data=routes/random&foo=bar\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    let res = await handler(request);\n    expect(await res.headers.get(\"X-Remix-Catch\")).toBeTruthy();\n  });","file":"data-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"removes index from request.url","suites":["loaders"],"updatePoint":{"line":81,"column":36},"line":81,"code":"  it(\"removes index from request.url\", async () => {\n    let loader = async ({ request }) => {\n      return new URL(request.url).search;\n    };\n\n    let routeId = \"routes/random\";\n    let build = {\n      routes: {\n        [routeId]: {\n          id: routeId,\n          path: \"/random\",\n          module: {\n            loader,\n          },\n        },\n      },\n      entry: { module: {} },\n      future: {},\n    } as unknown as ServerBuild;\n\n    let handler = createRequestHandler(build);\n\n    let request = new Request(\n      \"http://example.com/random?_data=routes/random&index&foo=bar\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    let res = await handler(request);\n    expect(await res.json()).toMatchInlineSnapshot(`\"?foo=bar\"`);\n  });","file":"data-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"removes index from request.url and keeps other values","suites":["loaders"],"updatePoint":{"line":116,"column":59},"line":116,"code":"  it(\"removes index from request.url and keeps other values\", async () => {\n    let loader = async ({ request }) => {\n      return new URL(request.url).search;\n    };\n\n    let routeId = \"routes/random\";\n    let build = {\n      routes: {\n        [routeId]: {\n          id: routeId,\n          path: \"/random\",\n          module: {\n            loader,\n          },\n        },\n      },\n      entry: { module: {} },\n      future: {},\n    } as unknown as ServerBuild;\n\n    let handler = createRequestHandler(build);\n\n    let request = new Request(\n      \"http://example.com/random?_data=routes/random&index&foo=bar&index=test\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    let res = await handler(request);\n    expect(await res.json()).toMatchInlineSnapshot(`\"?foo=bar&index=test\"`);\n  });","file":"data-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"can use a custom upload handler","suites":["parseMultipartFormData"],"updatePoint":{"line":16,"column":37},"line":16,"code":"  it(\"can use a custom upload handler\", async () => {\n    let formData = new NodeFormData();\n    formData.set(\"a\", \"value\");\n    formData.set(\"blob\", new Blob([\"blob\".repeat(1000)]), \"blob.txt\");\n    formData.set(\"file\", new File([\"file\".repeat(1000)], \"file.txt\"));\n\n    let req = new NodeRequest(\"https://test.com\", {\n      method: \"post\",\n      body: formData,\n    });\n\n    let parsedFormData = await parseMultipartFormData(\n      req,\n      async ({ filename, data, contentType }) => {\n        let chunks = [];\n        for await (let chunk of data) {\n          chunks.push(chunk);\n        }\n        if (filename) {\n          return new File(chunks, filename, { type: contentType });\n        }\n\n        return await new Blob(chunks, { type: contentType }).text();\n      }\n    );\n\n    expect(parsedFormData.get(\"a\")).toBe(\"value\");\n    let blob = parsedFormData.get(\"blob\") as Blob;\n    expect(await blob.text()).toBe(\"blob\".repeat(1000));\n    let file = parsedFormData.get(\"file\") as File;\n    expect(file.name).toBe(\"file.txt\");\n    expect(await file.text()).toBe(\"file\".repeat(1000));\n  });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"can return undefined","suites":["parseMultipartFormData"],"updatePoint":{"line":50,"column":26},"line":50,"code":"  it(\"can return undefined\", async () => {\n    let formData = new NodeFormData();\n    formData.set(\"a\", \"value\");\n    formData.set(\"blob\", new Blob([\"blob\".repeat(1000)]), \"blob.txt\");\n    formData.set(\"file\", new File([\"file\".repeat(1000)], \"file.txt\"));\n\n    let req = new NodeRequest(\"https://test.com\", {\n      method: \"post\",\n      body: formData,\n    });\n\n    let parsedFormData = await parseMultipartFormData(\n      req,\n      async () => undefined\n    );\n\n    expect(parsedFormData.get(\"a\")).toBe(null);\n    expect(parsedFormData.get(\"blob\")).toBe(null);\n    expect(parsedFormData.get(\"file\")).toBe(null);\n  });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"can throw errors in upload handlers","suites":["parseMultipartFormData"],"updatePoint":{"line":71,"column":41},"line":71,"code":"  it(\"can throw errors in upload handlers\", async () => {\n    let formData = new NodeFormData();\n    formData.set(\"blob\", new Blob([\"blob\"]), \"blob.txt\");\n\n    let req = new NodeRequest(\"https://test.com\", {\n      method: \"post\",\n      body: formData,\n    });\n\n    let error: Error;\n    try {\n      await parseMultipartFormData(req, async () => {\n        throw new CustomError();\n      });\n      throw new Error(\"should have thrown\");\n    } catch (err) {\n      error = err;\n    }\n    expect(error).toBeInstanceOf(CustomError);\n    expect(error.message).toBe(\"test error\");\n  });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"when controller errors","suites":["parseMultipartFormData","stream should propagate events"],"updatePoint":{"line":94,"column":30},"line":94,"code":"    it(\"when controller errors\", async () => {\n      let formData = new NodeFormData();\n      formData.set(\"a\", \"value\");\n      formData.set(\"blob\", new Blob([\"blob\".repeat(1000)]), \"blob.txt\");\n      formData.set(\"file\", new File([\"file\".repeat(1000)], \"file.txt\"));\n\n      let underlyingRequest = new NodeRequest(\"https://test.com\", {\n        method: \"post\",\n        body: formData,\n      });\n      let underlyingBody = await underlyingRequest.text();\n\n      let encoder = new TextEncoder();\n      let body = new ReadableStream({\n        start(controller) {\n          controller.enqueue(\n            encoder.encode(underlyingBody.slice(0, underlyingBody.length / 2))\n          );\n          controller.error(new CustomError());\n        },\n      });\n\n      let req = new NodeRequest(\"https://test.com\", {\n        method: \"post\",\n        body,\n        headers: underlyingRequest.headers,\n      });\n\n      let error: Error;\n      try {\n        await parseMultipartFormData(req, async () => undefined);\n        throw new Error(\"should have thrown\");\n      } catch (err) {\n        error = err;\n      }\n\n      expect(error).toBeInstanceOf(CustomError);\n      expect(error.message).toBe(\"test error\");\n    });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"when controller is closed","suites":["parseMultipartFormData","stream should propagate events"],"updatePoint":{"line":134,"column":33},"line":134,"code":"    it(\"when controller is closed\", async () => {\n      let formData = new NodeFormData();\n      formData.set(\"a\", \"value\");\n      formData.set(\"blob\", new Blob([\"blob\".repeat(1000)]), \"blob.txt\");\n      formData.set(\"file\", new File([\"file\".repeat(1000)], \"file.txt\"));\n\n      let underlyingRequest = new NodeRequest(\"https://test.com\", {\n        method: \"post\",\n        body: formData,\n      });\n      let underlyingBody = await underlyingRequest.text();\n\n      let encoder = new TextEncoder();\n      let body = new ReadableStream({\n        start(controller) {\n          controller.enqueue(\n            encoder.encode(underlyingBody.slice(0, underlyingBody.length / 2))\n          );\n          controller.close();\n        },\n      });\n\n      let req = new NodeRequest(\"https://test.com\", {\n        method: \"post\",\n        body,\n        headers: underlyingRequest.headers,\n      });\n\n      let error: Error;\n      try {\n        await parseMultipartFormData(req, async () => undefined);\n        throw new Error(\"should have thrown\");\n      } catch (err) {\n        error = err;\n      }\n\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message).toMatch(\"malformed multipart-form data\");\n    });","file":"formData-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"retains request headers when stripping body off for loaders","suites":["createRequestHandler"],"updatePoint":{"line":5,"column":65},"line":5,"code":"  it(\"retains request headers when stripping body off for loaders\", async () => {\n    // @ts-expect-error\n    let handler = createRequestHandler({\n      routes: {\n        root: {\n          id: \"routes/test\",\n          path: \"/test\",\n          module: {\n            loader: ({ request }) => json(request.headers.get(\"X-Foo\")),\n          } as any,\n        },\n      },\n      assets: {} as any,\n      entry: { module: {} as any },\n      future: {\n        v2_errorBoundary: false,\n        v2_meta: false,\n      },\n    });\n\n    let response = await handler(\n      new Request(\"http://.../test\", {\n        headers: {\n          \"X-Foo\": \"bar\",\n        },\n        signal: new AbortController().signal,\n      })\n    );\n\n    expect(await response.json()).toBe(\"bar\");\n  });","file":"handler-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with angle brackets should escape","suites":["escapeHtml"],"updatePoint":{"line":9,"column":41},"line":9,"code":"  test(\"with angle brackets should escape\", () => {\n    let evilObj = { evil: \"<script></script>\" };\n    expect(escapeHtml(JSON.stringify(evilObj))).toBe(\n      '{\"evil\":\"\\\\u003cscript\\\\u003e\\\\u003c/script\\\\u003e\"}'\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with angle brackets should parse back","suites":["escapeHtml"],"updatePoint":{"line":16,"column":45},"line":16,"code":"  test(\"with angle brackets should parse back\", () => {\n    let evilObj = { evil: \"<script></script>\" };\n    expect(JSON.parse(escapeHtml(JSON.stringify(evilObj)))).toMatchObject(\n      evilObj\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with ampersands should escape","suites":["escapeHtml"],"updatePoint":{"line":23,"column":37},"line":23,"code":"  test(\"with ampersands should escape\", () => {\n    let evilObj = { evil: \"&\" };\n    expect(escapeHtml(JSON.stringify(evilObj))).toBe('{\"evil\":\"\\\\u0026\"}');\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with ampersands should parse back","suites":["escapeHtml"],"updatePoint":{"line":28,"column":41},"line":28,"code":"  test(\"with ampersands should parse back\", () => {\n    let evilObj = { evil: \"&\" };\n    expect(JSON.parse(escapeHtml(JSON.stringify(evilObj)))).toMatchObject(\n      evilObj\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with \"LINE SEPARATOR\" and \"PARAGRAPH SEPARATOR\" should escape","suites":["escapeHtml"],"updatePoint":{"line":35,"column":69},"line":35,"code":"  test('with \"LINE SEPARATOR\" and \"PARAGRAPH SEPARATOR\" should escape', () => {\n    let evilObj = { evil: \"\\u2028\\u2029\" };\n    expect(escapeHtml(JSON.stringify(evilObj))).toBe(\n      '{\"evil\":\"\\\\u2028\\\\u2029\"}'\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"with \"LINE SEPARATOR\" and \"PARAGRAPH SEPARATOR\" should parse back","suites":["escapeHtml"],"updatePoint":{"line":42,"column":73},"line":42,"code":"  test('with \"LINE SEPARATOR\" and \"PARAGRAPH SEPARATOR\" should parse back', () => {\n    let evilObj = { evil: \"\\u2028\\u2029\" };\n    expect(JSON.parse(escapeHtml(JSON.stringify(evilObj)))).toMatchObject(\n      evilObj\n    );\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"escaped line terminators should work","suites":["escapeHtml"],"updatePoint":{"line":49,"column":44},"line":49,"code":"  test(\"escaped line terminators should work\", () => {\n    expect(() => {\n      vm.runInNewContext(\n        \"(\" + escapeHtml(JSON.stringify({ evil: \"\\u2028\\u2029\" })) + \")\"\n      );\n    }).not.toThrow();\n  });","file":"markup-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets the Content-Type header","suites":["json"],"updatePoint":{"line":6,"column":34},"line":6,"code":"  it(\"sets the Content-Type header\", () => {\n    let response = json({});\n    expect(response.headers.get(\"Content-Type\")).toEqual(\n      \"application/json; charset=utf-8\"\n    );\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"preserves existing headers, including Content-Type","suites":["json"],"updatePoint":{"line":13,"column":56},"line":13,"code":"  it(\"preserves existing headers, including Content-Type\", () => {\n    let response = json(\n      {},\n      {\n        headers: {\n          \"Content-Type\": \"application/json; charset=iso-8859-1\",\n          \"X-Remix\": \"is awesome\",\n        },\n      }\n    );\n\n    expect(response.headers.get(\"Content-Type\")).toEqual(\n      \"application/json; charset=iso-8859-1\"\n    );\n    expect(response.headers.get(\"X-Remix\")).toEqual(\"is awesome\");\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"encodes the response body","suites":["json"],"updatePoint":{"line":30,"column":31},"line":30,"code":"  it(\"encodes the response body\", async () => {\n    let response = json({ hello: \"remix\" });\n    expect(await response.json()).toEqual({ hello: \"remix\" });\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"accepts status as a second parameter","suites":["json"],"updatePoint":{"line":35,"column":42},"line":35,"code":"  it(\"accepts status as a second parameter\", () => {\n    let response = json({}, 201);\n    expect(response.status).toEqual(201);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"infers input type","suites":["json"],"updatePoint":{"line":40,"column":23},"line":40,"code":"  it(\"infers input type\", async () => {\n    let response = json({ hello: \"remix\" });\n    isEqual<typeof response, TypedResponse<{ hello: string }>>(true);\n    let result = await response.json();\n    expect(result).toMatchObject({ hello: \"remix\" });\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"disallows unmatched typed responses","suites":["json"],"updatePoint":{"line":47,"column":41},"line":47,"code":"  it(\"disallows unmatched typed responses\", async () => {\n    let response = json(\"hello\");\n    isEqual<TypedResponse<number>, typeof response>(false);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"disallows unserializables","suites":["json"],"updatePoint":{"line":52,"column":31},"line":52,"code":"  it(\"disallows unserializables\", () => {\n    // @ts-expect-error\n    expect(() => json(124n)).toThrow();\n    // @ts-expect-error\n    expect(() => json({ field: 124n })).toThrow();\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets the status to 302 by default","suites":["redirect"],"updatePoint":{"line":61,"column":39},"line":61,"code":"  it(\"sets the status to 302 by default\", () => {\n    let response = redirect(\"/login\");\n    expect(response.status).toEqual(302);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets the status to 302 when only headers are given","suites":["redirect"],"updatePoint":{"line":66,"column":56},"line":66,"code":"  it(\"sets the status to 302 when only headers are given\", () => {\n    let response = redirect(\"/login\", {\n      headers: {\n        \"X-Remix\": \"is awesome\",\n      },\n    });\n    expect(response.status).toEqual(302);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets the Location header","suites":["redirect"],"updatePoint":{"line":75,"column":30},"line":75,"code":"  it(\"sets the Location header\", () => {\n    let response = redirect(\"/login\");\n    expect(response.headers.get(\"Location\")).toEqual(\"/login\");\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"preserves existing headers, but not Location","suites":["redirect"],"updatePoint":{"line":80,"column":50},"line":80,"code":"  it(\"preserves existing headers, but not Location\", () => {\n    let response = redirect(\"/login\", {\n      headers: {\n        Location: \"/\",\n        \"X-Remix\": \"is awesome\",\n      },\n    });\n\n    expect(response.headers.get(\"Location\")).toEqual(\"/login\");\n    expect(response.headers.get(\"X-Remix\")).toEqual(\"is awesome\");\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"accepts status as a second parameter","suites":["redirect"],"updatePoint":{"line":92,"column":42},"line":92,"code":"  it(\"accepts status as a second parameter\", () => {\n    let response = redirect(\"/profile\", 301);\n    expect(response.status).toEqual(301);\n  });","file":"responses-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"infers types","suites":["SerializeFrom"],"updatePoint":{"line":7,"column":18},"line":7,"code":"  it(\"infers types\", () => {\n    isEqual<SerializeFrom<string>, string>(true);\n    isEqual<SerializeFrom<number>, number>(true);\n    isEqual<SerializeFrom<boolean>, boolean>(true);\n    isEqual<SerializeFrom<String>, String>(true);\n    isEqual<SerializeFrom<Number>, Number>(true);\n    isEqual<SerializeFrom<Boolean>, Boolean>(true);\n    isEqual<SerializeFrom<null>, null>(true);\n\n    isEqual<IsNever<SerializeFrom<undefined>>, true>(true);\n    isEqual<IsNever<SerializeFrom<Function>>, true>(true);\n    isEqual<IsNever<SerializeFrom<symbol>>, true>(true);\n\n    isEqual<SerializeFrom<[]>, []>(true);\n    isEqual<SerializeFrom<[string, number]>, [string, number]>(true);\n    isEqual<SerializeFrom<[number, number]>, [number, number]>(true);\n\n    isEqual<SerializeFrom<ReadonlyArray<string>>, string[]>(true);\n    isEqual<SerializeFrom<ReadonlyArray<Function>>, null[]>(true);\n\n    isEqual<SerializeFrom<{ hello: \"remix\" }>, { hello: \"remix\" }>(true);\n    isEqual<\n      SerializeFrom<{ data: { hello: \"remix\" } }>,\n      { data: { hello: \"remix\" } }\n    >(true);\n  });","file":"serialize-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"infers type from json responses","suites":["SerializeFrom"],"updatePoint":{"line":34,"column":37},"line":34,"code":"  it(\"infers type from json responses\", () => {\n    let loader = () => json({ hello: \"remix\" });\n    isEqual<SerializeFrom<typeof loader>, { hello: string }>(true);\n\n    let asyncLoader = async () => json({ hello: \"remix\" });\n    isEqual<SerializeFrom<typeof asyncLoader>, { hello: string }>(true);\n  });","file":"serialize-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"infers type from defer responses","suites":["SerializeFrom"],"updatePoint":{"line":42,"column":38},"line":42,"code":"  it(\"infers type from defer responses\", () => {\n    let loader = async () => defer({ data: { hello: \"remix\" } });\n    isEqual<SerializeFrom<typeof loader>, { data: { hello: string } }>(true);\n  });","file":"serialize-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"infers type from json responses containing a data key","suites":["SerializeFrom"],"updatePoint":{"line":48,"column":59},"line":48,"code":"  it(\"infers type from json responses containing a data key\", () => {\n    let loader = async () => json({ data: { hello: \"remix\" } });\n    isEqual<SerializeFrom<typeof loader>, { data: { hello: string } }>(true);\n  });","file":"serialize-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"allows through %s request to %s","suites":["server","createRequestHandler"],"line":80,"code":"    it.each(allowThrough)(\n      `allows through %s request to %s`,\n      async (method, to) => {\n        let handler = createRequestHandler(build);\n        let response = await handler(\n          new Request(`http://localhost:3000${to}`, {\n            method,\n          })\n        );\n\n        expect(response.status).toBe(200);\n        let text = await response.text();\n        expect(text).toContain(method);\n        let expected = !to.includes(\"?_data=root\")\n          ? \"COMPONENT\"\n          : method === \"GET\"\n          ? \"LOADER\"\n          : \"ACTION\";\n        expect(text).toContain(expected);\n        expect(spy.console).not.toHaveBeenCalled();\n      }\n    );","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"strips body for HEAD requests","suites":["server","createRequestHandler"],"updatePoint":{"line":103,"column":37},"line":103,"code":"    it(\"strips body for HEAD requests\", async () => {\n      let handler = createRequestHandler(build);\n      let response = await handler(\n        new Request(\"http://localhost:3000/\", {\n          method: \"HEAD\",\n        })\n      );\n\n      expect(await response.text()).toBe(\"\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls resource route loader","suites":["shared server runtime","resource routes"],"updatePoint":{"line":126,"column":37},"line":126,"code":"    test(\"calls resource route loader\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceLoader = jest.fn(() => {\n        return \"resource\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/resource\": {\n          loader: resourceLoader,\n          path: \"resource\",\n        },\n        future: {},\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"resource\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(resourceLoader.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls sub resource route loader","suites":["shared server runtime","resource routes"],"updatePoint":{"line":157,"column":41},"line":157,"code":"    test(\"calls sub resource route loader\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceLoader = jest.fn(() => {\n        return \"resource\";\n      });\n      let subResourceLoader = jest.fn(() => {\n        return \"sub\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/resource\": {\n          loader: resourceLoader,\n          path: \"resource\",\n        },\n        \"routes/resource.sub\": {\n          loader: subResourceLoader,\n          path: \"resource/sub\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource/sub`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"sub\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(resourceLoader.mock.calls.length).toBe(0);\n      expect(subResourceLoader.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route loader allows thrown responses","suites":["shared server runtime","resource routes"],"updatePoint":{"line":195,"column":55},"line":195,"code":"    test(\"resource route loader allows thrown responses\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceLoader = jest.fn(() => {\n        throw new Response(\"resource\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/resource\": {\n          loader: resourceLoader,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.text()).toBe(\"resource\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(resourceLoader.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route loader responds with generic error when thrown","suites":["shared server runtime","resource routes"],"updatePoint":{"line":225,"column":71},"line":225,"code":"    test(\"resource route loader responds with generic error when thrown\", async () => {\n      let error = new Error(\"should be logged when resource loader throws\");\n      let loader = jest.fn(() => {\n        throw error;\n      });\n      let build = mockServerBuild({\n        \"routes/resource\": {\n          loader,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(await result.text()).toBe(\n        \"Unexpected Server Error\\n\\nError: should be logged when resource loader throws\"\n      );\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route loader responds with detailed error when thrown in development","suites":["shared server runtime","resource routes"],"updatePoint":{"line":248,"column":87},"line":248,"code":"    test(\"resource route loader responds with detailed error when thrown in development\", async () => {\n      let error = new Error(\"should be logged when resource loader throws\");\n      let loader = jest.fn(() => {\n        throw error;\n      });\n      let build = mockServerBuild({\n        \"routes/resource\": {\n          loader,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect((await result.text()).includes(error.message)).toBe(true);\n      expect(spy.console.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls resource route action","suites":["shared server runtime","resource routes"],"updatePoint":{"line":270,"column":37},"line":270,"code":"    test(\"calls resource route action\", async () => {\n      let rootAction = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceAction = jest.fn(() => {\n        return \"resource\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          action: rootAction,\n        },\n        \"routes/resource\": {\n          action: resourceAction,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"resource\");\n      expect(rootAction.mock.calls.length).toBe(0);\n      expect(resourceAction.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls sub resource route action","suites":["shared server runtime","resource routes"],"updatePoint":{"line":300,"column":41},"line":300,"code":"    test(\"calls sub resource route action\", async () => {\n      let rootAction = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceAction = jest.fn(() => {\n        return \"resource\";\n      });\n      let subResourceAction = jest.fn(() => {\n        return \"sub\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          action: rootAction,\n        },\n        \"routes/resource\": {\n          action: resourceAction,\n          path: \"resource\",\n        },\n        \"routes/resource.sub\": {\n          action: subResourceAction,\n          path: \"resource/sub\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource/sub`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"sub\");\n      expect(rootAction.mock.calls.length).toBe(0);\n      expect(resourceAction.mock.calls.length).toBe(0);\n      expect(subResourceAction.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route action allows thrown responses","suites":["shared server runtime","resource routes"],"updatePoint":{"line":338,"column":55},"line":338,"code":"    test(\"resource route action allows thrown responses\", async () => {\n      let rootAction = jest.fn(() => {\n        return \"root\";\n      });\n      let resourceAction = jest.fn(() => {\n        throw new Response(\"resource\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          action: rootAction,\n        },\n        \"routes/resource\": {\n          action: resourceAction,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.text()).toBe(\"resource\");\n      expect(rootAction.mock.calls.length).toBe(0);\n      expect(resourceAction.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route action responds with generic error when thrown","suites":["shared server runtime","resource routes"],"updatePoint":{"line":368,"column":71},"line":368,"code":"    test(\"resource route action responds with generic error when thrown\", async () => {\n      let error = new Error(\"should be logged when resource loader throws\");\n      let action = jest.fn(() => {\n        throw error;\n      });\n      let build = mockServerBuild({\n        \"routes/resource\": {\n          action,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(await result.text()).toBe(\n        \"Unexpected Server Error\\n\\nError: should be logged when resource loader throws\"\n      );\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"resource route action responds with detailed error when thrown in development","suites":["shared server runtime","resource routes"],"updatePoint":{"line":391,"column":87},"line":391,"code":"    test(\"resource route action responds with detailed error when thrown in development\", async () => {\n      let message = \"should be logged when resource loader throws\";\n      let action = jest.fn(() => {\n        throw new Error(message);\n      });\n      let build = mockServerBuild({\n        \"routes/resource\": {\n          action,\n          path: \"resource\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/resource`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect((await result.text()).includes(message)).toBe(true);\n      expect(spy.console.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request that does not match loader surfaces error for boundary","suites":["shared server runtime","data requests"],"updatePoint":{"line":415,"column":77},"line":415,"code":"    test(\"data request that does not match loader surfaces error for boundary\", async () => {\n      let build = mockServerBuild({\n        root: {\n          default: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?_data=routes/index`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect((await result.json()).message).toBeTruthy();\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls loader","suites":["shared server runtime","data requests"],"updatePoint":{"line":437,"column":35},"line":437,"code":"    test(\"data request calls loader\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          loader: indexLoader,\n          index: true,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?_data=routes/index`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"index\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls loader and responds with generic message and error header","suites":["shared server runtime","data requests"],"updatePoint":{"line":468,"column":86},"line":468,"code":"    test(\"data request calls loader and responds with generic message and error header\", async () => {\n      let rootLoader = jest.fn(() => {\n        throw new Error(\"test\");\n      });\n      let testAction = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=root`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.json()).message).toBe(\"Unexpected Server Error\");\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(testAction.mock.calls.length).toBe(0);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls loader and responds with detailed info and error header in development mode","suites":["shared server runtime","data requests"],"updatePoint":{"line":500,"column":104},"line":500,"code":"    test(\"data request calls loader and responds with detailed info and error header in development mode\", async () => {\n      let message =\n        \"data request loader error logged to console once in dev mode\";\n      let rootLoader = jest.fn(() => {\n        throw new Error(message);\n      });\n      let testAction = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/test?_data=root`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.json()).message).toBe(message);\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(testAction.mock.calls.length).toBe(0);\n      expect(spy.console.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls loader and responds with catch header","suites":["shared server runtime","data requests"],"updatePoint":{"line":535,"column":66},"line":535,"code":"    test(\"data request calls loader and responds with catch header\", async () => {\n      let rootLoader = jest.fn(() => {\n        throw new Response(\"test\", { status: 400 });\n      });\n      let testAction = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=root`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(await result.text()).toBe(\"test\");\n      expect(result.headers.get(\"X-Remix-Catch\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(testAction.mock.calls.length).toBe(0);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls action","suites":["shared server runtime","data requests"],"updatePoint":{"line":567,"column":35},"line":567,"code":"    test(\"data request calls action\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=routes/test`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"test\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testAction.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls action and responds with generic message and error header","suites":["shared server runtime","data requests"],"updatePoint":{"line":598,"column":86},"line":598,"code":"    test(\"data request calls action and responds with generic message and error header\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(\"test\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=routes/test`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.json()).message).toBe(\"Unexpected Server Error\");\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testAction.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls action and responds with detailed info and error header in development mode","suites":["shared server runtime","data requests"],"updatePoint":{"line":630,"column":104},"line":630,"code":"    test(\"data request calls action and responds with detailed info and error header in development mode\", async () => {\n      let message =\n        \"data request action error logged to console once in dev mode\";\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(message);\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/test?_data=routes/test`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.json()).message).toBe(message);\n      expect(result.headers.get(\"X-Remix-Error\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testAction.mock.calls.length).toBe(1);\n      expect(spy.console.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls action and responds with catch header","suites":["shared server runtime","data requests"],"updatePoint":{"line":665,"column":66},"line":665,"code":"    test(\"data request calls action and responds with catch header\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Response(\"test\", { status: 400 });\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          action: testAction,\n          path: \"test\",\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test?_data=routes/test`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(await result.text()).toBe(\"test\");\n      expect(result.headers.get(\"X-Remix-Catch\")).toBe(\"yes\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testAction.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls layout action","suites":["shared server runtime","data requests"],"updatePoint":{"line":697,"column":42},"line":697,"code":"    test(\"data request calls layout action\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let rootAction = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          action: rootAction,\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?_data=root`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"root\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(rootAction.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"data request calls index action","suites":["shared server runtime","data requests"],"updatePoint":{"line":728,"column":41},"line":728,"code":"    test(\"data request calls index action\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          action: indexAction,\n          index: true,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index&_data=routes/index`, {\n        method: \"post\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(200);\n      expect(await result.json()).toBe(\"index\");\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexAction.mock.calls.length).toBe(1);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"not found document request for no matches and no CatchBoundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":761,"column":72},"line":761,"code":"    test(\"not found document request for no matches and no CatchBoundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, {\n        method: \"get\",\n      });\n\n      let result = await handler(request);\n      expect(result.status).toBe(404);\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors!.root.status).toBe(404);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"sets root as catch boundary for not found document request","suites":["shared server runtime","document requests"],"updatePoint":{"line":789,"column":68},"line":789,"code":"    test(\"sets root as catch boundary for not found document request\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(404);\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors!.root.status).toBe(404);\n      expect(context.loaderData).toEqual({});\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown loader responses bubble up","suites":["shared server runtime","document requests"],"updatePoint":{"line":817,"column":43},"line":817,"code":"    test(\"thrown loader responses bubble up\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(indexLoader.mock.calls.length).toBe(1);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors!.root.status).toBe(400);\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown loader responses catch deep","suites":["shared server runtime","document requests"],"updatePoint":{"line":857,"column":44},"line":857,"code":"    test(\"thrown loader responses catch deep\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          CatchBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(indexLoader.mock.calls.length).toBe(1);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/index\"].status).toBe(400);\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown action responses bubble up","suites":["shared server runtime","document requests"],"updatePoint":{"line":898,"column":43},"line":898,"code":"    test(\"thrown action responses bubble up\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(testAction.mock.calls.length).toBe(1);\n      // Should not call root loader since it is the boundary route\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors!.root.status).toBe(400);\n      expect(context.loaderData).toEqual({\n        root: null,\n        \"routes/test\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown action responses bubble up for index routes","suites":["shared server runtime","document requests"],"updatePoint":{"line":945,"column":60},"line":945,"code":"    test(\"thrown action responses bubble up for index routes\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(indexAction.mock.calls.length).toBe(1);\n      // Should not call root loader since it is the boundary route\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors!.root.status).toBe(400);\n      expect(context.loaderData).toEqual({\n        root: null,\n        \"routes/index\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown action responses catch deep","suites":["shared server runtime","document requests"],"updatePoint":{"line":992,"column":44},"line":992,"code":"    test(\"thrown action responses catch deep\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n          CatchBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(testAction.mock.calls.length).toBe(1);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/test\"].status).toBe(400);\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n        \"routes/test\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown action responses catch deep for index routes","suites":["shared server runtime","document requests"],"updatePoint":{"line":1039,"column":61},"line":1039,"code":"    test(\"thrown action responses catch deep for index routes\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        throw new Response(null, { status: 400 });\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n          CatchBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(indexAction.mock.calls.length).toBe(1);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/index\"].status).toBe(400);\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n        \"routes/index\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown loader response after thrown action response bubble up action throw to deepest loader boundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":1086,"column":111},"line":1086,"code":"    test(\"thrown loader response after thrown action response bubble up action throw to deepest loader boundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let layoutLoader = jest.fn(() => {\n        throw new Response(\"layout\", { status: 401 });\n      });\n      let testAction = jest.fn(() => {\n        throw new Response(\"action\", { status: 400 });\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/__layout\": {\n          parentId: \"root\",\n          default: {},\n          loader: layoutLoader,\n          CatchBoundary: {},\n        },\n        \"routes/__layout/test\": {\n          parentId: \"routes/__layout\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(testAction.mock.calls.length).toBe(1);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/__layout\"].data).toBe(\"action\");\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n        \"routes/__layout\": null,\n        \"routes/__layout/test\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"thrown loader response after thrown index action response bubble up action throw to deepest loader boundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":1142,"column":117},"line":1142,"code":"    test(\"thrown loader response after thrown index action response bubble up action throw to deepest loader boundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let layoutLoader = jest.fn(() => {\n        throw new Response(\"layout\", { status: 401 });\n      });\n      let indexAction = jest.fn(() => {\n        throw new Response(\"action\", { status: 400 });\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          CatchBoundary: {},\n        },\n        \"routes/__layout\": {\n          parentId: \"root\",\n          default: {},\n          loader: layoutLoader,\n          CatchBoundary: {},\n        },\n        \"routes/__layout/index\": {\n          parentId: \"routes/__layout\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(400);\n      expect(indexAction.mock.calls.length).toBe(1);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/__layout\"].data).toBe(\"action\");\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n        \"routes/__layout\": null,\n        \"routes/__layout/index\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"loader errors bubble up","suites":["shared server runtime","document requests"],"updatePoint":{"line":1198,"column":33},"line":1198,"code":"    test(\"loader errors bubble up\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        throw new Error(\"index\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(indexLoader.mock.calls.length).toBe(1);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors!.root).toBeInstanceOf(Error);\n      expect(context.errors!.root.message).toBe(\"Unexpected Server Error\");\n      expect(context.errors!.root.stack).toBeUndefined();\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"loader errors catch deep","suites":["shared server runtime","document requests"],"updatePoint":{"line":1240,"column":34},"line":1240,"code":"    test(\"loader errors catch deep\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        throw new Error(\"index\");\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          ErrorBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(indexLoader.mock.calls.length).toBe(1);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/index\"]).toBeInstanceOf(Error);\n      expect(context.errors![\"routes/index\"].message).toBe(\n        \"Unexpected Server Error\"\n      );\n      expect(context.errors![\"routes/index\"].stack).toBeUndefined();\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"action errors bubble up","suites":["shared server runtime","document requests"],"updatePoint":{"line":1285,"column":33},"line":1285,"code":"    test(\"action errors bubble up\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(\"test\");\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(testAction.mock.calls.length).toBe(1);\n      // Should not call root loader since it is the boundary route\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors!.root).toBeInstanceOf(Error);\n      expect(context.errors!.root.message).toBe(\"Unexpected Server Error\");\n      expect(context.errors!.root.stack).toBeUndefined();\n      expect(context.loaderData).toEqual({\n        root: null,\n        \"routes/test\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"action errors bubble up for index routes","suites":["shared server runtime","document requests"],"updatePoint":{"line":1334,"column":50},"line":1334,"code":"    test(\"action errors bubble up for index routes\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        throw new Error(\"index\");\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(indexAction.mock.calls.length).toBe(1);\n      // Should not call root loader since it is the boundary route\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors!.root).toBeInstanceOf(Error);\n      expect(context.errors!.root.message).toBe(\"Unexpected Server Error\");\n      expect(context.errors!.root.stack).toBeUndefined();\n      expect(context.loaderData).toEqual({\n        root: null,\n        \"routes/index\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"action errors catch deep","suites":["shared server runtime","document requests"],"updatePoint":{"line":1383,"column":34},"line":1383,"code":"    test(\"action errors catch deep\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(\"test\");\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/test\": {\n          parentId: \"root\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n          ErrorBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(testAction.mock.calls.length).toBe(1);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/test\"]).toBeInstanceOf(Error);\n      expect(context.errors![\"routes/test\"].message).toBe(\n        \"Unexpected Server Error\"\n      );\n      expect(context.errors![\"routes/test\"].stack).toBeUndefined();\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n        \"routes/test\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"action errors catch deep for index routes","suites":["shared server runtime","document requests"],"updatePoint":{"line":1434,"column":51},"line":1434,"code":"    test(\"action errors catch deep for index routes\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexAction = jest.fn(() => {\n        throw new Error(\"index\");\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n          ErrorBoundary: {},\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(indexAction.mock.calls.length).toBe(1);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/index\"]).toBeInstanceOf(Error);\n      expect(context.errors![\"routes/index\"].message).toBe(\n        \"Unexpected Server Error\"\n      );\n      expect(context.errors![\"routes/index\"].stack).toBeUndefined();\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n        \"routes/index\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"loader errors after action error bubble up action error to deepest loader boundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":1485,"column":92},"line":1485,"code":"    test(\"loader errors after action error bubble up action error to deepest loader boundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let layoutLoader = jest.fn(() => {\n        throw new Error(\"layout\");\n      });\n      let testAction = jest.fn(() => {\n        throw new Error(\"action\");\n      });\n      let testLoader = jest.fn(() => {\n        return \"test\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/__layout\": {\n          parentId: \"root\",\n          default: {},\n          loader: layoutLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/__layout/test\": {\n          parentId: \"routes/__layout\",\n          path: \"test\",\n          default: {},\n          loader: testLoader,\n          action: testAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/test`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(testAction.mock.calls.length).toBe(1);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(testLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/__layout\"]).toBeInstanceOf(Error);\n      expect(context.errors![\"routes/__layout\"].message).toBe(\n        \"Unexpected Server Error\"\n      );\n      expect(context.errors![\"routes/__layout\"].stack).toBeUndefined();\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n        \"routes/__layout\": null,\n        \"routes/__layout/test\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"loader errors after index action error bubble up action error to deepest loader boundary","suites":["shared server runtime","document requests"],"updatePoint":{"line":1545,"column":98},"line":1545,"code":"    test(\"loader errors after index action error bubble up action error to deepest loader boundary\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let layoutLoader = jest.fn(() => {\n        throw new Error(\"layout\");\n      });\n      let indexAction = jest.fn(() => {\n        throw new Error(\"action\");\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/__layout\": {\n          parentId: \"root\",\n          default: {},\n          loader: layoutLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/__layout/index\": {\n          parentId: \"routes/__layout\",\n          index: true,\n          default: {},\n          loader: indexLoader,\n          action: indexAction,\n        },\n      });\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/?index`, { method: \"post\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(indexAction.mock.calls.length).toBe(1);\n      expect(rootLoader.mock.calls.length).toBe(1);\n      expect(indexLoader.mock.calls.length).toBe(0);\n      expect(build.entry.module.default.mock.calls.length).toBe(1);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(1);\n      let context = calls[0][3].staticHandlerContext as StaticHandlerContext;\n      expect(context.errors).toBeTruthy();\n      expect(context.errors![\"routes/__layout\"]).toBeInstanceOf(Error);\n      expect(context.errors![\"routes/__layout\"].message).toBe(\n        \"Unexpected Server Error\"\n      );\n      expect(context.errors![\"routes/__layout\"].stack).toBeUndefined();\n      expect(context.loaderData).toEqual({\n        root: \"root\",\n        \"routes/__layout\": null,\n        \"routes/__layout/index\": null,\n      });\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"calls handleDocumentRequest again with new error when handleDocumentRequest throws","suites":["shared server runtime","document requests"],"updatePoint":{"line":1605,"column":92},"line":1605,"code":"    test(\"calls handleDocumentRequest again with new error when handleDocumentRequest throws\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let calledBefore = false;\n      let ogHandleDocumentRequest = build.entry.module.default;\n      build.entry.module.default = jest.fn(function () {\n        if (!calledBefore) {\n          throw new Error(\"thrown\");\n        }\n        calledBefore = true;\n        return ogHandleDocumentRequest.call(null, arguments);\n      }) as any;\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(2);\n      let context = calls[1][3].staticHandlerContext;\n      expect(context.errors.root).toBeTruthy();\n      expect(context.errors!.root.message).toBe(\"thrown\");\n      expect(context.loaderData).toEqual({});\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns generic message if handleDocumentRequest throws a second time","suites":["shared server runtime","document requests"],"updatePoint":{"line":1650,"column":79},"line":1650,"code":"    test(\"returns generic message if handleDocumentRequest throws a second time\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let lastThrownError;\n      build.entry.module.default = jest.fn(function () {\n        lastThrownError = new Error(\"rofl\");\n        throw lastThrownError;\n      }) as any;\n      let handler = createRequestHandler(build, ServerMode.Test);\n\n      let request = new Request(`${baseUrl}/`, { method: \"get\" });\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect(await result.text()).toBe(\n        \"Unexpected Server Error\\n\\nError: rofl\"\n      );\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(2);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns more detailed message if handleDocumentRequest throws a second time in development mode","suites":["shared server runtime","document requests"],"updatePoint":{"line":1690,"column":105},"line":1690,"code":"    test(\"returns more detailed message if handleDocumentRequest throws a second time in development mode\", async () => {\n      let rootLoader = jest.fn(() => {\n        return \"root\";\n      });\n      let indexLoader = jest.fn(() => {\n        return \"index\";\n      });\n      let build = mockServerBuild({\n        root: {\n          default: {},\n          loader: rootLoader,\n          ErrorBoundary: {},\n        },\n        \"routes/index\": {\n          parentId: \"root\",\n          default: {},\n          loader: indexLoader,\n        },\n      });\n      let errorMessage =\n        \"thrown from handleDocumentRequest and expected to be logged in console only once\";\n      let lastThrownError;\n      build.entry.module.default = jest.fn(function () {\n        lastThrownError = new Error(errorMessage);\n        errorMessage = \"second error thrown from handleDocumentRequest\";\n        throw lastThrownError;\n      }) as any;\n      let handler = createRequestHandler(build, ServerMode.Development);\n\n      let request = new Request(`${baseUrl}/`);\n\n      let result = await handler(request);\n      expect(result.status).toBe(500);\n      expect((await result.text()).includes(errorMessage)).toBe(true);\n      expect(rootLoader.mock.calls.length).toBe(0);\n      expect(indexLoader.mock.calls.length).toBe(0);\n\n      let calls = build.entry.module.default.mock.calls;\n      expect(calls.length).toBe(2);\n      expect(spy.console.mock.calls[0][0].data).toEqual(\n        'Error: No route matches URL \"/\"'\n      );\n      expect(spy.console.mock.calls[1][0].message).toEqual(\n        \"thrown from handleDocumentRequest and expected to be logged in console only once\"\n      );\n      expect(spy.console.mock.calls[2][0].message).toEqual(\n        \"second error thrown from handleDocumentRequest\"\n      );\n      expect(spy.console.mock.calls.length).toBe(3);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"provides load context to server entrypoint","suites":["shared server runtime","document requests"],"updatePoint":{"line":1742,"column":50},"line":1742,"code":"  test(\"provides load context to server entrypoint\", async () => {\n    let rootLoader = jest.fn(() => {\n      return \"root\";\n    });\n    let indexLoader = jest.fn(() => {\n      return \"index\";\n    });\n    let build = mockServerBuild({\n      root: {\n        default: {},\n        loader: rootLoader,\n        ErrorBoundary: {},\n      },\n      \"routes/index\": {\n        parentId: \"root\",\n        default: {},\n        loader: indexLoader,\n      },\n    });\n\n    build.entry.module.default = jest.fn(\n      async (\n        request,\n        responseStatusCode,\n        responseHeaders,\n        entryContext,\n        loadContext\n      ) =>\n        new Response(JSON.stringify(loadContext), {\n          status: responseStatusCode,\n          headers: responseHeaders,\n        })\n    );\n\n    let handler = createRequestHandler(build, ServerMode.Development);\n    let request = new Request(`${baseUrl}/`, { method: \"get\" });\n    let loadContext = { \"load-context\": \"load-value\" };\n\n    let result = await handler(request, loadContext);\n    expect(await result.text()).toBe(JSON.stringify(loadContext));\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"has an empty id by default","suites":["Session"],"updatePoint":{"line":35,"column":32},"line":35,"code":"  it(\"has an empty id by default\", () => {\n    expect(createSession().id).toEqual(\"\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"correctly stores and retrieves values","suites":["Session"],"updatePoint":{"line":39,"column":43},"line":39,"code":"  it(\"correctly stores and retrieves values\", () => {\n    let session = createSession();\n\n    session.set(\"user\", \"mjackson\");\n    session.flash(\"error\", \"boom\");\n\n    expect(session.has(\"user\")).toBe(true);\n    expect(session.get(\"user\")).toBe(\"mjackson\");\n    // Normal values should remain in the session after get()\n    expect(session.has(\"user\")).toBe(true);\n    expect(session.get(\"user\")).toBe(\"mjackson\");\n\n    expect(session.has(\"error\")).toBe(true);\n    expect(session.get(\"error\")).toBe(\"boom\");\n    // Flash values disappear after the first get()\n    expect(session.has(\"error\")).toBe(false);\n    expect(session.get(\"error\")).toBeUndefined();\n\n    session.unset(\"user\");\n\n    expect(session.has(\"user\")).toBe(false);\n    expect(session.get(\"user\")).toBeUndefined();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns `true` for Session objects","suites":["isSession"],"updatePoint":{"line":65,"column":40},"line":65,"code":"  it(\"returns `true` for Session objects\", () => {\n    expect(isSession(createSession())).toBe(true);\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns `false` for non-Session objects","suites":["isSession"],"updatePoint":{"line":69,"column":45},"line":69,"code":"  it(\"returns `false` for non-Session objects\", () => {\n    expect(isSession({})).toBe(false);\n    expect(isSession([])).toBe(false);\n    expect(isSession(\"\")).toBe(false);\n    expect(isSession(true)).toBe(false);\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"persists session data across requests","suites":["In-memory session storage"],"updatePoint":{"line":78,"column":43},"line":78,"code":"  it(\"persists session data across requests\", async () => {\n    let { getSession, commitSession } = createMemorySessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n    let setCookie = await commitSession(session);\n    session = await getSession(getCookieFromSetCookie(setCookie));\n\n    expect(session.get(\"user\")).toEqual(\"mjackson\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"persists session data across requests","suites":["Cookie session storage"],"updatePoint":{"line":92,"column":43},"line":92,"code":"  it(\"persists session data across requests\", async () => {\n    let { getSession, commitSession } = createCookieSessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n    let setCookie = await commitSession(session);\n    session = await getSession(getCookieFromSetCookie(setCookie));\n\n    expect(session.get(\"user\")).toEqual(\"mjackson\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"returns an empty session for cookies that are not signed properly","suites":["Cookie session storage"],"updatePoint":{"line":104,"column":71},"line":104,"code":"  it(\"returns an empty session for cookies that are not signed properly\", async () => {\n    let { getSession, commitSession } = createCookieSessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n\n    expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n    let setCookie = await commitSession(session);\n    session = await getSession(\n      // Tamper with the session cookie...\n      getCookieFromSetCookie(setCookie).slice(0, -1)\n    );\n\n    expect(session.get(\"user\")).toBeUndefined();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"\"makes the default path of cookies to be /","suites":["Cookie session storage"],"updatePoint":{"line":122,"column":48},"line":122,"code":"  it('\"makes the default path of cookies to be /', async () => {\n    let { getSession, commitSession } = createCookieSessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    session.set(\"user\", \"mjackson\");\n    let setCookie = await commitSession(session);\n    expect(setCookie).toContain(\"Path=/\");\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"throws an error when the cookie size exceeds 4096 bytes","suites":["Cookie session storage"],"updatePoint":{"line":132,"column":61},"line":132,"code":"  it(\"throws an error when the cookie size exceeds 4096 bytes\", async () => {\n    let { getSession, commitSession } = createCookieSessionStorage({\n      cookie: { secrets: [\"secret1\"] },\n    });\n    let session = await getSession();\n    let longString = new Array(4097).fill(\"a\").join(\"\");\n    session.set(\"over4096bytes\", longString);\n    await expect(() => commitSession(session)).rejects.toThrow();\n  });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"warns against using `expires` when creating the session","suites":["Cookie session storage","warnings when providing options you may not want to"],"updatePoint":{"line":145,"column":63},"line":145,"code":"    it(\"warns against using `expires` when creating the session\", async () => {\n      createCookieSessionStorage({\n        cookie: {\n          secrets: [\"secret1\"],\n          expires: new Date(Date.now() + 60_000),\n        },\n      });\n\n      expect(spy.console).toHaveBeenCalledTimes(1);\n      expect(spy.console).toHaveBeenCalledWith(\n        'The \"__session\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use `commitSession(session, { expires })` if using a session storage object, or `cookie.serialize(\"value\", { expires })` if you\\'re using the cookie directly.'\n      );\n    });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"warns when not passing secrets when creating the session","suites":["Cookie session storage","warnings when providing options you may not want to"],"updatePoint":{"line":159,"column":64},"line":159,"code":"    it(\"warns when not passing secrets when creating the session\", async () => {\n      createCookieSessionStorage({ cookie: {} });\n\n      expect(spy.console).toHaveBeenCalledTimes(1);\n      expect(spy.console).toHaveBeenCalledWith(\n        'The \"__session\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.'\n      );\n    });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"unsigns old session cookies using the old secret and encodes new cookies using the new secret","suites":["Cookie session storage","when a new secret shows up in the rotation"],"updatePoint":{"line":170,"column":101},"line":170,"code":"    it(\"unsigns old session cookies using the old secret and encodes new cookies using the new secret\", async () => {\n      let { getSession, commitSession } = createCookieSessionStorage({\n        cookie: { secrets: [\"secret1\"] },\n      });\n      let session = await getSession();\n      session.set(\"user\", \"mjackson\");\n      let setCookie = await commitSession(session);\n      session = await getSession(getCookieFromSetCookie(setCookie));\n\n      expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n      // A new secret enters the rotation...\n      let storage = createCookieSessionStorage({\n        cookie: { secrets: [\"secret2\", \"secret1\"] },\n      });\n      getSession = storage.getSession;\n      commitSession = storage.commitSession;\n\n      // Old cookies should still work with the old secret.\n      session = await storage.getSession(getCookieFromSetCookie(setCookie));\n      expect(session.get(\"user\")).toEqual(\"mjackson\");\n\n      // New cookies should be signed using the new secret.\n      let setCookie2 = await storage.commitSession(session);\n      expect(setCookie2).not.toEqual(setCookie);\n    });","file":"sessions-test.ts","skipped":false,"dir":"packages/remix-server-runtime/__tests__"},{"name":"handles requests","suites":["Vercel createRequestHandler","basic requests"],"updatePoint":{"line":45,"column":24},"line":45,"code":"    it(\"handles requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/foo/bar\");\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"URL: /foo/bar\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles root // requests","suites":["Vercel createRequestHandler","basic requests"],"updatePoint":{"line":57,"column":32},"line":57,"code":"    it(\"handles root // requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"//\");\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"URL: //\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles nested // requests","suites":["Vercel createRequestHandler","basic requests"],"updatePoint":{"line":69,"column":34},"line":69,"code":"    it(\"handles nested // requests\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async (req) => {\n        return new Response(`URL: ${new URL(req.url).pathname}`);\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"//foo//bar\");\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"URL: //foo//bar\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles null body","suites":["Vercel createRequestHandler","basic requests"],"updatePoint":{"line":81,"column":25},"line":81,"code":"    it(\"handles null body\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 200 });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.status).toBe(200);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles body as stream","suites":["Vercel createRequestHandler","basic requests"],"updatePoint":{"line":93,"column":30},"line":93,"code":"    it(\"handles body as stream\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let stream = Readable.from(\"hello world\");\n        return new NodeResponse(stream, { status: 200 }) as unknown as Response;\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.status).toBe(200);\n      expect(res.text).toBe(\"hello world\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles status codes","suites":["Vercel createRequestHandler","basic requests"],"updatePoint":{"line":106,"column":28},"line":106,"code":"    it(\"handles status codes\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        return new Response(null, { status: 204 });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.status).toBe(204);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"sets headers","suites":["Vercel createRequestHandler","basic requests"],"updatePoint":{"line":117,"column":20},"line":117,"code":"    it(\"sets headers\", async () => {\n      mockedCreateRequestHandler.mockImplementation(() => async () => {\n        let headers = new Headers({ \"X-Time-Of-Year\": \"most wonderful\" });\n        headers.append(\n          \"Set-Cookie\",\n          \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        headers.append(\n          \"Set-Cookie\",\n          \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\"\n        );\n        return new Response(null, { headers });\n      });\n\n      let request = supertest(createApp());\n      let res = await request.get(\"/\");\n\n      expect(res.headers[\"x-time-of-year\"]).toBe(\"most wonderful\");\n      expect(res.headers[\"set-cookie\"]).toEqual([\n        \"first=one; Expires=0; Path=/; HttpOnly; Secure; SameSite=Lax\",\n        \"second=two; MaxAge=1209600; Path=/; HttpOnly; Secure; SameSite=Lax\",\n        \"third=three; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Path=/; HttpOnly; Secure; SameSite=Lax\",\n      ]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles empty headers","suites":["Vercel createRemixHeaders","creates fetch headers from Vercel headers"],"updatePoint":{"line":150,"column":29},"line":150,"code":"    it(\"handles empty headers\", () => {\n      let headers = createRemixHeaders({});\n      expect(headers.raw()).toMatchInlineSnapshot(`Object {}`);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles simple headers","suites":["Vercel createRemixHeaders","creates fetch headers from Vercel headers"],"updatePoint":{"line":155,"column":30},"line":155,"code":"    it(\"handles simple headers\", () => {\n      let headers = createRemixHeaders({ \"x-foo\": \"bar\" });\n      expect(headers.get(\"x-foo\")).toBe(\"bar\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles multiple headers","suites":["Vercel createRemixHeaders","creates fetch headers from Vercel headers"],"updatePoint":{"line":160,"column":32},"line":160,"code":"    it(\"handles multiple headers\", () => {\n      let headers = createRemixHeaders({ \"x-foo\": \"bar\", \"x-bar\": \"baz\" });\n      expect(headers.get(\"x-foo\")).toBe(\"bar\");\n      expect(headers.get(\"x-bar\")).toBe(\"baz\");\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles headers with multiple values","suites":["Vercel createRemixHeaders","creates fetch headers from Vercel headers"],"updatePoint":{"line":166,"column":44},"line":166,"code":"    it(\"handles headers with multiple values\", () => {\n      let headers = createRemixHeaders({\n        \"x-foo\": [\"bar\", \"baz\"],\n        \"x-bar\": \"baz\",\n      });\n      expect(headers.getAll(\"x-foo\")).toEqual([\"bar\", \"baz\"]);\n      expect(headers.getAll(\"x-bar\")).toEqual([\"baz\"]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"handles multiple set-cookie headers","suites":["Vercel createRemixHeaders","creates fetch headers from Vercel headers"],"updatePoint":{"line":175,"column":43},"line":175,"code":"    it(\"handles multiple set-cookie headers\", () => {\n      let headers = createRemixHeaders({\n        \"set-cookie\": [\n          \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n          \"__other=some_other_value; Path=/; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT; SameSite=Lax\",\n        ],\n      });\n      expect(headers.getAll(\"set-cookie\")).toEqual([\n        \"__session=some_value; Path=/; Secure; HttpOnly; MaxAge=7200; SameSite=Lax\",\n        \"__other=some_other_value; Path=/; Secure; HttpOnly; Expires=Wed, 21 Oct 2015 07:28:00 GMT; SameSite=Lax\",\n      ]);\n    });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"},{"name":"creates a request with the correct headers","suites":["Vercel createRemixRequest"],"updatePoint":{"line":191,"column":48},"line":191,"code":"  it(\"creates a request with the correct headers\", async () => {\n    let request = createRequest({\n      method: \"GET\",\n      url: \"/foo/bar\",\n      headers: {\n        \"x-forwarded-host\": \"localhost:3000\",\n        \"x-forwarded-proto\": \"http\",\n        \"Cache-Control\": \"max-age=300, s-maxage=3600\",\n      },\n    }) as VercelRequest;\n    let response = createResponse() as unknown as VercelResponse;\n\n    let remixRequest = createRemixRequest(request, response);\n\n    expect(remixRequest.method).toBe(\"GET\");\n    expect(remixRequest.headers.get(\"cache-control\")).toBe(\n      \"max-age=300, s-maxage=3600\"\n    );\n    expect(remixRequest.headers.get(\"x-forwarded-host\")).toBe(\"localhost:3000\");\n    expect(remixRequest.headers.get(\"x-forwarded-proto\")).toBe(\"http\");\n  });","file":"server-test.ts","skipped":false,"dir":"packages/remix-vercel/__tests__"}]}