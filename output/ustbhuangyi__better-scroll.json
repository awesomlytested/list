{
    "repo": "ustbhuangyi/better-scroll",
    "url": "https://github.com/ustbhuangyi/better-scroll",
    "branch": "dev",
    "configs": [
        {
            "package": "better-scroll",
            "lang": "js",
            "dir": "tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@better-scroll/core",
            "lang": "ts",
            "dir": "packages/core/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/indicators",
            "lang": "ts",
            "dir": "packages/indicators/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/infinity",
            "lang": "ts",
            "dir": "packages/infinity/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/mouse-wheel",
            "lang": "ts",
            "dir": "packages/mouse-wheel/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/movable",
            "lang": "ts",
            "dir": "packages/movable/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/nested-scroll",
            "lang": "ts",
            "dir": "packages/nested-scroll/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/observe-dom",
            "lang": "ts",
            "dir": "packages/observe-dom/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/observe-image",
            "lang": "ts",
            "dir": "packages/observe-image/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/pull-down",
            "lang": "ts",
            "dir": "packages/pull-down/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/pull-up",
            "lang": "ts",
            "dir": "packages/pull-up/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/scroll-bar",
            "lang": "ts",
            "dir": "packages/scroll-bar/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/shared-utils",
            "lang": "ts",
            "dir": "packages/shared-utils/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/slide",
            "lang": "ts",
            "dir": "packages/slide/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/wheel",
            "lang": "ts",
            "dir": "packages/wheel/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@better-scroll/zoom",
            "lang": "ts",
            "dir": "packages/zoom/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "use()",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 16,
                "column": 11
            },
            "line": 16,
            "code": "  it('use()', () => {\n    const plugin = class MyPlugin {\n      static pluginName = 'myPlugin'\n    }\n    BScroll.use(plugin)\n    // has installed\n    BScroll.use(plugin)\n\n    expect(BScroll.plugins.length).toBe(1)\n\n    // Plugin should specify pluginName\n    const spyFn = jest.spyOn(console, 'error')\n    const unnamedPlugin = class UnnamedPlugin {}\n    BScroll.use(unnamedPlugin as any)\n    expect(spyFn).toBeCalled()\n    spyFn.mockRestore()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "should init plugins when set top-level of BScroll options",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 34,
                "column": 63
            },
            "line": 34,
            "code": "  it('should init plugins when set top-level of BScroll options', () => {\n    let mockFn = jest.fn()\n    const plugin = class MyPlugin {\n      static pluginName = 'myPlugin2'\n      constructor(bscroll: BScroll) {\n        mockFn(bscroll)\n      }\n    }\n    BScroll.use(plugin)\n    let wrapper = document.createElement('div')\n    wrapper.appendChild(document.createElement('p'))\n\n    let bs = new BScroll(wrapper, {\n      myPlugin2: true\n    })\n    expect(mockFn).toBeCalledWith(bs)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "should throw error when wrapper is not a ElementNode or wrapper has no children ",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 52,
                "column": 86
            },
            "line": 52,
            "code": "  it('should throw error when wrapper is not a ElementNode or wrapper has no children ', () => {\n    let spy = jest.spyOn(console, 'error')\n    let bs = new BScroll('.div', {})\n    let bs2 = new BScroll(document.createElement('div'), {})\n\n    expect(spy).toHaveBeenCalled()\n    expect(spy).toBeCalledTimes(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "disable()",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 61,
                "column": 15
            },
            "line": 61,
            "code": "  it('disable()', () => {\n    const mockFn = jest.fn()\n    bscroll.on(bscroll.eventTypes.disable, mockFn)\n    bscroll.hooks.on(bscroll.hooks.eventTypes.disable, mockFn)\n    bscroll.disable()\n\n    expect(mockFn).toBeCalledTimes(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "destroy()",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 70,
                "column": 15
            },
            "line": 70,
            "code": "  it('destroy()', () => {\n    const mockFn = jest.fn()\n    bscroll.on(bscroll.eventTypes.destroy, mockFn)\n    bscroll.hooks.on(bscroll.hooks.eventTypes.destroy, mockFn)\n    bscroll.destroy()\n\n    expect(mockFn).toBeCalledTimes(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "eventRegister()",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 79,
                "column": 21
            },
            "line": 79,
            "code": "  it('eventRegister()', () => {\n    bscroll.eventRegister(['dummy'])\n    expect(bscroll.eventTypes.dummy).toBeTruthy()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "should refresh when window resized",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 84,
                "column": 40
            },
            "line": 84,
            "code": "  it('should refresh when window resized', () => {\n    const mockFn = jest.fn()\n    bscroll.on(bscroll.eventTypes.refresh, mockFn)\n    bscroll.scroller.hooks.trigger(bscroll.scroller.hooks.eventTypes.resize)\n    expect(mockFn).toBeCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "plugin wanna control scroll position ",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 91,
                "column": 43
            },
            "line": 91,
            "code": "  it('plugin wanna control scroll position ', () => {\n    const mockFn = jest.fn().mockImplementation(() => true)\n    class DummyPlugin {\n      static pluginName = 'dummy'\n      constructor(scroll: BScroll) {\n        scroll.hooks.on(scroll.hooks.eventTypes.beforeInitialScrollTo, mockFn)\n      }\n    }\n    BScroll.use(DummyPlugin)\n    bscroll = new BScroll(wrapper, { dummy: true })\n    expect(mockFn).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "should trigger contentChanged hook when content DOM has changed",
            "suites": [
                "BetterScroll Core"
            ],
            "updatePoint": {
                "line": 104,
                "column": 69
            },
            "line": 104,
            "code": "  it('should trigger contentChanged hook when content DOM has changed', () => {\n    const mockFn = jest.fn()\n    bscroll.on(bscroll.eventTypes.contentChanged, mockFn)\n\n    // content DOM has\n    wrapper.removeChild(content)\n    wrapper.appendChild(document.createElement('div'))\n    bscroll.refresh()\n    expect(mockFn).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "should have default value",
            "suites": [
                "BetterScroll Options"
            ],
            "updatePoint": {
                "line": 13,
                "column": 31
            },
            "line": 13,
            "code": "  it('should have default value', () => {\n    expect(options).toEqual({\n      HWCompositing: true,\n      autoBlur: true,\n      bindToWrapper: false,\n      bounce: {\n        bottom: true,\n        left: true,\n        right: true,\n        top: true,\n      },\n      bounceTime: 800,\n      click: false,\n      dblclick: false,\n      deceleration: 0.0015,\n      directionLockThreshold: 0,\n      disableMouse: false,\n      disableTouch: true,\n      eventPassthrough: '',\n      flickLimitDistance: 100,\n      flickLimitTime: 200,\n      freeScroll: false,\n      momentum: true,\n      momentumLimitDistance: 15,\n      momentumLimitTime: 300,\n      preventDefault: true,\n      preventDefaultException: {\n        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|AUDIO)$/,\n      },\n      tagException: {\n        tagName: /^TEXTAREA$/,\n      },\n      probeType: 0,\n      resizePolling: 60,\n      scrollX: false,\n      scrollY: true,\n      startX: 0,\n      startY: 0,\n      stopPropagation: false,\n      swipeBounceTime: 500,\n      swipeTime: 2500,\n      tap: '',\n      useTransition: true,\n      autoEndDistance: 5,\n      bindToTarget: false,\n      outOfBoundaryDampingFactor: 1 / 3,\n      specifiedIndexAsContent: 0,\n      quadrant: 1,\n    })\n  })",
            "file": "Options.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "should shallow copy options when call merge(options)",
            "suites": [
                "BetterScroll Options"
            ],
            "updatePoint": {
                "line": 64,
                "column": 58
            },
            "line": 64,
            "code": "  it('should shallow copy options when call merge(options)', () => {\n    options.merge({\n      scrollY: false,\n      scrollX: true,\n      bounce: false,\n    })\n\n    expect(options).toEqual({\n      HWCompositing: true,\n      autoBlur: true,\n      bindToWrapper: false,\n      bounce: {\n        top: false,\n        right: false,\n        bottom: false,\n        left: false,\n      },\n      bounceTime: 800,\n      click: false,\n      dblclick: false,\n      deceleration: 0.0015,\n      directionLockThreshold: 0,\n      disableMouse: false,\n      disableTouch: true,\n      eventPassthrough: '',\n      flickLimitDistance: 100,\n      flickLimitTime: 200,\n      freeScroll: false,\n      momentum: true,\n      momentumLimitDistance: 15,\n      momentumLimitTime: 300,\n      preventDefault: true,\n      preventDefaultException: {\n        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|AUDIO)$/,\n      },\n      tagException: {\n        tagName: /^TEXTAREA$/,\n      },\n      probeType: 0,\n      resizePolling: 60,\n      scrollX: true,\n      scrollY: false,\n      startX: 0,\n      startY: 0,\n      stopPropagation: false,\n      swipeBounceTime: 500,\n      swipeTime: 2500,\n      tap: '',\n      useTransition: true,\n      autoEndDistance: 5,\n      bindToTarget: false,\n      outOfBoundaryDampingFactor: 1 / 3,\n      specifiedIndexAsContent: 0,\n      quadrant: 1,\n    })\n    // an invalid parameter\n    const ret = options.merge()\n    expect(ret).toBe(options)\n  })",
            "file": "Options.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "should generate some extra properties of options",
            "suites": [
                "BetterScroll Options"
            ],
            "updatePoint": {
                "line": 124,
                "column": 54
            },
            "line": 124,
            "code": "  it('should generate some extra properties of options', () => {\n    options.process()\n\n    expect(options).toEqual({\n      HWCompositing: true,\n      autoBlur: true,\n      bindToWrapper: false,\n      bounce: {\n        bottom: true,\n        left: true,\n        right: true,\n        top: true,\n      },\n      bounceTime: 800,\n      click: false,\n      dblclick: false,\n      deceleration: 0.0015,\n      directionLockThreshold: 0,\n      disableMouse: false,\n      disableTouch: true,\n      eventPassthrough: '',\n      flickLimitDistance: 100,\n      flickLimitTime: 200,\n      freeScroll: false,\n      momentum: true,\n      momentumLimitDistance: 15,\n      momentumLimitTime: 300,\n      preventDefault: true,\n      preventDefaultException: {\n        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|AUDIO)$/,\n      },\n      tagException: {\n        tagName: /^TEXTAREA$/,\n      },\n      probeType: 0,\n      resizePolling: 60,\n      scrollX: false,\n      scrollY: true,\n      startX: 0,\n      startY: 0,\n      stopPropagation: false,\n      swipeBounceTime: 500,\n      swipeTime: 2500,\n      tap: '',\n      useTransition: true,\n      translateZ: '',\n      autoEndDistance: 5,\n      bindToTarget: false,\n      outOfBoundaryDampingFactor: 1 / 3,\n      specifiedIndexAsContent: 0,\n      quadrant: 1,\n    })\n  })",
            "file": "Options.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "should resolve bounce when calling process",
            "suites": [
                "BetterScroll Options"
            ],
            "updatePoint": {
                "line": 178,
                "column": 48
            },
            "line": 178,
            "code": "  it('should resolve bounce when calling process', () => {\n    options.merge({\n      bounce: false,\n    })\n\n    expect(options.bounce).toEqual({\n      bottom: false,\n      left: false,\n      right: false,\n      top: false,\n    })\n\n    options.merge({\n      bounce: true,\n    })\n\n    expect(options.bounce).toEqual({\n      bottom: true,\n      left: true,\n      right: true,\n      top: true,\n    })\n\n    options.merge({\n      bounce: {\n        top: false,\n        bottom: false,\n      },\n    })\n\n    expect(options.bounce).toEqual({\n      bottom: false,\n      left: true,\n      right: true,\n      top: false,\n    })\n  })",
            "file": "Options.spec.ts",
            "skipped": false,
            "dir": "packages/core/src/__tests__"
        },
        {
            "name": "throw error when pass wrong options",
            "suites": [
                "Indicators unit tests",
                "constructor"
            ],
            "updatePoint": {
                "line": 46,
                "column": 43
            },
            "line": 46,
            "code": "    it('throw error when pass wrong options', () => {\n      expect(() => {\n        new Indicators(scroll)\n      }).toThrow()\n      expect(() => {\n        addProperties(scroll.options, {\n          indicators: [\n            {\n              relationElement: null,\n            },\n          ],\n        })\n        new Indicators(scroll)\n      }).toThrow()\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/indicators/src/__tests__"
        },
        {
            "name": "should create indicator elements",
            "suites": [
                "Indicators unit tests",
                "constructor"
            ],
            "updatePoint": {
                "line": 62,
                "column": 40
            },
            "line": 62,
            "code": "    it('should create indicator elements', () => {\n      const { indicatorWrapper } = createIndicatorElement()\n      addProperties(scroll.options, {\n        indicators: [\n          {\n            relationElement: indicatorWrapper,\n          },\n        ],\n      })\n      const indicatorsInstance = new Indicators(scroll)\n      expect(indicatorsInstance.indicators.length).toBe(1)\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/indicators/src/__tests__"
        },
        {
            "name": "destroy hook",
            "suites": [
                "Indicators unit tests",
                "constructor"
            ],
            "updatePoint": {
                "line": 75,
                "column": 20
            },
            "line": 75,
            "code": "    it('destroy hook', () => {\n      const { indicatorWrapper } = createIndicatorElement()\n      addProperties(scroll.options, {\n        indicators: [\n          {\n            relationElement: indicatorWrapper,\n          },\n        ],\n      })\n      const indicatorsInstance = new Indicators(scroll)\n      scroll.hooks.trigger(scroll.hooks.eventTypes.destroy)\n      for (let indicator of indicatorsInstance.indicators) {\n        expect(indicator.destroy).toBeCalled()\n      }\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/indicators/src/__tests__"
        },
        {
            "name": "refresh hook",
            "suites": [
                "Indicator unit tests"
            ],
            "updatePoint": {
                "line": 53,
                "column": 18
            },
            "line": 53,
            "code": "  it('refresh hook', () => {\n    const indicator = new Indicator(scroll, indicatorOption)\n    addProperties(scroll, {\n      hasVerticalScroll: true,\n      hasHorizontalScroll: true,\n      maxScrollX: -1,\n      maxScrollY: -1,\n    })\n    addProperties(indicatorOption, {\n      ratio: {\n        x: 1,\n        y: 1,\n      },\n    })\n    scroll.hooks.trigger(scroll.hooks.eventTypes.refresh)\n    expect(indicator.currentPos).toMatchObject({\n      x: 0,\n      y: 0,\n    })\n    expect(indicator.indicatorEl.style.transform).toBe(\n      'translateX(0px) translateY(0px)  translateZ(0)'\n    )\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/indicators/src/__tests__"
        },
        {
            "name": "translater hook",
            "suites": [
                "Indicator unit tests"
            ],
            "updatePoint": {
                "line": 77,
                "column": 21
            },
            "line": 77,
            "code": "  it('translater hook', () => {\n    const indicator = new Indicator(scroll, indicatorOption)\n    addProperties(indicator, {\n      ratioY: 2,\n      translateYSign: 1,\n    })\n    const translaterHooks = scroll.scroller.translater.hooks\n    translaterHooks.trigger(translaterHooks.eventTypes.translate, {\n      x: 0,\n      y: -20,\n    })\n    expect(indicator.currentPos).toMatchObject({\n      x: 0,\n      y: -40,\n    })\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/indicators/src/__tests__"
        },
        {
            "name": "animater hook",
            "suites": [
                "Indicator unit tests"
            ],
            "updatePoint": {
                "line": 94,
                "column": 19
            },
            "line": 94,
            "code": "  it('animater hook', () => {\n    const indicator = new Indicator(scroll, indicatorOption)\n    const animaterHooks = scroll.scroller.animater.hooks\n    animaterHooks.trigger(\n      animaterHooks.eventTypes.timeFunction,\n      'cubic-bezier(0.25, 0.46, 0.45, 0.94)'\n    )\n    animaterHooks.trigger(animaterHooks.eventTypes.time, 200)\n    const style = indicator.indicatorEl.style as any\n    expect(style['transition-timing-function']).toBe(\n      'cubic-bezier(0.25, 0.46, 0.45, 0.94)'\n    )\n    expect(style['transition-duration']).toBe('200ms')\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/indicators/src/__tests__"
        },
        {
            "name": "touch hooks",
            "suites": [
                "Indicator unit tests"
            ],
            "updatePoint": {
                "line": 109,
                "column": 17
            },
            "line": 109,
            "code": "  it('touch hooks', async () => {\n    addProperties(scroll.options, {\n      probeType: 3,\n      disableMouse: false,\n    })\n    addProperties(scroll, {\n      hasHorizontalScroll: true,\n    })\n    const indicator = new Indicator(scroll, indicatorOption)\n    const beforeStartMockFn = jest.fn()\n    const startMockFn = jest.fn()\n    const moveMockFn = jest.fn()\n    const endMockFn = jest.fn()\n    const scroller = scroll.scroller\n    scroller.hooks.on(\n      scroller.hooks.eventTypes.beforeScrollStart,\n      beforeStartMockFn\n    )\n    scroller.hooks.on(scroller.hooks.eventTypes.scrollStart, startMockFn)\n    scroller.hooks.on(scroller.hooks.eventTypes.scroll, moveMockFn)\n    scroller.hooks.on(scroller.hooks.eventTypes.scrollEnd, endMockFn)\n\n    // scroll is disabled\n    scroll.enabled = false\n    dispatchTouchStart(indicatorOption.relationElement.children[0], [\n      {\n        pageX: 0,\n        pageY: -20,\n      },\n    ])\n    expect(beforeStartMockFn).not.toBeCalled()\n\n    // scroll is enabled\n    scroll.enabled = true\n    dispatchTouchStart(indicatorOption.relationElement.children[0], [\n      {\n        pageX: 0,\n        pageY: -20,\n      },\n    ])\n    dispatchTouchMove(window, [\n      {\n        pageX: 0,\n        pageY: -40,\n      },\n    ])\n\n    dispatchTouchEnd(window, [])\n\n    expect(beforeStartMockFn).toBeCalled()\n    expect(startMockFn).toBeCalled()\n    expect(moveMockFn).toBeCalled()\n    expect(endMockFn).toBeCalled()\n\n    // dispatch scroll in interval time\n    addProperties(scroll.options, {\n      probeType: 1,\n    })\n    const moveMockFn2 = jest.fn()\n    scroller.hooks.on(scroller.hooks.eventTypes.scroll, moveMockFn2)\n    dispatchTouchStart(indicatorOption.relationElement.children[0], [\n      {\n        pageX: 0,\n        pageY: -20,\n      },\n    ])\n    await new Promise((resolve) => {\n      setTimeout(resolve, 400)\n    })\n    dispatchTouchMove(window, [\n      {\n        pageX: 0,\n        pageY: -40,\n      },\n    ])\n    expect(moveMockFn2).toBeCalled()\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/indicators/src/__tests__"
        },
        {
            "name": "destroy",
            "suites": [
                "Indicator unit tests"
            ],
            "updatePoint": {
                "line": 187,
                "column": 13
            },
            "line": 187,
            "code": "  it('destroy', () => {\n    addProperties(indicatorOption, {\n      ratio: 1,\n    })\n    const indicator = new Indicator(scroll, indicatorOption)\n    scroll.hooks.trigger(scroll.hooks.eventTypes.refresh)\n    indicator.destroy()\n    expect(indicator.hooksFn.length).toBe(0)\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/indicators/src/__tests__"
        },
        {
            "name": "should fetch new data when loadedNum < list.length",
            "suites": [
                "DataManager unit test"
            ],
            "updatePoint": {
                "line": 21,
                "column": 56
            },
            "line": 21,
            "code": "  it('should fetch new data when loadedNum < list.length', () => {\n    // given\n    let end = NEW_LEN\n    const DATA = 1\n    const newData = new Array(NEW_LEN).fill(DATA)\n    fetchFn.mockReturnValue(Promise.resolve(newData))\n    // when\n    // tslint:disable-next-line: no-floating-promises\n    dataManager.update(end)\n    // then\n    // create empty data firstly, and then, go to fetch data\n    expect(dataManager.getList().length).not.toBeLessThan(NEW_LEN)\n    expect(fetchFn).toBeCalledWith(NEW_LEN)\n  })",
            "file": "DataManager.spec.ts",
            "skipped": false,
            "dir": "packages/infinity/src/__tests__"
        },
        {
            "name": "should call onFetchFinish with hasMore equal true when loaded new data",
            "suites": [
                "DataManager unit test"
            ],
            "updatePoint": {
                "line": 36,
                "column": 76
            },
            "line": 36,
            "code": "  it('should call onFetchFinish with hasMore equal true when loaded new data', async () => {\n    // given\n    const start = 0\n    const end = NEW_LEN\n    const DATA = 1\n    const newData = new Array(NEW_LEN).fill(DATA)\n    fetchFn.mockReturnValue(Promise.resolve(newData))\n    // when\n    await dataManager.update(end)\n    // then\n    expect(onFetchFinish).toBeCalledWith(dataManager.getList(), true)\n  })",
            "file": "DataManager.spec.ts",
            "skipped": false,
            "dir": "packages/infinity/src/__tests__"
        },
        {
            "name": "should call onFetchFinish with hasMore equal false when no more data",
            "suites": [
                "DataManager unit test"
            ],
            "updatePoint": {
                "line": 49,
                "column": 74
            },
            "line": 49,
            "code": "  it('should call onFetchFinish with hasMore equal false when no more data', async () => {\n    // given\n    const start = 0\n    const end = NEW_LEN\n    fetchFn.mockReturnValue(Promise.resolve(false))\n    // when\n    await dataManager.update(end)\n    // then\n    expect(onFetchFinish).toBeCalledWith(dataManager.getList(), false)\n  })",
            "file": "DataManager.spec.ts",
            "skipped": false,
            "dir": "packages/infinity/src/__tests__"
        },
        {
            "name": "should get start equal to 0 when pos is 0",
            "suites": [
                "IndexCalculator unit test"
            ],
            "updatePoint": {
                "line": 15,
                "column": 47
            },
            "line": 15,
            "code": "  it('should get start equal to 0 when pos is 0', () => {\n    // given\n    const list = new FakeList(0).getList()\n    // when\n    const { start, end } = indexCalculator.calculate(0, list)\n    // then\n    expect(start).toBe(0)\n    expect(end).toBe(VISIBLE_CNT + POST_NUM)\n  })",
            "file": "IndexCalculator.spec.ts",
            "skipped": false,
            "dir": "packages/infinity/src/__tests__"
        },
        {
            "name": "should get start equal to 0 when first rendered index < PRE_NUM",
            "suites": [
                "IndexCalculator unit test"
            ],
            "updatePoint": {
                "line": 25,
                "column": 69
            },
            "line": 25,
            "code": "  it('should get start equal to 0 when first rendered index < PRE_NUM', () => {\n    // given\n    const list = new FakeList(100)\n      .fillDom(0)\n      .fillPos()\n      .getList()\n    const INDEX = 5\n    const POSITION = INDEX * TOMBSTONE_HEIGHT\n    // when\n    const { start, end } = indexCalculator.calculate(POSITION, list)\n    // then\n    expect(start).toBe(0)\n  })",
            "file": "IndexCalculator.spec.ts",
            "skipped": false,
            "dir": "packages/infinity/src/__tests__"
        },
        {
            "name": "should get start equal to index-PRE_NUM when first visilbe index > PRE_NUM",
            "suites": [
                "IndexCalculator unit test"
            ],
            "updatePoint": {
                "line": 39,
                "column": 80
            },
            "line": 39,
            "code": "  it('should get start equal to index-PRE_NUM when first visilbe index > PRE_NUM', () => {\n    // given\n    const list = new FakeList(100)\n      .fillDom(0)\n      .fillPos()\n      .getList()\n    const INDEX = 15\n    const POSITION = INDEX * TOMBSTONE_HEIGHT\n    // when\n    const { start } = indexCalculator.calculate(POSITION, list)\n    // then\n    expect(start).toBe(INDEX - PRE_NUM)\n  })",
            "file": "IndexCalculator.spec.ts",
            "skipped": false,
            "dir": "packages/infinity/src/__tests__"
        },
        {
            "name": "should get correct val when scroll up and down",
            "suites": [
                "IndexCalculator unit test"
            ],
            "updatePoint": {
                "line": 53,
                "column": 52
            },
            "line": 53,
            "code": "  it('should get correct val when scroll up and down', () => {\n    // given\n    const list = new FakeList(100)\n      .fillDom(0)\n      .fillPos()\n      .getList()\n    const FIRST_INDEX = 50\n    const FIRST_POSITION = FIRST_INDEX * TOMBSTONE_HEIGHT\n    const SECOND_INDEX = 40\n    const SECOND_POSITION = SECOND_INDEX * TOMBSTONE_HEIGHT\n    // when\n    indexCalculator.calculate(FIRST_POSITION, list)\n    const { start } = indexCalculator.calculate(SECOND_POSITION, list)\n    // then\n    expect(start).toBe(SECOND_INDEX - POST_NUM)\n  })",
            "file": "IndexCalculator.spec.ts",
            "skipped": false,
            "dir": "packages/infinity/src/__tests__"
        },
        {
            "name": "should proxy hooks to BScroll instance",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 63,
                "column": 44
            },
            "line": 63,
            "code": "  it('should proxy hooks to BScroll instance', () => {\n    expect(scroll.registerType).toHaveBeenCalledWith([\n      'alterOptions',\n      'mousewheelStart',\n      'mousewheelMove',\n      'mousewheelEnd',\n    ])\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should handle default options and user options",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 72,
                "column": 52
            },
            "line": 72,
            "code": "  it('should handle default options and user options', () => {\n    // case 1\n    scroll.options.mouseWheel = true\n    mouseWheel = new MouseWheel(scroll)\n\n    expect(mouseWheel.mouseWheelOpt).toMatchObject({\n      speed: 20,\n      invert: false,\n      easeTime: 300,\n      discreteTime: 400,\n      throttleTime: 0,\n      dampingFactor: 0.1,\n    })\n\n    // case 2\n    scroll.options.mouseWheel = {\n      dampingFactor: 1,\n      throttleTime: 50,\n    }\n    mouseWheel = new MouseWheel(scroll)\n\n    expect(mouseWheel.mouseWheelOpt).toMatchObject({\n      speed: 20,\n      invert: false,\n      easeTime: 300,\n      discreteTime: 400,\n      throttleTime: 50,\n      dampingFactor: 1,\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should trigger mousewheel(start|move|end) when moved ",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 103,
                "column": 59
            },
            "line": 103,
            "code": "  it('should trigger mousewheel(start|move|end) when moved ', () => {\n    const onStart = jest.fn()\n    const onMove = jest.fn()\n    const onEnd = jest.fn()\n    const onAlterOptions = jest.fn()\n\n    scroll.on('mousewheelStart', onStart)\n    scroll.on('mousewheelMove', onMove)\n    scroll.on('mousewheelEnd', onEnd)\n    scroll.on('alterOptions', onAlterOptions)\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel')\n    expect(onStart).toBeCalledTimes(1)\n    expect(onMove).toBeCalledTimes(1)\n    expect(onAlterOptions).toBeCalledTimes(1)\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel')\n    jest.advanceTimersByTime(DISCRETE_TIME)\n    expect(onMove).toBeCalledTimes(2)\n\n    expect(onEnd).toBeCalledTimes(1)\n\n    // forbid moving\n    scroll.enabled = false\n    dispatchMouseWheel(scroll.wrapper, 'wheel')\n    expect(onStart).toBeCalledTimes(1)\n    expect(onMove).toBeCalledTimes(2)\n    expect(onEnd).toBeCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should support throttle when throttleTime > 0",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 133,
                "column": 51
            },
            "line": 133,
            "code": "  it('should support throttle when throttleTime > 0', () => {\n    mouseWheel.mouseWheelOpt.throttleTime = 50\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 10,\n    })\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 20,\n    })\n    jest.advanceTimersByTime(51)\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 30,\n    })\n    expect(scroll.scrollTo).toBeCalledTimes(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should warn when easeTime is invalid",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 151,
                "column": 42
            },
            "line": 151,
            "code": "  it('should warn when easeTime is invalid', () => {\n    const spyFn = jest.spyOn(console, 'error')\n    mouseWheel.mouseWheelOpt.easeTime = 50\n    dispatchMouseWheel(scroll.wrapper, 'wheel')\n    expect(spyFn).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should preventDefault & stopProgation if they are set",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 158,
                "column": 59
            },
            "line": 158,
            "code": "  it('should preventDefault & stopProgation if they are set', () => {\n    const mockStopPropagation = jest.fn()\n    const mockPreventDefault = jest.fn()\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      preventDefault: mockPreventDefault,\n      stopPropagation: mockStopPropagation,\n    })\n    expect(mockPreventDefault).toBeCalled()\n    expect(mockStopPropagation).not.toBe(0)\n    jest.advanceTimersByTime(400)\n\n    mockPreventDefault.mockClear()\n    mockStopPropagation.mockClear()\n\n    // preventDefaultException work\n    scroll.options.preventDefaultException = {\n      tagName: /^(DIV)$/,\n    }\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      preventDefault: mockPreventDefault,\n      stopPropagation: mockStopPropagation,\n    })\n    expect(mockPreventDefault).not.toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should forbid scrollTo when mousewheelMove hook return true",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 185,
                "column": 65
            },
            "line": 185,
            "code": "  it('should forbid scrollTo when mousewheelMove hook return true', () => {\n    const onStart = jest.fn()\n    const onMove = jest.fn().mockImplementation(() => {\n      return true\n    })\n    const onEnd = jest.fn()\n\n    scroll.on('mousewheelStart', onStart)\n    scroll.on('mousewheelMove', onMove)\n    scroll.on('mousewheelEnd', onEnd)\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel')\n    expect(onStart).toBeCalledTimes(1)\n    expect(onMove).toBeCalledTimes(1)\n\n    expect(scroll.scrollTo).not.toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should get right postion when move with deltaMode = 0",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 203,
                "column": 59
            },
            "line": 203,
            "code": "  it('should get right postion when move with deltaMode = 0', () => {\n    const onEnd = jest.fn()\n    scroll.on('mousewheelEnd', onEnd)\n\n    // x direction\n    scroll.hasVerticalScroll = false\n    scroll.hasHorizontalScroll = true\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 10,\n      deltaMode: 0,\n    })\n\n    expect(scroll.scrollTo).toBeCalledWith(-10, 0, 300)\n    jest.advanceTimersByTime(410)\n    expect(onEnd).toBeCalledWith({\n      x: -10,\n      y: 0,\n      directionX: 1,\n      directionY: 0,\n    })\n\n    // y direction\n    scroll.hasVerticalScroll = true\n    scroll.hasHorizontalScroll = false\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 10,\n      deltaMode: 0,\n    })\n    expect(scroll.scrollTo).toBeCalledWith(0, -10, 300)\n    jest.advanceTimersByTime(410)\n    expect(onEnd).toBeCalledWith({\n      x: 0,\n      y: -10,\n      directionX: 0,\n      directionY: 1,\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should get right postion when move with deltaMode = 1",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 243,
                "column": 59
            },
            "line": 243,
            "code": "  it('should get right postion when move with deltaMode = 1', () => {\n    // x direction\n    scroll.hasVerticalScroll = false\n    scroll.hasHorizontalScroll = true\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 2,\n      deltaMode: 1,\n    })\n    expect(scroll.scrollTo).toBeCalledWith(-40, 0, 300)\n\n    // y direction\n    scroll.hasVerticalScroll = true\n    scroll.hasHorizontalScroll = false\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 2,\n      deltaMode: 1,\n    })\n    expect(scroll.scrollTo).toBeCalledWith(0, -40, 300)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should get right postion when move with wheelDeltaX and wheelDeltaY",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 266,
                "column": 73
            },
            "line": 266,
            "code": "  it('should get right postion when move with wheelDeltaX and wheelDeltaY', () => {\n    scroll.hasVerticalScroll = true\n    scroll.hasHorizontalScroll = true\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      wheelDeltaX: -120,\n      wheelDeltaY: -240,\n      deltaMode: 0,\n    })\n    expect(scroll.scrollTo).toBeCalledWith(-20, -40, 300)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should get right postion when move with wheelDelta",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 277,
                "column": 56
            },
            "line": 277,
            "code": "  it('should get right postion when move with wheelDelta', () => {\n    scroll.hasVerticalScroll = true\n    scroll.hasHorizontalScroll = true\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      wheelDelta: -120,\n      deltaMode: 0,\n    })\n    expect(scroll.scrollTo).toBeCalledWith(-20, -20, 300)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should get right postion when move with detail",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 287,
                "column": 52
            },
            "line": 287,
            "code": "  it('should get right postion when move with detail', () => {\n    scroll.hasVerticalScroll = true\n    scroll.hasHorizontalScroll = true\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      detail: 60,\n      deltaMode: 0,\n    })\n    expect(scroll.scrollTo).toBeCalledWith(-400, -400, 300)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should get right postion when move with invert = true",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 298,
                "column": 59
            },
            "line": 298,
            "code": "  it('should get right postion when move with invert = true', () => {\n    // x direction\n    scroll.hasVerticalScroll = false\n    scroll.hasHorizontalScroll = true\n\n    mouseWheel.mouseWheelOpt.invert = true\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 2,\n      deltaMode: 1,\n    })\n    expect(scroll.scrollTo).toBeCalledWith(40, 0, 300)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should work with dampingFactor",
            "suites": [
                "mouse-wheel plugin"
            ],
            "updatePoint": {
                "line": 313,
                "column": 36
            },
            "line": 313,
            "code": "  it('should work with dampingFactor', () => {\n    mouseWheel.mouseWheelOpt.dampingFactor = 0.1\n\n    scroll.scroller.scrollBehaviorX.performDampingAlgorithm = jest\n      .fn()\n      .mockImplementation((distance, factor) => {\n        return distance * factor\n      })\n    scroll.scroller.scrollBehaviorY.performDampingAlgorithm = jest\n      .fn()\n      .mockImplementation((distance, factor) => {\n        return distance * factor\n      })\n\n    dispatchMouseWheel(scroll.wrapper, 'wheel', {\n      deltaX: 0,\n      deltaY: 2,\n      deltaMode: 1,\n    })\n\n    expect(scroll.scrollTo).toBeCalledWith(0, -4, 300)\n    // improve coverage\n    mouseWheel.destroy()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/mouse-wheel/src/__tests__"
        },
        {
            "name": "should proxy properties to BScroll instance",
            "suites": [
                "movable plugin"
            ],
            "updatePoint": {
                "line": 31,
                "column": 49
            },
            "line": 31,
            "code": "  it('should proxy properties to BScroll instance', () => {\n    expect(scroll.proxy).toBeCalled()\n    expect(scroll.proxy).toHaveBeenLastCalledWith([\n      {\n        key: 'putAt',\n        sourceKey: 'plugins.movable.putAt',\n      },\n    ])\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/movable/src/__tests__"
        },
        {
            "name": "should modify boundary",
            "suites": [
                "movable plugin"
            ],
            "updatePoint": {
                "line": 41,
                "column": 28
            },
            "line": 41,
            "code": "  it('should modify boundary', () => {\n    const { scrollBehaviorX, scrollBehaviorY } = scroll.scroller\n    scrollBehaviorX.options.scrollable = true\n    scrollBehaviorY.options.scrollable = true\n\n    scrollBehaviorX.wrapperSize = 200\n    scrollBehaviorX.contentSize = 100\n    scrollBehaviorY.wrapperSize = 400\n    scrollBehaviorY.contentSize = 200\n\n    let boundaryX: Boundary = { minScrollPos: 0, maxScrollPos: 1 }\n    let boundaryY: Boundary = { minScrollPos: 0, maxScrollPos: 1 }\n\n    scrollBehaviorX.hooks.trigger(\n      scrollBehaviorX.hooks.eventTypes.computeBoundary,\n      boundaryX\n    )\n    scrollBehaviorY.hooks.trigger(\n      scrollBehaviorY.hooks.eventTypes.computeBoundary,\n      boundaryY\n    )\n\n    expect(boundaryX).toMatchObject({\n      minScrollPos: 100,\n      maxScrollPos: 0,\n    })\n\n    expect(boundaryY).toMatchObject({\n      minScrollPos: 200,\n      maxScrollPos: 0,\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/movable/src/__tests__"
        },
        {
            "name": "should register ignoreHasScroll hook",
            "suites": [
                "movable plugin"
            ],
            "updatePoint": {
                "line": 74,
                "column": 42
            },
            "line": 74,
            "code": "  it('should register ignoreHasScroll hook', () => {\n    const { scrollBehaviorX, scrollBehaviorY } = scroll.scroller\n    const retX = scrollBehaviorX.hooks.trigger(\n      scrollBehaviorX.hooks.eventTypes.ignoreHasScroll\n    )\n    const retY = scrollBehaviorY.hooks.trigger(\n      scrollBehaviorY.hooks.eventTypes.ignoreHasScroll\n    )\n\n    expect(retX).toBe(true)\n    expect(retY).toBe(true)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/movable/src/__tests__"
        },
        {
            "name": "should work well when call putAt()",
            "suites": [
                "movable plugin"
            ],
            "updatePoint": {
                "line": 87,
                "column": 40
            },
            "line": 87,
            "code": "  it('should work well when call putAt()', () => {\n    // integer\n    movable.putAt(20, 20)\n    expect(scroll.scrollTo).toBeCalledWith(20, 20, 800, expect.anything())\n\n    // simulate minScrollPos\n    scroll.scroller.scrollBehaviorX.minScrollPos = 300\n    scroll.scroller.scrollBehaviorY.minScrollPos = 300\n\n    // [left, bottom]\n    movable.putAt('left', 'bottom')\n    expect(scroll.scrollTo).toBeCalledWith(0, 300, 800, expect.anything())\n\n    // [right, top]\n    movable.putAt('right', 'top')\n    expect(scroll.scrollTo).toBeCalledWith(300, 0, 800, expect.anything())\n\n    // [center, center]\n    movable.putAt('center', 'center')\n    expect(scroll.scrollTo).toBeCalledWith(150, 150, 800, expect.anything())\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/movable/src/__tests__"
        },
        {
            "name": "should destroy all events",
            "suites": [
                "movable plugin"
            ],
            "updatePoint": {
                "line": 109,
                "column": 31
            },
            "line": 109,
            "code": "  it('should destroy all events', () => {\n    const { scrollBehaviorX, scrollBehaviorY } = scroll.scroller\n    scroll.hooks.trigger(scroll.hooks.eventTypes.destroy)\n    expect(scrollBehaviorX.hooks.events['computeBoundary'].length).toBe(0)\n    expect(scrollBehaviorX.hooks.events['ignoreHasScroll'].length).toBe(0)\n\n    expect(scrollBehaviorY.hooks.events['computeBoundary'].length).toBe(0)\n    expect(scrollBehaviorY.hooks.events['ignoreHasScroll'].length).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/movable/src/__tests__"
        },
        {
            "name": "should proxy properties to scroll instance",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 45,
                "column": 48
            },
            "line": 45,
            "code": "  it('should proxy properties to scroll instance', () => {\n    const scroll = new BScroll(parentWrapper, {\n      nestedScroll: true,\n    })\n    new NestedScroll(scroll)\n    expect(scroll.proxy).toBeCalledWith([\n      {\n        key: 'purgeNestedScroll',\n        sourceKey: 'plugins.nestedScroll.purgeNestedScroll',\n      },\n    ])\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "nestedScroll.gropuId should be string or number ",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 58,
                "column": 54
            },
            "line": 58,
            "code": "  it('nestedScroll.gropuId should be string or number ', () => {\n    const spyFn = jest.spyOn(console, 'error')\n    const nestedScroll1 = new NestedScroll(\n      new BScroll(parentWrapper, {\n        nestedScroll: {\n          groupId: {} as any,\n        },\n      })\n    )\n\n    expect(spyFn).toBeCalledWith(\n      '[BScroll warn]: groupId must be string or number for NestedScroll plugin'\n    )\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should allocate default groupId when nestedScroll options is \"true\"",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 73,
                "column": 73
            },
            "line": 73,
            "code": "  it('should allocate default groupId when nestedScroll options is \"true\"', () => {\n    const nestedScroll1 = new NestedScroll(\n      new BScroll(parentWrapper, {\n        nestedScroll: true,\n      })\n    )\n    const nestedScroll2 = new NestedScroll(\n      new BScroll(childWrapper, {\n        nestedScroll: true,\n      })\n    )\n\n    expect(nestedScroll1).toEqual(nestedScroll2)\n    expect(NestedScroll.instancesMap[DEFAUL_GROUP_ID]).toBe(nestedScroll1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should share same nestedScroll when groupId is equal",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 89,
                "column": 58
            },
            "line": 89,
            "code": "  it('should share same nestedScroll when groupId is equal', () => {\n    const nestedScroll1 = new NestedScroll(\n      new BScroll(parentWrapper, {\n        nestedScroll: {\n          groupId: 0,\n        },\n      })\n    )\n    const nestedScroll2 = new NestedScroll(\n      new BScroll(childWrapper, {\n        nestedScroll: {\n          groupId: 0,\n        },\n      })\n    )\n\n    expect(nestedScroll1).toEqual(nestedScroll2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should store BScroll instance",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 108,
                "column": 35
            },
            "line": 108,
            "code": "  it('should store BScroll instance', () => {\n    const nestedScroll1 = new NestedScroll(new BScroll(parentWrapper, {}))\n    const nestedScroll2 = new NestedScroll(new BScroll(childWrapper, {}))\n\n    expect(nestedScroll1.store.length).toBe(2)\n    expect(nestedScroll1).toBe(nestedScroll2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should build BScrollGraph",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 116,
                "column": 31
            },
            "line": 116,
            "code": "  it('should build BScrollGraph', () => {\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'BScrollGraph',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'BScrollGraph',\n      },\n    })\n    // ns1 === ns2\n    const ns1 = new NestedScroll(parentScroll)\n    const ns2 = new NestedScroll(childScroll)\n    const parentBScrollFamily = ns1.store[0]\n    const childBScrollFamily = ns1.store[1]\n\n    expect(parentBScrollFamily.ancestors.length).toBe(0)\n    expect(\n      parentBScrollFamily.descendants.findIndex(([bf]) => {\n        return bf === childBScrollFamily\n      }) > -1\n    ).toBe(true)\n    expect(\n      childBScrollFamily.ancestors.findIndex(([bf]) => {\n        return bf === parentBScrollFamily\n      }) > -1\n    ).toBe(true)\n    expect(childBScrollFamily.descendants.length).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should has different nestedScroll instance in NestedScroll class",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 147,
                "column": 70
            },
            "line": 147,
            "code": "  it('should has different nestedScroll instance in NestedScroll class', () => {\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'BScrollGraph1',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'BScrollGraph2',\n      },\n    })\n\n    const nestedScroll1 = new NestedScroll(parentScroll)\n    const nestedScroll2 = new NestedScroll(childScroll)\n\n    expect(nestedScroll1).not.toBe(nestedScroll2)\n    expect(NestedScroll.getAllNestedScrolls().length).toBe(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "disable the ancestors scroll when self is scrolling",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 166,
                "column": 57
            },
            "line": 166,
            "code": "  it('disable the ancestors scroll when self is scrolling', () => {\n    // vertical\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'vertical',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'vertical',\n      },\n    })\n    const grandsonScroll = new BScroll(grandsonWrapper, {\n      nestedScroll: {\n        groupId: 'vertical',\n      },\n    })\n    new NestedScroll(parentScroll)\n    new NestedScroll(childScroll)\n    new NestedScroll(grandsonScroll)\n\n    addProperties(parentScroll, {\n      pending: true,\n    })\n    addProperties(childScroll, {\n      pending: true,\n    })\n    grandsonScroll.trigger(grandsonScroll.eventTypes.beforeScrollStart)\n\n    expect(parentScroll.stop).toBeCalled()\n    expect(parentScroll.resetPosition).toBeCalled()\n    expect(childScroll.stop).toBeCalled()\n    expect(childScroll.resetPosition).toBeCalled()\n\n    // horizontal\n    const parentScrollH = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'horizontal',\n      },\n      scrollY: false,\n      scrollX: true,\n    })\n    const childScrollH = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'horizontal',\n      },\n      scrollY: false,\n      scrollX: true,\n    })\n    const grandsonScrollH = new BScroll(grandsonWrapper, {\n      nestedScroll: {\n        groupId: 'horizontal',\n      },\n      scrollY: false,\n      scrollX: true,\n    })\n    new NestedScroll(parentScrollH)\n    new NestedScroll(childScrollH)\n    new NestedScroll(grandsonScrollH)\n\n    addProperties(parentScrollH, {\n      hasVerticalScroll: false,\n      hasHorizontalScroll: true,\n    })\n    addProperties(childScrollH, {\n      hasVerticalScroll: false,\n      hasHorizontalScroll: true,\n    })\n    addProperties(grandsonScrollH, {\n      hasVerticalScroll: false,\n      hasHorizontalScroll: true,\n    })\n    grandsonScrollH.trigger(grandsonScrollH.eventTypes.beforeScrollStart)\n\n    expect(parentScrollH.disable).toBeCalled()\n    expect(parentScrollH.scroller.actions.startTime).toBeTruthy()\n    expect(childScrollH.disable).toBeCalled()\n    expect(childScrollH.scroller.actions.startTime).toBeTruthy()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should delete scroll from nestedScroll graph when scroll is destroyed",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 246,
                "column": 75
            },
            "line": 246,
            "code": "  it('should delete scroll from nestedScroll graph when scroll is destroyed', () => {\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'deleteScroll',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'deleteScroll',\n      },\n    })\n\n    const ns = new NestedScroll(parentScroll)\n    new NestedScroll(childScroll)\n\n    expect(ns.store.length).toBe(2)\n    expect(childScroll.hooks.events.destroy.length).toBe(1)\n    childScroll.hooks.trigger(childScroll.hooks.eventTypes.destroy)\n    expect(ns.store.length).toBe(1)\n    expect(childScroll.hooks.events.destroy.length).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should force ancestors and descendants stop when self will start scrolling",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 268,
                "column": 80
            },
            "line": 268,
            "code": "  it('should force ancestors and descendants stop when self will start scrolling', () => {\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'force-stop',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'force-stop',\n      },\n    })\n\n    new NestedScroll(parentScroll)\n    new NestedScroll(childScroll)\n\n    addProperties(childScroll, {\n      pending: true,\n    })\n\n    parentScroll.trigger(parentScroll.eventTypes.beforeScrollStart)\n    expect(childScroll.stop).toBeCalled()\n    expect(childScroll.resetPosition).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should force self resetting potisition",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 292,
                "column": 44
            },
            "line": 292,
            "code": "  it('should force self resetting potisition', () => {\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'force-stop',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'force-stop',\n      },\n    })\n\n    addProperties(parentScroll, {\n      hasVerticalScroll: false,\n      hasHorizontalScroll: true,\n    })\n    addProperties(childScroll, {\n      hasVerticalScroll: false,\n      hasHorizontalScroll: true,\n      x: 1,\n    })\n\n    new NestedScroll(parentScroll)\n    new NestedScroll(childScroll)\n\n    childScroll.trigger(childScroll.eventTypes.beforeScrollStart)\n    expect(childScroll.scroller.reflow).toBeCalled()\n    expect(childScroll.resetPosition).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "detectMovingDirection hook",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 322,
                "column": 32
            },
            "line": 322,
            "code": "  it('detectMovingDirection hook', () => {\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'enable-others',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'enable-others',\n      },\n    })\n\n    new NestedScroll(parentScroll)\n    new NestedScroll(childScroll)\n\n    // one is moved, all ancestors should be disabled\n    childScroll.scroller.actions.contentMoved = true\n    const selfActionsHooks = childScroll.scroller.actions.hooks\n    selfActionsHooks.trigger(selfActionsHooks.eventTypes.detectMovingDirection)\n    expect(parentScroll.disable).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should enable ancestors and descendants when self touchended",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 344,
                "column": 66
            },
            "line": 344,
            "code": "  it('should enable ancestors and descendants when self touchended', () => {\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'touchend',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'touchend',\n      },\n    })\n\n    new NestedScroll(parentScroll)\n    new NestedScroll(childScroll)\n\n    childScroll.trigger(childScroll.eventTypes.touchEnd)\n    expect(parentScroll.enable).toBeCalled()\n    parentScroll.trigger(parentScroll.eventTypes.touchEnd)\n    expect(childScroll.enable).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "should only allow top-scroll has bounce effect",
            "suites": [
                "NestedScroll tests"
            ],
            "updatePoint": {
                "line": 365,
                "column": 52
            },
            "line": 365,
            "code": "  it('should only allow top-scroll has bounce effect', () => {\n    // vertical\n    const parentScroll = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'vertical-bounce-effect',\n      },\n    })\n    const childScroll = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'vertical-bounce-effect',\n      },\n    })\n\n    new NestedScroll(parentScroll)\n    new NestedScroll(childScroll)\n\n    childScroll.movingDirectionY = -1\n\n    const selfActionsHooks = childScroll.scroller.actions.hooks\n    selfActionsHooks.trigger(selfActionsHooks.eventTypes.detectMovingDirection)\n\n    expect(childScroll.disable).toBeCalled()\n    expect(parentScroll.enable).toBeCalled()\n\n    // horizontal\n\n    const parentScrollH = new BScroll(parentWrapper, {\n      nestedScroll: {\n        groupId: 'horizontal-bounce-effect',\n      },\n    })\n    const childScrollH = new BScroll(childWrapper, {\n      nestedScroll: {\n        groupId: 'horizontal-bounce-effect',\n      },\n    })\n\n    addProperties(childScrollH, {\n      hasVerticalScroll: false,\n      hasHorizontalScroll: true,\n    })\n\n    new NestedScroll(parentScrollH)\n    new NestedScroll(childScrollH)\n\n    childScrollH.movingDirectionX = -1\n\n    const selfActionsHooksH = childScrollH.scroller.actions.hooks\n    selfActionsHooksH.trigger(\n      selfActionsHooksH.eventTypes.detectMovingDirection\n    )\n\n    expect(childScrollH.disable).toBeCalled()\n    expect(parentScrollH.enable).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/nested-scroll/src/__tests__"
        },
        {
            "name": "observe without MutationObserver",
            "suites": [
                "observe dom"
            ],
            "updatePoint": {
                "line": 67,
                "column": 38
            },
            "line": 67,
            "code": "  it('observe without MutationObserver', () => {\n    // set MutationObserver to undefined\n    Object.defineProperty(window, 'MutationObserver', {\n      get: function () {\n        return undefined\n      },\n    })\n\n    observeDOM = new ObserveDOM(scroll)\n\n    expect(observeDOM.observer).toBeFalsy()\n\n    mockDomOffset(scroll.scroller.content as CustomHTMLDivElement, {\n      width: 400,\n    })\n    jest.advanceTimersByTime(1000)\n    expect(scroll.refresh).toBeCalled()\n\n    // destroy\n    scroll.hooks.trigger('destroy')\n    mockDomOffset(scroll.scroller.content as CustomHTMLDivElement, {\n      width: 500,\n    })\n    jest.advanceTimersByTime(1000)\n    expect(scroll.refresh).toHaveBeenCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/observe-dom/src/__tests__"
        },
        {
            "name": "observe with MutationObserver",
            "suites": [
                "observe dom"
            ],
            "updatePoint": {
                "line": 94,
                "column": 35
            },
            "line": 94,
            "code": "  it('observe with MutationObserver', () => {\n    expect(scroll.hooks.events.enable.length).toBe(1)\n    expect(scroll.hooks.events.disable.length).toBe(1)\n    expect(scroll.hooks.events.destroy.length).toBe(1)\n    expect(mockObserve).toHaveBeenCalledWith(scroll.scroller.content, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n    })\n\n    // init can't be call again when it is observing\n    const init = jest.spyOn(observeDOM, 'init')\n    scroll.hooks.trigger(scroll.hooks.eventTypes.enabled)\n    expect(init).not.toHaveBeenCalled()\n    init.mockReset()\n\n    addProperties(scroll.scroller.scrollBehaviorX, {\n      currentPos: -12,\n      minScrollPos: 0,\n      maxScrollPos: -100,\n    })\n\n    addProperties(scroll.scroller.scrollBehaviorY, {\n      currentPos: -12,\n      minScrollPos: 0,\n      maxScrollPos: -100,\n    })\n\n    addProperties(scroll.scroller.animater, {\n      pending: false,\n    })\n\n    triggerMutation(\n      [\n        {\n          type: 'test',\n        },\n      ],\n      300\n    )\n    expect(scroll.refresh).toBeCalledTimes(1)\n\n    // attributes change & target is scroller.content\n    triggerMutation(\n      [\n        {\n          type: 'attributes',\n          target: scroll.scroller.content,\n        },\n      ],\n      300\n    )\n    expect(scroll.refresh).toBeCalledTimes(1)\n\n    // attributes change & target is not scroller.content\n    triggerMutation(\n      [\n        {\n          type: 'attributes',\n          target: '',\n        },\n      ],\n      300\n    )\n    expect(scroll.refresh).toBeCalledTimes(1)\n    jest.advanceTimersByTime(61)\n    expect(scroll.refresh).toBeCalledTimes(2)\n\n    // pedding\n    addProperties(scroll.scroller.animater, {\n      pending: true,\n    })\n    triggerMutation(\n      [\n        {\n          type: 'test',\n        },\n      ],\n      300\n    )\n    expect(scroll.refresh).toBeCalledTimes(2)\n\n    // out of boundary\n    addProperties(scroll.scroller.scrollBehaviorY, {\n      currentPos: -12,\n      minScrollPos: 0,\n      maxScrollPos: -10,\n    })\n    triggerMutation(\n      [\n        {\n          type: 'test',\n        },\n      ],\n      300\n    )\n    expect(scroll.refresh).toBeCalledTimes(2)\n\n    // destroy\n    scroll.hooks.trigger(scroll.hooks.eventTypes.destroy)\n    expect(mockDisconnect).toBeCalled()\n    expect(scroll.hooks.events.enable.length).toBe(0)\n    expect(scroll.hooks.events.disable.length).toBe(0)\n    expect(scroll.hooks.events.destroy.length).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/observe-dom/src/__tests__"
        },
        {
            "name": "enable/disable",
            "suites": [
                "observe dom"
            ],
            "updatePoint": {
                "line": 200,
                "column": 20
            },
            "line": 200,
            "code": "  it('enable/disable', () => {\n    scroll.hooks.trigger(scroll.hooks.eventTypes.disable)\n    expect(mockDisconnect).toBeCalled()\n\n    scroll.hooks.trigger(scroll.hooks.eventTypes.enable)\n    expect(mockObserve).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/observe-dom/src/__tests__"
        },
        {
            "name": "should capture image load or error event",
            "suites": [
                "observe image"
            ],
            "updatePoint": {
                "line": 33,
                "column": 46
            },
            "line": 33,
            "code": "  it('should capture image load or error event', () => {\n    let img = document.createElement('img')\n    let loadEvent = createEvent('Event', 'load')\n    content.appendChild(img)\n    img.dispatchEvent(loadEvent)\n    jest.advanceTimersByTime(151)\n    expect(scroll.refresh).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/observe-image/src/__tests__"
        },
        {
            "name": "should trigger bs.refresh in a tick when debounceTime is 0",
            "suites": [
                "observe image"
            ],
            "updatePoint": {
                "line": 42,
                "column": 64
            },
            "line": 42,
            "code": "  it('should trigger bs.refresh in a tick when debounceTime is 0', () => {\n    observeImage.options.debounceTime = 0\n    let img = document.createElement('img')\n    let loadEvent = createEvent('Event', 'load')\n    content.appendChild(img)\n    img.dispatchEvent(loadEvent)\n    expect(scroll.refresh).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/observe-image/src/__tests__"
        },
        {
            "name": "should proxy properties to BScroll instance",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 29,
                "column": 49
            },
            "line": 29,
            "code": "  it('should proxy properties to BScroll instance', () => {\n    new PullDown(scroll)\n\n    expect(scroll.proxy).toBeCalledWith([\n      {\n        key: 'finishPullDown',\n        sourceKey: 'plugins.pullDownRefresh.finishPullDown',\n      },\n      {\n        key: 'openPullDown',\n        sourceKey: 'plugins.pullDownRefresh.openPullDown',\n      },\n      {\n        key: 'closePullDown',\n        sourceKey: 'plugins.pullDownRefresh.closePullDown',\n      },\n      {\n        key: 'autoPullDownRefresh',\n        sourceKey: 'plugins.pullDownRefresh.autoPullDownRefresh',\n      },\n    ])\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should handle default options and user options",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 52,
                "column": 52
            },
            "line": 52,
            "code": "  it('should handle default options and user options', () => {\n    // case 1\n    scroll.options.pullDownRefresh = true\n    pullDown = new PullDown(scroll)\n\n    expect(pullDown.options).toMatchObject({\n      threshold: 90,\n      stop: 40,\n    })\n\n    // case 2\n    scroll.options.pullDownRefresh = {\n      threshold: 100,\n      stop: 50,\n    }\n    pullDown = new PullDown(scroll)\n\n    expect(pullDown.options).toMatchObject({\n      threshold: 100,\n      stop: 50,\n    })\n\n    expect(scroll.options.probeType).toBe(Probe.Realtime)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should cache originalMinScrollY",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 77,
                "column": 37
            },
            "line": 77,
            "code": "  it('should cache originalMinScrollY', () => {\n    expect(pullDown.cachedOriginanMinScrollY).toBe(0)\n    expect(pullDown.currentMinScrollY).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should modify minScrollY when necessary",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 82,
                "column": 45
            },
            "line": 82,
            "code": "  it('should modify minScrollY when necessary', () => {\n    pullDown.currentMinScrollY = 50\n    const scrollBehaviorY = scroll.scroller.scrollBehaviorY\n    let boundary = {\n      minScrollPos: 0,\n      maxScrollPos: 20,\n    }\n    scrollBehaviorY.hooks.trigger(\n      scrollBehaviorY.hooks.eventTypes.computeBoundary,\n      boundary\n    )\n    expect(boundary).toMatchObject({\n      minScrollPos: 50,\n      maxScrollPos: -1,\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should checkPullDown",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 99,
                "column": 26
            },
            "line": 99,
            "code": "  it('should checkPullDown', () => {\n    const mockFn = jest.fn()\n    scroll.on(scroll.eventTypes.pullingDown, mockFn)\n\n    scroll.trigger(scroll.eventTypes.scrollStart)\n    // simulate pullUp action\n    scroll.y = -100\n    scroll.scroller.hooks.trigger(scroll.scroller.hooks.eventTypes.end)\n    expect(mockFn).toHaveBeenCalledTimes(0)\n\n    // simulate pullDown action\n    scroll.y = 100\n\n    scroll.scroller.hooks.trigger(scroll.scroller.hooks.eventTypes.end)\n    expect(mockFn).toHaveBeenCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should checkLocationOfThresholdBoundary",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 116,
                "column": 45
            },
            "line": 116,
            "code": "  it('should checkLocationOfThresholdBoundary', () => {\n    const enterThresholdFn = jest.fn()\n    const leaveThresholdFn = jest.fn()\n    scroll.on(scroll.eventTypes.enterThreshold, enterThresholdFn)\n    scroll.on(scroll.eventTypes.leaveThreshold, leaveThresholdFn)\n    scroll.trigger(scroll.eventTypes.scrollStart)\n\n    // enter threshold boundary\n    scroll.y = 20\n    scroll.trigger(scroll.eventTypes.scroll)\n\n    // leave threshold boundary\n    scroll.y = 100\n    scroll.trigger(scroll.eventTypes.scroll)\n\n    expect(enterThresholdFn).toHaveBeenCalledTimes(1)\n    expect(leaveThresholdFn).toHaveBeenCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should trigger pullingDown once",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 135,
                "column": 37
            },
            "line": 135,
            "code": "  it('should trigger pullingDown once', () => {\n    const mockFn = jest.fn()\n    scroll.on(scroll.eventTypes.pullingDown, mockFn)\n    // when\n    scroll.y = 100\n    scroll.trigger(scroll.eventTypes.scrollStart)\n    scroll.scroller.hooks.trigger('end')\n    scroll.scroller.hooks.trigger('end')\n    // then\n    expect(mockFn).toBeCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should stop at correct position",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 147,
                "column": 37
            },
            "line": 147,
            "code": "  it('should stop at correct position', () => {\n    // when\n    scroll.y = 100\n    scroll.scroller.hooks.trigger('end')\n    expect(scroll.scrollTo).toHaveBeenCalledWith(\n      0,\n      40,\n      scroll.options.bounceTime,\n      ease.bounce\n    )\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should work well when call finishPullDown()",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 159,
                "column": 49
            },
            "line": 159,
            "code": "  it('should work well when call finishPullDown()', () => {\n    pullDown.pulling = 2\n    pullDown.finishPullDown()\n\n    expect(pullDown.pulling).toBe(0)\n    expect(scroll.scroller.scrollBehaviorY.computeBoundary).toBeCalled()\n    expect(scroll.resetPosition).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should work well when call closePullDown()",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 168,
                "column": 48
            },
            "line": 168,
            "code": "  it('should work well when call closePullDown()', () => {\n    pullDown.closePullDown()\n\n    expect(pullDown.watching).toBe(false)\n    expect(scroll.scroller.hooks.events.end.length).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should work well when call openPullDown()",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 175,
                "column": 47
            },
            "line": 175,
            "code": "  it('should work well when call openPullDown()', () => {\n    pullDown.closePullDown()\n\n    expect(pullDown.watching).toBe(false)\n    expect(pullDown.options).toMatchObject({\n      threshold: 90,\n      stop: 40,\n    })\n\n    // modify options\n    pullDown.openPullDown({\n      threshold: 200,\n      stop: 80,\n    })\n\n    expect(pullDown.options).toMatchObject({\n      threshold: 200,\n      stop: 80,\n    })\n    expect(pullDown.watching).toBe(true)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should work well when call autoPullDownRefresh()",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 197,
                "column": 54
            },
            "line": 197,
            "code": "  it('should work well when call autoPullDownRefresh()', () => {\n    const mockFn = jest.fn()\n    scroll.on(scroll.eventTypes.pullingDown, mockFn)\n    pullDown.autoPullDownRefresh()\n    expect(pullDown.watching).toBe(true)\n    expect(pullDown.currentMinScrollY).toBe(40)\n    expect(scroll.scroller.scrollBehaviorY.computeBoundary).toBeCalled()\n    expect(scroll.scrollTo).toHaveBeenCalledTimes(2)\n    expect(scroll.scrollTo).toHaveBeenLastCalledWith(\n      0,\n      40,\n      scroll.options.bounceTime,\n      ease.bounce\n    )\n\n    // closePullDown, and autoPullDownRefresh will not work\n    pullDown.closePullDown()\n    pullDown.autoPullDownRefresh()\n    expect(scroll.scrollTo).toBeCalledTimes(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should call finishPullDown when content DOM changed",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 218,
                "column": 57
            },
            "line": 218,
            "code": "  it('should call finishPullDown when content DOM changed', () => {\n    // simulate pullDown action\n    pullDown.pulling = 2\n\n    scroll.hooks.trigger(scroll.hooks.eventTypes.contentChanged)\n    expect(scroll.scroller.scrollBehaviorY.computeBoundary).toBeCalled()\n    expect(scroll.resetPosition).toBeCalledWith(800, ease.bounce)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should work well when integrating with mousewheel",
            "suites": [
                "pull down tests"
            ],
            "updatePoint": {
                "line": 227,
                "column": 55
            },
            "line": 227,
            "code": "  it('should work well when integrating with mousewheel', () => {\n    const options = {} as any\n    scroll.trigger(scroll.eventTypes.alterOptions, options)\n\n    expect(options.discreteTime).toBe(300)\n    expect(options.easeTime).toBe(350)\n\n    const mockFn = jest.fn()\n    scroll.scroller.hooks.on(scroll.scroller.hooks.eventTypes.end, mockFn)\n\n    scroll.trigger(scroll.eventTypes.mousewheelEnd)\n    expect(mockFn).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-down/src/__tests__"
        },
        {
            "name": "should proxy properties to scroll instance",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 29,
                "column": 48
            },
            "line": 29,
            "code": "  it('should proxy properties to scroll instance', () => {\n    expect(scroll.proxy).toBeCalledWith([\n      {\n        key: 'finishPullUp',\n        sourceKey: 'plugins.pullUpLoad.finishPullUp',\n      },\n      {\n        key: 'openPullUp',\n        sourceKey: 'plugins.pullUpLoad.openPullUp',\n      },\n      {\n        key: 'closePullUp',\n        sourceKey: 'plugins.pullUpLoad.closePullUp',\n      },\n      {\n        key: 'autoPullUpLoad',\n        sourceKey: 'plugins.pullUpLoad.autoPullUpLoad',\n      },\n    ])\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should handle default options and user options",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 50,
                "column": 52
            },
            "line": 50,
            "code": "  it('should handle default options and user options', () => {\n    // case 1\n    scroll.options.pullUpLoad = true\n    pullUp = new PullUp(scroll)\n\n    expect(pullUp.options).toMatchObject({\n      threshold: 0,\n    })\n\n    // case 2\n    scroll.options.pullUpLoad = {\n      threshold: 40,\n    }\n    pullUp = new PullUp(scroll)\n\n    expect(pullUp.options).toMatchObject({\n      threshold: 40,\n    })\n\n    // case 3\n    scroll.options.pullUpLoad = {\n      threshold: -40,\n    }\n    pullUp = new PullUp(scroll)\n\n    expect(pullUp.options).toMatchObject({\n      threshold: -40,\n    })\n\n    expect(scroll.options.probeType).toBe(Probe.Realtime)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should modify maxScrollY when content is full of wrapper",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 82,
                "column": 62
            },
            "line": 82,
            "code": "  it('should modify maxScrollY when content is full of wrapper', () => {\n    const scrollBehaviorY = scroll.scroller.scrollBehaviorY\n    let boundary = {\n      minScrollPos: 0,\n      maxScrollPos: 20,\n    }\n    scrollBehaviorY.hooks.trigger(\n      scrollBehaviorY.hooks.eventTypes.computeBoundary,\n      boundary\n    )\n    expect(boundary).toMatchObject({\n      minScrollPos: 0,\n      maxScrollPos: -1,\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should checkPullUp",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 98,
                "column": 24
            },
            "line": 98,
            "code": "  it('should checkPullUp', () => {\n    const mockFn = jest.fn()\n    scroll.on(scroll.eventTypes.pullingUp, mockFn)\n\n    const pos1 = {\n      x: 0,\n      y: 100,\n    }\n    // simulate pullDown action\n    scroll.movingDirectionY = -1\n\n    scroll.trigger(scroll.eventTypes.scroll, pos1)\n    expect(mockFn).toHaveBeenCalledTimes(0)\n\n    // simulate pullUp action\n    const pos2 = {\n      x: 0,\n      y: -100,\n    }\n    scroll.movingDirectionY = 1\n    scroll.trigger(scroll.eventTypes.scroll, pos2)\n    expect(mockFn).toHaveBeenCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should trigger pullingUp once",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 122,
                "column": 35
            },
            "line": 122,
            "code": "  it('should trigger pullingUp once', () => {\n    const mockFn = jest.fn()\n    const pos = {\n      x: 0,\n      y: -100,\n    }\n    scroll.on(scroll.eventTypes.pullingUp, mockFn)\n    // when\n    scroll.movingDirectionY = 1\n    scroll.trigger(scroll.eventTypes.scroll, pos)\n    scroll.trigger(scroll.eventTypes.scroll, pos)\n    // then\n    expect(mockFn).toBeCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should work well when call finishPullUp()",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 137,
                "column": 47
            },
            "line": 137,
            "code": "  it('should work well when call finishPullUp()', () => {\n    // simulate pullUp action\n    const pos = {\n      x: 0,\n      y: -100,\n    }\n    scroll.movingDirectionY = 1\n    scroll.trigger(scroll.eventTypes.scroll, pos)\n\n    pullUp.finishPullUp()\n\n    expect(scroll.scroller.scrollBehaviorY.setMovingDirection).toBeCalledWith(0)\n    expect(scroll.events.scrollEnd.length).toBe(2)\n    expect(pullUp.watching).toBe(false)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should work well when call closePullUp()",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 153,
                "column": 46
            },
            "line": 153,
            "code": "  it('should work well when call closePullUp()', () => {\n    pullUp.closePullUp()\n\n    expect(pullUp.watching).toBe(false)\n    expect(scroll.events.scroll.length).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should work well when call openPullUp()",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 160,
                "column": 45
            },
            "line": 160,
            "code": "  it('should work well when call openPullUp()', () => {\n    pullUp.closePullUp()\n\n    expect(pullUp.watching).toBe(false)\n    expect(pullUp.options).toMatchObject({\n      threshold: 0,\n    })\n\n    // modify options\n    pullUp.openPullUp({\n      threshold: 200,\n    })\n\n    expect(pullUp.options).toMatchObject({\n      threshold: 200,\n    })\n    expect(pullUp.watching).toBe(true)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should reset pulling when scrollEnd triggered",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 179,
                "column": 51
            },
            "line": 179,
            "code": "  it('should reset pulling when scrollEnd triggered', () => {\n    // simulate pullUp action\n    const pos = {\n      x: 0,\n      y: -100,\n    }\n    scroll.movingDirectionY = 1\n    scroll.trigger(scroll.eventTypes.scroll, pos)\n\n    expect(pullUp.pulling).toBe(true)\n\n    scroll.trigger(scroll.eventTypes.scrollEnd)\n\n    expect(pullUp.pulling).toBe(false)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should call watch() in scrollEnd hooks when pullingUp",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 195,
                "column": 59
            },
            "line": 195,
            "code": "  it('should call watch() in scrollEnd hooks when pullingUp', () => {\n    const pullUpMockFn = jest.fn()\n    // simulate pullUp action\n    const pos = {\n      x: 0,\n      y: -100,\n    }\n    scroll.on(scroll.eventTypes.pullingUp, pullUpMockFn)\n    scroll.movingDirectionY = 1\n    scroll.trigger(scroll.eventTypes.scroll, pos)\n\n    expect(pullUpMockFn).toBeCalledTimes(1)\n    expect(pullUp.pulling).toBe(true)\n\n    pullUp.finishPullUp()\n    // because pulling is true, won't trigger pullingUp\n    scroll.trigger(scroll.eventTypes.scroll, pos)\n    expect(pullUpMockFn).toBeCalledTimes(1)\n    expect(pullUp.watching).toBe(false)\n\n    // register another watch in scrollEnd\n    scroll.trigger(scroll.eventTypes.scrollEnd)\n\n    scroll.movingDirectionY = 1\n    scroll.trigger(scroll.eventTypes.scroll, pos)\n    expect(pullUpMockFn).toBeCalledTimes(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should work well when call autoPullUpLoad()",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 223,
                "column": 49
            },
            "line": 223,
            "code": "  it('should work well when call autoPullUpLoad()', () => {\n    pullUp.autoPullUpLoad()\n\n    const outOfBoundaryPos = -1\n    expect(scroll.scroller.scrollBehaviorY.setMovingDirection).toBeCalledWith(\n      -1\n    )\n    expect(scroll.scrollTo).toBeCalledWith(0, outOfBoundaryPos, 800)\n    expect(scroll.scrollTo).toBeCalledTimes(1)\n\n    // closePullUp, and autoPullUpLoad will not work\n    pullUp.closePullUp()\n    pullUp.autoPullUpLoad()\n    expect(scroll.scrollTo).toBeCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "should call finishPullUp when content DOM changed",
            "suites": [
                "pullUp plugins"
            ],
            "updatePoint": {
                "line": 239,
                "column": 55
            },
            "line": 239,
            "code": "  it('should call finishPullUp when content DOM changed', () => {\n    scroll.hooks.trigger(scroll.hooks.eventTypes.contentChanged)\n    expect(scroll.scroller.scrollBehaviorY.setMovingDirection).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/pull-up/src/__tests__"
        },
        {
            "name": "touchStart | touchMove | touchEnd hooks",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 57,
                "column": 45
            },
            "line": 57,
            "code": "  it('touchStart | touchMove | touchEnd hooks', () => {\n    const eventHandler = new EventHandler(indicator, EventHandlerOptions)\n    expect(Object.keys(eventHandler.hooks.eventTypes)).toMatchObject([\n      'touchStart',\n      'touchMove',\n      'touchEnd',\n    ])\n\n    const touchStartMockFn = jest.fn()\n    const touchMoveMockFn = jest.fn()\n    const touchEndMockFn = jest.fn()\n    const eventHandlerHooks = eventHandler.hooks\n    eventHandlerHooks.on(\n      eventHandlerHooks.eventTypes.touchStart,\n      touchStartMockFn\n    )\n    eventHandlerHooks.on(\n      eventHandlerHooks.eventTypes.touchMove,\n      touchMoveMockFn\n    )\n    eventHandlerHooks.on(eventHandlerHooks.eventTypes.touchEnd, touchEndMockFn)\n\n    // scroll is disabled\n    addProperties(scroll, {\n      enabled: false,\n    })\n    dispatchTouchStart(indicatorEl, [\n      {\n        pageX: 0,\n        pageY: 0,\n      },\n    ])\n    dispatchTouchMove(window, [\n      {\n        pageX: 10,\n        pageY: 10,\n      },\n    ])\n    dispatchTouchEnd(window, [\n      {\n        pageX: 20,\n        pageY: 20,\n      },\n    ])\n    expect(touchStartMockFn).not.toBeCalled()\n    expect(touchMoveMockFn).not.toBeCalled()\n    expect(touchEndMockFn).not.toBeCalled()\n\n    // scroll is enabled\n    addProperties(scroll, {\n      enabled: true,\n    })\n    dispatchTouchStart(indicatorEl, [\n      {\n        pageX: 0,\n        pageY: 0,\n      },\n    ])\n    dispatchTouchMove(window, [\n      {\n        pageX: 10,\n        pageY: 10,\n      },\n    ])\n    dispatchTouchEnd(window, [\n      {\n        pageX: 20,\n        pageY: 20,\n      },\n    ])\n    expect(touchStartMockFn).toBeCalled()\n    expect(touchMoveMockFn).toBeCalled()\n    expect(touchEndMockFn).toBeCalled()\n  })",
            "file": "event-handler.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "destroy",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 132,
                "column": 13
            },
            "line": 132,
            "code": "  it('destroy', () => {\n    const eventHandler = new EventHandler(indicator, EventHandlerOptions)\n    eventHandler.destroy()\n  })",
            "file": "event-handler.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "should create indicator elements",
            "suites": [
                "scroll-bar unit tests",
                "constructor"
            ],
            "updatePoint": {
                "line": 42,
                "column": 40
            },
            "line": 42,
            "code": "    it('should create indicator elements', () => {\n      const scrollbar = new ScrollBar(scroll)\n      // then\n      expect(scroll.wrapper).toMatchSnapshot()\n      expect(scrollbar.options).toMatchObject({\n        fade: true,\n        interactive: false,\n        customElements: [],\n        minSize: 8,\n        scrollbarTrackClickable: false,\n        scrollbarTrackOffsetType: 'step',\n        scrollbarTrackOffsetTime: 300,\n      })\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "custom scrollbar",
            "suites": [
                "scroll-bar unit tests",
                "constructor"
            ],
            "updatePoint": {
                "line": 57,
                "column": 24
            },
            "line": 57,
            "code": "    it('custom scrollbar', () => {\n      const customHScrollbar = document.createElement('div')\n      addProperties(scroll.options, {\n        scrollX: true,\n        scrollY: false,\n        scrollbar: {\n          customElements: [customHScrollbar],\n        },\n      })\n      const scrollbar = new ScrollBar(scroll)\n      expect(scrollbar.indicators[0].wrapper).toBe(customHScrollbar)\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "destroy hook",
            "suites": [
                "scroll-bar unit tests",
                "constructor"
            ],
            "updatePoint": {
                "line": 70,
                "column": 20
            },
            "line": 70,
            "code": "    it('destroy hook', () => {\n      const scrollbar = new ScrollBar(scroll)\n      scroll.hooks.trigger(scroll.hooks.eventTypes.destroy)\n      for (let indicator of scrollbar.indicators) {\n        expect(indicator.destroy).toBeCalled()\n      }\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "should have corrent key",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 51,
                "column": 29
            },
            "line": 51,
            "code": "  it('should have corrent key', () => {\n    indicator = new Indicator(scroll, indicatorOptions)\n    expect(indicator.keysMap).toMatchObject({\n      hasScroll: 'hasVerticalScroll',\n      size: 'height',\n      wrapperSize: 'clientHeight',\n      scrollerSize: 'scrollerHeight',\n      maxScrollPos: 'maxScrollY',\n      pos: 'y',\n      point: 'pageY',\n      translateProperty: 'translateY',\n      domRect: 'top',\n    })\n    expect(wrapper.style.opacity).toEqual('0')\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "refresh hook",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 67,
                "column": 18
            },
            "line": 67,
            "code": "  it('refresh hook', () => {\n    Object.assign(indicatorOptions, {\n      direction: IndicatorDirection.Horizontal,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    addProperties(scroll, {\n      hasHorizontalScroll: true,\n      maxScrollX: 8,\n    })\n    scroll.hooks.trigger(scroll.hooks.eventTypes.refresh)\n    expect(indicator.currentPos).toBe(-8)\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "translate hook",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 80,
                "column": 20
            },
            "line": 80,
            "code": "  it('translate hook', () => {\n    Object.assign(indicatorOptions, {\n      direction: IndicatorDirection.Horizontal,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    addProperties(scroll, {\n      hasHorizontalScroll: true,\n      maxScrollX: 8,\n    })\n    const translaterHooks = scroll.scroller.translater.hooks\n    scroll.hooks.trigger(scroll.hooks.eventTypes.refresh)\n    translaterHooks.trigger(translaterHooks.eventTypes.translate, {\n      x: 10,\n      y: 0,\n    })\n    expect(indicator.currentPos).toBe(0)\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "transitionTime and transitionTimingFunction hook",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 98,
                "column": 54
            },
            "line": 98,
            "code": "  it('transitionTime and transitionTimingFunction hook', () => {\n    Object.assign(indicatorOptions, {\n      direction: IndicatorDirection.Horizontal,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    const animaterHooks = scroll.scroller.animater.hooks\n    animaterHooks.trigger(animaterHooks.eventTypes.time)\n    animaterHooks.trigger(\n      animaterHooks.eventTypes.timeFunction,\n      'cubic-bezier(0.23, 1, 0.32, 1)'\n    )\n    expect(indicator.indicatorEl.style.transitionDuration).toBe('0ms')\n    expect(indicator.indicatorEl.style.transitionTimingFunction).toBe(\n      'cubic-bezier(0.23, 1, 0.32, 1)'\n    )\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "about scrolling's hook",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 115,
                "column": 28
            },
            "line": 115,
            "code": "  it(\"about scrolling's hook\", () => {\n    Object.assign(indicatorOptions, {\n      direction: IndicatorDirection.Horizontal,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    scroll.trigger(scroll.eventTypes.scrollStart)\n    expect(indicator.wrapper.style.opacity).toBe('1')\n    scroll.trigger(scroll.eventTypes.scrollEnd)\n    expect(indicator.wrapper.style.opacity).toBe('0')\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "about mouse-wheel scrolling's hook",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 126,
                "column": 40
            },
            "line": 126,
            "code": "  it(\"about mouse-wheel scrolling's hook\", () => {\n    Object.assign(indicatorOptions, {\n      direction: IndicatorDirection.Horizontal,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    scroll.registerType(['mousewheelStart', 'mousewheelMove', 'mousewheelEnd'])\n    scroll.trigger(scroll.eventTypes.mousewheelStart)\n    expect(indicator.wrapper.style.opacity).toBe('1')\n    scroll.trigger(scroll.eventTypes.mousewheelEnd)\n    expect(indicator.wrapper.style.opacity).toBe('0')\n    scroll.trigger(scroll.eventTypes.mousewheelMove)\n    expect(indicator.wrapper.style.opacity).toBe('1')\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "interactive option",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 140,
                "column": 24
            },
            "line": 140,
            "code": "  it('interactive option', () => {\n    // horizontal\n    addProperties(scroll.options, {\n      probeType: 3,\n    })\n    addProperties(scroll, {\n      hasHorizontalScroll: true,\n      maxScrollX: 8,\n    })\n    Object.assign(indicatorOptions, {\n      direction: IndicatorDirection.Horizontal,\n      interactive: true,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    indicator.refresh()\n    const beforeStartMockFn = jest.fn()\n    const startMockFn = jest.fn()\n    const moveMockFn = jest.fn()\n    const endMockFn = jest.fn()\n    const scroller = scroll.scroller\n    scroller.hooks.on(\n      scroller.hooks.eventTypes.beforeScrollStart,\n      beforeStartMockFn\n    )\n    scroller.hooks.on(scroller.hooks.eventTypes.scrollStart, startMockFn)\n    scroller.hooks.on(scroller.hooks.eventTypes.scroll, moveMockFn)\n    scroller.hooks.on(scroller.hooks.eventTypes.scrollEnd, endMockFn)\n\n    const eventHandlerHooks = indicator.eventHandler.hooks\n    indicator.scrollInfo.maxScrollPos = 10\n    eventHandlerHooks.trigger(eventHandlerHooks.eventTypes.touchStart)\n    eventHandlerHooks.trigger(eventHandlerHooks.eventTypes.touchMove, 2)\n    eventHandlerHooks.trigger(eventHandlerHooks.eventTypes.touchEnd)\n    expect(beforeStartMockFn).toBeCalled()\n    expect(startMockFn).toBeCalled()\n    expect(moveMockFn).toBeCalled()\n    expect(endMockFn).toBeCalled()\n    expect(scroll.scroller.translater.translate).toBeCalled()\n\n    // vertical\n    addProperties(scroll.options, {\n      probeType: 1,\n    })\n    addProperties(scroll, {\n      hasHorizontalScroll: false,\n      hasVerticalScroll: true,\n      maxScrollX: 0,\n      maxScrollY: 8,\n    })\n    addProperties(indicator, {\n      direction: IndicatorDirection.Vertical,\n    })\n\n    eventHandlerHooks.trigger(eventHandlerHooks.eventTypes.touchStart)\n    indicator.startTime = indicator.startTime - 400\n    indicator.scrollInfo.maxScrollPos = 10\n    eventHandlerHooks.trigger(eventHandlerHooks.eventTypes.touchMove, 2)\n    eventHandlerHooks.trigger(eventHandlerHooks.eventTypes.touchEnd)\n\n    expect(beforeStartMockFn).toBeCalledTimes(2)\n    expect(startMockFn).toBeCalledTimes(2)\n    expect(moveMockFn).toBeCalledTimes(2)\n    expect(endMockFn).toBeCalledTimes(2)\n    expect(scroll.scroller.translater.translate).toBeCalledTimes(2)\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "updatePosition",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 206,
                "column": 20
            },
            "line": 206,
            "code": "  it('updatePosition', () => {\n    addProperties(scroll, {\n      maxScrollY: -8,\n    })\n    addProperties(indicatorOptions, {\n      direction: IndicatorDirection.Vertical,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    indicator.refresh()\n    indicator.updatePosition({\n      x: 0,\n      y: -2,\n    })\n    expect(indicator.currentPos).toBe(0)\n\n    addProperties(scroll, {\n      maxScrollY: 8,\n    })\n    addProperties(indicator.options, {\n      isCustom: true,\n    })\n    indicator.refresh()\n    indicator.updatePosition({\n      x: 0,\n      y: 2,\n    })\n    expect(indicator.currentPos).toBe(0)\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "click",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 235,
                "column": 11
            },
            "line": 235,
            "code": "  it('click', () => {\n    addProperties(scroll, {\n      maxScrollY: -8,\n    })\n    addProperties(indicatorOptions, {\n      direction: IndicatorDirection.Vertical,\n      scrollbarTrackClickable: true,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    indicator.refresh()\n    dispatchClick(indicator.wrapper, 'click')\n    expect(scroll.scrollTo).toBeCalled()\n\n    addProperties(indicator, {\n      direction: IndicatorDirection.Horizontal,\n    })\n    addProperties(indicator.options, {\n      scrollbarTrackClickable: true,\n      scrollbarTrackOffsetType: OffsetType.Point,\n    })\n    dispatchClick(indicator.wrapper, 'click')\n    expect(scroll.scrollTo).toBeCalled()\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "destroy",
            "suites": [
                "scroll-bar indicator tests"
            ],
            "updatePoint": {
                "line": 259,
                "column": 13
            },
            "line": 259,
            "code": "  it('destroy', () => {\n    const parentNode = document.createElement('div')\n    parentNode.appendChild(wrapper)\n    addProperties(indicatorOptions, {\n      direction: IndicatorDirection.Vertical,\n      scrollbarTrackClickable: true,\n      isCustom: false,\n    })\n    indicator = new Indicator(scroll, indicatorOptions)\n    indicator.destroy()\n    expect(indicator.eventHandler.destroy).toBeCalled()\n    expect(indicator.hooksFn.length).toBe(0)\n  })",
            "file": "indicator.spec.ts",
            "skipped": false,
            "dir": "packages/scroll-bar/src/__tests__"
        },
        {
            "name": "should work well when call warn()",
            "suites": [
                "debug"
            ],
            "updatePoint": {
                "line": 4,
                "column": 39
            },
            "line": 4,
            "code": "  it('should work well when call warn()', () => {\n    const spyFn = jest.spyOn(console, 'error')\n    warn('Error occured')\n\n    expect(spyFn).toBeCalledWith('[BScroll warn]: Error occured')\n  })",
            "file": "debug.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should work well when call assert()",
            "suites": [
                "debug"
            ],
            "updatePoint": {
                "line": 11,
                "column": 41
            },
            "line": 11,
            "code": "  it('should work well when call assert()', () => {\n    const a = 1 + Math.random()\n    const b = 2\n    expect(() => {\n      assert(a > b, '')\n    }).toThrow()\n  })",
            "file": "debug.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "prepend",
            "suites": [
                "dom"
            ],
            "updatePoint": {
                "line": 12,
                "column": 13
            },
            "line": 12,
            "code": "  it('prepend', () => {\n    // append operation\n    const target1 = document.createElement('div')\n    const el1 = document.createElement('p')\n    prepend(el1, target1)\n\n    expect(target1.children[0]).toBe(el1)\n\n    // prepend operation\n    const target2 = document.createElement('div')\n    const child = document.createElement('div')\n    target2.appendChild(child)\n    const el2 = document.createElement('p')\n    prepend(el2, target2)\n\n    expect(target2.children[0]).toBe(el2)\n    expect(target2.children[1]).toBe(child)\n  })",
            "file": "dom.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "removeChild",
            "suites": [
                "dom"
            ],
            "updatePoint": {
                "line": 31,
                "column": 17
            },
            "line": 31,
            "code": "  it('removeChild', () => {\n    // append operation\n    const target = document.createElement('div')\n    const el = document.createElement('p')\n    prepend(el, target)\n\n    expect(target.children[0]).toBe(el)\n\n    removeChild(target, el)\n    expect(target.children.length).toBe(0)\n  })",
            "file": "dom.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "addClass & removeClass",
            "suites": [
                "dom"
            ],
            "updatePoint": {
                "line": 43,
                "column": 28
            },
            "line": 43,
            "code": "  it('addClass & removeClass', () => {\n    const target = document.createElement('div')\n    addClass(target, 'test')\n    expect(target.className).toBe(' test')\n\n    // same classname\n    addClass(target, 'test')\n\n    addClass(target, 'test2')\n    expect(target.className).toBe(' test test2')\n\n    // exclude unexisted classname\n    removeClass(target, 'biz')\n    expect(target.className).toBe(' test test2')\n\n    removeClass(target, 'test test2')\n    expect(target.className).toBe(' ')\n  })",
            "file": "dom.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "tap & dblclick",
            "suites": [
                "dom"
            ],
            "updatePoint": {
                "line": 62,
                "column": 20
            },
            "line": 62,
            "code": "  it('tap & dblclick', () => {\n    const mockFn1 = jest.fn()\n    const mockFn2 = jest.fn()\n    const target = document.createElement('div')\n    document.body.appendChild(target)\n\n    let e = { target } as any\n    window.addEventListener('tap', mockFn1)\n    window.addEventListener('dblclick', mockFn2)\n    tap(e, 'tap')\n    expect(mockFn1).toBeCalled()\n\n    dblclick(e)\n    expect(mockFn2).toBeCalled()\n  })",
            "file": "dom.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "click ",
            "suites": [
                "dom"
            ],
            "updatePoint": {
                "line": 78,
                "column": 12
            },
            "line": 78,
            "code": "  it('click ', () => {\n    const mockFn1 = jest.fn()\n    const target = document.createElement('div')\n    document.body.appendChild(target)\n\n    let e = { target, type: 'mouseup' } as any\n    window.addEventListener('click', mockFn1)\n    click(e)\n\n    expect(mockFn1).toBeCalled()\n\n    // fallback to createEvent\n    Object.defineProperty(window, 'MouseEvent', {\n      get() {\n        return undefined\n      },\n    })\n    click(Object.assign(e, { type: 'touchend', changedTouches: [{}] }))\n    expect(mockFn1).toBeCalledTimes(2)\n  })",
            "file": "dom.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "swipe fn",
            "suites": [
                "ease"
            ],
            "updatePoint": {
                "line": 4,
                "column": 14
            },
            "line": 4,
            "code": "  it('swipe fn', () => {\n    const handler = ease.swipe.fn\n    const time1 = handler(0.2)\n    const time2 = handler(0.4)\n    const time3 = handler(0.5)\n    const time4 = handler(0.6)\n    const time5 = handler(0.8)\n    const time6 = handler(1)\n\n    expect(time1).toBeCloseTo(0.6723)\n    expect(time2).toBeCloseTo(0.92224)\n    expect(time3).toBeCloseTo(0.96875)\n    expect(time4).toBeCloseTo(0.98976)\n    expect(time5).toBeCloseTo(0.99968)\n    expect(time6).toBeCloseTo(1)\n  })",
            "file": "ease.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "swipeBounce fn",
            "suites": [
                "ease"
            ],
            "updatePoint": {
                "line": 21,
                "column": 20
            },
            "line": 21,
            "code": "  it('swipeBounce fn', () => {\n    const handler = ease.swipeBounce.fn\n    const time1 = handler(0.2)\n    const time2 = handler(0.4)\n    const time3 = handler(0.5)\n    const time4 = handler(0.6)\n    const time5 = handler(0.8)\n    const time6 = handler(1)\n\n    expect(time1).toBeCloseTo(0.36)\n    expect(time2).toBeCloseTo(0.64)\n    expect(time3).toBeCloseTo(0.75)\n    expect(time4).toBeCloseTo(0.84)\n    expect(time5).toBeCloseTo(0.96)\n    expect(time6).toBeCloseTo(1)\n  })",
            "file": "ease.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should register handler successfully",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 14,
                "column": 44
            },
            "line": 14,
            "code": "    it('should register handler successfully', () => {\n      eventEmitter.on('test1', () => {})\n\n      expect(eventEmitter.eventTypes.test1).toBeTruthy()\n      expect(eventEmitter.events.test1).not.toBeUndefined()\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should trigger handler",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 21,
                "column": 30
            },
            "line": 21,
            "code": "    it('should trigger handler', () => {\n      let mockHandler = jest.fn((x) => x + 1)\n      eventEmitter.on('test1', mockHandler)\n      eventEmitter.trigger('test1', 1)\n\n      expect(mockHandler.mock.calls.length).toBe(1)\n      expect(mockHandler.mock.calls[0][0]).toBe(1)\n      expect(mockHandler.mock.results[0].value).toBe(2)\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should trigger handler only once",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 31,
                "column": 40
            },
            "line": 31,
            "code": "    it('should trigger handler only once', () => {\n      let mockHandler = jest.fn((x) => x + 1)\n      eventEmitter.once('test1', mockHandler)\n      eventEmitter.trigger('test1', 1)\n      eventEmitter.trigger('test1', 1)\n\n      expect(mockHandler.mock.calls.length).toBe(1)\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should tear down handler when invoking off()",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 40,
                "column": 52
            },
            "line": 40,
            "code": "    it('should tear down handler when invoking off()', () => {\n      let mockHandler = jest.fn((x) => x + 1)\n      eventEmitter.once('test1', mockHandler)\n      eventEmitter.off('test1', mockHandler)\n\n      expect(eventEmitter.events.test1.length).toBe(0)\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should register eventTypes when invoking registerType()",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 48,
                "column": 63
            },
            "line": 48,
            "code": "    it('should register eventTypes when invoking registerType()', () => {\n      eventEmitter.registerType(['test2'])\n\n      expect(eventEmitter.eventTypes.test2).toBe('test2')\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should warn about unregistered event when invoking off()",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 54,
                "column": 64
            },
            "line": 54,
            "code": "    it('should warn about unregistered event when invoking off()', () => {\n      const spyFn = jest.spyOn(console, 'error')\n      eventEmitter.off('test2')\n\n      expect(spyFn).toBeCalled()\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should keep chainable call when invoking off()",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 61,
                "column": 54
            },
            "line": 61,
            "code": "    it('should keep chainable call when invoking off()', () => {\n      const ret = eventEmitter.off('test1', () => {})\n      const ret2 = eventEmitter.off()\n\n      expect(ret).toBe(eventEmitter)\n      expect(ret2).toBe(eventEmitter)\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should support cancelable callback",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 69,
                "column": 42
            },
            "line": 69,
            "code": "    it('should support cancelable callback', () => {\n      const mockHandler1 = jest.fn().mockImplementation(() => true)\n      const mockHandler2 = jest.fn()\n      eventEmitter.on('test1', mockHandler1)\n      eventEmitter.on('test1', mockHandler2)\n\n      const ret = eventEmitter.trigger('test1')\n      expect(mockHandler1).toBeCalled()\n      expect(mockHandler2).not.toBeCalled()\n      expect(ret).toBe(true)\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should support cancelable once callback",
            "suites": [
                "events",
                "EventEmitter"
            ],
            "updatePoint": {
                "line": 81,
                "column": 47
            },
            "line": 81,
            "code": "    it('should support cancelable once callback', () => {\n      const mockHandler1 = jest.fn()\n      const mockHandler2 = jest.fn().mockImplementation(() => true)\n      const mockHandler3 = jest.fn()\n\n      eventEmitter.on('test1', mockHandler1)\n      eventEmitter.once('test1', mockHandler2)\n      eventEmitter.on('test1', mockHandler3)\n\n      const ret = eventEmitter.trigger('test1')\n\n      expect(mockHandler1).toBeCalled()\n      expect(mockHandler2).toBeCalled()\n      expect(mockHandler3).not.toBeCalled()\n      expect(ret).toBe(true)\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should trigger handler when dispatch touch event",
            "suites": [
                "events",
                "EventRegister"
            ],
            "updatePoint": {
                "line": 118,
                "column": 56
            },
            "line": 118,
            "code": "    it('should trigger handler when dispatch touch event', () => {\n      const evt = document.createEvent('Event')\n      const evtType = 'test'\n      evt.initEvent(evtType, false, false)\n\n      fakeNode.dispatchEvent(evt)\n      expect(mockHandler.mock.calls.length).toBe(1)\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should remove dom events when destroy",
            "suites": [
                "events",
                "EventRegister"
            ],
            "updatePoint": {
                "line": 127,
                "column": 45
            },
            "line": 127,
            "code": "    it('should remove dom events when destroy', () => {\n      eventRegister.destroy()\n      const evt = document.createEvent('Event')\n      const evtType = 'test'\n      evt.initEvent(evtType, false, false)\n\n      fakeNode.dispatchEvent(evt)\n      expect(mockHandler.mock.calls.length).toBe(0)\n    })",
            "file": "events.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "findIndex",
            "suites": [
                "lang"
            ],
            "updatePoint": {
                "line": 4,
                "column": 15
            },
            "line": 4,
            "code": "  it('findIndex', () => {\n    // hide ES6 findIndex\n    // @ts-ignore\n    Array.prototype.findIndex = undefined\n    const array = [1, 2]\n    const ret = findIndex(array, (item) => item % 2 === 0)\n    expect(ret).toBe(1)\n  })",
            "file": "lang.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should proxy property correctly",
            "suites": [
                "propertiesProxy"
            ],
            "updatePoint": {
                "line": 4,
                "column": 37
            },
            "line": 4,
            "code": "  it('should proxy property correctly', () => {\n    let obj = {\n      a: {\n        b: {\n          c: 1,\n        },\n      },\n    } as any\n    propertiesProxy(obj, 'a.b.c', 'c')\n    expect(obj.c).toBe(1)\n    obj.c = 3\n    expect(obj.a.b.c).toBe(3)\n  })",
            "file": "propertiesProxy.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should prevent error when string path is wrong",
            "suites": [
                "propertiesProxy"
            ],
            "updatePoint": {
                "line": 18,
                "column": 52
            },
            "line": 18,
            "code": "  it('should prevent error when string path is wrong', () => {\n    let obj = {\n      a: {\n        b: {\n          d: 1,\n        },\n      },\n    } as any\n    propertiesProxy(obj, 'a.c.d', 'c')\n    expect(obj.c).toBeFalsy()\n    obj.c = 2\n    expect(obj.a.c.d).toBe(2)\n  })",
            "file": "propertiesProxy.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should change context when proxying method",
            "suites": [
                "propertiesProxy"
            ],
            "updatePoint": {
                "line": 32,
                "column": 48
            },
            "line": 32,
            "code": "  it('should change context when proxying method', () => {\n    let obj = {\n      a: {\n        b: {\n          c() {\n            return (this as any).d\n          },\n          d: 1,\n        },\n      },\n    } as any\n    propertiesProxy(obj, 'a.b.c', 'c')\n    expect(obj.c()).toBe(1)\n  })",
            "file": "propertiesProxy.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should fallback setTimeout or clearTimeout",
            "suites": [
                "raf"
            ],
            "updatePoint": {
                "line": 19,
                "column": 48
            },
            "line": 19,
            "code": "  it('should fallback setTimeout or clearTimeout', () => {\n    jest.useFakeTimers()\n    const spySetTimeout = jest.spyOn(window, 'setTimeout')\n    const spyClearTimeout = jest.spyOn(window, 'clearTimeout')\n    const mockFn = jest.fn()\n\n    const timer = requestAnimationFrame(mockFn)\n    jest.advanceTimersByTime(17)\n\n    expect(mockFn).toBeCalled()\n    expect(spySetTimeout).toBeCalled()\n    cancelAnimationFrame(timer)\n    expect(spyClearTimeout).toBeCalled()\n  })",
            "file": "raf.spec.ts",
            "skipped": false,
            "dir": "packages/shared-utils/src/__tests__"
        },
        {
            "name": "should fail when slideContent has no children element",
            "suites": [
                "slide test for SlidePage class"
            ],
            "updatePoint": {
                "line": 37,
                "column": 59
            },
            "line": 37,
            "code": "  it('should fail when slideContent has no children element', () => {\n    const spyFn = jest.spyOn(console, 'error')\n    const { wrapper } = createSlideElements(0)\n    scroll = new BScroll(wrapper, {})\n    slide = new Slide(scroll)\n\n    expect(spyFn).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should proxy hooks to BScroll instance",
            "suites": [
                "slide test for SlidePage class"
            ],
            "updatePoint": {
                "line": 46,
                "column": 44
            },
            "line": 46,
            "code": "  it('should proxy hooks to BScroll instance', () => {\n    expect(scroll.registerType).toHaveBeenCalledWith([\n      'slideWillChange',\n      'slidePageChanged',\n    ])\n\n    expect(scroll.proxy).toHaveBeenLastCalledWith([\n      {\n        key: 'next',\n        sourceKey: 'plugins.slide.next',\n      },\n      {\n        key: 'prev',\n        sourceKey: 'plugins.slide.prev',\n      },\n      {\n        key: 'goToPage',\n        sourceKey: 'plugins.slide.goToPage',\n      },\n      {\n        key: 'getCurrentPage',\n        sourceKey: 'plugins.slide.getCurrentPage',\n      },\n      {\n        key: 'startPlay',\n        sourceKey: 'plugins.slide.startPlay',\n      },\n      {\n        key: 'pausePlay',\n        sourceKey: 'plugins.slide.pausePlay',\n      },\n    ])\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should handle default options and user options",
            "suites": [
                "slide test for SlidePage class"
            ],
            "updatePoint": {
                "line": 80,
                "column": 52
            },
            "line": 80,
            "code": "  it('should handle default options and user options', () => {\n    // case 1\n    scroll.options.slide = true\n    slide = new Slide(scroll)\n\n    expect(slide.options).toMatchObject({\n      loop: true,\n      threshold: 0.1,\n      speed: 400,\n      easing: ease.bounce,\n      listenFlick: true,\n      autoplay: true,\n      interval: 3000,\n    })\n\n    // case 2\n    scroll.options.slide = {\n      loop: false,\n      autoplay: false,\n    }\n    slide = new Slide(scroll)\n\n    expect(slide.options).toMatchObject({\n      loop: false,\n      threshold: 0.1,\n      speed: 400,\n      easing: ease.bounce,\n      listenFlick: true,\n      autoplay: false,\n      interval: 3000,\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should clone the first and last page when loop is true",
            "suites": [
                "slide test for SlidePage class"
            ],
            "updatePoint": {
                "line": 113,
                "column": 60
            },
            "line": 113,
            "code": "  it('should clone the first and last page when loop is true', () => {\n    const content = scroll.scroller.content\n    scroll.scroller.hooks.trigger(\n      scroll.scroller.hooks.eventTypes.beforeRefresh\n    )\n    expect(content.children.length).toBe(5)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should not clone the first and last page when loop is false",
            "suites": [
                "slide test for SlidePage class"
            ],
            "updatePoint": {
                "line": 121,
                "column": 65
            },
            "line": 121,
            "code": "  it('should not clone the first and last page when loop is false', () => {\n    const { wrapper } = createSlideElements()\n    scroll = new BScroll(wrapper)\n    scroll.options.slide = {\n      loop: false,\n    }\n    slide = new Slide(scroll)\n    scroll.scroller.hooks.trigger(\n      scroll.scroller.hooks.eventTypes.beforeRefresh\n    )\n    const content = scroll.scroller.content\n    expect(content.children.length).toBe(3)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should failed to initialised slide when only has a child",
            "suites": [
                "slide test for SlidePage class"
            ],
            "updatePoint": {
                "line": 135,
                "column": 62
            },
            "line": 135,
            "code": "  it('should failed to initialised slide when only has a child', () => {\n    const { wrapper } = createSlideElements(0)\n    const spyFn = jest.spyOn(console, 'error')\n    scroll = new BScroll(wrapper, {})\n    slide = new Slide(scroll)\n    expect(spyFn).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "goToPage()",
            "suites": [
                "slide test for SlidePage class",
                "api"
            ],
            "updatePoint": {
                "line": 144,
                "column": 18
            },
            "line": 144,
            "code": "    it('goToPage()', () => {\n      slide.goToPage(2, 0)\n\n      expect(scroll.scroller.scrollTo).toBeCalledWith(\n        20,\n        20,\n        400,\n        expect.anything()\n      )\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "getCurrentPage()",
            "suites": [
                "slide test for SlidePage class",
                "api"
            ],
            "updatePoint": {
                "line": 155,
                "column": 24
            },
            "line": 155,
            "code": "    it('getCurrentPage()', () => {\n      slide.getCurrentPage()\n\n      expect(slide.pages.getInitialPage).toBeCalled()\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "startPlay()",
            "suites": [
                "slide test for SlidePage class",
                "api"
            ],
            "updatePoint": {
                "line": 161,
                "column": 19
            },
            "line": 161,
            "code": "    it('startPlay()', () => {\n      slide.startPlay()\n      jest.advanceTimersByTime(4000)\n      expect(scroll.scroller.scrollTo).toBeCalledWith(\n        20,\n        20,\n        400,\n        expect.anything()\n      )\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should pause play when BScroll trigger beforeScrollStart hook",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroll"
            ],
            "updatePoint": {
                "line": 174,
                "column": 69
            },
            "line": 174,
            "code": "    it('should pause play when BScroll trigger beforeScrollStart hook', () => {\n      const spyFn = jest.spyOn(Slide.prototype, 'pausePlay')\n      slide = new Slide(scroll)\n      scroll.trigger(scroll.eventTypes.beforeScrollStart)\n\n      expect(spyFn).toBeCalled()\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should call modifyCurrentPage() when BScroll trigger scrollEnd hook",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroll"
            ],
            "updatePoint": {
                "line": 182,
                "column": 75
            },
            "line": 182,
            "code": "    it('should call modifyCurrentPage() when BScroll trigger scrollEnd hook', () => {\n      // simulate stopping from animation\n      scroll.scroller.animater.forceStopped = true\n      scroll.trigger(scroll.eventTypes.scrollEnd, { x: 0, y: 0 })\n\n      expect(slide.pages.setCurrentPage).toBeCalled()\n\n      scroll.trigger(scroll.eventTypes.scrollEnd, { x: 0, y: 0 })\n      expect(slide.pages.resetLoopPage).toBeCalledTimes(1)\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "slidePageChanged event",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroll"
            ],
            "updatePoint": {
                "line": 193,
                "column": 30
            },
            "line": 193,
            "code": "    it('slidePageChanged event', () => {\n      const { wrapper } = createSlideElements()\n      const scroll = new BScroll(wrapper, {})\n      const slide = new Slide(scroll)\n      scroll.trigger(scroll.eventTypes.scrollEnd, { x: 0, y: 0 })\n      expect(slide.pages.getExposedPageByPageIndex).toBeCalled()\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should stop mousewheelMove handler chain",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroll"
            ],
            "updatePoint": {
                "line": 201,
                "column": 48
            },
            "line": 201,
            "code": "    it('should stop mousewheelMove handler chain', () => {\n      scroll.registerType(['mousewheelMove'])\n      slide = new Slide(scroll)\n      const mock = jest.fn()\n      scroll.on(scroll.eventTypes.mousewheelMove, mock)\n      scroll.trigger(scroll.eventTypes.mousewheelMove)\n      expect(mock).not.toBeCalled()\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should call next/prev in mousewheelEnd hook",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroll"
            ],
            "updatePoint": {
                "line": 210,
                "column": 51
            },
            "line": 210,
            "code": "    it('should call next/prev in mousewheelEnd hook', () => {\n      scroll.registerType(['mousewheelMove', 'mousewheelEnd'])\n      slide = new Slide(scroll)\n      const nextSpyFn = jest.spyOn(Slide.prototype, 'next')\n      const prevSpyFn = jest.spyOn(Slide.prototype, 'prev')\n      const delta1 = {\n        directionX: -1,\n        directionY: -1,\n      }\n      scroll.trigger(scroll.eventTypes.mousewheelEnd, delta1)\n      expect(prevSpyFn).toBeCalled()\n      const delta2 = {\n        directionX: 1,\n        directionY: 1,\n      }\n      scroll.trigger(scroll.eventTypes.mousewheelEnd, delta2)\n      expect(nextSpyFn).toBeCalled()\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should call refreshHandler when Bscroll.hooks.refresh triggered",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroll hooks"
            ],
            "updatePoint": {
                "line": 231,
                "column": 71
            },
            "line": 231,
            "code": "    it('should call refreshHandler when Bscroll.hooks.refresh triggered', () => {\n      // case 1 content changed\n      let wrapper1 = createSlideElements().wrapper\n      scroll = new BScroll(wrapper1, {\n        slide: {\n          threshold: 100,\n        },\n      })\n      slide = new Slide(scroll)\n      ;(slide as any).initialised = true\n      scroll.hooks.trigger(scroll.hooks.eventTypes.refresh)\n\n      expect(scroll.scroller.scrollTo).toBeCalledWith(\n        20,\n        20,\n        0,\n        expect.anything()\n      )\n      expect(slide.pages.getInitialPage).toHaveBeenCalled()\n\n      // case 2 content has only no child\n      let { wrapper: wrapper2, content: content2 } = createSlideElements(1)\n      scroll = new BScroll(wrapper2, {})\n      slide = new Slide(scroll)\n      content2.removeChild(content2.children[0])\n      scroll.hooks.trigger(scroll.hooks.eventTypes.refresh)\n      expect(slide.pages.refresh).not.toBeCalled()\n\n      // case3 common refresh\n      let { wrapper: wrapper3 } = createSlideElements(1)\n      scroll = new BScroll(wrapper3, {})\n      slide = new Slide(scroll)\n      const spyFn2 = jest.spyOn(Slide.prototype, 'startPlay')\n      const position = {}\n      scroll.hooks.trigger(scroll.hooks.eventTypes.refresh)\n      scroll.hooks.trigger(\n        scroll.hooks.eventTypes.beforeInitialScrollTo,\n        position\n      )\n\n      expect(slide.pages.refresh).toBeCalled()\n      expect(slide.pages.getInitialPage).toBeCalled()\n      expect(position).toMatchObject({\n        x: 10,\n        y: 10,\n      })\n      expect(spyFn2).toBeCalled()\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should call modifyScrollMetaHandler when scroller.hooks.momentum triggered",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroller hooks"
            ],
            "updatePoint": {
                "line": 282,
                "column": 82
            },
            "line": 282,
            "code": "    it('should call modifyScrollMetaHandler when scroller.hooks.momentum triggered', () => {\n      const scrollMeta = {\n        newX: -1,\n        newY: -1,\n        time: 0,\n      }\n      scroll.scroller.hooks.trigger(\n        scroll.scroller.hooks.eventTypes.momentum,\n        scrollMeta\n      )\n      expect(scrollMeta.newX).toBe(0)\n      expect(scrollMeta.newY).toBe(0)\n      expect(scrollMeta.time).toBe(400)\n\n      expect(slide.pages.getPageByDirection).toBeCalledWith(\n        {\n          x: 0,\n          y: 0,\n          pageX: 0,\n          pageY: 0,\n        },\n        0,\n        0\n      )\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should start a new autoPlay timer when scroller.hooks.checkClick triggered",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroller hooks"
            ],
            "updatePoint": {
                "line": 307,
                "column": 82
            },
            "line": 307,
            "code": "    it('should start a new autoPlay timer when scroller.hooks.checkClick triggered', () => {\n      const spyFn = jest.spyOn(Slide.prototype, 'startPlay')\n      slide = new Slide(scroll)\n\n      scroll.scroller.hooks.trigger(scroll.scroller.hooks.eventTypes.checkClick)\n      expect(spyFn).toBeCalled()\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should go to next/pre page scroller.hooks.flickHandler triggered",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroller hooks"
            ],
            "updatePoint": {
                "line": 315,
                "column": 72
            },
            "line": 315,
            "code": "    it('should go to next/pre page scroller.hooks.flickHandler triggered', () => {\n      slide = new Slide(scroll)\n\n      scroll.scroller.hooks.trigger(scroll.scroller.hooks.eventTypes.flick)\n\n      expect(scroll.scroller.scrollTo).toBeCalledWith(\n        20,\n        20,\n        400,\n        expect.anything()\n      )\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should dispatch slideWillChange event when scroller.hooks.scroll triggered",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroller hooks"
            ],
            "updatePoint": {
                "line": 328,
                "column": 82
            },
            "line": 328,
            "code": "    it('should dispatch slideWillChange event when scroller.hooks.scroll triggered', () => {\n      slide = new Slide(scroll)\n      let pageX = 0\n\n      scroll.on(scroll.eventTypes.slideWillChange, (Page: any) => {\n        pageX = Page.pageX\n      })\n      slide.pages.getWillChangedPage = jest.fn().mockImplementation(() => {\n        return {\n          pageX: 1,\n          pageY: 0,\n          x: 0,\n          y: 0,\n        }\n      })\n      scroll.hooks.trigger(scroll.hooks.eventTypes.refresh)\n      scroll.scroller.hooks.trigger(scroll.scroller.hooks.eventTypes.scroll, {\n        x: 0,\n        y: 0,\n      })\n      expect(pageX).toBe(0)\n\n      scroll.scroller.hooks.trigger(scroll.scroller.hooks.eventTypes.scroll, {\n        x: 200,\n        y: 0,\n      })\n      expect(pageX).toBe(1)\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "scroller.hooks.beforeRefresh",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroller hooks"
            ],
            "updatePoint": {
                "line": 357,
                "column": 36
            },
            "line": 357,
            "code": "    it('scroller.hooks.beforeRefresh', () => {\n      const { wrapper } = createSlideElements()\n      const scroll = new BScroll(wrapper, {})\n      const slide = new Slide(scroll)\n\n      scroll.scroller.hooks.trigger(\n        scroll.scroller.hooks.eventTypes.beforeRefresh\n      )\n      expect(scroll.scroller.content.children.length).toBe(5)\n\n      // slideContent changed\n      slide.prevContent = document.createElement('p')\n      scroll.scroller.hooks.trigger(\n        scroll.scroller.hooks.eventTypes.beforeRefresh\n      )\n      expect(scroll.scroller.content.children.length).toBe(7)\n\n      // many pages reduce to one page\n      const mockFn1 = jest.fn()\n      slide.initialised = true\n      slide.prevContent = wrapper.children[0] as HTMLElement\n      const childrenEl = [...Array.from(scroll.scroller.content.children)]\n      for (let i = 1; i < 5; i++) {\n        scroll.scroller.content.removeChild(childrenEl[i])\n      }\n      scroll.on(scroll.eventTypes.scrollEnd, mockFn1)\n      scroll.scroller.hooks.trigger(\n        scroll.scroller.hooks.eventTypes.beforeRefresh\n      )\n      scroll.trigger(scroll.eventTypes.scrollEnd, { x: 0, y: 0 })\n      expect(scroll.scroller.content.children.length).toBe(1)\n      expect(mockFn1).not.toBeCalled()\n\n      // one page increases to many page\n      const mockFn2 = jest.fn()\n      scroll.scroller.content.appendChild(document.createElement('div'))\n      scroll.on(scroll.eventTypes.scrollEnd, mockFn1)\n      scroll.scroller.hooks.trigger(\n        scroll.scroller.hooks.eventTypes.beforeRefresh\n      )\n      scroll.trigger(scroll.eventTypes.scrollEnd, { x: 0, y: 0 })\n      expect(scroll.scroller.content.children.length).toBe(4)\n      expect(mockFn2).not.toBeCalled()\n      while (scroll.scroller.content.children.length) {\n        const len = scroll.scroller.content.children.length\n        scroll.scroller.content.removeChild(\n          scroll.scroller.content.children[len - 1]\n        )\n      }\n      // reset loop changed status\n      scroll.scroller.hooks.trigger(\n        scroll.scroller.hooks.eventTypes.beforeRefresh\n      )\n    })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should destroy all events",
            "suites": [
                "slide test for SlidePage class",
                "tap into scroller hooks"
            ],
            "updatePoint": {
                "line": 413,
                "column": 31
            },
            "line": 413,
            "code": "  it('should destroy all events', () => {\n    scroll.scroller.hooks.trigger(\n      scroll.scroller.hooks.eventTypes.beforeRefresh\n    )\n    scroll.hooks.trigger(scroll.hooks.eventTypes.destroy)\n\n    expect(scroll.scroller.content.children.length).toBe(3)\n    expect(scroll.events['beforeScrollStart'].length).toBe(0)\n    expect(scroll.events['scrollEnd'].length).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should create 4 * 1 matrix page in X direction",
            "suites": [
                "slide test for PagesMatrix class"
            ],
            "updatePoint": {
                "line": 34,
                "column": 52
            },
            "line": 34,
            "code": "  it('should create 4 * 1 matrix page in X direction', () => {\n    expect(pageMatrix.pages.length).toBe(4)\n    expect(pageMatrix.pages[0].length).toBe(1)\n    expect(pageMatrix.pageLengthOfX).toBe(4)\n    expect(pageMatrix.pageLengthOfY).toBe(1)\n\n    const pageIndex1 = pageMatrix.getNearestPageIndex(0, 0)\n\n    expect(pageIndex1).toMatchObject({\n      pageX: 0,\n      pageY: 0,\n    })\n\n    const pageIndex2 = pageMatrix.getNearestPageIndex(-175, 0)\n\n    expect(pageIndex2).toMatchObject({\n      pageX: 2,\n      pageY: 0,\n    })\n  })",
            "file": "PagesMatrix.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should create 1 * 4 matrix page in Y direction",
            "suites": [
                "slide test for PagesMatrix class"
            ],
            "updatePoint": {
                "line": 55,
                "column": 52
            },
            "line": 55,
            "code": "  it('should create 1 * 4 matrix page in Y direction', () => {\n    const { wrapper } = createSlideElements()\n    scroll = new BScroll(wrapper, {})\n    scroll.scroller.scrollBehaviorX.wrapperSize = 100\n    scroll.scroller.scrollBehaviorX.contentSize = 100\n    scroll.scroller.scrollBehaviorX.maxScrollPos = 0\n    scroll.scroller.scrollBehaviorY.wrapperSize = 100\n    scroll.scroller.scrollBehaviorY.contentSize = 400\n    scroll.scroller.scrollBehaviorY.maxScrollPos = -300\n    pageMatrix = new PagesMatrix(scroll)\n\n    expect(pageMatrix.pages.length).toBe(1)\n    expect(pageMatrix.pages[0].length).toBe(4)\n    expect(pageMatrix.pageLengthOfX).toBe(1)\n    expect(pageMatrix.pageLengthOfY).toBe(4)\n\n    const pageIndex1 = pageMatrix.getNearestPageIndex(0, 0)\n\n    expect(pageIndex1).toMatchObject({\n      pageX: 0,\n      pageY: 0,\n    })\n\n    const pageIndex2 = pageMatrix.getNearestPageIndex(0, -175)\n\n    expect(pageIndex2).toMatchObject({\n      pageX: 0,\n      pageY: 2,\n    })\n  })",
            "file": "PagesMatrix.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getPageStats()",
            "suites": [
                "slide test for PagesMatrix class"
            ],
            "updatePoint": {
                "line": 86,
                "column": 42
            },
            "line": 86,
            "code": "  it('should work well with getPageStats()', () => {\n    const pageStats1 = pageMatrix.getPageStats(1, 0)\n\n    expect(pageStats1).toMatchObject({\n      x: -100,\n      y: 0,\n      width: 100,\n      height: 100,\n      cx: -150,\n      cy: -50,\n    })\n\n    const pageStats2 = pageMatrix.getPageStats(2, 0)\n    expect(pageStats2).toMatchObject({\n      x: -200,\n      y: 0,\n      width: 100,\n      height: 100,\n      cx: -250,\n      cy: -50,\n    })\n  })",
            "file": "PagesMatrix.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should has base current page",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 55,
                "column": 36
            },
            "line": 55,
            "code": "    it('should has base current page', () => {\n      expect(slidePages.currentPage).toMatchObject(BASE_PAGE)\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should set loopX when new SlidePage",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 59,
                "column": 43
            },
            "line": 59,
            "code": "    it('should set loopX when new SlidePage', () => {\n      expect(slidePages.loopX).toBe(true)\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getExposedPageByPageIndex()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 63,
                "column": 57
            },
            "line": 63,
            "code": "    it('should work well with getExposedPageByPageIndex()', () => {\n      const ret = slidePages.getExposedPageByPageIndex(1, 0)\n      expect(ret).toMatchObject({\n        x: 0,\n        y: 0,\n        pageX: 1,\n        pageY: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with setCurrentPage()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 73,
                "column": 46
            },
            "line": 73,
            "code": "    it('should work well with setCurrentPage()', () => {\n      const currentPage = {\n        pageX: 1,\n        pageY: 0,\n        x: 200,\n        y: 200,\n      }\n      slidePages.setCurrentPage(currentPage)\n      expect(slidePages.currentPage).toMatchObject(currentPage)\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getInternalPage()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 84,
                "column": 47
            },
            "line": 84,
            "code": "    it('should work well with getInternalPage()', () => {\n      const page1 = slidePages.getInternalPage(1, 0)\n\n      expect(page1).toMatchObject({\n        pageX: 1,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n\n      // exceed maxPageX\n      const page2 = slidePages.getInternalPage(4, 0)\n\n      expect(page2).toMatchObject({\n        pageX: 3,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n\n      // less than maxPageX\n      const page3 = slidePages.getInternalPage(-1, 0)\n\n      expect(page3).toMatchObject({\n        pageX: 0,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getInitialPage()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 115,
                "column": 46
            },
            "line": 115,
            "code": "    it('should work well with getInitialPage()', () => {\n      const page = slidePages.getInitialPage(true)\n\n      expect(page).toMatchObject({\n        pageX: 1,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getExposedPage() when loopX is true",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 126,
                "column": 65
            },
            "line": 126,
            "code": "    it('should work well with getExposedPage() when loopX is true', () => {\n      const pageX = slidePages.getExposedPage({\n        x: 0,\n        y: 0,\n        pageX: 1,\n        pageY: 0,\n      })\n\n      expect(pageX).toMatchObject({\n        pageX: 0,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getWillChangedPage() when loopX is true",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 142,
                "column": 69
            },
            "line": 142,
            "code": "    it('should work well with getWillChangedPage() when loopX is true', () => {\n      const page = slidePages.getWillChangedPage({\n        pageX: 0,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n\n      expect(page).toMatchObject({\n        pageX: 1,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getPageStats()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 158,
                "column": 44
            },
            "line": 158,
            "code": "    it('should work well with getPageStats()', () => {\n      const pageStats = slidePages.getPageStats()\n\n      expect(pageStats).toMatchObject({\n        x: 0,\n        y: 0,\n        width: 100,\n        height: 100,\n        cx: 50,\n        cy: 50,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getValidPageIndex()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 171,
                "column": 49
            },
            "line": 171,
            "code": "    it('should work well with getValidPageIndex()', () => {\n      const pageIndex = slidePages.getValidPageIndex(1, 0)\n\n      expect(pageIndex).toMatchObject({\n        pageX: 2,\n        pageY: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with nextPageIndex()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 180,
                "column": 45
            },
            "line": 180,
            "code": "    it('should work well with nextPageIndex()', () => {\n      const pageIndex = slidePages.nextPageIndex()\n\n      expect(pageIndex).toMatchObject({\n        pageX: 1,\n        pageY: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with prevPageIndex()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 189,
                "column": 45
            },
            "line": 189,
            "code": "    it('should work well with prevPageIndex()', () => {\n      const pageIndex = slidePages.prevPageIndex()\n\n      expect(pageIndex).toMatchObject({\n        pageX: -1,\n        pageY: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getNearestPage()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 198,
                "column": 46
            },
            "line": 198,
            "code": "    it('should work well with getNearestPage()', () => {\n      const pageIndex = slidePages.getNearestPage(30, 0)\n\n      expect(pageIndex).toMatchObject({\n        pageX: 1,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with resetLoopPage()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 209,
                "column": 45
            },
            "line": 209,
            "code": "    it('should work well with resetLoopPage()', () => {\n      const page1 = slidePages.resetLoopPage()\n\n      expect(page1).toMatchObject({\n        pageX: 2,\n        pageY: 0,\n      })\n\n      slidePages.setCurrentPage({\n        pageX: 3,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n      const page2 = slidePages.resetLoopPage()\n\n      expect(page2).toMatchObject({\n        pageX: 1,\n        pageY: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getPageByDirection()",
            "suites": [
                "slide test for SlidePages class",
                "loopX"
            ],
            "updatePoint": {
                "line": 231,
                "column": 50
            },
            "line": 231,
            "code": "    it('should work well with getPageByDirection()', () => {\n      const page = slidePages.getPageByDirection(\n        {\n          x: 0,\n          y: 0,\n          pageY: 0,\n          pageX: 0,\n        },\n        1,\n        0\n      )\n\n      expect(page.pageX).toBe(1)\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should set loopY when new SlidePage",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 258,
                "column": 43
            },
            "line": 258,
            "code": "    it('should set loopY when new SlidePage', () => {\n      expect(slidePages.loopY).toBe(true)\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getExposedPageByPageIndex()",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 262,
                "column": 57
            },
            "line": 262,
            "code": "    it('should work well with getExposedPageByPageIndex()', () => {\n      const ret = slidePages.getExposedPageByPageIndex(0, 1)\n      expect(ret).toMatchObject({\n        x: 0,\n        y: 0,\n        pageX: 0,\n        pageY: 1,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getInitialPage()",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 272,
                "column": 46
            },
            "line": 272,
            "code": "    it('should work well with getInitialPage()', () => {\n      const page = slidePages.getInitialPage(true, true)\n\n      expect(page).toMatchObject({\n        pageX: 0,\n        pageY: 1,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getExposedPage() when loopY is true",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 283,
                "column": 65
            },
            "line": 283,
            "code": "    it('should work well with getExposedPage() when loopY is true', () => {\n      const pageY = slidePages.getExposedPage({\n        x: 0,\n        y: 0,\n        pageX: 0,\n        pageY: 1,\n      })\n\n      expect(pageY).toMatchObject({\n        pageX: 0,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getWillChangedPage() when loopY is true",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 299,
                "column": 69
            },
            "line": 299,
            "code": "    it('should work well with getWillChangedPage() when loopY is true', () => {\n      const page = slidePages.getWillChangedPage({\n        pageX: 0,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n\n      expect(page).toMatchObject({\n        pageX: 0,\n        pageY: 1,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getValidPageIndex()",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 315,
                "column": 49
            },
            "line": 315,
            "code": "    it('should work well with getValidPageIndex()', () => {\n      const pageIndex = slidePages.getValidPageIndex(0, 1)\n\n      expect(pageIndex).toMatchObject({\n        pageX: 0,\n        pageY: 2,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with nextPageIndex()",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 324,
                "column": 45
            },
            "line": 324,
            "code": "    it('should work well with nextPageIndex()', () => {\n      const pageIndex = slidePages.nextPageIndex()\n\n      expect(pageIndex).toMatchObject({\n        pageX: 0,\n        pageY: 1,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with prevPageIndex()",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 333,
                "column": 45
            },
            "line": 333,
            "code": "    it('should work well with prevPageIndex()', () => {\n      const pageIndex = slidePages.prevPageIndex()\n\n      expect(pageIndex).toMatchObject({\n        pageX: 0,\n        pageY: -1,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with resetLoopPage()",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 342,
                "column": 45
            },
            "line": 342,
            "code": "    it('should work well with resetLoopPage()', () => {\n      const page1 = slidePages.resetLoopPage()\n\n      expect(page1).toMatchObject({\n        pageX: 0,\n        pageY: 2,\n      })\n\n      slidePages.setCurrentPage({\n        pageX: 0,\n        pageY: 3,\n        x: 0,\n        y: 0,\n      })\n\n      const page2 = slidePages.resetLoopPage()\n\n      expect(page2).toMatchObject({\n        pageX: 0,\n        pageY: 1,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getPageByDirection()",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 365,
                "column": 50
            },
            "line": 365,
            "code": "    it('should work well with getPageByDirection()', () => {\n      const page = slidePages.getPageByDirection(\n        {\n          x: 0,\n          y: 0,\n          pageY: 0,\n          pageX: 0,\n        },\n        0,\n        1\n      )\n\n      expect(page.pageY).toBe(1)\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should work well with getInternalPage()",
            "suites": [
                "slide test for SlidePages class",
                "loopY"
            ],
            "updatePoint": {
                "line": 380,
                "column": 47
            },
            "line": 380,
            "code": "    it('should work well with getInternalPage()', () => {\n      const page1 = slidePages.getInternalPage(0, 1)\n\n      expect(page1).toMatchObject({\n        pageX: 0,\n        pageY: 1,\n        x: 0,\n        y: 0,\n      })\n\n      // exceed maxPageY\n      const page2 = slidePages.getInternalPage(0, 4)\n\n      expect(page2).toMatchObject({\n        pageX: 0,\n        pageY: 3,\n        x: 0,\n        y: 0,\n      })\n\n      // less than maxPageX\n      const page3 = slidePages.getInternalPage(0, -1)\n\n      expect(page3).toMatchObject({\n        pageX: 0,\n        pageY: 0,\n        x: 0,\n        y: 0,\n      })\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should warn when loopX & loopY is true",
            "suites": [
                "slide test for SlidePages class",
                "loopX & loopY"
            ],
            "updatePoint": {
                "line": 413,
                "column": 46
            },
            "line": 413,
            "code": "    it('should warn when loopX & loopY is true', () => {\n      const spyFn = jest.spyOn(console, 'error')\n      const { wrapper } = createSlideElements()\n      scroll = new BScroll(wrapper, {\n        scrollX: true,\n        scrollY: true,\n      })\n      slidePages = new SlidePages(scroll, slideOptions)\n      slidePages.refresh()\n      expect(spyFn).toHaveBeenCalledTimes(1)\n    })",
            "file": "SlidePages.spec.ts",
            "skipped": false,
            "dir": "packages/slide/src/__tests__"
        },
        {
            "name": "should proxy properties to BScroll instance",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 36,
                "column": 49
            },
            "line": 36,
            "code": "  it('should proxy properties to BScroll instance', () => {\n    expect(scroll.proxy).toBeCalled()\n    expect(scroll.proxy).toHaveBeenLastCalledWith([\n      {\n        key: 'wheelTo',\n        sourceKey: 'plugins.wheel.wheelTo'\n      },\n      {\n        key: 'getSelectedIndex',\n        sourceKey: 'plugins.wheel.getSelectedIndex'\n      },\n      {\n        key: 'restorePosition',\n        sourceKey: 'plugins.wheel.restorePosition'\n      }\n    ])\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should handle options",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 54,
                "column": 27
            },
            "line": 54,
            "code": "  it('should handle options', () => {\n    expect(wheel.options.rotate).toBe(25)\n    expect(wheel.options.adjustTime).toBe(400)\n    expect(wheel.options.selectedIndex).toBe(0)\n    expect(wheel.options.wheelWrapperClass).toBe('wheel-scroll')\n    expect(wheel.options.wheelItemClass).toBe('wheel-item')\n    expect(wheel.options.wheelDisabledItemClass).toBe('wheel-disabled-item')\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should refresh BehaviorX and BehaviorY boundary",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 63,
                "column": 53
            },
            "line": 63,
            "code": "  it('should refresh BehaviorX and BehaviorY boundary', () => {\n    const { scrollBehaviorX, scrollBehaviorY } = scroll.scroller\n\n    expect(scrollBehaviorX.refresh).toBeCalled()\n    expect(scrollBehaviorY.refresh).toBeCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should handle selectedIndex",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 70,
                "column": 33
            },
            "line": 70,
            "code": "  it('should handle selectedIndex', () => {\n    // default\n    expect(wheel.selectedIndex).toBe(0)\n    // specified\n    const { wheel: wheel2 } = createWheel({\n      selectedIndex: 2\n    })\n    expect(wheel2.selectedIndex).toBe(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should trigger scroll.scrollTo when invoking wheelTo method",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 80,
                "column": 65
            },
            "line": 80,
            "code": "  it('should trigger scroll.scrollTo when invoking wheelTo method', () => {\n    addPropertiesToWheel(wheel, {\n      itemHeight: 40\n    })\n    wheel.wheelTo(0)\n\n    expect(scroll.scrollTo).toBeCalled()\n    expect(scroll.scrollTo).toHaveBeenLastCalledWith(0, -0, 0, undefined)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should return seletedIndex when invoking getSelectedIndex",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 90,
                "column": 63
            },
            "line": 90,
            "code": "  it('should return seletedIndex when invoking getSelectedIndex', () => {\n    const { wheel: wheel2 } = createWheel({\n      selectedIndex: 2\n    })\n    expect(wheel2.getSelectedIndex()).toBe(2)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should support scrollTo somewhere by selectedIndex when initialized",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 97,
                "column": 73
            },
            "line": 97,
            "code": "  it('should support scrollTo somewhere by selectedIndex when initialized', () => {\n    addPropertiesToWheel(wheel, {\n      selectedIndex: 1,\n      itemHeight: 50\n    })\n    const postion = {\n      x: 100,\n      y: 100\n    }\n    // manually trigger\n    scroll.hooks.trigger(scroll.hooks.eventTypes.beforeInitialScrollTo, postion)\n    expect(postion).toMatchObject({\n      x: 0,\n      y: -50\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should invoke wheelTo when scroll.scroller trigger checkClick hook",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 114,
                "column": 72
            },
            "line": 114,
            "code": "  it('should invoke wheelTo when scroll.scroller trigger checkClick hook', () => {\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div],\n      target: div,\n      wheelTo: jest.fn()\n    })\n\n    scroll.scroller.hooks.trigger('checkClick')\n    expect(wheel.wheelTo).toBeCalled()\n    expect(wheel.wheelTo).toHaveBeenCalledWith(0, 400, expect.anything())\n\n    // if target element is not found\n    addPropertiesToWheel(wheel, {\n      items: [div],\n      target: null,\n      wheelTo: jest.fn()\n    })\n    let ret = scroll.scroller.hooks.trigger('checkClick')\n    expect(ret).toBe(true)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should invoke findNearestValidWheel when scroll.scroller trigger scrollTo hook",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 136,
                "column": 84
            },
            "line": 136,
            "code": "  it('should invoke findNearestValidWheel when scroll.scroller trigger scrollTo hook', () => {\n    let endPoint = { x: 0, y: -20 }\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div],\n      target: div,\n      itemHeight: 40,\n      wheelTo: jest.fn()\n    })\n\n    scroll.scroller.hooks.trigger('scrollTo', endPoint)\n    expect(endPoint.y).toBe(-0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should change position when scroll.scroller trigger scrollToElement hook",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 150,
                "column": 78
            },
            "line": 150,
            "code": "  it('should change position when scroll.scroller trigger scrollToElement hook', () => {\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div],\n      target: div,\n      itemHeight: 40\n    })\n    let pos = {\n      top: -20,\n      left: 0\n    }\n    div.className = 'wheel-item'\n    scroll.scroller.hooks.trigger('scrollToElement', div, pos)\n\n    expect(pos).toEqual({\n      top: -0,\n      left: 0\n    })\n\n    // mismatch target element\n    let div1 = document.createElement('div')\n    let pos1 = {\n      top: -40,\n      left: 0\n    }\n    addPropertiesToWheel(wheel, {\n      items: [div1],\n      target: div1,\n      itemHeight: 40\n    })\n    let ret = scroll.scroller.hooks.trigger('scrollToElement', div1, pos1)\n    expect(ret).toBe(true)\n    expect(pos1).toMatchObject({\n      top: -40,\n      left: 0\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should change target when scroll.scroller.actionsHandler trigger beforeStart hook",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 188,
                "column": 87
            },
            "line": 188,
            "code": "  it('should change target when scroll.scroller.actionsHandler trigger beforeStart hook', () => {\n    let e = {} as any\n    let div = document.createElement('div')\n    e.target = div\n    scroll.scroller.actionsHandler.hooks.trigger('beforeStart', e)\n\n    expect(wheel.target).toEqual(div)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should modify boundary when scrollBehaviorY or scrollBehaviorX computedBoundary",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 197,
                "column": 85
            },
            "line": 197,
            "code": "  it('should modify boundary when scrollBehaviorY or scrollBehaviorX computedBoundary', () => {\n    let div = document.createElement('div')\n    let cachedXBoundary = {} as Boundary\n    let cachedYBoundary = {} as Boundary\n    addPropertiesToWheel(wheel, {\n      items: [div, div],\n      itemHight: 50\n    })\n    const { scrollBehaviorX, scrollBehaviorY } = scroll.scroller\n    // append two element\n    scroll.scroller.content.appendChild(document.createElement('div'))\n    scroll.scroller.content.appendChild(document.createElement('div'))\n    scrollBehaviorY.contentSize = 100\n\n    // manually trigger\n    scrollBehaviorX.hooks.trigger(\n      scrollBehaviorX.hooks.eventTypes.computeBoundary,\n      cachedXBoundary\n    )\n    scrollBehaviorY.hooks.trigger(\n      scrollBehaviorY.hooks.eventTypes.computeBoundary,\n      cachedYBoundary\n    )\n\n    expect(cachedXBoundary).toMatchObject({\n      minScrollPos: 0,\n      maxScrollPos: 0\n    })\n\n    expect(cachedYBoundary).toMatchObject({\n      minScrollPos: 0,\n      maxScrollPos: -50\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should change momentumInfo when scroll.scroller.scrollBehaviorY trigger momentum or end hook",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 232,
                "column": 98
            },
            "line": 232,
            "code": "  it('should change momentumInfo when scroll.scroller.scrollBehaviorY trigger momentum or end hook', () => {\n    let momentumInfo = {\n      destination: 0,\n      rate: 15\n    }\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div],\n      target: div,\n      itemHeight: 40\n    })\n    scroll.scroller.scrollBehaviorY.hooks.trigger('momentum', momentumInfo)\n\n    expect(momentumInfo).toEqual({\n      destination: -0,\n      rate: 4\n    })\n\n    scroll.scroller.scrollBehaviorY.currentPos = -20\n    scroll.scroller.scrollBehaviorY.hooks.trigger('end', momentumInfo)\n    expect(momentumInfo).toEqual({\n      destination: -0,\n      rate: 4,\n      duration: 400\n    })\n\n    scroll.scroller.scrollBehaviorY.hooks.trigger('momentum', momentumInfo, 800)\n    expect(momentumInfo).toEqual({\n      destination: -0,\n      rate: 4,\n      duration: 400\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "scroll.hooks.refresh ",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 266,
                "column": 27
            },
            "line": 266,
            "code": "  it('scroll.hooks.refresh ', () => {\n    let newContent = document.createElement('p')\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div],\n      target: div,\n      itemHeight: 40\n    })\n    wheel.options.selectedIndex = 1\n    scroll.hooks.trigger(scroll.hooks.eventTypes.refresh, newContent)\n\n    expect(scroll.scrollTo).toBeCalledWith(0, -40, 0, undefined)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "scroll.scroller.animater.hooks.time ",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 280,
                "column": 42
            },
            "line": 280,
            "code": "  it('scroll.scroller.animater.hooks.time ', () => {\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div]\n    })\n    const animater = scroll.scroller.animater\n    animater.hooks.trigger(animater.hooks.eventTypes.time, 100)\n    expect(div.style.transitionDuration).toBe('100ms')\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "scroll.scroller.animater.hooks.timeFunction ",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 290,
                "column": 50
            },
            "line": 290,
            "code": "  it('scroll.scroller.animater.hooks.timeFunction ', () => {\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div]\n    })\n    const animater = scroll.scroller.animater\n    animater.hooks.trigger(\n      animater.hooks.eventTypes.timeFunction,\n      'cubic-bezier(0.23, 1, 0.32, 1)'\n    )\n    expect(div.style.transitionTimingFunction).toBe(\n      'cubic-bezier(0.23, 1, 0.32, 1)'\n    )\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "scroll.scroller.animater.hooks.callStop",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 305,
                "column": 45
            },
            "line": 305,
            "code": "  it('scroll.scroller.animater.hooks.callStop', () => {\n    let div1 = document.createElement('div')\n    let div2 = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div1, div2],\n      itemHeight: 40,\n      wheelItemsAllDisabled: false\n    })\n    scroll.y = -41\n    scroll.maxScrollY = -80\n    scroll.scroller.animater.hooks.trigger('callStop')\n    expect(scroll.scrollTo).toBeCalledWith(0, -40, 0, undefined)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "scroll.scroller.animater.translater.hooks.translate",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 319,
                "column": 57
            },
            "line": 319,
            "code": "  it('scroll.scroller.animater.translater.hooks.translate', () => {\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div],\n      itemHeight: 40,\n      wheelItemsAllDisabled: false\n    })\n    const translater = scroll.scroller.animater.translater\n    translater.hooks.trigger(translater.hooks.eventTypes.translate, {\n      x: 0,\n      y: -20\n    })\n    expect(wheel.selectedIndex).toEqual(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "scroll.scroller.hooks.minDistanceScroll ",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 334,
                "column": 46
            },
            "line": 334,
            "code": "  it('scroll.scroller.hooks.minDistanceScroll ', () => {\n    let div = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      items: [div]\n    })\n    const scroller = scroll.scroller\n    scroller.animater.forceStopped = true\n    scroller.hooks.trigger(scroller.hooks.eventTypes.minDistanceScroll)\n    expect(scroller.animater.forceStopped).toBe(false)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "scrollEnd event",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 345,
                "column": 21
            },
            "line": 345,
            "code": "  it('scrollEnd event', () => {\n    let div1 = document.createElement('div')\n    let div2 = document.createElement('div')\n    addPropertiesToWheel(wheel, {\n      itemHeight: 40,\n      items: [div1, div2]\n    })\n    scroll.maxScrollY = -80\n    scroll.scroller.animater.forceStopped = true\n    // stopped from an animation,\n    // prevent user's scrollEnd callback triggered twice\n    const ret = scroll.trigger(scroll.eventTypes.scrollEnd, { y: 0 })\n    expect(ret).toBe(true)\n\n    wheel.isAdjustingPosition = true\n    // update selectedIndex\n    scroll.trigger(scroll.eventTypes.scrollEnd, { y: -41 })\n\n    expect(wheel.getSelectedIndex()).toBe(1)\n    expect(wheel.isAdjustingPosition).toBe(false)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "wheel.restorePosition()",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 367,
                "column": 29
            },
            "line": 367,
            "code": "  it('wheel.restorePosition()', () => {\n    addPropertiesToWheel(wheel, {\n      itemHeight: 40\n    })\n    // simulate bs is scrolling\n    scroll.pending = true\n    wheel.restorePosition()\n    expect(scroll.scroller.animater.clearTimer).toBeCalled()\n    expect(scroll.scrollTo).toBeCalledWith(0, -0, 0, undefined)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should support disable wheel items",
            "suites": [
                "wheel plugin tests"
            ],
            "updatePoint": {
                "line": 378,
                "column": 40
            },
            "line": 378,
            "code": "  it('should support disable wheel items', () => {\n    let div1 = document.createElement('div')\n    let div2 = document.createElement('div')\n    const scroller = scroll.scroller\n    const position = { y: -41 }\n    addPropertiesToWheel(wheel, {\n      items: [div1, div2],\n      itemHeight: 40,\n      wheelItemsAllDisabled: false\n    })\n    scroll.y = -41\n    scroll.maxScrollY = -80\n    div2.className = 'wheel-disabled-item'\n    scroller.hooks.trigger(scroller.hooks.eventTypes.scrollTo, position)\n    expect(position.y).toBe(-0)\n\n    div1.className = 'wheel-disabled-item'\n    wheel.wheelItemsAllDisabled = true\n    scroller.hooks.trigger(scroller.hooks.eventTypes.scrollTo, position)\n    expect(position.y).toBe(-0)\n\n    let div3 = document.createElement('div')\n    let position3 = {\n      y: -39\n    }\n    addPropertiesToWheel(wheel, {\n      items: [div1, div2, div3],\n      itemHeight: 40,\n      wheelItemsAllDisabled: false\n    })\n    scroller.hooks.trigger(scroller.hooks.eventTypes.scrollTo, position3)\n    expect(position3.y).toBe(-80)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/wheel/src/__tests__"
        },
        {
            "name": "should proxy properties to BScroll instance",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 21,
                "column": 49
            },
            "line": 21,
            "code": "  it('should proxy properties to BScroll instance', () => {\n    new Zoom(scroll)\n\n    expect(scroll.proxy).toBeCalled()\n    expect(scroll.proxy).toHaveBeenLastCalledWith([\n      {\n        key: 'zoomTo',\n        sourceKey: 'plugins.zoom.zoomTo',\n      },\n    ])\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should register hooks to BScroll instance",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 33,
                "column": 47
            },
            "line": 33,
            "code": "  it('should register hooks to BScroll instance', () => {\n    new Zoom(scroll)\n\n    expect(scroll.registerType).toBeCalled()\n    expect(scroll.registerType).toHaveBeenLastCalledWith([\n      'beforeZoomStart',\n      'zoomStart',\n      'zooming',\n      'zoomEnd',\n    ])\n    expect(scroll.eventTypes.beforeZoomStart).toEqual('beforeZoomStart')\n    expect(scroll.eventTypes.zoomStart).toEqual('zoomStart')\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should handle default options and user options",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 47,
                "column": 52
            },
            "line": 47,
            "code": "  it('should handle default options and user options', () => {\n    // case 1\n    scroll.options.zoom = true\n    let zoom = new Zoom(scroll)\n    expect(zoom.zoomOpt).toMatchObject({\n      start: 1,\n      min: 1,\n      max: 4,\n      initialOrigin: [0, 0],\n      minimalZoomDistance: 5,\n      bounceTime: 800,\n    })\n\n    // case 2\n    scroll.options.zoom = {\n      initialOrigin: ['center', 'center'],\n      bounceTime: 300,\n    }\n    zoom = new Zoom(scroll)\n    expect(zoom.zoomOpt).toMatchObject({\n      start: 1,\n      min: 1,\n      max: 4,\n      initialOrigin: ['center', 'center'],\n      minimalZoomDistance: 5,\n      bounceTime: 300,\n    })\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should try initialZoomTo when new zoom()",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 76,
                "column": 46
            },
            "line": 76,
            "code": "  it('should try initialZoomTo when new zoom()', () => {\n    // start is 1, no zoomTo\n    new Zoom(scroll)\n    expect(scroll.scroller.scrollTo).toBeCalledTimes(0)\n\n    // start !== 1\n    scroll.options.zoom = {\n      start: 1.5,\n      initialOrigin: [0, 0],\n    }\n    new Zoom(scroll)\n    expect(scroll.scroller.scrollTo).toBeCalledTimes(1)\n    expect(scroll.scroller.scrollTo).toHaveBeenLastCalledWith(\n      0,\n      0,\n      0,\n      ease.bounce,\n      {\n        start: {\n          scale: 1,\n        },\n        end: {\n          scale: 1.5,\n        },\n      }\n    )\n\n    // start should <= max\n    scroll.options.zoom = {\n      start: 3.5,\n      max: 3,\n      initialOrigin: [0, 0],\n    }\n    new Zoom(scroll)\n    expect(scroll.scroller.scrollTo).toBeCalledTimes(2)\n    expect(scroll.scroller.scrollTo).toHaveBeenLastCalledWith(\n      0,\n      0,\n      0,\n      ease.bounce,\n      {\n        start: {\n          scale: 1,\n        },\n        end: {\n          scale: 3, // equals max\n        },\n      }\n    )\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should set scaled element's transform origin",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 127,
                "column": 50
            },
            "line": 127,
            "code": "  it(\"should set scaled element's transform origin\", () => {\n    new Zoom(scroll)\n    expect(scroll.scroller.content.style['transform-origin' as any]).toBe('0 0')\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should not response with one finger",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 132,
                "column": 41
            },
            "line": 132,
            "code": "  it('should not response with one finger', () => {\n    const zoom = new Zoom(scroll)\n    const hooks = scroll.scroller.actions.hooks\n\n    const zoomStartSpy = jest.spyOn(zoom, 'zoomStart')\n    const zoomSpy = jest.spyOn(zoom, 'zoom')\n    const zoomEndSpy = jest.spyOn(zoom, 'zoomEnd')\n\n    const e = createTouchEvent({ pageX: 0, pageY: 0 })\n    hooks.trigger(hooks.eventTypes.start, e)\n    expect(zoomStartSpy).not.toHaveBeenCalled()\n\n    hooks.trigger(hooks.eventTypes.beforeMove, e)\n    expect(zoomSpy).not.toHaveBeenCalled()\n\n    hooks.trigger(hooks.eventTypes.beforeEnd, e)\n    expect(zoomEndSpy).not.toHaveBeenCalled()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should compute boundary of Behavior when zoom ends",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 151,
                "column": 56
            },
            "line": 151,
            "code": "  it('should compute boundary of Behavior when zoom ends', () => {\n    const zoom = new Zoom(scroll) as any\n\n    // simulate two fingers\n    zoom.numberOfFingers = 2\n    // allow trigger beforeEnd hooks\n    zoom.zoomed = true\n\n    const e = createTouchEvent({ pageX: 0, pageY: 0 }, { pageX: 20, pageY: 20 })\n    const actions = scroll.scroller.actions\n    const behaviorX = scroll.scroller.scrollBehaviorX\n    const behaviorY = scroll.scroller.scrollBehaviorY\n    behaviorX.checkInBoundary = jest.fn().mockImplementation(() => {\n      return { inBoundary: true }\n    })\n    behaviorY.checkInBoundary = jest.fn().mockImplementation(() => {\n      return { inBoundary: true }\n    })\n    actions.hooks.trigger(actions.hooks.eventTypes.beforeEnd, e)\n\n    expect(behaviorX.computeBoundary).toHaveBeenCalled()\n    expect(behaviorY.computeBoundary).toHaveBeenCalled()\n\n    // we should zoomed before call zoomEnd\n    zoom.zoomed = false\n    actions.hooks.trigger(actions.hooks.eventTypes.beforeEnd, e)\n    expect(behaviorX.computeBoundary).toBeCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should fail when zooming distance < minimalZoomDistance",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 180,
                "column": 61
            },
            "line": 180,
            "code": "  it('should fail when zooming distance < minimalZoomDistance', () => {\n    scroll.options.zoom = {\n      minimalZoomDistance: 10,\n    }\n    new Zoom(scroll)\n    const actions = scroll.scroller.actions\n    const mockZoomingFn = jest.fn()\n    scroll.on(scroll.eventTypes.zooming, mockZoomingFn)\n    // zoomStart\n    const e = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 130, pageY: 130 }\n    )\n    actions.hooks.trigger(actions.hooks.eventTypes.start, e)\n    // zoom\n    const e2 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 135, pageY: 135 }\n    )\n    actions.hooks.trigger(actions.hooks.eventTypes.beforeMove, e2)\n    expect(mockZoomingFn).toHaveBeenCalledTimes(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should have correct behavior when zooming out",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 203,
                "column": 51
            },
            "line": 203,
            "code": "  it('should have correct behavior when zooming out', () => {\n    scroll.options.zoom = {\n      max: 2,\n    }\n    const zoom = new Zoom(scroll)\n    const actions = scroll.scroller.actions\n    const translater = scroll.scroller.translater\n    const mockZoomingFn = jest.fn()\n    scroll.on(scroll.eventTypes.zooming, mockZoomingFn)\n\n    // zoomStart\n    const e = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 130, pageY: 130 }\n    )\n    actions.hooks.trigger(actions.hooks.eventTypes.start, e)\n    // zoom\n    const e2 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 150, pageY: 150 }\n    )\n    actions.hooks.trigger(actions.hooks.eventTypes.beforeMove, e2)\n\n    // triggered zooming hooks\n    expect(mockZoomingFn).toHaveBeenCalled()\n    expect(mockZoomingFn).toHaveBeenCalledTimes(1)\n    // beforeMove hooks use translater.translate, not scroller.scrollTo\n    expect(scroll.scroller.translater.translate).toBeCalledWith({\n      x: -16,\n      y: -16,\n      scale: 1.2,\n    })\n    expect(zoom.scale).toBe(1.2)\n    // triggered beforeTranslate hooks\n    const transformString: string[] = []\n    const transformPoint = {\n      scale: 1.2,\n    }\n    translater.hooks.trigger(\n      translater.hooks.eventTypes.beforeTranslate,\n      transformString,\n      transformPoint\n    )\n    expect(transformString[0]).toBe('scale(1.2)')\n\n    // keep zoom\n    const e3 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 170, pageY: 170 }\n    )\n    actions.hooks.trigger('beforeMove', e3)\n    // triggered zooming hooks\n    expect(mockZoomingFn).toHaveBeenCalledTimes(2)\n\n    expect(scroll.scroller.translater.translate).toHaveBeenLastCalledWith({\n      x: -32,\n      y: -32,\n      scale: 1.4,\n    })\n    expect(zoom.scale).toBe(1.4)\n\n    // keep zoom, allow zooming exceeds max\n    const e4 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 240, pageY: 240 }\n    )\n    actions.hooks.trigger('beforeMove', e4)\n    // triggered zooming hooks\n    expect(mockZoomingFn).toHaveBeenCalledTimes(3)\n\n    expect(scroll.scroller.translater.translate).toHaveBeenLastCalledWith({\n      x: -85,\n      y: -85,\n      scale: 2 * 2 * Math.pow(0.5, 2 / 2.1),\n    })\n    expect(zoom.scale).toBeCloseTo(2.067)\n\n    // zoom end, perform a rebound animation,back to max scale\n    actions.hooks.trigger('beforeEnd')\n    expect(zoom.scale).toBe(2)\n    expect(scroll.scroller.scrollTo).toHaveBeenLastCalledWith(\n      0,\n      0,\n      800,\n      ease.bounce,\n      {\n        start: {\n          scale: 2.0671155660140554,\n        },\n        end: {\n          scale: 2,\n        },\n      }\n    )\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should have correct behavior when zooming in",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 299,
                "column": 50
            },
            "line": 299,
            "code": "  it('should have correct behavior when zooming in', () => {\n    scroll.options.zoom = {\n      min: 0.5,\n    }\n    const zoom = new Zoom(scroll)\n    const actions = scroll.scroller.actions\n    const translater = scroll.scroller.translater\n    const mockZoomingFn = jest.fn()\n    scroll.on(scroll.eventTypes.zooming, mockZoomingFn)\n\n    // zoomStart\n    const e = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 130, pageY: 130 }\n    )\n    actions.hooks.trigger(actions.hooks.eventTypes.start, e)\n    // zoom\n    const e2 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 110, pageY: 110 }\n    )\n    actions.hooks.trigger(actions.hooks.eventTypes.beforeMove, e2)\n\n    // triggered zooming hooks\n    expect(mockZoomingFn).toHaveBeenCalled()\n    expect(mockZoomingFn).toHaveBeenCalledTimes(1)\n    // beforeMove hooks use translater.translate, not scroller.scrollTo\n    expect(scroll.scroller.translater.translate).toBeCalledWith({\n      x: 16,\n      y: 16,\n      scale: 0.8,\n    })\n    expect(zoom.scale).toBe(0.8)\n    // triggered beforeTranslate hooks\n    const transformString: string[] = []\n    const transformPoint = {\n      scale: 0.8,\n    }\n    translater.hooks.trigger(\n      translater.hooks.eventTypes.beforeTranslate,\n      transformString,\n      transformPoint\n    )\n    expect(transformString[0]).toBe('scale(0.8)')\n\n    // keep zoom\n    const e3 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 90, pageY: 90 }\n    )\n    actions.hooks.trigger('beforeMove', e3)\n    // triggered zooming hooks\n    expect(mockZoomingFn).toHaveBeenCalledTimes(2)\n\n    expect(scroll.scroller.translater.translate).toHaveBeenLastCalledWith({\n      x: 32,\n      y: 32,\n      scale: 0.6,\n    })\n    expect(zoom.scale).toBe(0.6)\n\n    // keep zoom, allow zooming exceeds max\n    const e4 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 40, pageY: 40 }\n    )\n    actions.hooks.trigger('beforeMove', e4)\n    // triggered zooming hooks\n    expect(mockZoomingFn).toHaveBeenCalledTimes(3)\n\n    expect(scroll.scroller.translater.translate).toHaveBeenLastCalledWith({\n      x: 57,\n      y: 57,\n      scale: 0.5 * 0.5 * Math.pow(2, 0.1 / 0.5),\n    })\n    expect(zoom.scale).toBeCloseTo(0.287)\n\n    // zoom end, perform a rebound animation,back to max scale\n    actions.hooks.trigger('beforeEnd')\n    expect(zoom.scale).toBe(0.5)\n    expect(scroll.scroller.scrollTo).toHaveBeenLastCalledWith(\n      0,\n      0,\n      800,\n      ease.bounce,\n      {\n        start: {\n          scale: 0.2871745887492588,\n        },\n        end: {\n          scale: 0.5,\n        },\n      }\n    )\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should have correct behavior for zoomTo",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 395,
                "column": 45
            },
            "line": 395,
            "code": "  it('should have correct behavior for zoomTo', (done) => {\n    scroll.options.zoom = {\n      min: 0.5,\n      max: 3,\n      start: 1,\n    }\n    const zoom = new Zoom(scroll)\n    const { scrollBehaviorX, scrollBehaviorY } = scroll.scroller\n    scrollBehaviorX.contentSize = 100\n    scrollBehaviorY.contentSize = 100\n    scrollBehaviorX.wrapperSize = 100\n    scrollBehaviorY.wrapperSize = 100\n\n    // [0, 0] as origin, scale to 2\n    zoom.zoomTo(2, 0, 0)\n    expect(scroll.scroller.scrollTo).toHaveBeenCalledWith(\n      0,\n      0,\n      800,\n      ease.bounce,\n      {\n        start: {\n          scale: 1,\n        },\n        end: {\n          scale: 2,\n        },\n      }\n    )\n\n    // ['center', 'center'] as origin, time is 300, scale to 1.5\n    zoom.zoomTo(1.5, 'center', 'center', 300)\n    expect(scroll.scroller.scrollTo).toHaveBeenCalledWith(\n      0,\n      0,\n      300,\n      ease.bounce,\n      {\n        start: {\n          scale: 2,\n        },\n        end: {\n          scale: 1.5,\n        },\n      }\n    )\n\n    // ['left', 'top'] as origin, time is 300, scale to 3\n    zoom.zoomTo(3, 'left', 'top', 300)\n    expect(scroll.scroller.scrollTo).toHaveBeenCalledWith(\n      0,\n      0,\n      300,\n      ease.bounce,\n      {\n        start: {\n          scale: 1.5,\n        },\n        end: {\n          scale: 3,\n        },\n      }\n    )\n\n    // ['right', 'bottom'] as origin, time is 300, scale to 3\n    zoom.zoomTo(2, 'right', 'bottom', 300)\n    expect(scroll.scroller.scrollTo).toHaveBeenCalledWith(\n      0,\n      0,\n      300,\n      ease.bounce,\n      {\n        start: {\n          scale: 3,\n        },\n        end: {\n          scale: 2,\n        },\n      }\n    )\n    // The purpose for improving test coverage\n    setTimeout(() => {\n      done()\n    }, 320)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should support full hooks",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 481,
                "column": 31
            },
            "line": 481,
            "code": "  it('should support full hooks', () => {\n    scroll.options.zoom = {\n      min: 1,\n      start: 1,\n      max: 4,\n    }\n    new Zoom(scroll)\n    const actions = scroll.scroller.actions\n    const behaviorX = scroll.scroller.scrollBehaviorX\n    const behaviorY = scroll.scroller.scrollBehaviorY\n    behaviorX.checkInBoundary = jest.fn().mockImplementation(() => {\n      return { inBoundary: true }\n    })\n    behaviorY.checkInBoundary = jest.fn().mockImplementation(() => {\n      return { inBoundary: true }\n    })\n\n    const mockBeforeZoomStartFn = jest.fn()\n    const mockZoomStartFn = jest.fn()\n    const mockZoomingFn = jest.fn()\n    const mockZoomEndFn = jest.fn()\n\n    // tap hooks\n    scroll.on(scroll.eventTypes.beforeZoomStart, mockBeforeZoomStartFn)\n    scroll.on(scroll.eventTypes.zoomStart, mockZoomStartFn)\n    scroll.on(scroll.eventTypes.zooming, mockZoomingFn)\n    scroll.on(scroll.eventTypes.zoomEnd, mockZoomEndFn)\n\n    // zoomStart\n    const e1 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 130, pageY: 130 }\n    )\n    actions.hooks.trigger(actions.hooks.eventTypes.start, e1)\n    // zooming\n    const e2 = createTouchEvent(\n      { pageX: 30, pageY: 30 },\n      { pageX: 150, pageY: 150 }\n    )\n    actions.hooks.trigger(actions.hooks.eventTypes.beforeMove, e2)\n    // zoomEnd\n    actions.hooks.trigger(actions.hooks.eventTypes.beforeEnd)\n\n    expect(mockBeforeZoomStartFn).toBeCalledTimes(1)\n    expect(mockZoomStartFn).toBeCalledTimes(1)\n    expect(mockZoomingFn).toBeCalledTimes(1)\n    expect(mockZoomEndFn).toBeCalledTimes(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should destroy all events",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 530,
                "column": 31
            },
            "line": 530,
            "code": "  it('should destroy all events', () => {\n    new Zoom(scroll)\n    const {\n      actions,\n      scrollBehaviorX,\n      scrollBehaviorY,\n      translater,\n    } = scroll.scroller\n    scroll.hooks.trigger(scroll.hooks.eventTypes.destroy)\n    expect(scrollBehaviorX.hooks.events['beforeComputeBoundary'].length).toBe(0)\n    expect(scrollBehaviorY.hooks.events['beforeComputeBoundary'].length).toBe(0)\n    expect(actions.hooks.events['start'].length).toBe(0)\n    expect(actions.hooks.events['beforeMove'].length).toBe(0)\n    expect(actions.hooks.events['beforeEnd'].length).toBe(0)\n    expect(translater.hooks.events['beforeTranslate'].length).toBe(0)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should work well when content DOM has changed",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 547,
                "column": 51
            },
            "line": 547,
            "code": "  it('should work well when content DOM has changed', () => {\n    const zoom = new Zoom(scroll)\n    const newContent = document.createElement('p')\n    scroll.hooks.trigger(scroll.hooks.eventTypes.contentChanged, newContent)\n\n    expect(zoom.scale).toBe(1)\n    expect(newContent.style['transform-origin' as any]).toBe('0 0')\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should prevent initial scroll when startScale not equals 1",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 556,
                "column": 64
            },
            "line": 556,
            "code": "  it('should prevent initial scroll when startScale not equals 1', () => {\n    const { wrapper } = createZoomElements()\n    scroll = new BScroll(wrapper, {\n      zoom: {\n        start: 2,\n      },\n    })\n    new Zoom(scroll)\n    const ret = scroll.hooks.trigger(\n      scroll.hooks.eventTypes.beforeInitialScrollTo\n    )\n\n    expect(ret).toBeTruthy()\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should calculate right size when scrollBehavior triggered beforeComputeBoundary hook",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 571,
                "column": 90
            },
            "line": 571,
            "code": "  it('should calculate right size when scrollBehavior triggered beforeComputeBoundary hook', () => {\n    const zoom = new Zoom(scroll)\n    zoom.scale = 1.2\n    const scrollBehaviorX = scroll.scroller.scrollBehaviorX\n    const scrollBehaviorY = scroll.scroller.scrollBehaviorY\n    scrollBehaviorX.hooks.trigger(\n      scrollBehaviorX.hooks.eventTypes.beforeComputeBoundary\n    )\n    scrollBehaviorY.hooks.trigger(\n      scrollBehaviorY.hooks.eventTypes.beforeComputeBoundary\n    )\n\n    expect(scrollBehaviorX.contentSize).toBe(360)\n    expect(scrollBehaviorY.contentSize).toBe(360)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        },
        {
            "name": "should dispatch scrollEnd event when two fingers make bs scroll",
            "suites": [
                "zoom plugin"
            ],
            "updatePoint": {
                "line": 587,
                "column": 69
            },
            "line": 587,
            "code": "  it('should dispatch scrollEnd event when two fingers make bs scroll', () => {\n    new Zoom(scroll)\n    let endScale\n\n    scroll.scroller.actions.hooks.trigger(\n      scroll.scroller.actions.hooks.eventTypes.start,\n      {\n        touches: [\n          {\n            pageX: 1,\n            pageY: 1,\n          },\n          {\n            pageX: 2,\n            pageY: 2,\n          },\n        ],\n      }\n    )\n\n    scroll.on(scroll.eventTypes.zoomEnd, ({ scale }: { scale: number }) => {\n      endScale = scale\n    })\n\n    scroll.scroller.hooks.trigger(scroll.scroller.hooks.eventTypes.scrollEnd)\n\n    expect(endScale).toBe(1)\n  })",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/zoom/src/__tests__"
        }
    ],
    "badge": "ustbhuangyi__better-scroll.svg"
}