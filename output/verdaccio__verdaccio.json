{"repo":"verdaccio/verdaccio","url":"https://github.com/verdaccio/verdaccio","branch":"master","configs":[{"package":"verdaccio-dev","lang":"js","dir":"test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/api","lang":"js","dir":"packages/api/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/auth","lang":"ts","dir":"packages/auth/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/cli","lang":"ts","dir":"packages/cli/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/config","lang":"ts","dir":"packages/config/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/core","lang":"ts","dir":"packages/core/core/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/file-locking","lang":"ts","dir":"packages/core/file-locking/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/readme","lang":"ts","dir":"packages/core/readme/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/streams","lang":"ts","dir":"packages/core/streams/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/tarball","lang":"ts","dir":"packages/core/tarball/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/url","lang":"ts","dir":"packages/core/url/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/hooks","lang":"ts","dir":"packages/hooks/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/loaders","lang":"ts","dir":"packages/loaders/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/logger-prettify","lang":"ts","dir":"packages/logger-prettify/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/logger","lang":"ts","dir":"packages/logger/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/middleware","lang":"ts","dir":"packages/middleware/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/node-api","lang":"ts","dir":"packages/node-api/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/active-directory","lang":"ts","dir":"packages/plugins/active-directory/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-audit","lang":"ts","dir":"packages/plugins/audit/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-auth-memory","lang":"ts","dir":"packages/plugins/auth-memory/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-aws-s3-storage","lang":"ts","dir":"packages/plugins/aws-storage/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-google-cloud","lang":"ts","dir":"packages/plugins/google-cloud-storage/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-htpasswd","lang":"ts","dir":"packages/plugins/htpasswd/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/local-storage","lang":"ts","dir":"packages/plugins/local-storage/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio-memory","lang":"ts","dir":"packages/plugins/memory/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/proxy","lang":"ts","dir":"packages/proxy/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/server","lang":"js","dir":"packages/server/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/store","lang":"ts","dir":"packages/store/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/mock","lang":"ts","dir":"packages/tools/mock/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/utils","lang":"ts","dir":"packages/utils/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"verdaccio","lang":"js","dir":"packages/verdaccio/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@verdaccio/web","lang":"ts","dir":"packages/web/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should run npm install","suites":["install a package"],"updatePoint":{"line":12,"column":30,"index":442},"line":12,"code":"  test('should run npm install', async () => {\n    const projectFolder = createProject('webpack-npm-jest');\n    const resp = await npm('install', 'jest', '--json', ...addNpmPrefix(projectFolder), ...addRegistry(port));\n    expect(resp.stderr).toBeUndefined();\n    const resp2 = await npm('run', 'jest', '--version', ...addNpmPrefix(projectFolder));\n    expect(semver.valid(resp2.stdout)).toBeTruthy();\n  });","file":"e2e-cli/test_bk/install.spec.ts","skipped":false,"dir":"test"},{"name":"should run pnpm install","suites":["install a package"],"updatePoint":{"line":19,"column":31,"index":851},"line":19,"code":"  test('should run pnpm install', async () => {\n    const projectFolder = createProject('webpack-pnpm-test');\n    const resp = await pnpm('install', 'jest@26.6.3', ...addNpmPrefix(projectFolder), ...addRegistry(port));\n    expect(resp.stderr).toBeUndefined(); // TODO: verify package was correctly installed\n  });","file":"e2e-cli/test_bk/install.spec.ts","skipped":false,"dir":"test"},{"name":"should run yarn classic install","suites":["install a package"],"updatePoint":{"line":24,"column":39,"index":1173},"line":24,"code":"  test('should run yarn classic install', async () => {\n    const projectFolder = createProject('jest-yarn-test');\n    const resp = await yarn('add', 'jest@26.6.3', ...addYarnPrefix(projectFolder), ...addRegistry(port));\n    expect(resp.stderr).toBeUndefined();\n    const resp2 = await yarnWithCwd(projectFolder, 'jest', '--version'); // yarn output is to verbose\n\n    expect(resp2.stdout).toMatch(/26.6.3/);\n  });","file":"e2e-cli/test_bk/install.spec.ts","skipped":false,"dir":"test"},{"name":"should match the listing port and load metadata","suites":["install a package"],"updatePoint":{"line":10,"column":55,"index":341},"line":10,"code":"  test('should match the listing port and load metadata', async () => {\n    const body = await callRegistry(`http://localhost:${port}/verdaccio`);\n    const parsedBody = JSON.parse(body);\n    expect(parsedBody.name).toEqual('verdaccio');\n  });","file":"e2e-cli/test_bk/listen.spec.ts","skipped":false,"dir":"test"},{"name":"should run npm search on v1","suites":["search a package"],"updatePoint":{"line":10,"column":35,"index":328},"line":10,"code":"  test('should run npm search on v1', async () => {\n    // await waitOnRegistry(port);\n    const resp = await npm('search', 'verdaccio-memory', '--json', ...addRegistry(port));\n    const {\n      stdout\n    } = resp;\n    const response = JSON.parse(stdout);\n    expect(Array.isArray(response)).toBeTruthy();\n  });","file":"e2e-cli/test_bk/search.spec.ts","skipped":false,"dir":"test"},{"name":"prefix","suites":["registry utils"],"updatePoint":{"line":3,"column":14,"index":99},"line":3,"code":"  test('prefix', () => {\n    expect([...addNpmPrefix('foo')]).toEqual('');\n  });","file":"e2e-cli/utils/registry.spec.ts","skipped":false,"dir":"test"},{"name":"should display title","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":60,"column":28,"index":1809},"line":60,"code":"  test('should display title', async () => {\n    const text = await page.title();\n    await page.waitForTimeout(1000);\n    expect(text).toContain('verdaccio-server-e2e');\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should match title with no packages published","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":66,"column":53,"index":2015},"line":66,"code":"  test('should match title with no packages published', async () => {\n    const text = await page.evaluate(() => document.querySelector('#help-card__title').textContent);\n    expect(text).toMatch('No Package Published Yet.');\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should match title with first step","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":71,"column":42,"index":2240},"line":71,"code":"  test('should match title with first step', async () => {\n    const text = await page.evaluate(() => document.querySelector('#help-card').textContent);\n    expect(text).toContain('npm adduser --registry http://0.0.0.0:55558');\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should match title with second step","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":76,"column":43,"index":2479},"line":76,"code":"  test('should match title with second step', async () => {\n    const text = await page.evaluate(() => document.querySelector('#help-card').textContent);\n    expect(text).toContain('npm publish --registry http://0.0.0.0:55558');\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should match button Login to sign in","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":81,"column":44,"index":2719},"line":81,"code":"  test('should match button Login to sign in', async () => {\n    await evaluateSignIn();\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should click on sign in button","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":85,"column":38,"index":2812},"line":85,"code":"  test('should click on sign in button', async () => {\n    const signInButton = await page.$('button[data-testid=\"header--button-login\"]');\n    await signInButton.click();\n    await page.waitForTimeout(1000);\n    const signInDialog = await page.$('#login--dialog');\n    expect(signInDialog).not.toBeNull();\n    const closeButton = await page.$('button[data-testid=\"close-login-dialog-button\"]');\n    await closeButton.click();\n    await page.waitForTimeout(500);\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should log in an user","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":96,"column":29,"index":3276},"line":96,"code":"  test('should log in an user', async () => {\n    // we open the dialog\n    await logIn(); // verify if logged in\n\n    const accountButton = await page.$('#header--button-account');\n    expect(accountButton).toBeDefined(); // check whether user is logged\n\n    const buttonLogout = await page.$('#logOutDialogIcon');\n    expect(buttonLogout).toBeDefined();\n  });","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should logout an user","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":106,"column":29,"index":3638},"line":106,"code":"  test('should logout an user', async () => {\n    // await wa\n    await page.waitForTimeout(10000); // we assume the user is logged already\n\n    await clickElement('#header--button-account', {\n      delay: 500\n    });\n    await page.waitForTimeout(1000);\n    await clickElement('#logOutDialogIcon > span', {\n      delay: 500\n    });\n    await page.waitForTimeout(1000);\n    await evaluateSignIn();\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should publish a package","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":121,"column":32,"index":4049},"line":121,"code":"  test('should publish a package', async () => {\n    await global.__SERVER__.putPackage(scopedPackageMetadata.name, scopedPackageMetadata);\n    await page.waitForTimeout(1000);\n    await page.reload();\n    await page.waitForTimeout(1000);\n    const packagesList = await getPackages();\n    expect(packagesList).toHaveLength(1);\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should navigate to the package detail","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":130,"column":45,"index":4399},"line":130,"code":"  test('should navigate to the package detail', async () => {\n    const packagesList = await getPackages(); // console.log(\"-->packagesList:\", packagesList);\n\n    const firstPackage = packagesList[0];\n    await firstPackage.click({\n      delay: 200\n    });\n    await page.waitForTimeout(1000);\n    const readmeText = await page.evaluate(() => document.querySelector('.markdown-body').textContent);\n    expect(readmeText).toMatch('test');\n  });","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should contains last sync information","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":141,"column":45,"index":4843},"line":141,"code":"  test('should contains last sync information', async () => {\n    const versionList = await page.$$('.sidebar-info .detail-info');\n    expect(versionList).toHaveLength(1);\n  }); //","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should display dependencies tab","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":146,"column":39,"index":5019},"line":146,"code":"  test('should display dependencies tab', async () => {\n    const dependenciesTab = await page.$$('#dependencies-tab');\n    expect(dependenciesTab).toHaveLength(1);\n    await dependenciesTab[0].click({\n      delay: 200\n    });\n    await page.waitForTimeout(1000);\n    const tags = await page.$$('.dep-tag');\n    const tag = tags[0];\n    const label = await page.evaluate(el => el.innerText, tag);\n    expect(label).toMatch('verdaccio@');\n  });","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should display version tab","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":158,"column":34,"index":5458},"line":158,"code":"  test('should display version tab', async () => {\n    const versionsTab = await page.$$('#versions-tab');\n    expect(versionsTab).toHaveLength(1);\n    await versionsTab[0].click({\n      delay: 200\n    });\n    await page.waitForTimeout(1000);\n    const versionItems = await page.$$('.version-item');\n    expect(versionItems).toHaveLength(2);\n  });","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should display uplinks tab","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":168,"column":34,"index":5806},"line":168,"code":"  test('should display uplinks tab', async () => {\n    const upLinksTab = await page.$$('#uplinks-tab');\n    expect(upLinksTab).toHaveLength(1);\n    await upLinksTab[0].click({\n      delay: 200\n    });\n    await page.waitForTimeout(1000);\n  });","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should display readme tab","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":176,"column":33,"index":6050},"line":176,"code":"  test('should display readme tab', async () => {\n    const readmeTab = await page.$$('#readme-tab');\n    expect(readmeTab).toHaveLength(1);\n    await readmeTab[0].click({\n      delay: 200\n    });\n    await page.waitForTimeout(1000);\n  });","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should publish a protected package","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":184,"column":42,"index":6299},"line":184,"code":"  test('should publish a protected package', async () => {\n    await page.goto('http://0.0.0.0:55552');\n    await page.waitForTimeout(500);\n    await global.__SERVER_PROTECTED__.putPackage(protectedPackageMetadata.name, protectedPackageMetadata);\n    await page.waitForTimeout(500);\n    await page.reload();\n    await page.waitForTimeout(500);\n    const text = await page.evaluate(() => document.querySelector('#help-card__title').textContent);\n    expect(text).toMatch('No Package Published Yet');\n  });","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should go to 404 page","suites":["/ (Verdaccio Page)"],"updatePoint":{"line":194,"column":29,"index":6791},"line":194,"code":"  test('should go to 404 page', async () => {\n    await page.goto('http://0.0.0.0:55552/-/web/detail/@verdaccio/not-found');\n    await page.waitForTimeout(500);\n    const text = await page.evaluate(() => document.querySelector('.not-found-text').textContent);\n    expect(text).toMatch(\"Sorry, we couldn't find it...\");\n  });","file":"e2e-ui/e2e.spec.js","skipped":false,"dir":"test"},{"name":"should return a package","suites":["package"],"updatePoint":{"line":37,"column":31,"index":886},"line":37,"code":"  test('should return a package', async () => {\n    await publishVersion(app, 'package.yaml', 'foo', '1.0.0');\n    return new Promise(resolve => {\n      supertest(app).get('/foo').set('Accept', HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).then(response => {\n        expect(response.body.name).toEqual('foo');\n        resolve(response);\n      });\n    });\n  });","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return a package by version","suites":["package"],"updatePoint":{"line":46,"column":42,"index":1304},"line":46,"code":"  test('should return a package by version', async () => {\n    await publishVersion(app, 'package.yaml', 'foo2', '1.0.0');\n    return new Promise(resolve => {\n      supertest(app).get('/foo2/1.0.0').set('Accept', HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).then(response => {\n        expect(response.body.name).toEqual('foo2');\n        resolve(response);\n      });\n    });\n  }); // FIXME: investigate the 404","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return a package by dist-tag","suites":["package"],"line":56,"code":"  test.skip('should return a package by dist-tag', async done => {","file":"integration/package.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"should return 404","suites":["package"],"updatePoint":{"line":65,"column":25,"index":2292},"line":65,"code":"  test('should return 404', async () => {\n    return supertest(app).get('/404-not-found').set('Accept', HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.NOT_FOUND);\n  });","file":"integration/package.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should return the reply the ping","suites":["ping"],"updatePoint":{"line":5,"column":40,"index":216},"line":5,"code":"  test('should return the reply the ping', async () => {\n    return supertest(await initializeServer('ping.yaml')).get('/-/ping').set('Accept', HEADERS.JSON).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).then(response => expect(response.body).toEqual({}));\n  });","file":"integration/ping.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fail on publish a bad _attachments package","suites":["publish","handle invalid publish formats"],"line":61,"code":"    test.skip('should fail on publish a bad _attachments package', async done => {","file":"integration/publish.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"should fail on publish a bad versions package","suites":["publish","handle invalid publish formats"],"updatePoint":{"line":71,"column":55,"index":2246},"line":71,"code":"    test('should fail on publish a bad versions package', async () => {\n      const app = await initializeServer('publish.yaml');\n      return new Promise(resolve => {\n        supertest(app).put(`/${encodeURIComponent(pkgName)}`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify(Object.assign({}, pkgMetadata, {\n          versions: ''\n        }))).set('accept', HEADERS.GZIP).expect(HTTP_STATUS.BAD_REQUEST).then(response => {\n          console.log('response.body', response.body);\n          expect(response.body.error).toEqual(API_ERROR.UNSUPORTED_REGISTRY_CALL);\n          resolve(response);\n        });\n      });\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should publish a package","suites":["publish","publish a package"],"updatePoint":{"line":85,"column":34,"index":2910},"line":85,"code":"    test('should publish a package', async () => {\n      const app = await initializeServer('publish.yaml');\n      return new Promise(resolve => {\n        publishVersion(app, 'publish.yaml', 'foo', '1.0.0').expect(HTTP_STATUS.CREATED).then(response => {\n          expect(response.body.ok).toEqual(API_MESSAGE.PKG_CREATED);\n          resolve(response);\n        });\n      });\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should publish a new package","suites":["publish","publish a package"],"updatePoint":{"line":94,"column":38,"index":3296},"line":94,"code":"    test('should publish a new package', async () => {\n      const pkgName = 'test';\n      const pkgMetadata = generatePackageMetadata(pkgName, '1.0.0');\n      const app = await initializeServer('publish.yaml');\n      return new Promise(resolve => {\n        supertest(app).put(`/${encodeURIComponent(pkgName)}`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify(Object.assign({}, pkgMetadata, {\n          _attachments: null\n        }))).set('accept', HEADERS.GZIP).expect(HTTP_STATUS.CREATED).then(response => {\n          expect(response.body.ok).toEqual(API_MESSAGE.PKG_CREATED);\n          resolve(response);\n        });\n      });\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should publish a new package with no readme","suites":["publish","publish a package"],"updatePoint":{"line":107,"column":53,"index":3965},"line":107,"code":"    test('should publish a new package with no readme', async () => {\n      const pkgName = 'test';\n      const pkgMetadata = generatePackageMetadata(pkgName, '1.0.0');\n      const app = await initializeServer('publish.yaml');\n      return new Promise(resolve => {\n        supertest(app).put(`/${encodeURIComponent(pkgName)}`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify(Object.assign({}, pkgMetadata, {\n          versions: {\n            ['1.0.0']: {\n              readme: null\n            }\n          }\n        }))).set('accept', HEADERS.GZIP).expect(HTTP_STATUS.CREATED).then(response => {\n          expect(response.body.ok).toEqual(API_MESSAGE.PKG_CREATED);\n          resolve(response);\n        });\n      });\n    });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should fails on publish a duplicated package","suites":["publish","publish a package"],"updatePoint":{"line":125,"column":52,"index":4710},"line":125,"code":"  test('should fails on publish a duplicated package', async () => {\n    const app = await initializeServer('publish.yaml');\n    await publishVersion(app, 'publish.yaml', 'foo', '1.0.0');\n    return new Promise(resolve => {\n      publishVersion(app, 'publish.yaml', 'foo', '1.0.0').expect(HTTP_STATUS.CONFLICT).then(response => {\n        console.log('response.body', response.body);\n        expect(response.body.error).toEqual(API_ERROR.PACKAGE_EXIST);\n        resolve(response);\n      });\n    });\n  });","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should unpublish a package","suites":["publish","unpublish a package"],"updatePoint":{"line":142,"column":36,"index":5407},"line":142,"code":"    test('should unpublish a package', () => {});","file":"integration/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should test add a new user","suites":["user"],"updatePoint":{"line":47,"column":34,"index":1261},"line":47,"code":"  test('should test add a new user', async () => {\n    mockApiJWTmiddleware.mockImplementationOnce(() => (req, res, _next) => {\n      req.remote_user = {\n        name: undefined\n      };\n\n      _next();\n    });\n    mockAddUser.mockImplementationOnce(() => (_name, _password, callback) => {\n      return callback(null, true);\n    });\n    const app = await initializeServer('user.yaml');\n    return new Promise((resolve, reject) => {\n      supertest(app).put(`/-/user/org.couchdb.user:newUser`).send({\n        name: 'newUser',\n        password: 'newUser'\n      }).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        expect(res.body.ok).toBeDefined();\n        expect(res.body.token).toBeDefined();\n        const token = res.body.token;\n        expect(typeof token).toBe('string');\n        expect(res.body.ok).toMatch(`user 'newUser' created`);\n        resolve(null);\n      });\n    });\n  });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should test fails on add a existing user with login","suites":["user"],"updatePoint":{"line":77,"column":59,"index":2299},"line":77,"code":"  test('should test fails on add a existing user with login', async () => {\n    mockApiJWTmiddleware.mockImplementationOnce(() => (req, res, _next) => {\n      req.remote_user = {\n        name: undefined\n      };\n\n      _next();\n    });\n    const app = await initializeServer('user.yaml');\n    return new Promise((resolve, reject) => {\n      supertest(app).put('/-/user/org.couchdb.user:jotaNew').send(credentials).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CONFLICT).end(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        expect(res.body.error).toBeDefined();\n        expect(res.body.error).toMatch(API_ERROR.USERNAME_ALREADY_REGISTERED);\n        resolve(res.body);\n      });\n    });\n  });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should log in as existing user","suites":["user"],"updatePoint":{"line":98,"column":38,"index":3038},"line":98,"code":"  test('should log in as existing user', async () => {\n    const app = await initializeServer('user.yaml');\n    return new Promise((resolve, reject) => {\n      supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send(credentials).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CREATED).end((err, res) => {\n        if (err) {\n          return reject(err);\n        }\n\n        expect(res.body).toBeTruthy();\n        expect(res.body.ok).toMatch(`you are authenticated as \\'${credentials.name}\\'`);\n        resolve(res);\n      });\n    });\n  });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should test fails add a new user with missing name","suites":["user"],"updatePoint":{"line":112,"column":58,"index":3640},"line":112,"code":"  test('should test fails add a new user with missing name', async () => {\n    mockApiJWTmiddleware.mockImplementationOnce(() => (req, res, _next) => {\n      req.remote_user = {\n        name: undefined\n      };\n\n      _next();\n    });\n    mockAddUser.mockImplementationOnce(() => (_name, _password, callback) => {\n      return callback(errorUtils.getBadRequest(API_ERROR.USERNAME_PASSWORD_REQUIRED));\n    });\n\n    const credentialsShort = _.cloneDeep(credentials);\n\n    delete credentialsShort.name;\n    const app = await initializeServer('user.yaml');\n    return new Promise((resolve, reject) => {\n      supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send(credentialsShort).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.BAD_REQUEST).end(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        expect(res.body.error).toBeDefined();\n        expect(res.body.error).toMatch(API_ERROR.USERNAME_PASSWORD_REQUIRED);\n        resolve(app);\n      });\n    });\n  });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should test fails add a new user with missing password","suites":["user"],"updatePoint":{"line":140,"column":62,"index":4682},"line":140,"code":"  test('should test fails add a new user with missing password', async () => {\n    mockApiJWTmiddleware.mockImplementationOnce(() => (req, res, _next) => {\n      req.remote_user = {\n        name: undefined\n      };\n\n      _next();\n    });\n\n    const credentialsShort = _.cloneDeep(credentials);\n\n    delete credentialsShort.password;\n    const app = await initializeServer('user.yaml');\n    return new Promise((resolve, reject) => {\n      supertest(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send(credentialsShort).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.BAD_REQUEST).end(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        expect(res.body.error).toBeDefined(); // FIXME: message is not 100% accurate\n        // eslint-disable-next-line new-cap\n\n        expect(res.body.error).toMatch(API_ERROR.PASSWORD_SHORT());\n        resolve(res);\n      });\n    });\n  });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should test fails add a new user with wrong password","suites":["user"],"updatePoint":{"line":167,"column":60,"index":5626},"line":167,"code":"  test('should test fails add a new user with wrong password', async () => {\n    mockApiJWTmiddleware.mockImplementationOnce(() => (req, res, _next) => {\n      req.remote_user = {\n        name: 'test'\n      };\n\n      _next();\n    });\n    mockAuthenticate.mockImplementationOnce(() => (_name, _password, callback) => {\n      return callback(errorUtils.getUnauthorized(API_ERROR.BAD_USERNAME_PASSWORD));\n    });\n\n    const credentialsShort = _.cloneDeep(credentials);\n\n    credentialsShort.password = 'failPassword';\n    const app = await initializeServer('user.yaml');\n    return new Promise((resolve, reject) => {\n      supertest(app).put('/-/user/org.couchdb.user:test').send(credentialsShort).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.UNAUTHORIZED).end(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        expect(res.body.error).toBeDefined();\n        expect(res.body.error).toMatch(API_ERROR.BAD_USERNAME_PASSWORD);\n        resolve(res);\n      });\n    });\n  });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should be able to logout an user","suites":["user"],"updatePoint":{"line":195,"column":40,"index":6640},"line":195,"code":"  test('should be able to logout an user', async () => {\n    mockApiJWTmiddleware.mockImplementationOnce(() => (req, _res, _next) => {\n      req.remote_user = {\n        name: 'test'\n      };\n\n      _next();\n    });\n    mockAuthenticate.mockImplementationOnce(() => (_name, _password, callback) => {\n      return callback(errorUtils.getUnauthorized(API_ERROR.BAD_USERNAME_PASSWORD));\n    });\n\n    const credentialsShort = _.cloneDeep(credentials);\n\n    credentialsShort.password = 'failPassword';\n    const app = await initializeServer('user.yaml');\n    return new Promise((resolve, reject) => {\n      supertest(app).delete('/-/user/token/someSecretToken').send(credentialsShort).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).end(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n\n        expect(res.body.ok).toMatch(API_MESSAGE.LOGGED_OUT);\n        resolve(res);\n      });\n    });\n  });","file":"integration/user.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should test referer /whoami endpoint","suites":["whoami"],"line":27,"code":"  test.skip('should test referer /whoami endpoint', async done => {","file":"integration/whoami.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"should test no referer /whoami endpoint","suites":["whoami"],"line":30,"code":"  test.skip('should test no referer /whoami endpoint', async done => {","file":"integration/whoami.spec.ts","skipped":true,"dir":"packages/api/test"},{"name":"should return the logged username","suites":["whoami"],"updatePoint":{"line":33,"column":41,"index":1031},"line":33,"code":"  test('should return the logged username', async () => {\n    return supertest(await initializeServer('whoami.yaml')).get('/-/whoami').set('Accept', HEADERS.JSON).expect('Content-Type', HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).then(response => {\n      expect(response.body.username).toEqual('foo');\n    });\n  });","file":"integration/whoami.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should add a version","suites":["Publish endpoints - add a tag"],"updatePoint":{"line":29,"column":28,"index":672},"line":29,"code":"  test('should add a version', done => {\n    const storage = {\n      addVersion: (packageName, version, body, tag, cb) => {\n        expect(packageName).toEqual(req.params.package);\n        expect(version).toEqual(req.params.version);\n        expect(body).toEqual(req.body);\n        expect(tag).toEqual(req.params.tag);\n        cb();\n        done();\n      }\n    }; // @ts-ignore\n\n    addVersion(storage)(req, res, next);\n    expect(res.status).toHaveBeenLastCalledWith(HTTP_STATUS.CREATED);\n    expect(next).toHaveBeenLastCalledWith({\n      ok: 'package published'\n    });\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"when failed to add a version","suites":["Publish endpoints - add a tag"],"updatePoint":{"line":47,"column":36,"index":1258},"line":47,"code":"  test('when failed to add a version', done => {\n    const storage = {\n      addVersion: (packageName, version, body, tag, cb) => {\n        const error = {\n          message: 'failure'\n        };\n        cb(error);\n        done();\n      }\n    }; // @ts-ignore\n\n    addVersion(storage)(req, res, next);\n    expect(next).toHaveBeenLastCalledWith({\n      message: 'failure'\n    });\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should upload package tarball successfully","suites":["Publish endpoints - upload package tarball"],"updatePoint":{"line":89,"column":50,"index":2113},"line":89,"code":"  test('should upload package tarball successfully', () => {\n    const stream = {\n      done: jest.fn(),\n      abort: jest.fn(),\n      on: jest.fn(() => (status, cb) => cb())\n    };\n    const storage = {\n      addTarball(packageName, filename) {\n        expect(packageName).toEqual(req.params.package);\n        expect(filename).toEqual(req.params.filename);\n        return stream;\n      }\n\n    }; // @ts-ignore\n\n    uploadPackageTarball(storage)(req, res, next);\n    expect(req.pipe).toHaveBeenCalled();\n    expect(req.on).toHaveBeenCalled();\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should delete tarball successfully","suites":["Publish endpoints - delete tarball"],"updatePoint":{"line":130,"column":42,"index":3047},"line":130,"code":"  test('should delete tarball successfully', done => {\n    const storage = {\n      removeTarball(packageName, filename, revision, cb) {\n        expect(packageName).toEqual(req.params.package);\n        expect(filename).toEqual(req.params.filename);\n        expect(revision).toEqual(req.params.revision);\n        cb();\n        done();\n      }\n\n    }; // @ts-ignore\n\n    removeTarball(storage)(req, res, next);\n    expect(res.status).toHaveBeenCalledWith(HTTP_STATUS.CREATED);\n    expect(next).toHaveBeenCalledWith({\n      ok: 'tarball removed'\n    });\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"failed while deleting the tarball","suites":["Publish endpoints - delete tarball"],"updatePoint":{"line":148,"column":41,"index":3602},"line":148,"code":"  test('failed while deleting the tarball', done => {\n    const error = {\n      message: 'deletion failed'\n    };\n    const storage = {\n      removeTarball(packageName, filename, revision, cb) {\n        cb(error);\n        done();\n      }\n\n    }; // @ts-ignore\n\n    removeTarball(storage)(req, res, next);\n    expect(next).toHaveBeenCalledWith(error);\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should un-publish package successfully","suites":["Publish endpoints - un-publish package"],"updatePoint":{"line":183,"column":46,"index":4276},"line":183,"code":"  test('should un-publish package successfully', async () => {\n    const storage = {\n      removePackage(packageName) {\n        expect(packageName).toEqual(req.params.package);\n        return Promise.resolve();\n      }\n\n    }; // @ts-ignore\n\n    await unPublishPackage(storage)(req, res, next);\n    expect(res.status).toHaveBeenCalledWith(HTTP_STATUS.CREATED);\n    expect(next).toHaveBeenCalledWith({\n      ok: 'package removed'\n    });\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"un-publish failed","suites":["Publish endpoints - un-publish package"],"updatePoint":{"line":198,"column":25,"index":4698},"line":198,"code":"  test('un-publish failed', async () => {\n    const storage = {\n      removePackage(packageName) {\n        expect(packageName).toEqual(req.params.package);\n        return Promise.reject(errorUtils.getInternalError());\n      }\n\n    }; // @ts-ignore\n\n    await unPublishPackage(storage)(req, res, next);\n    expect(next).toHaveBeenCalledWith(errorUtils.getInternalError());\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should change the existing package","suites":["Publish endpoints - publish package"],"updatePoint":{"line":233,"column":42,"index":5459},"line":233,"code":"  test('should change the existing package', () => {\n    const storage = {\n      changePackage: jest.fn()\n    };\n    req.params._rev = REVISION_MOCK; // @ts-ignore\n\n    publishPackage(storage)(req, res, next);\n    expect(storage.changePackage).toMatchSnapshot();\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should publish a new a new package","suites":["Publish endpoints - publish package"],"updatePoint":{"line":242,"column":42,"index":5728},"line":242,"code":"  test('should publish a new a new package', () => {\n    const storage = {\n      addPackage: jest.fn()\n    }; // @ts-ignore\n\n    publishPackage(storage)(req, res, next);\n    expect(storage.addPackage).toMatchSnapshot();\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should throw an error while publishing package","suites":["Publish endpoints - publish package"],"updatePoint":{"line":250,"column":54,"index":5966},"line":250,"code":"  test('should throw an error while publishing package', () => {\n    const storage = {\n      addPackage() {\n        throw new Error();\n      }\n\n    }; // @ts-ignore\n\n    publishPackage(storage)(req, res, next);\n    expect(next).toHaveBeenCalledWith(new Error(API_ERROR.BAD_PACKAGE_DATA));\n  });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should star a package","suites":["Publish endpoints - publish package","test start"],"updatePoint":{"line":262,"column":31,"index":6271},"line":262,"code":"    test('should star a package', () => {\n      const storage = {\n        changePackage: jest.fn(),\n\n        getPackage({\n          callback\n        }) {\n          callback(null, {\n            users: {}\n          });\n        }\n\n      };\n      req = {\n        params: {\n          package: 'verdaccio'\n        },\n        body: {\n          _rev: REVISION_MOCK,\n          users: {\n            verdaccio: true\n          }\n        },\n        remote_user: {\n          name: 'verdaccio'\n        }\n      }; // @ts-ignore\n\n      publishPackage(storage)(req, res, next);\n      expect(storage.changePackage).toMatchSnapshot();\n    });","file":"unit/publish.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"should validate \":%s\"","suites":["api endpoint app.param()"],"line":40,"code":"  test.each(Object.keys(appParams))('should validate \":%s\"', param => {\n    expect(appParams[param]).toEqual('ok');\n  });","file":"unit/validate.api.params.middleware.spec.ts","skipped":false,"dir":"packages/api/test"},{"name":"authentication should fail by default (default)","suites":["Auth utilities","getDefaultPlugins"],"updatePoint":{"line":113,"column":57},"line":113,"code":"    test('authentication should fail by default (default)', () => {\n      const plugin = getDefaultPlugins({ trace: jest.fn() });\n      plugin.authenticate('foo', 'bar', (error: any) => {\n        expect(error).toEqual(errorUtils.getForbidden(API_ERROR.BAD_USERNAME_PASSWORD));\n      });\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"add user should fail by default (default)","suites":["Auth utilities","getDefaultPlugins"],"updatePoint":{"line":120,"column":51},"line":120,"code":"    test('add user should fail by default (default)', () => {\n      const plugin = getDefaultPlugins({ trace: jest.fn() });\n      // @ts-ignore\n      plugin.adduser('foo', 'bar', (error: any) => {\n        expect(error).toEqual(errorUtils.getForbidden(API_ERROR.BAD_USERNAME_PASSWORD));\n      });\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should restrict %s to anonymous users","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":139,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should restrict %s to anonymous users',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createAnonymousRemoteUser(),\n            {\n              ...packageAccess,\n              [type]: ['foo'],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).not.toBeNull();\n              expect(allowed).toBeUndefined();\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should allow %s to anonymous users","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":156,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should allow %s to anonymous users',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createAnonymousRemoteUser(),\n            {\n              ...packageAccess,\n              [type]: [ROLES.$ANONYMOUS],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).toBeNull();\n              expect(allowed).toBe(true);\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should allow %s only if user is anonymous if the logged user has groups","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":173,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should allow %s only if user is anonymous if the logged user has groups',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createRemoteUser('juan', ['maintainer', 'admin']),\n            {\n              ...packageAccess,\n              [type]: [ROLES.$ANONYMOUS],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).not.toBeNull();\n              expect(allowed).toBeUndefined();\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should allow %s only if user is anonymous match any other groups","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":190,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should allow %s only if user is anonymous match any other groups',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createRemoteUser('juan', ['maintainer', 'admin']),\n            {\n              ...packageAccess,\n              [type]: ['admin', 'some-other-group', ROLES.$ANONYMOUS],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).toBeNull();\n              expect(allowed).toBe(true);\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should not allow %s anonymous if other groups are defined and does not match","suites":["Auth utilities","allow_action","access/publish/unpublish and anonymous"],"line":207,"code":"      test.each(['access', 'publish', 'unpublish'])(\n        'should not allow %s anonymous if other groups are defined and does not match',\n        (type) => {\n          allow_action(type as ActionsAllowed, { trace: jest.fn() })(\n            createRemoteUser('juan', ['maintainer', 'admin']),\n            {\n              ...packageAccess,\n              [type]: ['bla-bla-group', 'some-other-group', ROLES.$ANONYMOUS],\n            },\n            (error: VerdaccioError | null, allowed: AllowActionCallbackResponse) => {\n              expect(error).not.toBeNull();\n              expect(allowed).toBeUndefined();\n            }\n          );\n        }\n      );","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with aes and security missing","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":227,"column":57},"line":227,"code":"    test('should sign token with aes and security missing', async () => {\n      const token = await getTokenByConfiguration(\n        'security-missing',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'aesEncrypt',\n        'jwtEncrypt'\n      );\n\n      verifyAES(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n      expect(_.isString(token)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with aes and security empty","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":241,"column":55},"line":241,"code":"    test('should sign token with aes and security empty', async () => {\n      const token = await getTokenByConfiguration(\n        'security-empty',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'aesEncrypt',\n        'jwtEncrypt'\n      );\n\n      verifyAES(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n      expect(_.isString(token)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with aes","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":255,"column":36},"line":255,"code":"    test('should sign token with aes', async () => {\n      const token = await getTokenByConfiguration(\n        'security-basic',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'aesEncrypt',\n        'jwtEncrypt'\n      );\n\n      verifyAES(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n      expect(_.isString(token)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with legacy and jwt disabled","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":269,"column":56},"line":269,"code":"    test('should sign token with legacy and jwt disabled', async () => {\n      const token = await getTokenByConfiguration(\n        'security-no-legacy',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'aesEncrypt',\n        'jwtEncrypt'\n      );\n\n      expect(_.isString(token)).toBeTruthy();\n      verifyAES(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with legacy enabled and jwt enabled","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":283,"column":63},"line":283,"code":"    test('should sign token with legacy enabled and jwt enabled', async () => {\n      const token = await getTokenByConfiguration(\n        'security-jwt-legacy-enabled',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'jwtEncrypt',\n        'aesEncrypt'\n      );\n\n      verifyJWT(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n      expect(_.isString(token)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with jwt enabled","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":297,"column":44},"line":297,"code":"    test('should sign token with jwt enabled', async () => {\n      const token = await getTokenByConfiguration(\n        'security-jwt',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'jwtEncrypt',\n        'aesEncrypt'\n      );\n\n      expect(_.isString(token)).toBeTruthy();\n      verifyJWT(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign with jwt whether legacy is disabled","suites":["Auth utilities","getApiToken test"],"updatePoint":{"line":311,"column":57},"line":311,"code":"    test('should sign with jwt whether legacy is disabled', async () => {\n      const token = await getTokenByConfiguration(\n        'security-legacy-disabled',\n        'test',\n        'test',\n        'b2df428b9929d3ace7c598bbf4e496b2',\n        'jwtEncrypt',\n        'aesEncrypt'\n      );\n\n      expect(_.isString(token)).toBeTruthy();\n      verifyJWT(token, 'test', 'test', 'b2df428b9929d3ace7c598bbf4e496b2');\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should sign token with jwt enabled","suites":["Auth utilities","getAuthenticatedMessage test"],"updatePoint":{"line":327,"column":44},"line":327,"code":"    test('should sign token with jwt enabled', () => {\n      expect(getAuthenticatedMessage('test')).toBe(\"you are authenticated as 'test'\");\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should fail on verify the token and return anonymous users","suites":["Auth utilities","getMiddlewareCredentials test","verifyJWTPayload"],"updatePoint":{"line":428,"column":70},"line":428,"code":"      test('should fail on verify the token and return anonymous users', () => {\n        expect(verifyJWTPayload('fakeToken', 'b2df428b9929d3ace7c598bbf4e496b2')).toEqual(\n          createAnonymousRemoteUser()\n        );\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should verify the token and return a remote user","suites":["Auth utilities","getMiddlewareCredentials test","verifyJWTPayload"],"updatePoint":{"line":434,"column":60},"line":434,"code":"      test('should verify the token and return a remote user', async () => {\n        const remoteUser = createRemoteUser('foo', []);\n        const token = await signPayload(remoteUser, '12345');\n        const verifiedToken = verifyJWTPayload(token, '12345');\n        expect(verifiedToken.groups).toEqual(remoteUser.groups);\n        expect(verifiedToken.name).toEqual(remoteUser.name);\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should return anonymous whether token is corrupted","suites":["Auth utilities","getMiddlewareCredentials test","should get JWT credentials"],"updatePoint":{"line":444,"column":62},"line":444,"code":"      test('should return anonymous whether token is corrupted', () => {\n        const config: Config = getConfig('security-jwt', '12345');\n        const security: Security = config.security;\n        const credentials = getMiddlewareCredentials(\n          security,\n          '12345',\n          buildToken(TOKEN_BEARER, 'fakeToken')\n        );\n\n        expect(credentials).toBeDefined();\n        // @ts-ignore\n        expect(credentials.name).not.toBeDefined();\n        // @ts-ignore\n        expect(credentials.real_groups).toBeDefined();\n        // @ts-ignore\n        expect(credentials.real_groups).toEqual([]);\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should return anonymous whether token and scheme are corrupted","suites":["Auth utilities","getMiddlewareCredentials test","should get JWT credentials"],"updatePoint":{"line":462,"column":74},"line":462,"code":"      test('should return anonymous whether token and scheme are corrupted', () => {\n        const config: Config = getConfig('security-jwt', '12345');\n        const security: Security = config.security;\n        const credentials = getMiddlewareCredentials(\n          security,\n          '12345',\n          buildToken('FakeScheme', 'fakeToken')\n        );\n\n        expect(credentials).not.toBeDefined();\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should verify successfully a JWT token","suites":["Auth utilities","getMiddlewareCredentials test","should get JWT credentials"],"updatePoint":{"line":474,"column":50},"line":474,"code":"      test('should verify successfully a JWT token', async () => {\n        const secret = 'b2df428b9929d3ace7c598bbf4e496b2';\n        const user = 'test';\n        const config: Config = getConfig('security-jwt', secret);\n        const token = await getTokenByConfiguration(\n          'security-jwt',\n          user,\n          'secretTest',\n          secret,\n          'jwtEncrypt',\n          'aesEncrypt'\n        );\n        const security: Security = config.security;\n        const credentials = getMiddlewareCredentials(\n          security,\n          secret,\n          buildToken(TOKEN_BEARER, token)\n        );\n        expect(credentials).toBeDefined();\n        // @ts-ignore\n        expect(credentials.name).toEqual(user);\n        // @ts-ignore\n        expect(credentials.real_groups).toBeDefined();\n        // @ts-ignore\n        expect(credentials.real_groups).toEqual([]);\n      });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should be defined","suites":["AuthTest"],"updatePoint":{"line":15,"column":25},"line":15,"code":"  test('should be defined', () => {\n    const config: Config = new AppConfig(_.cloneDeep(authProfileConf));\n    config.checkSecretKey('12345');\n\n    const auth: IAuth = new Auth(config);\n\n    expect(auth).toBeDefined();\n  });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should be a success login","suites":["AuthTest","test authenticate method","test authenticate states"],"updatePoint":{"line":26,"column":37},"line":26,"code":"      test('should be a success login', () => {\n        const config: Config = new AppConfig(_.cloneDeep(authProfileConf));\n        config.checkSecretKey('12345');\n        const auth: IAuth = new Auth(config);\n\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n        const groups = ['test'];\n\n        auth.authenticate('foo', 'bar', callback);\n\n        expect(callback).toHaveBeenCalledTimes(1);\n        expect(callback).toHaveBeenCalledWith(null, {\n          groups: [\n            'test',\n            ROLES.$ALL,\n            ROLES.$AUTH,\n            ROLES.DEPRECATED_ALL,\n            ROLES.DEPRECATED_AUTH,\n            ROLES.ALL,\n          ],\n          name: 'foo',\n          real_groups: groups,\n        });\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should be a fail on login","suites":["AuthTest","test authenticate method","test authenticate states"],"updatePoint":{"line":53,"column":37},"line":53,"code":"      test('should be a fail on login', () => {\n        const config: Config = new AppConfig(_.cloneDeep(authPluginFailureConf));\n        config.checkSecretKey('12345');\n        const auth: IAuth = new Auth(config);\n\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n\n        auth.authenticate('foo', 'bar', callback);\n        expect(callback).toHaveBeenCalledTimes(1);\n        expect(callback).toHaveBeenCalledWith(errorUtils.getInternalError());\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should skip falsy values","suites":["AuthTest","test authenticate method","test authenticate out of control inputs from plugins"],"updatePoint":{"line":72,"column":36},"line":72,"code":"      test('should skip falsy values', () => {\n        const config: Config = new AppConfig(_.cloneDeep(authPluginPassThrougConf));\n        config.checkSecretKey('12345');\n        const auth: IAuth = new Auth(config);\n\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n        let index = 0;\n\n        // as defined by https://developer.mozilla.org/en-US/docs/Glossary/Falsy\n        for (const value of [false, 0, '', null, undefined, NaN]) {\n          // @ts-ignore\n          auth.authenticate(null, value, callback);\n          const call = callback.mock.calls[index++];\n          expect(call[0]).toBeDefined();\n          expect(call[1]).toBeUndefined();\n        }\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should error truthy non-array","suites":["AuthTest","test authenticate method","test authenticate out of control inputs from plugins"],"updatePoint":{"line":92,"column":41},"line":92,"code":"      test('should error truthy non-array', () => {\n        const config: Config = new AppConfig(_.cloneDeep(authPluginPassThrougConf));\n        config.checkSecretKey('12345');\n        const auth: IAuth = new Auth(config);\n\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n\n        for (const value of [true, 1, 'test', {}]) {\n          expect(function () {\n            // @ts-ignore\n            auth.authenticate(null, value, callback);\n          }).toThrow(TypeError);\n          expect(callback).not.toHaveBeenCalled();\n        }\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should skip empty array","suites":["AuthTest","test authenticate method","test authenticate out of control inputs from plugins"],"updatePoint":{"line":110,"column":35},"line":110,"code":"      test('should skip empty array', () => {\n        const config: Config = new AppConfig(_.cloneDeep(authPluginPassThrougConf));\n        config.checkSecretKey('12345');\n        const auth: IAuth = new Auth(config);\n\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n        const value = [];\n\n        // @ts-ignore\n        auth.authenticate(null, value, callback);\n        expect(callback.mock.calls).toHaveLength(1);\n        expect(callback.mock.calls[0][0]).toBeDefined();\n        expect(callback.mock.calls[0][1]).toBeUndefined();\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"should accept valid array","suites":["AuthTest","test authenticate method","test authenticate out of control inputs from plugins"],"updatePoint":{"line":127,"column":37},"line":127,"code":"      test('should accept valid array', () => {\n        const config: Config = new AppConfig(_.cloneDeep(authPluginPassThrougConf));\n        config.checkSecretKey('12345');\n        const auth: IAuth = new Auth(config);\n\n        expect(auth).toBeDefined();\n\n        const callback = jest.fn();\n        let index = 0;\n\n        for (const value of [[''], ['1'], ['0'], ['000']]) {\n          // @ts-ignore\n          auth.authenticate(null, value, callback);\n          const call = callback.mock.calls[index++];\n          expect(call[0]).toBeNull();\n          expect(call[1].real_groups).toBe(value);\n        }\n      });","file":"auth.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"decrypt payload flow","suites":["test crypto utils"],"updatePoint":{"line":4,"column":28},"line":4,"code":"  test('decrypt payload flow', () => {\n    const secret = 'f5bb945cc57fea2f25961e1bd6fb3c89';\n    const payload = 'juan:password';\n    const token = aesEncrypt(payload, secret) as string;\n    const data = aesDecrypt(token, secret);\n\n    expect(payload).toEqual(data);\n  });","file":"legacy-token.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"crypt fails if secret is incorrect","suites":["test crypto utils"],"updatePoint":{"line":13,"column":42},"line":13,"code":"  test('crypt fails if secret is incorrect', () => {\n    const secret = 'f5bb945cc57fea2f25961e1bd6fb3c89_TO_LONG';\n    const payload = 'juan';\n    const token = aesEncrypt(payload, secret) as string;\n    expect(token).toBeUndefined();\n  });","file":"legacy-token.spec.ts","skipped":false,"dir":"packages/auth/test"},{"name":"write some test for this module","suites":["cli test"],"line":2,"code":"  test.todo('write some test for this module');","file":"cli-test.spec.ts","skipped":true,"dir":"packages/cli/test"},{"name":"valid version node.js","suites":[],"updatePoint":{"line":3,"column":27},"line":3,"code":"test('valid version node.js', () => {\n  expect(isVersionValid('v14.0.0')).toBeTruthy();\n  expect(isVersionValid('v15.0.0')).toBeTruthy();\n  expect(isVersionValid('v16.0.0')).toBeTruthy();\n  expect(isVersionValid('v17.0.0')).toBeTruthy();\n});","file":"utils.spec.ts","skipped":false,"dir":"packages/cli/test"},{"name":"is invalid version node.js","suites":[],"updatePoint":{"line":10,"column":32},"line":10,"code":"test('is invalid version node.js', () => {\n  expect(isVersionValid('v13.0.0')).toBeFalsy();\n  expect(isVersionValid('v12.0.0')).toBeFalsy();\n  expect(isVersionValid('v8.0.0')).toBeFalsy();\n  expect(isVersionValid('v4.0.0')).toBeFalsy();\n  expect(isVersionValid('v0.0.10')).toBeFalsy();\n});","file":"utils.spec.ts","skipped":false,"dir":"packages/cli/test"},{"name":"parse default.json","suites":["Package access utilities","JSON format"],"updatePoint":{"line":6,"column":28},"line":6,"code":"    test('parse default.json', () => {\n      const config = parseConfigFile(parseConfigurationFile('default.json'));\n\n      expect(config.storage).toBeDefined();\n    });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse invalid.json","suites":["Package access utilities","JSON format"],"updatePoint":{"line":12,"column":28},"line":12,"code":"    test('parse invalid.json', () => {\n      expect(function () {\n        parseConfigFile(parseConfigurationFile('invalid.json'));\n      }).toThrow(/CONFIG: it does not look like a valid config file/);\n    });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse not-exists.json","suites":["Package access utilities","JSON format"],"updatePoint":{"line":18,"column":31},"line":18,"code":"    test('parse not-exists.json', () => {\n      expect(function () {\n        parseConfigFile(parseConfigurationFile('not-exists.json'));\n      }).toThrow(/Cannot find module/);\n    });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse default.js","suites":["Package access utilities","JavaScript format"],"updatePoint":{"line":26,"column":26},"line":26,"code":"    test('parse default.js', () => {\n      const config = parseConfigFile(parseConfigurationFile('default.js'));\n\n      expect(config.storage).toBeDefined();\n    });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse invalid.js","suites":["Package access utilities","JavaScript format"],"updatePoint":{"line":32,"column":26},"line":32,"code":"    test('parse invalid.js', () => {\n      expect(function () {\n        parseConfigFile(parseConfigurationFile('invalid.js'));\n      }).toThrow(/CONFIG: it does not look like a valid config file/);\n    });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse not-exists.js","suites":["Package access utilities","JavaScript format"],"updatePoint":{"line":38,"column":29},"line":38,"code":"    test('parse not-exists.js', () => {\n      expect(function () {\n        parseConfigFile(parseConfigurationFile('not-exists.js'));\n      }).toThrow(/Cannot find module/);\n    });","file":"config-parsing.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with custom location","suites":["config-path","findConfigFile","using defiled location from arguments"],"updatePoint":{"line":38,"column":34},"line":38,"code":"        test('with custom location', () => {\n          expect(findConfigFile('/home/user/custom/location/config.yaml')).toEqual(\n            '/home/user/custom/location/config.yaml'\n          );\n          expect(mockwriteFile).not.toHaveBeenCalled();\n          expect(mockmkDir).not.toHaveBeenCalled();\n        });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with XDG_CONFIG_HOME if directory exist but config file is missing","suites":["config-path","findConfigFile","whith env variables"],"updatePoint":{"line":48,"column":80},"line":48,"code":"        test('with XDG_CONFIG_HOME if directory exist but config file is missing', () => {\n          process.env.XDG_CONFIG_HOME = '/home/user';\n          expect(findConfigFile()).toEqual('/home/user/verdaccio/config.yaml');\n          expect(mockwriteFile).toHaveBeenCalledWith('/home/user/verdaccio/config.yaml');\n          expect(mockmkDir).toHaveBeenCalledWith('/home/user/verdaccio');\n        });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with HOME if directory exist but config file is missing","suites":["config-path","findConfigFile","whith env variables"],"updatePoint":{"line":55,"column":69},"line":55,"code":"        test('with HOME if directory exist but config file is missing', () => {\n          delete process.env.XDG_CONFIG_HOME;\n          process.env.HOME = '/home/user';\n          expect(findConfigFile()).toEqual('/home/user/.config/verdaccio/config.yaml');\n          expect(mockwriteFile).toHaveBeenCalledWith('/home/user/.config/verdaccio/config.yaml');\n          expect(mockmkDir).toHaveBeenCalledWith('/home/user/.config/verdaccio');\n        });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"XDG_CONFIG_HOME is not directory fallback to default","suites":["config-path","findConfigFile","whith env variables","error handling"],"updatePoint":{"line":64,"column":68},"line":64,"code":"          test('XDG_CONFIG_HOME is not directory fallback to default', () => {\n            process.env.XDG_CONFIG_HOME = '/home/user/fail';\n            mockaccessSync.mockImplementation(() => {});\n            mockwriteFile.mockImplementation(() => {});\n            expect(findConfigFile()).toMatch('packages/config/verdaccio/config.yaml');\n          });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"no permissions on read default config file","suites":["config-path","findConfigFile","whith env variables","error handling"],"updatePoint":{"line":71,"column":58},"line":71,"code":"          test('no permissions on read default config file', () => {\n            process.env.XDG_CONFIG_HOME = '/home/user';\n            mockaccessSync.mockImplementation(() => {\n              throw new Error('error on write file');\n            });\n\n            expect(function () {\n              findConfigFile();\n            }).toThrow(/configuration file does not have enough permissions for reading/);\n          });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with relative location","suites":["config-path","findConfigFile","with no env variables"],"updatePoint":{"line":85,"column":36},"line":85,"code":"        test('with relative location', () => {\n          mockaccessSync.mockImplementation(() => {});\n          delete process.env.XDG_CONFIG_HOME;\n          delete process.env.HOME;\n          process.env.APPDATA = '/app/data/';\n          expect(findConfigFile()).toMatch('packages/config/verdaccio/config.yaml');\n          expect(mockwriteFile).toHaveBeenCalled();\n          expect(mockmkDir).toHaveBeenCalled();\n        });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with windows as directory exist but config file is missing","suites":["config-path","findConfigFile","with no env variables"],"updatePoint":{"line":96,"column":70},"line":96,"code":"      test('with windows as directory exist but config file is missing', () => {\n        delete process.env.XDG_CONFIG_HOME;\n        delete process.env.HOME;\n        process.env.APPDATA = '/app/data/';\n        expect(findConfigFile()).toMatch('\\\\app\\\\data\\\\verdaccio\\\\config.yaml');\n        expect(mockwriteFile).toHaveBeenCalled();\n        expect(mockmkDir).toHaveBeenCalled();\n      });","file":"config.path.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse default.yaml","suites":["check basic content parsed file"],"updatePoint":{"line":76,"column":26},"line":76,"code":"  test('parse default.yaml', () => {\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    checkDefaultUplink(config);\n    expect(config.storage).toBe('./storage');\n    expect(config.auth.htpasswd.file).toBe('./htpasswd');\n    checkDefaultConfPackages(config);\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"parse docker.yaml","suites":["check basic content parsed file"],"updatePoint":{"line":84,"column":25},"line":84,"code":"  test('parse docker.yaml', () => {\n    const config = new Config(parseConfigFile(resolveConf('docker')));\n    checkDefaultUplink(config);\n    expect(config.storage).toBe('/verdaccio/storage/data');\n    expect(config.auth.htpasswd.file).toBe('/verdaccio/storage/htpasswd');\n    checkDefaultConfPackages(config);\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with default.yaml and pre selected secret","suites":["checkSecretKey"],"updatePoint":{"line":94,"column":49},"line":94,"code":"  test('with default.yaml and pre selected secret', () => {\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    expect(config.checkSecretKey('12345')).toEqual('12345');\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with default.yaml and void secret","suites":["checkSecretKey"],"updatePoint":{"line":99,"column":41},"line":99,"code":"  test('with default.yaml and void secret', () => {\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    expect(typeof config.checkSecretKey() === 'string').toBeTruthy();\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"with default.yaml and emtpy string secret","suites":["checkSecretKey"],"updatePoint":{"line":104,"column":49},"line":104,"code":"  test('with default.yaml and emtpy string secret', () => {\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    expect(typeof config.checkSecretKey('') === 'string').toBeTruthy();\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should match with react as defined in config file","suites":["getMatchedPackagesSpec"],"updatePoint":{"line":111,"column":57},"line":111,"code":"  test('should match with react as defined in config file', () => {\n    const configParsed = parseConfigFile(parseConfigurationFile('config-getMatchedPackagesSpec'));\n    const config = new Config(configParsed);\n    expect(config.getMatchedPackagesSpec('react')).toEqual({\n      access: ['admin'],\n      proxy: ['facebook'],\n      publish: ['admin'],\n      unpublish: false,\n    });\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should not match with react as defined in config file","suites":["getMatchedPackagesSpec"],"updatePoint":{"line":122,"column":61},"line":122,"code":"  test('should not match with react as defined in config file', () => {\n    const configParsed = parseConfigFile(parseConfigurationFile('config-getMatchedPackagesSpec'));\n    const config = new Config(configParsed);\n    expect(config.getMatchedPackagesSpec('somePackage')).toEqual({\n      access: [ROLES.$ALL],\n      proxy: ['npmjs'],\n      publish: [ROLES.$AUTH],\n      unpublish: false,\n    });\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should set storage to value set in VERDACCIO_STORAGE_PATH environment variable","suites":["VERDACCIO_STORAGE_PATH"],"updatePoint":{"line":135,"column":86},"line":135,"code":"  test('should set storage to value set in VERDACCIO_STORAGE_PATH environment variable', () => {\n    const storageLocation = '/tmp/verdaccio';\n    process.env.VERDACCIO_STORAGE_PATH = storageLocation;\n    const config = new Config(parseConfigFile(resolveConf('default')));\n    expect(config.storage).toBe(storageLocation);\n    delete process.env.VERDACCIO_STORAGE_PATH;\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should set storage path to VERDACCIO_STORAGE_PATH if both config and env are set","suites":["VERDACCIO_STORAGE_PATH"],"updatePoint":{"line":143,"column":88},"line":143,"code":"  test('should set storage path to VERDACCIO_STORAGE_PATH if both config and env are set', () => {\n    const storageLocation = '/tmp/verdaccio';\n    process.env.VERDACCIO_STORAGE_PATH = storageLocation;\n    const config = new Config(parseConfigFile(parseConfigurationFile('storage')));\n    expect(config.storage).toBe(storageLocation);\n    delete process.env.VERDACCIO_STORAGE_PATH;\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should take storage from environment variable if not exists in configs","suites":["VERDACCIO_STORAGE_PATH"],"updatePoint":{"line":151,"column":78},"line":151,"code":"  test('should take storage from environment variable if not exists in configs', () => {\n    const storageLocation = '/tmp/verdaccio';\n    process.env.VERDACCIO_STORAGE_PATH = storageLocation;\n    const defaultConfig = parseConfigFile(resolveConf('default'));\n    delete defaultConfig.storage;\n    const config = new Config(defaultConfig);\n    expect(config.storage).toBe(storageLocation);\n    delete process.env.VERDACCIO_STORAGE_PATH;\n  });","file":"config.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test basic conversion","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":9,"column":38},"line":9,"code":"    test('should test basic conversion', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-basic'));\n      const access = normalisePackageAccess(packages);\n\n      expect(access).toBeDefined();\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n\n      expect(scoped).toBeDefined();\n      expect(all).toBeDefined();\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should define an empty publish array even if is not defined in packages","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":21,"column":81},"line":21,"code":"    test('should define an empty publish array even if is not defined in packages', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-basic-no-publish'));\n      const access = normalisePackageAccess(packages);\n\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n      // publish must defined\n      expect(scoped.publish).toBeDefined();\n      expect(scoped.publish).toHaveLength(0);\n      expect(all.publish).toBeDefined();\n      expect(all.publish).toHaveLength(0);\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should define an empty access array even if is not defined in packages","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":34,"column":80},"line":34,"code":"    test('should define an empty access array even if is not defined in packages', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-basic-no-access'));\n      const access = normalisePackageAccess(packages);\n\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n      // publish must defined\n      expect(scoped.access).toBeDefined();\n      expect(scoped.access).toHaveLength(0);\n      expect(all.access).toBeDefined();\n      expect(all.access).toHaveLength(0);\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should define an empty proxy array even if is not defined in package","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":47,"column":78},"line":47,"code":"    test('should define an empty proxy array even if is not defined in package', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-basic-no-proxy'));\n      const access = normalisePackageAccess(packages);\n\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n      // publish must defined\n      expect(scoped.proxy).toBeDefined();\n      expect(scoped.proxy).toHaveLength(0);\n      expect(all.proxy).toBeDefined();\n      expect(all.proxy).toHaveLength(0);\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test multi user group definition","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":60,"column":49},"line":60,"code":"    test('should test multi user group definition', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-multi-group'));\n      const access = normalisePackageAccess(packages);\n\n      expect(access).toBeDefined();\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n\n      expect(scoped).toBeDefined();\n      expect(scoped.access).toContain('$all');\n      expect(scoped.publish).toHaveLength(2);\n      expect(scoped.publish).toContain('admin');\n      expect(scoped.publish).toContain('superadmin');\n\n      expect(all).toBeDefined();\n      expect(all.access).toHaveLength(3);\n      expect(all.access).toContain('$all');\n      expect(all.publish).toHaveLength(1);\n      expect(all.publish).toContain('admin');\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should check not default packages access","suites":["Package access utilities","normalisePackageAccess"],"updatePoint":{"line":109,"column":50},"line":109,"code":"    test('should check not default packages access', () => {\n      const { packages } = parseConfigFile(parseConfigurationFile('pkgs-empty'));\n      const access = normalisePackageAccess(packages);\n      expect(access).toBeDefined();\n\n      const scoped = access[`${PACKAGE_ACCESS.SCOPE}`];\n      expect(scoped).toBeUndefined();\n      // ** should be added by default **\n      const all = access[`${PACKAGE_ACCESS.ALL}`];\n      expect(all).toBeDefined();\n\n      expect(all.access).toBeDefined();\n      expect(_.isArray(all.access)).toBeTruthy();\n      expect(all.publish).toBeDefined();\n      expect(_.isArray(all.publish)).toBeTruthy();\n    });","file":"package-access.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"token test valid length","suites":[],"updatePoint":{"line":3,"column":29},"line":3,"code":"test('token test valid length', () => {\n  const token = generateRandomSecretKey();\n  expect(token).toHaveLength(TOKEN_VALID_LENGTH);\n});","file":"token.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test basic conversion","suites":["Uplinks Utilities","uplinkSanityCheck"],"updatePoint":{"line":7,"column":38},"line":7,"code":"    test('should test basic conversion', () => {\n      const uplinks = uplinkSanityCheck(\n        parseConfigFile(parseConfigurationFile('uplink-basic')).uplinks\n      );\n      expect(Object.keys(uplinks)).toContain('server1');\n      expect(Object.keys(uplinks)).toContain('server2');\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should throw error on blacklisted uplink name","suites":["Uplinks Utilities","uplinkSanityCheck"],"updatePoint":{"line":15,"column":55},"line":15,"code":"    test('should throw error on blacklisted uplink name', () => {\n      const { uplinks } = parseConfigFile(parseConfigurationFile('uplink-wrong'));\n\n      expect(() => {\n        uplinkSanityCheck(uplinks);\n      }).toThrow('CONFIG: reserved uplink name: anonymous');\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should fails if url prop is missing","suites":["Uplinks Utilities","sanityCheckUplinksProps"],"updatePoint":{"line":25,"column":45},"line":25,"code":"    test('should fails if url prop is missing', () => {\n      const { uplinks } = parseConfigFile(parseConfigurationFile('uplink-wrong'));\n      expect(() => {\n        sanityCheckUplinksProps(uplinks);\n      }).toThrow('CONFIG: no url for uplink: none-url');\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should bypass an empty uplink list","suites":["Uplinks Utilities","sanityCheckUplinksProps"],"updatePoint":{"line":32,"column":44},"line":32,"code":"    test('should bypass an empty uplink list', () => {\n      // @ts-ignore\n      expect(sanityCheckUplinksProps([])).toHaveLength(0);\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test basic config","suites":["Uplinks Utilities","hasProxyTo"],"updatePoint":{"line":39,"column":34},"line":39,"code":"    test('should test basic config', () => {\n      const packages = normalisePackageAccess(\n        parseConfigFile(parseConfigurationFile('pkgs-basic')).packages\n      );\n      // react\n      expect(hasProxyTo('react', 'facebook', packages)).toBeFalsy();\n      expect(hasProxyTo('react', 'google', packages)).toBeFalsy();\n      // vue\n      expect(hasProxyTo('vue', 'google', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'fake', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeTruthy();\n      // angular\n      expect(hasProxyTo('angular', 'google', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'facebook', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeTruthy();\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should test resolve based on custom package access","suites":["Uplinks Utilities","hasProxyTo"],"updatePoint":{"line":56,"column":60},"line":56,"code":"    test('should test resolve based on custom package access', () => {\n      const packages = normalisePackageAccess(\n        parseConfigFile(parseConfigurationFile('pkgs-custom')).packages\n      );\n      // react\n      expect(hasProxyTo('react', 'facebook', packages)).toBeTruthy();\n      expect(hasProxyTo('react', 'google', packages)).toBeFalsy();\n      // vue\n      expect(hasProxyTo('vue', 'google', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'fake', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeTruthy();\n      // angular\n      expect(hasProxyTo('angular', 'google', packages)).toBeTruthy();\n      expect(hasProxyTo('angular', 'facebook', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeFalsy();\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should not resolve any proxy","suites":["Uplinks Utilities","hasProxyTo"],"updatePoint":{"line":73,"column":38},"line":73,"code":"    test('should not resolve any proxy', () => {\n      const packages = normalisePackageAccess(\n        parseConfigFile(parseConfigurationFile('pkgs-empty')).packages\n      );\n      // react\n      expect(hasProxyTo('react', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('react', 'npmjs', packages)).toBeFalsy();\n      // vue\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('vue', 'npmjs', packages)).toBeFalsy();\n      // angular\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeFalsy();\n      expect(hasProxyTo('angular', 'npmjs', packages)).toBeFalsy();\n      // private\n      expect(hasProxyTo('private', 'fake', packages)).toBeFalsy();\n    });","file":"uplinks.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should splice two strings and generate a url","suites":["spliceURL"],"updatePoint":{"line":5,"column":52},"line":5,"code":"  test('should splice two strings and generate a url', () => {\n    const url: string = spliceURL('http://domain.com', '/-/static/logo.png');\n\n    expect(url).toMatch('http://domain.com/-/static/logo.png');\n  });","file":"utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should splice a empty strings and generate a url","suites":["spliceURL"],"updatePoint":{"line":11,"column":56},"line":11,"code":"  test('should splice a empty strings and generate a url', () => {\n    const url: string = spliceURL('', '/-/static/logo.png');\n\n    expect(url).toMatch('/-/static/logo.png');\n  });","file":"utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should create a remote user with default groups","suites":["spliceURL","createRemoteUser and createAnonymousRemoteUser"],"updatePoint":{"line":18,"column":57},"line":18,"code":"    test('should create a remote user with default groups', () => {\n      expect(createRemoteUser('12345', ['foo', 'bar'])).toEqual({\n        groups: [\n          'foo',\n          'bar',\n          ROLES.$ALL,\n          ROLES.$AUTH,\n          ROLES.DEPRECATED_ALL,\n          ROLES.DEPRECATED_AUTH,\n          ROLES.ALL,\n        ],\n        name: '12345',\n        real_groups: ['foo', 'bar'],\n      });\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should create a anonymous remote user with default groups","suites":["spliceURL","createRemoteUser and createAnonymousRemoteUser"],"updatePoint":{"line":34,"column":67},"line":34,"code":"    test('should create a anonymous remote user with default groups', () => {\n      expect(createAnonymousRemoteUser()).toEqual({\n        groups: [ROLES.$ALL, ROLES.$ANONYMOUS, ROLES.DEPRECATED_ALL, ROLES.DEPRECATED_ANONYMOUS],\n        name: undefined,\n        real_groups: [],\n      });\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/config/test"},{"name":"should qualify as an native error","suites":["testing errors"],"updatePoint":{"line":18,"column":41},"line":18,"code":"  test('should qualify as an native error', () => {\n    expect(_.isError(getNotFound())).toBeTruthy();\n    expect(_.isError(getConflict())).toBeTruthy();\n    expect(_.isError(getBadData())).toBeTruthy();\n    expect(_.isError(getInternalError())).toBeTruthy();\n    expect(_.isError(getUnauthorized())).toBeTruthy();\n    expect(_.isError(getForbidden())).toBeTruthy();\n    expect(_.isError(getServiceUnavailable())).toBeTruthy();\n    expect(_.isError(getCode(400, 'fooError'))).toBeTruthy();\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test not found","suites":["testing errors"],"updatePoint":{"line":29,"column":29},"line":29,"code":"  test('should test not found', () => {\n    const err: VerdaccioError = getNotFound('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.NOT_FOUND);\n    expect(err.statusCode).toEqual(HTTP_STATUS.NOT_FOUND);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test conflict","suites":["testing errors"],"updatePoint":{"line":38,"column":28},"line":38,"code":"  test('should test conflict', () => {\n    const err: VerdaccioError = getConflict('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.CONFLICT);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test bad data","suites":["testing errors"],"updatePoint":{"line":46,"column":28},"line":46,"code":"  test('should test bad data', () => {\n    const err: VerdaccioError = getBadData('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.BAD_DATA);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test internal error custom message","suites":["testing errors"],"updatePoint":{"line":54,"column":49},"line":54,"code":"  test('should test internal error custom message', () => {\n    const err: VerdaccioError = getInternalError('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.INTERNAL_ERROR);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test internal error","suites":["testing errors"],"updatePoint":{"line":62,"column":34},"line":62,"code":"  test('should test internal error', () => {\n    const err: VerdaccioError = getInternalError();\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.INTERNAL_ERROR);\n    expect(err.message).toEqual(API_ERROR.UNKNOWN_ERROR);\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test Unauthorized message","suites":["testing errors"],"updatePoint":{"line":70,"column":40},"line":70,"code":"  test('should test Unauthorized message', () => {\n    const err: VerdaccioError = getUnauthorized('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.UNAUTHORIZED);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test forbidden message","suites":["testing errors"],"updatePoint":{"line":78,"column":37},"line":78,"code":"  test('should test forbidden message', () => {\n    const err: VerdaccioError = getForbidden('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.FORBIDDEN);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test service unavailable message","suites":["testing errors"],"updatePoint":{"line":86,"column":47},"line":86,"code":"  test('should test service unavailable message', () => {\n    const err: VerdaccioError = getServiceUnavailable('foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.SERVICE_UNAVAILABLE);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test custom code error message","suites":["testing errors"],"updatePoint":{"line":94,"column":45},"line":94,"code":"  test('should test custom code error message', () => {\n    const err: VerdaccioError = getCode(HTTP_STATUS.NOT_FOUND, 'foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.NOT_FOUND);\n    expect(err.message).toEqual('foo');\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should test custom code ok message","suites":["testing errors"],"updatePoint":{"line":102,"column":42},"line":102,"code":"  test('should test custom code ok message', () => {\n    const err: VerdaccioError = getCode(HTTP_STATUS.OK, 'foo');\n\n    expect(err.code).toBeDefined();\n    expect(err.code).toEqual(HTTP_STATUS.OK);\n  });","file":"errors.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"simple","suites":["Storage._merge_versions versions"],"updatePoint":{"line":4,"column":14},"line":4,"code":"  test('simple', () => {\n    let pkg = {\n      versions: { a: 1, b: 1, c: 1 },\n      'dist-tags': {},\n    };\n\n    // @ts-ignore\n    mergeVersions(pkg, { versions: { a: 2, q: 2 } });\n\n    expect(pkg).toStrictEqual({\n      versions: { a: 1, b: 1, c: 1, q: 2 },\n      'dist-tags': {},\n    });\n  });","file":"merge.dist.tags.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"dist-tags - compat","suites":["Storage._merge_versions versions"],"updatePoint":{"line":19,"column":26},"line":19,"code":"  test('dist-tags - compat', () => {\n    let pkg = {\n      versions: {},\n      'dist-tags': { q: '1.1.1', w: '2.2.2' },\n    };\n\n    // @ts-ignore\n    mergeVersions(pkg, { 'dist-tags': { q: '2.2.2', w: '3.3.3', t: '4.4.4' } });\n\n    expect(pkg).toStrictEqual({\n      versions: {},\n      'dist-tags': { q: '2.2.2', w: '3.3.3', t: '4.4.4' },\n    });\n  });","file":"merge.dist.tags.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"dist-tags - staging","suites":["Storage._merge_versions versions"],"updatePoint":{"line":34,"column":27},"line":34,"code":"  test('dist-tags - staging', () => {\n    let pkg = {\n      versions: {},\n      // we've been locally publishing 1.1.x in preparation for the next\n      // public release\n      'dist-tags': { q: '1.1.10', w: '2.2.2' },\n    };\n    // 1.1.2 is the latest public release, but we want to continue testing\n    // against our local 1.1.10, which may end up published as 1.1.3 in the\n    // future\n\n    // @ts-ignore\n    mergeVersions(pkg, { 'dist-tags': { q: '1.1.2', w: '3.3.3', t: '4.4.4' } });\n\n    expect(pkg).toStrictEqual({\n      versions: {},\n      'dist-tags': { q: '1.1.10', w: '3.3.3', t: '4.4.4' },\n    });\n  });","file":"merge.dist.tags.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"semverSort","suites":["Storage._merge_versions versions"],"updatePoint":{"line":54,"column":18},"line":54,"code":"  test('semverSort', () => {\n    expect(semverSort(['1.2.3', '1.2', '1.2.3a', '1.2.3c', '1.2.3-b'])).toStrictEqual([\n      '1.2.3a',\n      '1.2.3-b',\n      '1.2.3c',\n      '1.2.3',\n    ]);\n  });","file":"merge.dist.tags.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should delay events on ReadTarball abort","suites":["mystreams"],"updatePoint":{"line":6,"column":48},"line":6,"code":"  test('should delay events on ReadTarball abort', (cb) => {\n    const readTballStream = new ReadTarball({});\n    readTballStream.abort();\n    setTimeout(function () {\n      readTballStream.abort = function (): void {\n        cb();\n      };\n      readTballStream.abort = function (): never {\n        throw Error('fail');\n      };\n    }, 10);\n  });","file":"mystreams.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should delay events on UploadTarball abort","suites":["mystreams"],"updatePoint":{"line":19,"column":50},"line":19,"code":"  test('should delay events on UploadTarball abort', (cb) => {\n    const uploadTballStream = new UploadTarball({});\n    uploadTballStream.abort();\n    setTimeout(function () {\n      uploadTballStream.abort = function (): void {\n        cb();\n      };\n      uploadTballStream.abort = function (): never {\n        throw Error('fail');\n      };\n    }, 10);\n  });","file":"mystreams.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"readableToString single string","suites":["mystreams"],"updatePoint":{"line":32,"column":38},"line":32,"code":"  test('readableToString single string', async () => {\n    expect(await readableToString(Stream.Readable.from('foo'))).toEqual('foo');\n  });","file":"mystreams.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"readableToString single object","suites":["mystreams"],"updatePoint":{"line":36,"column":38},"line":36,"code":"  test('readableToString single object', async () => {\n    expect(\n      JSON.parse(await readableToString(Stream.Readable.from(JSON.stringify({ foo: 1 }))))\n    ).toEqual({\n      foo: 1,\n    });\n  });","file":"mystreams.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate package names","suites":["validatePackage"],"updatePoint":{"line":4,"column":37},"line":4,"code":"  test('should validate package names', () => {\n    expect(validatePackage('package-name')).toBeTruthy();\n    expect(validatePackage('@scope/package-name')).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails on validate package names","suites":["validatePackage"],"updatePoint":{"line":9,"column":46},"line":9,"code":"  test('should fails on validate package names', () => {\n    expect(validatePackage('package-name/test/fake')).toBeFalsy();\n    expect(validatePackage('@/package-name')).toBeFalsy();\n    expect(validatePackage('$%$%#$%$#%#$%$#')).toBeFalsy();\n    expect(validatePackage('node_modules')).toBeFalsy();\n    expect(validatePackage('__proto__')).toBeFalsy();\n    expect(validatePackage('favicon.ico')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"isObject metadata","suites":["isObject"],"updatePoint":{"line":20,"column":25},"line":20,"code":"  test('isObject metadata', () => {\n    expect(isObject({ foo: 'bar' })).toBeTruthy();\n    expect(isObject('foo')).toBeTruthy();\n    expect(isObject(['foo'])).toBeFalsy();\n    expect(isObject(null)).toBeFalsy();\n    expect(isObject(undefined)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails with no string","suites":["validateName"],"updatePoint":{"line":30,"column":35},"line":30,"code":"  test('should fails with no string', () => {\n    // intended to fail with Typescript, do not remove\n    // @ts-ignore\n    expect(validateName(null)).toBeFalsy();\n    // @ts-ignore\n    expect(validateName(undefined)).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"good ones","suites":["validateName"],"updatePoint":{"line":38,"column":17},"line":38,"code":"  test('good ones', () => {\n    expect(validateName('verdaccio')).toBeTruthy();\n    expect(validateName('some.weird.package-zzz')).toBeTruthy();\n    expect(validateName('old-package@0.1.2.tgz')).toBeTruthy();\n    // fix https://github.com/verdaccio/verdaccio/issues/1400\n    expect(validateName('-build-infra')).toBeTruthy();\n    expect(validateName('@pkg-scoped/without-extension')).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should be valid using uppercase","suites":["validateName"],"updatePoint":{"line":47,"column":39},"line":47,"code":"  test('should be valid using uppercase', () => {\n    expect(validateName('ETE')).toBeTruthy();\n    expect(validateName('JSONStream')).toBeTruthy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails with path seps","suites":["validateName"],"updatePoint":{"line":52,"column":35},"line":52,"code":"  test('should fails with path seps', () => {\n    expect(validateName('some/thing')).toBeFalsy();\n    expect(validateName('some\\\\thing')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fail with no hidden files","suites":["validateName"],"updatePoint":{"line":57,"column":40},"line":57,"code":"  test('should fail with no hidden files', () => {\n    expect(validateName('.bin')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails with reserved words","suites":["validateName"],"updatePoint":{"line":61,"column":40},"line":61,"code":"  test('should fails with reserved words', () => {\n    expect(validateName('favicon.ico')).toBeFalsy();\n    expect(validateName('node_modules')).toBeFalsy();\n    expect(validateName('__proto__')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"should fails with other options","suites":["validateName"],"updatePoint":{"line":67,"column":39},"line":67,"code":"  test('should fails with other options', () => {\n    expect(validateName('pk g')).toBeFalsy();\n    expect(validateName('pk\\tg')).toBeFalsy();\n    expect(validateName('pk%20g')).toBeFalsy();\n    expect(validateName('pk+g')).toBeFalsy();\n    expect(validateName('pk:g')).toBeFalsy();\n  });","file":"validation-utilts.spec.ts","skipped":false,"dir":"packages/core/core/test"},{"name":"file should be found to be locked","suites":["testing locking","lockFile"],"updatePoint":{"line":25,"column":43},"line":25,"code":"    test('file should be found to be locked', (done) => {\n      lockFile(getFilePath('package.json'), (error: Error) => {\n        expect(error).toBeNull();\n        removeTempFile('package.json.lock');\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should fail to be found to be locked","suites":["testing locking","lockFile"],"updatePoint":{"line":33,"column":51},"line":33,"code":"    test('file should fail to be found to be locked', (done) => {\n      lockFile(getFilePath('package.fail.json'), (error: Error) => {\n        expect(error.message).toMatch(\n          /ENOENT: no such file or directory, stat '(.*)package.fail.json'/\n        );\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should to be found to be unLock","suites":["testing locking","unlockFile"],"updatePoint":{"line":44,"column":46},"line":44,"code":"    test('file should to be found to be unLock', (done) => {\n      unlockFile(getFilePath('package.json.lock'), (error: Error) => {\n        expect(error).toBeNull();\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with no options should to be found to be read it as string","suites":["testing locking","readFile"],"updatePoint":{"line":53,"column":78},"line":53,"code":"    test('read file with no options should to be found to be read it as string', (done) => {\n      readFile(getFilePath('package.json'), {}, (error: Error, data: string) => {\n        expect(error).toBeNull();\n        expect(data).toMatchInlineSnapshot(`\n            \"{\n              \\\\\"name\\\\\": \\\\\"assets\\\\\",\n              \\\\\"version\\\\\": \\\\\"0.0.1\\\\\"\n            }\n            \"\n          `);\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with no options should to be found to be read it as object","suites":["testing locking","readFile"],"updatePoint":{"line":67,"column":78},"line":67,"code":"    test('read file with no options should to be found to be read it as object', (done) => {\n      const options = {\n        parse: true,\n      };\n      readFile(getFilePath('package.json'), options, (error: Error, data: string) => {\n        expect(error).toBeNull();\n        expect(data).toMatchInlineSnapshot(`\n            Object {\n              \"name\": \"assets\",\n              \"version\": \"0.0.1\",\n            }\n          `);\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options (parse) should to be not found to be read it","suites":["testing locking","readFile"],"updatePoint":{"line":83,"column":77},"line":83,"code":"    test('read file with options (parse) should to be not found to be read it', (done) => {\n      const options = {\n        parse: true,\n      };\n      readFile(getFilePath('package.fail.json'), options, (error: Error) => {\n        expect(error.message).toMatch(\n          /ENOENT: no such file or directory, open '(.*)package.fail.json'/\n        );\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options should be found to be read it and fails to be parsed","suites":["testing locking","readFile"],"updatePoint":{"line":95,"column":85},"line":95,"code":"    test('read file with options should be found to be read it and fails to be parsed', (done) => {\n      const options = {\n        parse: true,\n      };\n      readFile(getFilePath('wrong.package.json'), options, (error: Error) => {\n        expect(error.message).toMatch(/Unexpected token } in JSON at position \\d+/);\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options (parse, lock) should be found to be read it as object","suites":["testing locking","readFile"],"updatePoint":{"line":105,"column":86},"line":105,"code":"    test('read file with options (parse, lock) should be found to be read it as object', (done) => {\n      const options = {\n        parse: true,\n        lock: true,\n      };\n      readFile(getFilePath('package2.json'), options, (error: Error, data: string) => {\n        expect(error).toBeNull();\n        expect(data).toMatchInlineSnapshot(`\n            Object {\n              \"name\": \"assets\",\n              \"version\": \"0.0.1\",\n            }\n          `);\n        removeTempFile('package2.json.lock');\n        done();\n      });\n    });","file":"lock.legacy.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should be found to be locked","suites":["testing locking","lockFile"],"updatePoint":{"line":22,"column":43},"line":22,"code":"    test('file should be found to be locked', async () => {\n      await lockFileNext(getFilePath('package.json'));\n      removeTempFile('package.json.lock');\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should fail to be found to be locked","suites":["testing locking","lockFile"],"updatePoint":{"line":27,"column":51},"line":27,"code":"    test('file should fail to be found to be locked', async () => {\n      await expect(lockFileNext(getFilePath('package.fail.json'))).rejects.toThrow(\n        'ENOENT: no such file or directory'\n      );\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"file should to be found to be unLock","suites":["testing locking","unlockFile"],"updatePoint":{"line":35,"column":46},"line":35,"code":"    test('file should to be found to be unLock', async () => {\n      await expect(unlockFileNext(getFilePath('package.json.lock'))).resolves.toBeUndefined();\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"error on missing dir","suites":["testing locking","statDir"],"updatePoint":{"line":41,"column":30},"line":41,"code":"    test('error on missing dir', async () => {\n      await expect(statDir(getFilePath('package.json/package.json'))).rejects.toThrow(\n        'is not a directory'\n      );\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"error on missing dir","suites":["testing locking","statFile"],"updatePoint":{"line":49,"column":30},"line":49,"code":"    test('error on missing dir', async () => {\n      await expect(statFile(getFilePath(''))).rejects.toThrow('is not a file');\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with no options should to be found to be read it as string","suites":["testing locking","readFile"],"updatePoint":{"line":55,"column":78},"line":55,"code":"    test('read file with no options should to be found to be read it as string', async () => {\n      const data = await readFileNext(getFilePath('package.json'), {});\n      expect(data).toMatchInlineSnapshot(`\n            \"{\n              \\\\\"name\\\\\": \\\\\"assets\\\\\",\n              \\\\\"version\\\\\": \\\\\"0.0.1\\\\\"\n            }\n            \"\n          `);\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with no options should to be found to be read it as object","suites":["testing locking","readFile"],"updatePoint":{"line":66,"column":78},"line":66,"code":"    test('read file with no options should to be found to be read it as object', async () => {\n      const options = {\n        parse: true,\n      };\n      const data = await readFileNext(getFilePath('package.json'), options);\n      expect(data).toMatchInlineSnapshot(`\n              Object {\n                \"name\": \"assets\",\n                \"version\": \"0.0.1\",\n              }\n            `);\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options (parse) should to be not found to be read it","suites":["testing locking","readFile"],"updatePoint":{"line":79,"column":77},"line":79,"code":"    test('read file with options (parse) should to be not found to be read it', async () => {\n      const options = {\n        parse: true,\n      };\n      await expect(readFileNext(getFilePath('package.fail.json'), options)).rejects.toThrow(\n        /ENOENT: no such file or directory, open '(.*)package.fail.json'/\n      );\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options should be found to be read it and fails to be parsed","suites":["testing locking","readFile"],"updatePoint":{"line":88,"column":85},"line":88,"code":"    test('read file with options should be found to be read it and fails to be parsed', async () => {\n      const options = {\n        parse: true,\n      };\n      await expect(readFileNext(getFilePath('wrong.package.json'), options)).rejects.toThrow(\n        'Unexpected token } in JSON at position 44'\n      );\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"read file with options (parse, lock) should be found to be read it as object","suites":["testing locking","readFile"],"updatePoint":{"line":97,"column":86},"line":97,"code":"    test('read file with options (parse, lock) should be found to be read it as object', async () => {\n      const options = {\n        parse: true,\n        lock: true,\n      };\n      await expect(\n        readFileNext(getFilePath('package2.json'), options)\n      ).resolves.toMatchInlineSnapshot(\n        `\n              Object {\n                \"name\": \"assets\",\n                \"version\": \"0.0.1\",\n              }\n            `\n      );\n      removeTempFile('package2.json.lock');\n    });","file":"lock.spec.ts","skipped":false,"dir":"packages/core/file-locking/tests"},{"name":"should handle empty readme","suites":["readme"],"updatePoint":{"line":23,"column":34},"line":23,"code":"  test('should handle empty readme', () => {\n    expect(parseReadme('')).toBeUndefined();\n  });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should handle single string readme","suites":["readme"],"updatePoint":{"line":27,"column":42},"line":27,"code":"  test('should handle single string readme', () => {\n    expect(parseReadme('this is a readme')).toEqual('<p>this is a readme</p>');\n  });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should handle wrong text","suites":["readme"],"updatePoint":{"line":31,"column":32},"line":31,"code":"  test('should handle wrong text', () => {\n    expect(parseReadme(undefined)).toBeUndefined();\n  });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should parse basic","suites":["readme","basic parsing"],"updatePoint":{"line":36,"column":28},"line":36,"code":"    test('should parse basic', () => {\n      expect(parseReadme('# hi')).toEqual(`<h1 id=\\\"hi\\\">hi</h1>`);\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should parse basic / js alert","suites":["readme","basic parsing"],"updatePoint":{"line":40,"column":39},"line":40,"code":"    test('should parse basic / js alert', () => {\n      expect(parseReadme(\"[Basic](javascript:alert('Basic'))\")).toEqual('<p><a>Basic</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should parse basic / local storage","suites":["readme","basic parsing"],"updatePoint":{"line":44,"column":44},"line":44,"code":"    test('should parse basic / local storage', () => {\n      expect(\n        parseReadme('[Local Storage](javascript:alert(JSON.stringify(localStorage)))')\n      ).toEqual('<p><a>Local Storage</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should parse basic / case insensitive","suites":["readme","basic parsing"],"updatePoint":{"line":50,"column":47},"line":50,"code":"    test('should parse basic / case insensitive', () => {\n      expect(parseReadme(\"[CaseInsensitive](JaVaScRiPt:alert('CaseInsensitive'))\")).toEqual(\n        '<p><a>CaseInsensitive</a></p>'\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should parse basic / url","suites":["readme","basic parsing"],"updatePoint":{"line":56,"column":34},"line":56,"code":"    test('should parse basic / url', () => {\n      expect(parseReadme(\"[URL](javascript://www.google.com%0Aalert('URL'))\")).toEqual(\n        '<p><a>URL</a></p>'\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should parse basic / in quotes","suites":["readme","basic parsing"],"updatePoint":{"line":62,"column":40},"line":62,"code":"    test('should parse basic / in quotes', () => {\n      expect(parseReadme('[In Quotes](\\'javascript:alert(\"InQuotes\")\\')')).toEqual(\n        '<p><a href=\"\\'javascript:alert(%22InQuotes%22)\\'\">In Quotes</a></p>'\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"in quotes","suites":["readme","should parse images"],"updatePoint":{"line":70,"column":19},"line":70,"code":"    test('in quotes', () => {\n      expect(\n        parseReadme(\n          '![Escape SRC - onload](https://www.example.com/image.png\"onload=\"alert(\\'ImageOnLoad\\'))'\n        )\n      ).toEqual(\n        '<p><img alt=\"Escape SRC - onload\" src=\"https://www.example.com/image.png%22onload=' +\n          \"%22alert('ImageOnLoad')\\\"></p>\"\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"in image error","suites":["readme","should parse images"],"updatePoint":{"line":81,"column":24},"line":81,"code":"    test('in image error', () => {\n      expect(parseReadme('![Escape SRC - onerror](\"onerror=\"alert(\\'ImageOnError\\'))')).toEqual(\n        '<p><img alt=\"Escape SRC - onerror\" src=\"%22onerror=%22alert(\\'ImageOnError\\')\"></p>'\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / document cookie","suites":["readme","should test fuzzing"],"updatePoint":{"line":89,"column":31},"line":89,"code":"    test('xss / document cookie', () => {\n      expect(parseReadme('[XSS](javascript:prompt(document.cookie))')).toEqual('<p><a>XSS</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / white space cookie","suites":["readme","should test fuzzing"],"updatePoint":{"line":93,"column":34},"line":93,"code":"    test('xss / white space cookie', () => {\n      expect(\n        parseReadme('[XSS](j    a   v   a   s   c   r   i   p   t:prompt(document.cookie))')\n      ).toEqual('<p>[XSS](j    a   v   a   s   c   r   i   p   t:prompt(document.cookie))</p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / data test/html","suites":["readme","should test fuzzing"],"updatePoint":{"line":99,"column":30},"line":99,"code":"    test('xss / data test/html', () => {\n      expect(\n        parseReadme('[XSS](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)')\n      ).toEqual('<p><a>XSS</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / data test/html encoded","suites":["readme","should test fuzzing"],"updatePoint":{"line":105,"column":38},"line":105,"code":"    test('xss / data test/html encoded', () => {\n      expect(\n        parseReadme(\n          '[XSS](&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x7' +\n            '2&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29)'\n        )\n      ).toEqual(\n        '<p><a href=\"&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;' +\n          '#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp' +\n          ';#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29\">XSS</a></p>'\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js prompt","suites":["readme","should test fuzzing"],"updatePoint":{"line":118,"column":25},"line":118,"code":"    test('xss / js prompt', () => {\n      expect(parseReadme('[XSS]: (javascript:prompt(document.cookie))')).toEqual('');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js window error alert","suites":["readme","should test fuzzing"],"updatePoint":{"line":122,"column":37},"line":122,"code":"    test('xss / js window error alert', () => {\n      expect(parseReadme('[XSS](javascript:window.onerror=alert;throw%20document.cookie)')).toEqual(\n        '<p><a>XSS</a></p>'\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js window encoded prompt","suites":["readme","should test fuzzing"],"updatePoint":{"line":128,"column":40},"line":128,"code":"    test('xss / js window encoded prompt', () => {\n      expect(parseReadme('[XSS](javascript://%0d%0aprompt(1))')).toEqual('<p><a>XSS</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js window encoded prompt multiple statement","suites":["readme","should test fuzzing"],"updatePoint":{"line":132,"column":59},"line":132,"code":"    test('xss / js window encoded prompt multiple statement', () => {\n      expect(parseReadme('[XSS](javascript://%0d%0aprompt(1);com)')).toEqual('<p><a>XSS</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js window encoded window error alert multiple statement","suites":["readme","should test fuzzing"],"updatePoint":{"line":136,"column":71},"line":136,"code":"    test('xss / js window encoded window error alert multiple statement', () => {\n      expect(parseReadme('[XSS](javascript:window.onerror=alert;throw%20document.cookie)')).toEqual(\n        '<p><a>XSS</a></p>'\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js window encoded window error alert throw error","suites":["readme","should test fuzzing"],"updatePoint":{"line":142,"column":64},"line":142,"code":"    test('xss / js window encoded window error alert throw error', () => {\n      expect(\n        parseReadme('[XSS](javascript://%0d%0awindow.onerror=alert;throw%20document.cookie)')\n      ).toEqual('<p><a>XSS</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js window encoded data text/html base 64","suites":["readme","should test fuzzing"],"updatePoint":{"line":148,"column":56},"line":148,"code":"    test('xss / js window encoded data text/html base 64', () => {\n      expect(\n        parseReadme('[XSS](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)')\n      ).toEqual('<p><a>XSS</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js vbscript alert","suites":["readme","should test fuzzing"],"updatePoint":{"line":154,"column":33},"line":154,"code":"    test('xss / js vbscript alert', () => {\n      expect(parseReadme('[XSS](vbscript:alert(document.domain))')).toEqual('<p><a>XSS</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js case #1","suites":["readme","should test fuzzing","xss / js alert this"],"updatePoint":{"line":159,"column":28},"line":159,"code":"      test('xss / js case #1', () => {\n        expect(parseReadme('[XSS](javascript:this;alert(1))')).toEqual('<p><a>XSS</a></p>');\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js case #2","suites":["readme","should test fuzzing","xss / js alert this"],"updatePoint":{"line":163,"column":28},"line":163,"code":"      test('xss / js case #2', () => {\n        expect(parseReadme('[XSS](javascript:this;alert(1&#41;)')).toEqual('<p><a>XSS</a></p>');\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js case #3","suites":["readme","should test fuzzing","xss / js alert this"],"updatePoint":{"line":167,"column":28},"line":167,"code":"      test('xss / js case #3', () => {\n        expect(parseReadme('[XSS](javascript&#58this;alert(1&#41;)')).toEqual('<p><a>XSS</a></p>');\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js case #4","suites":["readme","should test fuzzing","xss / js alert this"],"updatePoint":{"line":171,"column":28},"line":171,"code":"      test('xss / js case #4', () => {\n        expect(parseReadme('[XSS](Javas&#99;ript:alert(1&#41;)')).toEqual('<p><a>XSS</a></p>');\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js case #5","suites":["readme","should test fuzzing","xss / js alert this"],"updatePoint":{"line":175,"column":28},"line":175,"code":"      test('xss / js case #5', () => {\n        expect(parseReadme('[XSS](Javas%26%2399;ript:alert(1&#41;)')).toEqual(\n          '<p><a href=\"Javas%26%2399;ript:alert(1)\">XSS</a></p>'\n        );\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js case #6","suites":["readme","should test fuzzing","xss / js alert this"],"updatePoint":{"line":181,"column":28},"line":181,"code":"      test('xss / js case #6', () => {\n        expect(parseReadme('[XSS](javascript:alert&#65534;(1&#41;)')).toEqual('<p><a>XSS</a></p>');\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / js confirm","suites":["readme","should test fuzzing","xss / js alert this"],"updatePoint":{"line":186,"column":26},"line":186,"code":"    test('xss / js confirm', () => {\n      expect(parseReadme('[XSS](javascript:confirm(1)')).toEqual('<p><a>XSS</a></p>');\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / case #1","suites":["readme","should test fuzzing","xss / js url"],"updatePoint":{"line":191,"column":25},"line":191,"code":"      test('xss / case #1', () => {\n        expect(parseReadme('[XSS](javascript://www.google.com%0Aprompt(1))')).toEqual(\n          '<p><a>XSS</a></p>'\n        );\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / case #2","suites":["readme","should test fuzzing","xss / js url"],"updatePoint":{"line":197,"column":25},"line":197,"code":"      test('xss / case #2', () => {\n        expect(parseReadme('[XSS](javascript://%0d%0aconfirm(1);com)')).toEqual(\n          '<p><a>XSS</a></p>'\n        );\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / case #3","suites":["readme","should test fuzzing","xss / js url"],"updatePoint":{"line":203,"column":25},"line":203,"code":"      test('xss / case #3', () => {\n        expect(parseReadme('[XSS](javascript:window.onerror=confirm;throw%201)')).toEqual(\n          '<p><a>XSS</a></p>'\n        );\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / case #4","suites":["readme","should test fuzzing","xss / js url"],"updatePoint":{"line":209,"column":25},"line":209,"code":"      test('xss / case #4', () => {\n        expect(parseReadme('[XSS](javascript:alert(document.domain&#41;)')).toEqual(\n          '<p><a href=\"%EF%BF%BDjavascript:alert(document.domain)\">XSS</a></p>'\n        );\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / case #5","suites":["readme","should test fuzzing","xss / js url"],"updatePoint":{"line":215,"column":25},"line":215,"code":"      test('xss / case #5', () => {\n        expect(parseReadme('![XSS](javascript:prompt(document.cookie))\\\\')).toEqual(\n          '<p><img alt=\"XSS\">\\\\</p>'\n        );\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / case #6","suites":["readme","should test fuzzing","xss / js url"],"updatePoint":{"line":221,"column":25},"line":221,"code":"      test('xss / case #6', () => {\n        expect(\n          parseReadme('![XSS](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)\\\\')\n        ).toEqual(\n          '<p><img alt=\"XSS\" src=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3Nj' +\n            'cmlwdD4K\">\\\\</p>'\n        );\n      });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"xss / case #7","suites":["readme","should test fuzzing","xss / js url"],"line":231,"code":"      test.skip('xss / case #7', () => {","file":"readme.spec.ts","skipped":true,"dir":"packages/core/readme/tests"},{"name":"should parse marked","suites":["readme","mix readmes / markdown"],"updatePoint":{"line":240,"column":29},"line":240,"code":"    test('should parse marked', async () => {\n      const readme: string = await readReadme('mixed-html-mk');\n\n      expect(clean(parseReadme(readme) as string)).toMatchInlineSnapshot(\n        '\"<h1 id=\\\\\"mix-html-and-xss-markdown\\\\\">mix html and XSS markdown</h1><p><a>Basic<' +\n          '/a></p><p><a href=\\\\\"https://github.com/webpack/webpack\\\\\"><img src=\\\\\"https://webp' +\n          'ack.js.org/assets/icon-square-big.svg\\\\\" height=\\\\\"200\\\\\" width=\\\\\"200\\\\\"></a></p>\"'\n      );\n    });","file":"readme.spec.ts","skipped":false,"dir":"packages/core/readme/tests"},{"name":"should delay events on ReadTarball abort","suites":["mystreams"],"updatePoint":{"line":4,"column":48},"line":4,"code":"  test('should delay events on ReadTarball abort', (cb) => {\n    const readTballStream = new ReadTarball({});\n    readTballStream.abort();\n    setTimeout(function () {\n      readTballStream.abort = function (): void {\n        cb();\n      };\n      readTballStream.abort = function (): never {\n        throw Error('fail');\n      };\n    }, 10);\n  });","file":"mystreams.test.ts","skipped":false,"dir":"packages/core/streams/test"},{"name":"should delay events on UploadTarball abort","suites":["mystreams"],"updatePoint":{"line":17,"column":50},"line":17,"code":"  test('should delay events on UploadTarball abort', (cb) => {\n    const uploadTballStream = new UploadTarball({});\n    uploadTballStream.abort();\n    setTimeout(function () {\n      uploadTballStream.abort = function (): void {\n        cb();\n      };\n      uploadTballStream.abort = function (): never {\n        throw Error('fail');\n      };\n    }, 10);\n  });","file":"mystreams.test.ts","skipped":false,"dir":"packages/core/streams/test"},{"name":"should build a URI for dist tarball based on new domain","suites":["convertDistRemoteToLocalTarballUrls"],"updatePoint":{"line":26,"column":63},"line":26,"code":"  test('should build a URI for dist tarball based on new domain', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: fakeHost,\n        [HEADERS.FORWARDED_PROTO]: 'http',\n      },\n      url: '/',\n    });\n    const convertDist = convertDistRemoteToLocalTarballUrls(cloneMetadata(), {\n      host: req.hostname,\n      headers: req.headers as any,\n      protocol: req.protocol,\n    });\n    expect(convertDist.versions['1.0.0'].dist.tarball).toEqual(buildURI(fakeHost, '1.0.0'));\n    expect(convertDist.versions['1.0.1'].dist.tarball).toEqual(buildURI(fakeHost, '1.0.1'));\n  });","file":"convertDistRemoteToLocalTarballUrls.spec.ts","skipped":false,"dir":"packages/core/tarball/tests"},{"name":"should return same URI whether host is missing","suites":["convertDistRemoteToLocalTarballUrls"],"updatePoint":{"line":44,"column":54},"line":44,"code":"  test('should return same URI whether host is missing', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'http',\n      },\n      url: '/',\n    });\n    const convertDist = convertDistRemoteToLocalTarballUrls(cloneMetadata(), {\n      host: req.hostname,\n      headers: req.headers as any,\n      protocol: req.protocol,\n    });\n    expect(convertDist.versions['1.0.0'].dist.tarball).toEqual(\n      convertDist.versions['1.0.0'].dist.tarball\n    );\n  });","file":"convertDistRemoteToLocalTarballUrls.spec.ts","skipped":false,"dir":"packages/core/tarball/tests"},{"name":"should return same URI whether host is undefined","suites":["convertDistRemoteToLocalTarballUrls"],"updatePoint":{"line":62,"column":56},"line":62,"code":"  test('should return same URI whether host is undefined', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: undefined,\n      },\n      url: '/',\n    });\n    const convertDist = convertDistRemoteToLocalTarballUrls(cloneMetadata(), {\n      host: req.hostname,\n      headers: req.headers as any,\n      protocol: req.protocol,\n    });\n    expect(convertDist.versions['1.0.0'].dist.tarball).toEqual(\n      convertDist.versions['1.0.0'].dist.tarball\n    );\n  });","file":"convertDistRemoteToLocalTarballUrls.spec.ts","skipped":false,"dir":"packages/core/tarball/tests"},{"name":"should create a URI","suites":["combineBaseUrl"],"updatePoint":{"line":4,"column":27},"line":4,"code":"  test('should create a URI', () => {\n    expect(combineBaseUrl('http', 'domain')).toEqual('http://domain/');\n  });","file":"combineBaseUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should create a base url for registry","suites":["combineBaseUrl"],"updatePoint":{"line":8,"column":45},"line":8,"code":"  test('should create a base url for registry', () => {\n    expect(combineBaseUrl('http', 'domain.com', '')).toEqual('http://domain.com/');\n    expect(combineBaseUrl('http', 'domain.com', '/')).toEqual('http://domain.com/');\n    expect(combineBaseUrl('http', 'domain.com', '/prefix/')).toEqual('http://domain.com/prefix/');\n    expect(combineBaseUrl('http', 'domain.com', '/prefix/deep')).toEqual(\n      'http://domain.com/prefix/deep/'\n    );\n    expect(combineBaseUrl('http', 'domain.com', 'prefix/')).toEqual('http://domain.com/prefix/');\n    expect(combineBaseUrl('http', 'domain.com', 'prefix')).toEqual('http://domain.com/prefix/');\n  });","file":"combineBaseUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"invalid url prefix","suites":["combineBaseUrl"],"updatePoint":{"line":19,"column":26},"line":19,"code":"  test('invalid url prefix', () => {\n    expect(combineBaseUrl('http', 'domain.com', 'only-prefix')).toEqual(\n      'http://domain.com/only-prefix/'\n    );\n    expect(combineBaseUrl('https', 'domain.com', 'only-prefix')).toEqual(\n      'https://domain.com/only-prefix/'\n    );\n  });","file":"combineBaseUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get empty string with missing host header","suites":["host"],"updatePoint":{"line":10,"column":49},"line":10,"code":"  test('get empty string with missing host header', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      url: '/',\n    });\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get a valid host","suites":["host"],"updatePoint":{"line":24,"column":24},"line":24,"code":"  test('get a valid host', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n      },\n      url: '/',\n    });\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"check a valid host header injection","suites":["host"],"updatePoint":{"line":41,"column":43},"line":41,"code":"  test('check a valid host header injection', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: `some.com\"><svg onload=\"alert(1)\">`,\n      },\n      hostname: `some.com\"><svg onload=\"alert(1)\">`,\n      url: '/',\n    });\n    expect(function () {\n      getPublicUrl('', {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      });\n    }).toThrow('invalid host');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get a valid host with prefix","suites":["host"],"updatePoint":{"line":59,"column":36},"line":59,"code":"  test('get a valid host with prefix', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl('/prefix/', {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/prefix/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get a valid host with prefix no trailing","suites":["host"],"updatePoint":{"line":77,"column":48},"line":77,"code":"  test('get a valid host with prefix no trailing', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl('/prefix-no-trailing', {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/prefix-no-trailing/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"get a valid host with null prefix","suites":["host"],"updatePoint":{"line":95,"column":41},"line":95,"code":"  test('get a valid host with null prefix', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(null, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a valid X-Forwarded-Proto https","suites":["X-Forwarded-Proto"],"updatePoint":{"line":115,"column":44},"line":115,"code":"  test('with a valid X-Forwarded-Proto https', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https","suites":["X-Forwarded-Proto"],"updatePoint":{"line":134,"column":46},"line":134,"code":"  test('with a invalid X-Forwarded-Proto https', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProto',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a HAProxy X-Forwarded-Proto https","suites":["X-Forwarded-Proto"],"updatePoint":{"line":153,"column":46},"line":153,"code":"  test('with a HAProxy X-Forwarded-Proto https', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https,https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a HAProxy X-Forwarded-Proto different protocol","suites":["X-Forwarded-Proto"],"updatePoint":{"line":172,"column":59},"line":172,"code":"  test('with a HAProxy X-Forwarded-Proto different protocol', () => {\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'http,https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a valid X-Forwarded-Proto https and env variable","suites":["env variable"],"updatePoint":{"line":193,"column":61},"line":193,"code":"  test('with a valid X-Forwarded-Proto https and env variable', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'https://env.domain.com';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://env.domain.com/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a valid X-Forwarded-Proto https and env variable with prefix","suites":["env variable"],"updatePoint":{"line":214,"column":73},"line":214,"code":"  test('with a valid X-Forwarded-Proto https and env variable with prefix', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'https://env.domain.com/urlPrefix/';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'https',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://env.domain.com/urlPrefix/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https and env variable","suites":["env variable"],"updatePoint":{"line":235,"column":63},"line":235,"code":"  test('with a invalid X-Forwarded-Proto https and env variable', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'https://env.domain.com/';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProtocol',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('https://env.domain.com/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https and invalid url with env variable","suites":["env variable"],"updatePoint":{"line":256,"column":80},"line":256,"code":"  test('with a invalid X-Forwarded-Proto https and invalid url with env variable', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'ftp://env.domain.com';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProtocol',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https and host injection with host","suites":["env variable"],"updatePoint":{"line":277,"column":75},"line":277,"code":"  test('with a invalid X-Forwarded-Proto https and host injection with host', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'http://injection.test.com\"><svg onload=\"alert(1)\">';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some.com',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProtocol',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some.com/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"with a invalid X-Forwarded-Proto https and host injection with invalid host","suites":["env variable"],"updatePoint":{"line":298,"column":83},"line":298,"code":"  test('with a invalid X-Forwarded-Proto https and host injection with invalid host', () => {\n    process.env.VERDACCIO_PUBLIC_URL = 'http://injection.test.com\"><svg onload=\"alert(1)\">';\n    const req = httpMocks.createRequest({\n      method: 'GET',\n      headers: {\n        host: 'some',\n        [HEADERS.FORWARDED_PROTO]: 'invalidProtocol',\n      },\n      url: '/',\n    });\n\n    expect(\n      getPublicUrl(undefined, {\n        host: req.hostname,\n        headers: req.headers as any,\n        protocol: req.protocol,\n      })\n    ).toEqual('http://some/');\n    delete process.env.VERDACCIO_PUBLIC_URL;\n  });","file":"getPublicUrl.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should handle undefined header","suites":["getWebProtocol"],"updatePoint":{"line":4,"column":38},"line":4,"code":"  test('should handle undefined header', () => {\n    expect(getWebProtocol(undefined, 'http')).toBe('http');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should handle emtpy string","suites":["getWebProtocol"],"updatePoint":{"line":8,"column":34},"line":8,"code":"  test('should handle emtpy string', () => {\n    expect(getWebProtocol('', 'http')).toBe('http');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should have header priority over request protocol","suites":["getWebProtocol"],"updatePoint":{"line":12,"column":57},"line":12,"code":"  test('should have header priority over request protocol', () => {\n    expect(getWebProtocol('https', 'http')).toBe('https');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should have handle empty protocol","suites":["getWebProtocol"],"updatePoint":{"line":16,"column":41},"line":16,"code":"  test('should have handle empty protocol', () => {\n    expect(getWebProtocol('https', '')).toBe('https');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should have handle invalid protocol","suites":["getWebProtocol"],"updatePoint":{"line":20,"column":43},"line":20,"code":"  test('should have handle invalid protocol', () => {\n    expect(getWebProtocol('ftp', '')).toBe('http');\n  });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should handle http","suites":["getWebProtocol","getWebProtocol and HAProxy variant"],"updatePoint":{"line":26,"column":28},"line":26,"code":"    test('should handle http', () => {\n      expect(getWebProtocol('http,http', 'https')).toBe('http');\n    });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should handle https","suites":["getWebProtocol","getWebProtocol and HAProxy variant"],"updatePoint":{"line":30,"column":29},"line":30,"code":"    test('should handle https', () => {\n      expect(getWebProtocol('https,https', 'http')).toBe('https');\n    });","file":"getWebProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should be HTTP/HTTPS protocol","suites":[],"updatePoint":{"line":3,"column":35},"line":3,"code":"test('should be HTTP/HTTPS protocol', () => {\n  expect(isURLhasValidProtocol('http://domain.com/-/static/logo.png')).toBeTruthy();\n  expect(isURLhasValidProtocol('https://www.domain.com/-/static/logo.png')).toBeTruthy();\n  expect(isURLhasValidProtocol('//domain.com/-/static/logo.png')).toBeTruthy();\n});","file":"htttProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"should not be a valid HTTP protocol","suites":[],"updatePoint":{"line":9,"column":41},"line":9,"code":"test('should not be a valid HTTP protocol', () => {\n  expect(isURLhasValidProtocol('file:///home/user/logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('file:///F:/home/user/logo.png')).toBeFalsy();\n  // Note that uses ftp protocol in src was deprecated in modern browsers\n  expect(isURLhasValidProtocol('ftp://1.2.3.4/home/user/logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('./logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('.\\\\logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('../logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('..\\\\logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('../../static/logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('..\\\\..\\\\static\\\\logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('.logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('/static/logo.png')).toBeFalsy();\n  expect(isURLhasValidProtocol('F:\\\\static\\\\logo.png')).toBeFalsy();\n});","file":"htttProtocol.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"valid host","suites":[],"updatePoint":{"line":3,"column":16},"line":3,"code":"test('valid host', () => {\n  expect(isHost('http://ddd.dd.og')).toBeTruthy();\n  expect(isHost('https://ddd.dd.og')).toBeTruthy();\n  expect(isHost('https://ddd.dd.og/valid')).toBeTruthy();\n  expect(isHost('ddd.dd.og')).toBeTruthy();\n  expect(isHost('ddd.dd.og:40')).toBeTruthy();\n  expect(isHost('ddd.dd.og/someprefix')).toBeTruthy();\n});","file":"validHost.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"invalid","suites":[],"updatePoint":{"line":12,"column":13},"line":12,"code":"test('invalid', () => {\n  expect(isHost('/ddd.dd.og:40')).toBeFalsy();\n  expect(isHost('/')).toBeFalsy();\n  expect(isHost('')).toBeFalsy();\n  expect(isHost(undefined)).toBeFalsy();\n  expect(isHost(`/ddd.dd.og>\"<svg onload=\"alert(1)\">`)).toBeFalsy();\n});","file":"validHost.spec.ts","skipped":false,"dir":"packages/core/url/tests"},{"name":"when sending a empty notification","suites":["Notifications:: notifyRequest"],"updatePoint":{"line":28,"column":41},"line":28,"code":"  test('when sending a empty notification', async () => {\n    const mockAgent = new MockAgent({ connections: 1 });\n    setGlobalDispatcher(mockAgent);\n    const mockClient = mockAgent.get(domain);\n    mockClient.intercept(options).reply(200, { body: 'test' });\n\n    const notificationResponse = await notify({}, {}, createRemoteUser('foo', []), 'bar');\n    expect(notificationResponse).toEqual([false]);\n  });","file":"notify-request.spec.ts","skipped":false,"dir":"packages/hooks/test"},{"name":"when sending a single notification","suites":["Notifications:: notifyRequest"],"updatePoint":{"line":38,"column":42},"line":38,"code":"  test('when sending a single notification', async () => {\n    const mockAgent = new MockAgent({ connections: 1 });\n    setGlobalDispatcher(mockAgent);\n    const mockClient = mockAgent.get(domain);\n    mockClient.intercept(options).reply(200, { body: 'test' });\n\n    const notificationResponse = await notify(\n      {},\n      singleHeaderNotificationConfig,\n      createRemoteUser('foo', []),\n      'bar'\n    );\n    expect(notificationResponse).toEqual([true]);\n    await mockClient.close();\n  });","file":"notify-request.spec.ts","skipped":false,"dir":"packages/hooks/test"},{"name":"when notification endpoint is missing","suites":["Notifications:: notifyRequest"],"updatePoint":{"line":54,"column":45},"line":54,"code":"  test('when notification endpoint is missing', async () => {\n    const mockAgent = new MockAgent({ connections: 1 });\n    setGlobalDispatcher(mockAgent);\n    const mockClient = mockAgent.get(domain);\n    mockClient.intercept(options).reply(200, { body: 'test' });\n    const name = 'package';\n    const config: Partial<Config> = {\n      // @ts-ignore\n      notify: {\n        method: 'POST',\n        endpoint: undefined,\n        content: '',\n      },\n    };\n    const notificationResponse = await notify({ name }, config, createRemoteUser('foo', []), 'bar');\n    expect(notificationResponse).toEqual([false]);\n  });","file":"notify-request.spec.ts","skipped":false,"dir":"packages/hooks/test"},{"name":"when multiple notifications","suites":["Notifications:: notifyRequest"],"updatePoint":{"line":72,"column":35},"line":72,"code":"  test('when multiple notifications', async () => {\n    const mockAgent = new MockAgent({ connections: 1 });\n    setGlobalDispatcher(mockAgent);\n    const mockClient = mockAgent.get(domain);\n    mockClient.intercept(options).reply(200, { body: 'test' });\n    mockClient.intercept(options).reply(400, {});\n    mockClient.intercept(options).reply(500, { message: 'Something bad happened' });\n\n    const name = 'package';\n    const responses = await notify({ name }, multiNotificationConfig, { name: 'foo' }, 'bar');\n    expect(responses).toEqual([true, false, false]);\n    await mockClient.close();\n  });","file":"notify-request.spec.ts","skipped":false,"dir":"packages/hooks/test"},{"name":"testing auth valid plugin loader","suites":["plugin loader","auth plugins"],"updatePoint":{"line":22,"column":42},"line":22,"code":"    test('testing auth valid plugin loader', () => {\n      const _config = buildConf('verdaccio-plugin');\n      // @ts-ignore\n      const plugins = loadPlugin(_config, _config.auth, {}, function (plugin) {\n        return plugin.authenticate || plugin.allow_access || plugin.allow_publish;\n      });\n\n      expect(plugins).toHaveLength(1);\n    });","file":"plugin_loader.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing storage valid plugin loader","suites":["plugin loader","auth plugins"],"updatePoint":{"line":32,"column":45},"line":32,"code":"    test('testing storage valid plugin loader', () => {\n      const _config = buildConf('verdaccio-es6-plugin');\n      // @ts-ignore\n      const plugins = loadPlugin(_config, _config.auth, {}, function (p) {\n        return p.getPackageStorage;\n      });\n\n      expect(plugins).toHaveLength(1);\n    });","file":"plugin_loader.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing auth plugin invalid plugin","suites":["plugin loader","auth plugins"],"updatePoint":{"line":42,"column":44},"line":42,"code":"    test('testing auth plugin invalid plugin', () => {\n      const _config = buildConf('invalid-plugin');\n      try {\n        // @ts-ignore\n        loadPlugin(_config, _config.auth, {}, function (p) {\n          return p.authenticate || p.allow_access || p.allow_publish;\n        });\n      } catch (e: any) {\n        expect(e.message).toEqual(\n          `\"${relativePath}/invalid-plugin\" plugin does not have the right code structure`\n        );\n      }\n    });","file":"plugin_loader.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing auth plugin invalid plugin sanityCheck","suites":["plugin loader","auth plugins"],"updatePoint":{"line":56,"column":56},"line":56,"code":"    test('testing auth plugin invalid plugin sanityCheck', () => {\n      const _config = buildConf('invalid-plugin-sanity');\n      try {\n        // @ts-ignore\n        loadPlugin(_config, _config.auth, {}, function (plugin) {\n          return plugin.authenticate || plugin.allow_access || plugin.allow_publish;\n        });\n      } catch (err: any) {\n        expect(err.message).toEqual(\n          `sanity check has failed, \"${relativePath}/invalid-plugin-sanity\" is not a valid plugin`\n        );\n      }\n    });","file":"plugin_loader.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"testing auth plugin no plugins","suites":["plugin loader","auth plugins"],"updatePoint":{"line":70,"column":40},"line":70,"code":"    test('testing auth plugin no plugins', () => {\n      const _config = buildConf('invalid-package');\n      try {\n        // @ts-ignore\n        loadPlugin(_config, _config.auth, {}, function (plugin) {\n          return plugin.authenticate || plugin.allow_access || plugin.allow_publish;\n        });\n      } catch (e: any) {\n        expect(e.message).toMatch('plugin not found');\n        expect(e.message.replace(/\\\\/g, '/')).toMatch(\n          '/partials/test-plugin-storage/invalid-package'\n        );\n      }\n    });","file":"plugin_loader.spec.ts","skipped":false,"dir":"packages/loaders/test"},{"name":"test middleware plugins","suites":["plugin loader","auth plugins"],"line":85,"code":"    test.todo('test middleware plugins');","file":"plugin_loader.spec.ts","skipped":true,"dir":"packages/loaders/test"},{"name":"test storage plugins","suites":["plugin loader","auth plugins"],"line":86,"code":"    test.todo('test storage plugins');","file":"plugin_loader.spec.ts","skipped":true,"dir":"packages/loaders/test"},{"name":"should display config file","suites":["formatter","printMessage"],"updatePoint":{"line":14,"column":36},"line":14,"code":"    test('should display config file', () => {\n      const log = {\n        level: 40,\n        time: 1585410824129,\n        v: 1,\n        pid: 27029,\n        hostname: 'localhost',\n        file: '/Users/user/.config/verdaccio/config/config.yaml',\n        msg: 'config file  - @{file}',\n      };\n\n      expect(printMessage(log, prettyfierOptions)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display trace level","suites":["formatter","printMessage"],"updatePoint":{"line":28,"column":36},"line":28,"code":"    test('should display trace level', () => {\n      const log = {\n        level: 10,\n        foo: 'foo',\n        msg: '[trace]  - @{foo}',\n      };\n\n      expect(printMessage(log, prettyfierOptions)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display trace level with pretty stamp","suites":["formatter","printMessage"],"updatePoint":{"line":38,"column":54},"line":38,"code":"    test('should display trace level with pretty stamp', () => {\n      const log = {\n        level: 10,\n        foo: 'foo',\n        time: 1585411248203,\n        msg: '[trace]  - @{foo}',\n      };\n\n      expect(\n        printMessage(\n          log,\n          Object.assign({}, prettyfierOptions, {\n            prettyStamp: true,\n          })\n        )\n      ).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display a bytes request","suites":["formatter","printMessage"],"updatePoint":{"line":56,"column":40},"line":56,"code":"    test('should display a bytes request', () => {\n      const log = {\n        level: 35,\n        time: 1585411248203,\n        v: 1,\n        pid: 27029,\n        hostname: 'macbook-touch',\n        sub: 'in',\n        request: { method: 'GET', url: '/verdaccio' },\n        user: null,\n        remoteIP: '127.0.0.1',\n        status: 200,\n        error: undefined,\n        bytes: { in: 0, out: 150186 },\n        msg:\n          \"@{status}, user: @{user}(@{remoteIP}), req: '@{request.method} @{request.url}', \" +\n          'bytes: @{bytes.in}/@{bytes.out}',\n      };\n\n      expect(printMessage(log, prettyfierOptions)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display an error request","suites":["formatter","printMessage"],"updatePoint":{"line":78,"column":41},"line":78,"code":"    test('should display an error request', () => {\n      const log = {\n        level: 54,\n        time: 1585416029123,\n        v: 1,\n        pid: 30032,\n        hostname: 'macbook-touch',\n        sub: 'out',\n        err: {\n          type: 'Error',\n          message: 'getaddrinfo ENOTFOUND registry.fake.org',\n          stack:\n            'Error: getaddrinfo ENOTFOUND registry.fake.org\\n' +\n            '    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:60:26)',\n          errno: -3008,\n          code: 'ENOTFOUND',\n          syscall: 'getaddrinfo',\n          hostname: 'registry.fake.org',\n        },\n        request: { method: 'GET', url: 'https://registry.fake.org/aaa' },\n        status: 'ERR',\n        error: 'getaddrinfo ENOTFOUND registry.fake.org',\n        bytes: { in: 0, out: 0 },\n        msg: \"@{!status}, req: '@{request.method} @{request.url}', error: @{!error}\",\n      };\n\n      expect(printMessage(log, prettyfierOptions)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display an fatal request","suites":["formatter","printMessage"],"updatePoint":{"line":107,"column":41},"line":107,"code":"    test('should display an fatal request', () => {\n      const log = {\n        level: 60,\n        time: 1585416029123,\n        v: 1,\n        pid: 30032,\n        hostname: 'macbook-touch',\n        sub: 'out',\n        err: {\n          type: 'Error',\n          message: 'fatal error',\n          stack: '....',\n          errno: -3008,\n          code: 'ENOTFOUND',\n        },\n        request: { method: 'GET', url: 'https://registry.fake.org/aaa' },\n        status: 'ERR',\n        error: 'fatal error',\n        bytes: { in: 0, out: 0 },\n        msg: \"@{!status}, req: '@{request.method} @{request.url}', error: @{!error}\",\n      };\n\n      expect(printMessage(log, prettyfierOptions)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display a streaming request","suites":["formatter","printMessage"],"updatePoint":{"line":132,"column":44},"line":132,"code":"    test('should display a streaming request', () => {\n      const log = {\n        level: 35,\n        time: 1585411247920,\n        v: 1,\n        pid: 27029,\n        hostname: 'macbook-touch',\n        sub: 'out',\n        request: { method: 'GET', url: 'https://registry.npmjs.org/verdaccio' },\n        status: 304,\n        msg: \"@{!status}, req: '@{request.method} @{request.url}' (streaming)\",\n      };\n\n      expect(printMessage(log, prettyfierOptions)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display version and http address","suites":["formatter","printMessage"],"updatePoint":{"line":148,"column":49},"line":148,"code":"    test('should display version and http address', () => {\n      const log = {\n        level: 40,\n        time: 1585410824322,\n        v: 1,\n        pid: 27029,\n        hostname: 'macbook-touch',\n        addr: 'http://localhost:4873/',\n        version: 'verdaccio/5.0.0',\n        msg: 'http address - @{addr} - @{version}',\n      };\n\n      expect(printMessage(log, prettyfierOptions)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display custom log message","suites":["formatter","printMessage"],"updatePoint":{"line":163,"column":43},"line":163,"code":"    test('should display custom log message', () => {\n      const level: LevelCode = 15;\n      const log = {\n        level,\n        something: 'foo',\n        msg: 'custom - @{something} - @{missingParam}',\n      };\n\n      expect(printMessage(log, prettyfierOptions)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should display a resource request","suites":["formatter","printMessage"],"updatePoint":{"line":174,"column":43},"line":174,"code":"    test('should display a resource request', () => {\n      const log = {\n        level: 30,\n        time: 1585411247622,\n        v: 1,\n        pid: 27029,\n        hostname: 'macbook-touch',\n        sub: 'in',\n        req: {\n          id: undefined,\n          method: 'GET',\n          url: '/verdaccio',\n          headers: {\n            connection: 'keep-alive',\n            'user-agent': 'npm/6.13.2 node/v13.1.0 darwin x64',\n            'npm-in-ci': 'false',\n            'npm-scope': '',\n            'npm-session': 'afebb4748178bd4b',\n            referer: 'view verdaccio',\n            'pacote-req-type': 'packument',\n            'pacote-pkg-id': 'registry:verdaccio',\n            accept: 'application/json',\n            authorization: '<Classified>',\n            'if-none-match': '\"fd6440ba2ad24681077664d8f969e5c3\"',\n            'accept-encoding': 'gzip,deflate',\n            host: 'localhost:4873',\n          },\n          remoteAddress: '127.0.0.1',\n          remotePort: 57968,\n        },\n        ip: '127.0.0.1',\n        msg: \"@{ip} requested '@{req.method} @{req.url}'\",\n      };\n\n      expect(printMessage(log, prettyfierOptions, false)).toMatchSnapshot();\n    });","file":"formatter.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should return a function","suites":["prettyFactory"],"updatePoint":{"line":5,"column":32},"line":5,"code":"  test('should return a function', () => {\n    expect(typeof factory['default']({})).toEqual('function');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should return a function with options","suites":["prettyFactory"],"updatePoint":{"line":9,"column":45},"line":9,"code":"  test('should return a function with options', () => {\n    const log = {\n      level: 10,\n      foo: 'foo',\n      msg: '[trace]  - @{foo}',\n    };\n\n    expect(factory['default'](prettyfierOptions)(log)).toMatchSnapshot();\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/logger-prettify/test"},{"name":"should write message logger","suites":["logger"],"line":22,"code":"  test.skip('should write message logger', () => {","file":"logger.spec.ts","skipped":true,"dir":"packages/logger/test"},{"name":"throw deprecation warning if multiple loggers configured","suites":["logger"],"line":35,"code":"  test.skip('throw deprecation warning if multiple loggers configured', () => {","file":"logger.spec.ts","skipped":true,"dir":"packages/logger/test"},{"name":"regression: do not throw deprecation warning if no logger config is provided","suites":["logger"],"updatePoint":{"line":47,"column":84},"line":47,"code":"  test('regression: do not throw deprecation warning if no logger config is provided', () => {\n    setup();\n    expect(mockWarningUtils).not.toHaveBeenCalled();\n  });","file":"logger.spec.ts","skipped":false,"dir":"packages/logger/test"},{"name":"should get the right version","suites":["Utilities","getVersionFromTarball"],"updatePoint":{"line":5,"column":38},"line":5,"code":"    test('should get the right version', () => {\n      const simpleName = 'test-name-4.2.12.tgz';\n      const complexName = 'test-5.6.4-beta.2.tgz';\n      const otherComplexName = 'test-3.5.0-6.tgz';\n      expect(getVersionFromTarball(simpleName)).toEqual('4.2.12');\n      expect(getVersionFromTarball(complexName)).toEqual('5.6.4-beta.2');\n      expect(getVersionFromTarball(otherComplexName)).toEqual('3.5.0-6');\n    });","file":"middleware-utils.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should don'n fall at incorrect tarball name","suites":["Utilities","getVersionFromTarball"],"updatePoint":{"line":14,"column":53},"line":14,"code":"    test(\"should don'n fall at incorrect tarball name\", () => {\n      expect(getVersionFromTarball('incorrectName')).toBeUndefined();\n    });","file":"middleware-utils.spec.ts","skipped":false,"dir":"packages/middleware/test"},{"name":"should return no address if a single address is wrong","suites":["getListListenAddresses test"],"updatePoint":{"line":11,"column":61},"line":11,"code":"  test('should return no address if a single address is wrong', () => {\n    // @ts-ignore\n    const addrs = getListListenAddresses('wrong');\n\n    expect(_.isArray(addrs)).toBeTruthy();\n    expect(addrs).toHaveLength(0);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return no address if a two address are wrong","suites":["getListListenAddresses test"],"updatePoint":{"line":19,"column":59},"line":19,"code":"  test('should return no address if a two address are wrong', () => {\n    // @ts-ignore\n    const addrs = getListListenAddresses(['wrong', 'same-wrong']);\n\n    expect(_.isArray(addrs)).toBeTruthy();\n    expect(addrs).toHaveLength(0);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return a list of 1 address provided","suites":["getListListenAddresses test"],"updatePoint":{"line":27,"column":50},"line":27,"code":"  test('should return a list of 1 address provided', () => {\n    // @ts-ignore\n    const addrs = getListListenAddresses(null, '1000');\n\n    expect(_.isArray(addrs)).toBeTruthy();\n    expect(addrs).toHaveLength(1);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return a list of 2 address provided","suites":["getListListenAddresses test"],"updatePoint":{"line":35,"column":50},"line":35,"code":"  test('should return a list of 2 address provided', () => {\n    // @ts-ignore\n    const addrs = getListListenAddresses(null, ['1000', '2000']);\n\n    expect(_.isArray(addrs)).toBeTruthy();\n    expect(addrs).toHaveLength(2);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return by default ","suites":["getListListenAddresses test"],"updatePoint":{"line":43,"column":48},"line":43,"code":"  test(`should return by default ${DEFAULT_PORT}`, () => {\n    // @ts-ignore\n    const [addrs] = getListListenAddresses();\n\n    // @ts-ignore\n    expect(addrs.proto).toBe(DEFAULT_PROTOCOL);\n    // @ts-ignore\n    expect(addrs.host).toBe(DEFAULT_DOMAIN);\n    // @ts-ignore\n    expect(addrs.port).toBe(DEFAULT_PORT);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should return default proto, host and custom port","suites":["getListListenAddresses test"],"updatePoint":{"line":55,"column":57},"line":55,"code":"  test('should return default proto, host and custom port', () => {\n    const initPort = '1000';\n    // @ts-ignore\n    const [addrs] = getListListenAddresses(null, initPort);\n\n    // @ts-ignore\n    expect(addrs.proto).toEqual(DEFAULT_PROTOCOL);\n    // @ts-ignore\n    expect(addrs.host).toEqual(DEFAULT_DOMAIN);\n    // @ts-ignore\n    expect(addrs.port).toEqual(initPort);\n  });","file":"node-api.utils.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should parse (%s - %s - %s - %s)","suites":["Parse listen address"],"line":33,"code":"  test.each(useCases)(`should parse (%s - %s - %s - %s)`, (uri, proto, host, port) => {\n    const parsed = parseAddress(uri);\n\n    if (_.isNull(proto)) {\n      expect(parsed).toBeNull();\n    } else if (port) {\n      expect(parsed).toEqual({\n        proto,\n        host,\n        port,\n      });\n    } else {\n      expect(parsed).toEqual({\n        proto,\n        path: host,\n      });\n    }\n  });","file":"parseAddress.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should provide all HTTP server data","suites":["startServer via API"],"updatePoint":{"line":6,"column":43},"line":6,"code":"  test('should provide all HTTP server data', async () => {\n    const webServer = await runServer();\n    expect(webServer).toBeDefined();\n    await request(webServer).get('/').expect(200);\n  });","file":"run-server.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should fail on start with empty configuration","suites":["startServer via API"],"updatePoint":{"line":12,"column":53},"line":12,"code":"  test('should fail on start with empty configuration', async () => {\n    // @ts-expect-error\n    await expect(runServer({})).rejects.toThrow(\n      'AssertionError [ERR_ASSERTION]: CONFIG: storage path not defined'\n    );\n  });","file":"run-server.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"should fail on start with null as entry","suites":["startServer via API"],"updatePoint":{"line":19,"column":47},"line":19,"code":"  test('should fail on start with null as entry', async () => {\n    await expect(runServer(null)).rejects.toThrow('config file must be an object');\n  });","file":"run-server.spec.ts","skipped":false,"dir":"packages/node-api/test"},{"name":"get error when connection fails","suites":["Active Directory Plugin"],"updatePoint":{"line":40,"column":39},"line":40,"code":"  test('get error when connection fails', (done) => {\n    const errorMessage = 'Unknown error';\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(errorMessage, undefined));\n\n    adPlugin.authenticate('', '', (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(logger.warn).toHaveBeenCalled();\n      expect(error.code).toBe(HTTP_STATUS.INTERNAL_ERROR);\n      expect(error.message).toBe(errorMessage);\n      expect(authUser).toBeUndefined();\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"get error when not authenticated satisfactory","suites":["Active Directory Plugin"],"updatePoint":{"line":54,"column":53},"line":54,"code":"  test('get error when not authenticated satisfactory', (done) => {\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, false));\n\n    adPlugin.authenticate('', '', (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(logger.warn).toHaveBeenCalledWith(NotAuthMessage);\n      expect(error.code).toBe(HTTP_STATUS.UNAUTHORIZED);\n      expect(error.message).toBe(NotAuthMessage);\n      expect(authUser).toBeUndefined();\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"connect satisfactory without groups","suites":["Active Directory Plugin"],"updatePoint":{"line":67,"column":43},"line":67,"code":"  test('connect satisfactory without groups', (done) => {\n    const user = 'user';\n    const password = 'password';\n\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n\n    adPlugin.authenticate(user, password, (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(logger.info).toHaveBeenCalled();\n      expect(error).toBeNull();\n      expect(authUser).toStrictEqual([user]);\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"get error when getting groups for user","suites":["Active Directory Plugin"],"updatePoint":{"line":82,"column":46},"line":82,"code":"  test('get error when getting groups for user', (done) => {\n    const errorMessage = 'Unknown error retrieving groups';\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n    ActiveDirectory.prototype.getGroupMembershipForUser = jest.fn((_, cb) =>\n      cb(errorMessage as unknown as object, null)\n    ) as jest.Mock;\n\n    adPluginSingleGroup.authenticate('', '', (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(ActiveDirectory.prototype.getGroupMembershipForUser).toHaveBeenCalled();\n      expect(logger.warn).toHaveBeenCalled();\n      expect(error.code).toBe(HTTP_STATUS.INTERNAL_ERROR);\n      expect(error.message).toBe(errorMessage);\n      expect(authUser).toBeUndefined();\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"get error when user groups do not match","suites":["Active Directory Plugin"],"updatePoint":{"line":100,"column":47},"line":100,"code":"  test('get error when user groups do not match', (done) => {\n    const user = 'user';\n    const password = 'password';\n\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n    ActiveDirectory.prototype.getGroupMembershipForUser = jest.fn((_, cb) =>\n      cb(null, [{ cn: 'notMatchGroup' }])\n    ) as jest.Mock;\n\n    adPluginSingleGroup.authenticate(user, password, (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(ActiveDirectory.prototype.getGroupMembershipForUser).toHaveBeenCalled();\n      expect(logger.warn).toHaveBeenCalled();\n      expect(error.code).toBe(HTTP_STATUS.FORBIDDEN);\n      expect(error.message).toBe(\n        `AD - User ${user} is not member of group(s): ${configSingleGroup.groupName}`\n      );\n      expect(authUser).toBeUndefined();\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"connect satisfactory when connection has only one group defined","suites":["Active Directory Plugin"],"updatePoint":{"line":122,"column":71},"line":122,"code":"  test('connect satisfactory when connection has only one group defined', (done) => {\n    const { groupName } = configSingleGroup;\n    const user = 'user';\n    const password = 'password';\n\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n    ActiveDirectory.prototype.getGroupMembershipForUser = jest.fn((_, cb) =>\n      cb(null, [{ cn: groupName }])\n    ) as jest.Mock;\n\n    adPluginSingleGroup.authenticate(user, password, (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(ActiveDirectory.prototype.getGroupMembershipForUser).toHaveBeenCalled();\n      expect(logger.info).toHaveBeenCalled();\n      expect(error).toBeNull();\n      expect(authUser).toStrictEqual([groupName, user]);\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"connect satisfactory when connection has multiple groups defined","suites":["Active Directory Plugin"],"updatePoint":{"line":142,"column":72},"line":142,"code":"  test('connect satisfactory when connection has multiple groups defined', (done) => {\n    const [, group2, group3] = configMultiGroups.groupName;\n    const user = 'user';\n    const password = 'password';\n\n    ActiveDirectory.prototype.authenticate = jest.fn((_1, _2, cb) => cb(null, true));\n    ActiveDirectory.prototype.getGroupMembershipForUser = jest.fn((_, cb) =>\n      cb(null, [{ cn: group2 }, { dn: group3 }])\n    ) as jest.Mock;\n\n    adPluginMultiGroups.authenticate(user, password, (error, authUser) => {\n      expect(ActiveDirectory.prototype.authenticate).toHaveBeenCalled();\n      expect(ActiveDirectory.prototype.getGroupMembershipForUser).toHaveBeenCalled();\n      expect(logger.info).toHaveBeenCalled();\n      expect(error).toBeNull();\n      expect(authUser).toStrictEqual([group2, group3, user]);\n      done();\n    });\n  });","file":"active-directory.test.ts","skipped":false,"dir":"packages/plugins/active-directory/tests"},{"name":"should test audit","suites":["Audit plugin"],"updatePoint":{"line":20,"column":25},"line":20,"code":"  test('should test audit', () => {\n    const audit = new ProxyAudit(config, { logger, config: undefined });\n    expect(audit).toBeDefined();\n  });","file":"audit.spec.ts","skipped":false,"dir":"packages/plugins/audit/tests"},{"name":"should test audit with configuration","suites":["Audit plugin"],"updatePoint":{"line":25,"column":44},"line":25,"code":"  test('should test audit with configuration', () => {\n    const config = { strict_ssl: false } as ConfigAudit;\n    const audit = new ProxyAudit(config, { logger, config: config });\n    expect(audit).toBeDefined();\n    expect(audit.strict_ssl).toBeFalsy();\n  });","file":"audit.spec.ts","skipped":false,"dir":"packages/plugins/audit/tests"},{"name":"adds users","suites":["Memory","#adduser"],"updatePoint":{"line":27,"column":20},"line":27,"code":"    test('adds users', function (done) {\n      auth.adduser('test', 'secret', function (err, user) {\n        expect(err).toBeNull();\n        expect(user).toEqual('test');\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"login existing users","suites":["Memory","#adduser"],"updatePoint":{"line":35,"column":30},"line":35,"code":"    test('login existing users', function (done) {\n      auth.adduser('test', 'secret', function (err, user) {\n        expect(err).toBeNull();\n        expect(user).toEqual('test');\n        auth.adduser('test', 'secret', function (err, user) {\n          expect(err).toBeNull();\n          expect(user).toBe(true);\n          done();\n        });\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"max users reached","suites":["Memory","#adduser"],"updatePoint":{"line":47,"column":27},"line":47,"code":"    test('max users reached', function (done) {\n      const auth = new Memory({} as VerdaccioMemoryConfig, {\n        config: {\n          max_users: -1,\n        } as VerdaccioMemoryConfig,\n        logger,\n      });\n      auth.adduser('test', 'secret', function (err) {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/maximum amount of users reached/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"replaces password","suites":["Memory","replace user"],"updatePoint":{"line":69,"column":27},"line":69,"code":"    test('replaces password', function (done) {\n      auth.adduser('test', 'new_secret', function (err, user) {\n        expect(err).toBeNull();\n        expect(user).toEqual('test');\n        auth.authenticate('test', 'new_secret', function (err) {\n          expect(err).toBeNull();\n          done();\n        });\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $all to the package","suites":["Memory","#allow_access"],"updatePoint":{"line":104,"column":60},"line":104,"code":"    test('should be allowed to access as $all to the package', function (done) {\n      accessBy(['$all'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $anonymous to the package","suites":["Memory","#allow_access"],"updatePoint":{"line":108,"column":66},"line":108,"code":"    test('should be allowed to access as $anonymous to the package', function (done) {\n      accessBy(['$anonymous'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $authenticated to the package","suites":["Memory","#allow_access"],"updatePoint":{"line":112,"column":70},"line":112,"code":"    test('should be allowed to access as $authenticated to the package', function (done) {\n      accessBy(['$authenticated'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as test to the package","suites":["Memory","#allow_access"],"updatePoint":{"line":116,"column":60},"line":116,"code":"    test('should be allowed to access as test to the package', function (done) {\n      accessBy(['test'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should not to be allowed to access any package","suites":["Memory","#allow_access"],"updatePoint":{"line":120,"column":56},"line":120,"code":"    test('should not to be allowed to access any package', function (done) {\n      auth.allow_access({}, { access: [], publish: [], proxy: [] }, function (err) {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/not allowed to access package/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should not to be allowed to access the anyOtherUser package","suites":["Memory","#allow_access"],"updatePoint":{"line":128,"column":69},"line":128,"code":"    test('should not to be allowed to access the anyOtherUser package', function (done) {\n      auth.allow_access({}, { access: ['anyOtherUser'], publish: [], proxy: [] }, function (err) {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/not allowed to access package/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $all to the package","suites":["Memory","#allow_publish"],"updatePoint":{"line":160,"column":60},"line":160,"code":"    test('should be allowed to access as $all to the package', function (done) {\n      accessBy(['$all'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $anonymous to the package","suites":["Memory","#allow_publish"],"updatePoint":{"line":164,"column":66},"line":164,"code":"    test('should be allowed to access as $anonymous to the package', function (done) {\n      accessBy(['$anonymous'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as $authenticated to the package","suites":["Memory","#allow_publish"],"updatePoint":{"line":168,"column":70},"line":168,"code":"    test('should be allowed to access as $authenticated to the package', function (done) {\n      accessBy(['$authenticated'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should be allowed to access as test to the package","suites":["Memory","#allow_publish"],"updatePoint":{"line":172,"column":60},"line":172,"code":"    test('should be allowed to access as test to the package', function (done) {\n      accessBy(['test'], done);\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should not to be allowed to access any package","suites":["Memory","#allow_publish"],"updatePoint":{"line":176,"column":56},"line":176,"code":"    test('should not to be allowed to access any package', function (done) {\n      auth.allow_publish({}, { publish: [], proxy: [], access: [] }, function (err) {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/not allowed to publish package/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should not to be allowed to access the anyOtherUser package","suites":["Memory","#allow_publish"],"updatePoint":{"line":184,"column":69},"line":184,"code":"    test('should not to be allowed to access the anyOtherUser package', function (done) {\n      auth.allow_publish({}, { publish: ['anyOtherUser'], proxy: [], access: [] }, function (err) {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/not allowed to publish package/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should change password","suites":["Memory","#changePassword"],"updatePoint":{"line":206,"column":32},"line":206,"code":"    test('should change password', function (done) {\n      auth.changePassword('test', 'secret', 'newSecret', function (err, user) {\n        expect(err).toBeNull();\n        expect(user.password).toEqual('newSecret');\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should fail change password with user not found","suites":["Memory","#changePassword"],"updatePoint":{"line":214,"column":57},"line":214,"code":"    test('should fail change password with user not found', function (done) {\n      auth.changePassword('NOTFOUND', 'secret', 'newSecret', function (err) {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/user not found/);\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"validates existing users","suites":["Memory","#authenticate"],"updatePoint":{"line":230,"column":34},"line":230,"code":"    test('validates existing users', function (done) {\n      auth.authenticate('test', 'secret', function (err, groups) {\n        expect(err).toBeNull();\n        expect(groups).toBeDefined();\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"fails if wrong password","suites":["Memory","#authenticate"],"updatePoint":{"line":238,"column":33},"line":238,"code":"    test('fails if wrong password', function (done) {\n      auth.authenticate('test', 'no-secret', function (err) {\n        expect(err).not.toBeNull();\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"fails if user doesnt exist","suites":["Memory","#authenticate"],"updatePoint":{"line":245,"column":36},"line":245,"code":"    test('fails if user doesnt exist', function (done) {\n      auth.authenticate('john', 'secret', function (err, groups) {\n        expect(err).toBeNull();\n        expect(groups).toBeFalsy();\n        done();\n      });\n    });","file":"index.spec.ts","skipped":false,"dir":"packages/plugins/auth-memory/test"},{"name":"should create an instance","suites":["Local Database"],"updatePoint":{"line":86,"column":33},"line":86,"code":"  test('should create an instance', () => {\n    expect(db).toBeDefined();\n  });","file":"index.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"should create get secret","suites":["Local Database","manages a secret"],"updatePoint":{"line":91,"column":34},"line":91,"code":"    test('should create get secret', async () => {\n      const secretKey = await db.getSecret();\n      expect(secretKey).toBeDefined();\n      expect(typeof secretKey === 'string').toBeTruthy();\n    });","file":"index.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"should create set secret","suites":["Local Database","manages a secret"],"updatePoint":{"line":97,"column":34},"line":97,"code":"    test('should create set secret', async () => {\n      await db.setSecret(config.checkSecretKey());\n      expect(config.secret).toBeDefined();\n      expect(typeof config.secret === 'string').toBeTruthy();\n      const fetchedSecretKey = await db.getSecret();\n      expect(config.secret).toBe(fetchedSecretKey);\n    });","file":"index.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"should add an item to database","suites":["Local Database","Database CRUD"],"updatePoint":{"line":107,"column":40},"line":107,"code":"    test('should add an item to database', (done) => {\n      const pgkName = 'jquery';\n      db.get((err, data) => {\n        expect(err).toBeNull();\n        expect(data).toHaveLength(0);\n\n        db.add(pgkName, (err) => {\n          expect(err).toBeNull();\n          db.get((err, data) => {\n            expect(err).toBeNull();\n            expect(data).toHaveLength(1);\n            done();\n          });\n        });\n      });\n    });","file":"index.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"should remove an item to database","suites":["Local Database","Database CRUD"],"updatePoint":{"line":124,"column":43},"line":124,"code":"    test('should remove an item to database', (done) => {\n      const pgkName = 'jquery';\n      db.get((err, data) => {\n        expect(err).toBeNull();\n        expect(data).toHaveLength(0);\n        db.add(pgkName, (err) => {\n          expect(err).toBeNull();\n          db.remove(pgkName, (err) => {\n            expect(err).toBeNull();\n            db.get((err, data) => {\n              expect(err).toBeNull();\n              expect(data).toHaveLength(0);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"index.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"savePackage()","suites":["S3 package manager","savePackage() group"],"updatePoint":{"line":80,"column":23},"line":80,"code":"    test('savePackage()', (done) => {\n      const data = '{data:5}' as unknown as Package;\n      const packageManager = new S3PackageManager(config, 'first-package', logger);\n\n      packageManager.savePackage('pkg.1.0.0.tar.gz', data, (err) => {\n        expect(err).toBeNull();\n        done();\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"readPackage() success","suites":["S3 package manager","readPackage() group"],"updatePoint":{"line":129,"column":31},"line":129,"code":"    test('readPackage() success', async (done) => {\n      await syncFixtureDir('readme-test');\n\n      const packageManager = new S3PackageManager(config, 'readme-test', logger);\n\n      packageManager.readPackage(pkgFileName, (err) => {\n        expect(err).toBeNull();\n        done();\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"readPackage() fails","suites":["S3 package manager","readPackage() group"],"updatePoint":{"line":140,"column":29},"line":140,"code":"    test('readPackage() fails', async (done) => {\n      await syncFixtureDir('readme-test');\n\n      const packageManager = new S3PackageManager(config, 'readme-test', logger);\n\n      packageManager.readPackage(pkgFileName, (err) => {\n        expect(err).toBeTruthy();\n        done();\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"readPackage() fails corrupt","suites":["S3 package manager","readPackage() group"],"updatePoint":{"line":151,"column":37},"line":151,"code":"    test('readPackage() fails corrupt', async (done) => {\n      await syncFixtureDir('readme-test-corrupt');\n\n      const packageManager = new S3PackageManager(config, 'readme-test-corrupt', logger);\n\n      packageManager.readPackage('corrupt.js', (err) => {\n        expect(err).toBeTruthy();\n        done();\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"createPackage()","suites":["S3 package manager","createPackage() group"],"updatePoint":{"line":164,"column":25},"line":164,"code":"    test('createPackage()', (done) => {\n      const packageManager = new S3PackageManager(config, 'createPackage', logger);\n\n      packageManager.createPackage('package5', pkg, (err) => {\n        expect(err).toBeNull();\n        done();\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"createPackage() fails by fileExist","suites":["S3 package manager","createPackage() group"],"updatePoint":{"line":173,"column":44},"line":173,"code":"    test('createPackage() fails by fileExist', (done) => {\n      const packageManager = new S3PackageManager(config, 'createPackage', logger);\n\n      packageManager.createPackage('package5', pkg, (err) => {\n        expect(err).toBeNull();\n        packageManager.createPackage('package5', pkg, (err) => {\n          expect(err).not.toBeNull();\n          expect(err.code).toBe(create409Error().code); // file exists\n          done();\n        });\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"deletePackage()","suites":["S3 package manager","createPackage() group","deletePackage() group"],"updatePoint":{"line":187,"column":27},"line":187,"code":"      test('deletePackage()', (done) => {\n        const packageManager = new S3PackageManager(config, 'createPackage', logger);\n\n        // verdaccio removes the package.json instead the package name\n        packageManager.deletePackage('package.json', (err) => {\n          expect(err).toBeNull();\n          done();\n        });\n      });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"removePackage() success","suites":["S3 package manager","removePackage() group"],"updatePoint":{"line":200,"column":33},"line":200,"code":"    test('removePackage() success', (done) => {\n      const packageManager = new S3PackageManager(config, '_toDelete', logger);\n      packageManager.createPackage('package5', pkg, (err) => {\n        expect(err).toBeNull();\n        packageManager.removePackage((error) => {\n          expect(error).toBeNull();\n          done();\n        });\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"removePackage() fails","suites":["S3 package manager","removePackage() group"],"updatePoint":{"line":211,"column":31},"line":211,"code":"    test('removePackage() fails', (done) => {\n      const packageManager = new S3PackageManager(config, '_toDelete_fake', logger);\n      packageManager.removePackage((error) => {\n        expect(error).toBeTruthy();\n        expect(error.code).toBe(create404Error().code); // file exists\n        done();\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"readTarball() success","suites":["S3 package manager","readTarball() group"],"updatePoint":{"line":222,"column":31},"line":222,"code":"    test('readTarball() success', async (done) => {\n      await syncFixtureDir('readme-test');\n\n      const packageManager = new S3PackageManager(config, 'readme-test', logger);\n      const readTarballStream = packageManager.readTarball('test-readme-0.0.0.tgz');\n\n      readTarballStream.on('error', (err) => {\n        expect(err).toBeNull();\n      });\n\n      readTarballStream.on('content-length', (content) => {\n        expect(content).toBe(352);\n      });\n\n      readTarballStream.on('end', () => {\n        done();\n      });\n\n      readTarballStream.on('data', (data) => {\n        expect(data).toBeDefined();\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"readTarball() fails","suites":["S3 package manager","readTarball() group"],"updatePoint":{"line":245,"column":29},"line":245,"code":"    test('readTarball() fails', async (done) => {\n      await syncFixtureDir('readme-test');\n\n      const packageManager = new S3PackageManager(config, 'readme-test', logger);\n      const readTarballStream = packageManager.readTarball('file-does-not-exist-0.0.0.tgz');\n\n      readTarballStream.on('error', function (err) {\n        expect(err).toBeTruthy();\n        done();\n      });\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"writeTarball() success","suites":["S3 package manager","writeTarball() group"],"updatePoint":{"line":259,"column":32},"line":259,"code":"    test('writeTarball() success', async (done) => {\n      await syncFixtureDir('readme-test');\n\n      const newFileName = 'new-readme-0.0.0.tgz';\n      const readmeStorage = new S3PackageManager(config, 'readme-test', logger);\n      const writeStorage = new S3PackageManager(config, 'write-storage', logger);\n      const readTarballStream = readmeStorage.readTarball('test-readme-0.0.0.tgz');\n      const writeTarballStream = writeStorage.writeTarball(newFileName);\n\n      writeTarballStream.on('error', function (err) {\n        expect(err).toBeNull();\n        done.fail(new Error(\"shouldn't have errored\"));\n      });\n\n      writeTarballStream.on('success', () => {\n        done();\n      });\n\n      readTarballStream.on('end', () => {\n        writeTarballStream.done();\n      });\n\n      writeTarballStream.on('data', (data) => {\n        expect(data).toBeDefined();\n      });\n\n      readTarballStream.on('error', (err) => {\n        expect(err).toBeNull();\n        done.fail(new Error(\"shouldn't have errored\"));\n      });\n\n      readTarballStream.pipe(writeTarballStream);\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"writeTarball() fails on existing file","suites":["S3 package manager","writeTarball() group"],"updatePoint":{"line":293,"column":47},"line":293,"code":"    test('writeTarball() fails on existing file', async (done) => {\n      await syncFixtureDir('readme-test');\n\n      const newFileName = 'test-readme-0.0.0.tgz';\n      const storage = new S3PackageManager(config, 'readme-test', logger);\n      const readTarballStream = storage.readTarball('test-readme-0.0.0.tgz');\n      const writeTarballStream = storage.writeTarball(newFileName);\n\n      writeTarballStream.on('error', (err) => {\n        expect(err).toBeTruthy();\n        expect(err.code).toBe('EEXISTS');\n        done();\n      });\n\n      readTarballStream.pipe(writeTarballStream);\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"writeTarball() abort","suites":["S3 package manager","writeTarball() group"],"updatePoint":{"line":310,"column":30},"line":310,"code":"    test('writeTarball() abort', async (done) => {\n      await syncFixtureDir('readme-test');\n\n      const newFileName = 'new-readme-abort-0.0.0.tgz';\n      const readmeStorage = new S3PackageManager(config, 'readme-test', logger);\n      const writeStorage = new S3PackageManager(config, 'write-storage', logger);\n      const readTarballStream = readmeStorage.readTarball('test-readme-0.0.0.tgz');\n      const writeTarballStream = writeStorage.writeTarball(newFileName);\n\n      writeTarballStream.on('error', (err) => {\n        expect(err).toBeTruthy();\n        done();\n      });\n\n      writeTarballStream.on('data', (data) => {\n        expect(data).toBeDefined();\n        writeTarballStream.abort();\n      });\n\n      readTarballStream.pipe(writeTarballStream);\n    });","file":"s3PackageManager.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"existing packages on s3 are not recreated","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":36,"column":49},"line":36,"code":"  test('existing packages on s3 are not recreated', (done) => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'keyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => null) as PackageAccess,\n    } as S3Config;\n\n    mockHeadObject.mockImplementation((params, callback) => {\n      callback();\n    });\n\n    const testPackageManager = new S3PackageManager(config, 'test-package', logger);\n\n    testPackageManager.createPackage('test-0.0.0.tgz', pkg, (err) => {\n      expect(err.message).toEqual('file already exists');\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"new package is created on s3","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":56,"column":36},"line":56,"code":"  test('new package is created on s3', (done) => {\n    expect.assertions(2);\n\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'keyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => null) as PackageAccess,\n    } as S3Config;\n\n    mockHeadObject.mockImplementation((params, callback) => {\n      callback({ code: 'NoSuchKey' }, 'some data');\n    });\n\n    mockPutObject.mockImplementation((params, callback) => {\n      callback();\n    });\n\n    const testPackageManager = new S3PackageManager(config, 'test-package', logger);\n\n    testPackageManager.createPackage('test-0.0.0.tgz', pkg, (err) => {\n      expect(err).toBeUndefined();\n      expect(mockPutObject).toHaveBeenCalled();\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"new package is uploaded to keyprefix if custom storage is not specified","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":82,"column":79},"line":82,"code":"  test('new package is uploaded to keyprefix if custom storage is not specified', (done) => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => null) as PackageAccess,\n    } as S3Config;\n\n    mockHeadObject.mockImplementation((params, callback) => {\n      callback({ code: 'NoSuchKey' }, 'some data');\n    });\n\n    mockPutObject.mockImplementation((params, callback) => {\n      callback();\n    });\n\n    const testPackageManager = new S3PackageManager(config, 'test-package', logger);\n\n    testPackageManager.createPackage('test-0.0.0.tgz', pkg, () => {\n      expect(mockPutObject).toHaveBeenCalledWith(\n        expect.objectContaining({\n          Bucket: 'test-bucket',\n          Key: 'testKeyPrefix/test-package/package.json',\n        }),\n        expect.any(Function)\n      );\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"new package is uploaded to custom storage prefix","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":112,"column":56},"line":112,"code":"  test('new package is uploaded to custom storage prefix', (done) => {\n    expect.assertions(2);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => ({\n        storage: 'customFolder',\n      })) as PackageAccess,\n    } as S3Config;\n\n    mockHeadObject.mockImplementation((params, callback) => {\n      callback({ code: 'NoSuchKey' }, 'some data');\n    });\n\n    mockPutObject.mockImplementation((params, callback) => {\n      callback();\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.createPackage('test-0.0.0.tgz', pkg, () => {\n      expect(mockHeadObject).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Key: 'testKeyPrefix/customFolder/@company/test-package/package.json',\n        },\n        expect.any(Function)\n      );\n      expect(mockPutObject).toHaveBeenCalledWith(\n        expect.objectContaining({\n          Bucket: 'test-bucket',\n          Key: 'testKeyPrefix/customFolder/@company/test-package/package.json',\n        }),\n        expect.any(Function)\n      );\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"delete package with custom folder from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":151,"column":56},"line":151,"code":"  test('delete package with custom folder from s3 bucket', (done) => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => ({\n        storage: 'customFolder',\n      })) as PackageAccess,\n    } as S3Config;\n\n    mockDeleteObject.mockImplementation((params, callback) => {\n      callback();\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.deletePackage('test-0.0.0.tgz', () => {\n      expect(mockDeleteObject).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Key: 'testKeyPrefix/customFolder/@company/test-package/test-0.0.0.tgz',\n        },\n        expect.any(Function)\n      );\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"delete package from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":179,"column":37},"line":179,"code":"  test('delete package from s3 bucket', (done) => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => ({})) as PackageAccess,\n    } as S3Config;\n\n    mockDeleteObject.mockImplementation((params, callback) => {\n      callback();\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.deletePackage('test-0.0.0.tgz', () => {\n      expect(mockDeleteObject).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Key: 'testKeyPrefix/@company/test-package/test-0.0.0.tgz',\n        },\n        expect.any(Function)\n      );\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"remove packages from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":205,"column":38},"line":205,"code":"  test('remove packages from s3 bucket', (done) => {\n    expect.assertions(2);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => ({})) as PackageAccess,\n    } as S3Config;\n\n    mockListObject.mockImplementation((params, callback) => {\n      callback(null, { KeyCount: 1 });\n    });\n\n    mockDeleteObjects.mockImplementation((params, callback) => {\n      callback();\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.removePackage(() => {\n      expect(mockDeleteObjects).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Delete: { Objects: [] },\n        },\n        expect.any(Function)\n      );\n      expect(mockListObject).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Prefix: 'testKeyPrefix/@company/test-package/',\n        },\n        expect.any(Function)\n      );\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"remove packages with custom storage from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":242,"column":58},"line":242,"code":"  test('remove packages with custom storage from s3 bucket', (done) => {\n    expect.assertions(2);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => ({\n        storage: 'customFolder',\n      })) as PackageAccess,\n    } as S3Config;\n\n    mockListObject.mockImplementation((params, callback) => {\n      callback(null, { KeyCount: 1 });\n    });\n\n    mockDeleteObjects.mockImplementation((params, callback) => {\n      callback();\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.removePackage(() => {\n      expect(mockDeleteObjects).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Delete: { Objects: [] },\n        },\n        expect.any(Function)\n      );\n      expect(mockListObject).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Prefix: 'testKeyPrefix/customFolder/@company/test-package/',\n        },\n        expect.any(Function)\n      );\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"read packages with custom storage from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":281,"column":56},"line":281,"code":"  test('read packages with custom storage from s3 bucket', (done) => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => ({\n        storage: 'customStorage',\n      })) as PackageAccess,\n    } as S3Config;\n\n    mockGetObject.mockImplementation((params, callback) => {\n      callback(null, { Body: JSON.stringify({ some: 'data' }) });\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.readPackage('some package', () => {\n      expect(mockGetObject).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Key: 'testKeyPrefix/customStorage/@company/test-package/package.json',\n        },\n        expect.any(Function)\n      );\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"read packages from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":309,"column":36},"line":309,"code":"  test('read packages from s3 bucket', (done) => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => null) as PackageAccess,\n    } as S3Config;\n\n    mockGetObject.mockImplementation((params, callback) => {\n      callback(null, { Body: JSON.stringify({ some: 'data' }) });\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.readPackage('some package', () => {\n      expect(mockGetObject).toHaveBeenCalledWith(\n        {\n          Bucket: 'test-bucket',\n          Key: 'testKeyPrefix/@company/test-package/package.json',\n        },\n        expect.any(Function)\n      );\n      done();\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"read tarballs from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":335,"column":36},"line":335,"code":"  test('read tarballs from s3 bucket', () => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => null) as PackageAccess,\n    } as S3Config;\n\n    mockGetObject.mockImplementation(() => {\n      return {\n        on: jest.fn(() => ({\n          createReadStream: jest.fn(() => ({\n            on: jest.fn(),\n            pipe: jest.fn(),\n          })),\n        })),\n      };\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.readTarball('tarballfile.gz');\n\n    expect(mockGetObject).toHaveBeenCalledWith({\n      Bucket: 'test-bucket',\n      Key: 'testKeyPrefix/@company/test-package/tarballfile.gz',\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"read tarballs for a custom folder from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":364,"column":56},"line":364,"code":"  test('read tarballs for a custom folder from s3 bucket', () => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => ({\n        storage: 'customStorage',\n      })) as PackageAccess,\n    } as S3Config;\n\n    mockGetObject.mockImplementation(() => {\n      return {\n        on: jest.fn(() => ({\n          createReadStream: jest.fn(() => ({\n            on: jest.fn(),\n            pipe: jest.fn(),\n          })),\n        })),\n      };\n    });\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.readTarball('tarballfile.gz');\n\n    expect(mockGetObject).toHaveBeenCalledWith({\n      Bucket: 'test-bucket',\n      Key: 'testKeyPrefix/customStorage/@company/test-package/tarballfile.gz',\n    });\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"write tarballs from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":395,"column":37},"line":395,"code":"  test('write tarballs from s3 bucket', () => {\n    expect.assertions(1);\n\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => null) as PackageAccess,\n    } as S3Config;\n\n    mockHeadObject.mockImplementation(() => {});\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    testPackageManager.writeTarball('tarballfile.gz');\n\n    expect(mockHeadObject).toHaveBeenCalledWith(\n      {\n        Bucket: 'test-bucket',\n        Key: 'testKeyPrefix/@company/test-package/tarballfile.gz',\n      },\n      expect.any(Function)\n    );\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"write tarballs with custom storage from s3 bucket","suites":["S3PackageManager with mocked s3"],"updatePoint":{"line":419,"column":57},"line":419,"code":"  test('write tarballs with custom storage from s3 bucket', () => {\n    expect.assertions(1);\n    const config: S3Config = {\n      bucket: 'test-bucket',\n      keyPrefix: 'testKeyPrefix/',\n      getMatchedPackagesSpec: jest.fn(() => ({\n        storage: 'customStorage',\n      })) as PackageAccess,\n    } as S3Config;\n\n    const testPackageManager = new S3PackageManager(config, '@company/test-package', logger);\n\n    mockHeadObject.mockImplementation(() => {});\n\n    testPackageManager.writeTarball('tarballfile.gz');\n\n    expect(mockHeadObject).toHaveBeenCalledWith(\n      {\n        Bucket: 'test-bucket',\n        Key: 'testKeyPrefix/customStorage/@company/test-package/tarballfile.gz',\n      },\n      expect.any(Function)\n    );\n  });","file":"s3PackageManagerMockedS3.test.ts","skipped":true,"dir":"packages/plugins/aws-storage/tests"},{"name":"should fall back to value if environment variable is not set","suites":["Setting config values"],"updatePoint":{"line":13,"column":68},"line":13,"code":"  test('should fall back to value if environment variable is not set', () => {\n    const expected = bucket;\n    const actual = setConfigValue(bucket);\n\n    expect(actual === expected).toBeTruthy();\n  });","file":"setConfigValue.test.ts","skipped":false,"dir":"packages/plugins/aws-storage/tests"},{"name":"should use the environment variable value","suites":["Setting config values"],"updatePoint":{"line":20,"column":49},"line":20,"code":"  test('should use the environment variable value', async () => {\n    const expected = 'someBucket';\n    process.env[bucket] = expected;\n    const actual = setConfigValue(bucket);\n\n    expect(actual === expected).toBeTruthy();\n  });","file":"setConfigValue.test.ts","skipped":false,"dir":"packages/plugins/aws-storage/tests"},{"name":"should use the environment variable value for session token","suites":["Setting config values"],"updatePoint":{"line":29,"column":67},"line":29,"code":"  test('should use the environment variable value for session token', async () => {\n    const expected = 'mySessionToken';\n    process.env[sessionToken] = expected;\n    const actual = setConfigValue(sessionToken);\n\n    expect(actual === expected).toBeTruthy();\n  });","file":"setConfigValue.test.ts","skipped":false,"dir":"packages/plugins/aws-storage/tests"},{"name":"should create an instance","suites":["Google Cloud Storage","Google Cloud DataStore","should test create instances"],"updatePoint":{"line":37,"column":37},"line":37,"code":"      test('should create an instance', () => {\n        const cloudDatabase = getCloudDatabase(storageConfig);\n\n        expect(cloudDatabase).toBeDefined();\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails on create an instance due to bucket name invalid","suites":["Google Cloud Storage","Google Cloud DataStore","should test create instances"],"updatePoint":{"line":43,"column":73},"line":43,"code":"      test('should fails on create an instance due to bucket name invalid', () => {\n        expect(() => {\n          const testConf: VerdaccioConfigGoogleStorage = _.clone(storageConfig);\n          delete testConf.bucket;\n\n          getCloudDatabase(testConf);\n        }).toThrow(new Error('Google Cloud Storage requires a bucket name, please define one.'));\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails on create an instance fails due projectId invalid","suites":["Google Cloud Storage","Google Cloud DataStore","should test create instances"],"updatePoint":{"line":52,"column":74},"line":52,"code":"      test('should fails on create an instance fails due projectId invalid', () => {\n        expect(() => {\n          const testConf: VerdaccioConfigGoogleStorage = _.clone(storageConfig);\n          delete testConf.projectId;\n\n          getCloudDatabase(testConf);\n        }).toThrow(new Error('Google Cloud Storage requires a ProjectId.'));\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails on config is not to be provided","suites":["Google Cloud Storage","Google Cloud DataStore","should test create instances"],"updatePoint":{"line":61,"column":56},"line":61,"code":"      test('should fails on config is not to be provided', () => {\n        expect(() => {\n          getCloudDatabase(undefined);\n        }).toThrow(new Error(ERROR_MISSING_CONFIG));\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should add an Entity","suites":["Google Cloud Storage","Google Cloud DataStore","DataStore basic calls"],"updatePoint":{"line":71,"column":32},"line":71,"code":"      test('should add an Entity', (done) => {\n        // ** add, remove, get, getPackageStorage\n        jest.doMock('../src/storage-helper', () => {\n          const originalModule = jest.requireActual('../src/storage-helper').default;\n\n          return {\n            __esModule: true,\n            default: class Foo extends originalModule {\n              public datastore: object;\n              public constructor(props) {\n                super(props);\n                this.datastore = {\n                  key: jest.fn(),\n                  save: (): Promise<[]> => Promise.resolve([]),\n                  createQuery: (): string => 'query',\n                  runQuery: (): Promise<object[]> =>\n                    Promise.resolve([\n                      [\n                        {\n                          name: pkgName,\n                        },\n                      ],\n                      {},\n                    ]),\n                };\n              }\n            },\n          };\n        });\n\n        const cloudDatabase = getCloudDatabase(storageConfig);\n        cloudDatabase.add(pkgName, (err: VerdaccioError) => {\n          expect(err).toBeNull();\n\n          cloudDatabase.get((err: VerdaccioError, results: string[]) => {\n            expect(results).not.toBeNull();\n            expect(err).toBeNull();\n            expect(results).toHaveLength(1);\n            expect(results[0]).toBe(pkgName);\n            done();\n          });\n        });\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails add an Entity","suites":["Google Cloud Storage","Google Cloud DataStore","DataStore basic calls"],"updatePoint":{"line":115,"column":38},"line":115,"code":"      test('should fails add an Entity', (done) => {\n        // ** add, remove, get, getPackageStorage\n        jest.doMock('../src/storage-helper', () => {\n          const originalModule = jest.requireActual('../src/storage-helper').default;\n\n          return {\n            __esModule: true,\n            default: class Foo extends originalModule {\n              public datastore: object;\n              public constructor(props) {\n                super(props);\n                this.datastore = {\n                  key: jest.fn(),\n                  save: (): Promise<never> => Promise.reject(new Error('')),\n                  createQuery: (): string => 'query',\n                  runQuery: (): Promise<object[]> =>\n                    Promise.resolve([\n                      [\n                        {\n                          name: pkgName,\n                        },\n                      ],\n                      {},\n                    ]),\n                };\n              }\n            },\n          };\n        });\n\n        const cloudDatabase = getCloudDatabase(storageConfig);\n        cloudDatabase.add(pkgName, (err: VerdaccioError) => {\n          expect(err).not.toBeNull();\n          expect(err.code).toEqual(HTTP_STATUS.INTERNAL_ERROR);\n          done();\n        });\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should delete an entity","suites":["Google Cloud Storage","Google Cloud DataStore","DataStore basic calls"],"updatePoint":{"line":153,"column":35},"line":153,"code":"      test('should delete an entity', (done) => {\n        const deleteDataStore = jest.fn();\n\n        jest.doMock('../src/storage-helper', () => {\n          const originalModule = jest.requireActual('../src/storage-helper').default;\n\n          return {\n            __esModule: true,\n            default: class Foo extends originalModule {\n              public datastore: object;\n              public constructor(props) {\n                super(props);\n                // gcloud sdk uses Symbols for metadata in entities\n                const sym = Symbol('name');\n                this.datastore = {\n                  KEY: sym,\n                  key: jest.fn(() => true),\n                  int: jest.fn(() => 1),\n                  delete: deleteDataStore,\n                  createQuery: (): string => 'query',\n                  runQuery: (): Promise<object[]> => {\n                    const entity = {\n                      name: pkgName,\n                      id: 1,\n                    };\n                    entity[sym] = entity;\n\n                    return Promise.resolve([[entity], {}]);\n                  },\n                };\n              }\n            },\n          };\n        });\n\n        const cloudDatabase = getCloudDatabase(storageConfig);\n\n        cloudDatabase.remove(pkgName, (err, result) => {\n          expect(err).toBeNull();\n          expect(result).not.toBeNull();\n          expect(deleteDataStore).toHaveBeenCalled();\n          expect(deleteDataStore).toHaveBeenCalledTimes(1);\n          done();\n        });\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should get a new instance package storage","suites":["Google Cloud Storage","Google Cloud DataStore","DataStore basic calls"],"updatePoint":{"line":208,"column":53},"line":208,"code":"      test('should get a new instance package storage', () => {\n        const cloudDatabase = getCloudDatabase(storageConfig);\n        const store: ILocalPackageManager = cloudDatabase.getPackageStorage('newInstance');\n        expect(store).not.toBeNull();\n        expect(store).toBeDefined();\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should test saveToken","suites":["Google Cloud Storage","Google Cloud DataStore","should test non implemented methods"],"updatePoint":{"line":217,"column":33},"line":217,"code":"      test('should test saveToken', (done) => {\n        const warn = jest.fn();\n        const cloudDatabase = getCloudDatabase(storageConfig, { ...loggerDefault, warn });\n        cloudDatabase.saveToken({}).catch(() => {\n          expect(warn).toHaveBeenCalled();\n          done();\n        });\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should test deleteToken","suites":["Google Cloud Storage","Google Cloud DataStore","should test non implemented methods"],"updatePoint":{"line":226,"column":35},"line":226,"code":"      test('should test deleteToken', (done) => {\n        const warn = jest.fn();\n        const cloudDatabase = getCloudDatabase(storageConfig, { ...loggerDefault, warn });\n        cloudDatabase.deleteToken({}).catch(() => {\n          expect(warn).toHaveBeenCalled();\n          done();\n        });\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should test readTokens","suites":["Google Cloud Storage","Google Cloud DataStore","should test non implemented methods"],"updatePoint":{"line":235,"column":34},"line":235,"code":"      test('should test readTokens', (done) => {\n        const warn = jest.fn();\n        const cloudDatabase = getCloudDatabase(storageConfig, { ...loggerDefault, warn });\n        cloudDatabase.readTokens({}).catch(() => {\n          expect(warn).toHaveBeenCalled();\n          done();\n        });\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should test search","suites":["Google Cloud Storage","Google Cloud DataStore","should test non implemented methods"],"updatePoint":{"line":244,"column":30},"line":244,"code":"      test('should test search', (done) => {\n        const warn = jest.fn();\n        const cloudDatabase = getCloudDatabase(storageConfig, { ...loggerDefault, warn });\n        cloudDatabase.search(null, () => {\n          expect(warn).toHaveBeenCalled();\n          done();\n        });\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should test sync","suites":["Google Cloud Storage","Google Cloud DataStore","should test non implemented methods"],"updatePoint":{"line":253,"column":28},"line":253,"code":"      test('should test sync', (done) => {\n        const warn = jest.fn();\n        const cloudDatabase = getCloudDatabase(storageConfig, { ...loggerDefault, warn });\n        cloudDatabase.sync();\n        expect(warn).toHaveBeenCalled();\n        done();\n      });","file":"datastore.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should create a package","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:create"],"updatePoint":{"line":94,"column":35},"line":94,"code":"      test('should create a package', (done: jest.DoneCallback) => {\n        jest.doMock('../src/storage-helper', () => {\n          const originalModule = jest.requireActual('../src/storage-helper').default;\n          return {\n            __esModule: true,\n            default: class Foo extends originalModule {\n              public storage: object;\n              public config: object;\n              public constructor(props) {\n                super(props);\n                this.config = {\n                  bucket: 'foo',\n                };\n                this.storage = {\n                  bucket: (name): any => new Bucket(name, false),\n                };\n              }\n            },\n          };\n        });\n\n        const pkg = generatePackage(pkgName);\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store: IPackageStorage = cloudDatabase.getPackageStorage(\n          pkgName\n        ) as IPackageStorageManager;\n        expect(store).not.toBeNull();\n\n        store.createPackage(pkgName, pkg, (err: VerdaccioError) => {\n          expect(err).toBeNull();\n          expect(pkg.name).toBe(pkgName);\n          done();\n        });\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails on package already exist","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:create"],"updatePoint":{"line":129,"column":49},"line":129,"code":"      test('should fails on package already exist', (done) => {\n        jest.doMock('../src/storage-helper', () => {\n          const originalModule = jest.requireActual('../src/storage-helper').default;\n          return {\n            __esModule: true,\n            default: class Foo extends originalModule {\n              public storage: object;\n              public config: object;\n              public constructor(props) {\n                super(props);\n                this.config = {\n                  bucket: 'foo',\n                };\n                this.storage = {\n                  bucket: (name) => new Bucket(name, true),\n                };\n              }\n            },\n          };\n        });\n\n        const pkg = generatePackage(pkgName);\n\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store = cloudDatabase.getPackageStorage(pkgName);\n        expect(store).not.toBeNull();\n        if (store) {\n          store.createPackage(pkgName, pkg, (err: VerdaccioError) => {\n            expect(err).not.toBeNull();\n            store.createPackage(pkgName, pkg, (err: VerdaccioError) => {\n              expect(err).not.toBeNull();\n              expect(err.code).toEqual(HTTP_STATUS.CONFLICT);\n              expect(err.message).toEqual('createPkg1 package already exist');\n              done();\n            });\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails on package unexpected error","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:create"],"updatePoint":{"line":168,"column":52},"line":168,"code":"      test('should fails on package unexpected error', (done) => {\n        const FileMockedFailure = class {\n          public exists(): Promise<never> {\n            return Promise.reject(new Error(API_ERROR.UNKNOWN_ERROR));\n          }\n        };\n\n        jest.doMock('../src/storage-helper', () => {\n          const originalModule = jest.requireActual('../src/storage-helper').default;\n          return {\n            __esModule: true,\n            default: class Foo extends originalModule {\n              public storage: object;\n              public config: object;\n              public constructor(props) {\n                super(props);\n                this.config = {\n                  bucket: 'foo',\n                };\n                this.storage = {\n                  bucket: (name) => new Bucket(name, true, FileMockedFailure),\n                };\n              }\n            },\n          };\n        });\n\n        const pkg = generatePackage(pkgName);\n\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store: IPackageStorage = cloudDatabase.getPackageStorage(\n          pkgName\n        ) as IPackageStorageManager;\n        store.createPackage(pkgName, pkg, (err: VerdaccioError) => {\n          expect(err).not.toBeNull();\n          store.createPackage(pkgName, pkg, (err: VerdaccioError) => {\n            expect(err).not.toBeNull();\n            expect(err.code).toEqual(HTTP_STATUS.INTERNAL_ERROR);\n            expect(err.message).toEqual(API_ERROR.UNKNOWN_ERROR);\n            done();\n          });\n        });\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should save a package","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:create","GoogleCloudStorageHandler:save"],"updatePoint":{"line":214,"column":35},"line":214,"code":"        test('should save a package', (done) => {\n          const pkg = generatePackage(pkgName);\n\n          const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n          const store = cloudDatabase.getPackageStorage(pkgName);\n          expect(store).not.toBeNull();\n          if (store) {\n            store.createPackage(pkgName, pkg, (err: VerdaccioError) => {\n              expect(err).not.toBeNull();\n              expect(pkg.name).toBe(pkgName);\n              done();\n            });\n          }\n        });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should delete an instance","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:delete"],"updatePoint":{"line":235,"column":37},"line":235,"code":"      test('should delete an instance', (done) => {\n        const store = cloudDatabase.getPackageStorage(pkgName);\n        expect(store).not.toBeNull();\n        if (store) {\n          store.deletePackage(pkgFileName, (err: VerdaccioError) => {\n            expect(err).toBeNull();\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fail on delete an instance","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:delete"],"updatePoint":{"line":246,"column":45},"line":246,"code":"      test('should fail on delete an instance', (done) => {\n        const store = cloudDatabase.getPackageStorage('404Fake');\n        expect(store).not.toBeNull();\n        if (store) {\n          store.deletePackage(pkgFileName, (err: VerdaccioError) => {\n            expect(err).not.toBeNull();\n            expect(err.message).toBe(API_ERROR.NO_PACKAGE);\n            expect(err.code).toEqual(HTTP_STATUS.NOT_FOUND);\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should remove an entire package","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:delete"],"updatePoint":{"line":259,"column":43},"line":259,"code":"      test('should remove an entire package', (done) => {\n        // FIXME: relocate this test\n        const cloudDatabase = getCloudDatabase(storageConfig);\n        const store = cloudDatabase.getPackageStorage(pkgExample.name);\n        expect(store).not.toBeNull();\n        if (store) {\n          store.removePackage((err: VerdaccioError) => {\n            // FIXME: we need to implement removePackage\n            expect(err).toBeNull();\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should read a package","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:read"],"updatePoint":{"line":287,"column":33},"line":287,"code":"      test('should read a package', (done) => {\n        const store = cloudDatabase.getPackageStorage(packageName);\n        expect(store).not.toBeNull();\n        if (store) {\n          store.readPackage(pkg.name, (err: VerdaccioError, pkgJson: Package) => {\n            expect(err).toBeNull();\n            expect(pkgJson.name).toBe(pkg.name);\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails read a missing package","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:read"],"updatePoint":{"line":299,"column":47},"line":299,"code":"      test('should fails read a missing package', (done) => {\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store = cloudDatabase.getPackageStorage('');\n        expect(store).not.toBeNull();\n        if (store) {\n          store.readPackage('missing404Pkg', (err: VerdaccioError) => {\n            expect(err).not.toBeNull();\n            expect(err.code).toEqual(HTTP_STATUS.NOT_FOUND);\n            expect(err.message).toBe(API_ERROR.NO_PACKAGE);\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should update and transform an instance","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:update"],"updatePoint":{"line":338,"column":51},"line":338,"code":"      test('should update and transform an instance', (done) => {\n        const pkg = generatePackage(packageName);\n        const store = cloudDatabase.getPackageStorage(packageName);\n\n        expect(store).not.toBeNull();\n        if (store) {\n          store.updatePackage(\n            pkg.name,\n            (_data: unknown, cb: Callback) => {\n              // Handle Update\n              cb();\n            },\n            (_name: string, json: any, cb: Callback) => {\n              // Write Package\n              expect(json.test).toBe('test');\n              cb(null);\n            },\n            (json: any) => {\n              // Transformation\n              json.test = 'test';\n              return json;\n            },\n            (err: VerdaccioError) => {\n              // on End\n              expect(err).toBeNull();\n              done();\n            }\n          );\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails on update due unknown package","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:update"],"updatePoint":{"line":369,"column":54},"line":369,"code":"      test('should fails on update due unknown package', (done) => {\n        const store = cloudDatabase.getPackageStorage('');\n        expect(store).not.toBeNull();\n        if (store) {\n          store.updatePackage(\n            'fake404',\n            () => {},\n            () => {},\n            () => {},\n            (err: VerdaccioError) => {\n              expect(err).not.toBeNull();\n              expect(err.code).toEqual(HTTP_STATUS.NOT_FOUND);\n              expect(err.message).toBe(API_ERROR.NO_PACKAGE);\n              done();\n            }\n          );\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails on update on fails updateHandler","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:update"],"updatePoint":{"line":388,"column":57},"line":388,"code":"      test('should fails on update on fails updateHandler', (done) => {\n        const store = cloudDatabase.getPackageStorage('');\n        expect(store).not.toBeNull();\n        if (store) {\n          store.updatePackage(\n            'fake404',\n            () => {},\n            () => {},\n            () => {},\n            (err: VerdaccioError) => {\n              expect(err).not.toBeNull();\n              expect(err.code).toEqual(HTTP_STATUS.NOT_FOUND);\n              expect(err.message).toBe(API_ERROR.NO_PACKAGE);\n              done();\n            }\n          );\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should write a tarball successfully push data","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:: writeFile"],"updatePoint":{"line":449,"column":57},"line":449,"code":"      test('should write a tarball successfully push data', (done) => {\n        jest.doMock('../src/storage-helper', () => {\n          const originalModule = jest.requireActual('../src/storage-helper').default;\n          return {\n            __esModule: true,\n            default: class Foo extends originalModule {\n              public storage: object;\n              public config: object;\n              public constructor(props) {\n                super(props);\n                this.config = {\n                  bucket: 'foo',\n                };\n                this.storage = {\n                  bucket: (name) => new Bucket(name, false, FileWriteMocked),\n                };\n              }\n            },\n          };\n        });\n\n        const bufferFile = fs.readFileSync(tarballFile);\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store: IPackageStorage = cloudDatabase.getPackageStorage(\n          pkgExample.name\n        ) as IPackageStorageManager;\n        const writeTarballStream = store.writeTarball('test-pkg-1.0.0.tgz');\n\n        writeTarballStream.on('error', (err: VerdaccioError) => {\n          done.fail(err);\n        });\n\n        writeTarballStream.on('success', () => {\n          done();\n        });\n\n        writeTarballStream.on('end', () => {\n          done();\n        });\n\n        writeTarballStream.end(bufferFile);\n        writeTarballStream.done();\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should write a abort successfully push data","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:: writeFile"],"line":493,"code":"      test.skip('should write a abort successfully push data', (done) => {","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should read a tarball successfully","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:: readFile"],"updatePoint":{"line":523,"column":46},"line":523,"code":"      test('should read a tarball successfully', (done) => {\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store = cloudDatabase.getPackageStorage(pkgExample.name);\n        expect(store).not.toBeNull();\n        if (store) {\n          const readTarballStream = store.readTarball('test-pkg-1.0.0.tgz');\n          let isOpen = false;\n\n          readTarballStream.on('data', (data) => {\n            expect(data).toBeDefined();\n          });\n\n          readTarballStream.on('open', () => {\n            isOpen = true;\n          });\n\n          readTarballStream.on('content-length', (contentLength) => {\n            expect(contentLength).toBeDefined();\n          });\n\n          readTarballStream.on('error', () => {\n            done.fail(new Error('should not fail'));\n          });\n\n          readTarballStream.on('end', () => {\n            expect(isOpen).toBe(true);\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails with 404 on get a tarball","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:: readFile"],"updatePoint":{"line":554,"column":50},"line":554,"code":"      test('should fails with 404 on get a tarball', (done) => {\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store = cloudDatabase.getPackageStorage(pkgExample.name);\n        let isOpen = false;\n        expect(store).not.toBeNull();\n        if (store) {\n          const readTarballStream = store.readTarball('fake-tarball.tgz');\n\n          readTarballStream.on('data', (data: any) => {\n            expect(data).toBeUndefined();\n          });\n\n          readTarballStream.on('open', () => {\n            isOpen = true;\n          });\n\n          readTarballStream.on('error', (err: VerdaccioError) => {\n            expect(err).not.toBeNull();\n            // this is really important, verdaccio handle such errors instead 404\n            expect(err.code).toBe('ENOENT');\n            expect(err.message).toMatch(/no such package/);\n            expect(isOpen).toBe(true);\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should abort successfully get a tarball","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:: readFile"],"updatePoint":{"line":581,"column":51},"line":581,"code":"      test('should abort successfully get a tarball', (done) => {\n        let isOpen = false;\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store = cloudDatabase.getPackageStorage(pkgExample.name);\n        expect(store).not.toBeNull();\n        if (store) {\n          const readTarballStream = store.readTarball('test-pkg-1.0.0.tgz');\n\n          readTarballStream.on('data', () => {\n            readTarballStream.abort();\n          });\n\n          readTarballStream.on('open', () => {\n            isOpen = true;\n          });\n\n          readTarballStream.on('error', (err: VerdaccioError) => {\n            expect(err).not.toBeNull();\n            expect(err.statusCode).toBe(400);\n            expect(err.message).toMatch(/transmision aborted/);\n            expect(isOpen).toBe(true);\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should delete successfully get a tarball","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:: deleteTarball"],"updatePoint":{"line":609,"column":52},"line":609,"code":"      test('should delete successfully get a tarball', (done) => {\n        jest.doMock('../src/storage-helper', () => {\n          return {\n            __esModule: true,\n            default: class Foo {\n              public buildFilePath(): {\n                name: string;\n                delete: () => Promise<object[]>;\n              } {\n                return {\n                  name: 'foo',\n                  delete: (): Promise<object[]> =>\n                    Promise.resolve([\n                      {\n                        foo: 'bar',\n                      },\n                    ]),\n                };\n              }\n            },\n          };\n        });\n\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store = cloudDatabase.getPackageStorage(pkgExample.name);\n        if (store) {\n          store.deletePackage('test-pkg-1.0.0.tgz', (err: VerdaccioError) => {\n            expect(err).toBeNull();\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should fails on delete a tarball","suites":["Google Cloud Storage","Google Cloud Storage","GoogleCloudStorageHandler:: deleteTarball"],"updatePoint":{"line":642,"column":44},"line":642,"code":"      test('should fails on delete a tarball', (done) => {\n        jest.doMock('../src/storage-helper', () => {\n          return {\n            __esModule: true,\n            default: class Foo {\n              public buildFilePath(): {\n                name: string;\n                delete: () => Promise<never>;\n              } {\n                return {\n                  name: 'foo',\n                  delete: (): Promise<never> => Promise.reject(new Error(API_ERROR.NO_PACKAGE)),\n                };\n              }\n            },\n          };\n        });\n\n        const cloudDatabase: ITestLocalData = getCloudDatabase(storageConfig);\n        const store = cloudDatabase.getPackageStorage(pkgExample.name);\n        if (store) {\n          store.deletePackage('test-pkg-1.0.0.tgz', (err: VerdaccioError) => {\n            expect(err).not.toBeNull();\n            expect(err.code).toEqual(HTTP_STATUS.INTERNAL_ERROR);\n            expect(err.message).toBe(API_ERROR.NO_PACKAGE);\n            done();\n          });\n        }\n      });","file":"storage.spec.ts","skipped":true,"dir":"packages/plugins/google-cloud-storage/tests"},{"name":"should match with the correct salt type","suites":["createSalt"],"updatePoint":{"line":14,"column":47},"line":14,"code":"  test('should match with the correct salt type', () => {\n    expect(createSalt(EncryptionMethod.crypt)).toEqual('/U');\n    expect(createSalt(EncryptionMethod.md5)).toEqual('$1$/UEGzD0RxS');\n    expect(createSalt(EncryptionMethod.blowfish)).toEqual('$2a$/UEGzD0RxS');\n    expect(createSalt(EncryptionMethod.sha256)).toEqual('$5$/UEGzD0RxS');\n    expect(createSalt(EncryptionMethod.sha512)).toEqual('$6$/UEGzD0RxS');\n  });","file":"crypt3.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should fails on unkwon type","suites":["createSalt"],"updatePoint":{"line":22,"column":35},"line":22,"code":"  test('should fails on unkwon type', () => {\n    expect(function () {\n      createSalt('bad' as any);\n    }).toThrow(/Unknown salt type at crypt3.createSalt: bad/);\n  });","file":"crypt3.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should generate legacy crypt salt by default","suites":["createSalt"],"updatePoint":{"line":28,"column":52},"line":28,"code":"  test('should generate legacy crypt salt by default', () => {\n    expect(createSalt()).toEqual(createSalt(EncryptionMethod.crypt));\n  });","file":"crypt3.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should ensure file path configuration exists","suites":["HTPasswd","constructor()"],"updatePoint":{"line":44,"column":54},"line":44,"code":"    test('should ensure file path configuration exists', () => {\n      expect(function () {\n        new HTPasswd({} as HTPasswdConfig, emptyPluginOptions);\n      }).toThrow(/should specify \"file\" in config/);\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error about incorrect algorithm","suites":["HTPasswd","constructor()"],"updatePoint":{"line":50,"column":54},"line":50,"code":"    test('should throw error about incorrect algorithm', () => {\n      expect(function () {\n        let invalidConfig = { algorithm: 'invalid', ...config } as HTPasswdConfig;\n        new HTPasswd(invalidConfig, emptyPluginOptions);\n      }).toThrow(/Invalid algorithm \"invalid\"/);\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should authenticate user with given credentials","suites":["HTPasswd","authenticate()"],"updatePoint":{"line":59,"column":60},"line":59,"code":"    test('it should authenticate user with given credentials', (done) => {\n      const users = [\n        { username: 'test', password: 'test' },\n        { username: 'username', password: 'password' },\n        { username: 'bcrypt', password: 'password' },\n      ];\n      let usersAuthenticated = 0;\n      const generateCallback = (username) => (error, userGroups) => {\n        usersAuthenticated += 1;\n        expect(error).toBeNull();\n        expect(userGroups).toContain(username);\n        usersAuthenticated === users.length && done();\n      };\n      users.forEach(({ username, password }) =>\n        wrapper.authenticate(username, password, generateCallback(username))\n      );\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should not authenticate user with given credentials","suites":["HTPasswd","authenticate()"],"updatePoint":{"line":77,"column":64},"line":77,"code":"    test('it should not authenticate user with given credentials', (done) => {\n      const users = ['test', 'username', 'bcrypt'];\n      let usersAuthenticated = 0;\n      const generateCallback = () => (error, userGroups) => {\n        usersAuthenticated += 1;\n        expect(error).toBeNull();\n        expect(userGroups).toBeFalsy();\n        usersAuthenticated === users.length && done();\n      };\n      users.forEach((username) =>\n        wrapper.authenticate(username, 'somerandompassword', generateCallback())\n      );\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should warn on slow password verification","suites":["HTPasswd","authenticate()"],"updatePoint":{"line":91,"column":54},"line":91,"code":"    test('it should warn on slow password verification', (done) => {\n      bcrypt.compare = jest.fn((passwd, hash, callback) => {\n        setTimeout(() => callback(null, true), DEFAULT_SLOW_VERIFY_MS + 1);\n      });\n      const callback = (a, b): void => {\n        expect(a).toBeNull();\n        expect(b).toContain('bcrypt');\n        const mockWarn = options.logger.warn as jest.MockedFn<jest.MockableFunction>;\n        expect(mockWarn.mock.calls.length).toBe(1);\n        const [{ user, durationMs }, message] = mockWarn.mock.calls[0];\n        expect(user).toEqual('bcrypt');\n        expect(durationMs).toBeGreaterThan(DEFAULT_SLOW_VERIFY_MS);\n        expect(message).toEqual('Password for user \"@{user}\" took @{durationMs}ms to verify');\n        done();\n      };\n      wrapper.authenticate('bcrypt', 'password', callback);\n    }, 15000);","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should not pass sanity check","suites":["HTPasswd","addUser()"],"updatePoint":{"line":111,"column":41},"line":111,"code":"    test('it should not pass sanity check', (done) => {\n      const callback = (a): void => {\n        expect(a.message).toEqual('unauthorized access');\n        done();\n      };\n      wrapper.adduser('test', 'somerandompassword', callback);\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should add the user","suites":["HTPasswd","addUser()"],"updatePoint":{"line":119,"column":32},"line":119,"code":"    test('it should add the user', (done) => {\n      let dataToWrite;\n      // @ts-ignore\n      fs.writeFile = jest.fn((name, data, callback) => {\n        dataToWrite = data;\n        callback();\n      });\n\n      MockDate.set('2018-01-14T11:17:40.712Z');\n\n      const callback = (a, b): void => {\n        expect(a).toBeNull();\n        expect(b).toBeTruthy();\n        expect(fs.writeFile).toHaveBeenCalled();\n        expect(dataToWrite.indexOf('usernotpresent')).not.toEqual(-1);\n        done();\n      };\n      wrapper.adduser('usernotpresent', 'somerandompassword', callback);\n    });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"sanityCheck should return an Error","suites":["HTPasswd","addUser()","addUser() error handling"],"updatePoint":{"line":140,"column":46},"line":140,"code":"      test('sanityCheck should return an Error', (done) => {\n        jest.doMock('../src/utils.ts', () => {\n          return {\n            sanityCheck: (): Error => Error('some error'),\n            HtpasswdHashAlgorithm,\n          };\n        });\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.adduser('sanityCheck', 'test', (sanity) => {\n          expect(sanity.message).toBeDefined();\n          expect(sanity.message).toMatch('some error');\n          done();\n        });\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"lockAndRead should return an Error","suites":["HTPasswd","addUser()","addUser() error handling"],"updatePoint":{"line":157,"column":46},"line":157,"code":"      test('lockAndRead should return an Error', (done) => {\n        jest.doMock('../src/utils.ts', () => {\n          return {\n            sanityCheck: (): any => null,\n            lockAndRead: (_a, b): any => b(new Error('lock error')),\n            HtpasswdHashAlgorithm,\n          };\n        });\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.adduser('lockAndRead', 'test', (sanity) => {\n          expect(sanity.message).toBeDefined();\n          expect(sanity.message).toMatch('lock error');\n          done();\n        });\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"addUserToHTPasswd should return an Error","suites":["HTPasswd","addUser()","addUser() error handling"],"updatePoint":{"line":175,"column":52},"line":175,"code":"      test('addUserToHTPasswd should return an Error', (done) => {\n        jest.doMock('../src/utils.ts', () => {\n          return {\n            sanityCheck: (): any => null,\n            parseHTPasswd: (): void => {},\n            lockAndRead: (_a, b): any => b(null, ''),\n            unlockFile: (_a, b): any => b(),\n            HtpasswdHashAlgorithm,\n          };\n        });\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.adduser('addUserToHTPasswd', 'test', () => {\n          done();\n        });\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"writeFile should return an Error","suites":["HTPasswd","addUser()","addUser() error handling"],"updatePoint":{"line":193,"column":44},"line":193,"code":"      test('writeFile should return an Error', (done) => {\n        jest.doMock('../src/utils.ts', () => {\n          return {\n            sanityCheck: (): any => null,\n            parseHTPasswd: (): void => {},\n            lockAndRead: (_a, b): any => b(null, ''),\n            addUserToHTPasswd: (): void => {},\n            HtpasswdHashAlgorithm,\n          };\n        });\n        jest.doMock('fs', () => {\n          const original = jest.requireActual('fs');\n          return {\n            ...original,\n            writeFile: jest.fn((_name, _data, callback) => {\n              callback(new Error('write error'));\n            }),\n          };\n        });\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.adduser('addUserToHTPasswd', 'test', (err) => {\n          expect(err).not.toBeNull();\n          expect(err.message).toMatch('write error');\n          done();\n        });\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"it should read the file and set the users","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":224,"column":53},"line":224,"code":"      test('it should read the file and set the users', (done) => {\n        const output = {\n          test: '$6FrCaT/v0dwE',\n          username: '$66to3JK5RgZM',\n          bcrypt: '$2y$04$K2Cn3StiXx4CnLmcTW/ymekOrj7WlycZZF9xgmoJ/U0zGPqSLPVBe',\n        };\n        const callback = (): void => {\n          expect(wrapper.users).toEqual(output);\n          done();\n        };\n        wrapper.reload(callback);\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"reload should fails on check file","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":237,"column":45},"line":237,"code":"      test('reload should fails on check file', (done) => {\n        jest.doMock('fs', () => {\n          return {\n            readFile: (_name, callback): void => {\n              callback(new Error('stat error'), null);\n            },\n            stat: (_name, callback): void => {\n              callback(new Error('stat error'), null);\n            },\n          };\n        });\n        const callback = (err): void => {\n          expect(err).not.toBeNull();\n          expect(err.message).toMatch('stat error');\n          done();\n        };\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.reload(callback);\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"reload times match","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":259,"column":30},"line":259,"code":"      test('reload times match', (done) => {\n        jest.doMock('fs', () => {\n          return {\n            readFile: (_name, callback): void => {\n              callback(new Error('stat error'), null);\n            },\n            stat: (_name, callback): void => {\n              callback(null, {\n                mtime: null,\n              });\n            },\n          };\n        });\n        const callback = (err): void => {\n          expect(err).toBeUndefined();\n          done();\n        };\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.reload(callback);\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"reload should fails on read file","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":282,"column":44},"line":282,"code":"      test('reload should fails on read file', (done) => {\n        jest.doMock('fs', () => {\n          return {\n            stat: jest.requireActual('fs').stat,\n            readFile: (_name, _format, callback): void => {\n              callback(new Error('read error'), null);\n            },\n          };\n        });\n        const callback = (err): void => {\n          expect(err).not.toBeNull();\n          expect(err.message).toMatch('read error');\n          done();\n        };\n\n        const HTPasswd = require('../src/htpasswd.ts').default;\n        const wrapper = new HTPasswd(config, options);\n        wrapper.reload(callback);\n      });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"changePassword - it should throw an error for user not found","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":304,"column":68},"line":304,"code":"  test('changePassword - it should throw an error for user not found', (done) => {\n    const callback = (error, isSuccess): void => {\n      expect(error).not.toBeNull();\n      expect(error.message).toBe(\n        `Unable to change password for user 'usernotpresent': user does not currently exist`\n      );\n      expect(isSuccess).toBeFalsy();\n      done();\n    };\n    wrapper.changePassword('usernotpresent', 'oldPassword', 'newPassword', callback);\n  });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"changePassword - it should throw an error for wrong password","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":316,"column":68},"line":316,"code":"  test('changePassword - it should throw an error for wrong password', (done) => {\n    const callback = (error, isSuccess): void => {\n      expect(error).not.toBeNull();\n      expect(error.message).toBe(\n        `Unable to change password for user 'username': invalid old password`\n      );\n      expect(isSuccess).toBeFalsy();\n      done();\n    };\n    wrapper.changePassword('username', 'wrongPassword', 'newPassword', callback);\n  });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"changePassword - it should change password","suites":["HTPasswd","addUser()","reload()"],"updatePoint":{"line":328,"column":50},"line":328,"code":"  test('changePassword - it should change password', (done) => {\n    let dataToWrite;\n    // @ts-ignore\n    fs.writeFile = jest.fn((_name, data, callback) => {\n      dataToWrite = data;\n      callback();\n    });\n    const callback = (error, isSuccess): void => {\n      expect(error).toBeNull();\n      expect(isSuccess).toBeTruthy();\n      expect(fs.writeFile).toHaveBeenCalled();\n      expect(dataToWrite.indexOf('username')).not.toEqual(-1);\n      done();\n    };\n    wrapper.changePassword('username', 'password', 'newPassword', callback);\n  });","file":"htpasswd.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should parse the password for a single line","suites":["parseHTPasswd"],"updatePoint":{"line":41,"column":49},"line":41,"code":"  it('should parse the password for a single line', () => {\n    const input = 'test:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z';\n    const output = { test: '$6b9MlB3WUELU' };\n    expect(parseHTPasswd(input)).toEqual(output);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should parse the password for two lines","suites":["parseHTPasswd"],"updatePoint":{"line":47,"column":45},"line":47,"code":"  it('should parse the password for two lines', () => {\n    const input = `user1:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z\nuser2:$6FrCaT/v0dwE:autocreated 2017-12-14T13:30:20.838Z`;\n    const output = { user1: '$6b9MlB3WUELU', user2: '$6FrCaT/v0dwE' };\n    expect(parseHTPasswd(input)).toEqual(output);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should parse the password for multiple lines","suites":["parseHTPasswd"],"updatePoint":{"line":54,"column":50},"line":54,"code":"  it('should parse the password for multiple lines', () => {\n    const input = `user1:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z\nuser2:$6FrCaT/v0dwE:autocreated 2017-12-14T13:30:20.838Z\nuser3:$6FrCdfd\\v0dwE:autocreated 2017-12-14T13:30:20.838Z\nuser4:$6FrCasdvppdwE:autocreated 2017-12-14T13:30:20.838Z`;\n    const output = {\n      user1: '$6b9MlB3WUELU',\n      user2: '$6FrCaT/v0dwE',\n      user3: '$6FrCdfd\\v0dwE',\n      user4: '$6FrCasdvppdwE',\n    };\n    expect(parseHTPasswd(input)).toEqual(output);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the MD5/Crypt3 password with true","suites":["verifyPassword"],"updatePoint":{"line":70,"column":53},"line":70,"code":"  it('should verify the MD5/Crypt3 password with true', async () => {\n    const input = ['test', '$apr1$sKXK9.lG$rZ4Iy63Vtn8jF9/USc4BV0'];\n    expect(await verifyPassword(input[0], input[1])).toBeTruthy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the MD5/Crypt3 password with false","suites":["verifyPassword"],"updatePoint":{"line":74,"column":54},"line":74,"code":"  it('should verify the MD5/Crypt3 password with false', async () => {\n    const input = ['testpasswordchanged', '$apr1$sKXK9.lG$rZ4Iy63Vtn8jF9/USc4BV0'];\n    expect(await verifyPassword(input[0], input[1])).toBeFalsy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the plain password with true","suites":["verifyPassword"],"updatePoint":{"line":78,"column":48},"line":78,"code":"  it('should verify the plain password with true', async () => {\n    const input = ['testpasswordchanged', '{PLAIN}testpasswordchanged'];\n    expect(await verifyPassword(input[0], input[1])).toBeTruthy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the plain password with false","suites":["verifyPassword"],"updatePoint":{"line":82,"column":49},"line":82,"code":"  it('should verify the plain password with false', async () => {\n    const input = ['testpassword', '{PLAIN}testpasswordchanged'];\n    expect(await verifyPassword(input[0], input[1])).toBeFalsy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the crypto SHA password with true","suites":["verifyPassword"],"updatePoint":{"line":86,"column":53},"line":86,"code":"  it('should verify the crypto SHA password with true', async () => {\n    const input = ['testpassword', '{SHA}i7YRj4/Wk1rQh2o740pxfTJwj/0='];\n    expect(await verifyPassword(input[0], input[1])).toBeTruthy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the crypto SHA password with false","suites":["verifyPassword"],"updatePoint":{"line":90,"column":54},"line":90,"code":"  it('should verify the crypto SHA password with false', async () => {\n    const input = ['testpasswordchanged', '{SHA}i7YRj4/Wk1rQh2o740pxfTJwj/0='];\n    expect(await verifyPassword(input[0], input[1])).toBeFalsy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the bcrypt password with true","suites":["verifyPassword"],"updatePoint":{"line":94,"column":49},"line":94,"code":"  it('should verify the bcrypt password with true', async () => {\n    const input = ['testpassword', '$2y$04$Wqed4yN0OktGbiUdxSTwtOva1xfESfkNIZfcS9/vmHLsn3.lkFxJO'];\n    expect(await verifyPassword(input[0], input[1])).toBeTruthy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should verify the bcrypt password with false","suites":["verifyPassword"],"updatePoint":{"line":98,"column":50},"line":98,"code":"  it('should verify the bcrypt password with false', async () => {\n    const input = [\n      'testpasswordchanged',\n      '$2y$04$Wqed4yN0OktGbiUdxSTwtOva1xfESfkNIZfcS9/vmHLsn3.lkFxJO',\n    ];\n    expect(await verifyPassword(input[0], input[1])).toBeFalsy();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should correctly generate line for md5","suites":["generateHtpasswdLine"],"updatePoint":{"line":112,"column":44},"line":112,"code":"  it('should correctly generate line for md5', () => {\n    const md5Conf = { algorithm: HtpasswdHashAlgorithm.md5 };\n    expect(generateHtpasswdLine(user, passwd, md5Conf)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should correctly generate line for sha1","suites":["generateHtpasswdLine"],"updatePoint":{"line":117,"column":45},"line":117,"code":"  it('should correctly generate line for sha1', () => {\n    const sha1Conf = { algorithm: HtpasswdHashAlgorithm.sha1 };\n    expect(generateHtpasswdLine(user, passwd, sha1Conf)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should correctly generate line for crypt","suites":["generateHtpasswdLine"],"updatePoint":{"line":122,"column":46},"line":122,"code":"  it('should correctly generate line for crypt', () => {\n    const cryptConf = { algorithm: HtpasswdHashAlgorithm.crypt };\n    expect(generateHtpasswdLine(user, passwd, cryptConf)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should correctly generate line for bcrypt","suites":["generateHtpasswdLine"],"updatePoint":{"line":127,"column":47},"line":127,"code":"  it('should correctly generate line for bcrypt', () => {\n    const bcryptAlgoConfig = {\n      algorithm: HtpasswdHashAlgorithm.bcrypt,\n      rounds: 2,\n    };\n    expect(generateHtpasswdLine(user, passwd, bcryptAlgoConfig)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should add new htpasswd to the end","suites":["addUserToHTPasswd - bcrypt"],"updatePoint":{"line":139,"column":40},"line":139,"code":"  it('should add new htpasswd to the end', () => {\n    const input = ['', 'username', 'password'];\n    expect(addUserToHTPasswd(input[0], input[1], input[2], defaultHashConfig)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should add new htpasswd to the end in multiline input","suites":["addUserToHTPasswd - bcrypt"],"updatePoint":{"line":144,"column":59},"line":144,"code":"  it('should add new htpasswd to the end in multiline input', () => {\n    const body = `test1:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z\n    test2:$6FrCaT/v0dwE:autocreated 2017-12-14T13:30:20.838Z`;\n    const input = [body, 'username', 'password'];\n    expect(addUserToHTPasswd(input[0], input[1], input[2], defaultHashConfig)).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw an error for incorrect username with space","suites":["addUserToHTPasswd - bcrypt"],"updatePoint":{"line":151,"column":61},"line":151,"code":"  it('should throw an error for incorrect username with space', () => {\n    const [a, b, c] = ['', 'firstname lastname', 'password'];\n    expect(() => addUserToHTPasswd(a, b, c, defaultHashConfig)).toThrowErrorMatchingSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should call the readFile method","suites":["lockAndRead"],"updatePoint":{"line":158,"column":37},"line":158,"code":"  it('should call the readFile method', () => {\n    // console.log(fileLocking);\n    // const spy = jest.spyOn(fileLocking, 'readFile');\n    const cb = (): void => {};\n    lockAndRead('.htpasswd', cb);\n    expect(mockReadFile).toHaveBeenCalled();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for user already exists","suites":["sanityCheck"],"updatePoint":{"line":174,"column":50},"line":174,"code":"  test('should throw error for user already exists', async () => {\n    const verifyFn = jest.fn();\n    const input = await sanityCheck('test', users.test, verifyFn, users, Infinity);\n    expect(input.status).toEqual(401);\n    expect(input.message).toEqual('unauthorized access');\n    expect(verifyFn).toHaveBeenCalled();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for registration disabled of users","suites":["sanityCheck"],"updatePoint":{"line":182,"column":61},"line":182,"code":"  test('should throw error for registration disabled of users', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck('username', users.test, verifyFn, users, -1);\n    expect(input.status).toEqual(409);\n    expect(input.message).toEqual('user registration disabled');\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error max number of users","suites":["sanityCheck"],"updatePoint":{"line":189,"column":46},"line":189,"code":"  test('should throw error max number of users', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck('username', users.test, verifyFn, users, 1);\n    expect(input.status).toEqual(403);\n    expect(input.message).toEqual('maximum amount of users reached');\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should not throw anything and sanity check","suites":["sanityCheck"],"updatePoint":{"line":196,"column":50},"line":196,"code":"  test('should not throw anything and sanity check', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck('username', users.test, verifyFn, users, 2);\n    expect(input).toBeNull();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for required username field","suites":["sanityCheck"],"updatePoint":{"line":202,"column":54},"line":202,"code":"  test('should throw error for required username field', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck(undefined, users.test, verifyFn, users, 2);\n    expect(input.message).toEqual('username and password is required');\n    expect(input.status).toEqual(400);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for required password field","suites":["sanityCheck"],"updatePoint":{"line":209,"column":54},"line":209,"code":"  test('should throw error for required password field', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck('username', undefined, verifyFn, users, 2);\n    expect(input.message).toEqual('username and password is required');\n    expect(input.status).toEqual(400);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for required username & password fields","suites":["sanityCheck"],"updatePoint":{"line":216,"column":66},"line":216,"code":"  test('should throw error for required username & password fields', async () => {\n    const verifyFn = (): void => {};\n    const input = await sanityCheck(undefined, undefined, verifyFn, users, 2);\n    expect(input.message).toEqual('username and password is required');\n    expect(input.status).toEqual(400);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for existing username and password","suites":["sanityCheck"],"updatePoint":{"line":223,"column":61},"line":223,"code":"  test('should throw error for existing username and password', async () => {\n    const verifyFn = jest.fn(() => true);\n    const input = await sanityCheck('test', users.test, verifyFn, users, 2);\n    expect(input.status).toEqual(409);\n    expect(input.message).toEqual('username is already registered');\n    expect(verifyFn).toHaveBeenCalledTimes(1);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error for wrong password","suites":["changePasswordToHTPasswd"],"updatePoint":{"line":244,"column":45},"line":244,"code":"  test('should throw error for wrong password', async () => {\n    const body = 'test:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z';\n\n    try {\n      await changePasswordToHTPasswd(\n        body,\n        'test',\n        'somerandompassword',\n        'newPassword',\n        defaultHashConfig\n      );\n    } catch (error: any) {\n      expect(error.message).toEqual(\n        `Unable to change password for user 'test': invalid old password`\n      );\n    }\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should throw error when user does not exist","suites":["changePasswordToHTPasswd"],"updatePoint":{"line":262,"column":51},"line":262,"code":"  test('should throw error when user does not exist', async () => {\n    const body = 'test:$6b9MlB3WUELU:autocreated 2017-11-06T18:17:21.957Z';\n\n    try {\n      await changePasswordToHTPasswd(\n        body,\n        'test2',\n        'somerandompassword',\n        'newPassword',\n        defaultHashConfig\n      );\n    } catch (error: any) {\n      expect(error.message).toEqual(\n        `Unable to change password for user 'test2': user does not currently exist`\n      );\n    }\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"should change the password","suites":["changePasswordToHTPasswd"],"updatePoint":{"line":280,"column":34},"line":280,"code":"  test('should change the password', async () => {\n    const body = 'root:$6qLTHoPfGLy2:autocreated 2018-08-20T13:38:12.164Z';\n\n    expect(\n      await changePasswordToHTPasswd(body, 'root', 'demo123', 'newPassword', defaultHashConfig)\n    ).toMatchSnapshot();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/htpasswd/tests"},{"name":"getFolders storage 1","suites":[],"updatePoint":{"line":13,"column":26},"line":13,"code":"test('getFolders storage 1', async () => {\n  const files = await getFolders(join(pathStorage1, '@bar'));\n  expect(files).toHaveLength(2);\n  expect(files).toEqual(['pkg1', 'pkg2']);\n});","file":"dir-utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"getFolders storage 2","suites":[],"updatePoint":{"line":19,"column":26},"line":19,"code":"test('getFolders storage 2', async () => {\n  const files = await getFolders(pathStorage2);\n  expect(files).toHaveLength(1);\n  expect(files).toEqual(['pkg4']);\n});","file":"dir-utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"getFolders storage 2 with pattern","suites":[],"updatePoint":{"line":25,"column":39},"line":25,"code":"test('getFolders storage 2 with pattern', async () => {\n  const files = await getFolders(pathStorage1, '*bar*');\n  expect(files).toHaveLength(1);\n  expect(files).toEqual(['@bar']);\n});","file":"dir-utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should find results","suites":["searchOnFolders"],"updatePoint":{"line":32,"column":27},"line":32,"code":"  test('should find results', async () => {\n    const packages = await searchOnStorage(mockFolder, storages);\n    expect(packages).toHaveLength(9);\n    expect(packages).toEqual([\n      {\n        name: '@foo/pkg1',\n        scoped: '@foo',\n      },\n      {\n        name: '@foo/pkg2',\n        scoped: '@foo',\n      },\n      { name: 'dont-include' },\n      {\n        name: 'pkg1',\n      },\n\n      {\n        name: 'pkg2',\n      },\n      {\n        name: 'pkg3',\n      },\n      {\n        name: '@bar/pkg1',\n        scoped: '@bar',\n      },\n      {\n        name: '@bar/pkg2',\n        scoped: '@bar',\n      },\n      {\n        name: 'pkg4',\n      },\n    ]);\n  });","file":"dir-utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should create an instance","suites":["Local Database"],"updatePoint":{"line":61,"column":33},"line":61,"code":"  test('should create an instance', () => {\n    expect(optionsPlugin.logger.error).not.toHaveBeenCalled();\n    expect(locaDatabase).toBeDefined();\n  });","file":"local-database.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should display log error if fails on load database","suites":["Local Database"],"updatePoint":{"line":66,"column":58},"line":66,"code":"  test('should display log error if fails on load database', async () => {\n    mockmkdir.mockImplementation(() => {\n      throw Error();\n    });\n    const tmpFolder = dirSync({ unsafeCleanup: true });\n    const tempFolder = path.join(tmpFolder.name, 'verdaccio-test.yaml');\n    const instance = new LocalDatabase(\n      // @ts-expect-error\n      {\n        storage: 'storage',\n        config_path: tempFolder,\n      },\n      optionsPlugin.logger\n    );\n\n    await expect(instance.init()).rejects.toEqual(new Error(ERROR_DB_LOCKED));\n    expect(optionsPlugin.logger.error).toHaveBeenCalled();\n    tmpFolder.removeCallback();\n  });","file":"local-database.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should create get secret","suites":["Local Database","should handle secret"],"updatePoint":{"line":87,"column":34},"line":87,"code":"    test('should create get secret', async () => {\n      const secretKey = await locaDatabase.getSecret();\n      expect(secretKey).toBeDefined();\n      expect(typeof secretKey === 'string').toBeTruthy();\n    });","file":"local-database.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should create set secret","suites":["Local Database","should handle secret"],"updatePoint":{"line":93,"column":34},"line":93,"code":"    test('should create set secret', async () => {\n      await locaDatabase.setSecret('foooo');\n      const fetchedSecretKey = await locaDatabase.getSecret();\n      expect('foooo').toBe(fetchedSecretKey);\n    });","file":"local-database.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"write tarball","suites":["Local Database","should handle secret"],"line":100,"code":"  test.todo('write tarball');","file":"local-database.test.ts","skipped":true,"dir":"packages/plugins/local-storage/tests"},{"name":"read tarball","suites":["Local Database","should handle secret"],"line":101,"code":"  test.todo('read tarball');","file":"local-database.test.ts","skipped":true,"dir":"packages/plugins/local-storage/tests"},{"name":"savePackage()","suites":["Local FS test","savePackage() group"],"updatePoint":{"line":35,"column":23},"line":35,"code":"    test('savePackage()', (done) => {\n      const data = {};\n      const localFs = new LocalDriver(path.join(localTempStorage, 'first-package'), logger);\n\n      localFs.savePackage('pkg.1.0.0.tar.gz', data as Package, (err) => {\n        expect(err).toBeNull();\n        done();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"readPackage() success","suites":["Local FS test","readPackage() group"],"updatePoint":{"line":47,"column":31},"line":47,"code":"    test('readPackage() success', (done) => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-test'),\n        logger\n      );\n\n      localFs.readPackage(pkgFileName, (err) => {\n        expect(err).toBeNull();\n        done();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"readPackage() fails","suites":["Local FS test","readPackage() group"],"updatePoint":{"line":59,"column":29},"line":59,"code":"    test('readPackage() fails', (done) => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-testt'),\n        logger\n      );\n\n      localFs.readPackage(pkgFileName, (err) => {\n        expect(err).toBeTruthy();\n        done();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"readPackage() fails corrupt","suites":["Local FS test","readPackage() group"],"updatePoint":{"line":71,"column":37},"line":71,"code":"    test('readPackage() fails corrupt', (done) => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-test-corrupt'),\n        logger\n      );\n\n      localFs.readPackage('corrupt.js', (err) => {\n        expect(err).toBeTruthy();\n        done();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"createPackage()","suites":["Local FS test","createPackage() group"],"updatePoint":{"line":85,"column":25},"line":85,"code":"    test('createPackage()', (done) => {\n      const localFs = new LocalDriver(path.join(localTempStorage, 'createPackage'), logger);\n\n      localFs.createPackage(path.join(localTempStorage, 'package5'), pkg, (err) => {\n        expect(err).toBeNull();\n        done();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"createPackage() fails by fileExist","suites":["Local FS test","createPackage() group"],"updatePoint":{"line":94,"column":44},"line":94,"code":"    test('createPackage() fails by fileExist', (done) => {\n      const localFs = new LocalDriver(path.join(localTempStorage, 'createPackage'), logger);\n\n      localFs.createPackage(path.join(localTempStorage, 'package5'), pkg, (err) => {\n        expect(err).not.toBeNull();\n        expect(err.code).toBe(fileExist);\n        done();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"deletePackage()","suites":["Local FS test","createPackage() group","deletePackage() group"],"updatePoint":{"line":105,"column":27},"line":105,"code":"      test('deletePackage()', async () => {\n        const localFs = new LocalDriver(path.join(localTempStorage, 'createPackage'), logger);\n\n        // verdaccio removes the package.json instead the package name\n        await localFs.deletePackage('package.json');\n      });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should successfully remove the package","suites":["Local FS test","removePackage() group"],"updatePoint":{"line":119,"column":48},"line":119,"code":"    test('should successfully remove the package', async () => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(localTempStorage, '_toDelete'),\n        logger\n      );\n\n      await expect(localFs.removePackage()).resolves.toBeUndefined();\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"removePackage() fails","suites":["Local FS test","removePackage() group"],"updatePoint":{"line":128,"column":31},"line":128,"code":"    test('removePackage() fails', async () => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(localTempStorage, '_toDelete_fake'),\n        logger\n      );\n      await expect(localFs.removePackage()).rejects.toThrow(/ENOENT/);\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should read tarball successfully","suites":["Local FS test","readTarball"],"updatePoint":{"line":138,"column":42},"line":138,"code":"    test('should read tarball successfully', (done) => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-test'),\n        logger\n      );\n      const readTarballStream = localFs.readTarball('test-readme-0.0.0.tgz');\n\n      readTarballStream.on('error', function (err) {\n        expect(err).toBeNull();\n      });\n\n      readTarballStream.on('content-length', function (content) {\n        expect(content).toBe(352);\n      });\n\n      readTarballStream.on('end', function () {\n        done();\n      });\n\n      readTarballStream.on('data', function (data) {\n        expect(data).toBeDefined();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"readTarball() fails","suites":["Local FS test","readTarball"],"updatePoint":{"line":162,"column":29},"line":162,"code":"    test('readTarball() fails', (done) => {\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(__dirname, '__fixtures__/readme-test'),\n        logger\n      );\n      const readTarballStream = localFs.readTarball('file-does-not-exist-0.0.0.tgz');\n\n      readTarballStream.on('error', function (err) {\n        expect(err).toBeTruthy();\n        done();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"updatePackage() success","suites":["Local FS test","updatePackage() group"],"updatePoint":{"line":190,"column":33},"line":190,"code":"    test('updatePackage() success', (done) => {\n      jest.doMock('@verdaccio/file-locking', () => {\n        return {\n          readFile: (name, _options, cb): any => cb(null, { name }),\n          unlockFile: (_something, cb): any => cb(null),\n        };\n      });\n\n      const LocalDriver = require('../src/local-fs').default;\n      const localFs: ILocalPackageManager = new LocalDriver(\n        path.join(__dirname, '__fixtures__/update-package'),\n        logger\n      );\n\n      localFs.updatePackage('updatePackage', updateHandler, onWrite, transform, () => {\n        expect(transform).toHaveBeenCalledTimes(1);\n        expect(updateHandler).toHaveBeenCalledTimes(1);\n        expect(onWrite).toHaveBeenCalledTimes(1);\n        done();\n      });\n    });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"updatePackage() whether locking fails","suites":["Local FS test","updatePackage() group","updatePackage() failures handler"],"updatePoint":{"line":213,"column":49},"line":213,"code":"      test('updatePackage() whether locking fails', (done) => {\n        jest.doMock('@verdaccio/file-locking', () => {\n          return {\n            readFile: (name, _options, cb): any => cb(Error('whateverError'), { name }),\n            unlockFile: (_something, cb): any => cb(null),\n          };\n        });\n        require('../src/local-fs').default;\n        const localFs: ILocalPackageManager = new LocalDriver(\n          path.join(__dirname, '__fixtures__/update-package'),\n          logger\n        );\n\n        localFs.updatePackage('updatePackage', updateHandler, onWrite, transform, (err) => {\n          expect(err).not.toBeNull();\n          expect(transform).toHaveBeenCalledTimes(0);\n          expect(updateHandler).toHaveBeenCalledTimes(0);\n          expect(onWrite).toHaveBeenCalledTimes(0);\n          done();\n        });\n      });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"updatePackage() unlock a missing package","suites":["Local FS test","updatePackage() group","updatePackage() failures handler"],"updatePoint":{"line":235,"column":52},"line":235,"code":"      test('updatePackage() unlock a missing package', (done) => {\n        jest.doMock('@verdaccio/file-locking', () => {\n          return {\n            readFile: (name, _options, cb): any => cb(fSError(noSuchFile, 404), { name }),\n            unlockFile: (_something, cb): any => cb(null),\n          };\n        });\n        const LocalDriver = require('../src/local-fs').default;\n        const localFs: ILocalPackageManager = new LocalDriver(\n          path.join(__dirname, '__fixtures__/update-package'),\n          logger\n        );\n\n        localFs.updatePackage('updatePackage', updateHandler, onWrite, transform, (err) => {\n          expect(err).not.toBeNull();\n          expect(transform).toHaveBeenCalledTimes(0);\n          expect(updateHandler).toHaveBeenCalledTimes(0);\n          expect(onWrite).toHaveBeenCalledTimes(0);\n          done();\n        });\n      });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"updatePackage() unlock a resource non available","suites":["Local FS test","updatePackage() group","updatePackage() failures handler"],"updatePoint":{"line":257,"column":59},"line":257,"code":"      test('updatePackage() unlock a resource non available', (done) => {\n        jest.doMock('@verdaccio/file-locking', () => {\n          return {\n            readFile: (name, _options, cb): any => cb(fSError(resourceNotAvailable, 503), { name }),\n            unlockFile: (_something, cb): any => cb(null),\n          };\n        });\n        const LocalDriver = require('../src/local-fs').default;\n        const localFs: ILocalPackageManager = new LocalDriver(\n          path.join(__dirname, '__fixtures__/update-package'),\n          logger\n        );\n\n        localFs.updatePackage('updatePackage', updateHandler, onWrite, transform, (err) => {\n          expect(err).not.toBeNull();\n          expect(transform).toHaveBeenCalledTimes(0);\n          expect(updateHandler).toHaveBeenCalledTimes(0);\n          expect(onWrite).toHaveBeenCalledTimes(0);\n          done();\n        });\n      });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"updatePackage() if updateHandler fails","suites":["Local FS test","updatePackage() group","updatePackage() failures handler"],"updatePoint":{"line":279,"column":50},"line":279,"code":"      test('updatePackage() if updateHandler fails', (done) => {\n        jest.doMock('@verdaccio/file-locking', () => {\n          return {\n            readFile: (name, _options, cb): any => cb(null, { name }),\n            unlockFile: (_something, cb): any => cb(null),\n          };\n        });\n\n        const LocalDriver = require('../src/local-fs').default;\n        const localFs: ILocalPackageManager = new LocalDriver(\n          path.join(__dirname, '__fixtures__/update-package'),\n          logger\n        );\n        const updateHandler = jest.fn((_name, cb) => {\n          cb(fSError('something wrong', 500));\n        });\n\n        localFs.updatePackage('updatePackage', updateHandler, onWrite, transform, (err) => {\n          expect(err).not.toBeNull();\n          expect(transform).toHaveBeenCalledTimes(0);\n          expect(updateHandler).toHaveBeenCalledTimes(1);\n          expect(onWrite).toHaveBeenCalledTimes(0);\n          done();\n        });\n      });","file":"local-fs.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should save and get token","suites":["Local Database","token"],"updatePoint":{"line":53,"column":35},"line":53,"code":"    test('should save and get token', async () => {\n      await locaDatabase.saveToken(token);\n      const tokens = await locaDatabase.readTokens({ user: token.user });\n      expect(tokens).toHaveLength(1);\n      expect(tokens[0]).toEqual(token);\n    });","file":"token.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should revoke and get token","suites":["Local Database","token"],"updatePoint":{"line":60,"column":37},"line":60,"code":"    test('should revoke and get token', async () => {\n      await locaDatabase.saveToken(token);\n      const tokens = await locaDatabase.readTokens({ user: token.user });\n      expect(tokens).toHaveLength(1);\n      expect(tokens[0]).toEqual(token);\n      await locaDatabase.deleteToken(token.user, token.key);\n      const tokens2 = await locaDatabase.readTokens({ user: token.user });\n      expect(tokens2).toHaveLength(0);\n    });","file":"token.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should fail on revoke","suites":["Local Database","token"],"updatePoint":{"line":70,"column":31},"line":70,"code":"    test('should fail on revoke', async () => {\n      await expect(locaDatabase.deleteToken({ user: 'foo', key: 'bar' })).rejects.toThrow(\n        'user not found'\n      );\n    });","file":"token.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should verify save more than one token","suites":["Local Database","token"],"updatePoint":{"line":76,"column":48},"line":76,"code":"    test('should verify save more than one token', async () => {\n      await locaDatabase.saveToken(token);\n      const tokens = await locaDatabase.readTokens({ user: token.user });\n      expect(tokens).toHaveLength(1);\n      expect(tokens[0]).toEqual(token);\n      await locaDatabase.saveToken({ ...token, key: 'foo' });\n      expect(tokens).toHaveLength(2);\n      expect(tokens[1].key).toEqual('foo');\n    });","file":"token.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should load private packages","suites":["Utitlies"],"updatePoint":{"line":27,"column":36},"line":27,"code":"  test('should load private packages', async () => {\n    const database = loadDb('ok');\n    const db = await loadPrivatePackages(database, logger);\n\n    expect(db.list).toHaveLength(15);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should load and empty private packages if database file is valid and empty","suites":["Utitlies"],"updatePoint":{"line":34,"column":82},"line":34,"code":"  test('should load and empty private packages if database file is valid and empty', async () => {\n    const database = loadDb('empty');\n    const db = await loadPrivatePackages(database, logger);\n\n    expect(db.list).toHaveLength(0);\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should fails on load private packages","suites":["Utitlies"],"updatePoint":{"line":41,"column":45},"line":41,"code":"  test('should fails on load private packages', async () => {\n    const database = loadDb('corrupted');\n\n    await expect(loadPrivatePackages(database, logger)).rejects.toThrow();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should handle null read values and return empty database","suites":["Utitlies"],"updatePoint":{"line":47,"column":64},"line":47,"code":"  test('should handle null read values and return empty database', async () => {\n    const spy = jest.spyOn(readFile, 'readFilePromise');\n    spy.mockResolvedValue(null);\n    const database = loadDb('ok');\n    const db = await loadPrivatePackages(database, logger);\n\n    expect(db.list).toHaveLength(0);\n\n    spy.mockRestore();\n  });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should fails on wrong storage path","suites":["Utitlies","find packages"],"updatePoint":{"line":59,"column":44},"line":59,"code":"    test('should fails on wrong storage path', async () => {\n      try {\n        await findPackages(\n          './no_such_folder_fake',\n          jest.fn(() => true)\n        );\n      } catch (e: any) {\n        expect(e.code).toEqual(noSuchFile);\n      }\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should fetch all packages from valid storage","suites":["Utitlies","find packages"],"updatePoint":{"line":70,"column":54},"line":70,"code":"    test('should fetch all packages from valid storage', async () => {\n      const storage = path.join(__dirname, '__fixtures__/findPackages');\n      const validator = jest.fn((file) => file.indexOf('.') === -1);\n      const pkgs = await findPackages(storage, validator);\n      // the result is 7 due number of packages on \"findPackages\" directory\n      expect(pkgs).toHaveLength(5);\n      expect(validator).toHaveBeenCalledTimes(8);\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should generate a storage path","suites":["Utitlies","dbGenPath"],"updatePoint":{"line":81,"column":40},"line":81,"code":"    test('should generate a storage path', () => {\n      expect(\n        _dbGenPath('local.db', {\n          storage: './storage',\n          config_path: '/etc/foo/config.yaml',\n        })\n      ).toMatch('local.db');\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should verify with empty storage","suites":["Utitlies","dbGenPath"],"updatePoint":{"line":90,"column":42},"line":90,"code":"    test('should verify with empty storage', () => {\n      expect(\n        _dbGenPath('local.db', {\n          storage: '',\n          config_path: '/etc/foo/config.yaml',\n        })\n      ).toMatch('local.db');\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should verify with undefined storage","suites":["Utitlies","dbGenPath"],"updatePoint":{"line":99,"column":46},"line":99,"code":"    test('should verify with undefined storage', () => {\n      expect(\n        _dbGenPath('local.db', {\n          storage: '',\n          config_path: '/etc/foo/config.yaml',\n        })\n      ).toMatch('local.db');\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should verify with config path is invalid","suites":["Utitlies","dbGenPath"],"updatePoint":{"line":108,"column":51},"line":108,"code":"    test('should verify with config path is invalid', () => {\n      expect(\n        _dbGenPath('local.db', {\n          storage: './storage',\n          config_path: undefined,\n        })\n      ).toMatch('local.db');\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/plugins/local-storage/tests"},{"name":"should create an LocalMemory instance","suites":["memory unit test .","LocalMemory"],"updatePoint":{"line":22,"column":47},"line":22,"code":"    test('should create an LocalMemory instance', () => {\n      const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n\n      expect(localMemory).toBeDefined();\n    });","file":"local-memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should create add a package","suites":["memory unit test .","LocalMemory"],"updatePoint":{"line":28,"column":37},"line":28,"code":"    test('should create add a package', (done) => {\n      const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n      localMemory.add('test').then(() => {\n        localMemory.get().then((data: DataHandler) => {\n          expect(data).toHaveLength(1);\n          done();\n        });\n      });\n    });","file":"local-memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should reach max limit","suites":["memory unit test .","LocalMemory"],"updatePoint":{"line":38,"column":32},"line":38,"code":"    test('should reach max limit', (done) => {\n      config.limit = 2;\n      const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n\n      localMemory.add('test1').then(() => {\n        localMemory.add('test2').then(() => {\n          localMemory.add('test3').catch((err) => {\n            expect(err).not.toBeNull();\n            expect(err.message).toMatch(/Storage memory has reached limit of limit packages/);\n            done();\n          });\n        });\n      });\n    });","file":"local-memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should remove a package","suites":["memory unit test .","LocalMemory"],"updatePoint":{"line":53,"column":33},"line":53,"code":"    test('should remove a package', (done) => {\n      const pkgName = 'test';\n      const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n      localMemory.add(pkgName).then(() => {\n        localMemory.remove(pkgName).then(() => {\n          localMemory.get().then((data) => {\n            expect(data).toHaveLength(0);\n            done();\n          });\n        });\n      });\n    });","file":"local-memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should create an MemoryHandler instance","suites":["memory unit test ."],"updatePoint":{"line":36,"column":47},"line":36,"code":"  test('should create an MemoryHandler instance', () => {\n    const memoryHandler = new MemoryHandler(\n      'test',\n      {\n        ['foo']: 'bar',\n      },\n      logger\n    );\n\n    expect(memoryHandler).toBeDefined();\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should save a package","suites":["memory unit test ."],"updatePoint":{"line":48,"column":29},"line":48,"code":"  test('should save a package', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n    expect(handler).toBeDefined();\n\n    if (handler) {\n      handler.savePackage(pkgName, pkgExample, (err) => {\n        expect(err).toBeNull();\n        handler.readPackage(pkgName, (err, data) => {\n          expect(err).toBeNull();\n          expect(data).toEqual(pkgExample);\n          done();\n        });\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should fails on save a package","suites":["memory unit test ."],"updatePoint":{"line":67,"column":38},"line":67,"code":"  test('should fails on save a package', (done) => {\n    mockStringify.mockImplementationOnce(() => {\n      throw new Error('error on parse');\n    });\n\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test';\n\n    const handler: IPackageStorage = localMemory.getPackageStorage(pkgName) as ILocalPackageManager;\n\n    handler.savePackage(pkgName, pkgExample, (err) => {\n      expect(err).toEqual(errorUtils.getInternalError('error on parse'));\n      done();\n    });\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should fails on read a package","suites":["memory unit test ."],"updatePoint":{"line":83,"column":38},"line":83,"code":"  test('should fails on read a package', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n    expect(handler).toBeDefined();\n\n    if (handler) {\n      handler.readPackage(pkgName, (err) => {\n        expect(err).not.toBeNull();\n        expect(err.code).toBe(404);\n        done();\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should update a package","suites":["memory unit test ."],"updatePoint":{"line":99,"column":31},"line":99,"code":"  test('should update a package', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n    expect(handler).toBeDefined();\n    const onEnd = jest.fn();\n\n    if (handler) {\n      handler.savePackage(pkgName, pkgExample, (err) => {\n        expect(err).toBeNull();\n\n        handler.updatePackage(\n          pkgName,\n          (json, callback) => {\n            expect(json).toBeDefined();\n            expect(json.name).toBe(pkgExample.name);\n            expect(callback).toBeDefined();\n            callback(null);\n          },\n          (name, data, onEnd) => {\n            expect(name).toBe(pkgName);\n            expect(data.name).toBe(pkgExample.name);\n            onEnd();\n            expect(onEnd).toHaveBeenCalled();\n            done();\n          },\n          (data) => {\n            expect(data).toBeDefined();\n            return data;\n          },\n          onEnd\n        );\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should parse fails on update a package","suites":["memory unit test ."],"updatePoint":{"line":136,"column":46},"line":136,"code":"  test('should parse fails on update a package', (done) => {\n    mockParsePackage.mockImplementationOnce(() => {\n      throw new Error('error on parse');\n    });\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n\n    const pkgName = 'test';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n    expect(handler).toBeDefined();\n    const onEnd = jest.fn((err) => {\n      expect(err).not.toBeNull();\n      expect(err).toEqual(errorUtils.getInternalError('error on parse'));\n      done();\n    });\n\n    if (handler) {\n      handler.savePackage(pkgName, pkgExample, (err) => {\n        expect(err).toBeNull();\n        handler.updatePackage(\n          pkgName,\n          () => {},\n          () => {},\n          // @ts-ignore\n          () => {},\n          onEnd\n        );\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should fail updateHandler update a package","suites":["memory unit test ."],"updatePoint":{"line":167,"column":50},"line":167,"code":"  test('should fail updateHandler update a package', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n    expect(handler).toBeDefined();\n    const onEnd = jest.fn((err) => {\n      expect(err).not.toBeNull();\n      expect(err).toEqual(errorUtils.getInternalError('some error'));\n      done();\n    });\n\n    if (handler) {\n      handler.savePackage(pkgName, pkgExample, (err) => {\n        expect(err).toBeNull();\n\n        handler.updatePackage(\n          pkgName,\n          (json, callback) => {\n            expect(json).toBeDefined();\n            expect(json.name).toBe(pkgExample.name);\n            expect(callback).toBeDefined();\n            callback(errorUtils.getInternalError('some error'));\n          },\n          () => {},\n          // @ts-ignore\n          () => {},\n          onEnd\n        );\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should onWrite update a package","suites":["memory unit test ."],"updatePoint":{"line":200,"column":39},"line":200,"code":"  test('should onWrite update a package', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n    expect(handler).toBeDefined();\n    const onEnd = jest.fn((err) => {\n      expect(err).not.toBeNull();\n      expect(err).toEqual(errorUtils.getInternalError('error on parse the metadata'));\n      done();\n    });\n\n    if (handler) {\n      handler.savePackage(pkgName, pkgExample, (err) => {\n        expect(err).toBeNull();\n\n        handler.updatePackage(\n          pkgName,\n          (json, callback) => {\n            expect(json).toBeDefined();\n            expect(json.name).toBe(pkgExample.name);\n            expect(callback).toBeDefined();\n            callback(null);\n          },\n          (name, data, onEnd) => {\n            expect(name).toBe(pkgName);\n            expect(data.name).toBe(pkgExample.name);\n            onEnd();\n            expect(onEnd).toHaveBeenCalled();\n            done();\n          },\n          () => {\n            throw new Error('dadsads');\n          },\n          onEnd\n        );\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should delete a package","suites":["memory unit test ."],"updatePoint":{"line":240,"column":31},"line":240,"code":"  test('should delete a package', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test2';\n\n    const handler: IPackageStorage = localMemory.getPackageStorage(pkgName);\n    expect(handler).toBeDefined();\n    if (handler) {\n      handler.createPackage(pkgName, pkgExample, (err) => {\n        expect(err).toBeNull();\n        handler.deletePackage(pkgName).then((err) => {\n          expect(err).toBeUndefined();\n          handler.readPackage(pkgName, (err) => {\n            expect(err).not.toBeNull();\n            expect(err.message).toMatch(/no such package/);\n            done();\n          });\n        });\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should write a tarball","suites":["writing files"],"updatePoint":{"line":263,"column":30},"line":263,"code":"  test('should write a tarball', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test';\n    const dataTarball = '12345';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n    if (handler) {\n      const stream = handler.writeTarball(pkgName);\n      stream.on('data', (data) => {\n        expect(data.toString()).toBe(dataTarball);\n      });\n      stream.on('open', () => {\n        stream.done();\n        stream.end();\n      });\n      stream.on('success', () => {\n        done();\n      });\n\n      stream.write(dataTarball);\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should abort while write a tarball","suites":["writing files"],"updatePoint":{"line":285,"column":42},"line":285,"code":"  test('should abort while write a tarball', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test-abort.tar.gz';\n    const handler = localMemory.getPackageStorage(pkgName);\n\n    if (handler) {\n      const stream = handler.writeTarball(pkgName);\n      stream.on('error', (err) => {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/transmision aborted/);\n        done();\n      });\n      stream.on('open', () => {\n        stream.abort();\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should support writting identical tarball filenames from different packages","suites":["writing files"],"updatePoint":{"line":303,"column":83},"line":303,"code":"  test('should support writting identical tarball filenames from different packages', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName1 = 'package1';\n    const pkgName2 = 'package2';\n    const filename = 'tarball-3.0.0.tgz';\n    const dataTarball1 = '12345';\n    const dataTarball2 = '12345678';\n    const handler = localMemory.getPackageStorage(pkgName1);\n    if (handler) {\n      const stream = handler.writeTarball(filename);\n      stream.on('data', (data) => {\n        expect(data.toString()).toBe(dataTarball1);\n      });\n      stream.on('open', () => {\n        stream.done();\n        stream.end();\n      });\n      stream.on('success', () => {\n        const handler = localMemory.getPackageStorage(pkgName2);\n        if (handler) {\n          const stream = handler.writeTarball(filename);\n          stream.on('data', (data) => {\n            expect(data.toString()).toBe(dataTarball2);\n          });\n          stream.on('open', () => {\n            stream.done();\n            stream.end();\n          });\n          stream.on('success', () => {\n            done();\n          });\n\n          stream.write(dataTarball2);\n        }\n      });\n\n      stream.write(dataTarball1);\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should read a tarball","suites":["reading files"],"updatePoint":{"line":345,"column":29},"line":345,"code":"  test('should read a tarball', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test.tar.gz';\n    const dataTarball = '12345';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n\n    if (handler) {\n      const stream = handler.writeTarball(pkgName);\n      stream.on('open', () => {\n        stream.done();\n        stream.end();\n      });\n      stream.on('success', () => {\n        const readStream = handler.readTarball(pkgName);\n        readStream.on('data', (data) => {\n          expect(data.toString()).toBe(dataTarball);\n          done();\n        });\n      });\n      stream.write(dataTarball);\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should abort read a tarball","suites":["reading files"],"updatePoint":{"line":369,"column":35},"line":369,"code":"  test('should abort read a tarball', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test2.tar.gz';\n    const dataTarball = '12345';\n\n    const handler = localMemory.getPackageStorage(pkgName);\n\n    if (handler) {\n      const stream = handler.writeTarball(pkgName);\n      stream.on('open', () => {\n        stream.done();\n        stream.end();\n      });\n      stream.on('success', () => {\n        const readStream = handler.readTarball(pkgName);\n        readStream.on('data', () => {\n          readStream.abort();\n        });\n        readStream.on('error', (err) => {\n          expect(err).not.toBeNull();\n          expect(err.message).toMatch(/read has been aborted/);\n          done();\n        });\n      });\n      stream.write(dataTarball);\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"should fails read a tarball not found","suites":["reading files"],"updatePoint":{"line":397,"column":45},"line":397,"code":"  test('should fails read a tarball not found', (done) => {\n    const localMemory: IPluginStorage<ConfigMemory> = new LocalMemory(config, defaultConfig);\n    const pkgName = 'test2.tar.gz';\n    const handler = localMemory.getPackageStorage(pkgName);\n\n    if (handler) {\n      const readStream = handler.readTarball('not-found');\n      readStream.on('error', (err) => {\n        expect(err).not.toBeNull();\n        expect(err.message).toMatch(/no such package/);\n        done();\n      });\n    }\n  });","file":"memory.spec.ts","skipped":false,"dir":"packages/plugins/memory/test"},{"name":"if set headers empty should return default headers","suites":["uplink headers auth test"],"updatePoint":{"line":28,"column":58},"line":28,"code":"  test('if set headers empty should return default headers', () => {\n    const headers = setHeaders();\n    const keys = Object.keys(headers);\n    const keysExpected = [HEADERS.ACCEPT, HEADERS.ACCEPT_ENCODING, HEADERS.USER_AGENT];\n\n    expect(keys).toEqual(keysExpected);\n    expect(keys).toHaveLength(3);\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"if assigns value invalid to attribute auth","suites":["uplink headers auth test"],"updatePoint":{"line":37,"column":50},"line":37,"code":"  test('if assigns value invalid to attribute auth', () => {\n    const fnError = function () {\n      setHeaders({\n        auth: '',\n      });\n    };\n\n    expect(function () {\n      fnError();\n    }).toThrow(Error('Auth invalid'));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"if assigns the header authorization","suites":["uplink headers auth test"],"updatePoint":{"line":49,"column":43},"line":49,"code":"  test('if assigns the header authorization', () => {\n    const headers = setHeaders(\n      {},\n      {\n        [HEADERS.AUTHORIZATION]: buildToken(TOKEN_BASIC, 'Zm9vX2Jhcg=='),\n      }\n    );\n\n    expect(Object.keys(headers)).toHaveLength(4);\n    expect(headers[HEADERS.AUTHORIZATION]).toEqual(buildToken(TOKEN_BASIC, 'Zm9vX2Jhcg=='));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"if assigns headers authorization and token the header precedes","suites":["uplink headers auth test"],"updatePoint":{"line":61,"column":70},"line":61,"code":"  test('if assigns headers authorization and token the header precedes', () => {\n    const headers = setHeaders(\n      {\n        auth: {\n          type: TOKEN_BEARER,\n          token: 'tokenBearer',\n        },\n      },\n      {\n        [HEADERS.AUTHORIZATION]: buildToken(TOKEN_BASIC, 'tokenBasic'),\n      }\n    );\n\n    expect(headers[HEADERS.AUTHORIZATION]).toEqual(buildToken(TOKEN_BASIC, 'tokenBasic'));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set type auth basic","suites":["uplink headers auth test"],"updatePoint":{"line":77,"column":27},"line":77,"code":"  test('set type auth basic', () => {\n    const headers = setHeaders({\n      auth: {\n        type: TOKEN_BASIC,\n        token: 'Zm9vX2Jhcg==',\n      },\n    });\n\n    expect(Object.keys(headers)).toHaveLength(4);\n    expect(headers[HEADERS.AUTHORIZATION]).toEqual(buildToken(TOKEN_BASIC, 'Zm9vX2Jhcg=='));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set type auth bearer","suites":["uplink headers auth test"],"updatePoint":{"line":89,"column":28},"line":89,"code":"  test('set type auth bearer', () => {\n    const headers = setHeaders({\n      auth: {\n        type: TOKEN_BEARER,\n        token: 'Zm9vX2Jhcf===',\n      },\n    });\n\n    expect(Object.keys(headers)).toHaveLength(4);\n    expect(headers[HEADERS.AUTHORIZATION]).toEqual(buildToken(TOKEN_BEARER, 'Zm9vX2Jhcf==='));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set auth type invalid","suites":["uplink headers auth test"],"updatePoint":{"line":101,"column":29},"line":101,"code":"  test('set auth type invalid', () => {\n    const fnError = function () {\n      setHeaders({\n        auth: {\n          type: 'null',\n          token: 'Zm9vX2Jhcf===',\n        },\n      });\n    };\n\n    expect(function () {\n      fnError();\n    }).toThrow(Error(`Auth type 'null' not allowed`));\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set auth with NPM_TOKEN","suites":["uplink headers auth test"],"updatePoint":{"line":116,"column":31},"line":116,"code":"  test('set auth with NPM_TOKEN', () => {\n    process.env.NPM_TOKEN = 'myToken';\n    const headers = setHeaders({\n      auth: {\n        type: TOKEN_BEARER,\n      },\n    });\n\n    expect(headers[HEADERS.AUTHORIZATION]).toBe(buildToken(TOKEN_BEARER, 'myToken'));\n    delete process.env.NPM_TOKEN;\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"set auth with token name and assigns in env","suites":["uplink headers auth test"],"updatePoint":{"line":128,"column":51},"line":128,"code":"  test('set auth with token name and assigns in env', () => {\n    process.env.NPM_TOKEN_TEST = 'myTokenTest';\n    const headers = setHeaders({\n      auth: {\n        type: TOKEN_BASIC,\n        token_env: 'NPM_TOKEN_TEST',\n      },\n    });\n\n    expect(headers[HEADERS.AUTHORIZATION]).toBe(buildToken(TOKEN_BASIC, 'myTokenTest'));\n    delete process.env.NPM_TOKEN_TEST;\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"if token not set","suites":["uplink headers auth test"],"updatePoint":{"line":141,"column":24},"line":141,"code":"  test('if token not set', () => {\n    const fnError = function () {\n      setHeaders({\n        auth: {\n          type: TOKEN_BASIC,\n        },\n      });\n    };\n\n    expect(function () {\n      fnError();\n    }).toThrow(constants.ERROR_CODE.token_required);\n  });","file":"headers.auth.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should work fine without proxy","suites":["Use proxy"],"updatePoint":{"line":12,"column":38},"line":12,"code":"  test('should work fine without proxy', () => {\n    const x = setupProxy('http://x/x', {}, {});\n\n    expect(x.proxy).toEqual(undefined);\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"local config should take priority","suites":["Use proxy"],"updatePoint":{"line":18,"column":41},"line":18,"code":"  test('local config should take priority', () => {\n    const x = setupProxy('http://x/x', { http_proxy: '123' }, { http_proxy: '456' });\n    expect(x.proxy).toEqual('123');\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy is invalid","suites":["Use proxy"],"updatePoint":{"line":23,"column":27},"line":23,"code":"  test('no_proxy is invalid', () => {\n    let x = setupProxy('http://x/x', { http_proxy: '123', no_proxy: false }, {});\n\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('http://x/x', { http_proxy: '123', no_proxy: null }, {});\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('http://x/x', { http_proxy: '123', no_proxy: [] }, {});\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('http://x/x', { http_proxy: '123', no_proxy: '' }, {});\n    expect(x.proxy).toEqual('123');\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - simple/include","suites":["Use proxy"],"updatePoint":{"line":35,"column":33},"line":35,"code":"  test('no_proxy - simple/include', () => {\n    let x = setupProxy('http://localhost', { http_proxy: '123' }, { no_proxy: 'localhost' });\n\n    expect(x.proxy).toEqual(undefined);\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - simple/not","suites":["Use proxy"],"updatePoint":{"line":41,"column":29},"line":41,"code":"  test('no_proxy - simple/not', () => {\n    let x = setupProxy('http://localhost', { http_proxy: '123' }, { no_proxy: 'blah' });\n\n    expect(x.proxy).toEqual('123');\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - various, single string","suites":["Use proxy"],"updatePoint":{"line":47,"column":41},"line":47,"code":"  test('no_proxy - various, single string', () => {\n    let x = setupProxy('http://blahblah', { http_proxy: '123' }, { no_proxy: 'blah' });\n\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('http://blah.blah', {}, { http_proxy: '123', no_proxy: 'blah' });\n    expect(x.proxy).toEqual(undefined);\n    x = setupProxy('http://blahblah', {}, { http_proxy: '123', no_proxy: '.blah' });\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('http://blah.blah', { http_proxy: '123', no_proxy: '.blah' }, {});\n    expect(x.proxy).toEqual(undefined);\n    x = setupProxy('http://blah', { http_proxy: '123', no_proxy: '.blah' }, {});\n    expect(x.proxy).toEqual(undefined);\n    x = setupProxy('http://blahh', { http_proxy: '123', no_proxy: 'blah' }, {});\n    expect(x.proxy).toEqual('123');\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - various, array","suites":["Use proxy"],"updatePoint":{"line":63,"column":33},"line":63,"code":"  test('no_proxy - various, array', () => {\n    let x = setupProxy('http://blahblah', { http_proxy: '123' }, { no_proxy: 'foo,bar,blah' });\n\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('http://blah.blah', { http_proxy: '123' }, { no_proxy: 'foo,bar,blah' });\n    expect(x.proxy).toEqual(undefined);\n    x = setupProxy('http://blah.foo', { http_proxy: '123' }, { no_proxy: 'foo,bar,blah' });\n    expect(x.proxy).toEqual(undefined);\n    x = setupProxy('http://foo.baz', { http_proxy: '123' }, { no_proxy: 'foo,bar,blah' });\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('http://blahblah', { http_proxy: '123' }, { no_proxy: ['foo', 'bar', 'blah'] });\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('http://blah.blah', { http_proxy: '123' }, { no_proxy: ['foo', 'bar', 'blah'] });\n    expect(x.proxy).toEqual(undefined);\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - hostport","suites":["Use proxy"],"updatePoint":{"line":79,"column":27},"line":79,"code":"  test('no_proxy - hostport', () => {\n    let x = setupProxy('http://localhost:80', { http_proxy: '123' }, { no_proxy: 'localhost' });\n\n    expect(x.proxy).toEqual(undefined);\n    x = setupProxy('http://localhost:8080', { http_proxy: '123' }, { no_proxy: 'localhost' });\n    expect(x.proxy).toEqual(undefined);\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"no_proxy - secure","suites":["Use proxy"],"updatePoint":{"line":87,"column":25},"line":87,"code":"  test('no_proxy - secure', () => {\n    let x = setupProxy('https://something', { http_proxy: '123' }, {});\n\n    expect(x.proxy).toEqual(undefined);\n    x = setupProxy('https://something', { https_proxy: '123' }, {});\n    expect(x.proxy).toEqual('123');\n    x = setupProxy('https://something', { http_proxy: '456', https_proxy: '123' }, {});\n    expect(x.proxy).toEqual('123');\n  });","file":"noProxy.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should be offline uplink","suites":["proxy","error handling"],"updatePoint":{"line":45,"column":34},"line":45,"code":"    test('should be offline uplink', (done) => {\n      const tarball = 'https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz';\n      nock(domain).get('/jquery/-/jquery-0.0.1.tgz').times(100).replyWithError('some error');\n      const proxy = new ProxyStorage(defaultRequestOptions, conf);\n      const stream = proxy.fetchTarball(tarball);\n      // to test a uplink is offline we have to be try 3 times\n      // the default failed request are set to 2\n      process.nextTick(function () {\n        stream.on('error', function (err) {\n          expect(err).not.toBeNull();\n          // expect(err.statusCode).toBe(404);\n          expect(proxy.failed_requests).toBe(1);\n\n          const streamSecondTry = proxy.fetchTarball(tarball);\n          streamSecondTry.on('error', function (err) {\n            expect(err).not.toBeNull();\n            /*\n                  code: 'ENOTFOUND',\n                  errno: 'ENOTFOUND',\n                 */\n            // expect(err.statusCode).toBe(404);\n            expect(proxy.failed_requests).toBe(2);\n            const streamThirdTry = proxy.fetchTarball(tarball);\n            streamThirdTry.on('error', function (err: VerdaccioError) {\n              expect(err).not.toBeNull();\n              expect(err.statusCode).toBe(HTTP_STATUS.INTERNAL_ERROR);\n              expect(proxy.failed_requests).toBe(2);\n              expect(err.message).toMatch(API_ERROR.UPLINK_OFFLINE);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"proxy.error.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"not found tarball","suites":["proxy","error handling"],"updatePoint":{"line":80,"column":27},"line":80,"code":"    test('not found tarball', (done) => {\n      nock(domain).get('/jquery/-/jquery-0.0.1.tgz').reply(404);\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n      stream.on('error', (response) => {\n        expect(response).toEqual(errorUtils.getNotFound(API_ERROR.NOT_FILE_UPLINK));\n        done();\n      });\n    });","file":"proxy.error.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"fail tarball request","suites":["proxy","error handling"],"updatePoint":{"line":90,"column":30},"line":90,"code":"    test('fail tarball request', (done) => {\n      nock(domain).get('/jquery/-/jquery-0.0.1.tgz').replyWithError('boom file');\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n      stream.on('error', (response) => {\n        expect(response).toEqual(Error('boom file'));\n        done();\n      });\n    });","file":"proxy.error.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"bad uplink request","suites":["proxy","error handling"],"updatePoint":{"line":100,"column":28},"line":100,"code":"    test('bad uplink request', (done) => {\n      nock(domain).get('/jquery/-/jquery-0.0.1.tgz').reply(409);\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n      stream.on('error', (response) => {\n        expect(response).toEqual(errorUtils.getInternalError(`bad uplink status code: 409`));\n        done();\n      });\n    });","file":"proxy.error.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"content length header mismatch","suites":["proxy","error handling"],"updatePoint":{"line":110,"column":40},"line":110,"code":"    test('content length header mismatch', (done) => {\n      nock(domain)\n        .get('/jquery/-/jquery-0.0.1.tgz')\n        // types does not match here with documentation\n        // @ts-expect-error\n        .replyWithFile(201, path.join(__dirname, 'partials/jquery-0.0.1.tgz'), {\n          [HEADER_TYPE.CONTENT_LENGTH]: 0,\n        });\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n      stream.on('error', (response) => {\n        expect(response).toEqual(errorUtils.getInternalError(API_ERROR.CONTENT_MISMATCH));\n        done();\n      });\n    });","file":"proxy.error.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"get response from endpoint","suites":["proxy","search"],"updatePoint":{"line":59,"column":36},"line":59,"code":"    test('get response from endpoint', async () => {\n      const response = require('./partials/search-v1.json');\n      const mockAgent = new MockAgent({ connections: 1 });\n      mockAgent.disableNetConnect();\n      setGlobalDispatcher(mockAgent);\n      const mockClient = mockAgent.get(domain);\n      mockClient.intercept(options).reply(200, JSON.stringify(response));\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const abort = new AbortController();\n      const stream = await prox1.search({\n        abort,\n        url: queryUrl,\n      });\n\n      const searchResponse = await getStream(stream.pipe(streamUtils.transformObjectToString()));\n      expect(searchResponse).toEqual(searchResponse);\n    });","file":"proxy.search.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"handle bad response 409","suites":["proxy","search"],"updatePoint":{"line":77,"column":33},"line":77,"code":"    test('handle bad response 409', async () => {\n      const mockAgent = new MockAgent({ connections: 1 });\n      mockAgent.disableNetConnect();\n      setGlobalDispatcher(mockAgent);\n      const mockClient = mockAgent.get(domain);\n      mockClient.intercept(options).reply(409, {});\n      const abort = new AbortController();\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      await expect(\n        prox1.search({\n          abort,\n          url: queryUrl,\n        })\n      ).rejects.toThrow('bad status code 409 from uplink');\n    });","file":"proxy.search.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"abort search from endpoint","suites":["proxy","search"],"line":93,"code":"    test.todo('abort search from endpoint');","file":"proxy.search.spec.ts","skipped":true,"dir":"packages/proxy/test"},{"name":"get file from endpoint with gzip headers","suites":["proxy","search"],"line":97,"code":"    test.todo('get file from endpoint with gzip headers');","file":"proxy.search.spec.ts","skipped":true,"dir":"packages/proxy/test"},{"name":"search endpoint fails","suites":["proxy","search"],"updatePoint":{"line":99,"column":31},"line":99,"code":"    test('search endpoint fails', async () => {\n      const mockAgent = new MockAgent({ connections: 1 });\n      mockAgent.disableNetConnect();\n      setGlobalDispatcher(mockAgent);\n      const mockClient = mockAgent.get(domain);\n      mockClient.intercept(options).reply(500, {});\n      const abort = new AbortController();\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      await expect(\n        prox1.search({\n          abort,\n          url: queryUrl,\n        })\n      ).rejects.toThrow('bad status code 500 from uplink');\n    });","file":"proxy.search.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"get file tarball no content-length","suites":["proxy","fetchTarball"],"updatePoint":{"line":47,"column":44},"line":47,"code":"    test('get file tarball no content-length', (done) => {\n      nock(domain)\n        .get('/jquery/-/jquery-0.0.1.tgz')\n        .replyWithFile(201, path.join(__dirname, 'partials/jquery-0.0.1.tgz'));\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n      stream.on('data', (data) => {\n        expect(data).toBeDefined();\n        done();\n      });\n    });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"get file tarball correct content-length","suites":["proxy","fetchTarball"],"updatePoint":{"line":59,"column":49},"line":59,"code":"    test('get file tarball correct content-length', (done) => {\n      nock(domain)\n        .get('/jquery/-/jquery-0.0.1.tgz')\n        // types does not match here with documentation\n        // @ts-expect-error\n        .replyWithFile(201, path.join(__dirname, 'partials/jquery-0.0.1.tgz'), {\n          [HEADER_TYPE.CONTENT_LENGTH]: 277,\n        });\n      const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n      const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n      stream.on(HEADER_TYPE.CONTENT_LENGTH, (data) => {\n        expect(data).toEqual('277');\n        done();\n      });\n    });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should be offline uplink","suites":["proxy","fetchTarball","error handling"],"updatePoint":{"line":76,"column":36},"line":76,"code":"      test('should be offline uplink', (done) => {\n        const tarball = 'https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz';\n        nock(domain).get('/jquery/-/jquery-0.0.1.tgz').times(100).replyWithError('some error');\n        const proxy = new ProxyStorage(defaultRequestOptions, conf);\n        const stream = proxy.fetchTarball(tarball);\n        // to test a uplink is offline we have to be try 3 times\n        // the default failed request are set to 2\n        process.nextTick(function () {\n          stream.on('error', function (err) {\n            expect(err).not.toBeNull();\n            // expect(err.statusCode).toBe(404);\n            expect(proxy.failed_requests).toBe(1);\n\n            const streamSecondTry = proxy.fetchTarball(tarball);\n            streamSecondTry.on('error', function (err) {\n              expect(err).not.toBeNull();\n              /*\n                  code: 'ENOTFOUND',\n                  errno: 'ENOTFOUND',\n                 */\n              // expect(err.statusCode).toBe(404);\n              expect(proxy.failed_requests).toBe(2);\n              const streamThirdTry = proxy.fetchTarball(tarball);\n              streamThirdTry.on('error', function (err: VerdaccioError) {\n                expect(err).not.toBeNull();\n                expect(err.statusCode).toBe(HTTP_STATUS.INTERNAL_ERROR);\n                expect(proxy.failed_requests).toBe(2);\n                expect(err.message).toMatch(API_ERROR.UPLINK_OFFLINE);\n                done();\n              });\n            });\n          });\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"not found tarball","suites":["proxy","fetchTarball","error handling"],"updatePoint":{"line":111,"column":29},"line":111,"code":"      test('not found tarball', (done) => {\n        nock(domain).get('/jquery/-/jquery-0.0.1.tgz').reply(404);\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n        stream.on('error', (response) => {\n          expect(response).toEqual(errorUtils.getNotFound(API_ERROR.NOT_FILE_UPLINK));\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"fail tarball request","suites":["proxy","fetchTarball","error handling"],"updatePoint":{"line":121,"column":32},"line":121,"code":"      test('fail tarball request', (done) => {\n        nock(domain).get('/jquery/-/jquery-0.0.1.tgz').replyWithError('boom file');\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n        stream.on('error', (response) => {\n          expect(response).toEqual(Error('boom file'));\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"bad uplink request","suites":["proxy","fetchTarball","error handling"],"updatePoint":{"line":131,"column":30},"line":131,"code":"      test('bad uplink request', (done) => {\n        nock(domain).get('/jquery/-/jquery-0.0.1.tgz').reply(409);\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n        stream.on('error', (response) => {\n          expect(response).toEqual(errorUtils.getInternalError(`bad uplink status code: 409`));\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"content length header mismatch","suites":["proxy","fetchTarball","error handling"],"updatePoint":{"line":141,"column":42},"line":141,"code":"      test('content length header mismatch', (done) => {\n        nock(domain)\n          .get('/jquery/-/jquery-0.0.1.tgz')\n          // types does not match here with documentation\n          // @ts-expect-error\n          .replyWithFile(201, path.join(__dirname, 'partials/jquery-0.0.1.tgz'), {\n            [HEADER_TYPE.CONTENT_LENGTH]: 0,\n          });\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        const stream = prox1.fetchTarball('https://registry.npmjs.org/jquery/-/jquery-0.0.1.tgz');\n        stream.on('error', (response) => {\n          expect(response).toEqual(errorUtils.getInternalError(API_ERROR.CONTENT_MISMATCH));\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"proxy call with etag","suites":["proxy","getRemoteMetadata","basic requests"],"updatePoint":{"line":161,"column":32},"line":161,"code":"      test('proxy call with etag', (done) => {\n        nock(domain)\n          .get('/jquery')\n          .reply(\n            200,\n            { body: 'test' },\n            {\n              etag: () => `_ref_4444`,\n            }\n          );\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        prox1.getRemoteMetadata('jquery', {}, (_error, body, etag) => {\n          expect(etag).toEqual('_ref_4444');\n          expect(body).toEqual({ body: 'test' });\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"proxy call with etag as option","suites":["proxy","getRemoteMetadata","basic requests"],"updatePoint":{"line":179,"column":42},"line":179,"code":"      test('proxy call with etag as option', (done) => {\n        nock(domain)\n          .get('/jquery')\n          .reply(\n            200,\n            { body: 'test' },\n            {\n              etag: () => `_ref_4444`,\n            }\n          );\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        prox1.getRemoteMetadata('jquery', { etag: 'rev_3333' }, (_error, body, etag) => {\n          expect(etag).toEqual('_ref_4444');\n          expect(body).toEqual({ body: 'test' });\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"proxy  not found","suites":["proxy","getRemoteMetadata","basic requests"],"updatePoint":{"line":197,"column":28},"line":197,"code":"      test('proxy  not found', (done) => {\n        nock(domain).get('/jquery').reply(404);\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        prox1.getRemoteMetadata('jquery', { etag: 'rev_3333' }, (error) => {\n          expect(error).toEqual(errorUtils.getNotFound(API_ERROR.NOT_PACKAGE_UPLINK));\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"reply with error","suites":["proxy","getRemoteMetadata","error handling"],"updatePoint":{"line":208,"column":28},"line":208,"code":"      test('reply with error', (done) => {\n        nock(domain).get('/jquery').replyWithError('something awful happened');\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        prox1.getRemoteMetadata('jquery', {}, (error) => {\n          expect(error).toEqual(new Error('something awful happened'));\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"reply with bad body json format","suites":["proxy","getRemoteMetadata","error handling"],"updatePoint":{"line":217,"column":43},"line":217,"code":"      test('reply with bad body json format', (done) => {\n        nock(domain).get('/jquery').reply(200, 'some-text');\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        prox1.getRemoteMetadata('jquery', {}, (error) => {\n          expect(error).toEqual(new SyntaxError('Unexpected token s in JSON at position 0'));\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"400 error proxy call","suites":["proxy","getRemoteMetadata","error handling"],"updatePoint":{"line":226,"column":32},"line":226,"code":"      test('400 error proxy call', (done) => {\n        nock(domain).get('/jquery').reply(409);\n        const prox1 = new ProxyStorage(defaultRequestOptions, conf);\n        prox1.getRemoteMetadata('jquery', {}, (error) => {\n          expect(error.statusCode).toEqual(500);\n          expect(mockInfo).toHaveBeenCalledTimes(1);\n          expect(mockHttp).toHaveBeenCalledWith({\n            request: { method: 'GET', url: `${domain}/jquery` },\n            status: 409,\n          });\n          done();\n        });\n      });","file":"proxy.tarball.spec.ts","skipped":false,"dir":"packages/proxy/test"},{"name":"should fails on protected endpoint /-/auth-package bad format","suites":["endpoint unit test","Registry API Endpoints","should test user api","should test authorization headers with tokens only errors"],"updatePoint":{"line":61,"column":75,"index":2383},"line":61,"code":"        test('should fails on protected endpoint /-/auth-package bad format', () => {\n          return new Promise(resolve => {\n            request(app).get('/auth-package').set(HEADERS.AUTHORIZATION, 'FakeHader').expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.FORBIDDEN).end(function (err, res) {\n              expect(res.body.error).toBeDefined();\n              expect(res.body.error).toMatch(/authorization required to access package auth-package/);\n              resolve(res);\n            });\n          });\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fails on protected endpoint /-/auth-package bad JWT Bearer format","suites":["endpoint unit test","Registry API Endpoints","should test user api","should test authorization headers with tokens only errors"],"updatePoint":{"line":70,"column":86,"index":2936},"line":70,"code":"        test('should fails on protected endpoint /-/auth-package bad JWT Bearer format', done => {\n          request(app).get('/auth-package').set(HEADERS.AUTHORIZATION, TOKEN_BEARER).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.FORBIDDEN).end(function (err, res) {\n            expect(res.body.error).toBeDefined();\n            expect(res.body.error).toMatch(/authorization required to access package auth-package/);\n            done();\n          });\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fails on protected endpoint /-/auth-package well JWT Bearer","suites":["endpoint unit test","Registry API Endpoints","should test user api","should test authorization headers with tokens only errors"],"updatePoint":{"line":77,"column":80,"index":3414},"line":77,"code":"        test('should fails on protected endpoint /-/auth-package well JWT Bearer', done => {\n          request(app).get('/auth-package').set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, '12345')).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.FORBIDDEN).end(function (err, res) {\n            expect(res.body.error).toBeDefined();\n            expect(res.body.error).toMatch(/authorization required to access package auth-package/);\n            done();\n          });\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should test add a new user","suites":["endpoint unit test","Registry API Endpoints","should test user api","should test authorization headers with tokens only errors"],"updatePoint":{"line":85,"column":38,"index":3881},"line":85,"code":"      test('should test add a new user', done => {\n        request(app).put(`/-/user/org.couchdb.user:${credentials.name}`).send(credentials).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n          if (err) {\n            return done(err);\n          }\n\n          expect(res.body.ok).toBeDefined();\n          expect(res.body.token).toBeDefined();\n          const token = res.body.token;\n          expect(typeof token).toBe('string');\n          expect(res.body.ok).toMatch(`user '${credentials.name}' created`); // testing JWT auth headers with token\n          // we need it here, because token is required\n\n          request(app).get('/vue').set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).end(function (err, res) {\n            expect(err).toBeNull();\n            expect(res.body).toBeDefined();\n            expect(res.body.name).toMatch(/vue/);\n            done();\n          });\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fetch jquery package from remote uplink","suites":["endpoint unit test","Registry API Endpoints","should test package api"],"updatePoint":{"line":114,"column":58,"index":5250},"line":114,"code":"      test('should fetch jquery package from remote uplink', done => {\n        request(app).get('/jquery').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            return done(err);\n          }\n\n          expect(res.body).toBeDefined();\n          expect(res.body.name).toMatch(/jquery/);\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fetch jquery specific version package from remote uplink","suites":["endpoint unit test","Registry API Endpoints","should test package api"],"updatePoint":{"line":125,"column":75,"index":5727},"line":125,"code":"      test('should fetch jquery specific version package from remote uplink', done => {\n        request(app).get('/jquery/1.5.1').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            return done(err);\n          }\n\n          expect(res.body).toBeDefined();\n          expect(res.body.name).toMatch(/jquery/);\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fetch jquery specific tag package from remote uplink","suites":["endpoint unit test","Registry API Endpoints","should test package api"],"updatePoint":{"line":136,"column":71,"index":6206},"line":136,"code":"      test('should fetch jquery specific tag package from remote uplink', done => {\n        request(app).get('/jquery/latest').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            return done(err);\n          }\n\n          expect(res.body).toBeDefined();\n          expect(res.body.name).toMatch(/jquery/);\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fails on fetch jquery specific tag package from remote uplink","suites":["endpoint unit test","Registry API Endpoints","should test package api"],"updatePoint":{"line":147,"column":80,"index":6695},"line":147,"code":"      test('should fails on fetch jquery specific tag package from remote uplink', done => {\n        request(app).get('/jquery/never-will-exist-this-tag').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.NOT_FOUND).end(function (err) {\n          if (err) {\n            return done(err);\n          }\n\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should not found a unexisting remote package under scope","suites":["endpoint unit test","Registry API Endpoints","should test package api"],"updatePoint":{"line":156,"column":68,"index":7100},"line":156,"code":"      test('should not found a unexisting remote package under scope', done => {\n        request(app).get('/@verdaccio/not-found').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.NOT_FOUND).end(function (err) {\n          if (err) {\n            return done(err);\n          }\n\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"be able to filter packages","suites":["endpoint unit test","Registry API Endpoints","should test package api","testing filters"],"updatePoint":{"line":166,"column":40,"index":7507},"line":166,"code":"        test('be able to filter packages', done => {\n          request(app).get('/npm_test').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).end(function (err, res) {\n            if (err) {\n              return done(err);\n            } // Filter out 2.0.0\n\n\n            expect(Object.keys(res.body.versions)).toEqual(['1.0.0']);\n            done();\n          });\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should not found when a filter fails","suites":["endpoint unit test","Registry API Endpoints","should test package api","testing filters"],"updatePoint":{"line":177,"column":50,"index":7974},"line":177,"code":"        test('should not found when a filter fails', done => {\n          request(app) // Filter errors look like other uplink errors\n          .get('/trigger-filter-failure').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.NOT_FOUND).end(function (err) {\n            if (err) {\n              return done(err);\n            }\n\n            done();\n          });\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should forbid access to remote package","suites":["endpoint unit test","Registry API Endpoints","should test package api","testing filters"],"updatePoint":{"line":188,"column":50,"index":8433},"line":188,"code":"      test('should forbid access to remote package', done => {\n        request(app).get('/forbidden-place').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.UNAUTHORIZED).end(function (err) {\n          if (err) {\n            return done(err);\n          }\n\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fetch a tarball from remote uplink","suites":["endpoint unit test","Registry API Endpoints","should test package api","testing filters"],"updatePoint":{"line":197,"column":53,"index":8809},"line":197,"code":"      test('should fetch a tarball from remote uplink', done => {\n        request(app).get('/jquery/-/jquery-1.5.1.tgz').expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.OCTET_STREAM).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            return done(err);\n          }\n\n          expect(res.body).toBeDefined();\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fetch a scoped tarball from remote uplink","suites":["endpoint unit test","Registry API Endpoints","should test package api","testing filters"],"updatePoint":{"line":207,"column":60,"index":9187},"line":207,"code":"      test('should fetch a scoped tarball from remote uplink', done => {\n        request(app).get('/@jquery/jquery/-/@jquery/jquery-1.5.1.tgz').expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.OCTET_STREAM).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            return done(err);\n          }\n\n          expect(res.body).toBeDefined();\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fails fetch a tarball from remote uplink","suites":["endpoint unit test","Registry API Endpoints","should test package api","testing filters"],"updatePoint":{"line":217,"column":59,"index":9580},"line":217,"code":"      test('should fails fetch a tarball from remote uplink', done => {\n        request(app).get('/jquery/-/jquery-not-found-tarball-0.0.1.tgz').expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.OCTET_STREAM).expect(HTTP_STATUS.NOT_FOUND).end(function (err) {\n          if (err) {\n            expect(err).not.toBeNull();\n            return done(err);\n          }\n\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should set a new tag on jquery","suites":["endpoint unit test","Registry API Endpoints","should test dist-tag api"],"updatePoint":{"line":234,"column":42,"index":10143},"line":234,"code":"      test('should set a new tag on jquery', done => {\n        putVersion(app, '/jquery/verdaccio-tag', jqueryVersion).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n          if (err) {\n            expect(err).toBeNull();\n            return done(err);\n          }\n\n          expect(res.body.ok).toBeDefined();\n          expect(res.body.ok).toMatch(/package tagged/);\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fetch all tag for jquery","suites":["endpoint unit test","Registry API Endpoints","should test dist-tag api"],"updatePoint":{"line":246,"column":43,"index":10559},"line":246,"code":"      test('should fetch all tag for jquery', done => {\n        request(app).get('/-/package/jquery/dist-tags').set('accept-encoding', HEADERS.JSON).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            expect(err).toBeNull();\n            return done(err);\n          }\n\n          expect(res.body).toBeDefined();\n          expect(res.body['verdaccio-tag']).toMatch(jqueryVersion);\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should update a new tag on jquery","suites":["endpoint unit test","Registry API Endpoints","should test dist-tag api"],"updatePoint":{"line":258,"column":45,"index":11053},"line":258,"code":"      test('should update a new tag on jquery', done => {\n        request(app).post('/-/package/jquery/dist-tags').send(JSON.stringify(jqueryUpdatedVersion)).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n          if (err) {\n            expect(err).toBeNull();\n            return done(err);\n          }\n\n          expect(res.body.ok).toBeDefined();\n          expect(res.body.ok).toMatch(API_MESSAGE.TAG_UPDATED);\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fetch all tags for jquery and ccheck previous update","suites":["endpoint unit test","Registry API Endpoints","should test dist-tag api"],"updatePoint":{"line":270,"column":71,"index":11584},"line":270,"code":"      test('should fetch all tags for jquery and ccheck previous update', done => {\n        request(app).get('/-/package/jquery/dist-tags').set('accept-encoding', HEADERS.JSON).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            expect(err).toBeNull();\n            return done(err);\n          }\n\n          expect(res.body).toBeDefined();\n          expect(res.body['beta']).toMatch(jqueryUpdatedVersion['beta']);\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should set a remove a tag on jquery","suites":["endpoint unit test","Registry API Endpoints","should test dist-tag api"],"updatePoint":{"line":282,"column":47,"index":12086},"line":282,"code":"      test('should set a remove a tag on jquery', done => {\n        request(app).del('/-/package/jquery/dist-tags/verdaccio-tag').set('accept-encoding', HEADERS.JSON).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON) // .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n        .expect(HTTP_STATUS.CREATED).end(function (err, res) {\n          if (err) {\n            expect(err).toBeNull();\n            return done(err);\n          }\n\n          expect(res.body.ok).toBeDefined();\n          expect(res.body.ok).toMatch(API_MESSAGE.TAG_REMOVED);\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should perform a search","suites":["endpoint unit test","Registry API Endpoints","should test search api"],"updatePoint":{"line":297,"column":35,"index":12711},"line":297,"code":"      test('should perform a search', done => {\n        request(app).get('/-/v1/search?text=npm7&size=2000&from=0&quality=1&popularity=0.1&maintenance=0.1').set('accept-encoding', HEADERS.JSON).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).expect(HEADERS.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.OK).end(function (err) {\n          if (err) {\n            expect(err).toBeNull();\n            return done(err);\n          } // TODO: we have to catch the stream check whether it returns something\n          // we should not spend much time on this api since is deprecated somehow.\n\n\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should flow with no credentials","suites":["endpoint unit test","Registry API Endpoints","should test publish/unpublish api","un/publish scenarios with credentials"],"updatePoint":{"line":343,"column":45,"index":14738},"line":343,"code":"        test('should flow with no credentials', async () => {\n          const pkgName = '@public-anyone-can-publish/pk1-test';\n          return await runPublishUnPublishFlow(pkgName, undefined);\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should flow with credentials","suites":["endpoint unit test","Registry API Endpoints","should test publish/unpublish api","un/publish scenarios with credentials"],"updatePoint":{"line":347,"column":42,"index":14942},"line":347,"code":"        test('should flow with credentials', async () => {\n          const credentials = {\n            name: 'jota_unpublish',\n            password: 'secretPass'\n          };\n          const token = await getNewToken(request(app), credentials);\n          const pkgName = '@only-one-can-publish/pk1-test';\n          return await runPublishUnPublishFlow(pkgName, token);\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fail if user is not allowed to unpublish","suites":["endpoint unit test","Registry API Endpoints","should test publish/unpublish api","test error handling"],"updatePoint":{"line":358,"column":61,"index":15398},"line":358,"code":"        test('should fail if user is not allowed to unpublish', async () => {\n          /**\n           * Context:\n           *\n           *  'non-unpublish':\n           *    access: $authenticated\n           *    publish: jota_unpublish_fail\n           *    # There is some conditions to keep on mind here\n           *    # - If unpublish is empty, fallback with the publish value\n           *    # - If the user has permissions to publish and this empty it will\n           *    #   be allowed to unpublish\n           *    # - If we want to forbid anyone to unpublish, just write here any non-existing user\n           *    unpublish: none\n           *\n           *   The result of this test should fail and even if jota_unpublish_fail is\n           *   allowed to publish.\n           *\n           */\n          const credentials = {\n            name: 'jota_unpublish_fail',\n            password: 'secretPass'\n          };\n          const pkgName = 'non-unpublish';\n          const newVersion = '1.0.0';\n          const token = await getNewToken(request(app), credentials);\n          const [newErr] = await putPackage(request(app), `/${pkgName}`, generatePackageMetadata(pkgName, newVersion), token);\n\n          if (newErr) {\n            expect(newErr).toBeNull();\n            return Promise.reject(newErr);\n          }\n\n          const deletePayload = generatePackageUnpublish(pkgName, ['2.0.0']);\n          const [err2, res2] = await putPackage(request(app), generateUnPublishURI(pkgName), deletePayload, token);\n          expect(err2).not.toBeNull();\n          expect(res2.body.error).toMatch(/user jota_unpublish_fail is not allowed to unpublish package non-unpublish/);\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fail if publish prop is not defined","suites":["endpoint unit test","Registry API Endpoints","should test publish/unpublish api","test error handling"],"updatePoint":{"line":395,"column":56,"index":17078},"line":395,"code":"        test('should fail if publish prop is not defined', async () => {\n          /**\n           * Context:\n           *\n           *   'non-unpublish':\n           access: $authenticated\n           publish: jota_unpublish_fail\n           # There is some conditions to keep on mind here\n           # - If unpublish is empty, fallback with the publish value\n           # - If the user has permissions to publish and this empty it will be allowed to unpublish\n           # - If we want to forbid anyone to unpublish,  just write here any non-existing user\n           unpublish: none\n            The result of this test should fail and even if jota_unpublish_fail is allowed\n           to publish.\n            *\n           */\n          const credentials = {\n            name: 'jota_only_unpublish_fail',\n            password: 'secretPass'\n          };\n          const pkgName = 'only-unpublish';\n          const newVersion = '1.0.0';\n          const token = await getNewToken(request(app), credentials);\n          const [newErr, resp] = await putPackage(request(app), `/${pkgName}`, generatePackageMetadata(pkgName, newVersion), token);\n          expect(newErr).not.toBeNull();\n          expect(resp.body.error).toMatch(/user jota_only_unpublish_fail is not allowed to publish package only-unpublish/);\n        });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should be able to publish/unpublish by only super_admin user","suites":["endpoint unit test","Registry API Endpoints","should test publish/unpublish api","test error handling"],"updatePoint":{"line":423,"column":72,"index":18416},"line":423,"code":"      test('should be able to publish/unpublish by only super_admin user', async () => {\n        const credentials = {\n          name: 'super_admin',\n          password: 'secretPass'\n        };\n        const token = await getNewToken(request(app), credentials);\n        return new Promise((resolve, reject) => {\n          request(app).put('/super-admin-can-unpublish').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).send(JSON.stringify(_.assign({}, publishMetadata, {\n            name: 'super-admin-can-unpublish'\n          }))).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n            if (err) {\n              expect(err).toBeNull();\n              return reject(err);\n            }\n\n            expect(res.body.ok).toBeDefined();\n            expect(res.body.success).toBeDefined();\n            expect(res.body.success).toBeTruthy();\n            expect(res.body.ok).toMatch(API_MESSAGE.PKG_CREATED);\n            request(app).del('/super-admin-can-unpublish/-rev/4-6abcdb4efd41a576').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n              expect(err).toBeNull();\n              expect(res.body.ok).toBeDefined();\n              expect(res.body.ok).toMatch(API_MESSAGE.PKG_REMOVED);\n              resolve(res);\n            });\n          });\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should be able to publish/unpublish by any user","suites":["endpoint unit test","Registry API Endpoints","should test publish/unpublish api","test error handling"],"updatePoint":{"line":451,"column":59,"index":19845},"line":451,"code":"      test('should be able to publish/unpublish by any user', async () => {\n        const credentials = {\n          name: 'any_user',\n          password: 'secretPass'\n        };\n        const token = await getNewToken(request(app), credentials);\n        return new Promise((resolve, reject) => {\n          request(app).put('/all-can-unpublish').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).send(JSON.stringify(_.assign({}, publishMetadata, {\n            name: 'all-can-unpublish'\n          }))).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n            if (err) {\n              expect(err).toBeNull();\n              return reject(err);\n            }\n\n            expect(res.body.ok).toBeDefined();\n            expect(res.body.success).toBeDefined();\n            expect(res.body.success).toBeTruthy();\n            expect(res.body.ok).toMatch(API_MESSAGE.PKG_CREATED);\n            request(app).del('/all-can-unpublish/-rev/4-6abcdb4efd41a576').set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n              expect(err).toBeNull();\n              expect(res.body.ok).toBeDefined();\n              expect(res.body.ok).toMatch(API_MESSAGE.PKG_REMOVED);\n              resolve(res);\n            });\n          });\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should star a package","suites":["endpoint unit test","Registry API Endpoints","should test star and stars api"],"updatePoint":{"line":491,"column":33,"index":21643},"line":491,"code":"      test('should star a package', done => {\n        request(app).put(`/${pkgName}`).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify(generateStarMedatada(pkgName, {\n          [credentials.name]: true\n        }))).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            expect(err).toBeNull();\n            return done(err);\n          }\n\n          expect(res.body.success).toBeDefined();\n          expect(res.body.success).toBeTruthy();\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should unstar a package","suites":["endpoint unit test","Registry API Endpoints","should test star and stars api"],"updatePoint":{"line":505,"column":35,"index":22223},"line":505,"code":"      test('should unstar a package', done => {\n        request(app).put(`/${pkgName}`).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).send(JSON.stringify(generateStarMedatada(pkgName, {}))).expect(HTTP_STATUS.OK).end(function (err, res) {\n          if (err) {\n            expect(err).toBeNull();\n            return done(err);\n          }\n\n          expect(res.body.success).toBeDefined();\n          expect(res.body.success).toBeTruthy();\n          done();\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should retrieve stars list with credentials","suites":["endpoint unit test","Registry API Endpoints","should test star and stars api"],"updatePoint":{"line":517,"column":55,"index":22779},"line":517,"code":"      test('should retrieve stars list with credentials', async () => {\n        return new Promise((resolve, reject) => {\n          request(app).put(`/${pkgName}`).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(generateStarMedatada(pkgName, {\n            [credentials.name]: true\n          })).expect(HTTP_STATUS.OK).end(function (err) {\n            if (err) {\n              expect(err).toBeNull();\n              return reject(err);\n            }\n\n            request(app).get('/-/_view/starredByUser').set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BEARER, token)).set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON).send(JSON.stringify({\n              key: [credentials.name]\n            })).expect(HTTP_STATUS.OK).end(function (err, res) {\n              if (err) {\n                expect(err).toBeNull();\n                return reject(err);\n              }\n\n              expect(res.body.rows).toBeDefined();\n              expect(res.body.rows).toHaveLength(1);\n              resolve(res);\n            });\n          });\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should deprecate a package","suites":["endpoint unit test","Registry API Endpoints","should test (un)deprecate api"],"updatePoint":{"line":555,"column":38,"index":24322},"line":555,"code":"      test('should deprecate a package', async () => {\n        const pkg = generateDeprecateMetadata(pkgName, version, 'get deprecated');\n        const [err] = await putPackage(request(app), `/${pkgName}`, pkg, token);\n\n        if (err) {\n          expect(err).toBeNull();\n          return Promise.reject(err);\n        }\n\n        const [, res] = await getPackage(request(app), '', pkgName);\n        expect(res.body.versions[version].deprecated).toEqual('get deprecated');\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should undeprecate a package","suites":["endpoint unit test","Registry API Endpoints","should test (un)deprecate api"],"updatePoint":{"line":567,"column":40,"index":24806},"line":567,"code":"      test('should undeprecate a package', async () => {\n        let pkg = generateDeprecateMetadata(pkgName, version, 'get deprecated');\n        await putPackage(request(app), `/${pkgName}`, pkg, token);\n        pkg = generateDeprecateMetadata(pkgName, version, '');\n        const [err] = await putPackage(request(app), `/${pkgName}`, pkg, token);\n\n        if (err) {\n          expect(err).toBeNull();\n          return;\n        }\n\n        const [, res] = await getPackage(request(app), '', pkgName);\n        expect(res.body.versions[version].deprecated).not.toBeDefined();\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should deprecate multiple packages","suites":["endpoint unit test","Registry API Endpoints","should test (un)deprecate api"],"updatePoint":{"line":602,"column":46,"index":26503},"line":602,"code":"      test('should deprecate multiple packages', async () => {\n        await putPackage(request(app), `/${pkgName}`, generatePackageMetadata(pkgName, '1.0.1'), token);\n        const pkg = generateDeprecateMetadata(pkgName, version, 'get deprecated');\n        pkg.versions['1.0.1'] = { ...generateVersion(pkgName, '1.0.1'),\n          deprecated: 'get deprecated'\n        };\n        await putPackage(request(app), `/${pkgName}`, pkg, token);\n        const [, res] = await getPackage(request(app), '', pkgName);\n        return new Promise(resolve => {\n          expect(res.body.versions[version].deprecated).toEqual('get deprecated');\n          expect(res.body.versions['1.0.1'].deprecated).toEqual('get deprecated');\n          resolve(res);\n        });\n      });","file":"api/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"server should respond on /","suites":["basic system test"],"updatePoint":{"line":36,"column":34,"index":957},"line":36,"code":"  test('server should respond on /', done => {\n    request({\n      url: 'http://localhost:' + port + '/'\n    }, function (err, res, body) {\n      expect(err).toBeNull();\n      expect(body).toMatch(/Verdaccio/);\n      done();\n    });\n  });","file":"basic/index.spec.ts","skipped":true,"dir":"packages/server/test"},{"name":"server should respond on /___not_found_package","suites":["basic system test"],"updatePoint":{"line":45,"column":54,"index":1216},"line":45,"code":"  test('server should respond on /___not_found_package', done => {\n    request({\n      json: true,\n      url: `http://localhost:${port}/___not_found_package`\n    }, function (err, res, body) {\n      expect(err).toBeNull();\n      expect(body.error).toMatch(API_ERROR.NO_PACKAGE);\n      done();\n    });\n  });","file":"basic/index.spec.ts","skipped":true,"dir":"packages/server/test"},{"name":"should test add a new user with JWT enabled","suites":["endpoint user auth JWT unit test"],"updatePoint":{"line":47,"column":51,"index":1633},"line":47,"code":"  test('should test add a new user with JWT enabled', async () => {\n    const [err, res] = await addUser(request(app), credentials.name, credentials);\n    expect(err).toBeNull();\n    expect(res.body.ok).toBeDefined();\n    expect(res.body.token).toBeDefined();\n    const {\n      token\n    } = res.body;\n    expect(typeof token).toBe('string');\n    expect(res.body.ok).toMatch(`user '${credentials.name}' created`); // testing JWT auth headers with token\n    // we need it here, because token is required\n\n    const [err1, resp1] = await getPackage(request(app), token, 'vue');\n    expect(err1).toBeNull();\n    expect(resp1.body).toBeDefined();\n    expect(resp1.body.name).toMatch('vue');\n    const [err2, resp2] = await getPackage(request(app), FAKE_TOKEN, 'vue', HTTP_STATUS.UNAUTHORIZED);\n    expect(err2).toBeNull();\n    expect(resp2.statusCode).toBe(HTTP_STATUS.UNAUTHORIZED);\n    expect(resp2.body.error).toMatch(FORBIDDEN_VUE);\n  });","file":"jwt/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should emulate npm login when user already exist","suites":["endpoint user auth JWT unit test"],"updatePoint":{"line":68,"column":56,"index":2577},"line":68,"code":"  test('should emulate npm login when user already exist', async () => {\n    const credentials = {\n      name: 'jwtUser2',\n      password: 'secretPass'\n    }; // creates an user\n\n    await addUser(request(app), credentials.name, credentials); // it should fails conflict 409\n\n    await addUser(request(app), credentials.name, credentials, HTTP_STATUS.CONFLICT); // npm will try to sign in sending credentials via basic auth header\n\n    const token = buildUserBuffer(credentials.name, credentials.password).toString('base64'); // put should exist in request\n\n    return new Promise(resolve => {\n      // @ts-ignore\n      request(app).put(`/-/user/org.couchdb.user:${credentials.name}/-rev/undefined`).send(credentials).set(HEADERS.AUTHORIZATION, buildToken(TOKEN_BASIC, token)).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HTTP_STATUS.CREATED).end(function (err, res) {\n        expect(err).toBeNull();\n        expect(res.body.ok).toBeDefined();\n        expect(res.body.token).toBeDefined();\n        resolve(res);\n      });\n    });\n  });","file":"jwt/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fails on try to access with corrupted token","suites":["endpoint user auth JWT unit test"],"updatePoint":{"line":90,"column":58,"index":3632},"line":90,"code":"  test('should fails on try to access with corrupted token', async () => {\n    const [err2, resp2] = await getPackage(request(app), FAKE_TOKEN, 'vue', HTTP_STATUS.UNAUTHORIZED);\n    expect(err2).toBeNull();\n    expect(resp2.statusCode).toBe(HTTP_STATUS.UNAUTHORIZED);\n    expect(resp2.body.error).toMatch(FORBIDDEN_VUE);\n  });","file":"jwt/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should test fails on fetch endpoint /-/not-found","suites":["api with no limited access configuration","test proxy packages partially restricted"],"updatePoint":{"line":39,"column":58,"index":1308},"line":39,"code":"    test('should test fails on fetch endpoint /-/not-found', () => {\n      return new Promise((resolve, reject) => {\n        request(app) // @ts-ignore\n        .get('/not-found-for-sure').set(HEADERS.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADERS.CONTENT_TYPE, /json/).expect(HTTP_STATUS.NOT_FOUND).end(function (err) {\n          if (err) {\n            return reject(err);\n          }\n\n          resolve(null);\n        });\n      });\n    });","file":"package-access/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should test fetch endpoint /-/jquery","suites":["api with no limited access configuration","test proxy packages partially restricted"],"updatePoint":{"line":51,"column":46,"index":1741},"line":51,"code":"    test('should test fetch endpoint /-/jquery', () => {\n      return new Promise((resolve, reject) => {\n        request(app) // @ts-ignore\n        .get('/jquery').set(HEADERS.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADERS.CONTENT_TYPE, /json/).expect(HTTP_STATUS.OK).end(function (err) {\n          if (err) {\n            return reject(err);\n          }\n\n          resolve(null);\n        });\n      });\n    });","file":"package-access/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should success on fetch endpoint /-/vue","suites":["api with no limited access configuration","test proxy packages partially restricted"],"updatePoint":{"line":63,"column":49,"index":2158},"line":63,"code":"    test('should success on fetch endpoint /-/vue', () => {\n      return new Promise((resolve, reject) => {\n        request(app) // @ts-ignore\n        .get('/vue').set(HEADERS.CONTENT_TYPE, HEADERS.JSON_CHARSET).expect(HEADERS.CONTENT_TYPE, /json/).expect(HTTP_STATUS.OK).end(function (err) {\n          if (err) {\n            return reject(err);\n          }\n\n          resolve(null);\n        });\n      });\n    });","file":"package-access/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should fetch a profile of logged user","suites":["endpoint user profile"],"updatePoint":{"line":40,"column":45,"index":1324},"line":40,"code":"  test('should fetch a profile of logged user', async () => {\n    const credentials = {\n      name: 'JotaJWT',\n      password: 'secretPass'\n    };\n    const token = await getNewToken(request(app), credentials);\n    const [err1, res1] = await getProfile(request(app), token);\n    expect(err1).toBeNull();\n    expect(res1.body.name).toBe(credentials.name);\n  });","file":"profile/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should change password successfully","suites":["endpoint user profile","change password"],"updatePoint":{"line":51,"column":45,"index":1723},"line":51,"code":"    test('should change password successfully', async () => {\n      const credentials = {\n        name: 'userTest2000',\n        password: 'secretPass000'\n      };\n      const body = {\n        password: {\n          new: '12345678',\n          old: credentials.password\n        }\n      };\n      const token = await getNewToken(request(app), credentials);\n      const [err1, res1] = await postProfile(request(app), body, token);\n      expect(err1).toBeNull();\n      expect(res1.body.name).toBe(credentials.name);\n    });","file":"profile/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should change password is too short","suites":["endpoint user profile","change password"],"updatePoint":{"line":67,"column":45,"index":2240},"line":67,"code":"    test('should change password is too short', async () => {\n      const credentials = {\n        name: 'userTest2001',\n        password: 'secretPass001'\n      };\n      const body = {\n        password: {\n          new: 'p1',\n          old: credentials.password\n        }\n      };\n      const token = await getNewToken(request(app), credentials);\n      const [, resp] = await postProfile(request(app), body, token, HTTP_STATUS.UNAUTHORIZED);\n      expect(resp.error).not.toBeNull();\n      /* eslint new-cap: 0 */\n\n      expect(resp.error.text).toMatch(API_ERROR.PASSWORD_SHORT());\n    });","file":"profile/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should report TFA is disabled","suites":["endpoint user profile","change tfa"],"updatePoint":{"line":87,"column":39,"index":2861},"line":87,"code":"    test('should report TFA is disabled', async () => {\n      const credentials = {\n        name: 'userTest2002',\n        password: 'secretPass002'\n      };\n      const body = {\n        tfa: {}\n      };\n      const token = await getNewToken(request(app), credentials);\n      const [, resp] = await postProfile(request(app), body, token, HTTP_STATUS.SERVICE_UNAVAILABLE);\n      expect(resp.error).not.toBeNull();\n      expect(resp.error.text).toMatch(SUPPORT_ERRORS.TFA_DISABLED);\n    });","file":"profile/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should forbid to fetch a profile with invalid token","suites":["endpoint user profile","error handling"],"updatePoint":{"line":102,"column":61,"index":3414},"line":102,"code":"    test('should forbid to fetch a profile with invalid token', async () => {\n      const [, resp] = await getProfile(request(app), `fakeToken`, HTTP_STATUS.UNAUTHORIZED);\n      expect(resp.error).not.toBeNull();\n      expect(resp.error.text).toMatch(API_ERROR.MUST_BE_LOGGED);\n    });","file":"profile/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should forbid to update a profile with invalid token","suites":["endpoint user profile","error handling"],"updatePoint":{"line":107,"column":62,"index":3701},"line":107,"code":"    test('should forbid to update a profile with invalid token', async () => {\n      const [, resp] = await postProfile(request(app), {}, `fakeToken`, HTTP_STATUS.UNAUTHORIZED);\n      expect(resp.error).not.toBeNull();\n      expect(resp.error.text).toMatch(API_ERROR.MUST_BE_LOGGED);\n    });","file":"profile/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should display sidebar info","suites":["endpoint web unit test","Registry WebUI endpoints","Packages"],"updatePoint":{"line":47,"column":39,"index":1797},"line":47,"code":"      test('should display sidebar info', () => {\n        return new Promise(resolve => {\n          request(app).get('/-/verdaccio/data/sidebar/@scope/pk1-test').expect(HTTP_STATUS.OK).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).end(function (err, res) {\n            // console.log(\"-->\", res);\n            // expect(err).toBeNull();\n            const sideBarInfo = res.body;\n            const latestVersion = publishMetadata.versions[publishMetadata[DIST_TAGS].latest];\n            expect(sideBarInfo.latest.author).toBeDefined();\n            expect(sideBarInfo.latest.author.avatar).toMatch(/www.gravatar.com/);\n            expect(sideBarInfo.latest.author.name).toBe(latestVersion.author.name);\n            expect(sideBarInfo.latest.author.email).toBe(latestVersion.author.email);\n            resolve(sideBarInfo);\n          });\n        });\n      });","file":"web/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should display sidebar info by version","suites":["endpoint web unit test","Registry WebUI endpoints","Packages"],"updatePoint":{"line":62,"column":50,"index":2673},"line":62,"code":"      test('should display sidebar info by version', () => {\n        return new Promise(resolve => {\n          request(app).get('/-/verdaccio/data/sidebar/@scope/pk1-test?v=1.0.6').expect(HTTP_STATUS.OK).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).end(function (err, res) {\n            const sideBarInfo = res.body;\n            const latestVersion = publishMetadata.versions[publishMetadata[DIST_TAGS].latest];\n            expect(sideBarInfo.latest.author).toBeDefined();\n            expect(sideBarInfo.latest.author.avatar).toMatch(/www.gravatar.com/);\n            expect(sideBarInfo.latest.author.name).toBe(latestVersion.author.name);\n            expect(sideBarInfo.latest.author.email).toBe(latestVersion.author.email);\n            resolve(sideBarInfo);\n          });\n        });\n      });","file":"web/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should display sidebar info 404","suites":["endpoint web unit test","Registry WebUI endpoints","Packages"],"updatePoint":{"line":75,"column":43,"index":3471},"line":75,"code":"      test('should display sidebar info 404', () => {\n        return new Promise(resolve => {\n          request(app).get('/-/verdaccio/data/sidebar/@scope/404').expect(HTTP_STATUS.NOT_FOUND).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).end(function () {\n            resolve(null);\n          });\n        });\n      });","file":"web/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should display sidebar info 404 with version","suites":["endpoint web unit test","Registry WebUI endpoints","Packages"],"updatePoint":{"line":82,"column":56,"index":3811},"line":82,"code":"      test('should display sidebar info 404 with version', () => {\n        return new Promise(resolve => {\n          request(app).get('/-/verdaccio/data/sidebar/@scope/pk1-test?v=0.0.0-not-found').expect(HTTP_STATUS.NOT_FOUND).expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET).end(function () {\n            resolve(null);\n          });\n        });\n      });","file":"web/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should find @scope/pk1-test","suites":["endpoint web unit test","Registry WebUI endpoints","Search"],"updatePoint":{"line":91,"column":39,"index":4196},"line":91,"code":"      test('should find @scope/pk1-test', () => {\n        return new Promise(resolve => {\n          request(app).get('/-/verdaccio/data/search/@scope%2fpk1-test').expect(HTTP_STATUS.OK).end(function (_err, res) {\n            expect(res.body).toHaveLength(1);\n            resolve(res);\n          });\n        });\n      });","file":"web/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should not find forbidden-place","suites":["endpoint web unit test","Registry WebUI endpoints","Search"],"updatePoint":{"line":99,"column":43,"index":4521},"line":99,"code":"      test('should not find forbidden-place', () => {\n        return new Promise(resolve => {\n          request(app).get('/-/verdaccio/data/search/forbidden-place').expect(HTTP_STATUS.OK).end(function (err, res) {\n            // this is expected since we are not logged\n            // and  forbidden-place is allow_access: 'nobody'\n            expect(res.body).toHaveLength(0);\n            resolve(res);\n          });\n        });\n      });","file":"web/index.spec.ts","skipped":false,"dir":"packages/server/test"},{"name":"should add a package","suites":["LocalStorage","LocalStorage::preparePackage"],"updatePoint":{"line":106,"column":30},"line":106,"code":"    test('should add a package', (done) => {\n      const metadata = JSON.parse(readMetadata().toString());\n      // @ts-ignore\n      const pkgStoragePath = storage._getLocalStorage(pkgName);\n      // @ts-expect-error\n      rimRaf(pkgStoragePath.path, (err) => {\n        expect(err).toBeNull();\n        storage.addPackage(pkgName, metadata, (_err, data) => {\n          expect(data.version).toMatch(/1.0.0/);\n          expect(data.dist.tarball).toMatch(/npm_test-1.0.0.tgz/);\n          expect(data.name).toEqual(pkgName);\n          done();\n        });\n      });\n    });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should add a @scope package","suites":["LocalStorage","LocalStorage::preparePackage"],"updatePoint":{"line":122,"column":37},"line":122,"code":"    test('should add a @scope package', (done) => {\n      const metadata = JSON.parse(readMetadata());\n      // @ts-ignore\n      const pkgStoragePath = storage._getLocalStorage(pkgNameScoped);\n      // @ts-expect-error\n      rimRaf(pkgStoragePath.path, (err) => {\n        expect(err).toBeNull();\n        storage.addPackage(pkgNameScoped, metadata, (err, data) => {\n          expect(err).toBeNull();\n          expect(data.version).toMatch(/1.0.0/);\n          expect(data.dist.tarball).toMatch(/npm_test-1.0.0.tgz/);\n          expect(data.name).toEqual(pkgName);\n          done();\n        });\n      });\n    });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails on add a package","suites":["LocalStorage","LocalStorage::preparePackage"],"updatePoint":{"line":139,"column":39},"line":139,"code":"    test('should fails on add a package', async () => {\n      const metadata = JSON.parse(readMetadata());\n      await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n      return new Promise((resolve) => {\n        storage.addPackage(pkgName, metadata, (err) => {\n          expect(err).not.toBeNull();\n          expect(err.statusCode).toEqual(HTTP_STATUS.CONFLICT);\n          expect(err.message).toMatch(API_ERROR.PACKAGE_EXIST);\n          resolve(true);\n        });\n      });\n    });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should mergeTags","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::mergeTags"],"updatePoint":{"line":153,"column":28},"line":153,"code":"      test('should mergeTags', async () => {\n        const pkgName = 'merge-tags-test-1';\n        await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n        await addNewVersion(pkgName, '1.0.0');\n        await addNewVersion(pkgName, '2.0.0');\n        await addNewVersion(pkgName, '3.0.0');\n        const tags: MergeTags = {\n          beta: '3.0.0',\n          latest: '2.0.0',\n        };\n\n        return new Promise((resolve) => {\n          storage.mergeTags(pkgName, tags, async (err, data) => {\n            expect(err).toBeNull();\n            expect(data).toBeUndefined();\n            const metadata: Package = await getPackageMetadataFromStore(pkgName);\n            expect(metadata[DIST_TAGS]).toBeDefined();\n            expect(metadata[DIST_TAGS]['beta']).toBeDefined();\n            expect(metadata[DIST_TAGS]['beta']).toBe('3.0.0');\n            expect(metadata[DIST_TAGS]['latest']).toBe('2.0.0');\n            resolve(data);\n          });\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails mergeTags version not found","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::mergeTags"],"updatePoint":{"line":178,"column":52},"line":178,"code":"      test('should fails mergeTags version not found', async () => {\n        const pkgName = 'merge-tags-test-1';\n        await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n        // const tarballName: string = `${pkgName}-${version}.tgz`;\n        await addNewVersion(pkgName, '1.0.0');\n        await addNewVersion(pkgName, '2.0.0');\n        await addNewVersion(pkgName, '3.0.0');\n        const tags: MergeTags = {\n          beta: '9999.0.0',\n        };\n\n        return new Promise((resolve) => {\n          storage.mergeTags(pkgName, tags, async (err) => {\n            expect(err).not.toBeNull();\n            expect(err.statusCode).toEqual(HTTP_STATUS.NOT_FOUND);\n            expect(err.message).toMatch(API_ERROR.VERSION_NOT_EXIST);\n            resolve(tags);\n          });\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails on mergeTags","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::mergeTags"],"updatePoint":{"line":199,"column":37},"line":199,"code":"      test('should fails on mergeTags', (done) => {\n        const tags: MergeTags = {\n          beta: '3.0.0',\n          latest: '2.0.0',\n        };\n\n        storage.mergeTags('not-found', tags, (err) => {\n          expect(err).not.toBeNull();\n          expect(err.statusCode).toEqual(HTTP_STATUS.NOT_FOUND);\n          expect(err.message).toMatch(API_ERROR.NO_PACKAGE);\n          done();\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should add new version without tag","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::addVersion"],"updatePoint":{"line":215,"column":46},"line":215,"code":"      test('should add new version without tag', async () => {\n        const pkgName = 'add-version-test-1';\n        const version = '1.0.1';\n        await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n        const tarballName = `${pkgName}-${version}.tgz`;\n        await addNewVersion(pkgName, '9.0.0');\n        await addTarballToStore(pkgName, `${pkgName}-9.0.0.tgz`);\n        await addTarballToStore(pkgName, tarballName);\n\n        return new Promise((resolve) => {\n          storage.addVersion(\n            pkgName,\n            version,\n            generateNewVersion(pkgName, version),\n            '',\n            (err, data) => {\n              expect(err).toBeNull();\n              expect(data).toBeUndefined();\n              resolve(data);\n            }\n          );\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails on add a duplicated version without tag","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::addVersion"],"updatePoint":{"line":239,"column":64},"line":239,"code":"      test('should fails on add a duplicated version without tag', async () => {\n        const pkgName = 'add-version-test-2';\n        const version = '1.0.1';\n        await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n        await addNewVersion(pkgName, version);\n\n        return new Promise((resolve) => {\n          storage.addVersion(pkgName, version, generateNewVersion(pkgName, version), '', (err) => {\n            expect(err).not.toBeNull();\n            expect(err.statusCode).toEqual(HTTP_STATUS.CONFLICT);\n            expect(err.message).toMatch(API_ERROR.PACKAGE_EXIST);\n            resolve(err);\n          });\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails add new version wrong shasum","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::addVersion"],"updatePoint":{"line":255,"column":53},"line":255,"code":"      test('should fails add new version wrong shasum', async () => {\n        const pkgName = 'add-version-test-4';\n        const version = '4.0.0';\n        await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n        const tarballName = `${pkgName}-${version}.tgz`;\n        await addTarballToStore(pkgName, tarballName);\n\n        return new Promise((resolve) => {\n          storage.addVersion(\n            pkgName,\n            version,\n            generateNewVersion(pkgName, version, 'fake'),\n            '',\n            (err) => {\n              expect(err).not.toBeNull();\n              expect(err.statusCode).toEqual(HTTP_STATUS.BAD_REQUEST);\n              expect(err.message).toMatch(/shasum error/);\n              resolve(err);\n            }\n          );\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should add new second version without tag","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::addVersion"],"updatePoint":{"line":278,"column":53},"line":278,"code":"      test('should add new second version without tag', async () => {\n        const pkgName = 'add-version-test-3';\n        const version = '1.0.2';\n        await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n        await addNewVersion(pkgName, '1.0.1');\n        await addNewVersion(pkgName, '1.0.3');\n        return new Promise((resolve) => {\n          storage.addVersion(\n            pkgName,\n            version,\n            generateNewVersion(pkgName, version),\n            'beta',\n            (err, data) => {\n              expect(err).toBeNull();\n              expect(data).toBeUndefined();\n              resolve(data);\n            }\n          );\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should update versions from external source","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::updateVersions"],"updatePoint":{"line":323,"column":55},"line":323,"code":"      test('should update versions from external source', (done) => {\n        _storage.updateVersions(pkgName, metadata, (err, data) => {\n          expect(err).toBeNull();\n          expect(_storage._writePackage).toHaveBeenCalledTimes(1);\n          expect(data.versions['1.0.1']).toBeDefined();\n          expect(data.versions[version]).toBeDefined();\n          expect(data.versions['1.0.4']).toBeDefined();\n          expect(data[DIST_TAGS]['latest']).toBeDefined();\n          expect(data[DIST_TAGS]['latest']).toBe('1.0.1');\n          expect(data[DIST_TAGS]['beta']).toBeDefined();\n          expect(data[DIST_TAGS]['beta']).toBe('1.0.2');\n          expect(data[DIST_TAGS]['next']).toBeDefined();\n          expect(data[DIST_TAGS]['next']).toBe('1.0.4');\n          expect(data['_rev'] === metadata['_rev']).toBeFalsy();\n          expect(data.readme).toBe('readme 1.0.4');\n          done();\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should not update if the metadata match","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::updateVersions"],"updatePoint":{"line":342,"column":51},"line":342,"code":"      test('should not update if the metadata match', (done) => {\n        _storage.updateVersions(pkgName, metadata, (e) => {\n          expect(e).toBeNull();\n          _storage.updateVersions(pkgName, metadata, (err) => {\n            expect(err).toBeNull();\n            expect(_storage._writePackage).toHaveBeenCalledTimes(1);\n            done();\n          });\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should unpublish a version","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::changePackage"],"updatePoint":{"line":357,"column":38},"line":357,"code":"      test('should unpublish a version', async () => {\n        await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n        await addNewVersion(pkgName, '1.0.1');\n        await addNewVersion(pkgName, '1.0.2');\n        await addNewVersion(pkgName, '1.0.3');\n        const metadata = JSON.parse(readMetadata('changePackage/metadata-change'));\n        const rev: string = metadata['_rev'];\n\n        return new Promise((resolve) => {\n          storage.changePackage(pkgName, metadata, rev, (err) => {\n            expect(err).toBeUndefined();\n            storage.getPackageMetadata(pkgName, (err, data) => {\n              expect(err).toBeNull();\n              expect(data.versions['1.0.1']).toBeDefined();\n              expect(data.versions['1.0.2']).toBeUndefined();\n              expect(data.versions['1.0.3']).toBeUndefined();\n              resolve(data);\n            });\n          });\n        });\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should add a new tarball","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::addTarball"],"updatePoint":{"line":382,"column":38},"line":382,"code":"        test('should add a new tarball', async () => {\n          await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n          const tarballData = JSON.parse(readMetadata('addTarball'));\n          const stream = storage.addTarball(pkgName, tarballName);\n          stream.end(Buffer.from(tarballData.data, 'base64'));\n          stream.done();\n          return new Promise((resolve, reject) => {\n            stream.on('error', (err) => {\n              reject(err);\n            });\n            stream.on('success', function () {\n              resolve(true);\n            });\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails on add a duplicated new tarball","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::addTarball"],"updatePoint":{"line":398,"column":58},"line":398,"code":"        test('should fails on add a duplicated new tarball', async () => {\n          const tarballData = JSON.parse(readMetadata('addTarball'));\n          await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n          await addNewVersion(pkgName, '9.0.0');\n          const tarballName = `${pkgName}-9.0.0.tgz`;\n          await addTarballToStore(pkgName, tarballName);\n          const stream = storage.addTarball(pkgName, tarballName);\n          stream.end(Buffer.from(tarballData.data, 'base64'));\n          stream.done();\n          return new Promise((resolve, reject) => {\n            stream.on('error', (err: VerdaccioError) => {\n              expect(err).not.toBeNull();\n              expect(err.statusCode).toEqual(HTTP_STATUS.CONFLICT);\n              expect(err.message).toMatch(/this package is already present/);\n              resolve(true);\n            });\n            stream.on('succes', (err) => {\n              reject(err);\n            });\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails on add a new tarball on missing package","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::addTarball"],"updatePoint":{"line":420,"column":66},"line":420,"code":"        test('should fails on add a new tarball on missing package', async () => {\n          const tarballData = JSON.parse(readMetadata('addTarball'));\n          const stream = storage.addTarball('unexsiting-package', tarballName);\n          stream.end(Buffer.from(tarballData.data, 'base64'));\n          stream.done();\n          return new Promise((resolve) => {\n            stream.on('error', (err: VerdaccioError) => {\n              expect(err).not.toBeNull();\n              expect(err.statusCode).toEqual(HTTP_STATUS.NOT_FOUND);\n              expect(err.message).toMatch(/no such package available/);\n              resolve(true);\n            });\n\n            stream.on('success', () => {\n              resolve(true);\n            });\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails on use invalid content-legnth on add a new tarball","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::addTarball"],"updatePoint":{"line":439,"column":77},"line":439,"code":"        test('should fails on use invalid content-legnth on add a new tarball', async () => {\n          // FIXME: there is a race condition here that and slow down the test\n          // might be the related with stream.done(); call.\n          const pkgName = 'pkg-name';\n          await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n          await addNewVersion(pkgName, '9.0.0');\n          const stream = storage.addTarball(pkgName, `${pkgName}-9.0.0.tgz`);\n\n          return new Promise((resolve) => {\n            stream.on('error', function (err: VerdaccioError) {\n              expect(err).not.toBeNull();\n              expect(err.statusCode).toEqual(HTTP_STATUS.BAD_DATA);\n              expect(err.message).toMatch(/refusing to accept zero-length file/);\n              resolve(true);\n            });\n            // to make this fail we avoid feed the stream\n            stream.done();\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails forbidden name on add tarball","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::addTarball"],"updatePoint":{"line":459,"column":56},"line":459,"code":"        test('should fails forbidden name on add tarball', async () => {\n          const pkgName = PROTO_NAME;\n          await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n          await addNewVersion(pkgName, '9.0.0');\n          const stream = storage.addTarball(pkgName, `${pkgName}-9.0.0.tgz`);\n          return new Promise((resolve) => {\n            stream.on('error', function (err: VerdaccioError) {\n              expect(err).not.toBeNull();\n              expect(err.statusCode).toEqual(HTTP_STATUS.FORBIDDEN);\n              resolve(true);\n            });\n            stream.done();\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails on update data afer add version","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::addTarball"],"line":474,"code":"        test.todo('should fails on update data afer add version');","file":"local-storage.spec.ts","skipped":true,"dir":"packages/store/test"},{"name":"should fails on abort on add a new tarball","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::addTarball"],"line":477,"code":"        test.skip('should fails on abort on add a new tarball', (done) => {","file":"local-storage.spec.ts","skipped":true,"dir":"packages/store/test"},{"name":"should remove a tarball","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","removeTarball"],"updatePoint":{"line":492,"column":37},"line":492,"code":"        test('should remove a tarball', async () => {\n          const pkgName = `remove-tarball-package`;\n          const tarballName = `${pkgName}-9.0.1.tgz`;\n          await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n          await addNewVersion(pkgName, '9.0.1');\n          await addTarballToStore(pkgName, tarballName);\n          return new Promise((resolve) => {\n            storage.removeTarball(pkgName, tarballName, 'rev', (err) => {\n              expect(err).toBeNull();\n              resolve(true);\n            });\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should remove a tarball that does not exist","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","removeTarball"],"updatePoint":{"line":506,"column":57},"line":506,"code":"        test('should remove a tarball that does not exist', async () => {\n          const pkgName = `remove-tarball-package-does-not-exist`;\n          await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n          await addNewVersion(pkgName, '9.0.1');\n          return new Promise((resolve) => {\n            storage.removeTarball(pkgName, tarballName2, 'rev', (err) => {\n              expect(err).not.toBeNull();\n              expect(err.statusCode).toEqual(HTTP_STATUS.NOT_FOUND);\n              expect(err.message).toMatch(/no such file available/);\n              resolve(true);\n            });\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get a existing tarball","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::getTarball"],"updatePoint":{"line":522,"column":43},"line":522,"code":"        test('should get a existing tarball', async () => {\n          const pkgName = `existing-package`;\n          await addPackageToStore(pkgName, generatePackageTemplate(pkgName));\n          await addNewVersion(pkgName, '9.0.1');\n          await addTarballToStore(pkgName, `package-9.0.0.tgz`);\n          const stream = storage.getTarball(pkgName, `package-9.0.0.tgz`);\n          return new Promise((resolve, reject) => {\n            stream.on('content-length', function (contentLength) {\n              expect(contentLength).toBe(279);\n              resolve(true);\n            });\n            stream.on('error', function (err) {\n              reject(err);\n            });\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails on get a tarball that does not exist","suites":["LocalStorage","LocalStorage::preparePackage","LocalStorage::tarball operations","LocalStorage::getTarball"],"updatePoint":{"line":539,"column":63},"line":539,"code":"        test('should fails on get a tarball that does not exist', (done) => {\n          const stream = storage.getTarball('fake', tarballName);\n          stream.on('error', function (err: VerdaccioError) {\n            expect(err).not.toBeNull();\n            expect(err.statusCode).toEqual(HTTP_STATUS.NOT_FOUND);\n            expect(err.message).toMatch(/no such file available/);\n            done();\n          });\n        });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should remove completely package","suites":["LocalStorage","LocalStorage::preparePackage","removePackage"],"updatePoint":{"line":552,"column":44},"line":552,"code":"      test('should remove completely package', async () => {\n        const pkgNameScoped = `non-scoped-package`;\n        await addPackageToStore(pkgNameScoped, generatePackageTemplate(pkgNameScoped));\n        await addNewVersion(pkgNameScoped, '9.0.0');\n        await addNewVersion(pkgNameScoped, '9.0.1');\n        await addTarballToStore(pkgNameScoped, `package-9.0.0.tgz`);\n        await addTarballToStore(pkgNameScoped, `package-9.0.1.tgz`);\n        await storage.removePackage(pkgNameScoped);\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should remove completely @scoped package","suites":["LocalStorage","LocalStorage::preparePackage","removePackage"],"updatePoint":{"line":562,"column":52},"line":562,"code":"      test('should remove completely @scoped package', async () => {\n        const pkgNameScoped = `@remove/package`;\n        await addPackageToStore(pkgNameScoped, generatePackageTemplate(pkgNameScoped));\n        await addNewVersion(pkgNameScoped, '9.0.0');\n        await addNewVersion(pkgNameScoped, '9.0.1');\n        await addTarballToStore(pkgNameScoped, `package-9.0.0.tgz`);\n        await addTarballToStore(pkgNameScoped, `package-9.0.1.tgz`);\n        await storage.removePackage(pkgNameScoped);\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails with package not found","suites":["LocalStorage","LocalStorage::preparePackage","removePackage"],"updatePoint":{"line":572,"column":47},"line":572,"code":"      test('should fails with package not found', async () => {\n        const pkgName = 'npm_test_fake';\n        await expect(storage.removePackage(pkgName)).rejects.toThrow(API_ERROR.NO_PACKAGE);\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should fails with @scoped package not found","suites":["LocalStorage","LocalStorage::preparePackage","removePackage"],"updatePoint":{"line":577,"column":55},"line":577,"code":"      test('should fails with @scoped package not found', async () => {\n        const pkgNameScoped = `@remove/package`;\n        await expect(storage.removePackage(pkgNameScoped)).rejects.toThrow(API_ERROR.NO_PACKAGE);\n      });","file":"local-storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"remove duplicates","suites":["search","search manager utils"],"updatePoint":{"line":14,"column":27},"line":14,"code":"    test('remove duplicates', () => {\n      const item: searchUtils.SearchPackageItem = {\n        // @ts-expect-error\n        package: {\n          name: 'foo',\n        },\n        ['dist-tags']: {\n          latest: '1.0.0',\n        },\n        // @ts-expect-error\n        score: {},\n        searchScore: 0.4,\n      };\n\n      expect(removeDuplicates([item, item])).toEqual([item]);\n    });","file":"search.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"search items","suites":["search","search manager utils"],"updatePoint":{"line":31,"column":22},"line":31,"code":"    test('search items', async () => {\n      const { MockAgent } = require('undici');\n      // FIXME: fetch is already part of undici\n      const domain = 'http://localhost:4873';\n      const url = '/-/v1/search?maintenance=1&popularity=1&quality=1&size=10&text=verdaccio';\n      const response = require('./fixtures/search.json');\n      const options = {\n        path: url,\n        method: 'GET',\n      };\n      const mockAgent = new MockAgent({ connections: 1 });\n      mockAgent.disableNetConnect();\n      setGlobalDispatcher(mockAgent);\n      const mockClient = mockAgent.get(domain);\n      mockClient.intercept(options).reply(200, JSON.stringify(response));\n      const config = new Config(configExample());\n      const storage = new Storage(config);\n      await storage.init(config);\n\n      // @ts-expect-error\n      const results = await storage.searchManager.search({ url, query: { text: 'foo' } });\n      expect(results).toHaveLength(4);\n    });","file":"search.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"normalizePackage clean","suites":["Storage Utils","normalizePackage"],"updatePoint":{"line":18,"column":32},"line":18,"code":"    test('normalizePackage clean', () => {\n      const pkg = normalizePackage({\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        name: '',\n        versions: {},\n        [DIST_TAGS]: {},\n      });\n      expect(pkg).toBeDefined();\n      expect(pkg.time).toBeInstanceOf(Object);\n      expect(pkg.versions).toBeInstanceOf(Object);\n      expect(pkg[DIST_TAGS]).toBeInstanceOf(Object);\n      expect(pkg._distfiles).toBeInstanceOf(Object);\n      expect(pkg._attachments).toBeInstanceOf(Object);\n      expect(pkg._uplinks).toBeInstanceOf(Object);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"normalizePackage partial metadata","suites":["Storage Utils","normalizePackage"],"updatePoint":{"line":37,"column":43},"line":37,"code":"    test('normalizePackage partial metadata', () => {\n      // @ts-ignore\n      const pkg = normalizePackage(readFile('metadata'));\n      expect(pkg).toBeDefined();\n      expect(pkg.time).toBeInstanceOf(Object);\n      expect(pkg.versions).toBeInstanceOf(Object);\n      expect(pkg[DIST_TAGS]).toBeInstanceOf(Object);\n      expect(pkg._distfiles).toBeInstanceOf(Object);\n      expect(pkg._attachments).toBeInstanceOf(Object);\n      expect(pkg._uplinks).toBeInstanceOf(Object);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"normalizePackage partial default revision","suites":["Storage Utils","normalizePackage"],"updatePoint":{"line":49,"column":51},"line":49,"code":"    test('normalizePackage partial default revision', () => {\n      // @ts-ignore\n      const pkg = normalizePackage(readFile('metadata'));\n      expect(pkg).toBeDefined();\n      expect(pkg._rev).toBeDefined();\n      expect(pkg._rev).toBe(STORAGE.DEFAULT_REVISION);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"mergeTime basic","suites":["Storage Utils","mergeTime"],"updatePoint":{"line":68,"column":25},"line":68,"code":"    test('mergeTime basic', () => {\n      const pkg1: Package = {\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        time: {\n          modified: '2018-06-13T06:44:45.747Z',\n          created: '2018-06-07T05:50:21.505Z',\n          ...vGroup1,\n        },\n        name: '',\n        versions: {},\n        [DIST_TAGS]: {},\n      };\n\n      const pkg2: Package = {\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        name: '',\n        time: {\n          modified: '2019-06-13T06:44:45.747Z',\n          created: '2019-06-07T05:50:21.505Z',\n          ...vGroup2,\n        },\n        versions: {},\n        [DIST_TAGS]: {},\n      };\n\n      const mergedPkg = mergeUplinkTimeIntoLocal(pkg1, pkg2);\n      expect(Object.keys(mergedPkg)).toEqual([\n        'modified',\n        'created',\n        ...Object.keys(vGroup1),\n        ...Object.keys(vGroup2),\n      ]);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"mergeTime remote empty","suites":["Storage Utils","mergeTime"],"updatePoint":{"line":108,"column":32},"line":108,"code":"    test('mergeTime remote empty', () => {\n      const pkg1: Package = {\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        name: '',\n        time: {\n          modified: '2018-06-13T06:44:45.747Z',\n          created: '2018-06-07T05:50:21.505Z',\n          ...vGroup1,\n        },\n        versions: {},\n        [DIST_TAGS]: {},\n      };\n\n      const pkg2: Package = {\n        _attachments: {},\n        _distfiles: {},\n        _rev: '',\n        _uplinks: {},\n        name: '',\n        versions: {},\n        [DIST_TAGS]: {},\n      };\n      const mergedPkg = mergeUplinkTimeIntoLocal(pkg1, pkg2);\n      expect(Object.keys(mergedPkg)).toEqual(['modified', 'created', ...Object.keys(vGroup1)]);\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"add new one","suites":["Storage Utils","tagVersion"],"updatePoint":{"line":139,"column":21},"line":139,"code":"    test('add new one', () => {\n      let pkg = {\n        versions: {},\n        'dist-tags': {},\n      };\n\n      // @ts-ignore\n      assert(tagVersion(pkg, '1.1.1', 'foo', {}));\n      assert.deepEqual(pkg, {\n        versions: {},\n        'dist-tags': { foo: '1.1.1' },\n      });\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"add (compat)","suites":["Storage Utils","tagVersion"],"updatePoint":{"line":153,"column":22},"line":153,"code":"    test('add (compat)', () => {\n      const x = {\n        versions: {},\n        'dist-tags': { foo: '1.1.0' },\n      };\n\n      // @ts-ignore\n      assert(tagVersion(x, '1.1.1', 'foo'));\n      assert.deepEqual(x, {\n        versions: {},\n        'dist-tags': { foo: '1.1.1' },\n      });\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"add fresh tag","suites":["Storage Utils","tagVersion"],"updatePoint":{"line":167,"column":23},"line":167,"code":"    test('add fresh tag', () => {\n      let x = {\n        versions: {},\n        'dist-tags': { foo: '1.1.0' },\n      };\n\n      // @ts-ignore\n      assert(tagVersion(x, '1.1.1', 'foo'));\n      assert.deepEqual(x, {\n        versions: {},\n        'dist-tags': { foo: '1.1.1' },\n      });\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"isDifferentThanOne is true","suites":["Storage Utils","isDifferentThanOne"],"updatePoint":{"line":183,"column":36},"line":183,"code":"    test('isDifferentThanOne is true', () => {\n      expect(isDifferentThanOne({})).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"isDifferentThanOne is false","suites":["Storage Utils","isDifferentThanOne"],"updatePoint":{"line":186,"column":37},"line":186,"code":"    test('isDifferentThanOne is false', () => {\n      expect(\n        isDifferentThanOne({\n          foo: 'bar',\n        })\n      ).toBeFalsy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"isDifferentThanOne with two items is true","suites":["Storage Utils","isDifferentThanOne"],"updatePoint":{"line":193,"column":51},"line":193,"code":"    test('isDifferentThanOne with two items is true', () => {\n      expect(\n        isDifferentThanOne({\n          foo: 'bar',\n          foo1: 'bar',\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be valid","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":204,"column":25},"line":204,"code":"    test('should be valid', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {\n            'forbidden-place-1.0.6.tgz': {\n              content_type: 'application/octet-stream',\n              data: 'foo',\n              length: 512,\n            },\n          },\n          versions: {\n            // @ts-expect-error\n            '1.0.0': {},\n          },\n        })\n      ).toBeFalsy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be invalid due missing versions","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":222,"column":48},"line":222,"code":"    test('should be invalid due missing versions', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {},\n          versions: {},\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be invalid due missing _attachments","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":231,"column":52},"line":231,"code":"    test('should be invalid due missing _attachments', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {},\n          versions: {},\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be invalid due invalid empty versions  object","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":240,"column":62},"line":240,"code":"    test('should be invalid due invalid empty versions  object', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {\n            'forbidden-place-1.0.6.tgz': {\n              content_type: 'application/octet-stream',\n              data: 'foo',\n              length: 512,\n            },\n          },\n          versions: {},\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should be invalid due empty _attachments object","suites":["Storage Utils","hasInvalidPublishBody"],"updatePoint":{"line":255,"column":57},"line":255,"code":"    test('should be invalid due empty _attachments object', () => {\n      expect(\n        hasInvalidPublishBody({\n          _attachments: {},\n          versions: {\n            // @ts-expect-error\n            '1.0.0': {},\n            // @ts-expect-error\n            '1.0.1': {},\n          },\n        })\n      ).toBeTruthy();\n    });","file":"storage-utils.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"add package item","suites":["storage","add packages"],"updatePoint":{"line":25,"column":26},"line":25,"code":"    test('add package item', async () => {\n      nock(domain).get('/foo').reply(404);\n      const config = new Config(\n        configExample({\n          storage: generateRamdonStorage(),\n        })\n      );\n      const storage = new Storage(config);\n      await storage.init(config);\n\n      await storage.addPackage('foo', fooManifest, (err) => {\n        expect(err).toBeNull();\n      });\n    });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 201 and merge from uplink","suites":["storage","get packages getPackageNext()","with uplinks"],"updatePoint":{"line":44,"column":48},"line":44,"code":"      test('should get 201 and merge from uplink', async () => {\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            storage: generateRamdonStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo',\n            uplinksLook: true,\n            req,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host'),\n            },\n          })\n        ).resolves.toEqual(expect.objectContaining({ name: 'foo' }));\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 201 and merge from uplink with version","suites":["storage","get packages getPackageNext()","with uplinks"],"updatePoint":{"line":76,"column":61},"line":76,"code":"      test('should get 201 and merge from uplink with version', async () => {\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            storage: generateRamdonStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo',\n            version: '1.0.0',\n            uplinksLook: true,\n            req,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host'),\n            },\n          })\n        ).resolves.toEqual(expect.objectContaining({ name: 'foo' }));\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 201 and merge from uplink with dist-tag","suites":["storage","get packages getPackageNext()","with uplinks"],"updatePoint":{"line":109,"column":62},"line":109,"code":"      test('should get 201 and merge from uplink with dist-tag', async () => {\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            storage: generateRamdonStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo',\n            version: 'latest',\n            uplinksLook: true,\n            req,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host'),\n            },\n          })\n        ).resolves.toEqual(expect.objectContaining({ name: 'foo' }));\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 404 for version does not exist","suites":["storage","get packages getPackageNext()","with uplinks"],"updatePoint":{"line":142,"column":53},"line":142,"code":"      test('should get 404 for version does not exist', async () => {\n        nock(domain).get('/foo').reply(201, fooManifest);\n        const config = new Config(\n          configExample({\n            storage: generateRamdonStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo',\n            version: '1.0.0-does-not-exist',\n            uplinksLook: true,\n            req,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host'),\n            },\n          })\n        ).rejects.toThrow(\n          errorUtils.getNotFound(\"this version doesn't exist: 1.0.0-does-not-exist\")\n        );\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get 404","suites":["storage","get packages getPackageNext()","with uplinks"],"updatePoint":{"line":177,"column":26},"line":177,"code":"      test('should get 404', async () => {\n        nock(domain).get('/foo2').reply(404);\n        const config = new Config(\n          configExample({\n            storage: generateRamdonStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo2',\n            uplinksLook: true,\n            req,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host'),\n            },\n          })\n        ).rejects.toThrow(errorUtils.getNotFound());\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"should get ETIMEDOUT with uplink","suites":["storage","get packages getPackageNext()","with uplinks"],"updatePoint":{"line":209,"column":44},"line":209,"code":"      test('should get ETIMEDOUT with uplink', async () => {\n        nock(domain).get('/foo2').replyWithError({\n          code: 'ETIMEDOUT',\n          errno: 'ETIMEDOUT',\n        });\n        const config = new Config(\n          configExample({\n            storage: generateRamdonStorage(),\n          })\n        );\n        const req = httpMocks.createRequest({\n          method: 'GET',\n          connection: { remoteAddress: fakeHost },\n          headers: {\n            host: fakeHost,\n            [HEADERS.FORWARDED_PROTO]: 'http',\n          },\n          url: '/',\n        });\n        const storage = new Storage(config);\n        await storage.init(config);\n        await expect(\n          storage.getPackageByOptions({\n            name: 'foo2',\n            uplinksLook: true,\n            req,\n            requestOptions: {\n              headers: req.headers as any,\n              protocol: req.protocol,\n              host: req.get('host'),\n            },\n          })\n        ).rejects.toThrow(errorUtils.getServiceUnavailable());\n      });","file":"storage.spec.ts","skipped":false,"dir":"packages/store/test"},{"name":"PromiseAssert","suites":["Request Functional","Request Functional"],"updatePoint":{"line":17,"column":23},"line":17,"code":"    test('PromiseAssert', () => {\n      expect(_.isFunction(smartRequest)).toBeTruthy();\n    });","file":"request.spec.ts","skipped":false,"dir":"packages/tools/mock/test"},{"name":"basic resolve","suites":["Request Functional","Request Functional"],"updatePoint":{"line":21,"column":23},"line":21,"code":"    test('basic resolve', (done) => {\n      const requestPromise: IRequestPromise = new PromiseAssert((resolve) => {\n        resolve(1);\n      });\n      // @ts-ignore\n      requestPromise.then((result) => {\n        expect(result).toBe(1);\n        done();\n      });\n    });","file":"request.spec.ts","skipped":false,"dir":"packages/tools/mock/test"},{"name":"basic rest","suites":["Request Functional","smartRequest Rest"],"updatePoint":{"line":47,"column":20},"line":47,"code":"    test('basic rest', (done) => {\n      const options: any = {\n        url: restTest,\n        method: 'GET',\n      };\n\n      smartRequest(options).then((result) => {\n        expect(_.isString(result)).toBeTruthy();\n        done();\n      });\n    });","file":"request.spec.ts","skipped":false,"dir":"packages/tools/mock/test"},{"name":"basic check status 200","suites":["Request Functional","smartRequest Rest","smartRequest Status"],"updatePoint":{"line":60,"column":34},"line":60,"code":"      test('basic check status 200', (done) => {\n        const options: any = {\n          url: restTest,\n          method: 'GET',\n        };\n        // @ts-ignore\n        smartRequest(options)\n          .status(HTTP_STATUS.OK)\n          .then((result) => {\n            expect(JSON.parse(result).name).toBe('jquery');\n            done();\n          });\n      });","file":"request.spec.ts","skipped":false,"dir":"packages/tools/mock/test"},{"name":"basic ping status and empty response","suites":["Request Functional","smartRequest Rest","smartRequest Status"],"updatePoint":{"line":74,"column":48},"line":74,"code":"      test('basic ping status and empty response', (done) => {\n        const options: any = {\n          url: `${domainTest}/-/ping`,\n          method: 'GET',\n        };\n        // @ts-ignore\n        smartRequest(options)\n          .status(HTTP_STATUS.OK)\n          .then((result) => {\n            expect(JSON.parse(result)).toEqual({});\n            done();\n          });\n      });","file":"request.spec.ts","skipped":false,"dir":"packages/tools/mock/test"},{"name":"basic check status 404","suites":["Request Functional","smartRequest Rest","smartRequest Status"],"updatePoint":{"line":88,"column":34},"line":88,"code":"      test('basic check status 404', (done) => {\n        const options: any = {\n          url: 'http://www.google.fake',\n          method: 'GET',\n        };\n        // @ts-ignore\n        smartRequest(options)\n          .status(HTTP_STATUS.NOT_FOUND)\n          .then(\n            () => {\n              // we do not intent to resolve this\n            },\n            (error: VerdaccioError) => {\n              expect(error.code).toBe('ENOTFOUND');\n              done();\n            }\n          );\n      });","file":"request.spec.ts","skipped":false,"dir":"packages/tools/mock/test"},{"name":"should validate password according the length","suites":["Auth Utilities","validatePassword"],"updatePoint":{"line":5,"column":55},"line":5,"code":"    test('should validate password according the length', () => {\n      expect(validatePassword('12345', 1)).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should fails on validate password according the length","suites":["Auth Utilities","validatePassword"],"updatePoint":{"line":9,"column":64},"line":9,"code":"    test('should fails on validate password according the length', () => {\n      expect(validatePassword('12345', 10)).toBeFalsy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should fails on validate password according the length and default config","suites":["Auth Utilities","validatePassword"],"updatePoint":{"line":13,"column":83},"line":13,"code":"    test('should fails on validate password according the length and default config', () => {\n      expect(validatePassword('12')).toBeFalsy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should validate password according the length and default config","suites":["Auth Utilities","validatePassword"],"updatePoint":{"line":17,"column":74},"line":17,"code":"    test('should validate password according the length and default config', () => {\n      expect(validatePassword('1235678910')).toBeTruthy();\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should generate session token","suites":["Auth Utilities","createSessionToken"],"updatePoint":{"line":23,"column":39},"line":23,"code":"    test('should generate session token', () => {\n      expect(createSessionToken()).toHaveProperty('expires');\n      expect(createSessionToken().expires).toBeInstanceOf(Date);\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should generate user message token","suites":["Auth Utilities","getAuthenticatedMessage"],"updatePoint":{"line":30,"column":44},"line":30,"code":"    test('should generate user message token', () => {\n      expect(getAuthenticatedMessage('foo')).toEqual(\"you are authenticated as 'foo'\");\n    });","file":"auth-utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should test basic config","suites":["getMatchedPackagesSpec"],"updatePoint":{"line":4,"column":32},"line":4,"code":"  test('should test basic config', () => {\n    const packages = {\n      react: {\n        access: 'admin',\n        publish: 'admin',\n        proxy: 'facebook',\n      },\n      angular: {\n        access: 'admin',\n        publish: 'admin',\n        proxy: 'google',\n      },\n      '@*/*': {\n        access: '$all',\n        publish: '$authenticated',\n        proxy: 'npmjs',\n      },\n      '**': {\n        access: '$all',\n        publish: '$authenticated',\n        proxy: 'npmjs',\n      },\n    };\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('react', packages).proxy).toMatch('facebook');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('angular', packages).proxy).toMatch('google');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('vue', packages).proxy).toMatch('npmjs');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('@scope/vue', packages).proxy).toMatch('npmjs');\n  });","file":"matcher.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should test no ** wildcard on config","suites":["getMatchedPackagesSpec"],"updatePoint":{"line":37,"column":44},"line":37,"code":"  test('should test no ** wildcard on config', () => {\n    const packages = {\n      react: {\n        access: 'admin',\n        publish: 'admin',\n        proxy: 'facebook',\n      },\n      angular: {\n        access: 'admin',\n        publish: 'admin',\n        proxy: 'google',\n      },\n      '@fake/*': {\n        access: '$all',\n        publish: '$authenticated',\n        proxy: 'npmjs',\n      },\n    };\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('react', packages).proxy).toMatch('facebook');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('angular', packages).proxy).toMatch('google');\n    // @ts-expect-error\n    expect(getMatchedPackagesSpec('@fake/angular', packages).proxy).toMatch('npmjs');\n    expect(getMatchedPackagesSpec('vue', packages)).toBeUndefined();\n    expect(getMatchedPackagesSpec('@scope/vue', packages)).toBeUndefined();\n  });","file":"matcher.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should delete a invalid latest version","suites":["Utilities","API utilities","normalizeDistTags"],"updatePoint":{"line":33,"column":50},"line":33,"code":"      test('should delete a invalid latest version', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          latest: '20000',\n        };\n\n        normalizeDistTags(pkg);\n\n        expect(Object.keys(pkg[DIST_TAGS])).toHaveLength(0);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should define last published version as latest","suites":["Utilities","API utilities","normalizeDistTags"],"updatePoint":{"line":44,"column":58},"line":44,"code":"      test('should define last published version as latest', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {};\n\n        normalizeDistTags(pkg);\n\n        expect(pkg[DIST_TAGS]).toEqual({ latest: '1.0.1' });\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should define last published version as latest with a custom dist-tag","suites":["Utilities","API utilities","normalizeDistTags"],"updatePoint":{"line":53,"column":81},"line":53,"code":"      test('should define last published version as latest with a custom dist-tag', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          beta: '1.0.1',\n        };\n\n        normalizeDistTags(pkg);\n\n        expect(pkg[DIST_TAGS]).toEqual({ beta: '1.0.1', latest: '1.0.1' });\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should convert any array of dist-tags to a plain string","suites":["Utilities","API utilities","normalizeDistTags"],"updatePoint":{"line":64,"column":67},"line":64,"code":"      test('should convert any array of dist-tags to a plain string', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          latest: ['1.0.1'],\n        };\n\n        normalizeDistTags(pkg);\n\n        expect(pkg[DIST_TAGS]).toEqual({ latest: '1.0.1' });\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should fills an empty metadata object","suites":["Utilities","API utilities","validateMetadata"],"updatePoint":{"line":77,"column":49},"line":77,"code":"      test('should fills an empty metadata object', () => {\n        // intended to fail with flow, do not remove\n        // @ts-ignore\n        expect(Object.keys(validateMetadata({}))).toContain(DIST_TAGS);\n        // @ts-ignore\n        expect(Object.keys(validateMetadata({}))).toContain('versions');\n        // @ts-ignore\n        expect(Object.keys(validateMetadata({}))).toContain('time');\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should fails the assertions is not an object","suites":["Utilities","API utilities","validateMetadata"],"updatePoint":{"line":87,"column":56},"line":87,"code":"      test('should fails the assertions is not an object', () => {\n        expect(function () {\n          // @ts-ignore\n          validateMetadata('');\n          // @ts-ignore\n        }).toThrow(expect.hasAssertions());\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should fails the assertions is name does not match","suites":["Utilities","API utilities","validateMetadata"],"updatePoint":{"line":95,"column":62},"line":95,"code":"      test('should fails the assertions is name does not match', () => {\n        expect(function () {\n          // @ts-ignore\n          validateMetadata({}, 'no-name');\n          // @ts-ignore\n        }).toThrow(expect.hasAssertions());\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should check author field different values","suites":["Utilities","API utilities","formatAuthor"],"updatePoint":{"line":105,"column":54},"line":105,"code":"      test('should check author field different values', () => {\n        const author = 'verdaccioNpm';\n        expect(formatAuthor(author).name).toEqual(author);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should check author field for object value","suites":["Utilities","API utilities","formatAuthor"],"updatePoint":{"line":109,"column":54},"line":109,"code":"      test('should check author field for object value', () => {\n        const user = {\n          name: 'Verdaccion NPM',\n          email: 'verdaccio@verdaccio.org',\n          url: 'https://verdaccio.org',\n        };\n        expect(formatAuthor(user).url).toEqual(user.url);\n        expect(formatAuthor(user).email).toEqual(user.email);\n        expect(formatAuthor(user).name).toEqual(user.name);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should check author field for other value","suites":["Utilities","API utilities","formatAuthor"],"updatePoint":{"line":119,"column":53},"line":119,"code":"      test('should check author field for other value', () => {\n        expect(formatAuthor(null).name).toEqual(DEFAULT_USER);\n        expect(formatAuthor({}).name).toEqual(DEFAULT_USER);\n        expect(formatAuthor([]).name).toEqual(DEFAULT_USER);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should generate gravatar url with email","suites":["Utilities","API utilities","User utilities"],"updatePoint":{"line":127,"column":51},"line":127,"code":"      test('should generate gravatar url with email', () => {\n        const gravatarUrl: string = generateGravatarUrl('user@verdaccio.org');\n\n        expect(gravatarUrl).toMatch('https://www.gravatar.com/avatar/');\n        expect(gravatarUrl).not.toMatch('000000000');\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should generate generic gravatar url","suites":["Utilities","API utilities","User utilities"],"updatePoint":{"line":134,"column":48},"line":134,"code":"      test('should generate generic gravatar url', () => {\n        const gravatarUrl: string = generateGravatarUrl();\n\n        expect(gravatarUrl).toMatch(GENERIC_AVATAR);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"check for blank object","suites":["Utilities","API utilities","addGravatarSupport"],"updatePoint":{"line":142,"column":34},"line":142,"code":"      test('check for blank object', () => {\n        // @ts-ignore\n        expect(addGravatarSupport({})).toEqual({});\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"author, contributors and maintainers fields are not present","suites":["Utilities","API utilities","addGravatarSupport"],"updatePoint":{"line":147,"column":71},"line":147,"code":"      test('author, contributors and maintainers fields are not present', () => {\n        const packageInfo = {\n          latest: {},\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(packageInfo);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"author field is a blank object","suites":["Utilities","API utilities","addGravatarSupport"],"updatePoint":{"line":156,"column":42},"line":156,"code":"      test('author field is a blank object', () => {\n        const packageInfo = { latest: { author: {} } };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(packageInfo);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"author field is a string type","suites":["Utilities","API utilities","addGravatarSupport"],"updatePoint":{"line":163,"column":41},"line":163,"code":"      test('author field is a string type', () => {\n        const packageInfo = {\n          latest: { author: 'user@verdccio.org' },\n        };\n        const result = {\n          latest: {\n            author: {\n              author: 'user@verdccio.org',\n              avatar: GENERIC_AVATAR,\n              email: '',\n            },\n          },\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(result);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"author field is an object type with author information","suites":["Utilities","API utilities","addGravatarSupport"],"updatePoint":{"line":181,"column":66},"line":181,"code":"      test('author field is an object type with author information', () => {\n        const packageInfo = {\n          latest: { author: { name: 'verdaccio', email: 'user@verdccio.org' } },\n        };\n        const result = {\n          latest: {\n            author: {\n              avatar: 'https://www.gravatar.com/avatar/794d7f6ef93d0689437de3c3e48fadc7',\n              email: 'user@verdccio.org',\n              name: 'verdaccio',\n            },\n          },\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(result);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"contributor field is a blank array","suites":["Utilities","API utilities","addGravatarSupport"],"updatePoint":{"line":199,"column":46},"line":199,"code":"      test('contributor field is a blank array', () => {\n        const packageInfo = {\n          latest: {\n            contributors: [],\n          },\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(packageInfo);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"contributors field has contributors","suites":["Utilities","API utilities","addGravatarSupport","contributors"],"updatePoint":{"line":211,"column":49},"line":211,"code":"        test('contributors field has contributors', () => {\n          const packageInfo = {\n            latest: {\n              contributors: [\n                { name: 'user', email: 'user@verdccio.org' },\n                { name: 'user1', email: 'user1@verdccio.org' },\n              ],\n            },\n          };\n\n          const result = {\n            latest: {\n              contributors: [\n                {\n                  avatar: 'https://www.gravatar.com/avatar/794d7f6ef93d0689437de3c3e48fadc7',\n                  email: 'user@verdccio.org',\n                  name: 'user',\n                },\n                {\n                  avatar: 'https://www.gravatar.com/avatar/51105a49ce4a9c2bfabf0f6a2cba3762',\n                  email: 'user1@verdccio.org',\n                  name: 'user1',\n                },\n              ],\n            },\n          };\n\n          // @ts-ignore\n          expect(addGravatarSupport(packageInfo)).toEqual(result);\n        });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"contributors field is an object","suites":["Utilities","API utilities","addGravatarSupport","contributors"],"updatePoint":{"line":242,"column":45},"line":242,"code":"        test('contributors field is an object', () => {\n          const packageInfo = {\n            latest: {\n              contributors: { name: 'user', email: 'user@verdccio.org' },\n            },\n          };\n\n          const result = {\n            latest: {\n              contributors: [\n                {\n                  avatar: 'https://www.gravatar.com/avatar/794d7f6ef93d0689437de3c3e48fadc7',\n                  email: 'user@verdccio.org',\n                  name: 'user',\n                },\n              ],\n            },\n          };\n\n          // @ts-ignore\n          expect(addGravatarSupport(packageInfo)).toEqual(result);\n        });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"contributors field is a string","suites":["Utilities","API utilities","addGravatarSupport","contributors"],"updatePoint":{"line":265,"column":44},"line":265,"code":"        test('contributors field is a string', () => {\n          const contributor = 'Barney Rubble <b@rubble.com> (http://barnyrubble.tumblr.com/)';\n          const packageInfo = {\n            latest: {\n              contributors: contributor,\n            },\n          };\n\n          const result = {\n            latest: {\n              contributors: [\n                {\n                  avatar: GENERIC_AVATAR,\n                  email: contributor,\n                  name: contributor,\n                },\n              ],\n            },\n          };\n\n          // @ts-ignore\n          expect(addGravatarSupport(packageInfo)).toEqual(result);\n        });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"maintainers field is a blank array","suites":["Utilities","API utilities","addGravatarSupport","contributors"],"updatePoint":{"line":290,"column":46},"line":290,"code":"      test('maintainers field is a blank array', () => {\n        const packageInfo = {\n          latest: {\n            maintainers: [],\n          },\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(packageInfo);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"maintainers field has maintainers","suites":["Utilities","API utilities","addGravatarSupport","contributors"],"updatePoint":{"line":301,"column":45},"line":301,"code":"      test('maintainers field has maintainers', () => {\n        const packageInfo = {\n          latest: {\n            maintainers: [\n              { name: 'user', email: 'user@verdccio.org' },\n              { name: 'user1', email: 'user1@verdccio.org' },\n            ],\n          },\n        };\n\n        const result = {\n          latest: {\n            maintainers: [\n              {\n                avatar: 'https://www.gravatar.com/avatar/794d7f6ef93d0689437de3c3e48fadc7',\n                email: 'user@verdccio.org',\n                name: 'user',\n              },\n              {\n                avatar: 'https://www.gravatar.com/avatar/51105a49ce4a9c2bfabf0f6a2cba3762',\n                email: 'user1@verdccio.org',\n                name: 'user1',\n              },\n            ],\n          },\n        };\n\n        // @ts-ignore\n        expect(addGravatarSupport(packageInfo)).toEqual(result);\n      });","file":"utils.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should get the right version","suites":["Utilities","getVersion"],"updatePoint":{"line":21,"column":38},"line":21,"code":"    test('should get the right version', () => {\n      expect(getVersion({ ...metadata } as any, '1.0.0')).toEqual({ dist: dist('1.0.0') });\n      expect(getVersion({ ...metadata } as any, 'v1.0.0')).toEqual({ dist: dist('1.0.0') });\n      expect(getVersion({ ...metadata } as any, 'v0.2.1-1')).toEqual({ dist: dist('0.2.1-1') });\n      expect(getVersion({ ...metadata } as any, '0.2.1-alpha')).toEqual({\n        dist: dist('0.2.1-alpha'),\n      });\n      expect(getVersion({ ...metadata } as any, '0.2.1-alpha.0')).toEqual({\n        dist: dist('0.2.1-alpha.0'),\n      });\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should return nothing on get non existing version","suites":["Utilities","getVersion"],"updatePoint":{"line":33,"column":59},"line":33,"code":"    test('should return nothing on get non existing version', () => {\n      expect(getVersion({ ...metadata } as any, '0')).toBeUndefined();\n      expect(getVersion({ ...metadata } as any, '2.0.0')).toBeUndefined();\n      expect(getVersion({ ...metadata } as any, 'v2.0.0')).toBeUndefined();\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should return nothing on get invalid versions","suites":["Utilities","getVersion"],"updatePoint":{"line":39,"column":55},"line":39,"code":"    test('should return nothing on get invalid versions', () => {\n      expect(getVersion({ ...metadata } as any, undefined)).toBeUndefined();\n      expect(getVersion({ ...metadata } as any, null)).toBeUndefined();\n      expect(getVersion({ ...metadata } as any, 8)).toBeUndefined();\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should handle no versions","suites":["Utilities","getVersion"],"updatePoint":{"line":45,"column":35},"line":45,"code":"    test('should handle no versions', () => {\n      expect(getVersion(undefined, undefined)).toBeUndefined();\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should sort versions","suites":["Utilities","semverSort"],"updatePoint":{"line":51,"column":30},"line":51,"code":"    test('should sort versions', () => {\n      expect(sortVersionsAndFilterInvalid(['1.0.0', '5.0.0', '2.0.0'])).toEqual([\n        '1.0.0',\n        '2.0.0',\n        '5.0.0',\n      ]);\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should sort versions and filter out invalid","suites":["Utilities","semverSort"],"updatePoint":{"line":58,"column":53},"line":58,"code":"    test('should sort versions and filter out invalid', () => {\n      expect(sortVersionsAndFilterInvalid(['1.0.0', '5.0.0', '2.0.0', '', null])).toEqual([\n        '1.0.0',\n        '2.0.0',\n        '5.0.0',\n      ]);\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should convert any array of dist-tags to a plain string","suites":["Utilities","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":81,"column":67},"line":81,"code":"      test('should convert any array of dist-tags to a plain string', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          latest: ['1.0.1'],\n        };\n\n        expect(normalizeDistTags(pkg)[DIST_TAGS]).toEqual({ latest: '1.0.1' });\n      });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should convert any empty array to empty list of dist-tags","suites":["Utilities","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":90,"column":69},"line":90,"code":"      test('should convert any empty array to empty list of dist-tags', () => {\n        const pkg = cloneMetadata();\n        pkg[DIST_TAGS] = {\n          latest: [],\n        };\n\n        expect(normalizeDistTags(pkg)[DIST_TAGS]).toEqual({});\n      });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should clean up a invalid latest version","suites":["Utilities","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":100,"column":50},"line":100,"code":"    test('should clean up a invalid latest version', () => {\n      const pkg = cloneMetadata();\n      pkg[DIST_TAGS] = {\n        latest: '20000',\n      };\n\n      expect(Object.keys(normalizeDistTags(pkg)[DIST_TAGS])).toHaveLength(0);\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should handle empty dis-tags and define last published version as latest","suites":["Utilities","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":109,"column":82},"line":109,"code":"    test('should handle empty dis-tags and define last published version as latest', () => {\n      const pkg = cloneMetadata();\n      pkg[DIST_TAGS] = {};\n\n      expect(normalizeDistTags(pkg)[DIST_TAGS]).toEqual({ latest: '1.0.1' });\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should define last published version as latest with a custom dist-tag","suites":["Utilities","normalizeDistTags","tag as arrays [deprecated]"],"updatePoint":{"line":116,"column":79},"line":116,"code":"    test('should define last published version as latest with a custom dist-tag', () => {\n      const pkg = cloneMetadata();\n      pkg[DIST_TAGS] = {\n        beta: '1.0.1',\n      };\n\n      expect(normalizeDistTags(pkg)[DIST_TAGS]).toEqual({ beta: '1.0.1', latest: '1.0.1' });\n    });","file":"versions.spec.ts","skipped":false,"dir":"packages/utils/test"},{"name":"should test add a new user with JWT enabled","suites":["endpoint example unit test"],"updatePoint":{"line":73,"column":51,"index":2687},"line":73,"code":"  test('should test add a new user with JWT enabled', async done => {\n    // At this point the server is running and you can run the test\n    const credentials = {\n      name: 'JotaJWT',\n      password: 'secretPass'\n    }; // 11. Use helpers for repetitive tasks\n    // @ts-ignore\n\n    const [err, res] = await addUser(request(app), credentials.name, credentials); // 12. test your output\n\n    expect(err).toBeNull();\n    expect(res.body.ok).toBeDefined();\n    expect(res.body.token).toBeDefined(); // 13. end the async test\n\n    done();\n  });","file":"unit/__helper/__template/api.__test.ts","skipped":false,"dir":"packages/verdaccio/test"},{"name":"should OK to package api","suites":["test web server"],"updatePoint":{"line":20,"column":32},"line":20,"code":"  test('should OK to package api', async () => {\n    mockManifest.mockReturnValue(() => ({\n      staticPath: path.join(__dirname, 'static'),\n      manifestFiles: {\n        js: ['runtime.js', 'vendors.js', 'main.js'],\n      },\n      manifest: require('./partials/manifest/manifest.json'),\n    }));\n    const response = await supertest(await initializeServer('default-test.yaml'))\n      .get('/-/verdaccio/data/packages')\n      .set('Accept', HEADERS.JSON_CHARSET)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.body).toEqual([]);\n  });","file":"api.packages.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fetch readme scoped package","suites":["readme api"],"updatePoint":{"line":32,"column":42},"line":32,"code":"  test('should fetch readme scoped package', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, '@scope/pk1-test', '1.0.0', { readme: 'my readme scoped' });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/package/readme/@scope/pk1-test')\n      .set('Accept', HEADERS.TEXT_PLAIN)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_PLAIN_UTF8)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch('my readme scoped');\n  });","file":"api.readme.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fetch readme scoped package with not found message","suites":["readme api"],"updatePoint":{"line":43,"column":65},"line":43,"code":"  test('should fetch readme scoped package with not found message', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, '@scope/pk1-test', '1.0.0', { readme: null });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/package/readme/@scope/pk1-test')\n      .set('Accept', HEADERS.TEXT_PLAIN)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_PLAIN_UTF8)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch(NOT_README_FOUND);\n  });","file":"api.readme.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fetch readme a package","suites":["readme api"],"updatePoint":{"line":54,"column":37},"line":54,"code":"  test('should fetch readme a package', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, 'pk1-test', '1.0.0', { readme: 'my readme' });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/package/readme/pk1-test')\n      .set('Accept', HEADERS.TEXT_PLAIN)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_PLAIN_UTF8)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch('my readme');\n  });","file":"api.readme.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fetch readme a package with not found message","suites":["readme api"],"updatePoint":{"line":65,"column":60},"line":65,"code":"  test('should fetch readme a package with not found message', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, 'pk1-test', '1.0.0', { readme: null });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/package/readme/pk1-test')\n      .set('Accept', HEADERS.TEXT_PLAIN)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_PLAIN_UTF8)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch(NOT_README_FOUND);\n  });","file":"api.readme.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should find results to search api","suites":["test web server"],"updatePoint":{"line":32,"column":41},"line":32,"code":"  test('should find results to search api', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, 'foo', '1.0.0');\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/search/foo')\n      .set('Accept', HEADERS.JSON_CHARSET)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.body).toHaveLength(1);\n    // FUTURE: we can improve here matching the right outcome\n  });","file":"api.search.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should found no results to search","suites":["test web server"],"updatePoint":{"line":44,"column":41},"line":44,"code":"  test('should found no results to search', async () => {\n    const response = await supertest(await initializeServer('default-test.yaml'))\n      .get('/-/verdaccio/data/search/notFound')\n      .set('Accept', HEADERS.JSON_CHARSET)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.body).toHaveLength(0);\n  });","file":"api.search.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should fail search api","suites":["test web server"],"line":54,"code":"  test.skip('should fail search api', async () => {","file":"api.search.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"search abort request","suites":["test web server"],"line":63,"code":"  test.todo('search abort request');","file":"api.search.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"search allow request permissions","suites":["test web server"],"line":65,"code":"  test.todo('search allow request permissions');","file":"api.search.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"search query params, pagination etc","suites":["test web server"],"line":66,"code":"  test.todo('search query params, pagination etc');","file":"api.search.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should display sidebar info scoped package","suites":["sidebar api"],"updatePoint":{"line":31,"column":50},"line":31,"code":"  test('should display sidebar info scoped package', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, '@scope/pk1-test', '1.0.0', { readme: 'my readme scoped' });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/sidebar/@scope/pk1-test')\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch('@scope/pk1-test');\n  });","file":"api.sidebar.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should display sidebar info package","suites":["sidebar api"],"updatePoint":{"line":41,"column":43},"line":41,"code":"  test('should display sidebar info package', async () => {\n    const app = await initializeServer('default-test.yaml');\n    await publishVersion(app, 'pk2-test', '1.0.0', { readme: 'my readme scoped' });\n    const response = await supertest(app)\n      .get('/-/verdaccio/data/sidebar/pk2-test')\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK);\n    expect(response.text).toMatch('pk2-test');\n  });","file":"api.sidebar.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should get 401","suites":["test web server"],"updatePoint":{"line":30,"column":22},"line":30,"code":"  test('should get 401', async () => {\n    return supertest(await initializeServer('default-test.yaml'))\n      .post('/-/verdaccio/sec/login')\n      .send(\n        JSON.stringify({\n          username: 'test',\n          password: 'password1',\n        })\n      )\n      .set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.UNAUTHORIZED)\n      .then((response) => {\n        expect(response.body.error).toEqual(API_ERROR.BAD_USERNAME_PASSWORD);\n      });\n  });","file":"api.user.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should log in","suites":["test web server"],"updatePoint":{"line":47,"column":21},"line":47,"code":"  test('should log in', async () => {\n    return supertest(await initializeServer('default-test.yaml'))\n      .post('/-/verdaccio/sec/login')\n      .send(\n        JSON.stringify({\n          username: 'test',\n          password: 'test',\n        })\n      )\n      .set(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON)\n      .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.JSON_CHARSET)\n      .expect(HTTP_STATUS.OK)\n      .then((res) => {\n        expect(res.body.error).toBeUndefined();\n        expect(res.body.token).toBeDefined();\n        expect(res.body.token).toBeTruthy();\n        expect(res.body.username).toMatch('test');\n      });\n  });","file":"api.user.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"log in should be disabled","suites":["test web server"],"line":67,"code":"  test.skip('log in should be disabled', async () => {","file":"api.user.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should change password","suites":["test web server"],"line":80,"code":"  test.todo('should change password');","file":"api.user.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should not change password if flag is disabled","suites":["test web server"],"line":81,"code":"  test.todo('should not change password if flag is disabled');","file":"api.user.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"getManifestValue","suites":["manifest"],"updatePoint":{"line":6,"column":24},"line":6,"code":"  test('getManifestValue', () => {\n    expect(getManifestValue(['main.js'], manifest)).toEqual([\n      '/-/static/main.6126058572f989c948b1.js',\n    ]);\n  });","file":"manifest.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should match render set ui properties","suites":["test web server","render","output"],"updatePoint":{"line":42,"column":49},"line":42,"code":"      test('should match render set ui properties', async () => {\n        const {\n          window: { __VERDACCIO_BASENAME_UI_OPTIONS },\n        } = await render('web.yaml');\n        expect(__VERDACCIO_BASENAME_UI_OPTIONS).toEqual(\n          expect.objectContaining({\n            showInfo: true,\n            showSettings: true,\n            showThemeSwitch: true,\n            showFooter: true,\n            showSearch: true,\n            showDownloadTarball: true,\n            darkMode: false,\n            url_prefix: '/prefix',\n            basename: '/prefix/',\n            primaryColor: '#ffffff',\n            // FIXME: mock these values, avoid random\n            // base: 'http://127.0.0.1:60864/prefix/',\n            // version: '6.0.0-6-next.28',\n            logoURI: '',\n            flags: { searchRemote: true },\n            login: true,\n            pkgManagers: ['pnpm', 'yarn'],\n            title: 'verdaccio web',\n            scope: '@scope',\n            language: 'es-US',\n          })\n        );\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"test default title","suites":["test web server","render","output"],"line":72,"code":"      test.todo('test default title');","file":"render.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"test need html cache","suites":["test web server","render","output"],"line":73,"code":"      test.todo('test need html cache');","file":"render.test.ts","skipped":true,"dir":"packages/web/test"},{"name":"should return the http status 200 for root","suites":["test web server","render","status"],"updatePoint":{"line":77,"column":54},"line":77,"code":"      test('should return the http status 200 for root', async () => {\n        return supertest(await initializeServer('default-test.yaml'))\n          .get('/')\n          .set('Accept', HEADERS.TEXT_HTML)\n          .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_HTML_UTF8)\n          .expect(HTTP_STATUS.OK);\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should return the body for a package detail page","suites":["test web server","render","status"],"updatePoint":{"line":85,"column":60},"line":85,"code":"      test('should return the body for a package detail page', async () => {\n        return supertest(await initializeServer('default-test.yaml'))\n          .get('/-/web/section/some-package')\n          .set('Accept', HEADERS.TEXT_HTML)\n          .expect(HEADER_TYPE.CONTENT_TYPE, HEADERS.TEXT_HTML_UTF8)\n          .expect(HTTP_STATUS.OK);\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should static file not found","suites":["test web server","render","status"],"updatePoint":{"line":93,"column":40},"line":93,"code":"      test('should static file not found', async () => {\n        return supertest(await initializeServer('default-test.yaml'))\n          .get('/-/static/not-found.js')\n          .set('Accept', HEADERS.TEXT_HTML)\n          .expect(HTTP_STATUS.NOT_FOUND);\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"should static file found","suites":["test web server","render","status"],"updatePoint":{"line":100,"column":36},"line":100,"code":"      test('should static file found', async () => {\n        return supertest(await initializeServer('default-test.yaml'))\n          .get('/-/static/main.js')\n          .set('Accept', HEADERS.TEXT_HTML)\n          .expect(HTTP_STATUS.OK);\n      });","file":"render.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom render","suites":["template"],"updatePoint":{"line":12,"column":21},"line":12,"code":"  test('custom render', () => {\n    expect(\n      template({ options: { base: 'http://domain.com' }, manifest: exampleManifest }, manifest)\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom title","suites":["template"],"updatePoint":{"line":18,"column":20},"line":18,"code":"  test('custom title', () => {\n    expect(\n      template(\n        { options: { base: 'http://domain.com', title: 'foo title' }, manifest: exampleManifest },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom title","suites":["template"],"updatePoint":{"line":27,"column":20},"line":27,"code":"  test('custom title', () => {\n    expect(\n      template(\n        { options: { base: 'http://domain.com', title: 'foo title' }, manifest: exampleManifest },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"meta scripts","suites":["template"],"updatePoint":{"line":36,"column":20},"line":36,"code":"  test('meta scripts', () => {\n    expect(\n      template(\n        {\n          options: { base: 'http://domain.com' },\n          metaScripts: [`<style>.someclass{font-size:10px;}</style>`],\n          manifest: exampleManifest,\n        },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom body after","suites":["template"],"updatePoint":{"line":49,"column":25},"line":49,"code":"  test('custom body after', () => {\n    expect(\n      template(\n        {\n          options: { base: 'http://domain.com' },\n          scriptsBodyAfter: [`<script src=\"foo\"/>`],\n          manifest: exampleManifest,\n        },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"custom body before","suites":["template"],"updatePoint":{"line":62,"column":26},"line":62,"code":"  test('custom body before', () => {\n    expect(\n      template(\n        {\n          options: { base: 'http://domain.com' },\n          scriptsbodyBefore: [`<script src=\"fooBefore\"/>`, `<script src=\"barBefore\"/>`],\n          manifest: exampleManifest,\n        },\n        manifest\n      )\n    ).toMatchSnapshot();\n  });","file":"template.test.ts","skipped":false,"dir":"packages/web/test"},{"name":"is valid","suites":["Utilities","validatePrimaryColor"],"updatePoint":{"line":12,"column":18},"line":12,"code":"    test('is valid', () => {\n      expect(validatePrimaryColor('#222222')).toEqual('#222222');\n      expect(validatePrimaryColor('#222fff')).toEqual('#222fff');\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"is invalid","suites":["Utilities","validatePrimaryColor"],"updatePoint":{"line":16,"column":20},"line":16,"code":"    test('is invalid', () => {\n      expect(validatePrimaryColor('fff')).toBeUndefined();\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"should parse makrdown text to html template","suites":["Utilities","parseReadme"],"updatePoint":{"line":21,"column":53},"line":21,"code":"    test('should parse makrdown text to html template', () => {\n      const markdown = '# markdown';\n      expect(parseReadme('testPackage', markdown)).toEqual('<h1 id=\"markdown\">markdown</h1>');\n      // @ts-ignore\n      expect(parseReadme('testPackage', String(readmeFile('markdown.md')))).toMatchSnapshot();\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"should pass for conversion of non-ascii to markdown text","suites":["Utilities","parseReadme"],"updatePoint":{"line":28,"column":66},"line":28,"code":"    test('should pass for conversion of non-ascii to markdown text', () => {\n      const simpleText = 'simple text';\n      const randomText = '%%%%%**##==';\n      const randomTextMarkdown = 'simple text \\n # markdown';\n\n      expect(parseReadme('testPackage', randomText)).toEqual('<p>%%%%%**##==</p>');\n      expect(parseReadme('testPackage', simpleText)).toEqual('<p>simple text</p>');\n      expect(parseReadme('testPackage', randomTextMarkdown)).toEqual(\n        '<p>simple text </p>\\n<h1 id=\"markdown\">markdown</h1>'\n      );\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"should show error for no readme data","suites":["Utilities","parseReadme"],"updatePoint":{"line":40,"column":46},"line":40,"code":"    test('should show error for no readme data', () => {\n      const noData = '';\n      expect(() => parseReadme('testPackage', noData)).toThrowError('ERROR: No README data found!');\n    });","file":"utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"should order ascending","suites":["Utilities","Sort packages"],"updatePoint":{"line":16,"column":32},"line":16,"code":"    test('should order ascending', () => {\n      expect(sortByName(packages)).toEqual([\n        {\n          name: 'abc',\n        },\n        {\n          name: 'ghc',\n        },\n        {\n          name: 'zxy',\n        },\n      ]);\n    });","file":"web-utils.spec.ts","skipped":false,"dir":"packages/web/test"},{"name":"should order descending","suites":["Utilities","Sort packages"],"updatePoint":{"line":30,"column":33},"line":30,"code":"    test('should order descending', () => {\n      expect(sortByName(packages, false)).toEqual([\n        {\n          name: 'zxy',\n        },\n        {\n          name: 'ghc',\n        },\n        {\n          name: 'abc',\n        },\n      ]);\n    });","file":"web-utils.spec.ts","skipped":false,"dir":"packages/web/test"}]}