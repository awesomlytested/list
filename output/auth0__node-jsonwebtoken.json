{
    "repo": "auth0/node-jsonwebtoken",
    "url": "https://github.com/auth0/node-jsonwebtoken",
    "branch": "master",
    "configs": [
        {
            "package": "jsonwebtoken",
            "lang": "js",
            "dir": "test",
            "framework": "mocha",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "should error with with value ",
            "suites": [
                "audience",
                "`jwt.sign` \"audience\" option validation"
            ],
            "updatePoint": {
                "line": 34,
                "column": 64
            },
            "line": 34,
            "code": "      it(`should error with with value ${util.inspect(audience)}`, function (done) {\n        signWithAudience(audience, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"audience\" must be a string or array');\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value undefined",
            "suites": [
                "audience",
                "`jwt.sign` \"audience\" option validation"
            ],
            "updatePoint": {
                "line": 44,
                "column": 46
            },
            "line": 44,
            "code": "    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, 'secret', {\n        audience: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"audience\" must be a string or array');\n        });\n      });\n    });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error when \"aud\" is in payload",
            "suites": [
                "audience",
                "`jwt.sign` \"audience\" option validation"
            ],
            "updatePoint": {
                "line": 55,
                "column": 45
            },
            "line": 55,
            "code": "    it('should error when \"aud\" is in payload', function (done) {\n      signWithAudience('my_aud', {\n        aud: ''\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.audience\" option. The payload already has an \"aud\" property.');\n        });\n      });\n    });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a string payload",
            "suites": [
                "audience",
                "`jwt.sign` \"audience\" option validation"
            ],
            "updatePoint": {
                "line": 65,
                "column": 42
            },
            "line": 65,
            "code": "    it('should error with a string payload', function (done) {\n      signWithAudience('my_aud', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid audience option for string payload');\n        });\n      });\n    });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a Buffer payload",
            "suites": [
                "audience",
                "`jwt.sign` \"audience\" option validation"
            ],
            "updatePoint": {
                "line": 73,
                "column": 42
            },
            "line": 73,
            "code": "    it('should error with a Buffer payload', function (done) {\n      signWithAudience('my_aud', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid audience option for object payload');\n        });\n      });\n    });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify and decode with verify \"audience\" option of ",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with a \"aud\" of \"urn:foo\" in payload"
            ],
            "updatePoint": {
                "line": 92,
                "column": 95
            },
            "line": 92,
            "code": "        it(`should verify and decode with verify \"audience\" option of ${util.inspect(audience)}`, function (done) {\n          verifyWithAudience(token, audience, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud', 'urn:foo');\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with a string verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with a \"aud\" of \"urn:foo\" in payload"
            ],
            "updatePoint": {
                "line": 101,
                "column": 73
            },
            "line": 101,
            "code": "      it(`should error on no match with a string verify \"audience\" option`, function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of string verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with a \"aud\" of \"urn:foo\" in payload"
            ],
            "updatePoint": {
                "line": 109,
                "column": 83
            },
            "line": 109,
            "code": "      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with a Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with a \"aud\" of \"urn:foo\" in payload"
            ],
            "updatePoint": {
                "line": 117,
                "column": 72
            },
            "line": 117,
            "code": "      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with a \"aud\" of \"urn:foo\" in payload"
            ],
            "updatePoint": {
                "line": 125,
                "column": 82
            },
            "line": 125,
            "code": "      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of a Regex and a string in verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with a \"aud\" of \"urn:foo\" in payload"
            ],
            "updatePoint": {
                "line": 133,
                "column": 100
            },
            "line": 133,
            "code": "      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify and decode with verify \"audience\" option of ",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 151,
                "column": 95
            },
            "line": 151,
            "code": "        it(`should verify and decode with verify \"audience\" option of ${util.inspect(audience)}`, function (done) {\n          verifyWithAudience(token, audience, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with a string verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 160,
                "column": 73
            },
            "line": 160,
            "code": "      it(`should error on no match with a string verify \"audience\" option`, function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of string verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 168,
                "column": 83
            },
            "line": 168,
            "code": "      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with a Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 176,
                "column": 72
            },
            "line": 176,
            "code": "      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 184,
                "column": 82
            },
            "line": 184,
            "code": "      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of a Regex and a string in verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 192,
                "column": 100
            },
            "line": 192,
            "code": "      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', `jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match`);\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with an array of stings verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking for a matching on both \"urn:foo\" and \"urn:bar\""
            ],
            "updatePoint": {
                "line": 201,
                "column": 74
            },
            "line": 201,
            "code": "        it('should verify with an array of stings verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:foo', 'urn:bar'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking for a matching on both \"urn:foo\" and \"urn:bar\""
            ],
            "updatePoint": {
                "line": 209,
                "column": 63
            },
            "line": 209,
            "code": "        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:[a-z]{3}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with an array of Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking for a matching on both \"urn:foo\" and \"urn:bar\""
            ],
            "updatePoint": {
                "line": 217,
                "column": 73
            },
            "line": 217,
            "code": "        it('should verify with an array of Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:f[o]{2}$/, /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a string verify \"audience\"",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking for a matching for \"urn:foo\""
            ],
            "updatePoint": {
                "line": 227,
                "column": 57
            },
            "line": 227,
            "code": "        it('should verify with a string verify \"audience\"', function (done) {\n          verifyWithAudience(token, 'urn:foo', (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking for a matching for \"urn:foo\""
            ],
            "updatePoint": {
                "line": 235,
                "column": 63
            },
            "line": 235,
            "code": "        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:f[o]{2}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with an array of Regex verify \"audience\"",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking for a matching for \"urn:foo\""
            ],
            "updatePoint": {
                "line": 243,
                "column": 66
            },
            "line": 243,
            "code": "        it('should verify with an array of Regex verify \"audience\"', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, /^urn:f[o]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with an array containing a string and a Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking for a matching for \"urn:foo\""
            ],
            "updatePoint": {
                "line": 251,
                "column": 96
            },
            "line": 251,
            "code": "        it('should verify with an array containing a string and a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:no_match', /^urn:f[o]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with an array containing a Regex and a string verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking for a matching for \"urn:foo\""
            ],
            "updatePoint": {
                "line": 259,
                "column": 96
            },
            "line": 259,
            "code": "        it('should verify with an array containing a Regex and a string verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, 'urn:foo'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a string verify \"audience\"",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking matching for \"urn:bar\""
            ],
            "updatePoint": {
                "line": 269,
                "column": 57
            },
            "line": 269,
            "code": "        it('should verify with a string verify \"audience\"', function (done) {\n          verifyWithAudience(token, 'urn:bar', (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking matching for \"urn:bar\""
            ],
            "updatePoint": {
                "line": 277,
                "column": 63
            },
            "line": 277,
            "code": "        it('should verify with a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, /^urn:b[ar]{2}$/, (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with an array of Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking matching for \"urn:bar\""
            ],
            "updatePoint": {
                "line": 285,
                "column": 73
            },
            "line": 285,
            "code": "        it('should verify with an array of Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with an array containing a string and a Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking matching for \"urn:bar\""
            ],
            "updatePoint": {
                "line": 293,
                "column": 96
            },
            "line": 293,
            "code": "        it('should verify with an array containing a string and a Regex verify \"audience\" option', function (done) {\n          verifyWithAudience(token, ['urn:no_match', /^urn:b[ar]{2}$/], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with an array containing a Regex and a string verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "with an array of [\"urn:foo\", \"urn:bar\"] for \"aud\" value in payload",
                "when checking matching for \"urn:bar\""
            ],
            "updatePoint": {
                "line": 301,
                "column": 96
            },
            "line": 301,
            "code": "        it('should verify with an array containing a Regex and a string verify \"audience\" option', function (done) {\n          verifyWithAudience(token, [/^urn:no-match$/, 'urn:bar'], (err, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(err).to.be.null;\n              expect(decoded).to.have.property('aud').deep.equals(['urn:foo', 'urn:bar']);\n            });\n          });\n        });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify and decode without verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "without a \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 319,
                "column": 67
            },
            "line": 319,
            "code": "      it('should verify and decode without verify \"audience\" option', function (done) {\n        verifyWithAudience(token, undefined, (err, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.null;\n            expect(decoded).to.not.have.property('aud');\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with a string verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "without a \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 327,
                "column": 73
            },
            "line": 327,
            "code": "      it('should error on no match with a string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, 'urn:no-match', err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: urn:no-match');\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of string verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "without a \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 335,
                "column": 83
            },
            "line": 335,
            "code": "      it('should error on no match with an array of string verify \"audience\" option', function (done) {\n        verifyWithAudience(token, ['urn:no-match-1', 'urn:no-match-2'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: urn:no-match-1 or urn:no-match-2');\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with a Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "without a \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 343,
                "column": 72
            },
            "line": 343,
            "code": "      it('should error on no match with a Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, /^urn:no-match$/, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match$/');\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of Regex verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "without a \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 351,
                "column": 82
            },
            "line": 351,
            "code": "      it('should error on no match with an array of Regex verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match-1$/, /^urn:no-match-2$/], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match-1$/ or /^urn:no-match-2$/');\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on no match with an array of a Regex and a string in verify \"audience\" option",
            "suites": [
                "audience",
                "when signing and verifying a token with \"audience\" option",
                "without a \"aud\" value in payload"
            ],
            "updatePoint": {
                "line": 359,
                "column": 100
            },
            "line": 359,
            "code": "      it('should error on no match with an array of a Regex and a string in verify \"audience\" option', function (done) {\n        verifyWithAudience(token, [/^urn:no-match$/, 'urn:no-match'], err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'jwt audience invalid. expected: /^urn:no-match$/ or urn:no-match');\n          });\n        });\n      });",
            "file": "claim-aud.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "expires",
                "`jwt.sign` \"expiresIn\" option validation"
            ],
            "updatePoint": {
                "line": 33,
                "column": 65
            },
            "line": 33,
            "code": "      it(`should error with with value ${util.inspect(expiresIn)}`, function (done) {\n        signWithExpiresIn(expiresIn, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message').match(/\"expiresIn\" should be a number of seconds or string representing a timespan/);\n          });\n        });\n      });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value undefined",
            "suites": [
                "expires",
                "`jwt.sign` \"expiresIn\" option validation"
            ],
            "updatePoint": {
                "line": 43,
                "column": 46
            },
            "line": 43,
            "code": "    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        expiresIn: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"expiresIn\" should be a number of seconds or string representing a timespan');\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error when \"exp\" is in payload",
            "suites": [
                "expires",
                "`jwt.sign` \"expiresIn\" option validation"
            ],
            "updatePoint": {
                "line": 54,
                "column": 45
            },
            "line": 54,
            "code": "    it('should error when \"exp\" is in payload', function (done) {\n      signWithExpiresIn(100, {\n        exp: 100\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.expiresIn\" option the payload already has an \"exp\" property.');\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a string payload",
            "suites": [
                "expires",
                "`jwt.sign` \"expiresIn\" option validation"
            ],
            "updatePoint": {
                "line": 64,
                "column": 42
            },
            "line": 64,
            "code": "    it('should error with a string payload', function (done) {\n      signWithExpiresIn(100, 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid expiresIn option for string payload');\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a Buffer payload",
            "suites": [
                "expires",
                "`jwt.sign` \"expiresIn\" option validation"
            ],
            "updatePoint": {
                "line": 72,
                "column": 42
            },
            "line": 72,
            "code": "    it('should error with a Buffer payload', function (done) {\n      signWithExpiresIn(100, Buffer.from('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid expiresIn option for object payload');\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "expires",
                "`jwt.sign` \"exp\" claim validation"
            ],
            "updatePoint": {
                "line": 85,
                "column": 59
            },
            "line": 85,
            "code": "      it(`should error with with value ${util.inspect(exp)}`, function (done) {\n        signWithExpiresIn(undefined, {\n          exp\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"exp\" should be a number of seconds');\n          });\n        });\n      });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "expires",
                "\"exp\" in payload validation"
            ],
            "updatePoint": {
                "line": 101,
                "column": 59
            },
            "line": 101,
            "code": "      it(`should error with with value ${util.inspect(exp)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          exp\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        testUtils.verifyJWTHelper(token, undefined, {\n          exp\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'invalid exp value');\n          });\n        });\n      });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"exp\" with negative number of seconds",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 127,
                "column": 64
            },
            "line": 127,
            "code": "    it('should set correct \"exp\" with negative number of seconds', function (done) {\n      signWithExpiresIn(-10, {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"exp\" with positive number of seconds",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 139,
                "column": 64
            },
            "line": 139,
            "code": "    it('should set correct \"exp\" with positive number of seconds', function (done) {\n      signWithExpiresIn(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"exp\" with zero seconds",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 150,
                "column": 50
            },
            "line": 150,
            "code": "    it('should set correct \"exp\" with zero seconds', function (done) {\n      signWithExpiresIn(0, {}, (e1, token) => {\n        fakeClock.tick(-1);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 60);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"exp\" with negative string timespan",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 162,
                "column": 62
            },
            "line": 162,
            "code": "    it('should set correct \"exp\" with negative string timespan', function (done) {\n      signWithExpiresIn('-10 s', {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"exp\" with positive string timespan",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 174,
                "column": 62
            },
            "line": 174,
            "code": "    it('should set correct \"exp\" with positive string timespan', function (done) {\n      signWithExpiresIn('10 s', {}, (e1, token) => {\n        fakeClock.tick(-10001);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"exp\" with zero string timespan",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 186,
                "column": 58
            },
            "line": 186,
            "code": "    it('should set correct \"exp\" with zero string timespan', function (done) {\n      signWithExpiresIn('0 s', {}, (e1, token) => {\n        fakeClock.tick(-1);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 60);\n          });\n        });\n      });\n    }); // TODO an exp of -Infinity should fail validation",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set null \"exp\" when given -Infinity",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 199,
                "column": 50
            },
            "line": 199,
            "code": "    it('should set null \"exp\" when given -Infinity', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: -Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    }); // TODO an exp of Infinity should fail validation",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set null \"exp\" when given value Infinity",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 211,
                "column": 55
            },
            "line": 211,
            "code": "    it('should set null \"exp\" when given value Infinity', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    }); // TODO an exp of NaN should fail validation",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set null \"exp\" when given value NaN",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 223,
                "column": 50
            },
            "line": 223,
            "code": "    it('should set null \"exp\" when given value NaN', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: NaN\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('exp', null);\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"exp\" when \"iat\" is passed",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 234,
                "column": 53
            },
            "line": 234,
            "code": "    it('should set correct \"exp\" when \"iat\" is passed', function (done) {\n      signWithExpiresIn(-10, {\n        iat: 80\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify \"exp\" using \"clockTimestamp\"",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 247,
                "column": 50
            },
            "line": 247,
            "code": "    it('should verify \"exp\" using \"clockTimestamp\"', function (done) {\n      signWithExpiresIn(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 69\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 70);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify \"exp\" using \"clockTolerance\"",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 261,
                "column": 50
            },
            "line": 261,
            "code": "    it('should verify \"exp\" using \"clockTolerance\"', function (done) {\n      signWithExpiresIn(5, {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 6\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 65);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should ignore a expired token when \"ignoreExpiration\" is true",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 276,
                "column": 69
            },
            "line": 276,
            "code": "    it('should ignore a expired token when \"ignoreExpiration\" is true', function (done) {\n      signWithExpiresIn('-10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          ignoreExpiration: true\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('exp', 50);\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on verify if \"exp\" is at current time",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 290,
                "column": 58
            },
            "line": 290,
            "code": "    it('should error on verify if \"exp\" is at current time', function (done) {\n      signWithExpiresIn(undefined, {\n        exp: 60\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.TokenExpiredError);\n            expect(e2).to.have.property('message', 'jwt expired');\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on verify if \"exp\" is before current time using clockTolerance",
            "suites": [
                "expires",
                "when signing and verifying a token with expires option"
            ],
            "updatePoint": {
                "line": 303,
                "column": 83
            },
            "line": 303,
            "code": "    it('should error on verify if \"exp\" is before current time using clockTolerance', function (done) {\n      signWithExpiresIn(-5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 5\n        }, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.TokenExpiredError);\n            expect(e2).to.have.property('message', 'jwt expired');\n          });\n        });\n      });\n    });",
            "file": "claim-exp.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with iat of ",
            "suites": [
                "issue at",
                "`jwt.sign` \"iat\" claim validation"
            ],
            "updatePoint": {
                "line": 43,
                "column": 55
            },
            "line": 43,
            "code": "      it(`should error with iat of ${util.inspect(iat)}`, function (done) {\n        signWithIssueAt(iat, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err.message).to.equal('\"iat\" should be a number of seconds');\n          });\n        });\n      });",
            "file": "claim-iat.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with iat of undefined",
            "suites": [
                "issue at",
                "`jwt.sign` \"iat\" claim validation"
            ],
            "updatePoint": {
                "line": 53,
                "column": 42
            },
            "line": 53,
            "code": "    it('should error with iat of undefined', function (done) {\n      testUtils.signJWTHelper({\n        iat: undefined\n      }, 'secret', {\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err.message).to.equal('\"iat\" should be a number of seconds');\n        });\n      });\n    });",
            "file": "claim-iat.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with iat of ",
            "suites": [
                "issue at",
                "\"iat\" in payload with \"maxAge\" option validation"
            ],
            "updatePoint": {
                "line": 70,
                "column": 55
            },
            "line": 70,
            "code": "      it(`should error with iat of ${util.inspect(iat)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          iat\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        verifyWithIssueAt(token, '1 min', {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err.message).to.equal('iat required when maxAge is specified');\n          });\n        });\n      });",
            "file": "claim-iat.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not add iat to string",
            "suites": [
                "issue at",
                "with string payload"
            ],
            "updatePoint": {
                "line": 240,
                "column": 36
            },
            "line": 240,
            "code": "    it('should not add iat to string', function (done) {\n      const payload = 'string payload';\n      const options = {\n        algorithm: 'none'\n      };\n      testUtils.signJWTHelper(payload, 'secret', options, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.equal(payload);\n        });\n      });\n    });",
            "file": "claim-iat.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not add iat to stringified object",
            "suites": [
                "issue at",
                "with string payload"
            ],
            "updatePoint": {
                "line": 253,
                "column": 48
            },
            "line": 253,
            "code": "    it('should not add iat to stringified object', function (done) {\n      const payload = '{}';\n      const options = {\n        algorithm: 'none',\n        header: {\n          typ: 'JWT'\n        }\n      };\n      testUtils.signJWTHelper(payload, 'secret', options, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.equal(null);\n          expect(JSON.stringify(decoded)).to.equal(payload);\n        });\n      });\n    });",
            "file": "claim-iat.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "issuer",
                "`jwt.sign` \"issuer\" option validation"
            ],
            "updatePoint": {
                "line": 28,
                "column": 62
            },
            "line": 28,
            "code": "      it(`should error with with value ${util.inspect(issuer)}`, function (done) {\n        signWithIssuer(issuer, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"issuer\" must be a string');\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value undefined",
            "suites": [
                "issuer",
                "`jwt.sign` \"issuer\" option validation"
            ],
            "updatePoint": {
                "line": 38,
                "column": 46
            },
            "line": 38,
            "code": "    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        issuer: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"issuer\" must be a string');\n        });\n      });\n    });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error when \"iss\" is in payload",
            "suites": [
                "issuer",
                "`jwt.sign` \"issuer\" option validation"
            ],
            "updatePoint": {
                "line": 49,
                "column": 45
            },
            "line": 49,
            "code": "    it('should error when \"iss\" is in payload', function (done) {\n      signWithIssuer('foo', {\n        iss: 'bar'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.issuer\" option. The payload already has an \"iss\" property.');\n        });\n      });\n    });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a string payload",
            "suites": [
                "issuer",
                "`jwt.sign` \"issuer\" option validation"
            ],
            "updatePoint": {
                "line": 59,
                "column": 42
            },
            "line": 59,
            "code": "    it('should error with a string payload', function (done) {\n      signWithIssuer('foo', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid issuer option for string payload');\n        });\n      });\n    });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a Buffer payload",
            "suites": [
                "issuer",
                "`jwt.sign` \"issuer\" option validation"
            ],
            "updatePoint": {
                "line": 67,
                "column": 42
            },
            "line": 67,
            "code": "    it('should error with a Buffer payload', function (done) {\n      signWithIssuer('foo', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid issuer option for object payload');\n        });\n      });\n    });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not verify \"iss\" if verify \"issuer\" option not provided",
            "suites": [
                "issuer",
                "when signing and verifying a token"
            ],
            "updatePoint": {
                "line": 77,
                "column": 70
            },
            "line": 77,
            "code": "    it('should not verify \"iss\" if verify \"issuer\" option not provided', function (done) {\n      signWithIssuer(undefined, {\n        iss: 'foo'\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iss', 'foo');\n          });\n        });\n      });\n    });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a string \"issuer\"",
            "suites": [
                "issuer",
                "when signing and verifying a token",
                "with string \"issuer\" option"
            ],
            "updatePoint": {
                "line": 91,
                "column": 46
            },
            "line": 91,
            "code": "      it('should verify with a string \"issuer\"', function (done) {\n        signWithIssuer('foo', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a string \"iss\"",
            "suites": [
                "issuer",
                "when signing and verifying a token",
                "with string \"issuer\" option"
            ],
            "updatePoint": {
                "line": 104,
                "column": 43
            },
            "line": 104,
            "code": "      it('should verify with a string \"iss\"', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error if \"iss\" does not match verify \"issuer\" option",
            "suites": [
                "issuer",
                "when signing and verifying a token",
                "with string \"issuer\" option"
            ],
            "updatePoint": {
                "line": 119,
                "column": 69
            },
            "line": 119,
            "code": "      it('should error if \"iss\" does not match verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foobar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo');\n            });\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error without \"iss\" and with verify \"issuer\" option",
            "suites": [
                "issuer",
                "when signing and verifying a token",
                "with string \"issuer\" option"
            ],
            "updatePoint": {
                "line": 134,
                "column": 68
            },
            "line": 134,
            "code": "      it('should error without \"iss\" and with verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo');\n            });\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a string \"issuer\"",
            "suites": [
                "issuer",
                "when signing and verifying a token",
                "with array \"issuer\" option"
            ],
            "updatePoint": {
                "line": 149,
                "column": 46
            },
            "line": 149,
            "code": "      it('should verify with a string \"issuer\"', function (done) {\n        signWithIssuer('bar', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'bar');\n            });\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with a string \"iss\"",
            "suites": [
                "issuer",
                "when signing and verifying a token",
                "with array \"issuer\" option"
            ],
            "updatePoint": {
                "line": 162,
                "column": 43
            },
            "line": 162,
            "code": "      it('should verify with a string \"iss\"', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('iss', 'foo');\n            });\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error if \"iss\" does not match verify \"issuer\" option",
            "suites": [
                "issuer",
                "when signing and verifying a token",
                "with array \"issuer\" option"
            ],
            "updatePoint": {
                "line": 177,
                "column": 69
            },
            "line": 177,
            "code": "      it('should error if \"iss\" does not match verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {\n          iss: 'foobar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo,bar');\n            });\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error without \"iss\" and with verify \"issuer\" option",
            "suites": [
                "issuer",
                "when signing and verifying a token",
                "with array \"issuer\" option"
            ],
            "updatePoint": {
                "line": 192,
                "column": 68
            },
            "line": 192,
            "code": "      it('should error without \"iss\" and with verify \"issuer\" option', function (done) {\n        signWithIssuer(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            issuer: ['foo', 'bar']\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt issuer invalid. expected: foo,bar');\n            });\n          });\n        });\n      });",
            "file": "claim-iss.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "jwtid",
                "`jwt.sign` \"jwtid\" option validation"
            ],
            "updatePoint": {
                "line": 28,
                "column": 61
            },
            "line": 28,
            "code": "      it(`should error with with value ${util.inspect(jwtid)}`, function (done) {\n        signWithJWTId(jwtid, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"jwtid\" must be a string');\n          });\n        });\n      });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value undefined",
            "suites": [
                "jwtid",
                "`jwt.sign` \"jwtid\" option validation"
            ],
            "updatePoint": {
                "line": 38,
                "column": 46
            },
            "line": 38,
            "code": "    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        jwtid: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"jwtid\" must be a string');\n        });\n      });\n    });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error when \"jti\" is in payload",
            "suites": [
                "jwtid",
                "`jwt.sign` \"jwtid\" option validation"
            ],
            "updatePoint": {
                "line": 49,
                "column": 45
            },
            "line": 49,
            "code": "    it('should error when \"jti\" is in payload', function (done) {\n      signWithJWTId('foo', {\n        jti: 'bar'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.jwtid\" option. The payload already has an \"jti\" property.');\n        });\n      });\n    });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a string payload",
            "suites": [
                "jwtid",
                "`jwt.sign` \"jwtid\" option validation"
            ],
            "updatePoint": {
                "line": 59,
                "column": 42
            },
            "line": 59,
            "code": "    it('should error with a string payload', function (done) {\n      signWithJWTId('foo', 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid jwtid option for string payload');\n        });\n      });\n    });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a Buffer payload",
            "suites": [
                "jwtid",
                "`jwt.sign` \"jwtid\" option validation"
            ],
            "updatePoint": {
                "line": 67,
                "column": 42
            },
            "line": 67,
            "code": "    it('should error with a Buffer payload', function (done) {\n      signWithJWTId('foo', new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid jwtid option for object payload');\n        });\n      });\n    });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not verify \"jti\" if verify \"jwtid\" option not provided",
            "suites": [
                "jwtid",
                "when signing and verifying a token"
            ],
            "updatePoint": {
                "line": 77,
                "column": 69
            },
            "line": 77,
            "code": "    it('should not verify \"jti\" if verify \"jwtid\" option not provided', function (done) {\n      signWithJWTId(undefined, {\n        jti: 'foo'\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('jti', 'foo');\n          });\n        });\n      });\n    });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with \"jwtid\" option",
            "suites": [
                "jwtid",
                "when signing and verifying a token",
                "with \"jwtid\" option"
            ],
            "updatePoint": {
                "line": 91,
                "column": 43
            },
            "line": 91,
            "code": "      it('should verify with \"jwtid\" option', function (done) {\n        signWithJWTId('foo', {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('jti', 'foo');\n            });\n          });\n        });\n      });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify with \"jti\" in payload",
            "suites": [
                "jwtid",
                "when signing and verifying a token",
                "with \"jwtid\" option"
            ],
            "updatePoint": {
                "line": 104,
                "column": 45
            },
            "line": 104,
            "code": "      it('should verify with \"jti\" in payload', function (done) {\n        signWithJWTId(undefined, {\n          jti: 'foo'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jetid: 'foo'\n          }, (e2, decoded) => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.null;\n              expect(decoded).to.have.property('jti', 'foo');\n            });\n          });\n        });\n      });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error if \"jti\" does not match verify \"jwtid\" option",
            "suites": [
                "jwtid",
                "when signing and verifying a token",
                "with \"jwtid\" option"
            ],
            "updatePoint": {
                "line": 119,
                "column": 68
            },
            "line": 119,
            "code": "      it('should error if \"jti\" does not match verify \"jwtid\" option', function (done) {\n        signWithJWTId(undefined, {\n          jti: 'bar'\n        }, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt jwtid invalid. expected: foo');\n            });\n          });\n        });\n      });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error without \"jti\" and with verify \"jwtid\" option",
            "suites": [
                "jwtid",
                "when signing and verifying a token",
                "with \"jwtid\" option"
            ],
            "updatePoint": {
                "line": 134,
                "column": 67
            },
            "line": 134,
            "code": "      it('should error without \"jti\" and with verify \"jwtid\" option', function (done) {\n        signWithJWTId(undefined, {}, (e1, token) => {\n          testUtils.verifyJWTHelper(token, undefined, {\n            jwtid: 'foo'\n          }, e2 => {\n            testUtils.asyncCheck(done, () => {\n              expect(e1).to.be.null;\n              expect(e2).to.be.instanceOf(jwt.JsonWebTokenError);\n              expect(e2).to.have.property('message', 'jwt jwtid invalid. expected: foo');\n            });\n          });\n        });\n      });",
            "file": "claim-jti.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "not before",
                "`jwt.sign` \"notBefore\" option validation"
            ],
            "updatePoint": {
                "line": 33,
                "column": 65
            },
            "line": 33,
            "code": "      it(`should error with with value ${util.inspect(notBefore)}`, function (done) {\n        signWithNotBefore(notBefore, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message').match(/\"notBefore\" should be a number of seconds or string representing a timespan/);\n          });\n        });\n      });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value undefined",
            "suites": [
                "not before",
                "`jwt.sign` \"notBefore\" option validation"
            ],
            "updatePoint": {
                "line": 43,
                "column": 46
            },
            "line": 43,
            "code": "    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        notBefore: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"notBefore\" should be a number of seconds or string representing a timespan');\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error when \"nbf\" is in payload",
            "suites": [
                "not before",
                "`jwt.sign` \"notBefore\" option validation"
            ],
            "updatePoint": {
                "line": 54,
                "column": 45
            },
            "line": 54,
            "code": "    it('should error when \"nbf\" is in payload', function (done) {\n      signWithNotBefore(100, {\n        nbf: 100\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'Bad \"options.notBefore\" option the payload already has an \"nbf\" property.');\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a string payload",
            "suites": [
                "not before",
                "`jwt.sign` \"notBefore\" option validation"
            ],
            "updatePoint": {
                "line": 64,
                "column": 42
            },
            "line": 64,
            "code": "    it('should error with a string payload', function (done) {\n      signWithNotBefore(100, 'a string payload', err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid notBefore option for string payload');\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with a Buffer payload",
            "suites": [
                "not before",
                "`jwt.sign` \"notBefore\" option validation"
            ],
            "updatePoint": {
                "line": 72,
                "column": 42
            },
            "line": 72,
            "code": "    it('should error with a Buffer payload', function (done) {\n      signWithNotBefore(100, new Buffer('a Buffer payload'), err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', 'invalid notBefore option for object payload');\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "not before",
                "`jwt.sign` \"nbf\" claim validation"
            ],
            "updatePoint": {
                "line": 85,
                "column": 59
            },
            "line": 85,
            "code": "      it(`should error with with value ${util.inspect(nbf)}`, function (done) {\n        signWithNotBefore(undefined, {\n          nbf\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"nbf\" should be a number of seconds');\n          });\n        });\n      });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "not before",
                "\"nbf\" in payload validation"
            ],
            "updatePoint": {
                "line": 101,
                "column": 59
            },
            "line": 101,
            "code": "      it(`should error with with value ${util.inspect(nbf)}`, function (done) {\n        const encodedPayload = base64UrlEncode(JSON.stringify({\n          nbf\n        }));\n        const token = `${noneAlgorithmHeader}.${encodedPayload}.`;\n        testUtils.verifyJWTHelper(token, undefined, {\n          nbf\n        }, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n            expect(err).to.have.property('message', 'invalid nbf value');\n          });\n        });\n      });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"nbf\" with negative number of seconds",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 127,
                "column": 64
            },
            "line": 127,
            "code": "    it('should set correct \"nbf\" with negative number of seconds', function (done) {\n      signWithNotBefore(-10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 50);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"nbf\" with positive number of seconds",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 138,
                "column": 64
            },
            "line": 138,
            "code": "    it('should set correct \"nbf\" with positive number of seconds', function (done) {\n      signWithNotBefore(10, {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"nbf\" with zero seconds",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 150,
                "column": 50
            },
            "line": 150,
            "code": "    it('should set correct \"nbf\" with zero seconds', function (done) {\n      signWithNotBefore(0, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 60);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"nbf\" with negative string timespan",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 161,
                "column": 62
            },
            "line": 161,
            "code": "    it('should set correct \"nbf\" with negative string timespan', function (done) {\n      signWithNotBefore('-10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 50);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"nbf\" with positive string timespan",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 172,
                "column": 62
            },
            "line": 172,
            "code": "    it('should set correct \"nbf\" with positive string timespan', function (done) {\n      signWithNotBefore('10 s', {}, (e1, token) => {\n        fakeClock.tick(10000);\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"nbf\" with zero string timespan",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 184,
                "column": 58
            },
            "line": 184,
            "code": "    it('should set correct \"nbf\" with zero string timespan', function (done) {\n      signWithNotBefore('0 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 60);\n          });\n        });\n      });\n    }); // TODO an nbf of -Infinity should fail validation",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set null \"nbf\" when given -Infinity",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 196,
                "column": 50
            },
            "line": 196,
            "code": "    it('should set null \"nbf\" when given -Infinity', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: -Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    }); // TODO an nbf of Infinity should fail validation",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set null \"nbf\" when given value Infinity",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 208,
                "column": 55
            },
            "line": 208,
            "code": "    it('should set null \"nbf\" when given value Infinity', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: Infinity\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    }); // TODO an nbf of NaN should fail validation",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set null \"nbf\" when given value NaN",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 220,
                "column": 50
            },
            "line": 220,
            "code": "    it('should set null \"nbf\" when given value NaN', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: NaN\n      }, (err, token) => {\n        const decoded = jwt.decode(token);\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.null;\n          expect(decoded).to.have.property('nbf', null);\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should set correct \"nbf\" when \"iat\" is passed",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 231,
                "column": 53
            },
            "line": 231,
            "code": "    it('should set correct \"nbf\" when \"iat\" is passed', function (done) {\n      signWithNotBefore(-10, {\n        iat: 40\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('nbf', 30);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify \"nbf\" using \"clockTimestamp\"",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 244,
                "column": 50
            },
            "line": 244,
            "code": "    it('should verify \"nbf\" using \"clockTimestamp\"', function (done) {\n      signWithNotBefore(10, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTimestamp: 70\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should verify \"nbf\" using \"clockTolerance\"",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 258,
                "column": 50
            },
            "line": 258,
            "code": "    it('should verify \"nbf\" using \"clockTolerance\"', function (done) {\n      signWithNotBefore(5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 6\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 65);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should ignore a not active token when \"ignoreNotBefore\" is true",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 272,
                "column": 71
            },
            "line": 272,
            "code": "    it('should ignore a not active token when \"ignoreNotBefore\" is true', function (done) {\n      signWithNotBefore('10 s', {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          ignoreNotBefore: true\n        }, (e2, decoded) => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.null;\n            expect(decoded).to.have.property('iat', 60);\n            expect(decoded).to.have.property('nbf', 70);\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on verify if \"nbf\" is after current time",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 286,
                "column": 61
            },
            "line": 286,
            "code": "    it('should error on verify if \"nbf\" is after current time', function (done) {\n      signWithNotBefore(undefined, {\n        nbf: 61\n      }, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {}, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.NotBeforeError);\n            expect(e2).to.have.property('message', 'jwt not active');\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error on verify if \"nbf\" is after current time using clockTolerance",
            "suites": [
                "not before",
                "when signing and verifying a token with \"notBefore\" option"
            ],
            "updatePoint": {
                "line": 299,
                "column": 82
            },
            "line": 299,
            "code": "    it('should error on verify if \"nbf\" is after current time using clockTolerance', function (done) {\n      signWithNotBefore(5, {}, (e1, token) => {\n        testUtils.verifyJWTHelper(token, undefined, {\n          clockTolerance: 4\n        }, e2 => {\n          testUtils.asyncCheck(done, () => {\n            expect(e1).to.be.null;\n            expect(e2).to.be.instanceOf(jwt.NotBeforeError);\n            expect(e2).to.have.property('message', 'jwt not active');\n          });\n        });\n      });\n    });",
            "file": "claim-nbf.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value ",
            "suites": [
                "keyid",
                "`jwt.sign` \"keyid\" option validation"
            ],
            "updatePoint": {
                "line": 28,
                "column": 61
            },
            "line": 28,
            "code": "      it(`should error with with value ${util.inspect(keyid)}`, function (done) {\n        signWithKeyId(keyid, {}, err => {\n          testUtils.asyncCheck(done, () => {\n            expect(err).to.be.instanceOf(Error);\n            expect(err).to.have.property('message', '\"keyid\" must be a string');\n          });\n        });\n      });",
            "file": "header-kid.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with with value undefined",
            "suites": [
                "keyid",
                "`jwt.sign` \"keyid\" option validation"
            ],
            "updatePoint": {
                "line": 38,
                "column": 46
            },
            "line": 38,
            "code": "    it('should error with with value undefined', function (done) {\n      testUtils.signJWTHelper({}, undefined, {\n        keyid: undefined,\n        algorithm: 'none'\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(Error);\n          expect(err).to.have.property('message', '\"keyid\" must be a string');\n        });\n      });\n    });",
            "file": "header-kid.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not add \"kid\" header when \"keyid\" option not provided",
            "suites": [
                "keyid",
                "when signing a token"
            ],
            "updatePoint": {
                "line": 51,
                "column": 68
            },
            "line": 51,
            "code": "    it('should not add \"kid\" header when \"keyid\" option not provided', function (done) {\n      signWithKeyId(undefined, {}, (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.not.have.property('kid');\n        });\n      });\n    });",
            "file": "header-kid.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should add \"kid\" header when \"keyid\" option is provided and an object payload",
            "suites": [
                "keyid",
                "when signing a token"
            ],
            "updatePoint": {
                "line": 62,
                "column": 85
            },
            "line": 62,
            "code": "    it('should add \"kid\" header when \"keyid\" option is provided and an object payload', function (done) {\n      signWithKeyId('foo', {}, (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });",
            "file": "header-kid.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should add \"kid\" header when \"keyid\" option is provided and a Buffer payload",
            "suites": [
                "keyid",
                "when signing a token"
            ],
            "updatePoint": {
                "line": 73,
                "column": 84
            },
            "line": 73,
            "code": "    it('should add \"kid\" header when \"keyid\" option is provided and a Buffer payload', function (done) {\n      signWithKeyId('foo', new Buffer('a Buffer payload'), (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });",
            "file": "header-kid.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should add \"kid\" header when \"keyid\" option is provided and a string payload",
            "suites": [
                "keyid",
                "when signing a token"
            ],
            "updatePoint": {
                "line": 84,
                "column": 84
            },
            "line": 84,
            "code": "    it('should add \"kid\" header when \"keyid\" option is provided and a string payload', function (done) {\n      signWithKeyId('foo', 'a string payload', (err, token) => {\n        testUtils.asyncCheck(done, () => {\n          const decoded = jwt.decode(token, {\n            complete: true\n          });\n          expect(err).to.be.null;\n          expect(decoded.header).to.have.property('kid', 'foo');\n        });\n      });\n    });",
            "file": "header-kid.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with value ",
            "suites": [
                "maxAge option"
            ],
            "updatePoint": {
                "line": 55,
                "column": 55
            },
            "line": 55,
            "code": "    it(`should error with value ${util.inspect(maxAge)}`, function (done) {\n      expect(() => jwt.verify(token, undefined, {\n        maxAge\n      })).to.throw(jwt.JsonWebTokenError, '\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60');\n      jwt.verify(token, undefined, {\n        maxAge\n      }, err => {\n        expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n        expect(err.message).to.equal('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60');\n        done();\n      });\n    });",
            "file": "option-maxAge.test.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error with value ",
            "suites": [
                "nonce option"
            ],
            "updatePoint": {
                "line": 38,
                "column": 54
            },
            "line": 38,
            "code": "    it(`should error with value ${util.inspect(nonce)}`, function (done) {\n      testUtils.verifyJWTHelper(token, undefined, {\n        nonce\n      }, err => {\n        testUtils.asyncCheck(done, () => {\n          expect(err).to.be.instanceOf(jwt.JsonWebTokenError);\n          expect(err).to.have.property('message', 'nonce must be a non-empty string');\n        });\n      });\n    });",
            "file": "option-nonce.test.js",
            "skipped": false,
            "dir": "test"
        }
    ],
    "badge": "auth0__node-jsonwebtoken.svg"
}