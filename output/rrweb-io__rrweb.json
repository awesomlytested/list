{"repo":"rrweb-io/rrweb","url":"https://github.com/rrweb-io/rrweb","branch":"master","configs":[{"package":"rrweb-snapshot","lang":"ts","dir":"packages/rrweb-snapshot/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rrweb","lang":"ts","dir":"packages/rrweb/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should save the filename and source","suites":["css parser"],"updatePoint":{"line":4,"column":41},"line":4,"code":"  it('should save the filename and source', () => {\n    const css = 'booty {\\n  size: large;\\n}\\n';\n    const ast = parse(css, {\n      source: 'booty.css',\n    });\n\n    expect(ast.stylesheet!.source).toEqual('booty.css');\n\n    const position = ast.stylesheet!.rules[0].position!;\n    expect(position.start).toBeTruthy();\n    expect(position.end).toBeTruthy();\n    expect(position.source).toEqual('booty.css');\n    expect(position.content).toEqual(css);\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should throw when a selector is missing","suites":["css parser"],"updatePoint":{"line":19,"column":45},"line":19,"code":"  it('should throw when a selector is missing', () => {\n    expect(() => {\n      parse('{size: large}');\n    }).toThrow();\n\n    expect(() => {\n      parse('b { color: red; }\\n{ color: green; }\\na { color: blue; }');\n    }).toThrow();\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should throw when a broken comment is found","suites":["css parser"],"updatePoint":{"line":29,"column":49},"line":29,"code":"  it('should throw when a broken comment is found', () => {\n    expect(() => {\n      parse('thing { color: red; } /* b { color: blue; }');\n    }).toThrow();\n\n    expect(() => {\n      parse('/*');\n    }).toThrow();\n\n    /* Nested comments should be fine */\n    expect(() => {\n      parse('/* /* */');\n    }).not.toThrow();\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should allow empty property value","suites":["css parser"],"updatePoint":{"line":44,"column":39},"line":44,"code":"  it('should allow empty property value', () => {\n    expect(() => {\n      parse('p { color:; }');\n    }).not.toThrow();\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should not throw with silent option","suites":["css parser"],"updatePoint":{"line":50,"column":41},"line":50,"code":"  it('should not throw with silent option', () => {\n    expect(() => {\n      parse('thing { color: red; } /* b { color: blue; }', { silent: true });\n    }).not.toThrow();\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should list the parsing errors and continue parsing","suites":["css parser"],"updatePoint":{"line":56,"column":57},"line":56,"code":"  it('should list the parsing errors and continue parsing', () => {\n    const result = parse(\n      'foo { color= red; } bar { color: blue; } baz {}} boo { display: none}',\n      {\n        silent: true,\n        source: 'foo.css',\n      },\n    );\n\n    const rules = result.stylesheet!.rules;\n    expect(rules.length).toBeGreaterThan(2);\n\n    const errors = result.stylesheet!.parsingErrors!;\n    expect(errors.length).toEqual(2);\n\n    expect(errors[0]).toHaveProperty('message');\n    expect(errors[0]).toHaveProperty('reason');\n    expect(errors[0]).toHaveProperty('filename');\n    expect(errors[0]).toHaveProperty('line');\n    expect(errors[0]).toHaveProperty('column');\n    expect(errors[0]).toHaveProperty('source');\n    expect(errors[0].filename).toEqual('foo.css');\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should set parent property","suites":["css parser"],"updatePoint":{"line":80,"column":32},"line":80,"code":"  it('should set parent property', () => {\n    const result = parse(\n      'thing { test: value; }\\n' +\n        '@media (min-width: 100px) { thing { test: value; } }',\n    );\n\n    expect(result.parent).toEqual(null);\n\n    const rules = result.stylesheet!.rules;\n    expect(rules.length).toEqual(2);\n\n    let rule = rules[0] as Rule;\n    expect(rule.parent).toEqual(result);\n    expect(rule.declarations!.length).toEqual(1);\n\n    let decl = rule.declarations![0];\n    expect(decl.parent).toEqual(rule);\n\n    const media = rules[1] as Media;\n    expect(media.parent).toEqual(result);\n    expect(media.rules!.length).toEqual(1);\n\n    rule = media.rules![0] as Rule;\n    expect(rule.parent).toEqual(media);\n\n    expect(rule.declarations!.length).toEqual(1);\n    decl = rule.declarations![0];\n    expect(decl.parent).toEqual(rule);\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly triggers backCompat mode and rendering","suites":["integration tests"],"updatePoint":{"line":147,"column":54},"line":147,"code":"  it('correctly triggers backCompat mode and rendering', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    // console for debug\n    page.on('console', (msg) => console.log(msg.text()));\n\n    await page.goto('http://localhost:3030/html/compat-mode.html', {\n      waitUntil: 'load',\n    });\n    const compatMode = await page.evaluate('document.compatMode');\n    assert(\n      compatMode === 'BackCompat',\n      compatMode +\n        ' for compat-mode.html should be BackCompat as DOCTYPE is deliberately omitted',\n    );\n    const renderedHeight = await page.evaluate(\n      'document.querySelector(\"center\").clientHeight',\n    );\n    // can remove following assertion if dimensions of page change\n    assert(\n      renderedHeight < 400,\n      `pre-check: images will be rendered ~326px high in BackCompat mode, and ~588px in CSS1Compat mode; getting: ${renderedHeight}px`,\n    );\n    const rebuildRenderedHeight = await page.evaluate(`${code}\nconst snap = rrweb.snapshot(document);\nconst iframe = document.createElement('iframe');\niframe.setAttribute('width', document.body.clientWidth)\niframe.setAttribute('height', document.body.clientHeight)\niframe.style.transform = 'scale(0.3)'; // mini-me\ndocument.body.appendChild(iframe);\n// magic here! rebuild in a new iframe\nconst rebuildNode = rrweb.rebuild(snap, { doc: iframe.contentDocument })[0];\niframe.contentDocument.querySelector('center').clientHeight\n`);\n    const rebuildCompatMode = await page.evaluate(\n      'document.querySelector(\"iframe\").contentDocument.compatMode',\n    );\n    assert(\n      rebuildCompatMode === 'BackCompat',\n      \"rebuilt compatMode should match source compatMode, but doesn't: \" +\n        rebuildCompatMode,\n    );\n    assert(\n      rebuildRenderedHeight === renderedHeight,\n      'rebuilt height (${rebuildRenderedHeight}) should equal original height (${renderedHeight})',\n    );\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly saves images offline","suites":["integration tests"],"updatePoint":{"line":194,"column":36},"line":194,"code":"  it('correctly saves images offline', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto('http://localhost:3030/html/picture.html', {\n      waitUntil: 'load',\n    });\n    await page.waitForSelector('img', { timeout: 1000 });\n    await page.evaluate(`${code}var snapshot = rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false\n    })`);\n    await page.waitFor(100);\n    const snapshot = await page.evaluate('JSON.stringify(snapshot, null, 2);');\n    assert(snapshot.includes('\"rr_dataURL\"'));\n    assert(snapshot.includes('data:image/webp;base64,'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly saves blob:images offline","suites":["integration tests"],"updatePoint":{"line":212,"column":41},"line":212,"code":"  it('correctly saves blob:images offline', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto('http://localhost:3030/html/picture-blob.html', {\n      waitUntil: 'load',\n    });\n    await page.waitForSelector('img', { timeout: 1000 });\n    await page.evaluate(`${code}var snapshot = rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false\n    })`);\n    await page.waitFor(100);\n    const snapshot = await page.evaluate('JSON.stringify(snapshot, null, 2);');\n    assert(snapshot.includes('\"rr_dataURL\"'));\n    assert(snapshot.includes('data:image/webp;base64,'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly saves images in iframes offline","suites":["integration tests"],"updatePoint":{"line":230,"column":47},"line":230,"code":"  it('correctly saves images in iframes offline', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto('http://localhost:3030/html/picture-in-frame.html', {\n      waitUntil: 'load',\n    });\n    await page.waitForSelector('iframe', { timeout: 1000 });\n    await waitForRAF(page); // wait for page to render\n    await page.evaluate(`${code}\n        rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false,\n        onIframeLoad: function(iframe, sn) {\n          window.snapshot = sn;\n        }\n    })`);\n    await page.waitFor(100);\n    const snapshot = await page.evaluate(\n      'JSON.stringify(window.snapshot, null, 2);',\n    );\n    assert(snapshot.includes('\"rr_dataURL\"'));\n    assert(snapshot.includes('data:image/webp;base64,'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly saves blob:images in iframes offline","suites":["integration tests"],"updatePoint":{"line":255,"column":52},"line":255,"code":"  it('correctly saves blob:images in iframes offline', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto('http://localhost:3030/html/picture-blob-in-frame.html', {\n      waitUntil: 'load',\n    });\n    await page.waitForSelector('iframe', { timeout: 1000 });\n    await waitForRAF(page); // wait for page to render\n    await page.evaluate(`${code}\n        rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false,\n        onIframeLoad: function(iframe, sn) {\n          window.snapshot = sn;\n        }\n    })`);\n    await page.waitFor(100);\n    const snapshot = await page.evaluate(\n      'JSON.stringify(window.snapshot, null, 2);',\n    );\n    assert(snapshot.includes('\"rr_dataURL\"'));\n    assert(snapshot.includes('data:image/webp;base64,'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"snapshot async iframes","suites":["iframe integration tests"],"updatePoint":{"line":311,"column":28},"line":311,"code":"  it('snapshot async iframes', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    // console for debug\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`http://localhost:3030/iframe-html/main.html`, {\n      waitUntil: 'load',\n    });\n    const snapshotResult = JSON.stringify(\n      await page.evaluate(`${code};\n      rrweb.snapshot(document);\n    `),\n      null,\n      2,\n    );\n    expect(snapshotResult).toMatchSnapshot();\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"snapshot shadow DOM","suites":["shadow DOM integration tests"],"updatePoint":{"line":359,"column":25},"line":359,"code":"  it('snapshot shadow DOM', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    // console for debug\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`http://localhost:3030/html/shadow-dom.html`, {\n      waitUntil: 'load',\n    });\n    const snapshotResult = JSON.stringify(\n      await page.evaluate(`${code};\n      rrweb.snapshot(document);\n    `),\n      null,\n      2,\n    );\n    expect(snapshotResult).toMatchSnapshot();\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should rebuild dataURL","suites":["rebuild","rr_dataURL"],"updatePoint":{"line":25,"column":30},"line":25,"code":"    it('should rebuild dataURL', function () {\n      const dataURI =\n        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';\n      const node = buildNodeWithSN(\n        {\n          id: 1,\n          tagName: 'img',\n          type: NodeType.Element,\n          attributes: {\n            rr_dataURL: dataURI,\n            src: 'http://example.com/image.png',\n          },\n          childNodes: [],\n        },\n        {\n          doc: document,\n          mirror,\n          hackCss: false,\n          cache,\n        },\n      ) as HTMLImageElement;\n      expect(node?.src).toBe(dataURI);\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"will do nothing to css text without :hover","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":51,"column":50},"line":51,"code":"    it('will do nothing to css text without :hover', () => {\n      const cssText = 'body { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(cssText);\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class to css text","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":56,"column":39},"line":56,"code":"    it('can add hover class to css text', () => {\n      const cssText = '.a:hover { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        '.a:hover, .a.\\\\:hover { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class when there is multi selector","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":63,"column":56},"line":63,"code":"    it('can add hover class when there is multi selector', () => {\n      const cssText = '.a, .b:hover, .c { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        '.a, .b:hover, .b.\\\\:hover, .c { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class when there is a multi selector with the same prefix","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":70,"column":79},"line":70,"code":"    it('can add hover class when there is a multi selector with the same prefix', () => {\n      const cssText = '.a:hover, .a:hover::after { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        '.a:hover, .a.\\\\:hover, .a:hover::after, .a.\\\\:hover::after { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class when :hover is not the end of selector","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":77,"column":66},"line":77,"code":"    it('can add hover class when :hover is not the end of selector', () => {\n      const cssText = 'div:hover::after { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        'div:hover::after, div.\\\\:hover::after { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class when the selector has multi :hover","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":84,"column":62},"line":84,"code":"    it('can add hover class when the selector has multi :hover', () => {\n      const cssText = 'a:hover b:hover { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        'a:hover b:hover, a.\\\\:hover b.\\\\:hover { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"will ignore :hover in css value","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":91,"column":39},"line":91,"code":"    it('will ignore :hover in css value', () => {\n      const cssText = '.a::after { content: \":hover\" }';\n      expect(addHoverClass(cssText, cache)).toEqual(cssText);\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"benchmark","suites":["rebuild","add hover class to hover selector related rules"],"line":97,"code":"    it.skip('benchmark', () => {","file":"rebuild.test.ts","skipped":true,"dir":"packages/rrweb-snapshot/test"},{"name":"should be a lot faster to add a hover class to a previously processed css string","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":109,"column":88},"line":109,"code":"    it('should be a lot faster to add a hover class to a previously processed css string', () => {\n      const factor = 100;\n\n      let cssText = fs.readFileSync(\n        path.resolve(__dirname, './css/benchmark.css'),\n        'utf8',\n      );\n\n      const start = process.hrtime();\n      addHoverClass(cssText, cache);\n      const end = process.hrtime(start);\n\n      const cachedStart = process.hrtime();\n      addHoverClass(cssText, cache);\n      const cachedEnd = process.hrtime(cachedStart);\n\n      expect(getDuration(cachedEnd) * factor).toBeLessThan(getDuration(end));\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle relative path","suites":["absolute url to stylesheet"],"updatePoint":{"line":16,"column":30},"line":16,"code":"  it('can handle relative path', () => {\n    expect(absoluteToStylesheet('url(a.jpg)', href)).toEqual(\n      `url(http://localhost/css/a.jpg)`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle same level path","suites":["absolute url to stylesheet"],"updatePoint":{"line":22,"column":32},"line":22,"code":"  it('can handle same level path', () => {\n    expect(absoluteToStylesheet('url(\"./a.jpg\")', href)).toEqual(\n      `url(\"http://localhost/css/a.jpg\")`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle parent level path","suites":["absolute url to stylesheet"],"updatePoint":{"line":28,"column":34},"line":28,"code":"  it('can handle parent level path', () => {\n    expect(absoluteToStylesheet('url(\"../a.jpg\")', href)).toEqual(\n      `url(\"http://localhost/a.jpg\")`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle absolute path","suites":["absolute url to stylesheet"],"updatePoint":{"line":34,"column":30},"line":34,"code":"  it('can handle absolute path', () => {\n    expect(absoluteToStylesheet('url(\"/a.jpg\")', href)).toEqual(\n      `url(\"http://localhost/a.jpg\")`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle external path","suites":["absolute url to stylesheet"],"updatePoint":{"line":40,"column":30},"line":40,"code":"  it('can handle external path', () => {\n    expect(absoluteToStylesheet('url(\"http://localhost/a.jpg\")', href)).toEqual(\n      `url(\"http://localhost/a.jpg\")`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle single quote path","suites":["absolute url to stylesheet"],"updatePoint":{"line":46,"column":34},"line":46,"code":"  it('can handle single quote path', () => {\n    expect(absoluteToStylesheet(`url('./a.jpg')`, href)).toEqual(\n      `url('http://localhost/css/a.jpg')`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle no quote path","suites":["absolute url to stylesheet"],"updatePoint":{"line":52,"column":30},"line":52,"code":"  it('can handle no quote path', () => {\n    expect(absoluteToStylesheet('url(./a.jpg)', href)).toEqual(\n      `url(http://localhost/css/a.jpg)`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle multiple no quote paths","suites":["absolute url to stylesheet"],"updatePoint":{"line":58,"column":40},"line":58,"code":"  it('can handle multiple no quote paths', () => {\n    expect(\n      absoluteToStylesheet(\n        'background-image: url(images/b.jpg);background: #aabbcc url(images/a.jpg) 50% 50% repeat;',\n        href,\n      ),\n    ).toEqual(\n      `background-image: url(http://localhost/css/images/b.jpg);` +\n        `background: #aabbcc url(http://localhost/css/images/a.jpg) 50% 50% repeat;`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle data url image","suites":["absolute url to stylesheet"],"updatePoint":{"line":70,"column":31},"line":70,"code":"  it('can handle data url image', () => {\n    expect(\n      absoluteToStylesheet('url(data:image/gif;base64,ABC)', href),\n    ).toEqual('url(data:image/gif;base64,ABC)');\n    expect(\n      absoluteToStylesheet(\n        'url(data:application/font-woff;base64,d09GMgABAAAAAAm)',\n        href,\n      ),\n    ).toEqual('url(data:application/font-woff;base64,d09GMgABAAAAAAm)');\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"preserves quotes around inline svgs with spaces","suites":["absolute url to stylesheet"],"updatePoint":{"line":82,"column":53},"line":82,"code":"  it('preserves quotes around inline svgs with spaces', () => {\n    expect(\n      absoluteToStylesheet(\n        \"url(\\\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%2328a745' d='M3'/%3E%3C/svg%3E\\\")\",\n        href,\n      ),\n    ).toEqual(\n      \"url(\\\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%2328a745' d='M3'/%3E%3C/svg%3E\\\")\",\n    );\n    expect(\n      absoluteToStylesheet(\n        'url(\\'data:image/svg+xml;utf8,<svg width=\"28\" height=\"32\" viewBox=\"0 0 28 32\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27 14C28\" fill=\"white\"/></svg>\\')',\n        href,\n      ),\n    ).toEqual(\n      'url(\\'data:image/svg+xml;utf8,<svg width=\"28\" height=\"32\" viewBox=\"0 0 28 32\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27 14C28\" fill=\"white\"/></svg>\\')',\n    );\n    expect(\n      absoluteToStylesheet(\n        'url(\"data:image/svg+xml;utf8,<svg width=\"28\" height=\"32\" viewBox=\"0 0 28 32\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27 14C28\" fill=\"white\"/></svg>\")',\n        href,\n      ),\n    ).toEqual(\n      'url(\"data:image/svg+xml;utf8,<svg width=\"28\" height=\"32\" viewBox=\"0 0 28 32\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27 14C28\" fill=\"white\"/></svg>\")',\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle empty path","suites":["absolute url to stylesheet"],"updatePoint":{"line":108,"column":27},"line":108,"code":"  it('can handle empty path', () => {\n    expect(absoluteToStylesheet(`url('')`, href)).toEqual(`url('')`);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle empty elements","suites":["isBlockedElement()"],"updatePoint":{"line":120,"column":31},"line":120,"code":"  it('can handle empty elements', () => {\n    expect(subject('<div />')).toEqual(false);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"blocks prohibited className","suites":["isBlockedElement()"],"updatePoint":{"line":124,"column":33},"line":124,"code":"  it('blocks prohibited className', () => {\n    expect(subject('<div class=\"foo rr-block bar\" />')).toEqual(true);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"does not block random data selector","suites":["isBlockedElement()"],"updatePoint":{"line":128,"column":41},"line":128,"code":"  it('does not block random data selector', () => {\n    expect(subject('<div data-rr-block />')).toEqual(false);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"blocks blocked selector","suites":["isBlockedElement()"],"updatePoint":{"line":132,"column":29},"line":132,"code":"  it('blocks blocked selector', () => {\n    expect(\n      subject('<div data-rr-block />', { blockSelector: '[data-rr-block]' }),\n    ).toEqual(true);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should serialize all rules of stylesheet when the sheet has a single child node","suites":["style elements"],"updatePoint":{"line":161,"column":85},"line":161,"code":"  it('should serialize all rules of stylesheet when the sheet has a single child node', () => {\n    const styleEl = render(`<style>body { color: red; }</style>`);\n    styleEl.sheet?.insertRule('section { color: blue; }');\n    expect(serializeNode(styleEl.childNodes[0])).toMatchObject({\n      isStyle: true,\n      rootId: undefined,\n      textContent: 'section {color: blue;}body {color: red;}',\n      type: 3,\n    });\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should serialize individual text nodes on stylesheets with multiple child nodes","suites":["style elements"],"updatePoint":{"line":172,"column":85},"line":172,"code":"  it('should serialize individual text nodes on stylesheets with multiple child nodes', () => {\n    const styleEl = render(`<style>body { color: red; }</style>`);\n    styleEl.append(document.createTextNode('section { color: blue; }'));\n    expect(serializeNode(styleEl.childNodes[1])).toMatchObject({\n      isStyle: true,\n      rootId: undefined,\n      textContent: 'section { color: blue; }',\n      type: 3,\n    });\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should serialize scroll positions","suites":["scrollTop/scrollLeft"],"updatePoint":{"line":207,"column":39},"line":207,"code":"  it('should serialize scroll positions', () => {\n    const el = render(`<div stylel='overflow: auto; width: 1px; height: 1px;'>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n    </div>`);\n    el.scrollTop = 10;\n    el.scrollLeft = 20;\n    expect(serializeNode(el)).toMatchObject({\n      attributes: {\n        rr_scrollTop: 10,\n        rr_scrollLeft: 20,\n      },\n    });\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"will record and replay a webgl square","suites":["e2e webgl"],"updatePoint":{"line":82,"column":43},"line":82,"code":"  it('will record and replay a webgl square', async () => {\n    page = await browser.newPage();\n    await fakeGoto(page, `${serverURL}/html/canvas-webgl-square.html`);\n\n    await page.setContent(\n      getHtml.call(this, 'canvas-webgl-square.html', { recordCanvas: true }),\n    );\n\n    await waitForRAF(page);\n\n    const snapshots: eventWithTime[] = await page.evaluate('window.snapshots');\n\n    page = await browser.newPage();\n\n    await page.goto('about:blank');\n    await page.evaluate(code);\n\n    await hideMouseAnimation(page);\n    await page.evaluate(`let events = ${JSON.stringify(snapshots)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events, {\n        UNSAFE_replayCanvas: true,\n      });\n      replayer.play(500);\n    `);\n    await waitForRAF(page);\n\n    const element = await page.$('iframe');\n    const frameImage = await element!.screenshot();\n\n    expect(frameImage).toMatchImageSnapshot();\n  });","file":"e2e/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record and replay a webgl image","suites":["e2e webgl"],"updatePoint":{"line":116,"column":42},"line":116,"code":"  it('will record and replay a webgl image', async () => {\n    page = await browser.newPage();\n    await fakeGoto(page, `${serverURL}/html/canvas-webgl-image.html`);\n\n    await page.setContent(\n      getHtml.call(this, 'canvas-webgl-image.html', { recordCanvas: true }),\n    );\n\n    await page.waitForTimeout(100);\n    const snapshots: eventWithTime[] = await page.evaluate('window.snapshots');\n\n    page = await browser.newPage();\n\n    await page.goto('about:blank');\n    await page.evaluate(code);\n\n    await hideMouseAnimation(page);\n    await page.evaluate(`let events = ${JSON.stringify(snapshots)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events, {\n        UNSAFE_replayCanvas: true,\n      });\n    `);\n    // wait for iframe to get added and `preloadAllImages` to ge called\n    await page.waitForSelector('iframe');\n    await page.evaluate(`replayer.play(500);`);\n    await waitForRAF(page);\n\n    const element = await page.$('iframe');\n    const frameImage = await element!.screenshot();\n\n    expect(frameImage).toMatchImageSnapshot();\n  });","file":"e2e/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record form interactions","suites":["record integration tests"],"updatePoint":{"line":69,"column":34},"line":69,"code":"  it('can record form interactions', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'form.html'));\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('textarea', 'textarea test');\n    await page.select('select', '1');\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record childList mutations","suites":["record integration tests"],"updatePoint":{"line":84,"column":36},"line":84,"code":"  it('can record childList mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n      document.body.removeChild(ul);\n      const p = document.querySelector('p') as HTMLParagraphElement;\n      p.appendChild(document.createElement('span'));\n    });\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record character data muatations","suites":["record integration tests"],"updatePoint":{"line":102,"column":42},"line":102,"code":"  it('can record character data muatations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n      li.innerText = 'new list item';\n      li.innerText = 'new list item edit';\n      document.body.removeChild(ul);\n      const p = document.querySelector('p') as HTMLParagraphElement;\n      p.innerText = 'mutated';\n    });\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record attribute mutation","suites":["record integration tests"],"updatePoint":{"line":122,"column":35},"line":122,"code":"  it('can record attribute mutation', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n      li.setAttribute('foo', 'bar');\n      document.body.removeChild(ul);\n      document.body.setAttribute('test', 'true');\n    });\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record node mutations","suites":["record integration tests"],"updatePoint":{"line":140,"column":31},"line":140,"code":"  it('can record node mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'select2.html'), {\n      waitUntil: 'networkidle0',\n    });\n\n    // toggle the select box\n    await page.click('.select2-container', { clickCount: 2, delay: 100 });\n    // test storage of !important style\n    await page.evaluate(\n      'document.getElementById(\"select2-drop\").setAttribute(\"style\", document.getElementById(\"select2-drop\").style.cssText + \"color:black !important\")',\n    );\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can freeze mutations","suites":["record integration tests"],"updatePoint":{"line":157,"column":26},"line":157,"code":"  it('can freeze mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'mutation-observer.html', { recordCanvas: true }),\n    );\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n      li.setAttribute('foo', 'bar');\n      document.body.setAttribute('test', 'true');\n    });\n    await page.evaluate('rrweb.freezePage()');\n    await page.evaluate(() => {\n      document.body.setAttribute('test', 'bad');\n      const canvas = document.querySelector('canvas') as HTMLCanvasElement;\n      const gl = canvas.getContext('webgl') as WebGLRenderingContext;\n      gl.getExtension('bad');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      const li = document.createElement('li');\n      li.setAttribute('bad-attr', 'bad');\n      li.innerText = 'bad text';\n      ul.appendChild(li);\n      document.body.removeChild(ul);\n    });\n\n    await waitForRAF(page);\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record input events on ignored elements","suites":["record integration tests"],"updatePoint":{"line":191,"column":56},"line":191,"code":"  it('should not record input events on ignored elements', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'ignore.html'));\n\n    await page.type('.rr-ignore', 'secret');\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record input values if maskAllInputs is enabled","suites":["record integration tests"],"updatePoint":{"line":202,"column":64},"line":202,"code":"  it('should not record input values if maskAllInputs is enabled', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'form.html', { maskAllInputs: true }),\n    );\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('input[type=\"password\"]', 'password');\n    await page.type('textarea', 'textarea test');\n    await page.select('select', '1');\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can use maskInputOptions to configure which type of inputs should be masked","suites":["record integration tests"],"updatePoint":{"line":220,"column":81},"line":220,"code":"  it('can use maskInputOptions to configure which type of inputs should be masked', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'form.html', {\n        maskInputOptions: {\n          text: false,\n          textarea: false,\n          password: true,\n        },\n      }),\n    );\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('textarea', 'textarea test');\n    await page.type('input[type=\"password\"]', 'password');\n    await page.select('select', '1');\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should mask value attribute with maskInputOptions","suites":["record integration tests"],"updatePoint":{"line":244,"column":55},"line":244,"code":"  it('should mask value attribute with maskInputOptions', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'password.html', {\n        maskInputOptions: {\n          password: true,\n        },\n      }),\n    );\n\n    await page.type('input[type=\"password\"]', 'secr3t');\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record input userTriggered values if userTriggeredOnInput is enabled","suites":["record integration tests"],"updatePoint":{"line":261,"column":81},"line":261,"code":"  it('should record input userTriggered values if userTriggeredOnInput is enabled', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'form.html', { userTriggeredOnInput: true }),\n    );\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('input[type=\"password\"]', 'password');\n    await page.type('textarea', 'textarea test');\n    await page.select('select', '1');\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record blocked elements and its child nodes","suites":["record integration tests"],"updatePoint":{"line":279,"column":60},"line":279,"code":"  it('should not record blocked elements and its child nodes', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'block.html'));\n\n    await page.type('input', 'should not be record');\n    await page.evaluate(`document.getElementById('text').innerText = '1'`);\n    await page.click('#text');\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record blocked elements dynamically added","suites":["record integration tests"],"updatePoint":{"line":292,"column":58},"line":292,"code":"  it('should not record blocked elements dynamically added', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'block.html'));\n\n    await page.evaluate(() => {\n      const el = document.createElement('button');\n      el.className = 'rr-block';\n      el.style.width = '100px';\n      el.style.height = '100px';\n      el.innerText = 'Should not be recorded';\n\n      const nextElement = document.querySelector('.rr-block')!;\n      nextElement.parentNode!.insertBefore(el, nextElement);\n    });\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"mutations should work when blocked class is unblocked","suites":["record integration tests"],"updatePoint":{"line":312,"column":59},"line":312,"code":"  it('mutations should work when blocked class is unblocked', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about: blank');\n    await page.setContent(getHtml.call(this, 'blocked-unblocked.html'));\n\n    const elements1 = await page.$x('/html/body/div[1]/button');\n    await elements1[0].click();\n\n    const elements2 = await page.$x('/html/body/div[2]/button');\n    await elements2[0].click();\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record DOM node movement 1","suites":["record integration tests"],"updatePoint":{"line":327,"column":39},"line":327,"code":"  it('should record DOM node movement 1', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'move-node.html'));\n\n    await page.evaluate(() => {\n      const div = document.querySelector('div')!;\n      const p = document.querySelector('p')!;\n      const span = document.querySelector('span')!;\n      document.body.removeChild(span);\n      p.appendChild(span);\n      p.removeChild(span);\n      div.appendChild(span);\n    });\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record DOM node movement 2","suites":["record integration tests"],"updatePoint":{"line":345,"column":39},"line":345,"code":"  it('should record DOM node movement 2', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'move-node.html'));\n\n    await page.evaluate(() => {\n      const div = document.createElement('div');\n      const span = document.querySelector('span')!;\n      document.body.appendChild(div);\n      div.appendChild(span);\n    });\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record dynamic CSS changes","suites":["record integration tests"],"updatePoint":{"line":360,"column":39},"line":360,"code":"  it('should record dynamic CSS changes', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'react-styled-components.html'));\n    await page.click('.toggle');\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record canvas mutations","suites":["record integration tests"],"updatePoint":{"line":369,"column":36},"line":369,"code":"  it('should record canvas mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'canvas.html', {\n        recordCanvas: true,\n      }),\n    );\n    await waitForRAF(page);\n    const snapshots = await page.evaluate('window.snapshots');\n    for (const event of snapshots) {\n      if (event.type === EventType.FullSnapshot) {\n        visitSnapshot(event.data.node, (n) => {\n          if (n.type === NodeType.Element && n.attributes.rr_dataURL) {\n            n.attributes.rr_dataURL = `LOOKS LIKE WE COULD NOT GET STABLE BASE64 FROM SAME IMAGE.`;\n          }\n        });\n      }\n    }\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record webgl canvas mutations","suites":["record integration tests"],"updatePoint":{"line":391,"column":42},"line":391,"code":"  it('should record webgl canvas mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'canvas-webgl.html', {\n        recordCanvas: true,\n      }),\n    );\n    await page.waitForTimeout(50);\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will serialize node before record","suites":["record integration tests"],"updatePoint":{"line":404,"column":39},"line":404,"code":"  it('will serialize node before record', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      let count = 3;\n      while (count > 0) {\n        count--;\n        const li = document.createElement('li');\n        ul.appendChild(li);\n      }\n    });\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will defer missing next node mutation","suites":["record integration tests"],"updatePoint":{"line":423,"column":43},"line":423,"code":"  it('will defer missing next node mutation', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'shuffle.html'));\n\n    const text = await page.evaluate(() => {\n      const els = Array.prototype.slice.call(document.querySelectorAll('li'));\n      const parent = document.querySelector('ul')!;\n      parent.removeChild(els[3]);\n      parent.removeChild(els[2]);\n      parent.removeChild(els[1]);\n      parent.removeChild(els[0]);\n      parent.insertBefore(els[3], els[4]);\n      parent.insertBefore(els[2], els[4]);\n      parent.insertBefore(els[1], els[4]);\n      parent.insertBefore(els[0], els[4]);\n      return parent.innerText;\n    });\n\n    expect(text).toEqual('4\\n3\\n2\\n1\\n5');\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record console messages","suites":["record integration tests"],"updatePoint":{"line":445,"column":36},"line":445,"code":"  it('should record console messages', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml('log.html', {\n        plugins: ('[rrwebConsoleRecord.getRecordConsolePlugin()]' as unknown) as RecordPlugin<unknown>[],\n      }),\n    );\n\n    await page.evaluate(() => {\n      console.assert(0 === 0, 'assert');\n      console.count('count');\n      console.countReset('count');\n      console.debug('debug');\n      console.dir('dir');\n      console.dirxml('dirxml');\n      console.group();\n      console.groupCollapsed();\n      console.info('info');\n      console.log('log');\n      console.table('table');\n      console.time();\n      console.timeEnd();\n      console.timeLog();\n      console.trace('trace');\n      console.warn('warn');\n      console.clear();\n      console.log(new TypeError('a message'));\n      const iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n    });\n\n    await page.frames()[1].evaluate(() => {\n      console.log('from iframe');\n    });\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should nest record iframe","suites":["record integration tests"],"updatePoint":{"line":485,"column":31},"line":485,"code":"  it('should nest record iframe', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto(`${serverURL}/html`);\n    await page.setContent(getHtml.call(this, 'main.html'));\n\n    await page.waitForSelector('#two');\n    const frameIdTwo = await page.frames()[2];\n    await frameIdTwo.waitForSelector('#four');\n    const frameIdFour = frameIdTwo.childFrames()[1];\n    await frameIdFour.waitForSelector('#five');\n\n    await page.waitForTimeout(50);\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record images with blob url","suites":["record integration tests"],"updatePoint":{"line":502,"column":40},"line":502,"code":"  it('should record images with blob url', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`${serverURL}/html`);\n    page.setContent(\n      getHtml.call(this, 'image-blob-url.html', { inlineImages: true }),\n    );\n    await page.waitForResponse(`${serverURL}/html/assets/robot.png`);\n    await page.waitForSelector('img'); // wait for image to get added\n    await waitForRAF(page); // wait for image to be captured\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record images inside iframe with blob url","suites":["record integration tests"],"updatePoint":{"line":517,"column":54},"line":517,"code":"  it('should record images inside iframe with blob url', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`${serverURL}/html`);\n    await page.setContent(\n      getHtml.call(this, 'frame-image-blob-url.html', { inlineImages: true }),\n    );\n    await page.waitForResponse(`${serverURL}/html/assets/robot.png`);\n    await page.waitForTimeout(50); // wait for image to get added\n    await waitForRAF(page); // wait for image to be captured\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record images inside iframe with blob url after iframe was reloaded","suites":["record integration tests"],"updatePoint":{"line":532,"column":80},"line":532,"code":"  it('should record images inside iframe with blob url after iframe was reloaded', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`${serverURL}/html`);\n    await page.setContent(\n      getHtml.call(this, 'frame2.html', { inlineImages: true }),\n    );\n    await page.waitForSelector('iframe'); // wait for iframe to get added\n    await waitForRAF(page); // wait for iframe to load\n    page.evaluate(() => {\n      const iframe = document.querySelector('iframe')!;\n      iframe.setAttribute('src', '/html/image-blob-url.html');\n    });\n    await page.waitForResponse(`${serverURL}/html/assets/robot.png`); // wait for image to get loaded\n    await page.waitForTimeout(50); // wait for image to get added\n    await waitForRAF(page); // wait for image to be captured\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record shadow DOM","suites":["record integration tests"],"updatePoint":{"line":553,"column":30},"line":553,"code":"  it('should record shadow DOM', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'shadow-dom.html'));\n\n    await page.evaluate(() => {\n      const sleep = (ms: number) =>\n        new Promise((resolve) => setTimeout(resolve, ms));\n\n      const el = document.querySelector('.my-element') as HTMLDivElement;\n      const shadowRoot = el.shadowRoot as ShadowRoot;\n      shadowRoot.appendChild(document.createElement('span'));\n      shadowRoot.appendChild(document.createElement('p'));\n      sleep(1)\n        .then(() => {\n          shadowRoot.lastChild!.appendChild(document.createElement('p'));\n          return sleep(1);\n        })\n        .then(() => {\n          const firstP = shadowRoot.querySelector('p') as HTMLParagraphElement;\n          shadowRoot.removeChild(firstP);\n          return sleep(1);\n        })\n        .then(() => {\n          (shadowRoot.lastChild!.childNodes[0] as HTMLElement).innerText = 'hi';\n          return sleep(1);\n        })\n        .then(() => {\n          (shadowRoot.lastChild!.childNodes[0] as HTMLElement).innerText =\n            '123';\n          const nestedShadowElement = shadowRoot.lastChild!\n            .childNodes[0] as HTMLElement;\n          nestedShadowElement.attachShadow({\n            mode: 'open',\n          });\n          nestedShadowElement.shadowRoot!.appendChild(\n            document.createElement('span'),\n          );\n          (nestedShadowElement.shadowRoot!.lastChild as HTMLElement).innerText =\n            'nested shadow dom';\n        });\n    });\n    await page.waitForTimeout(50);\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record nested iframes and shadow doms","suites":["record integration tests"],"updatePoint":{"line":601,"column":50},"line":601,"code":"  it('should record nested iframes and shadow doms', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'frame2.html'));\n\n    await page.waitForTimeout(10); // wait till frame was added to dom\n    await waitForRAF(page); // wait till browser loaded contents of frame\n\n    await page.evaluate(() => {\n      // get contentDocument of iframe five\n      const contentDocument1 = document.querySelector('iframe')!\n        .contentDocument!;\n      // create shadow dom #1\n      contentDocument1.body.attachShadow({ mode: 'open' });\n      contentDocument1.body.shadowRoot!.appendChild(\n        document.createElement('div'),\n      );\n      const div = contentDocument1.body.shadowRoot!.childNodes[0];\n      const iframe = contentDocument1.createElement('iframe');\n      // append an iframe to shadow dom #1\n      div.appendChild(iframe);\n    });\n\n    await waitForRAF(page); // wait till browser loaded contents of frame\n\n    page.evaluate(() => {\n      const iframe: HTMLIFrameElement = document\n        .querySelector('iframe')!\n        .contentDocument!.body.shadowRoot!.querySelector('iframe')!;\n\n      const contentDocument2 = iframe.contentDocument!;\n      // create shadow dom #2 in the iframe\n      contentDocument2.body.attachShadow({ mode: 'open' });\n      contentDocument2.body.shadowRoot!.appendChild(\n        document.createElement('span'),\n      );\n    });\n    await waitForRAF(page); // wait till browser sent snapshots\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record mutations in iframes accross pages","suites":["record integration tests"],"updatePoint":{"line":644,"column":54},"line":644,"code":"  it('should record mutations in iframes accross pages', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto(`${serverURL}/html`);\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.setContent(getHtml.call(this, 'frame2.html'));\n\n    await page.waitForSelector('iframe'); // wait for iframe to get added\n    await waitForRAF(page); // wait for iframe to load\n\n    page.evaluate((serverURL) => {\n      const iframe = document.querySelector('iframe')!;\n      iframe.setAttribute('src', `${serverURL}/html`); // load new page\n    }, serverURL);\n\n    await page.waitForResponse(`${serverURL}/html`); // wait for iframe to load pt1\n    await waitForRAF(page); // wait for iframe to load pt2\n\n    await page.evaluate(() => {\n      const iframeDocument = document.querySelector('iframe')!.contentDocument!;\n      const div = iframeDocument.createElement('div');\n      iframeDocument.body.appendChild(div);\n    });\n\n    await waitForRAF(page); // wait for snapshot to be updated\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record shadow doms polyfilled by shadydom","suites":["record integration tests"],"updatePoint":{"line":673,"column":54},"line":673,"code":"  it('should record shadow doms polyfilled by shadydom', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      // insert shadydom script\n      replaceLast(\n        getHtml.call(this, 'polyfilled-shadowdom-mutation.html'),\n        '<head>',\n        `\n        <head>\n        <script>\n          // To force ShadyDOM to be used even when native ShadowDOM is available, set the ShadyDOM = {force: true} in a script prior to loading the polyfill.\n          window.ShadyDOM = { force: true };\n        </script>\n        <script src=\"https://cdn.jsdelivr.net/npm/@webcomponents/shadydom@1.9.0/shadydom.min.js\"></script>\n    `,\n      ),\n    );\n    await page.evaluate(() => {\n      const target3 = document.querySelector('#target3');\n      target3?.attachShadow({\n        mode: 'open',\n      });\n      target3?.shadowRoot?.appendChild(document.createElement('span'));\n    });\n    await waitForRAF(page); // wait till browser sent snapshots\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record shadow doms polyfilled by synthetic-shadow","suites":["record integration tests"],"updatePoint":{"line":705,"column":62},"line":705,"code":"  it('should record shadow doms polyfilled by synthetic-shadow', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      // insert lwc's synthetic-shadow script\n      replaceLast(\n        getHtml.call(this, 'polyfilled-shadowdom-mutation.html'),\n        '<head>',\n        `\n        <head>\n        <script>var process = {env: {NODE_ENV: \"production\"}};</script>\n        <script src=\"https://cdn.jsdelivr.net/npm/@lwc/synthetic-shadow@2.20.3/dist/synthetic-shadow.js\"></script>\n      `,\n      ),\n    );\n    await page.evaluate(() => {\n      const target3 = document.querySelector('#target3');\n      // create a shadow dom with synthetic shadow\n      // https://github.com/salesforce/lwc/blob/v2.20.3/packages/@lwc/synthetic-shadow/src/faux-shadow/element.ts#L81-L87\n      target3?.attachShadow({\n        mode: 'open',\n        '$$lwc-synthetic-mode': true,\n      } as ShadowRootInit);\n      target3?.shadowRoot?.appendChild(document.createElement('span'));\n      const target4 = document.createElement('div');\n      target4.id = 'target4';\n      // create a native shadow dom\n      document.body.appendChild(target4);\n      target4.attachShadow({\n        mode: 'open',\n      });\n      target4.shadowRoot?.appendChild(document.createElement('ul'));\n    });\n    await waitForRAF(page); // wait till browser sent snapshots\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should mask texts","suites":["record integration tests"],"updatePoint":{"line":744,"column":23},"line":744,"code":"  it('should mask texts', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'mask-text.html', {\n        maskTextSelector: '[data-masking=\"true\"]',\n      }),\n    );\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should mask texts using maskTextFn","suites":["record integration tests"],"updatePoint":{"line":757,"column":40},"line":757,"code":"  it('should mask texts using maskTextFn', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'mask-text.html', {\n        maskTextSelector: '[data-masking=\"true\"]',\n        maskTextFn: (t: string) => t.replace(/[a-z]/g, '*'),\n      }),\n    );\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can mask character data mutations","suites":["record integration tests"],"updatePoint":{"line":771,"column":39},"line":771,"code":"  it('can mask character data mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      const p = document.querySelector('p') as HTMLParagraphElement;\n      [li, p].forEach((element) => {\n        element.className = 'rr-mask';\n      });\n      ul.appendChild(li);\n      li.innerText = 'new list item';\n      p.innerText = 'mutated';\n    });\n\n    const snapshots = await page.evaluate('window.snapshots');\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will return all the events when there is only one session","suites":["get last session"],"updatePoint":{"line":18,"column":63},"line":18,"code":"  it('will return all the events when there is only one session', () => {\n    expect(discardPriorSnapshots(events, events[0].timestamp)).toEqual(events);\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will return last session when there is more than one in the events","suites":["get last session"],"updatePoint":{"line":22,"column":72},"line":22,"code":"  it('will return last session when there is more than one in the events', () => {\n    const multiple = events.concat(nextEvents).concat(nextNextEvents);\n    expect(\n      discardPriorSnapshots(\n        multiple,\n        nextNextEvents[nextNextEvents.length - 1].timestamp,\n      ),\n    ).toEqual(nextNextEvents);\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will return last session when baseline time is future time","suites":["get last session"],"updatePoint":{"line":32,"column":64},"line":32,"code":"  it('will return last session when baseline time is future time', () => {\n    const multiple = events.concat(nextEvents).concat(nextNextEvents);\n    expect(\n      discardPriorSnapshots(\n        multiple,\n        nextNextEvents[nextNextEvents.length - 1].timestamp + 1000,\n      ),\n    ).toEqual(nextNextEvents);\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will return all sessions when baseline time is prior time","suites":["get last session"],"updatePoint":{"line":42,"column":63},"line":42,"code":"  it('will return all sessions when baseline time is prior time', () => {\n    expect(discardPriorSnapshots(events, events[0].timestamp - 1000)).toEqual(\n      events,\n    );\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can pack event","suites":["pack"],"updatePoint":{"line":12,"column":20},"line":12,"code":"  it('can pack event', () => {\n    const packedData = pack(event);\n    expect(packedData).toMatchSnapshot();\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"is compatible with unpacked data 1","suites":["unpack"],"updatePoint":{"line":19,"column":40},"line":19,"code":"  it('is compatible with unpacked data 1', () => {\n    const result = unpack((event as unknown) as string);\n    expect(result).toEqual(event);\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"is compatible with unpacked data 2","suites":["unpack"],"updatePoint":{"line":24,"column":40},"line":24,"code":"  it('is compatible with unpacked data 2', () => {\n    const result = unpack(JSON.stringify(event));\n    expect(result).toEqual(event);\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"stop on unknown data format","suites":["unpack"],"updatePoint":{"line":29,"column":33},"line":29,"code":"  it('stop on unknown data format', () => {\n    const consoleSpy = jest\n      .spyOn(console, 'error')\n      .mockImplementation(() => {});\n\n    expect(() => unpack('[\"\"]')).toThrow('');\n\n    expect(consoleSpy).toHaveBeenCalled();\n    jest.resetAllMocks();\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can unpack packed data","suites":["unpack"],"updatePoint":{"line":40,"column":28},"line":40,"code":"  it('can unpack packed data', () => {\n    const packedData = pack(event);\n    const result = unpack(packedData);\n    expect(result).toEqual({\n      ...event,\n      v: MARK,\n    });\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will only have one full snapshot without checkout config","suites":["record"],"updatePoint":{"line":86,"column":62},"line":86,"code":"  it('will only have one full snapshot without checkout config', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n      });\n    });\n    let count = 30;\n    while (count--) {\n      await ctx.page.type('input', 'a');\n    }\n    await ctx.page.waitForTimeout(10);\n    expect(ctx.events.length).toEqual(33);\n    expect(\n      ctx.events.filter((event: eventWithTime) => event.type === EventType.Meta)\n        .length,\n    ).toEqual(1);\n    expect(\n      ctx.events.filter(\n        (event: eventWithTime) => event.type === EventType.FullSnapshot,\n      ).length,\n    ).toEqual(1);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can checkout full snapshot by count","suites":["record"],"updatePoint":{"line":110,"column":41},"line":110,"code":"  it('can checkout full snapshot by count', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n        checkoutEveryNth: 10,\n      });\n    });\n    let count = 30;\n    while (count--) {\n      await ctx.page.type('input', 'a');\n    }\n    await ctx.page.waitForTimeout(10);\n    expect(ctx.events.length).toEqual(39);\n    expect(\n      ctx.events.filter((event: eventWithTime) => event.type === EventType.Meta)\n        .length,\n    ).toEqual(4);\n    expect(\n      ctx.events.filter(\n        (event: eventWithTime) => event.type === EventType.FullSnapshot,\n      ).length,\n    ).toEqual(4);\n    expect(ctx.events[1].type).toEqual(EventType.FullSnapshot);\n    expect(ctx.events[13].type).toEqual(EventType.FullSnapshot);\n    expect(ctx.events[25].type).toEqual(EventType.FullSnapshot);\n    expect(ctx.events[37].type).toEqual(EventType.FullSnapshot);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can checkout full snapshot by time","suites":["record"],"updatePoint":{"line":139,"column":40},"line":139,"code":"  it('can checkout full snapshot by time', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n        checkoutEveryNms: 500,\n      });\n    });\n    await ctx.page.type('input', 'a');\n    await ctx.page.waitForTimeout(300);\n    expect(\n      ctx.events.filter((event: eventWithTime) => event.type === EventType.Meta)\n        .length,\n    ).toEqual(1); // before first automatic snapshot\n    expect(\n      ctx.events.filter(\n        (event: eventWithTime) => event.type === EventType.FullSnapshot,\n      ).length,\n    ).toEqual(1); // before first automatic snapshot\n    await ctx.page.waitForTimeout(200);\n    await ctx.page.type('input', 'a');\n    await ctx.page.waitForTimeout(10);\n    expect(\n      ctx.events.filter((event: eventWithTime) => event.type === EventType.Meta)\n        .length,\n    ).toEqual(2);\n    expect(\n      ctx.events.filter(\n        (event: eventWithTime) => event.type === EventType.FullSnapshot,\n      ).length,\n    ).toEqual(2);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"is safe to checkout during async callbacks","suites":["record"],"updatePoint":{"line":172,"column":48},"line":172,"code":"  it('is safe to checkout during async callbacks', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n        checkoutEveryNth: 2,\n      });\n      const p = document.createElement('p');\n      const span = document.createElement('span');\n      setTimeout(() => {\n        document.body.appendChild(p);\n        p.appendChild(span);\n        document.body.removeChild(document.querySelector('input')!);\n      }, 0);\n      setTimeout(() => {\n        span.innerText = 'test';\n      }, 10);\n      setTimeout(() => {\n        p.removeChild(span);\n        document.body.appendChild(span);\n      }, 10);\n    });\n    await ctx.page.waitForTimeout(100);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record scroll position","suites":["record"],"updatePoint":{"line":198,"column":35},"line":198,"code":"  it('should record scroll position', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n      });\n      const p = document.createElement('p');\n      p.innerText = 'testtesttesttesttesttesttesttesttesttest';\n      p.setAttribute('style', 'overflow: auto; height: 1px; width: 1px;');\n      document.body.appendChild(p);\n      p.scrollTop = 10;\n      p.scrollLeft = 10;\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record selection event","suites":["record"],"updatePoint":{"line":215,"column":35},"line":215,"code":"  it('should record selection event', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n      });\n      const startNode = document.createElement('p');\n\n      startNode.innerText =\n        'Lorem ipsum dolor sit amet consectetur adipisicing elit.';\n\n      const endNode = document.createElement('span');\n      endNode.innerText =\n        'nihil ipsum officiis pariatur laboriosam quas,corrupti vero vitae minus.';\n\n      document.body.appendChild(startNode);\n      document.body.appendChild(endNode);\n\n      const selection = window.getSelection();\n      const range = new Range();\n\n      range.setStart(startNode!.firstChild!, 10);\n      range.setEnd(endNode!.firstChild!, 2);\n\n      selection?.addRange(range);\n    });\n    await waitForRAF(ctx.page);\n    const selectionData = ctx.events\n      .filter(({ type, data }) => {\n        return (\n          type === EventType.IncrementalSnapshot &&\n          data.source === IncrementalSource.Selection\n        );\n      })\n      .map((ev) => ev.data as selectionData);\n\n    expect(selectionData.length).toEqual(1);\n    expect(selectionData[0].ranges[0].startOffset).toEqual(10);\n    expect(selectionData[0].ranges[0].endOffset).toEqual(2);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can add custom event","suites":["record"],"updatePoint":{"line":256,"column":26},"line":256,"code":"  it('can add custom event', async () => {\n    await ctx.page.evaluate(() => {\n      const { record, addCustomEvent } = ((window as unknown) as IWindow).rrweb;\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n      });\n      addCustomEvent<number>('tag1', 1);\n      addCustomEvent<{ a: string }>('tag2', {\n        a: 'b',\n      });\n    });\n    await ctx.page.waitForTimeout(50);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheet rules","suites":["record"],"updatePoint":{"line":271,"column":31},"line":271,"code":"  it('captures stylesheet rules', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n      });\n\n      const styleElement = document.createElement('style');\n      document.head.appendChild(styleElement);\n\n      const styleSheet = <CSSStyleSheet>styleElement.sheet;\n      // begin: pre-serialization\n      const ruleIdx0 = styleSheet.insertRule('body { background: #000; }');\n      const ruleIdx1 = styleSheet.insertRule('body { background: #111; }');\n      styleSheet.deleteRule(ruleIdx1);\n      // end: pre-serialization\n      setTimeout(() => {\n        styleSheet.insertRule('body { color: #fff; }');\n      }, 0);\n      setTimeout(() => {\n        styleSheet.deleteRule(ruleIdx0);\n      }, 5);\n      setTimeout(() => {\n        styleSheet.insertRule('body { color: #ccc; }');\n      }, 10);\n    });\n    await ctx.page.waitForTimeout(50);\n    const styleSheetRuleEvents = ctx.events.filter(\n      (e) =>\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.StyleSheetRule,\n    );\n    const addRules = styleSheetRuleEvents.filter((e) =>\n      Boolean((e.data as styleSheetRuleData).adds),\n    );\n    const removeRuleCount = styleSheetRuleEvents.filter((e) =>\n      Boolean((e.data as styleSheetRuleData).removes),\n    ).length;\n    // pre-serialization insert/delete should be ignored\n    expect(addRules.length).toEqual(2);\n    expect((addRules[0].data as styleSheetRuleData).adds).toEqual([\n      {\n        rule: 'body { color: #fff; }',\n      },\n    ]);\n    expect(removeRuleCount).toEqual(1);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures nested stylesheet rules","suites":["record"],"updatePoint":{"line":366,"column":38},"line":366,"code":"  it('captures nested stylesheet rules', captureNestedStylesheetRulesTest);","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures nested stylesheet rules","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":379,"column":40},"line":379,"code":"    it('captures nested stylesheet rules', captureNestedStylesheetRulesTest);","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures style property changes","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":382,"column":37},"line":382,"code":"  it('captures style property changes', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n        ignoreCSSAttributes: new Set(['color']),\n      });\n\n      const styleElement = document.createElement('style');\n      document.head.appendChild(styleElement);\n\n      const styleSheet = <CSSStyleSheet>styleElement.sheet;\n      styleSheet.insertRule('body { background: #000; }');\n      setTimeout(() => {\n        // should be ignored\n        (styleSheet.cssRules[0] as CSSStyleRule).style.setProperty(\n          'color',\n          'green',\n        );\n\n        // should be captured because we did not block it\n        (styleSheet.cssRules[0] as CSSStyleRule).style.setProperty(\n          'border-color',\n          'green',\n        );\n\n        (styleSheet.cssRules[0] as CSSStyleRule).style.removeProperty(\n          'background',\n        );\n      }, 0);\n    });\n    await ctx.page.waitForTimeout(50);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures inserted style text nodes correctly","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":418,"column":50},"line":418,"code":"  it('captures inserted style text nodes correctly', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n\n      const styleEl = document.createElement(`style`);\n      styleEl.append(document.createTextNode('div { color: red; }'));\n      styleEl.append(document.createTextNode('section { color: blue; }'));\n      document.head.appendChild(styleEl);\n\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n      });\n\n      styleEl.append(document.createTextNode('span { color: orange; }'));\n      styleEl.append(document.createTextNode('h1 { color: pink; }'));\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheets with `blob:` url","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":438,"column":43},"line":438,"code":"  it('captures stylesheets with `blob:` url', async () => {\n    await ctx.page.evaluate(() => {\n      const link1 = document.createElement('link');\n      link1.setAttribute('rel', 'stylesheet');\n      link1.setAttribute(\n        'href',\n        URL.createObjectURL(\n          new Blob(['body { color: pink; }'], {\n            type: 'text/css',\n          }),\n        ),\n      );\n      document.head.appendChild(link1);\n    });\n    await waitForRAF(ctx.page);\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n\n      record({\n        inlineStylesheet: true,\n        emit: ((window as unknown) as IWindow).emit,\n      });\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheets in iframes with `blob:` url","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":465,"column":54},"line":465,"code":"  it('captures stylesheets in iframes with `blob:` url', async () => {\n    await ctx.page.evaluate(() => {\n      const iframe = document.createElement('iframe');\n      iframe.setAttribute('src', 'about:blank');\n      document.body.appendChild(iframe);\n\n      const linkEl = document.createElement('link');\n      linkEl.setAttribute('rel', 'stylesheet');\n      linkEl.setAttribute(\n        'href',\n        URL.createObjectURL(\n          new Blob(['body { color: pink; }'], {\n            type: 'text/css',\n          }),\n        ),\n      );\n      const iframeDoc = iframe.contentDocument!;\n      iframeDoc.head.appendChild(linkEl);\n    });\n    await waitForRAF(ctx.page);\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n\n      record({\n        inlineStylesheet: true,\n        emit: ((window as unknown) as IWindow).emit,\n      });\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheets that are still loading","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":497,"column":49},"line":497,"code":"  it('captures stylesheets that are still loading', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n\n      record({\n        inlineStylesheet: true,\n        emit: ((window as unknown) as IWindow).emit,\n      });\n\n      const link1 = document.createElement('link');\n      link1.setAttribute('rel', 'stylesheet');\n      link1.setAttribute(\n        'href',\n        URL.createObjectURL(\n          new Blob(['body { color: pink; }'], {\n            type: 'text/css',\n          }),\n        ),\n      );\n      document.head.appendChild(link1);\n    });\n\n    // `blob:` URLs are not available immediately, so we need to wait for the browser to load them\n    await waitForRAF(ctx.page);\n\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheets in iframes that are still loading","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":525,"column":60},"line":525,"code":"  it('captures stylesheets in iframes that are still loading', async () => {\n    await ctx.page.evaluate(() => {\n      const iframe = document.createElement('iframe');\n      iframe.setAttribute('src', 'about:blank');\n      document.body.appendChild(iframe);\n      const iframeDoc = iframe.contentDocument!;\n\n      const { record } = ((window as unknown) as IWindow).rrweb;\n\n      record({\n        inlineStylesheet: true,\n        emit: ((window as unknown) as IWindow).emit,\n      });\n\n      const linkEl = document.createElement('link');\n      linkEl.setAttribute('rel', 'stylesheet');\n      linkEl.setAttribute(\n        'href',\n        URL.createObjectURL(\n          new Blob(['body { color: pink; }'], {\n            type: 'text/css',\n          }),\n        ),\n      );\n      iframeDoc.head.appendChild(linkEl);\n    });\n\n    // `blob:` URLs are not available immediately, so we need to wait for the browser to load them\n    await waitForRAF(ctx.page);\n\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures CORS stylesheets that are still loading","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":558,"column":54},"line":558,"code":"  it('captures CORS stylesheets that are still loading', async () => {\n    const corsStylesheetURL =\n      'https://cdn.jsdelivr.net/npm/pure@2.85.0/index.css';\n\n    // do not `await` the following function, otherwise `waitForResponse` _might_ not be called\n    void ctx.page.evaluate((corsStylesheetURL) => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n\n      record({\n        inlineStylesheet: true,\n        emit: ((window as unknown) as IWindow).emit,\n      });\n\n      const link1 = document.createElement('link');\n      link1.setAttribute('rel', 'stylesheet');\n      link1.setAttribute('href', corsStylesheetURL);\n      document.head.appendChild(link1);\n    }, corsStylesheetURL);\n\n    await ctx.page.waitForResponse(corsStylesheetURL); // wait for stylesheet to be loaded\n    await waitForRAF(ctx.page); // wait for rrweb to emit events\n\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures iframe content in correct order","suites":["record iframes"],"updatePoint":{"line":599,"column":46},"line":599,"code":"  it('captures iframe content in correct order', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n      record({\n        emit: ((window as unknown) as IWindow).emit,\n      });\n    });\n    await waitForRAF(ctx.page);\n    // console.log(JSON.stringify(ctx.events));\n\n    expect(ctx.events.length).toEqual(3);\n    const eventTypes = ctx.events\n      .filter(\n        (e) =>\n          e.type === EventType.IncrementalSnapshot ||\n          e.type === EventType.FullSnapshot,\n      )\n      .map((e) => e.type);\n    expect(eventTypes).toEqual([\n      EventType.FullSnapshot,\n      EventType.IncrementalSnapshot,\n    ]);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheet mutations in iframes","suites":["record iframes"],"updatePoint":{"line":623,"column":46},"line":623,"code":"  it('captures stylesheet mutations in iframes', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = ((window as unknown) as IWindow).rrweb;\n      record({\n        // need to reference window.top for when we are in an iframe!\n        emit: ((window.top as unknown) as IWindow).emit,\n      });\n\n      const iframe = document.querySelector('iframe');\n      // outer timeout is needed to wait for initStyleSheetObserver on iframe to be set up\n      setTimeout(() => {\n        const idoc = (iframe as HTMLIFrameElement).contentDocument!;\n        const styleElement = idoc.createElement('style');\n\n        idoc.head.appendChild(styleElement);\n\n        const styleSheet = <CSSStyleSheet>styleElement.sheet;\n        styleSheet.insertRule('@media {}');\n        const atMediaRule = styleSheet.cssRules[0] as CSSMediaRule;\n        const atRuleIdx0 = atMediaRule.insertRule(\n          'body { background: #000; }',\n          0,\n        );\n        const ruleIdx0 = styleSheet.insertRule('body { background: #000; }'); // inserted before above\n        // pre-serialization insert/delete above should be ignored\n        setTimeout(() => {\n          styleSheet.insertRule('body { color: #fff; }');\n          atMediaRule.insertRule('body { color: #ccc; }', 0);\n        }, 0);\n        setTimeout(() => {\n          styleSheet.deleteRule(ruleIdx0);\n          (styleSheet.cssRules[0] as CSSStyleRule).style.setProperty(\n            'color',\n            'green',\n          );\n        }, 5);\n        setTimeout(() => {\n          atMediaRule.deleteRule(atRuleIdx0);\n        }, 10);\n      }, 10);\n    });\n    await ctx.page.waitForTimeout(50); // wait till setTimeout is called\n    await waitForRAF(ctx.page); // wait till events get sent\n    const styleRelatedEvents = ctx.events.filter(\n      (e) =>\n        e.type === EventType.IncrementalSnapshot &&\n        (e.data.source === IncrementalSource.StyleSheetRule ||\n          e.data.source === IncrementalSource.StyleDeclaration),\n    );\n    const addRuleCount = styleRelatedEvents.filter((e) =>\n      Boolean((e.data as styleSheetRuleData).adds),\n    ).length;\n    const removeRuleCount = styleRelatedEvents.filter((e) =>\n      Boolean((e.data as styleSheetRuleData).removes),\n    ).length;\n    expect(styleRelatedEvents.length).toEqual(5);\n    expect(addRuleCount).toEqual(2);\n    expect(removeRuleCount).toEqual(2);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize Float32Array values","suites":["serializeArg"],"updatePoint":{"line":19,"column":42},"line":19,"code":"  it('should serialize Float32Array values', async () => {\n    const float32Array = new Float32Array([-1, -1, 3, -1, -1, 3]);\n    const expected = {\n      rr_type: 'Float32Array',\n      args: [[-1, -1, 3, -1, -1, 3]],\n    };\n    expect(serializeArg(float32Array, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize Float64Array values","suites":["serializeArg"],"updatePoint":{"line":28,"column":42},"line":28,"code":"  it('should serialize Float64Array values', async () => {\n    const float64Array = new Float64Array([-1, -1, 3, -1, -1, 3]);\n    const expected = {\n      rr_type: 'Float64Array',\n      args: [[-1, -1, 3, -1, -1, 3]],\n    };\n\n    expect(serializeArg(float64Array, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize ArrayBuffer values","suites":["serializeArg"],"updatePoint":{"line":38,"column":41},"line":38,"code":"  it('should serialize ArrayBuffer values', async () => {\n    const arrayBuffer = new Uint8Array([1, 2, 0, 4]).buffer;\n    const expected = {\n      rr_type: 'ArrayBuffer',\n      base64: 'AQIABA==',\n    };\n\n    expect(serializeArg(arrayBuffer, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize Uint8Array values","suites":["serializeArg"],"updatePoint":{"line":48,"column":40},"line":48,"code":"  it('should serialize Uint8Array values', async () => {\n    const object = new Uint8Array([1, 2, 0, 4]);\n    const expected = {\n      rr_type: 'Uint8Array',\n      args: [[1, 2, 0, 4]],\n    };\n\n    expect(serializeArg(object, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize DataView values","suites":["serializeArg"],"updatePoint":{"line":58,"column":38},"line":58,"code":"  it('should serialize DataView values', async () => {\n    const dataView = new DataView(new ArrayBuffer(16), 0, 16);\n    const expected = {\n      rr_type: 'DataView',\n      args: [\n        {\n          rr_type: 'ArrayBuffer',\n          base64: 'AAAAAAAAAAAAAAAAAAAAAA==',\n        },\n        0,\n        16,\n      ],\n    };\n\n    expect(serializeArg(dataView, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should leave arrays intact","suites":["serializeArg"],"updatePoint":{"line":75,"column":32},"line":75,"code":"  it('should leave arrays intact', async () => {\n    const array = [1, 2, 3, 4];\n    expect(serializeArg(array, window, context)).toStrictEqual(array);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize complex objects","suites":["serializeArg"],"updatePoint":{"line":80,"column":38},"line":80,"code":"  it('should serialize complex objects', async () => {\n    const dataView = [new DataView(new ArrayBuffer(16), 0, 16), 5, 6];\n    const expected = [\n      {\n        rr_type: 'DataView',\n        args: [\n          {\n            rr_type: 'ArrayBuffer',\n            base64: 'AAAAAAAAAAAAAAAAAAAAAA==',\n          },\n          0,\n          16,\n        ],\n      },\n      5,\n      6,\n    ];\n\n    expect(serializeArg(dataView, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize arraybuffer contents","suites":["serializeArg"],"updatePoint":{"line":101,"column":43},"line":101,"code":"  it('should serialize arraybuffer contents', async () => {\n    const buffer = new Float32Array([1, 2, 3, 4]).buffer;\n    const expected = {\n      rr_type: 'ArrayBuffer',\n      base64: 'AACAPwAAAEAAAEBAAACAQA==',\n    };\n\n    expect(serializeArg(buffer, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should leave null as-is","suites":["serializeArg"],"updatePoint":{"line":111,"column":29},"line":111,"code":"  it('should leave null as-is', async () => {\n    expect(serializeArg(null, window, context)).toStrictEqual(null);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support indexed variables","suites":["serializeArg"],"updatePoint":{"line":115,"column":38},"line":115,"code":"  it('should support indexed variables', async () => {\n    const webGLProgram = new WebGLProgram();\n    expect(serializeArg(webGLProgram, window, context)).toStrictEqual({\n      rr_type: 'WebGLProgram',\n      index: 0,\n    });\n    const webGLProgram2 = new WebGLProgram();\n    expect(serializeArg(webGLProgram2, window, context)).toStrictEqual({\n      rr_type: 'WebGLProgram',\n      index: 1,\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support indexed variables grouped by context","suites":["serializeArg"],"updatePoint":{"line":128,"column":57},"line":128,"code":"  it('should support indexed variables grouped by context', async () => {\n    const context1 = createContext();\n    const webGLProgram1 = new WebGLProgram();\n    expect(serializeArg(webGLProgram1, window, context1)).toStrictEqual({\n      rr_type: 'WebGLProgram',\n      index: 0,\n    });\n    const context2 = createContext();\n    const webGLProgram2 = new WebGLProgram();\n    expect(serializeArg(webGLProgram2, window, context2)).toStrictEqual({\n      rr_type: 'WebGLProgram',\n      index: 0,\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support HTMLImageElements","suites":["serializeArg"],"updatePoint":{"line":143,"column":38},"line":143,"code":"  it('should support HTMLImageElements', async () => {\n    const image = new Image();\n    image.src = 'http://example.com/image.png';\n    expect(serializeArg(image, window, context)).toStrictEqual({\n      rr_type: 'HTMLImageElement',\n      src: 'http://example.com/image.png',\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support HTMLCanvasElements saved to image","suites":["serializeArg"],"updatePoint":{"line":152,"column":54},"line":152,"code":"  it('should support HTMLCanvasElements saved to image', async () => {\n    const canvas = document.createElement('canvas');\n    // polyfill canvas.toDataURL as it doesn't exist in jsdom\n    canvas.toDataURL = () => 'data:image/png;base64,...';\n    expect(serializeArg(canvas, window, context)).toMatchObject({\n      rr_type: 'HTMLImageElement',\n      src: 'data:image/png;base64,...',\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize ImageData","suites":["serializeArg"],"updatePoint":{"line":162,"column":32},"line":162,"code":"  it('should serialize ImageData', async () => {\n    const arr = new Uint8ClampedArray(40000);\n\n    // Iterate through every pixel\n    for (let i = 0; i < arr.length; i += 4) {\n      arr[i + 0] = 0; // R value\n      arr[i + 1] = 190; // G value\n      arr[i + 2] = 0; // B value\n      arr[i + 3] = 255; // A value\n    }\n\n    // Initialize a new ImageData object\n    let imageData = new ImageData(arr, 200, 50);\n\n    const contents = Array.from(arr);\n    expect(serializeArg(imageData, window, context)).toStrictEqual({\n      rr_type: 'ImageData',\n      args: [\n        {\n          rr_type: 'Uint8ClampedArray',\n          args: [contents],\n        },\n        200,\n        50,\n      ],\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize a blob","suites":["serializeArg"],"line":191,"code":"  it.skip('should serialize a blob', async () => {","file":"record/serialize-args.test.ts","skipped":true,"dir":"packages/rrweb/test"},{"name":"will record changes to a canvas element","suites":["record webgl"],"updatePoint":{"line":104,"column":45},"line":104,"code":"  it('will record changes to a canvas element', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      var gl = canvas.getContext('webgl')!;\n\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    const lastEvent = ctx.events[ctx.events.length - 1];\n    expect(lastEvent).toMatchObject({\n      data: {\n        source: IncrementalSource.CanvasMutation,\n        type: CanvasContext.WebGL,\n        commands: [\n          {\n            args: [16384],\n            property: 'clear',\n          },\n        ],\n      },\n    });\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record changes to a webgl2 canvas element","suites":["record webgl"],"updatePoint":{"line":130,"column":52},"line":130,"code":"  it('will record changes to a webgl2 canvas element', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      var gl = canvas.getContext('webgl2')!;\n\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    const lastEvent = ctx.events[ctx.events.length - 1];\n    expect(lastEvent).toMatchObject({\n      data: {\n        source: IncrementalSource.CanvasMutation,\n        type: CanvasContext.WebGL2,\n        commands: [\n          {\n            args: [16384],\n            property: 'clear',\n          },\n        ],\n      },\n    });\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record changes to a canvas element before the canvas gets added","suites":["record webgl"],"updatePoint":{"line":156,"column":74},"line":156,"code":"  it('will record changes to a canvas element before the canvas gets added', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.createElement('canvas');\n      var gl = canvas.getContext('webgl')!;\n      var program = gl.createProgram()!;\n      gl.linkProgram(program);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      document.body.appendChild(canvas);\n    });\n\n    await waitForRAF(ctx.page);\n\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record changes to a canvas element before the canvas gets added (webgl2)","suites":["record webgl"],"updatePoint":{"line":171,"column":83},"line":171,"code":"  it('will record changes to a canvas element before the canvas gets added (webgl2)', async () => {\n    await ctx.page.evaluate(() => {\n      return new Promise<void>((resolve) => {\n        var canvas = document.createElement('canvas');\n        var gl = canvas.getContext('webgl2')!;\n        var program = gl.createProgram()!;\n        gl.linkProgram(program);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        setTimeout(() => {\n          document.body.appendChild(canvas);\n          resolve();\n        }, 10);\n      });\n    });\n\n    // FIXME: this wait deeply couples the test to the implementation\n    // When `pendingCanvasMutations` isn't run on requestAnimationFrame,\n    // we need to change this\n    await waitForRAF(ctx.page);\n\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record webgl variables","suites":["record webgl"],"updatePoint":{"line":194,"column":33},"line":194,"code":"  it('will record webgl variables', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      var gl = canvas.getContext('webgl')!;\n      var program0 = gl.createProgram()!;\n      gl.linkProgram(program0);\n      var program1 = gl.createProgram()!;\n      gl.linkProgram(program1);\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record webgl variables in reverse order","suites":["record webgl"],"updatePoint":{"line":209,"column":50},"line":209,"code":"  it('will record webgl variables in reverse order', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      var gl = canvas.getContext('webgl')!;\n      var program0 = gl.createProgram()!;\n      var program1 = gl.createProgram()!;\n      // attach them in reverse order\n      gl.linkProgram(program1);\n      gl.linkProgram(program0);\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"sets _context on canvas.getContext()","suites":["record webgl"],"updatePoint":{"line":225,"column":42},"line":225,"code":"  it('sets _context on canvas.getContext()', async () => {\n    const context = await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      canvas.getContext('webgl')!;\n      return (canvas as ICanvas).__context;\n    });\n\n    expect(context).toBe('webgl');\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"only sets _context on first canvas.getContext() call","suites":["record webgl"],"updatePoint":{"line":235,"column":58},"line":235,"code":"  it('only sets _context on first canvas.getContext() call', async () => {\n    const context = await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      canvas.getContext('webgl');\n      canvas.getContext('2d'); // returns null\n      return (canvas as ICanvas).__context;\n    });\n\n    expect(context).toBe('webgl');\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should batch events by RAF","suites":["record webgl"],"updatePoint":{"line":246,"column":32},"line":246,"code":"  it('should batch events by RAF', async () => {\n    await ctx.page.evaluate(() => {\n      return new Promise<void>((resolve) => {\n        const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n        const gl = canvas.getContext('webgl') as WebGLRenderingContext;\n        const program = gl.createProgram()!;\n        gl.linkProgram(program);\n        requestAnimationFrame(() => {\n          const program2 = gl.createProgram()!;\n          gl.linkProgram(program2);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n          requestAnimationFrame(() => {\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            resolve();\n          });\n        });\n      });\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    assertSnapshot(ctx.events);\n    expect(ctx.events.length).toEqual(5);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record snapshots","suites":["record webgl","recordCanvas FPS"],"updatePoint":{"line":289,"column":31},"line":289,"code":"    it('should record snapshots', async () => {\n      await ctx.page.evaluate(() => {\n        const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true })!;\n        // Set the clear color to darkish green.\n        gl.clearColor(0.0, 0.5, 0.0, 1.0);\n        // Clear the context with the newly set color. This is\n        // the function call that actually does the drawing.\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      });\n\n      await ctx.page.waitForTimeout(200); // give it some time buffer\n\n      await ctx.page.evaluate(() => {\n        const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true })!;\n        // Set the clear color to darkish blue.\n        gl.clearColor(0.0, 0.0, 0.5, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      });\n\n      await ctx.page.waitForTimeout(200);\n\n      await waitForRAF(ctx.page);\n\n      // should yield a frame for each change at a max of 60fps\n      assertSnapshot(stripBase64(ctx.events));\n    });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize Float32Array values","suites":["deserializeArg"],"updatePoint":{"line":14,"column":44},"line":14,"code":"  it('should deserialize Float32Array values', async () => {\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'Float32Array',\n        args: [[-1, -1, 3, -1, -1, 3]],\n      }),\n    ).toEqual(new Float32Array([-1, -1, 3, -1, -1, 3]));\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize Float64Array values","suites":["deserializeArg"],"updatePoint":{"line":26,"column":44},"line":26,"code":"  it('should deserialize Float64Array values', async () => {\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'Float64Array',\n        args: [[-1, -1, 3, -1, -1, 3]],\n      }),\n    ).toEqual(new Float64Array([-1, -1, 3, -1, -1, 3]));\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize ArrayBuffer values","suites":["deserializeArg"],"updatePoint":{"line":38,"column":43},"line":38,"code":"  it('should deserialize ArrayBuffer values', async () => {\n    const contents = [1, 2, 0, 4];\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'ArrayBuffer',\n        base64: 'AQIABA==',\n      }),\n    ).toStrictEqual(new Uint8Array(contents).buffer);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize DataView values","suites":["deserializeArg"],"updatePoint":{"line":51,"column":40},"line":51,"code":"  it('should deserialize DataView values', async () => {\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'DataView',\n        args: [\n          {\n            rr_type: 'ArrayBuffer',\n            base64: 'AAAAAAAAAAAAAAAAAAAAAA==',\n          },\n          0,\n          16,\n        ],\n      }),\n    ).toStrictEqual(new DataView(new ArrayBuffer(16), 0, 16));\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should leave arrays intact","suites":["deserializeArg"],"updatePoint":{"line":70,"column":32},"line":70,"code":"  it('should leave arrays intact', async () => {\n    const array = [1, 2, 3, 4];\n    expect(await deserializeArg(new Map(), context)(array)).toEqual(array);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize complex objects","suites":["deserializeArg"],"updatePoint":{"line":75,"column":40},"line":75,"code":"  it('should deserialize complex objects', async () => {\n    const serializedArg = [\n      {\n        rr_type: 'DataView',\n        args: [\n          {\n            rr_type: 'ArrayBuffer',\n            args: [16],\n          },\n          0,\n          16,\n        ],\n      },\n      5,\n      6,\n    ];\n    expect(\n      await deserializeArg(new Map(), context)(serializedArg),\n    ).toStrictEqual([new DataView(new ArrayBuffer(16), 0, 16), 5, 6]);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should leave null as-is","suites":["deserializeArg"],"updatePoint":{"line":96,"column":29},"line":96,"code":"  it('should leave null as-is', async () => {\n    expect(await deserializeArg(new Map(), context)(null)).toStrictEqual(null);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support HTMLImageElements","suites":["deserializeArg"],"updatePoint":{"line":100,"column":38},"line":100,"code":"  it('should support HTMLImageElements', async () => {\n    const image = new Image();\n    image.src = 'http://example.com/image.png';\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'HTMLImageElement',\n        src: 'http://example.com/image.png',\n      }),\n    ).toStrictEqual(image);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should return image from imageMap for HTMLImageElements","suites":["deserializeArg"],"updatePoint":{"line":114,"column":61},"line":114,"code":"  it('should return image from imageMap for HTMLImageElements', async () => {\n    const image = new Image();\n    image.src = 'http://example.com/image.png';\n    const imageMap = new Map();\n    imageMap.set(image.src, image);\n\n    expect(\n      await deserializeArg(\n        imageMap,\n        context,\n      )({\n        rr_type: 'HTMLImageElement',\n        src: 'http://example.com/image.png',\n      }),\n    ).toBe(image);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support blobs","suites":["deserializeArg"],"updatePoint":{"line":131,"column":26},"line":131,"code":"  it('should support blobs', async () => {\n    const arrayBuffer = new Uint8Array([1, 2, 0, 4]).buffer;\n    const expected = new Blob([arrayBuffer], { type: 'image/png' });\n\n    const deserialized = await deserializeArg(\n      new Map(),\n      context,\n    )({\n      rr_type: 'Blob',\n      data: [\n        {\n          rr_type: 'ArrayBuffer',\n          base64: 'AQIABA==',\n        },\n      ],\n      type: 'image/png',\n    });\n\n    // `expect(blob).toEqual(otherBlob)` doesn't really do anything yet\n    // jest hasn't implemented a propper way to compare blobs\n    // more info: https://github.com/facebook/jest/issues/7372\n    // because JSDOM doesn't support most functions needed for comparison:\n    // more info: https://github.com/jsdom/jsdom/issues/2555\n    expect(deserialized).toEqual(expected);\n    // thats why we test size of the blob as well\n    expect(deserialized.size).toEqual(expected.size);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should set isUnchanged:true when non of the args are changed","suites":["deserializeArg","isUnchanged"],"updatePoint":{"line":160,"column":68},"line":160,"code":"    it('should set isUnchanged:true when non of the args are changed', async () => {\n      const status = {\n        isUnchanged: true,\n      };\n\n      await deserializeArg(new Map(), context, status)(true);\n      expect(status.isUnchanged).toBeTruthy();\n    });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should set isUnchanged: false when args are deserialzed","suites":["deserializeArg","isUnchanged"],"updatePoint":{"line":169,"column":63},"line":169,"code":"    it('should set isUnchanged: false when args are deserialzed', async () => {\n      const status = {\n        isUnchanged: true,\n      };\n\n      await deserializeArg(\n        new Map(),\n        context,\n        status,\n      )({\n        rr_type: 'Float64Array',\n        args: [[-1, -1, 3, -1, -1, 3]],\n      });\n      expect(status.isUnchanged).toBeFalsy();\n    });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should set isUnchanged: false when nested args are deserialzed","suites":["deserializeArg","isUnchanged"],"updatePoint":{"line":185,"column":70},"line":185,"code":"    it('should set isUnchanged: false when nested args are deserialzed', async () => {\n      const status = {\n        isUnchanged: true,\n      };\n\n      await deserializeArg(\n        new Map(),\n        context,\n        status,\n      )([\n        {\n          rr_type: 'Float64Array',\n          args: [[-1, -1, 3, -1, -1, 3]],\n        },\n      ]);\n      expect(status.isUnchanged).toBeFalsy();\n    });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should preload image","suites":["preloadAllImages"],"updatePoint":{"line":48,"column":26},"line":48,"code":"  it('should preload image', () => {\n    replayer.service.state.context.events = [\n      canvasMutationEventWithArgs([\n        {\n          rr_type: 'HTMLImageElement',\n          src: 'http://example.com',\n        },\n      ]),\n    ];\n\n    (replayer as any).preloadAllImages();\n\n    const expectedImage = new Image();\n    expectedImage.src = 'http://example.com';\n    expect((replayer as any).imageMap.get('http://example.com')).toEqual(\n      expectedImage,\n    );\n  });","file":"replay/preload-all-images.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should preload nested image","suites":["preloadAllImages"],"updatePoint":{"line":67,"column":33},"line":67,"code":"  it('should preload nested image', async () => {\n    replayer.service.state.context.events = [\n      canvasMutationEventWithArgs([\n        {\n          rr_type: 'Array',\n          args: [\n            {\n              rr_type: 'HTMLImageElement',\n              src: 'http://example.com',\n            },\n          ],\n        },\n      ]),\n    ];\n\n    await (replayer as any).preloadAllImages();\n\n    const expectedImage = new Image();\n    expectedImage.src = 'http://example.com';\n\n    expect((replayer as any).imageMap.get('http://example.com')).toEqual(\n      expectedImage,\n    );\n  });","file":"replay/preload-all-images.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should preload multiple images","suites":["preloadAllImages"],"updatePoint":{"line":92,"column":36},"line":92,"code":"  it('should preload multiple images', () => {\n    replayer.service.state.context.events = [\n      canvasMutationEventWithArgs([\n        {\n          rr_type: 'HTMLImageElement',\n          src: 'http://example.com/img1.png',\n        },\n        {\n          rr_type: 'HTMLImageElement',\n          src: 'http://example.com/img2.png',\n        },\n      ]),\n    ];\n\n    (replayer as any).preloadAllImages();\n\n    const expectedImage1 = new Image();\n    expectedImage1.src = 'http://example.com/img1.png';\n\n    expect(\n      (replayer as any).imageMap.get('http://example.com/img1.png'),\n    ).toEqual(expectedImage1);\n\n    const expectedImage2 = new Image();\n    expectedImage1.src = 'http://example.com/img2.png';\n\n    expect(\n      (replayer as any).imageMap.get('http://example.com/img2.png'),\n    ).toEqual(expectedImage1);\n  });","file":"replay/preload-all-images.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should create webgl variables","suites":["webglMutation"],"updatePoint":{"line":21,"column":35},"line":21,"code":"  it('should create webgl variables', async () => {\n    const createShaderMock = jest.fn().mockImplementation(() => {\n      return new WebGLShader();\n    });\n    const context = ({\n      createShader: createShaderMock,\n    } as unknown) as WebGLRenderingContext;\n    jest.spyOn(canvas, 'getContext').mockImplementation(() => {\n      return context;\n    });\n\n    expect(variableListFor(context, 'WebGLShader')).toHaveLength(0);\n\n    await webglMutation({\n      mutation: {\n        property: 'createShader',\n        args: [35633],\n      },\n      type: CanvasContext.WebGL,\n      target: canvas,\n      imageMap: new Map(),\n      errorHandler: () => {},\n    });\n\n    expect(createShaderMock).toHaveBeenCalledWith(35633);\n    expect(variableListFor(context, 'WebGLShader')).toHaveLength(1);\n  });","file":"replay/webgl-mutation.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should output simple webgl object","suites":["replayer","webgl"],"updatePoint":{"line":53,"column":41},"line":53,"code":"    it('should output simple webgl object', async () => {\n      await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events, {\n        UNSAFE_replayCanvas: true,\n      });\n      replayer.play(2500);\n    `);\n\n      const image = await page.screenshot();\n      expect(image).toMatchImageSnapshot();\n    });","file":"replay/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can get meta data","suites":["replayer"],"updatePoint":{"line":58,"column":23},"line":58,"code":"  it('can get meta data', async () => {\n    const meta = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.getMetaData();\n    `);\n    expect(meta).toEqual({\n      startTime: events[0].timestamp,\n      endTime: events[events.length - 1].timestamp,\n      totalTime: events[events.length - 1].timestamp - events[0].timestamp,\n    });\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will start actions when play","suites":["replayer"],"updatePoint":{"line":71,"column":34},"line":71,"code":"  it('will start actions when play', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play();\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(events.length);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will clean actions when pause","suites":["replayer"],"updatePoint":{"line":81,"column":35},"line":81,"code":"  it('will clean actions when pause', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play();\n      replayer.pause();\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(0);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can play at any time offset","suites":["replayer"],"updatePoint":{"line":92,"column":33},"line":92,"code":"  it('can play at any time offset', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(1500);\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(\n      events.filter((e) => e.timestamp - events[0].timestamp >= 1500).length,\n    );\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can play a second time in the future","suites":["replayer"],"updatePoint":{"line":104,"column":42},"line":104,"code":"  it('can play a second time in the future', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(500);\n      replayer.play(1500);\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(\n      events.filter((e) => e.timestamp - events[0].timestamp >= 1500).length,\n    );\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can play a second time to the past","suites":["replayer"],"updatePoint":{"line":117,"column":40},"line":117,"code":"  it('can play a second time to the past', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(1500);\n      replayer.play(500);\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(\n      events.filter((e) => e.timestamp - events[0].timestamp >= 500).length,\n    );\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can pause at any time offset","suites":["replayer"],"updatePoint":{"line":130,"column":34},"line":130,"code":"  it('can pause at any time offset', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(2500);\n      replayer['timer']['actions'].length;\n    `);\n    const currentTime = await page.evaluate(`\n      replayer.getCurrentTime();\n    `);\n    const currentState = await page.evaluate(`\n      replayer['service']['state']['value'];\n    `);\n    expect(actionLength).toEqual(0);\n    expect(currentTime).toEqual(2500);\n    expect(currentState).toEqual('paused');\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward past StyleSheetRule changes on virtual elements","suites":["replayer"],"updatePoint":{"line":148,"column":70},"line":148,"code":"  it('can fast forward past StyleSheetRule changes on virtual elements', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(1500);\n      replayer['timer']['actions'].length;\n    `);\n\n    expect(actionLength).toEqual(\n      styleSheetRuleEvents.filter(\n        (e) => e.timestamp - styleSheetRuleEvents[0].timestamp >= 1500,\n      ).length,\n    );\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should apply fast forwarded StyleSheetRules that where added","suites":["replayer"],"updatePoint":{"line":166,"column":66},"line":166,"code":"  it('should apply fast forwarded StyleSheetRules that where added', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(1500);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-1000-deleted-at-2500');\n    `);\n\n    expect(result).toEqual(true);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can handle removing style elements","suites":["replayer"],"updatePoint":{"line":181,"column":40},"line":181,"code":"  it('can handle removing style elements', async () => {\n    await page.evaluate(`events = ${JSON.stringify(stylesheetRemoveEvents)}`);\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(2500);\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(\n      stylesheetRemoveEvents.filter(\n        (e) => e.timestamp - stylesheetRemoveEvents[0].timestamp >= 2500,\n      ).length,\n    );\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward selection events","suites":["replayer"],"updatePoint":{"line":198,"column":39},"line":198,"code":"  it('can fast forward selection events', async () => {\n    await page.evaluate(`events = ${JSON.stringify(selectionEvents)}`);\n\n    /** check the first selection event */\n    let [startOffset, endOffset] = (await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(360);\n      var range = replayer.iframe.contentDocument.getSelection().getRangeAt(0);\n      [range.startOffset, range.endOffset];\n    `)) as [startOffset: number, endOffset: number];\n\n    expect(startOffset).toEqual(5);\n    expect(endOffset).toEqual(15);\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n\n    /** check the second selection event */\n    [startOffset, endOffset] = (await page.evaluate(`      \n      replayer.pause(410);\n      var range = replayer.iframe.contentDocument.getSelection().getRangeAt(0);\n      [range.startOffset, range.endOffset];\n    `)) as [startOffset: number, endOffset: number];\n\n    expect(startOffset).toEqual(11);\n    expect(endOffset).toEqual(6);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward past StyleSheetRule deletion on virtual elements","suites":["replayer"],"updatePoint":{"line":227,"column":71},"line":227,"code":"  it('can fast forward past StyleSheetRule deletion on virtual elements', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(2600);\n      replayer['timer']['actions'].length;\n    `);\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should delete fast forwarded StyleSheetRules that where removed","suites":["replayer"],"updatePoint":{"line":240,"column":69},"line":240,"code":"  it('should delete fast forwarded StyleSheetRules that where removed', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(3000);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-1000-deleted-at-2500');\n    `);\n\n    expect(result).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should overwrite all StyleSheetRules by replacing style element's textContent while fast-forwarding","suites":["replayer"],"updatePoint":{"line":255,"column":105},"line":255,"code":"  it(\"should overwrite all StyleSheetRules by replacing style element's textContent while fast-forwarding\", async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(3500);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-200-overwritten-at-3000');\n    `);\n\n    expect(result).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should apply fast-forwarded StyleSheetRules that came after stylesheet textContent overwrite","suites":["replayer"],"updatePoint":{"line":270,"column":98},"line":270,"code":"  it('should apply fast-forwarded StyleSheetRules that came after stylesheet textContent overwrite', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(3500);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-3100') &&\n        !rules.some(\n          (x) => x.selectorText === '.css-added-at-500-overwritten-at-3000',\n        );\n    `);\n\n    expect(result).toEqual(true);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should overwrite all StyleSheetRules by appending a text node to stylesheet element while fast-forwarding","suites":["replayer"],"updatePoint":{"line":288,"column":111},"line":288,"code":"  it('should overwrite all StyleSheetRules by appending a text node to stylesheet element while fast-forwarding', async () => {\n    await page.evaluate(`events = ${JSON.stringify(StyleSheetTextMutation)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(1600);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-1000-overwritten-at-1500');\n    `);\n    expect(result).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should apply fast-forwarded StyleSheetRules that came after appending text node to stylesheet element","suites":["replayer"],"updatePoint":{"line":302,"column":107},"line":302,"code":"  it('should apply fast-forwarded StyleSheetRules that came after appending text node to stylesheet element', async () => {\n    await page.evaluate(`events = ${JSON.stringify(StyleSheetTextMutation)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(2100);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-2000-overwritten-at-2500');\n    `);\n    expect(result).toEqual(true);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should overwrite all StyleSheetRules by removing text node from stylesheet element while fast-forwarding","suites":["replayer"],"updatePoint":{"line":316,"column":110},"line":316,"code":"  it('should overwrite all StyleSheetRules by removing text node from stylesheet element while fast-forwarding', async () => {\n    await page.evaluate(`events = ${JSON.stringify(StyleSheetTextMutation)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(2600);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-2000-overwritten-at-2500');\n    `);\n    expect(result).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should apply fast-forwarded StyleSheetRules that came after removing text node from stylesheet element","suites":["replayer"],"updatePoint":{"line":330,"column":108},"line":330,"code":"  it('should apply fast-forwarded StyleSheetRules that came after removing text node from stylesheet element', async () => {\n    await page.evaluate(`events = ${JSON.stringify(StyleSheetTextMutation)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(3100);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-3000');\n    `);\n    expect(result).toEqual(true);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward scroll events","suites":["replayer"],"updatePoint":{"line":344,"column":36},"line":344,"code":"  it('can fast forward scroll events', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(scrollEvents)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(550);\n    `);\n    // add the \"#container\" element at 500\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    expect(await contentDocument!.$('#container')).not.toBeNull();\n    expect(await contentDocument!.$('#block')).not.toBeNull();\n    expect(\n      await contentDocument!.$eval(\n        '#container',\n        (element: Element) => element.scrollTop,\n      ),\n    ).toEqual(0);\n\n    // restart the replayer\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n\n    await page.evaluate('replayer.pause(1050);');\n    // scroll the \"#container\" div' at 1000\n    expect(\n      await contentDocument!.$eval(\n        '#container',\n        (element: Element) => element.scrollTop,\n      ),\n    ).toEqual(2500);\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(1550);');\n    // scroll the document at 1500\n    expect(\n      await page.$eval(\n        'iframe',\n        (element: Element) =>\n          (element as HTMLIFrameElement)!.contentWindow!.scrollY,\n      ),\n    ).toEqual(250);\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2050);');\n    // remove the \"#container\" element at 2000\n    expect(await contentDocument!.$('#container')).toBeNull();\n    expect(await contentDocument!.$('#block')).toBeNull();\n    expect(\n      await page.$eval(\n        'iframe',\n        (element: Element) =>\n          (element as HTMLIFrameElement)!.contentWindow!.scrollY,\n      ),\n    ).toEqual(0);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward input events","suites":["replayer"],"updatePoint":{"line":403,"column":35},"line":403,"code":"  it('can fast forward input events', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(inputEvents)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(1050);\n    `);\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    expect(await contentDocument!.$('select')).not.toBeNull();\n    expect(\n      await contentDocument!.$eval(\n        'select',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('valueB'); // the default value\n\n    // restart the replayer\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n\n    await page.evaluate('replayer.pause(1550);');\n    // the value get changed to 'valueA' at 1500\n    expect(\n      await contentDocument!.$eval(\n        'select',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('valueA');\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2050);');\n    // the value get changed to 'valueC' at 2000\n    expect(\n      await contentDocument!.$eval(\n        'select',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('valueC');\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2550);');\n    // add a new input element at 2500\n    expect(\n      await contentDocument!.$eval(\n        'input',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('');\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(3050);');\n    // set the value 'test input' for the input element at 3000\n    expect(\n      await contentDocument!.$eval(\n        'input',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('test input');\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(3550);');\n    // remove the select element at 3500\n    expect(await contentDocument!.$('select')).toBeNull();\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(4050);');\n    // remove the input element at 4000\n    expect(await contentDocument!.$('input')).toBeNull();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast-forward mutation events containing nested iframe elements","suites":["replayer"],"updatePoint":{"line":479,"column":72},"line":479,"code":"  it('can fast-forward mutation events containing nested iframe elements', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(iframeEvents)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(250);\n    `);\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    expect(await contentDocument!.$('iframe')).toBeNull();\n\n    // restart the replayer\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(550);'); // add 'iframe one' at 500\n    expect(await contentDocument!.$('iframe')).not.toBeNull();\n    let iframeOneDocument = await (await contentDocument!.$(\n      'iframe',\n    ))!.contentFrame();\n    expect(iframeOneDocument).not.toBeNull();\n    expect(await iframeOneDocument!.$('noscript')).not.toBeNull();\n    // make sure custom style rules are inserted rules\n    expect((await iframeOneDocument!.$$('style')).length).toBe(1);\n    expect(\n      await iframeOneDocument!.$eval(\n        'noscript',\n        (element) => window.getComputedStyle(element).display,\n      ),\n    ).toEqual('none');\n\n    // add 'iframe two' and 'iframe three' at 1000\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(1050);');\n    // check the inserted style of iframe 'one' again\n    iframeOneDocument = await (await contentDocument!.$(\n      'iframe',\n    ))!.contentFrame();\n    expect((await iframeOneDocument!.$$('style')).length).toBe(1);\n\n    expect((await contentDocument!.$$('iframe')).length).toEqual(2);\n    let iframeTwoDocument = await (\n      await contentDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect(iframeTwoDocument).not.toBeNull();\n    expect((await iframeTwoDocument!.$$('iframe')).length).toEqual(2);\n    expect((await iframeTwoDocument!.$$('style')).length).toBe(1);\n    let iframeThreeDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[0]!.contentFrame();\n    let iframeFourDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect(iframeThreeDocument).not.toBeNull();\n    expect((await iframeThreeDocument!.$$('style')).length).toBe(1);\n    expect(iframeFourDocument).not.toBeNull();\n\n    // add 'iframe four' at 1500\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(1550);');\n    iframeTwoDocument = await (\n      await contentDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect((await iframeTwoDocument!.$$('style')).length).toBe(1);\n    iframeFourDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect(await iframeFourDocument!.$('iframe')).toBeNull();\n    expect((await iframeFourDocument!.$$('style')).length).toBe(1);\n    expect(await iframeFourDocument!.title()).toEqual('iframe 4');\n\n    // add 'iframe five' at 2000\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2050);');\n    iframeTwoDocument = await (\n      await contentDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    iframeFourDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect((await iframeFourDocument!.$$('style')).length).toBe(1);\n    expect(await iframeFourDocument!.$('iframe')).not.toBeNull();\n    const iframeFiveDocument = await (await iframeFourDocument!.$(\n      'iframe',\n    ))!.contentFrame();\n    expect(iframeFiveDocument).not.toBeNull();\n    expect((await iframeFiveDocument!.$$('style')).length).toBe(1);\n    expect(await iframeFiveDocument!.$('noscript')).not.toBeNull();\n    expect(\n      await iframeFiveDocument!.$eval(\n        'noscript',\n        (element) => window.getComputedStyle(element).display,\n      ),\n    ).toEqual('none');\n\n    // remove the html element of 'iframe four' at 2500\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2550);');\n    iframeTwoDocument = await (\n      await contentDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    iframeFourDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    // the html element should be removed\n    expect(await iframeFourDocument!.$('html')).toBeNull();\n    // the doctype should still exist\n    expect(\n      await iframeTwoDocument!.evaluate(\n        (iframe) => (iframe as HTMLIFrameElement)!.contentDocument!.doctype,\n        (await iframeTwoDocument!.$$('iframe'))[1],\n      ),\n    ).not.toBeNull();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast-forward mutation events containing nested shadow doms","suites":["replayer"],"updatePoint":{"line":597,"column":68},"line":597,"code":"  it('can fast-forward mutation events containing nested shadow doms', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(shadowDomEvents)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(550);\n    `);\n    // add shadow dom 'one' at 500\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    expect(\n      await contentDocument!.$eval('div', (element) => element.shadowRoot),\n    ).not.toBeNull();\n    expect(\n      await contentDocument!.evaluate(\n        () =>\n          document\n            .querySelector('body > div')!\n            .shadowRoot!.querySelector('span')!.textContent,\n      ),\n    ).toEqual('shadow dom one');\n\n    // add shadow dom 'two' at 1000\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(1050);');\n    expect(\n      await contentDocument!.evaluate(\n        () =>\n          document\n            .querySelector('body > div')!\n            .shadowRoot!.querySelector('div')!.shadowRoot,\n      ),\n    ).not.toBeNull();\n    expect(\n      await contentDocument!.evaluate(\n        () =>\n          document\n            .querySelector('body > div')!\n            .shadowRoot!.querySelector('div')!\n            .shadowRoot!.querySelector('span')!.textContent,\n      ),\n    ).toEqual('shadow dom two');\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast-forward mutation events containing painted canvas in iframe","suites":["replayer"],"updatePoint":{"line":642,"column":74},"line":642,"code":"  it('can fast-forward mutation events containing painted canvas in iframe', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(canvasInIframe)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(550);            \n    `);\n    const replayerIframe = await page.$('iframe');\n    const contentDocument = await replayerIframe!.contentFrame()!;\n    const iframe = await contentDocument!.$('iframe');\n    expect(iframe).not.toBeNull();\n    const docInIFrame = await iframe?.contentFrame();\n    expect(docInIFrame).not.toBeNull();\n    const canvasElements = await docInIFrame!.$$('canvas');\n    // The first canvas is a blank one and the second is a painted one.\n    expect(canvasElements.length).toEqual(2);\n\n    const dataUrls = await docInIFrame?.$$eval('canvas', (elements) =>\n      elements.map((element) => (element as HTMLCanvasElement).toDataURL()),\n    );\n    expect(dataUrls?.length).toEqual(2);\n    // The painted canvas's data should not be empty.\n    expect(dataUrls![1]).not.toEqual(dataUrls![0]);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can stream events in live mode","suites":["replayer"],"updatePoint":{"line":667,"column":36},"line":667,"code":"  it('can stream events in live mode', async () => {\n    const status = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events, {\n        liveMode: true\n      });\n      replayer.startLive();\n      replayer.service.state.value;\n    `);\n    expect(status).toEqual('live');\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"replays same timestamp events in correct order","suites":["replayer"],"updatePoint":{"line":679,"column":52},"line":679,"code":"  it('replays same timestamp events in correct order', async () => {\n    await page.evaluate(`events = ${JSON.stringify(orderingEvents)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play();\n    `);\n    await page.waitForTimeout(50);\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"replays same timestamp events in correct order (with addAction)","suites":["replayer"],"updatePoint":{"line":691,"column":69},"line":691,"code":"  it('replays same timestamp events in correct order (with addAction)', async () => {\n    await page.evaluate(`events = ${JSON.stringify(orderingEvents)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events.slice(0, events.length-2));\n      replayer.play();\n      replayer.addEvent(events[events.length-2]);\n      replayer.addEvent(events[events.length-1]);\n    `);\n    await page.waitForTimeout(50);\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should destroy the replayer after calling destroy()","suites":["replayer"],"updatePoint":{"line":705,"column":57},"line":705,"code":"  it('should destroy the replayer after calling destroy()', async () => {\n    await page.evaluate(`events = ${JSON.stringify(events)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      let replayer = new Replayer(events);\n      replayer.play();      \n    `);\n\n    const replayerWrapperClassName = 'replayer-wrapper';\n    let wrapper = await page.$(`.${replayerWrapperClassName}`);\n    expect(wrapper).not.toBeNull();\n\n    await page.evaluate(`replayer.destroy(); replayer = null;`);\n    wrapper = await page.$(`.${replayerWrapperClassName}`);\n    expect(wrapper).toBeNull();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"}]}