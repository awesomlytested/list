{"repo":"supabase/supabase","url":"https://github.com/supabase/supabase","branch":"master","configs":[{"lang":"js","dir":"examples/sveltejs-todo-list/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"supabase","lang":"js","dir":"tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"studio","lang":"ts","dir":"studio/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"it should create new todo","suites":["New todo"],"updatePoint":{"line":2,"column":31,"index":61},"line":2,"code":"  it('it should create new todo', () => {\n    cy.visit('/');\n    cy.contains('h1', 'todos');\n    cy.get('.new-todo').type('Demo').type('{enter}');\n    cy.get('.main .todo-list .view').contains('Demo');\n  });","file":"e2e/new-todo.spec.js","skipped":false,"dir":"examples/sveltejs-todo-list/tests"},{"name":"Unauthorized","suites":[],"updatePoint":{"line":6,"column":18,"index":352},"line":6,"code":"test('Unauthorized', async () => {\n  const {\n    error\n  } = await unauthorized.from('profiles').select();\n  expect(error.message).toBe('Invalid authentication credentials');\n});","file":"integration/index.test.ts","skipped":false,"dir":"tests"},{"name":"Simple test","suites":[],"updatePoint":{"line":12,"column":17,"index":530},"line":12,"code":"test('Simple test', async () => {\n  const fakeOne = {\n    email: faker.internet.email().toLowerCase(),\n    password: faker.internet.password(),\n    username: faker.internet.userName()\n  };\n  const fakeTwo = {\n    email: faker.internet.email().toLowerCase(),\n    password: faker.internet.password(),\n    username: faker.internet.userName()\n  };\n  const first = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY_ANON);\n  const second = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY_ANON);\n  const {\n    user: firstUser\n  } = await first.auth.signUp({\n    email: fakeOne.email,\n    password: fakeOne.password\n  });\n  const {\n    user: secondUser\n  } = await second.auth.signUp({\n    email: fakeTwo.email,\n    password: fakeTwo.password\n  });\n  expect(firstUser.email).toEqual(fakeOne.email);\n  expect(secondUser.email).toEqual(fakeTwo.email);\n  const {\n    data: firstProfile\n  } = await first.from('profiles').insert({\n    id: firstUser.id,\n    username: fakeOne.username\n  }).single();\n  expect(firstProfile.username).toMatch(fakeOne.username); // Cannot insert the second user on the first client\n\n  const {\n    error: secondProfile\n  } = await first.from('profiles').insert({\n    id: secondUser.id,\n    username: fakeTwo.username\n  }).single();\n  expect(secondProfile.message).toMatch(/new row violates row-level security policy for table/);\n  const {\n    data: firstProfileList\n  } = await first.from('profiles').select();\n  const {\n    data: secondProfileList\n  } = await second.from('profiles').select();\n  const {\n    data: adminProfileList\n  } = await admin.from('profiles').select();\n  expect(firstProfileList.length).toBe(1);\n  expect(secondProfileList.length).toBe(0);\n  expect(adminProfileList.length).toBeGreaterThanOrEqual(1);\n});","file":"integration/index.test.ts","skipped":false,"dir":"tests"},{"name":"mounts correctly","suites":[],"updatePoint":{"line":62,"column":22},"line":62,"code":"test('mounts correctly', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('usage')) return {}\n    if (url.includes('subscription')) return {}\n    return { data: MOCK_CHART_DATA }\n  })\n  render(<ProjectUsage project=\"12345\" />)\n  await waitFor(() => screen.getByText(/Statistics for past 24 hours/))\n  await waitFor(() => screen.getByText(/123/))\n  await waitFor(() => screen.getByText(/223/))\n  await waitFor(() => screen.getByText(/323/))\n  await waitFor(() => screen.getByText(/333/))\n})","file":"components/Home/ProjectUsage.test.js","skipped":false,"dir":"studio/tests"},{"name":"dropdown options changes chart query","suites":[],"updatePoint":{"line":76,"column":42},"line":76,"code":"test('dropdown options changes chart query', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('usage')) return {}\n    return { data: MOCK_CHART_DATA }\n  })\n  render(<ProjectUsage project=\"12345\" />)\n  await waitFor(() => screen.getByText(/Statistics for past 24 hours/))\n  await waitFor(() => screen.getAllByRole('button', { name: '24 hours' }))\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('interval=hourly'))\n  })\n  // find button that has radix id\n  const [btn] = screen.getAllByRole('button', { name: '24 hours' }).filter((e) => e.id)\n  clickDropdown(btn)\n  await waitFor(() => screen.getByText(/7 days/))\n  await waitFor(() => screen.getByText(/60 minutes/))\n\n  // simulate changing of dropdown\n  userEvent.click(screen.getByText(/60 minutes/))\n  await waitFor(() => screen.getByText(/Statistics for past 60 minutes/))\n  expect(get).toHaveBeenCalledWith(expect.stringContaining('interval=minutely'))\n})","file":"components/Home/ProjectUsage.test.js","skipped":false,"dir":"studio/tests"},{"name":"renders chart","suites":[],"updatePoint":{"line":11,"column":19},"line":11,"code":"test('renders chart', async () => {\n  const mockFn = jest.fn()\n  const tsMicro = new Date().getTime() * 1000\n  render(\n    <LogEventChart\n      data={[{ timestamp: tsMicro }, { timestamp: tsMicro + 1 }]}\n      onBarClick={mockFn}\n    />\n  )\n  // TODO: figure out how to test rechart bar chart rendering, svg does not get rendered for some reason.\n  // should only have one bar rendered\n  // await waitFor(\n  //   () => {\n  //     const paths = container.querySelectorAll('path')\n  //     console.log(paths)\n  //     expect(paths.length).toBe(1)\n  //   },\n  //   { timeout: 1000 }\n  // )\n  // userEvent.click(paths[0])\n  // expect(mock).toBeCalledTimes(1)\n  await screen.findByText('Events')\n})","file":"pages/projects/LogEventChart.test.js","skipped":false,"dir":"studio/tests"},{"name":"can display log data","suites":[],"updatePoint":{"line":72,"column":26},"line":72,"code":"test('can display log data', async () => {\n  get.mockResolvedValue({\n    result: [\n      logDataFixture({\n        id: 'some-event-happened',\n        metadata: {\n          my_key: 'something_value',\n        },\n      }),\n    ],\n  })\n  const {container} = render(<LogsExplorerPage />)\n  let editor = container.querySelector('.monaco-editor')\n  await waitFor(() => {\n    editor = container.querySelector('.monaco-editor')\n    expect(editor).toBeTruthy()\n  })\n  // type new query\n  userEvent.type(editor, 'select \\ncount(*) as my_count \\nfrom edge_logs')\n\n  userEvent.click(await screen.findByText(/Run/))\n  const row  = await screen.findByText(\"some-event-happened\")\n  userEvent.click(row)\n  await screen.findByText(/something_value/)\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"q= query param will populate the query input","suites":[],"updatePoint":{"line":98,"column":50},"line":98,"code":"test('q= query param will populate the query input', async () => {\n  const router = defaultRouterMock()\n  router.query = { ...router.query, type: 'api', q: 'some_query' }\n  useRouter.mockReturnValue(router)\n  render(<LogsExplorerPage />)\n  // should populate editor with the query param\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('sql=some_query'))\n  })\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"custom sql querying","suites":[],"updatePoint":{"line":109,"column":25},"line":109,"code":"test('custom sql querying', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('sql=') && url.includes('select')) {\n      return {\n        result: [\n          {\n            my_count: 12345,\n          },\n        ],\n      }\n    }\n    return { result: [] }\n  })\n  const { container } = render(<LogsExplorerPage />)\n  let editor = container.querySelector('.monaco-editor')\n  expect(editor).toBeTruthy()\n\n  // type into the query editor\n  await waitFor(() => {\n    editor = container.querySelector('.monaco-editor')\n    expect(editor).toBeTruthy()\n  })\n  editor = container.querySelector('.monaco-editor')\n  // type new query\n  userEvent.type(editor, 'select \\ncount(*) as my_count \\nfrom edge_logs')\n\n  // should trigger query\n  userEvent.click(await screen.findByText('Run'))\n  await waitFor(\n    () => {\n      expect(get).toHaveBeenCalledWith(expect.stringContaining(encodeURI('\\n')))\n      expect(get).toHaveBeenCalledWith(expect.stringContaining('sql='))\n      expect(get).toHaveBeenCalledWith(expect.stringContaining('select'))\n      expect(get).toHaveBeenCalledWith(expect.stringContaining('edge_logs'))\n      expect(get).not.toHaveBeenCalledWith(expect.stringContaining('where'))\n    },\n    { timeout: 1000 }\n  )\n\n  await screen.findByText(/my_count/) //column header\n  const rowValue = await screen.findByText(/12345/) // row value\n\n  // clicking on the row value should not show log selection panel\n  userEvent.click(rowValue)\n  await expect(screen.findByText(/Metadata/)).rejects.toThrow()\n\n  // should not see chronological features\n  await expect(screen.findByText(/Load older/)).rejects.toThrow()\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"%s","suites":[],"line":3,"code":"describe.each(Object.values(LogsTableName))('%s', (table) => {\n  describe.each([\n    { filter: { search_query: '' } },\n    { filter: { search_query: undefined } },\n    { filter: {} },\n    { filter: { search_query: '123test' }, contains: ['123test'] },\n    //   test behaviour with overrides\n    {\n      filter: { search_query: '123test', override: 'something' },\n      contains: ['123test', 'override', 'something'],\n    },\n    {\n      filter: { search_query: '', override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { search_query: undefined, override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { 'override.nested': 'something' },\n      contains: ['override.nested', 'something'],\n    },\n  ])('generates sql for filter $filter', ({ filter, contains = [] }) => {\n    test('generates query correctly', async () => {\n      const generated = genDefaultQuery(table, filter)\n      //   should not contain functions\n      expect(generated).not.toMatch(/function[ A-Za-z_-]+\\(.+\\).+\\{.+return.+\\}/)\n      expect(generated).not.toMatch(/\\=\\>|\\$\\{.+\\}/)\n      expect(generated).not.toContain('return')\n\n      contains.forEach((str) => expect(generated).toContain(str))\n    })\n  })\n})","file":"pages/projects/Logs.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"generates sql for filter $filter","suites":[],"line":4,"code":"  describe.each([\n    { filter: { search_query: '' } },\n    { filter: { search_query: undefined } },\n    { filter: {} },\n    { filter: { search_query: '123test' }, contains: ['123test'] },\n    //   test behaviour with overrides\n    {\n      filter: { search_query: '123test', override: 'something' },\n      contains: ['123test', 'override', 'something'],\n    },\n    {\n      filter: { search_query: '', override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { search_query: undefined, override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { 'override.nested': 'something' },\n      contains: ['override.nested', 'something'],\n    },\n  ])('generates sql for filter $filter', ({ filter, contains = [] }) => {\n    test('generates query correctly', async () => {\n      const generated = genDefaultQuery(table, filter)\n      //   should not contain functions\n      expect(generated).not.toMatch(/function[ A-Za-z_-]+\\(.+\\).+\\{.+return.+\\}/)\n      expect(generated).not.toMatch(/\\=\\>|\\$\\{.+\\}/)\n      expect(generated).not.toContain('return')\n\n      contains.forEach((str) => expect(generated).toContain(str))\n    })\n  })","file":"pages/projects/Logs.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"generates query correctly","suites":[],"updatePoint":{"line":31,"column":35},"line":31,"code":"    test('generates query correctly', async () => {\n      const generated = genDefaultQuery(table, filter)\n      //   should not contain functions\n      expect(generated).not.toMatch(/function[ A-Za-z_-]+\\(.+\\).+\\{.+return.+\\}/)\n      expect(generated).not.toMatch(/\\=\\>|\\$\\{.+\\}/)\n      expect(generated).not.toContain('return')\n\n      contains.forEach((str) => expect(generated).toContain(str))\n    })","file":"pages/projects/Logs.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"templates","suites":[],"line":12,"code":"test.todo('templates')","file":"pages/projects/LogsQueryPanel.test.js","skipped":true,"dir":"studio/tests"},{"name":"run and clear","suites":[],"updatePoint":{"line":14,"column":19},"line":14,"code":"test('run and clear', async () => {\n  const mockRun = jest.fn()\n  const mockClear = jest.fn()\n  render(<LogsQueryPanel onRun={mockRun} onClear={mockClear} hasEditorValue/>)\n  await expect(screen.findByPlaceholderText(/Search/)).rejects.toThrow()\n  const run = await screen.findByText(/Run/)\n  userEvent.click(run)\n  expect(mockRun).toBeCalled()\n  const clear = await screen.findByText(/Clear/)\n  userEvent.click(clear)\n  expect(mockClear).toBeCalled()\n  \n})","file":"pages/projects/LogsQueryPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"can display log data","suites":[],"updatePoint":{"line":4,"column":26},"line":4,"code":"test('can display log data', async () => {\n  render(\n    <LogTable\n      data={[\n        {\n          id: 'some-uuid',\n          timestamp: 1621323232312,\n          event_message: 'some event happened',\n          metadata: {\n            my_key: 'something_value',\n          },\n        },\n      ]}\n    />\n  )\n\n  const row = await screen.findByText(/some-uuid/)\n  userEvent.click(row)\n  await waitFor(() => screen.getByText(/my_key/))\n  await waitFor(() => screen.getByText(/something_value/))\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"dedupes log lines with exact id","suites":[],"updatePoint":{"line":26,"column":37},"line":26,"code":"test('dedupes log lines with exact id', async () => {\n  // chronological mode requires 4 columns\n  render(\n    <LogTable\n      data={[\n        {\n          id: 'some-uuid',\n          timestamp: 1621323232312,\n          event_message: 'some event happened',\n          metadata: {},\n        },\n        {\n          id: 'some-uuid',\n          timestamp: 1621323232312,\n          event_message: 'some event happened',\n          metadata: {},\n        },\n      ]}\n    />\n  )\n\n  // should only have one element, this line will fail if there are >1 element\n  await screen.findByText(/some-uuid/)\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"can display custom columns and headers based on data input","suites":[],"updatePoint":{"line":51,"column":64},"line":51,"code":"test('can display custom columns and headers based on data input', async () => {\n  render(<LogTable data={[{ some_header: 'some_data', kinda: 123456 }]} />)\n  await waitFor(() => screen.getByText(/some_header/))\n  await waitFor(() => screen.getByText(/some_data/))\n  await waitFor(() => screen.getByText(/kinda/))\n  await waitFor(() => screen.getByText(/123456/))\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"toggle histogram","suites":[],"updatePoint":{"line":59,"column":22},"line":59,"code":"test('toggle histogram', async () => {\n  const mockFn = jest.fn()\n  render(<LogTable onHistogramToggle={mockFn} isHistogramShowing={true} />)\n  const toggle = await screen.getByText(/Histogram/)\n  userEvent.click(toggle)\n  expect(mockFn).toBeCalled()\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"templates","suites":[],"line":13,"code":"test.todo('templates')","file":"pages/projects/PreviewFilterPanel.test.js","skipped":true,"dir":"studio/tests"},{"name":"filter input change and submit","suites":[],"updatePoint":{"line":30,"column":36},"line":30,"code":"test('filter input change and submit', async () => {\n  const mockFn = jest.fn()\n  render(<PreviewFilterPanel onSearch={mockFn} />)\n  expect(mockFn).not.toBeCalled()\n  const search = screen.getByPlaceholderText(/Search/)\n  userEvent.type(search, '12345{enter}')\n  expect(mockFn).toBeCalled()\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"filter input value","suites":[],"updatePoint":{"line":39,"column":24},"line":39,"code":"test('filter input value', async () => {\n  render(<PreviewFilterPanel defaultSearchValue={'1234'} />)\n  await screen.findByDisplayValue('1234')\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"Manual refresh","suites":[],"updatePoint":{"line":44,"column":20},"line":44,"code":"test('Manual refresh', async () => {\n  const mockFn = jest.fn()\n  render(<PreviewFilterPanel onRefresh={mockFn} />)\n  const btn = await screen.findByText(/Refresh/)\n  userEvent.click(btn)\n  expect(mockFn).toBeCalled()\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"Datepicker dropdown","suites":[],"updatePoint":{"line":51,"column":25},"line":51,"code":"test('Datepicker dropdown', async () => {\n  render(<PreviewFilterPanel />)\n  clickDropdown(await screen.findByText(/Last hour/))\n  userEvent.click(await screen.findByText(/Last 3 hours/))\n  await screen.findByText(/Last 3 hours/)\n  await expect(screen.findByText(/Last hour/)).rejects.toThrow()\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"timestamp to/from filter default value","suites":[],"line":59,"code":"test.todo('timestamp to/from filter default value')","file":"pages/projects/PreviewFilterPanel.test.js","skipped":true,"dir":"studio/tests"},{"name":"timestamp to/from filter value change","suites":[],"line":69,"code":"test.todo('timestamp to/from filter value change')","file":"pages/projects/PreviewFilterPanel.test.js","skipped":true,"dir":"studio/tests"}]}