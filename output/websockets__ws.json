{"repo":"websockets/ws","url":"https://github.com/websockets/ws","branch":"master","configs":[{"package":"ws","lang":"js","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"never returns uninitialized data","suites":["bufferUtil","concat"],"updatePoint":{"line":11,"column":40,"index":204},"line":11,"code":"    it('never returns uninitialized data', () => {\n      const buf = concat([Buffer.from([1, 2]), Buffer.from([3, 4])], 6);\n      assert.ok(buf.equals(Buffer.from([1, 2, 3, 4])));\n    });","file":"buffer-util.test.js","skipped":false,"dir":"test"},{"name":"is exposed as a property of the `WebSocket` class","suites":["createWebSocketStream"],"updatePoint":{"line":30,"column":55,"index":511},"line":30,"code":"  it('is exposed as a property of the `WebSocket` class', () => {\n    assert.strictEqual(WebSocket.createWebSocketStream, createWebSocketStream);\n  });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"returns a `Duplex` stream","suites":["createWebSocketStream"],"updatePoint":{"line":33,"column":31,"index":639},"line":33,"code":"  it('returns a `Duplex` stream', () => {\n    const duplex = createWebSocketStream(new EventEmitter());\n    assert.ok(duplex instanceof Duplex);\n  });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"passes the options object to the `Duplex` constructor","suites":["createWebSocketStream"],"updatePoint":{"line":37,"column":59,"index":818},"line":37,"code":"  it('passes the options object to the `Duplex` constructor', done => {\n    const wss = new WebSocket.Server({\n      port: 0\n    }, () => {\n      const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      const duplex = createWebSocketStream(ws, {\n        allowHalfOpen: false,\n        encoding: 'utf8'\n      });\n      duplex.on('data', chunk => {\n        assert.strictEqual(chunk, 'hi');\n        duplex.on('close', () => {\n          wss.close(done);\n        });\n      });\n    });\n    wss.on('connection', ws => {\n      ws.send(Buffer.from('hi'));\n      ws.close();\n    });\n  });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"buffers writes if `readyState` is `CONNECTING`","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":59,"column":54,"index":1448},"line":59,"code":"    it('buffers writes if `readyState` is `CONNECTING`', done => {\n      const chunk = randomBytes(1024);\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n        const duplex = createWebSocketStream(ws);\n        duplex.write(chunk);\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (message, isBinary) => {\n          ws.on('close', (code, reason) => {\n            assert.deepStrictEqual(message, chunk);\n            assert.ok(isBinary);\n            assert.strictEqual(code, 1005);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"errors if a write occurs when `readyState` is `CLOSING`","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":82,"column":63,"index":2271},"line":82,"code":"    it('errors if a write occurs when `readyState` is `CLOSING`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.ok(duplex.destroyed);\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 2 (CLOSING)');\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n        });\n        ws.on('open', () => {\n          ws._receiver.on('conclude', () => {\n            duplex.write('hi');\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"errors if a write occurs when `readyState` is `CLOSED`","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":106,"column":62,"index":3063},"line":106,"code":"    it('errors if a write occurs when `readyState` is `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.ok(duplex.destroyed);\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 3 (CLOSED)');\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n        });\n        ws.on('close', () => {\n          duplex.write('hi');\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"does not error if `_final()` is called while connecting","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":128,"column":63,"index":3794},"line":128,"code":"    it('does not error if `_final()` is called while connecting', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('close', () => {\n          wss.close(done);\n        });\n        duplex.resume();\n        duplex.end();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"makes `_final()` a noop if no socket is assigned","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":142,"column":56,"index":4265},"line":142,"code":"    it('makes `_final()` a noop if no socket is assigned', done => {\n      const server = createServer();\n      server.on('upgrade', (request, socket) => {\n        socket.on('end', socket.end);\n        const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', 'Sec-WebSocket-Accept: foo'];\n        socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n      });\n      server.listen(() => {\n        const called = [];\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        const duplex = WebSocket.createWebSocketStream(ws);\n        const final = duplex._final;\n\n        duplex._final = callback => {\n          called.push('final');\n          assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n          assert.strictEqual(ws._socket, null);\n          final(callback);\n        };\n\n        duplex.on('error', err => {\n          called.push('error');\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'Invalid Sec-WebSocket-Accept header');\n        });\n        duplex.on('finish', () => {\n          called.push('finish');\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(called, ['final', 'error']);\n          server.close(done);\n        });\n        ws.on('upgrade', () => {\n          process.nextTick(() => {\n            duplex.end();\n          });\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"reemits errors","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":181,"column":22,"index":5644},"line":181,"code":"    it('reemits errors', done => {\n      let duplexCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          duplex.on('close', () => {\n            duplexCloseEventEmitted = true;\n            if (serverClientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws._socket.write(Buffer.from([0x85, 0x00]));\n\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1002);\n          assert.deepStrictEqual(reason, EMPTY_BUFFER);\n          serverClientCloseEventEmitted = true;\n          if (duplexCloseEventEmitted) wss.close(done);\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"does not swallow errors that may occur while destroying","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":210,"column":63,"index":6792},"line":210,"code":"    it('does not swallow errors that may occur while destroying', done => {\n      const frame = Buffer.concat(Sender.frame(Buffer.from([0x22, 0xfa, 0xec, 0x78]), {\n        fin: true,\n        rsv1: true,\n        opcode: 0x02,\n        mask: false,\n        readOnly: false\n      }));\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.code, 'Z_DATA_ERROR');\n          assert.strictEqual(err.errno, -3);\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n        });\n        let bytesRead = 0;\n        ws.on('open', () => {\n          ws._socket.on('data', chunk => {\n            bytesRead += chunk.length;\n            if (bytesRead === frame.length) duplex.destroy();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws._socket.write(frame);\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"does not suppress the throwing behavior of 'error' events","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":244,"column":65,"index":7901},"line":244,"code":"    it(\"does not suppress the throwing behavior of 'error' events\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        createWebSocketStream(ws);\n      });\n      wss.on('connection', ws => {\n        ws._socket.write(Buffer.from([0x85, 0x00]));\n      });\n      assert.strictEqual(process.listenerCount('uncaughtException'), 1);\n      const [listener] = process.listeners('uncaughtException');\n      process.removeAllListeners('uncaughtException');\n      process.once('uncaughtException', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n        process.on('uncaughtException', listener);\n        wss.close(done);\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"is destroyed after 'end' and 'finish' are emitted (1/2)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":264,"column":63,"index":8731},"line":264,"code":"    it(\"is destroyed after 'end' and 'finish' are emitted (1/2)\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const events = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('end', () => {\n          events.push('end');\n          assert.ok(duplex.destroyed);\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(events, ['finish', 'end']);\n          wss.close(done);\n        });\n        duplex.on('finish', () => {\n          events.push('finish');\n          assert.ok(!duplex.destroyed);\n          assert.ok(duplex.readable);\n          duplex.resume();\n        });\n        ws.on('close', () => {\n          duplex.end();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.send('foo');\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"is destroyed after 'end' and 'finish' are emitted (2/2)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":294,"column":63,"index":9641},"line":294,"code":"    it(\"is destroyed after 'end' and 'finish' are emitted (2/2)\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const events = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('end', () => {\n          events.push('end');\n          assert.ok(!duplex.destroyed);\n          assert.ok(duplex.writable);\n          duplex.end();\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(events, ['end', 'finish']);\n          wss.close(done);\n        });\n        duplex.on('finish', () => {\n          events.push('finish');\n        });\n        duplex.resume();\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"handles backpressure (1/3)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":320,"column":34,"index":10414},"line":320,"code":"    it('handles backpressure (1/3)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        // eslint-disable-next-line no-unused-vars\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        const duplex = createWebSocketStream(ws);\n        duplex.resume();\n        duplex.on('drain', () => {\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n          duplex.end();\n        });\n        const chunk = randomBytes(1024);\n        let ret;\n\n        do {\n          ret = duplex.write(chunk);\n        } while (ret !== false);\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"handles backpressure (2/3)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":344,"column":34,"index":11091},"line":344,"code":"    it('handles backpressure (2/3)', done => {\n      const wss = new WebSocket.Server({\n        port: 0,\n        perMessageDeflate: true\n      }, () => {\n        const called = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        const read = duplex._read;\n\n        duplex._read = () => {\n          duplex._read = read;\n          called.push('read');\n          assert.ok(ws._receiver._writableState.needDrain);\n          read();\n          assert.ok(ws._socket.isPaused());\n        };\n\n        ws.on('open', () => {\n          ws._socket.on('pause', () => {\n            duplex.resume();\n          });\n\n          ws._receiver.on('drain', () => {\n            called.push('drain');\n            assert.ok(!ws._socket.isPaused());\n            duplex.end();\n          });\n\n          const opts = {\n            fin: true,\n            opcode: 0x02,\n            mask: false,\n            readOnly: false\n          };\n          const list = [...Sender.frame(randomBytes(16 * 1024), {\n            rsv1: false,\n            ...opts\n          }), ...Sender.frame(Buffer.alloc(1), {\n            rsv1: true,\n            ...opts\n          })]; // This hack is used because there is no guarantee that more than\n          // 16 KiB will be sent as a single TCP packet.\n\n          ws._socket.push(Buffer.concat(list));\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(called, ['read', 'drain']);\n          wss.close(done);\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"handles backpressure (3/3)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":396,"column":34,"index":12635},"line":396,"code":"    it('handles backpressure (3/3)', done => {\n      const wss = new WebSocket.Server({\n        port: 0,\n        perMessageDeflate: true\n      }, () => {\n        const called = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        const read = duplex._read;\n\n        duplex._read = () => {\n          called.push('read');\n          assert.ok(!ws._receiver._writableState.needDrain);\n          read();\n          assert.ok(!ws._socket.isPaused());\n          duplex.end();\n        };\n\n        ws.on('open', () => {\n          ws._receiver.on('drain', () => {\n            called.push('drain');\n            assert.ok(ws._socket.isPaused());\n            duplex.resume();\n          });\n\n          const opts = {\n            fin: true,\n            opcode: 0x02,\n            mask: false,\n            readOnly: false\n          };\n          const list = [...Sender.frame(randomBytes(16 * 1024), {\n            rsv1: false,\n            ...opts\n          }), ...Sender.frame(Buffer.alloc(1), {\n            rsv1: true,\n            ...opts\n          })];\n\n          ws._socket.push(Buffer.concat(list));\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(called, ['drain', 'read']);\n          wss.close(done);\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"can be destroyed (1/2)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":443,"column":30,"index":13964},"line":443,"code":"    it('can be destroyed (1/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const error = new Error('Oops');\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('error', err => {\n          assert.strictEqual(err, error);\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n        });\n        ws.on('open', () => {\n          duplex.destroy(error);\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"can be destroyed (2/2)","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":461,"column":30,"index":14509},"line":461,"code":"    it('can be destroyed (2/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        duplex.on('close', () => {\n          wss.close(done);\n        });\n        ws.on('open', () => {\n          duplex.destroy();\n        });\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"converts text messages to strings in readable object mode","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":475,"column":65,"index":14947},"line":475,"code":"    it('converts text messages to strings in readable object mode', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const events = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws, {\n          readableObjectMode: true\n        });\n        duplex.on('data', data => {\n          events.push('data');\n          assert.strictEqual(data, 'foo');\n        });\n        duplex.on('end', () => {\n          events.push('end');\n          duplex.end();\n        });\n        duplex.on('close', () => {\n          assert.deepStrictEqual(events, ['data', 'end']);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.send('foo');\n        ws.close();\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"resumes the socket if `readyState` is `CLOSING`","suites":["createWebSocketStream","The returned stream"],"updatePoint":{"line":502,"column":55,"index":15749},"line":502,"code":"    it('resumes the socket if `readyState` is `CLOSING`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const duplex = createWebSocketStream(ws);\n        ws.on('message', () => {\n          assert.ok(ws._socket.isPaused());\n          duplex.on('close', () => {\n            wss.close(done);\n          });\n          duplex.end();\n          process.nextTick(() => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n            duplex.resume();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws.send(randomBytes(16 * 1024));\n      });\n    });","file":"create-websocket-stream.test.js","skipped":false,"dir":"test"},{"name":"takes a `type` argument","suites":["Event","#ctor"],"updatePoint":{"line":14,"column":31,"index":233},"line":14,"code":"    it('takes a `type` argument', () => {\n      const event = new Event('foo');\n      assert.strictEqual(event.type, 'foo');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["Event","Properties","`target`"],"updatePoint":{"line":21,"column":40,"index":447},"line":21,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'target');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to `null`","suites":["Event","Properties","`target`"],"updatePoint":{"line":28,"column":28,"index":797},"line":28,"code":"      it('defaults to `null`', () => {\n        const event = new Event('foo');\n        assert.strictEqual(event.target, null);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["Event","Properties","`type`"],"updatePoint":{"line":34,"column":40,"index":985},"line":34,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'type');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"inherits from `Event`","suites":["CloseEvent"],"updatePoint":{"line":45,"column":27,"index":1381},"line":45,"code":"  it('inherits from `Event`', () => {\n    assert.ok(CloseEvent.prototype instanceof Event);\n  });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes a `type` argument","suites":["CloseEvent","#ctor"],"updatePoint":{"line":49,"column":31,"index":1511},"line":49,"code":"    it('takes a `type` argument', () => {\n      const event = new CloseEvent('foo');\n      assert.strictEqual(event.type, 'foo');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes an optional `options` argument","suites":["CloseEvent","#ctor"],"updatePoint":{"line":53,"column":44,"index":1662},"line":53,"code":"    it('takes an optional `options` argument', () => {\n      const event = new CloseEvent('close', {\n        code: 1000,\n        reason: 'foo',\n        wasClean: true\n      });\n      assert.strictEqual(event.type, 'close');\n      assert.strictEqual(event.code, 1000);\n      assert.strictEqual(event.reason, 'foo');\n      assert.strictEqual(event.wasClean, true);\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["CloseEvent","Properties","`code`"],"updatePoint":{"line":67,"column":40,"index":2099},"line":67,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(CloseEvent.prototype, 'code');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to 0","suites":["CloseEvent","Properties","`code`"],"updatePoint":{"line":74,"column":23,"index":2447},"line":74,"code":"      it('defaults to 0', () => {\n        const event = new CloseEvent('close');\n        assert.strictEqual(event.code, 0);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["CloseEvent","Properties","`reason`"],"updatePoint":{"line":80,"column":40,"index":2639},"line":80,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(CloseEvent.prototype, 'reason');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to an empty string","suites":["CloseEvent","Properties","`reason`"],"updatePoint":{"line":87,"column":37,"index":3003},"line":87,"code":"      it('defaults to an empty string', () => {\n        const event = new CloseEvent('close');\n        assert.strictEqual(event.reason, '');\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["CloseEvent","Properties","`wasClean`"],"updatePoint":{"line":93,"column":40,"index":3200},"line":93,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(CloseEvent.prototype, 'wasClean');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to false","suites":["CloseEvent","Properties","`wasClean`"],"updatePoint":{"line":100,"column":27,"index":3556},"line":100,"code":"      it('defaults to false', () => {\n        const event = new CloseEvent('close');\n        assert.strictEqual(event.wasClean, false);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"inherits from `Event`","suites":["ErrorEvent"],"updatePoint":{"line":108,"column":27,"index":3751},"line":108,"code":"  it('inherits from `Event`', () => {\n    assert.ok(ErrorEvent.prototype instanceof Event);\n  });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes a `type` argument","suites":["ErrorEvent","#ctor"],"updatePoint":{"line":112,"column":31,"index":3881},"line":112,"code":"    it('takes a `type` argument', () => {\n      const event = new ErrorEvent('foo');\n      assert.strictEqual(event.type, 'foo');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes an optional `options` argument","suites":["ErrorEvent","#ctor"],"updatePoint":{"line":116,"column":44,"index":4032},"line":116,"code":"    it('takes an optional `options` argument', () => {\n      const error = new Error('Oops');\n      const event = new ErrorEvent('error', {\n        error,\n        message: error.message\n      });\n      assert.strictEqual(event.type, 'error');\n      assert.strictEqual(event.error, error);\n      assert.strictEqual(event.message, error.message);\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["ErrorEvent","Properties","`error`"],"updatePoint":{"line":129,"column":40,"index":4452},"line":129,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(ErrorEvent.prototype, 'error');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to `null`","suites":["ErrorEvent","Properties","`error`"],"updatePoint":{"line":136,"column":28,"index":4806},"line":136,"code":"      it('defaults to `null`', () => {\n        const event = new ErrorEvent('error');\n        assert.strictEqual(event.error, null);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["ErrorEvent","Properties","`message`"],"updatePoint":{"line":142,"column":40,"index":5003},"line":142,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(ErrorEvent.prototype, 'message');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to an empty string","suites":["ErrorEvent","Properties","`message`"],"updatePoint":{"line":149,"column":37,"index":5368},"line":149,"code":"      it('defaults to an empty string', () => {\n        const event = new ErrorEvent('error');\n        assert.strictEqual(event.message, '');\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"inherits from `Event`","suites":["MessageEvent"],"updatePoint":{"line":157,"column":27,"index":5561},"line":157,"code":"  it('inherits from `Event`', () => {\n    assert.ok(MessageEvent.prototype instanceof Event);\n  });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes a `type` argument","suites":["MessageEvent","#ctor"],"updatePoint":{"line":161,"column":31,"index":5693},"line":161,"code":"    it('takes a `type` argument', () => {\n      const event = new MessageEvent('foo');\n      assert.strictEqual(event.type, 'foo');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"takes an optional `options` argument","suites":["MessageEvent","#ctor"],"updatePoint":{"line":165,"column":44,"index":5846},"line":165,"code":"    it('takes an optional `options` argument', () => {\n      const event = new MessageEvent('message', {\n        data: 'bar'\n      });\n      assert.strictEqual(event.type, 'message');\n      assert.strictEqual(event.data, 'bar');\n    });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["MessageEvent","Properties","`data`"],"updatePoint":{"line":175,"column":40,"index":6149},"line":175,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(MessageEvent.prototype, 'data');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"defaults to `null`","suites":["MessageEvent","Properties","`data`"],"updatePoint":{"line":182,"column":28,"index":6504},"line":182,"code":"      it('defaults to `null`', () => {\n        const event = new MessageEvent('message');\n        assert.strictEqual(event.data, null);\n      });","file":"event-target.test.js","skipped":false,"dir":"test"},{"name":"parses a single extension","suites":["extension","parse"],"updatePoint":{"line":12,"column":33,"index":202},"line":12,"code":"    it('parses a single extension', () => {\n      assert.deepStrictEqual(parse('foo'), {\n        foo: [{\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"parses params","suites":["extension","parse"],"updatePoint":{"line":20,"column":21,"index":375},"line":20,"code":"    it('parses params', () => {\n      assert.deepStrictEqual(parse('foo;bar;baz=1;bar=2'), {\n        foo: [{\n          bar: [true, '2'],\n          baz: ['1'],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"parses multiple extensions","suites":["extension","parse"],"updatePoint":{"line":30,"column":34,"index":627},"line":30,"code":"    it('parses multiple extensions', () => {\n      assert.deepStrictEqual(parse('foo,bar;baz,foo;baz'), {\n        foo: [{\n          __proto__: null\n        }, {\n          baz: [true],\n          __proto__: null\n        }],\n        bar: [{\n          baz: [true],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"parses quoted params","suites":["extension","parse"],"updatePoint":{"line":45,"column":28,"index":962},"line":45,"code":"    it('parses quoted params', () => {\n      assert.deepStrictEqual(parse('foo;bar=\"hi\"'), {\n        foo: [{\n          bar: ['hi'],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.deepStrictEqual(parse('foo;bar=\"\\\\0\"'), {\n        foo: [{\n          bar: ['0'],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.deepStrictEqual(parse('foo;bar=\"b\\\\a\\\\z\"'), {\n        foo: [{\n          bar: ['baz'],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.deepStrictEqual(parse('foo;bar=\"b\\\\az\";bar'), {\n        foo: [{\n          bar: ['baz', true],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.throws(() => parse('foo;bar=\"baz\"qux'), /^SyntaxError: Unexpected character at index 13$/);\n      assert.throws(() => parse('foo;bar=\"baz\" qux'), /^SyntaxError: Unexpected character at index 14$/);\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"works with names that match `Object.prototype` property names","suites":["extension","parse"],"updatePoint":{"line":77,"column":69,"index":1941},"line":77,"code":"    it('works with names that match `Object.prototype` property names', () => {\n      assert.deepStrictEqual(parse('hasOwnProperty, toString'), {\n        hasOwnProperty: [{\n          __proto__: null\n        }],\n        toString: [{\n          __proto__: null\n        }],\n        __proto__: null\n      });\n      assert.deepStrictEqual(parse('foo;constructor'), {\n        foo: [{\n          constructor: [true],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"ignores the optional white spaces","suites":["extension","parse"],"updatePoint":{"line":95,"column":41,"index":2401},"line":95,"code":"    it('ignores the optional white spaces', () => {\n      const header = 'foo; bar\\t; \\tbaz=1\\t ;  bar=\"1\"\\t\\t, \\tqux\\t ;norf';\n      assert.deepStrictEqual(parse(header), {\n        foo: [{\n          bar: [true, '1'],\n          baz: ['1'],\n          __proto__: null\n        }],\n        qux: [{\n          norf: [true],\n          __proto__: null\n        }],\n        __proto__: null\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a name is empty","suites":["extension","parse"],"updatePoint":{"line":110,"column":42,"index":2800},"line":110,"code":"    it('throws an error if a name is empty', () => {\n      [[',', 0], ['foo,,', 4], ['foo,  ,', 6], ['foo;=', 4], ['foo; =', 5], ['foo;;', 4], ['foo; ;', 5], ['foo;bar=,', 8], ['foo;bar=\"\"', 9]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a white space is misplaced","suites":["extension","parse"],"updatePoint":{"line":115,"column":53,"index":3167},"line":115,"code":"    it('throws an error if a white space is misplaced', () => {\n      [[' foo', 0], ['f oo', 2], ['foo;ba r', 7], ['foo;bar =', 8], ['foo;bar= ', 8], ['foo;bar=ba z', 11]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a token contains invalid characters","suites":["extension","parse"],"updatePoint":{"line":120,"column":62,"index":3509},"line":120,"code":"    it('throws an error if a token contains invalid characters', () => {\n      [['f@o', 1], ['f\\\\oo', 1], ['\"foo\"', 0], ['f\"oo\"', 1], ['foo;b@r', 5], ['foo;b\\\\ar', 5], ['foo;\"bar\"', 4], ['foo;b\"ar\"', 5], ['foo;bar=b@z', 9], ['foo;bar=b\\\\az ', 9], ['foo;bar=\"b@z\"', 10], ['foo;bar=\"baz;\"', 12], ['foo;bar=b\"az\"', 9], ['foo;bar=\"\\\\\\\\\"', 10]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the header value ends prematurely","suites":["extension","parse"],"updatePoint":{"line":125,"column":60,"index":4008},"line":125,"code":"    it('throws an error if the header value ends prematurely', () => {\n      ['', 'foo ', 'foo\\t', 'foo, ', 'foo;', 'foo;bar ', 'foo;bar,', 'foo;bar; ', 'foo;bar=', 'foo;bar=\"baz', 'foo;bar=\"1\\\\', 'foo;bar=\"baz\" '].forEach(header => {\n        assert.throws(() => parse(header), /^SyntaxError: Unexpected end of input$/);\n      });\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"formats a single extension","suites":["extension","format"],"updatePoint":{"line":132,"column":34,"index":4356},"line":132,"code":"    it('formats a single extension', () => {\n      const extensions = format({\n        foo: {}\n      });\n      assert.strictEqual(extensions, 'foo');\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"formats params","suites":["extension","format"],"updatePoint":{"line":138,"column":22,"index":4502},"line":138,"code":"    it('formats params', () => {\n      const extensions = format({\n        foo: {\n          bar: [true, 2],\n          baz: 1\n        }\n      });\n      assert.strictEqual(extensions, 'foo; bar; bar=2; baz=1');\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"formats multiple extensions","suites":["extension","format"],"updatePoint":{"line":147,"column":35,"index":4732},"line":147,"code":"    it('formats multiple extensions', () => {\n      const extensions = format({\n        foo: [{}, {\n          baz: true\n        }],\n        bar: {\n          baz: true\n        }\n      });\n      assert.strictEqual(extensions, 'foo, foo; baz, bar; baz');\n    });","file":"extension.test.js","skipped":false,"dir":"test"},{"name":"takes a `concurrency` argument","suites":["Limiter","#ctor"],"updatePoint":{"line":9,"column":38,"index":189},"line":9,"code":"    it('takes a `concurrency` argument', () => {\n      const limiter = new Limiter(0);\n      assert.strictEqual(limiter.concurrency, Infinity);\n    });","file":"limiter.test.js","skipped":false,"dir":"test"},{"name":"limits the number of jobs allowed to run concurrently","suites":["Limiter","#kRun"],"updatePoint":{"line":15,"column":61,"index":398},"line":15,"code":"    it('limits the number of jobs allowed to run concurrently', done => {\n      const limiter = new Limiter(1);\n      limiter.add(callback => {\n        setImmediate(() => {\n          callback();\n          assert.strictEqual(limiter.jobs.length, 0);\n          assert.strictEqual(limiter.pending, 1);\n        });\n      });\n      limiter.add(callback => {\n        setImmediate(() => {\n          callback();\n          assert.strictEqual(limiter.pending, 0);\n          done();\n        });\n      });\n      assert.strictEqual(limiter.jobs.length, 1);\n    });","file":"limiter.test.js","skipped":false,"dir":"test"},{"name":"creates an offer","suites":["PerMessageDeflate","#offer"],"updatePoint":{"line":11,"column":24,"index":255},"line":11,"code":"    it('creates an offer', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      assert.deepStrictEqual(perMessageDeflate.offer(), {\n        client_max_window_bits: true\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"uses the configuration options","suites":["PerMessageDeflate","#offer"],"updatePoint":{"line":17,"column":38,"index":474},"line":17,"code":"    it('uses the configuration options', () => {\n      const perMessageDeflate = new PerMessageDeflate({\n        serverNoContextTakeover: true,\n        clientNoContextTakeover: true,\n        serverMaxWindowBits: 10,\n        clientMaxWindowBits: 11\n      });\n      assert.deepStrictEqual(perMessageDeflate.offer(), {\n        server_no_context_takeover: true,\n        client_no_context_takeover: true,\n        server_max_window_bits: 10,\n        client_max_window_bits: 11\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a parameter has multiple values","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":33,"column":58,"index":1019},"line":33,"code":"    it('throws an error if a parameter has multiple values', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate; server_no_context_takeover; server_no_context_takeover');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Parameter \"server_no_context_takeover\" must have only a single value$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a parameter has an invalid name","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":38,"column":58,"index":1441},"line":38,"code":"    it('throws an error if a parameter has an invalid name', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate;foo');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Unknown parameter \"foo\"$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_no_context_takeover has a value","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":43,"column":65,"index":1773},"line":43,"code":"    it('throws an error if client_no_context_takeover has a value', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate; client_no_context_takeover=10');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"client_no_context_takeover\": 10$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_no_context_takeover has a value","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":48,"column":65,"index":2173},"line":48,"code":"    it('throws an error if server_no_context_takeover has a value', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate; server_no_context_takeover=10');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"server_no_context_takeover\": 10$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_max_window_bits has an invalid value","suites":["PerMessageDeflate","#accept"],"updatePoint":{"line":53,"column":70,"index":2578},"line":53,"code":"    it('throws an error if server_max_window_bits has an invalid value', () => {\n      const perMessageDeflate = new PerMessageDeflate();\n      let extensions = extension.parse('permessage-deflate; server_max_window_bits=7');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"server_max_window_bits\": 7$/);\n      extensions = extension.parse('permessage-deflate; server_max_window_bits');\n      assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"server_max_window_bits\": true$/);\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts an offer with no parameters","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":61,"column":45,"index":3224},"line":61,"code":"      it('accepts an offer with no parameters', () => {\n        const perMessageDeflate = new PerMessageDeflate({}, true);\n        assert.deepStrictEqual(perMessageDeflate.accept([{}]), {});\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts an offer with parameters","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":65,"column":42,"index":3422},"line":65,"code":"      it('accepts an offer with parameters', () => {\n        const perMessageDeflate = new PerMessageDeflate({}, true);\n        const extensions = extension.parse('permessage-deflate; server_no_context_takeover; ' + 'client_no_context_takeover; server_max_window_bits=10; ' + 'client_max_window_bits=11');\n        assert.deepStrictEqual(perMessageDeflate.accept(extensions['permessage-deflate']), {\n          server_no_context_takeover: true,\n          client_no_context_takeover: true,\n          server_max_window_bits: 10,\n          client_max_window_bits: 11,\n          __proto__: null\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"prefers the configuration options","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":76,"column":43,"index":4034},"line":76,"code":"      it('prefers the configuration options', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverNoContextTakeover: true,\n          clientNoContextTakeover: true,\n          serverMaxWindowBits: 12,\n          clientMaxWindowBits: 11\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_max_window_bits=14; client_max_window_bits=13');\n        assert.deepStrictEqual(perMessageDeflate.accept(extensions['permessage-deflate']), {\n          server_no_context_takeover: true,\n          client_no_context_takeover: true,\n          server_max_window_bits: 12,\n          client_max_window_bits: 11,\n          __proto__: null\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts the first supported offer","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":92,"column":43,"index":4740},"line":92,"code":"      it('accepts the first supported offer', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverMaxWindowBits: 11\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_max_window_bits=10, permessage-deflate');\n        assert.deepStrictEqual(perMessageDeflate.accept(extensions['permessage-deflate']), {\n          server_max_window_bits: 11,\n          __proto__: null\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_no_context_takeover is unsupported","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":102,"column":70,"index":5223},"line":102,"code":"      it('throws an error if server_no_context_takeover is unsupported', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverNoContextTakeover: false\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_no_context_takeover');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: None of the extension offers can be accepted$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_max_window_bits is unsupported","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":109,"column":66,"index":5667},"line":109,"code":"      it('throws an error if server_max_window_bits is unsupported', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverMaxWindowBits: false\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_max_window_bits=10');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: None of the extension offers can be accepted$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if server_max_window_bits is less than configuration","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":116,"column":78,"index":6118},"line":116,"code":"      it('throws an error if server_max_window_bits is less than configuration', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          serverMaxWindowBits: 11\n        }, true);\n        const extensions = extension.parse('permessage-deflate; server_max_window_bits=10');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: None of the extension offers can be accepted$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits is unsupported on client","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":123,"column":76,"index":6564},"line":123,"code":"      it('throws an error if client_max_window_bits is unsupported on client', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientMaxWindowBits: 10\n        }, true);\n        const extensions = extension.parse('permessage-deflate');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: None of the extension offers can be accepted$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits has an invalid value","suites":["PerMessageDeflate","#accept","As server"],"updatePoint":{"line":130,"column":72,"index":6979},"line":130,"code":"      it('throws an error if client_max_window_bits has an invalid value', () => {\n        const perMessageDeflate = new PerMessageDeflate({}, true);\n        const extensions = extension.parse('permessage-deflate; client_max_window_bits=16');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"client_max_window_bits\": 16$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts a response with no parameters","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":137,"column":47,"index":7411},"line":137,"code":"      it('accepts a response with no parameters', () => {\n        const perMessageDeflate = new PerMessageDeflate({});\n        assert.deepStrictEqual(perMessageDeflate.accept([{}]), {});\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"accepts a response with parameters","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":141,"column":44,"index":7605},"line":141,"code":"      it('accepts a response with parameters', () => {\n        const perMessageDeflate = new PerMessageDeflate({});\n        const extensions = extension.parse('permessage-deflate; server_no_context_takeover; ' + 'client_no_context_takeover; server_max_window_bits=10; ' + 'client_max_window_bits=11');\n        assert.deepStrictEqual(perMessageDeflate.accept(extensions['permessage-deflate']), {\n          server_no_context_takeover: true,\n          client_no_context_takeover: true,\n          server_max_window_bits: 10,\n          client_max_window_bits: 11,\n          __proto__: null\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_no_context_takeover is unsupported","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":152,"column":70,"index":8238},"line":152,"code":"      it('throws an error if client_no_context_takeover is unsupported', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientNoContextTakeover: false\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Unexpected parameter \"client_no_context_takeover\"$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits is unsupported","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":159,"column":66,"index":8681},"line":159,"code":"      it('throws an error if client_max_window_bits is unsupported', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientMaxWindowBits: false\n        });\n        const extensions = extension.parse('permessage-deflate; client_max_window_bits=10');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Unexpected or invalid parameter \"client_max_window_bits\"$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits is greater than configuration","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":166,"column":81,"index":9141},"line":166,"code":"      it('throws an error if client_max_window_bits is greater than configuration', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientMaxWindowBits: 10\n        });\n        const extensions = extension.parse('permessage-deflate; client_max_window_bits=11');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^Error: Unexpected or invalid parameter \"client_max_window_bits\"$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"throws an error if client_max_window_bits has an invalid value","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":173,"column":72,"index":9589},"line":173,"code":"      it('throws an error if client_max_window_bits has an invalid value', () => {\n        const perMessageDeflate = new PerMessageDeflate();\n        let extensions = extension.parse('permessage-deflate; client_max_window_bits=16');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"client_max_window_bits\": 16$/);\n        extensions = extension.parse('permessage-deflate; client_max_window_bits');\n        assert.throws(() => perMessageDeflate.accept(extensions['permessage-deflate']), /^TypeError: Invalid value for parameter \"client_max_window_bits\": true$/);\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"uses the config value if client_max_window_bits is not specified","suites":["PerMessageDeflate","#accept","As client"],"updatePoint":{"line":180,"column":74,"index":10244},"line":180,"code":"      it('uses the config value if client_max_window_bits is not specified', () => {\n        const perMessageDeflate = new PerMessageDeflate({\n          clientMaxWindowBits: 10\n        });\n        assert.deepStrictEqual(perMessageDeflate.accept([{}]), {\n          client_max_window_bits: 10\n        });\n      });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"works with unfragmented messages","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":191,"column":40,"index":10585},"line":191,"code":"    it('works with unfragmented messages', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const buf = Buffer.from([1, 2, 3]);\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.compress(buf, true, (err, data) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(data, true, (err, data) => {\n          if (err) return done(err);\n          assert.ok(data.equals(buf));\n          done();\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"works with fragmented messages","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":204,"column":38,"index":11059},"line":204,"code":"    it('works with fragmented messages', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const buf = Buffer.from([1, 2, 3, 4]);\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.compress(buf.slice(0, 2), false, (err, compressed1) => {\n        if (err) return done(err);\n        perMessageDeflate.compress(buf.slice(2), true, (err, compressed2) => {\n          if (err) return done(err);\n          perMessageDeflate.decompress(compressed1, false, (err, data1) => {\n            if (err) return done(err);\n            perMessageDeflate.decompress(compressed2, true, (err, data2) => {\n              if (err) return done(err);\n              assert.ok(Buffer.concat([data1, data2]).equals(buf));\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"works with the negotiated parameters","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":223,"column":44,"index":11873},"line":223,"code":"    it('works with the negotiated parameters', done => {\n      const perMessageDeflate = new PerMessageDeflate({\n        memLevel: 5,\n        level: 9\n      });\n      const extensions = extension.parse('permessage-deflate; server_no_context_takeover; ' + 'client_no_context_takeover; server_max_window_bits=10; ' + 'client_max_window_bits=11');\n      const buf = Buffer.from(\"Some compressible data, it's compressible.\");\n      perMessageDeflate.accept(extensions['permessage-deflate']);\n      perMessageDeflate.compress(buf, true, (err, data) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(data, true, (err, data) => {\n          if (err) return done(err);\n          assert.ok(data.equals(buf));\n          done();\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"honors the `level` option","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":240,"column":33,"index":12636},"line":240,"code":"    it('honors the `level` option', done => {\n      const lev0 = new PerMessageDeflate({\n        zlibDeflateOptions: {\n          level: 0\n        }\n      });\n      const lev9 = new PerMessageDeflate({\n        zlibDeflateOptions: {\n          level: 9\n        }\n      });\n      const extensionStr = 'permessage-deflate; server_no_context_takeover; ' + 'client_no_context_takeover; server_max_window_bits=10; ' + 'client_max_window_bits=11';\n      const buf = Buffer.from(\"Some compressible data, it's compressible.\");\n      lev0.accept(extension.parse(extensionStr)['permessage-deflate']);\n      lev9.accept(extension.parse(extensionStr)['permessage-deflate']);\n      lev0.compress(buf, true, (err, compressed1) => {\n        if (err) return done(err);\n        lev0.decompress(compressed1, true, (err, decompressed1) => {\n          if (err) return done(err);\n          lev9.compress(buf, true, (err, compressed2) => {\n            if (err) return done(err);\n            lev9.decompress(compressed2, true, (err, decompressed2) => {\n              if (err) return done(err); // Level 0 compression actually adds a few bytes due to headers.\n\n              assert.ok(compressed1.length > buf.length); // Level 9 should not, of course.\n\n              assert.ok(compressed2.length < buf.length); // Ensure they both decompress back properly.\n\n              assert.ok(decompressed1.equals(buf));\n              assert.ok(decompressed2.equals(buf));\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"honors the `zlib{Deflate,Inflate}Options` option","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":276,"column":56,"index":14177},"line":276,"code":"    it('honors the `zlib{Deflate,Inflate}Options` option', done => {\n      const lev0 = new PerMessageDeflate({\n        zlibDeflateOptions: {\n          level: 0,\n          chunkSize: 256\n        },\n        zlibInflateOptions: {\n          chunkSize: 2048\n        }\n      });\n      const lev9 = new PerMessageDeflate({\n        zlibDeflateOptions: {\n          level: 9,\n          chunkSize: 128\n        },\n        zlibInflateOptions: {\n          chunkSize: 1024\n        }\n      }); // Note no context takeover so we can get a hold of the raw streams after\n      // we do the dance.\n\n      const extensionStr = 'permessage-deflate; server_max_window_bits=10; ' + 'client_max_window_bits=11';\n      const buf = Buffer.from(\"Some compressible data, it's compressible.\");\n      lev0.accept(extension.parse(extensionStr)['permessage-deflate']);\n      lev9.accept(extension.parse(extensionStr)['permessage-deflate']);\n      lev0.compress(buf, true, (err, compressed1) => {\n        if (err) return done(err);\n        lev0.decompress(compressed1, true, (err, decompressed1) => {\n          if (err) return done(err);\n          lev9.compress(buf, true, (err, compressed2) => {\n            if (err) return done(err);\n            lev9.decompress(compressed2, true, (err, decompressed2) => {\n              if (err) return done(err); // Level 0 compression actually adds a few bytes due to headers.\n\n              assert.ok(compressed1.length > buf.length); // Level 9 should not, of course.\n\n              assert.ok(compressed2.length < buf.length); // Ensure they both decompress back properly.\n\n              assert.ok(decompressed1.equals(buf));\n              assert.ok(decompressed2.equals(buf)); // Assert options were set.\n\n              assert.ok(lev0._deflate._level === 0);\n              assert.ok(lev9._deflate._level === 9);\n              assert.ok(lev0._deflate._chunkSize === 256);\n              assert.ok(lev9._deflate._chunkSize === 128);\n              assert.ok(lev0._inflate._chunkSize === 2048);\n              assert.ok(lev9._inflate._chunkSize === 1024);\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"doesn't use contex takeover if not allowed","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":329,"column":50,"index":16311},"line":329,"code":"    it(\"doesn't use contex takeover if not allowed\", done => {\n      const perMessageDeflate = new PerMessageDeflate({}, true);\n      const extensions = extension.parse('permessage-deflate;server_no_context_takeover');\n      const buf = Buffer.from('foofoo');\n      perMessageDeflate.accept(extensions['permessage-deflate']);\n      perMessageDeflate.compress(buf, true, (err, compressed1) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(compressed1, true, (err, data) => {\n          if (err) return done(err);\n          assert.ok(data.equals(buf));\n          perMessageDeflate.compress(data, true, (err, compressed2) => {\n            if (err) return done(err);\n            assert.strictEqual(compressed2.length, compressed1.length);\n            perMessageDeflate.decompress(compressed2, true, (err, data) => {\n              if (err) return done(err);\n              assert.ok(data.equals(buf));\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"uses contex takeover if allowed","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":351,"column":39,"index":17305},"line":351,"code":"    it('uses contex takeover if allowed', done => {\n      const perMessageDeflate = new PerMessageDeflate({}, true);\n      const extensions = extension.parse('permessage-deflate');\n      const buf = Buffer.from('foofoo');\n      perMessageDeflate.accept(extensions['permessage-deflate']);\n      perMessageDeflate.compress(buf, true, (err, compressed1) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(compressed1, true, (err, data) => {\n          if (err) return done(err);\n          assert.ok(data.equals(buf));\n          perMessageDeflate.compress(data, true, (err, compressed2) => {\n            if (err) return done(err);\n            assert.ok(compressed2.length < compressed1.length);\n            perMessageDeflate.decompress(compressed2, true, (err, data) => {\n              if (err) return done(err);\n              assert.ok(data.equals(buf));\n              done();\n            });\n          });\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"calls the callback when an error occurs (inflate)","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":373,"column":57,"index":18282},"line":373,"code":"    it('calls the callback when an error occurs (inflate)', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const data = Buffer.from('something invalid');\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.decompress(data, true, err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.code, 'Z_DATA_ERROR');\n        assert.strictEqual(err.errno, -3);\n        done();\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"doesn't call the callback twice when `maxPayload` is exceeded","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":384,"column":69,"index":18740},"line":384,"code":"    it(\"doesn't call the callback twice when `maxPayload` is exceeded\", done => {\n      const perMessageDeflate = new PerMessageDeflate({}, false, 25);\n      const buf = Buffer.from('A'.repeat(50));\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.compress(buf, true, (err, data) => {\n        if (err) return done(err);\n        perMessageDeflate.decompress(data, true, err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.message, 'Max payload size exceeded');\n          done();\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"calls the callback if the deflate stream is closed prematurely","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":397,"column":70,"index":19300},"line":397,"code":"    it('calls the callback if the deflate stream is closed prematurely', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const buf = Buffer.from('A'.repeat(50));\n      perMessageDeflate.accept([{}]);\n      perMessageDeflate.compress(buf, true, err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'The deflate stream was closed while data was being processed');\n        done();\n      });\n      process.nextTick(() => perMessageDeflate.cleanup());\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"recreates the inflate stream if it ends","suites":["PerMessageDeflate","#compress and #decompress"],"updatePoint":{"line":408,"column":47,"index":19794},"line":408,"code":"    it('recreates the inflate stream if it ends', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      const extensions = extension.parse('permessage-deflate; client_no_context_takeover; ' + 'server_no_context_takeover');\n      const buf = Buffer.from('33343236313533b7000000', 'hex');\n      const expected = Buffer.from('12345678');\n      perMessageDeflate.accept(extensions['permessage-deflate']);\n      perMessageDeflate.decompress(buf, true, (err, data) => {\n        assert.ok(data.equals(expected));\n        perMessageDeflate.decompress(buf, true, (err, data) => {\n          assert.ok(data.equals(expected));\n          done();\n        });\n      });\n    });","file":"permessage-deflate.test.js","skipped":false,"dir":"test"},{"name":"parses an unmasked text message","suites":["Receiver"],"updatePoint":{"line":19,"column":37,"index":377},"line":19,"code":"  it('parses an unmasked text message', done => {\n    const receiver = new Receiver();\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.from('Hello'));\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(Buffer.from('810548656c6c6f', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a close message","suites":["Receiver"],"updatePoint":{"line":28,"column":28,"index":676},"line":28,"code":"  it('parses a close message', done => {\n    const receiver = new Receiver();\n    receiver.on('conclude', (code, data) => {\n      assert.strictEqual(code, 1005);\n      assert.strictEqual(data, EMPTY_BUFFER);\n      done();\n    });\n    receiver.write(Buffer.from('8800', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a close message spanning multiple writes","suites":["Receiver"],"updatePoint":{"line":37,"column":53,"index":985},"line":37,"code":"  it('parses a close message spanning multiple writes', done => {\n    const receiver = new Receiver();\n    receiver.on('conclude', (code, data) => {\n      assert.strictEqual(code, 1000);\n      assert.deepStrictEqual(data, Buffer.from('DONE'));\n      done();\n    });\n    receiver.write(Buffer.from('8806', 'hex'));\n    receiver.write(Buffer.from('03e8444F4E45', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a masked text message","suites":["Receiver"],"updatePoint":{"line":47,"column":34,"index":1342},"line":47,"code":"  it('parses a masked text message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.from('5:::{\"name\":\"echo\"}'));\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(Buffer.from('81933483a86801b992524fa1c60959e68a5216e6cb005ba1d5', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a masked text message longer than 125 B","suites":["Receiver"],"updatePoint":{"line":58,"column":52,"index":1743},"line":58,"code":"  it('parses a masked text message longer than 125 B', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(200));\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x01,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(frame.slice(0, 2));\n    setImmediate(() => receiver.write(frame.slice(2)));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a really long masked text message","suites":["Receiver"],"updatePoint":{"line":79,"column":46,"index":2333},"line":79,"code":"  it('parses a really long masked text message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(64 * 1024));\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x01,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 300 B fragmented masked text message","suites":["Receiver"],"updatePoint":{"line":99,"column":51,"index":2866},"line":99,"code":"  it('parses a 300 B fragmented masked text message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(300));\n    const fragment1 = msg.slice(0, 150);\n    const fragment2 = msg.slice(150);\n    const options = {\n      rsv1: false,\n      mask: true,\n      readOnly: true\n    };\n    const frame1 = Buffer.concat(Sender.frame(fragment1, {\n      fin: false,\n      opcode: 0x01,\n      ...options\n    }));\n    const frame2 = Buffer.concat(Sender.frame(fragment2, {\n      fin: true,\n      opcode: 0x00,\n      ...options\n    }));\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(frame1);\n    receiver.write(frame2);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a ping message","suites":["Receiver"],"updatePoint":{"line":129,"column":27,"index":3630},"line":129,"code":"  it('parses a ping message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('Hello');\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('ping', data => {\n      assert.deepStrictEqual(data, msg);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a ping message with no data","suites":["Receiver"],"updatePoint":{"line":148,"column":40,"index":4095},"line":148,"code":"  it('parses a ping message with no data', done => {\n    const receiver = new Receiver();\n    receiver.on('ping', data => {\n      assert.strictEqual(data, EMPTY_BUFFER);\n      done();\n    });\n    receiver.write(Buffer.from('8900', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 300 B fragmented masked text message with a ping in the middle (1/2)","suites":["Receiver"],"updatePoint":{"line":156,"column":83,"index":4384},"line":156,"code":"  it('parses a 300 B fragmented masked text message with a ping in the middle (1/2)', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(300));\n    const pingMessage = Buffer.from('Hello');\n    const fragment1 = msg.slice(0, 150);\n    const fragment2 = msg.slice(150);\n    const options = {\n      rsv1: false,\n      mask: true,\n      readOnly: true\n    };\n    const frame1 = Buffer.concat(Sender.frame(fragment1, {\n      fin: false,\n      opcode: 0x01,\n      ...options\n    }));\n    const frame2 = Buffer.concat(Sender.frame(pingMessage, {\n      fin: true,\n      opcode: 0x09,\n      ...options\n    }));\n    const frame3 = Buffer.concat(Sender.frame(fragment2, {\n      fin: true,\n      opcode: 0x00,\n      ...options\n    }));\n    let gotPing = false;\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      assert.ok(gotPing);\n      done();\n    });\n    receiver.on('ping', data => {\n      gotPing = true;\n      assert.ok(data.equals(pingMessage));\n    });\n    receiver.write(frame1);\n    receiver.write(frame2);\n    receiver.write(frame3);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 300 B fragmented masked text message with a ping in the middle (2/2)","suites":["Receiver"],"updatePoint":{"line":199,"column":83,"index":5560},"line":199,"code":"  it('parses a 300 B fragmented masked text message with a ping in the middle (2/2)', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = Buffer.from('A'.repeat(300));\n    const pingMessage = Buffer.from('Hello');\n    const fragment1 = msg.slice(0, 150);\n    const fragment2 = msg.slice(150);\n    const options = {\n      rsv1: false,\n      mask: true,\n      readOnly: false\n    };\n    const frame1 = Buffer.concat(Sender.frame(Buffer.from(fragment1), {\n      fin: false,\n      opcode: 0x01,\n      ...options\n    }));\n    const frame2 = Buffer.concat(Sender.frame(Buffer.from(pingMessage), {\n      fin: true,\n      opcode: 0x09,\n      ...options\n    }));\n    const frame3 = Buffer.concat(Sender.frame(Buffer.from(fragment2), {\n      fin: true,\n      opcode: 0x00,\n      ...options\n    }));\n    let chunks = [];\n\n    const splitBuffer = buf => {\n      const i = Math.floor(buf.length / 2);\n      return [buf.slice(0, i), buf.slice(i)];\n    };\n\n    chunks = chunks.concat(splitBuffer(frame1));\n    chunks = chunks.concat(splitBuffer(frame2));\n    chunks = chunks.concat(splitBuffer(frame3));\n    let gotPing = false;\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(!isBinary);\n      assert.ok(gotPing);\n      done();\n    });\n    receiver.on('ping', data => {\n      gotPing = true;\n      assert.ok(data.equals(pingMessage));\n    });\n\n    for (let i = 0; i < chunks.length; ++i) {\n      receiver.write(chunks[i]);\n    }\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 100 B masked binary message","suites":["Receiver"],"updatePoint":{"line":253,"column":42,"index":7037},"line":253,"code":"  it('parses a 100 B masked binary message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = crypto.randomBytes(100);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 256 B masked binary message","suites":["Receiver"],"updatePoint":{"line":273,"column":42,"index":7549},"line":273,"code":"  it('parses a 256 B masked binary message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = crypto.randomBytes(256);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 200 KiB masked binary message","suites":["Receiver"],"updatePoint":{"line":293,"column":44,"index":8063},"line":293,"code":"  it('parses a 200 KiB masked binary message', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    const msg = crypto.randomBytes(200 * 1024);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a 200 KiB unmasked binary message","suites":["Receiver"],"updatePoint":{"line":313,"column":46,"index":8586},"line":313,"code":"  it('parses a 200 KiB unmasked binary message', done => {\n    const receiver = new Receiver();\n    const msg = crypto.randomBytes(200 * 1024);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: false,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, msg);\n      assert.ok(isBinary);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a compressed message","suites":["Receiver"],"updatePoint":{"line":331,"column":33,"index":9069},"line":331,"code":"  it('parses a compressed message', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    const buf = Buffer.from('Hello');\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, buf);\n      assert.ok(!isBinary);\n      done();\n    });\n    perMessageDeflate.compress(buf, true, (err, data) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0xc1, data.length]));\n      receiver.write(data);\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a compressed and fragmented message","suites":["Receiver"],"updatePoint":{"line":351,"column":48,"index":9709},"line":351,"code":"  it('parses a compressed and fragmented message', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    const buf1 = Buffer.from('foo');\n    const buf2 = Buffer.from('bar');\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.concat([buf1, buf2]));\n      assert.ok(!isBinary);\n      done();\n    });\n    perMessageDeflate.compress(buf1, false, (err, fragment1) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0x41, fragment1.length]));\n      receiver.write(fragment1);\n      perMessageDeflate.compress(buf2, true, (err, fragment2) => {\n        if (err) return done(err);\n        receiver.write(Buffer.from([0x80, fragment2.length]));\n        receiver.write(fragment2);\n      });\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"parses a buffer with thousands of frames","suites":["Receiver"],"updatePoint":{"line":377,"column":46,"index":10634},"line":377,"code":"  it('parses a buffer with thousands of frames', done => {\n    const buf = Buffer.allocUnsafe(40000);\n\n    for (let i = 0; i < buf.length; i += 2) {\n      buf[i] = 0x81;\n      buf[i + 1] = 0x00;\n    }\n\n    const receiver = new Receiver();\n    let counter = 0;\n    receiver.on('message', (data, isBinary) => {\n      assert.strictEqual(data, EMPTY_BUFFER);\n      assert.ok(!isBinary);\n      if (++counter === 20000) done();\n    });\n    receiver.write(buf);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"resets `totalPayloadLength` only on final frame (unfragmented)","suites":["Receiver"],"updatePoint":{"line":394,"column":68,"index":11117},"line":394,"code":"  it('resets `totalPayloadLength` only on final frame (unfragmented)', done => {\n    const receiver = new Receiver({\n      maxPayload: 10\n    });\n    receiver.on('message', (data, isBinary) => {\n      assert.strictEqual(receiver._totalPayloadLength, 0);\n      assert.deepStrictEqual(data, Buffer.from('Hello'));\n      assert.ok(!isBinary);\n      done();\n    });\n    assert.strictEqual(receiver._totalPayloadLength, 0);\n    receiver.write(Buffer.from('810548656c6c6f', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"resets `totalPayloadLength` only on final frame (fragmented)","suites":["Receiver"],"updatePoint":{"line":407,"column":66,"index":11598},"line":407,"code":"  it('resets `totalPayloadLength` only on final frame (fragmented)', done => {\n    const receiver = new Receiver({\n      maxPayload: 10\n    });\n    receiver.on('message', (data, isBinary) => {\n      assert.strictEqual(receiver._totalPayloadLength, 0);\n      assert.deepStrictEqual(data, Buffer.from('Hello'));\n      assert.ok(!isBinary);\n      done();\n    });\n    assert.strictEqual(receiver._totalPayloadLength, 0);\n    receiver.write(Buffer.from('01024865', 'hex'));\n    assert.strictEqual(receiver._totalPayloadLength, 2);\n    receiver.write(Buffer.from('80036c6c6f', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"resets `totalPayloadLength` only on final frame (fragmented + ping)","suites":["Receiver"],"updatePoint":{"line":422,"column":73,"index":12191},"line":422,"code":"  it('resets `totalPayloadLength` only on final frame (fragmented + ping)', done => {\n    const receiver = new Receiver({\n      maxPayload: 10\n    });\n    let data;\n    receiver.on('ping', buf => {\n      assert.strictEqual(receiver._totalPayloadLength, 2);\n      data = buf;\n    });\n    receiver.on('message', (buf, isBinary) => {\n      assert.strictEqual(receiver._totalPayloadLength, 0);\n      assert.deepStrictEqual(data, EMPTY_BUFFER);\n      assert.deepStrictEqual(buf, Buffer.from('Hello'));\n      assert.ok(isBinary);\n      done();\n    });\n    assert.strictEqual(receiver._totalPayloadLength, 0);\n    receiver.write(Buffer.from('02024865', 'hex'));\n    receiver.write(Buffer.from('8900', 'hex'));\n    receiver.write(Buffer.from('80036c6c6f', 'hex'));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"ignores any data after a close frame","suites":["Receiver"],"updatePoint":{"line":443,"column":42,"index":12923},"line":443,"code":"  it('ignores any data after a close frame', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    const results = [];\n    const push = results.push.bind(results);\n    receiver.on('conclude', push).on('message', push);\n    receiver.on('finish', () => {\n      assert.deepStrictEqual(results, [EMPTY_BUFFER, false, 1005, EMPTY_BUFFER]);\n      done();\n    });\n    receiver.write(Buffer.from([0xc1, 0x01, 0x00]));\n    receiver.write(Buffer.from([0x88, 0x00]));\n    receiver.write(Buffer.from([0x81, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if RSV1 is on and permessage-deflate is disabled","suites":["Receiver"],"updatePoint":{"line":462,"column":69,"index":13631},"line":462,"code":"  it('emits an error if RSV1 is on and permessage-deflate is disabled', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_1');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV1 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0xc2, 0x80, 0x00, 0x00, 0x00, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if RSV1 is on and opcode is 0","suites":["Receiver"],"updatePoint":{"line":473,"column":50,"index":14107},"line":473,"code":"  it('emits an error if RSV1 is on and opcode is 0', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_1');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV1 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x40, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if RSV2 is on","suites":["Receiver"],"updatePoint":{"line":490,"column":34,"index":14717},"line":490,"code":"  it('emits an error if RSV2 is on', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_2_3');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV2 and RSV3 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0xa2, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if RSV3 is on","suites":["Receiver"],"updatePoint":{"line":501,"column":34,"index":15164},"line":501,"code":"  it('emits an error if RSV3 is on', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_2_3');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV2 and RSV3 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x92, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the first frame in a fragmented message has opcode 0","suites":["Receiver"],"updatePoint":{"line":512,"column":76,"index":15653},"line":512,"code":"  it('emits an error if the first frame in a fragmented message has opcode 0', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 0');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x00, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame has opcode 1 in the middle of a fragmented message","suites":["Receiver"],"updatePoint":{"line":523,"column":82,"index":16133},"line":523,"code":"  it('emits an error if a frame has opcode 1 in the middle of a fragmented message', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 1');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x01, 0x00]));\n    receiver.write(Buffer.from([0x01, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame has opcode 2 in the middle of a fragmented message","suites":["Receiver"],"updatePoint":{"line":535,"column":82,"index":16660},"line":535,"code":"  it('emits an error if a frame has opcode 2 in the middle of a fragmented message', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 2');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x01, 0x00]));\n    receiver.write(Buffer.from([0x02, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a control frame has the FIN bit off","suites":["Receiver"],"updatePoint":{"line":547,"column":59,"index":17164},"line":547,"code":"  it('emits an error if a control frame has the FIN bit off', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_EXPECTED_FIN');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: FIN must be set');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x09, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a control frame has the RSV1 bit on","suites":["Receiver"],"updatePoint":{"line":558,"column":59,"index":17618},"line":558,"code":"  it('emits an error if a control frame has the RSV1 bit on', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_RSV_1');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: RSV1 must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0xc9, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a control frame has the FIN bit off","suites":["Receiver"],"updatePoint":{"line":575,"column":59,"index":18253},"line":575,"code":"  it('emits an error if a control frame has the FIN bit off', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_EXPECTED_FIN');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: FIN must be set');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x09, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame has the MASK bit off (server mode)","suites":["Receiver"],"updatePoint":{"line":586,"column":66,"index":18714},"line":586,"code":"  it('emits an error if a frame has the MASK bit off (server mode)', done => {\n    const receiver = new Receiver({\n      isServer: true\n    });\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_EXPECTED_MASK');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: MASK must be set');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x81, 0x02, 0x68, 0x69]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame has the MASK bit on (client mode)","suites":["Receiver"],"updatePoint":{"line":599,"column":65,"index":19216},"line":599,"code":"  it('emits an error if a frame has the MASK bit on (client mode)', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNEXPECTED_MASK');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: MASK must be clear');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x81, 0x82, 0x56, 0x3a, 0xac, 0x80, 0x3e, 0x53]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a control frame has a payload bigger than 125 B","suites":["Receiver"],"updatePoint":{"line":610,"column":71,"index":19724},"line":610,"code":"  it('emits an error if a control frame has a payload bigger than 125 B', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid payload length 126');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x89, 0x7e]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a data frame has a payload bigger than 2^53 - 1 B","suites":["Receiver"],"updatePoint":{"line":621,"column":73,"index":20221},"line":621,"code":"  it('emits an error if a data frame has a payload bigger than 2^53 - 1 B', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n      assert.strictEqual(err.message, 'Unsupported WebSocket frame: payload length > 2^53 - 1');\n      assert.strictEqual(err[kStatusCode], 1009);\n      done();\n    });\n    receiver.write(Buffer.from([0x82, 0x7f]));\n    setImmediate(() => receiver.write(Buffer.from([0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a text frame contains invalid UTF-8 data (1/2)","suites":["Receiver"],"updatePoint":{"line":633,"column":70,"index":20822},"line":633,"code":"  it('emits an error if a text frame contains invalid UTF-8 data (1/2)', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof Error);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_UTF8');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid UTF-8 sequence');\n      assert.strictEqual(err[kStatusCode], 1007);\n      done();\n    });\n    receiver.write(Buffer.from([0x81, 0x04, 0xce, 0xba, 0xe1, 0xbd]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a text frame contains invalid UTF-8 data (2/2)","suites":["Receiver"],"updatePoint":{"line":644,"column":70,"index":21313},"line":644,"code":"  it('emits an error if a text frame contains invalid UTF-8 data (2/2)', done => {\n    const perMessageDeflate = new PerMessageDeflate();\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      }\n    });\n    const buf = Buffer.from([0xce, 0xba, 0xe1, 0xbd]);\n    receiver.on('error', err => {\n      assert.ok(err instanceof Error);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_UTF8');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid UTF-8 sequence');\n      assert.strictEqual(err[kStatusCode], 1007);\n      done();\n    });\n    perMessageDeflate.compress(buf, true, (err, data) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0xc1, data.length]));\n      receiver.write(data);\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a close frame has a payload of 1 B","suites":["Receiver"],"updatePoint":{"line":666,"column":58,"index":22134},"line":666,"code":"  it('emits an error if a close frame has a payload of 1 B', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid payload length 1');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x88, 0x01, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a close frame contains an invalid close code","suites":["Receiver"],"updatePoint":{"line":677,"column":68,"index":22630},"line":677,"code":"  it('emits an error if a close frame contains an invalid close code', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_CLOSE_CODE');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid status code 0');\n      assert.strictEqual(err[kStatusCode], 1002);\n      done();\n    });\n    receiver.write(Buffer.from([0x88, 0x02, 0x00, 0x00]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a close frame contains invalid UTF-8 data","suites":["Receiver"],"updatePoint":{"line":688,"column":65,"index":23114},"line":688,"code":"  it('emits an error if a close frame contains invalid UTF-8 data', done => {\n    const receiver = new Receiver();\n    receiver.on('error', err => {\n      assert.ok(err instanceof Error);\n      assert.strictEqual(err.code, 'WS_ERR_INVALID_UTF8');\n      assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid UTF-8 sequence');\n      assert.strictEqual(err[kStatusCode], 1007);\n      done();\n    });\n    receiver.write(Buffer.from([0x88, 0x06, 0x03, 0xef, 0xce, 0xba, 0xe1, 0xbd]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if a frame payload length is bigger than `maxPayload`","suites":["Receiver"],"updatePoint":{"line":699,"column":74,"index":23621},"line":699,"code":"  it('emits an error if a frame payload length is bigger than `maxPayload`', done => {\n    const receiver = new Receiver({\n      isServer: true,\n      maxPayload: 20 * 1024\n    });\n    const msg = crypto.randomBytes(200 * 1024);\n    const list = Sender.frame(msg, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x02,\n      mask: true,\n      readOnly: true\n    });\n    const frame = Buffer.concat(list);\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      assert.strictEqual(err.message, 'Max payload size exceeded');\n      assert.strictEqual(err[kStatusCode], 1009);\n      done();\n    });\n    receiver.write(frame);\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the message length exceeds `maxPayload`","suites":["Receiver"],"updatePoint":{"line":722,"column":63,"index":24342},"line":722,"code":"  it('emits an error if the message length exceeds `maxPayload`', done => {\n    const perMessageDeflate = new PerMessageDeflate({}, false, 25);\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      },\n      isServer: false,\n      maxPayload: 25\n    });\n    const buf = Buffer.from('A'.repeat(50));\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      assert.strictEqual(err.message, 'Max payload size exceeded');\n      assert.strictEqual(err[kStatusCode], 1009);\n      done();\n    });\n    perMessageDeflate.compress(buf, true, (err, data) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0xc1, data.length]));\n      receiver.write(data);\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the sum of fragment lengths exceeds `maxPayload`","suites":["Receiver"],"updatePoint":{"line":746,"column":72,"index":25222},"line":746,"code":"  it('emits an error if the sum of fragment lengths exceeds `maxPayload`', done => {\n    const perMessageDeflate = new PerMessageDeflate({}, false, 25);\n    perMessageDeflate.accept([{}]);\n    const receiver = new Receiver({\n      extensions: {\n        'permessage-deflate': perMessageDeflate\n      },\n      isServer: false,\n      maxPayload: 25\n    });\n    const buf = Buffer.from('A'.repeat(15));\n    receiver.on('error', err => {\n      assert.ok(err instanceof RangeError);\n      assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      assert.strictEqual(err.message, 'Max payload size exceeded');\n      assert.strictEqual(err[kStatusCode], 1009);\n      done();\n    });\n    perMessageDeflate.compress(buf, false, (err, fragment1) => {\n      if (err) return done(err);\n      receiver.write(Buffer.from([0x41, fragment1.length]));\n      receiver.write(fragment1);\n      perMessageDeflate.compress(buf, true, (err, fragment2) => {\n        if (err) return done(err);\n        receiver.write(Buffer.from([0x80, fragment2.length]));\n        receiver.write(fragment2);\n      });\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the 'nodebuffer' binary type","suites":["Receiver"],"updatePoint":{"line":775,"column":41,"index":26296},"line":775,"code":"  it(\"honors the 'nodebuffer' binary type\", done => {\n    const receiver = new Receiver();\n    const frags = [crypto.randomBytes(7321), crypto.randomBytes(137), crypto.randomBytes(285787), crypto.randomBytes(3)];\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.concat(frags));\n      assert.ok(isBinary);\n      done();\n    });\n    frags.forEach((frag, i) => {\n      Sender.frame(frag, {\n        fin: i === frags.length - 1,\n        opcode: i === 0 ? 2 : 0,\n        readOnly: true,\n        mask: false,\n        rsv1: false\n      }).forEach(buf => receiver.write(buf));\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the 'arraybuffer' binary type","suites":["Receiver"],"updatePoint":{"line":793,"column":42,"index":26921},"line":793,"code":"  it(\"honors the 'arraybuffer' binary type\", done => {\n    const receiver = new Receiver({\n      binaryType: 'arraybuffer'\n    });\n    const frags = [crypto.randomBytes(19221), crypto.randomBytes(954), crypto.randomBytes(623987)];\n    receiver.on('message', (data, isBinary) => {\n      assert.ok(data instanceof ArrayBuffer);\n      assert.deepStrictEqual(Buffer.from(data), Buffer.concat(frags));\n      assert.ok(isBinary);\n      done();\n    });\n    frags.forEach((frag, i) => {\n      Sender.frame(frag, {\n        fin: i === frags.length - 1,\n        opcode: i === 0 ? 2 : 0,\n        readOnly: true,\n        mask: false,\n        rsv1: false\n      }).forEach(buf => receiver.write(buf));\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the 'fragments' binary type","suites":["Receiver"],"updatePoint":{"line":814,"column":40,"index":27620},"line":814,"code":"  it(\"honors the 'fragments' binary type\", done => {\n    const receiver = new Receiver({\n      binaryType: 'fragments'\n    });\n    const frags = [crypto.randomBytes(17), crypto.randomBytes(419872), crypto.randomBytes(83), crypto.randomBytes(9928), crypto.randomBytes(1)];\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, frags);\n      assert.ok(isBinary);\n      done();\n    });\n    frags.forEach((frag, i) => {\n      Sender.frame(frag, {\n        fin: i === frags.length - 1,\n        opcode: i === 0 ? 2 : 0,\n        readOnly: true,\n        mask: false,\n        rsv1: false\n      }).forEach(buf => receiver.write(buf));\n    });\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the `skipUTF8Validation` option (1/2)","suites":["Receiver"],"updatePoint":{"line":834,"column":50,"index":28298},"line":834,"code":"  it('honors the `skipUTF8Validation` option (1/2)', done => {\n    const receiver = new Receiver({\n      skipUTF8Validation: true\n    });\n    receiver.on('message', (data, isBinary) => {\n      assert.deepStrictEqual(data, Buffer.from([0xf8]));\n      assert.ok(!isBinary);\n      done();\n    });\n    receiver.write(Buffer.from([0x81, 0x01, 0xf8]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"honors the `skipUTF8Validation` option (2/2)","suites":["Receiver"],"updatePoint":{"line":845,"column":50,"index":28651},"line":845,"code":"  it('honors the `skipUTF8Validation` option (2/2)', done => {\n    const receiver = new Receiver({\n      skipUTF8Validation: true\n    });\n    receiver.on('conclude', (code, data) => {\n      assert.strictEqual(code, 1000);\n      assert.deepStrictEqual(data, Buffer.from([0xf8]));\n      done();\n    });\n    receiver.write(Buffer.from([0x88, 0x03, 0x03, 0xe8, 0xf8]));\n  });","file":"receiver.test.js","skipped":false,"dir":"test"},{"name":"does not mutate the input buffer if data is `readOnly`","suites":["Sender",".frame"],"updatePoint":{"line":34,"column":62,"index":575},"line":34,"code":"    it('does not mutate the input buffer if data is `readOnly`', () => {\n      const buf = Buffer.from([1, 2, 3, 4, 5]);\n      Sender.frame(buf, {\n        readOnly: true,\n        rsv1: false,\n        mask: true,\n        opcode: 2,\n        fin: true\n      });\n      assert.ok(buf.equals(Buffer.from([1, 2, 3, 4, 5])));\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"honors the `rsv1` option","suites":["Sender",".frame"],"updatePoint":{"line":45,"column":32,"index":871},"line":45,"code":"    it('honors the `rsv1` option', () => {\n      const list = Sender.frame(EMPTY_BUFFER, {\n        readOnly: false,\n        mask: false,\n        rsv1: true,\n        opcode: 1,\n        fin: true\n      });\n      assert.strictEqual(list[0][0] & 0x40, 0x40);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"accepts a string as first argument","suites":["Sender",".frame"],"updatePoint":{"line":55,"column":42,"index":1144},"line":55,"code":"    it('accepts a string as first argument', () => {\n      const list = Sender.frame('', {\n        readOnly: false,\n        rsv1: false,\n        mask: false,\n        opcode: 1,\n        fin: true\n      });\n      assert.deepStrictEqual(list[0], Buffer.from('8103', 'hex'));\n      assert.deepStrictEqual(list[1], Buffer.from('e282ac', 'hex'));\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"compresses data if compress option is enabled","suites":["Sender","#send"],"updatePoint":{"line":68,"column":53,"index":1539},"line":68,"code":"    it('compresses data if compress option is enabled', done => {\n      const chunks = [];\n      const perMessageDeflate = new PerMessageDeflate();\n      const mockSocket = new MockSocket({\n        write: chunk => {\n          chunks.push(chunk);\n          if (chunks.length !== 6) return;\n          assert.strictEqual(chunks[0].length, 2);\n          assert.strictEqual(chunks[0][0] & 0x40, 0x40);\n          assert.strictEqual(chunks[2].length, 2);\n          assert.strictEqual(chunks[2][0] & 0x40, 0x40);\n          assert.strictEqual(chunks[4].length, 2);\n          assert.strictEqual(chunks[4][0] & 0x40, 0x40);\n          done();\n        }\n      });\n      const sender = new Sender(mockSocket, {\n        'permessage-deflate': perMessageDeflate\n      });\n      perMessageDeflate.accept([{}]);\n      const options = {\n        compress: true,\n        fin: true\n      };\n      const array = new Uint8Array([0x68, 0x69]);\n      sender.send(array.buffer, options);\n      sender.send(array, options);\n      sender.send('hi', options);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"honors the compression threshold","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":98,"column":42,"index":2623},"line":98,"code":"      it('honors the compression threshold', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate();\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 2) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.notStrictEqual(chunk[0][0] & 0x40, 0x40);\n            assert.strictEqual(chunks[1], 'hi');\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send('hi', {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"compresses all fragments of a fragmented message","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":121,"column":58,"index":3504},"line":121,"code":"      it('compresses all fragments of a fragmented message', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate({\n          threshold: 3\n        });\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 4) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.strictEqual(chunks[0][0] & 0x40, 0x40);\n            assert.strictEqual(chunks[1].length, 9);\n            assert.strictEqual(chunks[2].length, 2);\n            assert.strictEqual(chunks[2][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[3].length, 4);\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send('123', {\n          compress: true,\n          fin: false\n        });\n        sender.send('12', {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"does not compress any fragments of a fragmented message","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":153,"column":65,"index":4681},"line":153,"code":"      it('does not compress any fragments of a fragmented message', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate({\n          threshold: 3\n        });\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 4) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.strictEqual(chunks[0][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[1].length, 2);\n            assert.strictEqual(chunks[2].length, 2);\n            assert.strictEqual(chunks[2][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[3].length, 3);\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send('12', {\n          compress: true,\n          fin: false\n        });\n        sender.send('123', {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"compresses empty buffer as first fragment","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":185,"column":51,"index":5844},"line":185,"code":"      it('compresses empty buffer as first fragment', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate({\n          threshold: 0\n        });\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 4) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.strictEqual(chunks[0][0] & 0x40, 0x40);\n            assert.strictEqual(chunks[1].length, 5);\n            assert.strictEqual(chunks[2].length, 2);\n            assert.strictEqual(chunks[2][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[3].length, 6);\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send(Buffer.alloc(0), {\n          compress: true,\n          fin: false\n        });\n        sender.send('data', {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"compresses empty buffer as last fragment","suites":["Sender","#send","when context takeover is disabled"],"updatePoint":{"line":217,"column":50,"index":7018},"line":217,"code":"      it('compresses empty buffer as last fragment', done => {\n        const chunks = [];\n        const perMessageDeflate = new PerMessageDeflate({\n          threshold: 0\n        });\n        const mockSocket = new MockSocket({\n          write: chunk => {\n            chunks.push(chunk);\n            if (chunks.length !== 4) return;\n            assert.strictEqual(chunks[0].length, 2);\n            assert.strictEqual(chunks[0][0] & 0x40, 0x40);\n            assert.strictEqual(chunks[1].length, 10);\n            assert.strictEqual(chunks[2].length, 2);\n            assert.strictEqual(chunks[2][0] & 0x40, 0x00);\n            assert.strictEqual(chunks[3].length, 1);\n            done();\n          }\n        });\n        const sender = new Sender(mockSocket, {\n          'permessage-deflate': perMessageDeflate\n        });\n        const extensions = extension.parse('permessage-deflate; client_no_context_takeover');\n        perMessageDeflate.accept(extensions['permessage-deflate']);\n        sender.send('data', {\n          compress: true,\n          fin: false\n        });\n        sender.send(Buffer.alloc(0), {\n          compress: true,\n          fin: true\n        });\n      });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"works with multiple types of data","suites":["Sender","#ping"],"updatePoint":{"line":252,"column":41,"index":8226},"line":252,"code":"    it('works with multiple types of data', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      let count = 0;\n      const mockSocket = new MockSocket({\n        write: data => {\n          if (++count < 3) return;\n\n          if (count % 2) {\n            assert.ok(data.equals(Buffer.from([0x89, 0x02])));\n          } else if (count < 8) {\n            assert.ok(data.equals(Buffer.from([0x68, 0x69])));\n          } else {\n            assert.strictEqual(data, 'hi');\n            done();\n          }\n        }\n      });\n      const sender = new Sender(mockSocket, {\n        'permessage-deflate': perMessageDeflate\n      });\n      perMessageDeflate.accept([{}]);\n      const array = new Uint8Array([0x68, 0x69]);\n      sender.send('foo', {\n        compress: true,\n        fin: true\n      });\n      sender.ping(array.buffer, false);\n      sender.ping(array, false);\n      sender.ping('hi', false);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"works with multiple types of data","suites":["Sender","#pong"],"updatePoint":{"line":284,"column":41,"index":9181},"line":284,"code":"    it('works with multiple types of data', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      let count = 0;\n      const mockSocket = new MockSocket({\n        write: data => {\n          if (++count < 3) return;\n\n          if (count % 2) {\n            assert.ok(data.equals(Buffer.from([0x8a, 0x02])));\n          } else if (count < 8) {\n            assert.ok(data.equals(Buffer.from([0x68, 0x69])));\n          } else {\n            assert.strictEqual(data, 'hi');\n            done();\n          }\n        }\n      });\n      const sender = new Sender(mockSocket, {\n        'permessage-deflate': perMessageDeflate\n      });\n      perMessageDeflate.accept([{}]);\n      const array = new Uint8Array([0x68, 0x69]);\n      sender.send('foo', {\n        compress: true,\n        fin: true\n      });\n      sender.pong(array.buffer, false);\n      sender.pong(array, false);\n      sender.pong('hi', false);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the first argument is invalid","suites":["Sender","#close"],"updatePoint":{"line":316,"column":56,"index":10152},"line":316,"code":"    it('throws an error if the first argument is invalid', () => {\n      const mockSocket = new MockSocket();\n      const sender = new Sender(mockSocket);\n      assert.throws(() => sender.close('error'), /^TypeError: First argument must be a valid error code number$/);\n      assert.throws(() => sender.close(1004), /^TypeError: First argument must be a valid error code number$/);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the message is greater than 123 bytes","suites":["Sender","#close"],"updatePoint":{"line":322,"column":64,"index":10550},"line":322,"code":"    it('throws an error if the message is greater than 123 bytes', () => {\n      const mockSocket = new MockSocket();\n      const sender = new Sender(mockSocket);\n      assert.throws(() => sender.close(1000, 'a'.repeat(124)), /^RangeError: The message must not be greater than 123 bytes$/);\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"should consume all data before closing","suites":["Sender","#close"],"updatePoint":{"line":327,"column":46,"index":10831},"line":327,"code":"    it('should consume all data before closing', done => {\n      const perMessageDeflate = new PerMessageDeflate();\n      let count = 0;\n      const mockSocket = new MockSocket({\n        write: (data, cb) => {\n          count++;\n          if (cb) cb();\n        }\n      });\n      const sender = new Sender(mockSocket, {\n        'permessage-deflate': perMessageDeflate\n      });\n      perMessageDeflate.accept([{}]);\n      sender.send('foo', {\n        compress: true,\n        fin: true\n      });\n      sender.send('bar', {\n        compress: true,\n        fin: true\n      });\n      sender.send('baz', {\n        compress: true,\n        fin: true\n      });\n      sender.close(1000, undefined, false, () => {\n        assert.strictEqual(count, 8);\n        done();\n      });\n    });","file":"sender.test.js","skipped":false,"dir":"test"},{"name":"parses a single subprotocol","suites":["subprotocol","parse"],"updatePoint":{"line":11,"column":35,"index":198},"line":11,"code":"    it('parses a single subprotocol', () => {\n      assert.deepStrictEqual(parse('foo'), new Set(['foo']));\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"parses multiple subprotocols","suites":["subprotocol","parse"],"updatePoint":{"line":14,"column":36,"index":315},"line":14,"code":"    it('parses multiple subprotocols', () => {\n      assert.deepStrictEqual(parse('foo,bar,baz'), new Set(['foo', 'bar', 'baz']));\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"ignores the optional white spaces","suites":["subprotocol","parse"],"updatePoint":{"line":17,"column":41,"index":459},"line":17,"code":"    it('ignores the optional white spaces', () => {\n      const header = 'foo , bar\\t, \\tbaz\\t ,  qux\\t\\t,norf';\n      assert.deepStrictEqual(parse(header), new Set(['foo', 'bar', 'baz', 'qux', 'norf']));\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a subprotocol is empty","suites":["subprotocol","parse"],"updatePoint":{"line":21,"column":49,"index":680},"line":21,"code":"    it('throws an error if a subprotocol is empty', () => {\n      [[',', 0], ['foo,,', 4], ['foo,  ,', 6]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a subprotocol is duplicated","suites":["subprotocol","parse"],"updatePoint":{"line":26,"column":54,"index":953},"line":26,"code":"    it('throws an error if a subprotocol is duplicated', () => {\n      ['foo,foo,bar', 'foo,bar,foo'].forEach(header => {\n        assert.throws(() => parse(header), /^SyntaxError: The \"foo\" subprotocol is duplicated$/);\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a white space is misplaced","suites":["subprotocol","parse"],"updatePoint":{"line":31,"column":53,"index":1190},"line":31,"code":"    it('throws an error if a white space is misplaced', () => {\n      [['f oo', 2], [' foo', 0]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a subprotocol contains invalid characters","suites":["subprotocol","parse"],"updatePoint":{"line":36,"column":68,"index":1463},"line":36,"code":"    it('throws an error if a subprotocol contains invalid characters', () => {\n      [['f@o', 1], ['f\\\\oo', 1], ['foo,b@r', 5]].forEach(element => {\n        assert.throws(() => parse(element[0]), new RegExp(`^SyntaxError: Unexpected character at index ${element[1]}$`));\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the header value ends prematurely","suites":["subprotocol","parse"],"updatePoint":{"line":41,"column":60,"index":1744},"line":41,"code":"    it('throws an error if the header value ends prematurely', () => {\n      ['foo ', 'foo, ', 'foo,bar ', 'foo,bar,'].forEach(header => {\n        assert.throws(() => parse(header), /^SyntaxError: Unexpected end of input$/);\n      });\n    });","file":"subprotocol.test.js","skipped":false,"dir":"test"},{"name":"returns false if it finds invalid bytes","suites":["extension","isValidUTF8"],"updatePoint":{"line":11,"column":47,"index":219},"line":11,"code":"    it('returns false if it finds invalid bytes', () => {\n      assert.strictEqual(isValidUTF8(Buffer.from([0xf8])), false);\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"returns false for overlong encodings","suites":["extension","isValidUTF8"],"updatePoint":{"line":14,"column":44,"index":349},"line":14,"code":"    it('returns false for overlong encodings', () => {\n      assert.strictEqual(isValidUTF8(Buffer.from([0xc0, 0xa0])), false);\n      assert.strictEqual(isValidUTF8(Buffer.from([0xe0, 0x80, 0xa0])), false);\n      assert.strictEqual(isValidUTF8(Buffer.from([0xf0, 0x80, 0x80, 0xa0])), false);\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"returns false for code points in the range U+D800 - U+DFFF","suites":["extension","isValidUTF8"],"updatePoint":{"line":19,"column":66,"index":671},"line":19,"code":"    it('returns false for code points in the range U+D800 - U+DFFF', () => {\n      for (let i = 0xa0; i < 0xc0; i++) {\n        for (let j = 0x80; j < 0xc0; j++) {\n          assert.strictEqual(isValidUTF8(Buffer.from([0xed, i, j])), false);\n        }\n      }\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"returns false for code points greater than U+10FFFF","suites":["extension","isValidUTF8"],"updatePoint":{"line":26,"column":59,"index":930},"line":26,"code":"    it('returns false for code points greater than U+10FFFF', () => {\n      assert.strictEqual(isValidUTF8(Buffer.from([0xf4, 0x90, 0x80, 0x80])), false);\n      assert.strictEqual(isValidUTF8(Buffer.from([0xf5, 0x80, 0x80, 0x80])), false);\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"returns true for a well-formed UTF-8 byte sequence","suites":["extension","isValidUTF8"],"updatePoint":{"line":30,"column":58,"index":1177},"line":30,"code":"    it('returns true for a well-formed UTF-8 byte sequence', () => {\n      // prettier-ignore\n      const buf = Buffer.from([0xe2, 0x82, 0xAC, // \n      0xf0, 0x90, 0x8c, 0x88, // \n      0x24 // $\n      ]);\n      assert.strictEqual(isValidUTF8(buf), true);\n    });","file":"validation.test.js","skipped":false,"dir":"test"},{"name":"throws an error if no option object is passed","suites":["WebSocketServer","#ctor"],"updatePoint":{"line":30,"column":53,"index":578},"line":30,"code":"    it('throws an error if no option object is passed', () => {\n      assert.throws(() => new WebSocket.Server(), new RegExp('^TypeError: One and only one of the \"port\", \"server\", or ' + '\"noServer\" options must be specified$'));\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error if required options are not specified","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":34,"column":63,"index":858},"line":34,"code":"      it('throws an error if required options are not specified', () => {\n        assert.throws(() => new WebSocket.Server({}), new RegExp('^TypeError: One and only one of the \"port\", \"server\", or ' + '\"noServer\" options must be specified$'));\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error if mutually exclusive options are specified","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":37,"column":69,"index":1118},"line":37,"code":"      it('throws an error if mutually exclusive options are specified', () => {\n        const server = http.createServer();\n        const variants = [{\n          port: 0,\n          noServer: true,\n          server\n        }, {\n          port: 0,\n          noServer: true\n        }, {\n          port: 0,\n          server\n        }, {\n          noServer: true,\n          server\n        }];\n\n        for (const options of variants) {\n          assert.throws(() => new WebSocket.Server(options), new RegExp('^TypeError: One and only one of the \"port\", \"server\", or ' + '\"noServer\" options must be specified$'));\n        }\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"exposes options passed to constructor","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":58,"column":47,"index":1724},"line":58,"code":"      it('exposes options passed to constructor', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          assert.strictEqual(wss.options.port, 0);\n          wss.close(done);\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"accepts the `maxPayload` option","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":66,"column":41,"index":1958},"line":66,"code":"      it('accepts the `maxPayload` option', done => {\n        const maxPayload = 20480;\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          maxPayload,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', ws.close);\n        });\n        wss.on('connection', ws => {\n          assert.strictEqual(ws._receiver._maxPayload, maxPayload);\n          assert.strictEqual(ws._receiver._extensions['permessage-deflate']._maxPayload, maxPayload);\n          wss.close(done);\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"honors the `WebSocket` option","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":82,"column":39,"index":2560},"line":82,"code":"      it('honors the `WebSocket` option', done => {\n        class CustomWebSocket extends WebSocket.WebSocket {\n          get foo() {\n            return 'foo';\n          }\n\n        }\n\n        const wss = new WebSocket.Server({\n          port: 0,\n          WebSocket: CustomWebSocket\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', ws.close);\n        });\n        wss.on('connection', ws => {\n          assert.ok(ws instanceof CustomWebSocket);\n          assert.strictEqual(ws.foo, 'foo');\n          wss.close(done);\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits an error if http server bind fails","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":104,"column":48,"index":3185},"line":104,"code":"    it('emits an error if http server bind fails', done => {\n      const wss1 = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const wss2 = new WebSocket.Server({\n          port: wss1.address().port\n        });\n        wss2.on('error', () => wss1.close(done));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"starts a server on a given port","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":114,"column":39,"index":3472},"line":114,"code":"    it('starts a server on a given port', done => {\n      const port = 1337;\n      const wss = new WebSocket.Server({\n        port\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${port}`);\n        ws.on('open', ws.close);\n      });\n      wss.on('connection', () => wss.close(done));\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"binds the server on any IPv6 address when available","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":124,"column":59,"index":3802},"line":124,"code":"    it('binds the server on any IPv6 address when available', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        assert.strictEqual(wss._server.address().address, '::');\n        wss.close(done);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"uses a precreated http server","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":132,"column":37,"index":4034},"line":132,"code":"    it('uses a precreated http server', done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const wss = new WebSocket.Server({\n          server\n        });\n        wss.on('connection', () => {\n          server.close(done);\n        });\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('open', ws.close);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"426s for non-Upgrade requests","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":145,"column":37,"index":4436},"line":145,"code":"    it('426s for non-Upgrade requests', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        http.get(`http://localhost:${wss.address().port}`, res => {\n          let body = '';\n          assert.strictEqual(res.statusCode, 426);\n          res.on('data', chunk => {\n            body += chunk;\n          });\n          res.on('end', () => {\n            assert.strictEqual(body, http.STATUS_CODES[426]);\n            wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"uses a precreated http server listening on unix socket","suites":["WebSocketServer","#ctor","options"],"updatePoint":{"line":162,"column":62,"index":4973},"line":162,"code":"    it('uses a precreated http server listening on unix socket', function (done) {\n      //\n      // Skip this test on Windows. The URL parser:\n      //\n      // - Throws an error if the named pipe uses backward slashes.\n      // - Incorrectly parses the path if the named pipe uses forward slashes.\n      //\n      if (process.platform === 'win32') return this.skip();\n      const server = http.createServer();\n      const sockPath = path.join(os.tmpdir(), `ws.${crypto.randomBytes(16).toString('hex')}.sock`);\n      server.listen(sockPath, () => {\n        const wss = new WebSocket.Server({\n          server\n        });\n        wss.on('connection', (ws, req) => {\n          if (wss.clients.size === 1) {\n            assert.strictEqual(req.url, '/foo?bar=bar');\n          } else {\n            assert.strictEqual(req.url, '/');\n\n            for (const client of wss.clients) {\n              client.close();\n            }\n\n            server.close(done);\n          }\n        });\n        const ws = new WebSocket(`ws+unix://${sockPath}:/foo?bar=bar`);\n        ws.on('open', () => new WebSocket(`ws+unix://${sockPath}`));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns the address of the server","suites":["WebSocketServer","#address"],"updatePoint":{"line":195,"column":41,"index":6125},"line":195,"code":"    it('returns the address of the server', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const addr = wss.address();\n        assert.deepStrictEqual(addr, wss._server.address());\n        wss.close(done);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error when operating in \"noServer\" mode","suites":["WebSocketServer","#address"],"updatePoint":{"line":204,"column":57,"index":6409},"line":204,"code":"    it('throws an error when operating in \"noServer\" mode', () => {\n      const wss = new WebSocket.Server({\n        noServer: true\n      });\n      assert.throws(() => {\n        wss.address();\n      }, /^Error: The server is operating in \"noServer\" mode$/);\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns `null` if called after close","suites":["WebSocketServer","#address"],"updatePoint":{"line":212,"column":44,"index":6662},"line":212,"code":"    it('returns `null` if called after close', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        wss.close(() => {\n          assert.strictEqual(wss.address(), null);\n          done();\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"does not throw if called multiple times","suites":["WebSocketServer","#close"],"updatePoint":{"line":224,"column":47,"index":6956},"line":224,"code":"    it('does not throw if called multiple times', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        wss.on('close', done);\n        wss.close();\n        wss.close();\n        wss.close();\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"doesn't close a precreated server","suites":["WebSocketServer","#close"],"updatePoint":{"line":234,"column":41,"index":7196},"line":234,"code":"    it(\"doesn't close a precreated server\", done => {\n      const server = http.createServer();\n      const realClose = server.close;\n\n      server.close = () => {\n        done(new Error('Must not close pre-created server'));\n      };\n\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('connection', () => {\n        wss.close();\n        server.close = realClose;\n        server.close(done);\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('open', ws.close);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"invokes the callback in noServer mode","suites":["WebSocketServer","#close"],"updatePoint":{"line":255,"column":45,"index":7789},"line":255,"code":"    it('invokes the callback in noServer mode', done => {\n      const wss = new WebSocket.Server({\n        noServer: true\n      });\n      wss.close(done);\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"cleans event handlers on precreated server","suites":["WebSocketServer","#close"],"updatePoint":{"line":261,"column":50,"index":7957},"line":261,"code":"    it('cleans event handlers on precreated server', done => {\n      const server = http.createServer();\n      const wss = new WebSocket.Server({\n        server\n      });\n      server.listen(0, () => {\n        wss.close(() => {\n          assert.strictEqual(server.listenerCount('listening'), 0);\n          assert.strictEqual(server.listenerCount('upgrade'), 0);\n          assert.strictEqual(server.listenerCount('error'), 0);\n          server.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'close' event after the server closes","suites":["WebSocketServer","#close"],"updatePoint":{"line":275,"column":55,"index":8448},"line":275,"code":"    it(\"emits the 'close' event after the server closes\", done => {\n      let serverCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        net.createConnection({\n          port: wss.address().port\n        });\n      });\n\n      wss._server.on('connection', socket => {\n        wss.close(); //\n        // The server is closing. Ensure this does not emit a `'close'`\n        // event before the server is actually closed.\n        //\n\n        wss.close();\n        process.nextTick(() => {\n          socket.end();\n        });\n      });\n\n      wss._server.on('close', () => {\n        serverCloseEventEmitted = true;\n      });\n\n      wss.on('close', () => {\n        assert.ok(serverCloseEventEmitted);\n        done();\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'close' event if client tracking is disabled","suites":["WebSocketServer","#close"],"updatePoint":{"line":306,"column":62,"index":9237},"line":306,"code":"    it(\"emits the 'close' event if client tracking is disabled\", done => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        clientTracking: false\n      });\n      wss.on('close', done);\n      wss.close();\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"calls the callback if the server is already closed","suites":["WebSocketServer","#close"],"updatePoint":{"line":314,"column":58,"index":9469},"line":314,"code":"    it('calls the callback if the server is already closed', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        wss.close(() => {\n          assert.strictEqual(wss._state, 2);\n          wss.close(err => {\n            assert.ok(err instanceof Error);\n            assert.strictEqual(err.message, 'The server is not running');\n            done();\n          });\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'close' event if the server is already closed","suites":["WebSocketServer","#close"],"updatePoint":{"line":328,"column":63,"index":9902},"line":328,"code":"    it(\"emits the 'close' event if the server is already closed\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        wss.close(() => {\n          assert.strictEqual(wss._state, 2);\n          wss.on('close', done);\n          wss.close();\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns a list of connected clients","suites":["WebSocketServer","#clients"],"updatePoint":{"line":341,"column":43,"index":10226},"line":341,"code":"    it('returns a list of connected clients', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        assert.strictEqual(wss.clients.size, 0);\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', ws.close);\n      });\n      wss.on('connection', () => {\n        assert.strictEqual(wss.clients.size, 1);\n        wss.close(done);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can be disabled","suites":["WebSocketServer","#clients"],"updatePoint":{"line":354,"column":23,"index":10629},"line":354,"code":"    it('can be disabled', done => {\n      const wss = new WebSocket.Server({\n        port: 0,\n        clientTracking: false\n      }, () => {\n        assert.strictEqual(wss.clients, undefined);\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.close());\n      });\n      wss.on('connection', ws => {\n        assert.strictEqual(wss.clients, undefined);\n        ws.on('close', () => wss.close(done));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"is updated when client terminates the connection","suites":["WebSocketServer","#clients"],"updatePoint":{"line":368,"column":56,"index":11132},"line":368,"code":"    it('is updated when client terminates the connection', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.terminate());\n      });\n      wss.on('connection', ws => {\n        ws.on('close', () => {\n          assert.strictEqual(wss.clients.size, 0);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"is updated when client closes the connection","suites":["WebSocketServer","#clients"],"updatePoint":{"line":382,"column":52,"index":11574},"line":382,"code":"    it('is updated when client closes the connection', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.close());\n      });\n      wss.on('connection', ws => {\n        ws.on('close', () => {\n          assert.strictEqual(wss.clients.size, 0);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns true when the path matches","suites":["WebSocketServer","#shouldHandle"],"updatePoint":{"line":398,"column":42,"index":12044},"line":398,"code":"    it('returns true when the path matches', () => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      assert.strictEqual(wss.shouldHandle({\n        url: '/foo'\n      }), true);\n      assert.strictEqual(wss.shouldHandle({\n        url: '/foo?bar=baz'\n      }), true);\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"returns false when the path doesn't match","suites":["WebSocketServer","#shouldHandle"],"updatePoint":{"line":410,"column":49,"index":12378},"line":410,"code":"    it(\"returns false when the path doesn't match\", () => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      assert.strictEqual(wss.shouldHandle({\n        url: '/bar'\n      }), false);\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can be used for a pre-existing server","suites":["WebSocketServer","#handleUpgrade"],"updatePoint":{"line":421,"column":45,"index":12663},"line":421,"code":"    it('can be used for a pre-existing server', done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const wss = new WebSocket.Server({\n          noServer: true\n        });\n        server.on('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, ws => {\n            ws.send('hello');\n            ws.close();\n          });\n        });\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, Buffer.from('hello'));\n          assert.ok(!isBinary);\n          server.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"closes the connection when path doesn't match","suites":["WebSocketServer","#handleUpgrade"],"updatePoint":{"line":441,"column":53,"index":13355},"line":441,"code":"    it(\"closes the connection when path doesn't match\", done => {\n      const wss = new WebSocket.Server({\n        port: 0,\n        path: '/ws'\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"closes the connection when protocol version is Hixie-76","suites":["WebSocketServer","#handleUpgrade"],"updatePoint":{"line":461,"column":63,"index":13952},"line":461,"code":"    it('closes the connection when protocol version is Hixie-76', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'WebSocket',\n            'Sec-WebSocket-Key1': '4 @1  46546xW%0l 1 5',\n            'Sec-WebSocket-Key2': '12998 5 Y3 1  .P00',\n            'Sec-WebSocket-Protocol': 'sample'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Key header');\n            wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error if called twice with the same socket","suites":["WebSocketServer","#completeUpgrade"],"updatePoint":{"line":490,"column":60,"index":14902},"line":490,"code":"    it('throws an error if called twice with the same socket', done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const wss = new WebSocket.Server({\n          noServer: true\n        });\n        server.on('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, ws => {\n            ws.close();\n          });\n          assert.throws(() => wss.handleUpgrade(req, socket, head, NOOP), err => {\n            assert.ok(err instanceof Error);\n            assert.strictEqual(err.message, 'server.handleUpgrade() was called more than once with the ' + 'same socket, possibly due to a misconfiguration');\n            return true;\n          });\n        });\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('open', () => {\n          ws.on('close', () => {\n            server.close(done);\n          });\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the HTTP method is not GET","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":516,"column":43,"index":15864},"line":516,"code":"    it('fails if the HTTP method is not GET', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.request({\n          method: 'POST',\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 405);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Invalid HTTP method');\n            wss.close(done);\n          });\n        });\n        req.end();\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Upgrade header field value is not \"websocket\"","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":545,"column":66,"index":16741},"line":545,"code":"    it('fails if the Upgrade header field value is not \"websocket\"', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'foo'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Invalid Upgrade header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Key header is invalid (1/2)","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":572,"column":62,"index":17562},"line":572,"code":"    it('fails if the Sec-WebSocket-Key header is invalid (1/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Key header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Key header is invalid (2/2)","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":599,"column":62,"index":18410},"line":599,"code":"    it('fails if the Sec-WebSocket-Key header is invalid (2/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'P5l8BJcZwRc='\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Key header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Version header is invalid (1/2)","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":627,"column":66,"index":19311},"line":627,"code":"    it('fails if the Sec-WebSocket-Version header is invalid (1/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ=='\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Version header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Version header is invalid (2/2)","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":655,"column":66,"index":20228},"line":655,"code":"    it('fails if the Sec-WebSocket-Version header is invalid (2/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 12\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Missing or invalid Sec-WebSocket-Version header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails is the Sec-WebSocket-Protocol header is invalid","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":684,"column":61,"index":21181},"line":684,"code":"    it('fails is the Sec-WebSocket-Protocol header is invalid', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13,\n            'Sec-WebSocket-Protocol': 'foo;bar'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Invalid Sec-WebSocket-Protocol header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Extensions header is invalid","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":714,"column":63,"index":22175},"line":714,"code":"    it('fails if the Sec-WebSocket-Extensions header is invalid', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13,\n            'Sec-WebSocket-Extensions': 'permessage-deflate; server_max_window_bits=foo'\n          }\n        });\n        req.on('response', res => {\n          assert.strictEqual(res.statusCode, 400);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'Invalid or unacceptable Sec-WebSocket-Extensions header');\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', () => {\n        done(new Error(\"Unexpected 'connection' event\"));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"fails if the WebSocket server is closing or closed","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":745,"column":58,"index":23256},"line":745,"code":"    it('fails if the WebSocket server is closing or closed', done => {\n      const server = http.createServer();\n      const wss = new WebSocket.Server({\n        noServer: true\n      });\n      server.on('upgrade', (req, socket, head) => {\n        wss.close();\n        wss.handleUpgrade(req, socket, head, () => {\n          done(new Error('Unexpected callback invocation'));\n        });\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('unexpected-response', (req, res) => {\n          assert.strictEqual(res.statusCode, 503);\n          res.resume();\n          server.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"handles unsupported extensions","suites":["WebSocketServer","Connection establishing"],"updatePoint":{"line":765,"column":38,"index":23928},"line":765,"code":"    it('handles unsupported extensions', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const req = http.get({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13,\n            'Sec-WebSocket-Extensions': 'foo; bar'\n          }\n        });\n        req.on('upgrade', (res, socket, head) => {\n          if (head.length) socket.unshift(head);\n          socket.once('data', chunk => {\n            assert.strictEqual(chunk[0], 0x88);\n            socket.destroy();\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        assert.strictEqual(ws.extensions, '');\n        ws.close();\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can reject client synchronously","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":795,"column":41,"index":24866},"line":795,"code":"      it('can reject client synchronously', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: () => false,\n          port: 0\n        }, () => {\n          const req = http.get({\n            port: wss.address().port,\n            headers: {\n              Connection: 'Upgrade',\n              Upgrade: 'websocket',\n              'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n              'Sec-WebSocket-Version': 8\n            }\n          });\n          req.on('response', res => {\n            assert.strictEqual(res.statusCode, 401);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can accept client synchronously","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":818,"column":41,"index":25601},"line":818,"code":"      it('can accept client synchronously', done => {\n        const server = https.createServer({\n          cert: fs.readFileSync('test/fixtures/certificate.pem'),\n          key: fs.readFileSync('test/fixtures/key.pem')\n        });\n        const wss = new WebSocket.Server({\n          verifyClient: info => {\n            assert.strictEqual(info.origin, 'https://example.com');\n            assert.strictEqual(info.req.headers.foo, 'bar');\n            assert.ok(info.secure, true);\n            return true;\n          },\n          server\n        });\n        wss.on('connection', () => {\n          server.close(done);\n        });\n        server.listen(0, () => {\n          const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n            headers: {\n              Origin: 'https://example.com',\n              foo: 'bar'\n            },\n            rejectUnauthorized: false\n          });\n          ws.on('open', ws.close);\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can accept client asynchronously","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":846,"column":42,"index":26559},"line":846,"code":"      it('can accept client asynchronously', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: (o, cb) => process.nextTick(cb, true),\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', ws.close);\n        });\n        wss.on('connection', () => wss.close(done));\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can reject client asynchronously","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":856,"column":42,"index":26943},"line":856,"code":"      it('can reject client asynchronously', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: (info, cb) => process.nextTick(cb, false),\n          port: 0\n        }, () => {\n          const req = http.get({\n            port: wss.address().port,\n            headers: {\n              Connection: 'Upgrade',\n              Upgrade: 'websocket',\n              'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n              'Sec-WebSocket-Version': 8\n            }\n          });\n          req.on('response', res => {\n            assert.strictEqual(res.statusCode, 401);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can reject client asynchronously w/ status code","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":879,"column":57,"index":27724},"line":879,"code":"      it('can reject client asynchronously w/ status code', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: (info, cb) => process.nextTick(cb, false, 404),\n          port: 0\n        }, () => {\n          const req = http.get({\n            port: wss.address().port,\n            headers: {\n              Connection: 'Upgrade',\n              Upgrade: 'websocket',\n              'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n              'Sec-WebSocket-Version': 8\n            }\n          });\n          req.on('response', res => {\n            assert.strictEqual(res.statusCode, 404);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"can reject client asynchronously w/ custom headers","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":902,"column":60,"index":28513},"line":902,"code":"      it('can reject client asynchronously w/ custom headers', done => {\n        const wss = new WebSocket.Server({\n          verifyClient: (info, cb) => {\n            process.nextTick(cb, false, 503, '', {\n              'Retry-After': 120\n            });\n          },\n          port: 0\n        }, () => {\n          const req = http.get({\n            port: wss.address().port,\n            headers: {\n              Connection: 'Upgrade',\n              Upgrade: 'websocket',\n              'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n              'Sec-WebSocket-Version': 8\n            }\n          });\n          req.on('response', res => {\n            assert.strictEqual(res.statusCode, 503);\n            assert.strictEqual(res.headers['retry-after'], '120');\n            wss.close(done);\n          });\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"doesn't emit the 'connection' event if socket is closed prematurely","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":931,"column":75,"index":29473},"line":931,"code":"    it(\"doesn't emit the 'connection' event if socket is closed prematurely\", done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const wss = new WebSocket.Server({\n          verifyClient: ({\n            req: {\n              socket\n            }\n          }, cb) => {\n            assert.strictEqual(socket.readable, true);\n            assert.strictEqual(socket.writable, true);\n            socket.on('end', () => {\n              assert.strictEqual(socket.readable, false);\n              assert.strictEqual(socket.writable, true);\n              cb(true);\n            });\n          },\n          server\n        });\n        wss.on('connection', () => {\n          done(new Error(\"Unexpected 'connection' event\"));\n        });\n        const socket = net.connect({\n          port: server.address().port,\n          allowHalfOpen: true\n        }, () => {\n          socket.end(['GET / HTTP/1.1', 'Host: localhost', 'Upgrade: websocket', 'Connection: Upgrade', 'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==', 'Sec-WebSocket-Version: 13', '\\r\\n'].join('\\r\\n'));\n        });\n        socket.on('end', () => {\n          wss.close();\n          server.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"handles data passed along with the upgrade request","suites":["WebSocketServer","Connection establishing","`verifyClient`"],"updatePoint":{"line":965,"column":58,"index":30672},"line":965,"code":"    it('handles data passed along with the upgrade request', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const req = http.request({\n          port: wss.address().port,\n          headers: {\n            Connection: 'Upgrade',\n            Upgrade: 'websocket',\n            'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',\n            'Sec-WebSocket-Version': 13\n          }\n        });\n        const list = Sender.frame(Buffer.from('Hello'), {\n          fin: true,\n          rsv1: false,\n          opcode: 0x01,\n          mask: true,\n          readOnly: false\n        });\n        req.write(Buffer.concat(list));\n        req.end();\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (data, isBinary) => {\n          assert.deepStrictEqual(data, Buffer.from('Hello'));\n          assert.ok(!isBinary);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"allows to select a subprotocol","suites":["WebSocketServer","Connection establishing","`handleProtocols`"],"updatePoint":{"line":997,"column":40,"index":31615},"line":997,"code":"      it('allows to select a subprotocol', done => {\n        const handleProtocols = (protocols, request) => {\n          assert.ok(request instanceof http.IncomingMessage);\n          assert.strictEqual(request.url, '/');\n          return Array.from(protocols).pop();\n        };\n\n        const wss = new WebSocket.Server({\n          handleProtocols,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, ['foo', 'bar']);\n          ws.on('open', () => {\n            assert.strictEqual(ws.protocol, 'bar');\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.close();\n        });\n      });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"emits the 'headers' event","suites":["WebSocketServer","Connection establishing","`handleProtocols`"],"updatePoint":{"line":1019,"column":33,"index":32314},"line":1019,"code":"    it(\"emits the 'headers' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', ws.close);\n      });\n      wss.on('headers', (headers, request) => {\n        assert.deepStrictEqual(headers.slice(0, 3), ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade']);\n        assert.ok(request instanceof http.IncomingMessage);\n        assert.strictEqual(request.url, '/');\n        wss.on('connection', () => wss.close(done));\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"is disabled by default","suites":["WebSocketServer","permessage-deflate"],"updatePoint":{"line":1035,"column":30,"index":32956},"line":1035,"code":"    it('is disabled by default', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', ws.close);\n      });\n      wss.on('connection', (ws, req) => {\n        assert.strictEqual(req.headers['sec-websocket-extensions'], 'permessage-deflate; client_max_window_bits');\n        assert.strictEqual(ws.extensions, '');\n        wss.close(done);\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"uses configuration options","suites":["WebSocketServer","permessage-deflate"],"updatePoint":{"line":1048,"column":34,"index":33441},"line":1048,"code":"    it('uses configuration options', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: {\n          clientMaxWindowBits: 8\n        },\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('upgrade', res => {\n          assert.strictEqual(res.headers['sec-websocket-extensions'], 'permessage-deflate; client_max_window_bits=8');\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket-server.test.js","skipped":false,"dir":"test"},{"name":"throws an error when using an invalid url","suites":["WebSocket","#ctor"],"updatePoint":{"line":47,"column":49,"index":769},"line":47,"code":"    it('throws an error when using an invalid url', () => {\n      assert.throws(() => new WebSocket('foo'), /^SyntaxError: Invalid URL: foo$/);\n      assert.throws(() => new WebSocket('https://websocket-echo.com'), /^SyntaxError: The URL's protocol must be one of \"ws:\", \"wss:\", or \"ws\\+unix:\"$/);\n      assert.throws(() => new WebSocket('ws+unix:'), /^SyntaxError: The URL's pathname is empty$/);\n      assert.throws(() => new WebSocket('wss://websocket-echo.com#foo'), /^SyntaxError: The URL contains a fragment identifier$/);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if a subprotocol is invalid or duplicated","suites":["WebSocket","#ctor"],"updatePoint":{"line":53,"column":65,"index":1322},"line":53,"code":"    it('throws an error if a subprotocol is invalid or duplicated', () => {\n      for (const subprotocol of [null, '', 'a,b', ['a', 'a']]) {\n        assert.throws(() => new WebSocket('ws://localhost', subprotocol), /^SyntaxError: An invalid or duplicated subprotocol was specified$/);\n      }\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"accepts `url.URL` objects as url","suites":["WebSocket","#ctor"],"updatePoint":{"line":58,"column":40,"index":1598},"line":58,"code":"    it('accepts `url.URL` objects as url', done => {\n      const agent = new CustomAgent();\n\n      agent.addRequest = (req, opts) => {\n        assert.strictEqual(opts.host, '::1');\n        assert.strictEqual(req.path, '/');\n        done();\n      };\n\n      const ws = new WebSocket(new URL('ws://[::1]'), {\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"accepts the `options` object as 3rd argument","suites":["WebSocket","#ctor","options"],"updatePoint":{"line":72,"column":54,"index":1982},"line":72,"code":"      it('accepts the `options` object as 3rd argument', () => {\n        const agent = new CustomAgent();\n        let count = 0;\n        let ws;\n\n        agent.addRequest = req => {\n          assert.strictEqual(req.getHeader('sec-websocket-protocol'), undefined);\n          count++;\n        };\n\n        ws = new WebSocket('ws://localhost', undefined, {\n          agent\n        });\n        ws = new WebSocket('ws://localhost', [], {\n          agent\n        });\n        assert.strictEqual(count, 2);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"accepts the `maxPayload` option","suites":["WebSocket","#ctor","options"],"updatePoint":{"line":90,"column":41,"index":2477},"line":90,"code":"      it('accepts the `maxPayload` option', done => {\n        const maxPayload = 20480;\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: true,\n            maxPayload\n          });\n          ws.on('open', () => {\n            assert.strictEqual(ws._receiver._maxPayload, maxPayload);\n            assert.strictEqual(ws._receiver._extensions['permessage-deflate']._maxPayload, maxPayload);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error when using an invalid `protocolVersion`","suites":["WebSocket","#ctor","options"],"updatePoint":{"line":110,"column":65,"index":3197},"line":110,"code":"      it('throws an error when using an invalid `protocolVersion`', () => {\n        const options = {\n          agent: new CustomAgent(),\n          protocolVersion: 1000\n        };\n        assert.throws(() => new WebSocket('ws://localhost', options), /^RangeError: Unsupported protocol version: 1000 \\(supported versions: 8, 13\\)$/);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `generateMask` option","suites":["WebSocket","#ctor","options"],"updatePoint":{"line":117,"column":42,"index":3518},"line":117,"code":"      it('honors the `generateMask` option', done => {\n        const data = Buffer.from('foo');\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            generateMask() {}\n\n          });\n          ws.on('open', () => {\n            ws.send(data);\n          });\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1005);\n            assert.deepStrictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          const chunks = [];\n\n          ws._socket.prependListener('data', chunk => {\n            chunks.push(chunk);\n          });\n\n          ws.on('message', message => {\n            assert.deepStrictEqual(message, data);\n            assert.deepStrictEqual(Buffer.concat(chunks).slice(2, 6), Buffer.alloc(4));\n            ws.close();\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable property of class","suites":["WebSocket","Constants","\\`\\`"],"updatePoint":{"line":160,"column":43,"index":4737},"line":160,"code":"        it('is enumerable property of class', () => {\n          const descriptor = Object.getOwnPropertyDescriptor(WebSocket, state);\n          assert.deepStrictEqual(descriptor, {\n            configurable: false,\n            enumerable: true,\n            value: readyStates[state],\n            writable: false\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable property of prototype","suites":["WebSocket","Constants","\\`\\`"],"updatePoint":{"line":169,"column":47,"index":5078},"line":169,"code":"        it('is enumerable property of prototype', () => {\n          const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, state);\n          assert.deepStrictEqual(descriptor, {\n            configurable: false,\n            enumerable: true,\n            value: readyStates[state],\n            writable: false\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`binaryType`"],"updatePoint":{"line":183,"column":40,"index":5516},"line":183,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'binaryType');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set !== undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"defaults to 'nodebuffer'","suites":["WebSocket","Attributes","`binaryType`"],"updatePoint":{"line":190,"column":34,"index":5880},"line":190,"code":"      it(\"defaults to 'nodebuffer'\", () => {\n        const ws = new WebSocket('ws://localhost', {\n          agent: new CustomAgent()\n        });\n        assert.strictEqual(ws.binaryType, 'nodebuffer');\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be changed to 'arraybuffer' or 'fragments'","suites":["WebSocket","Attributes","`binaryType`"],"updatePoint":{"line":196,"column":56,"index":6114},"line":196,"code":"      it(\"can be changed to 'arraybuffer' or 'fragments'\", () => {\n        const ws = new WebSocket('ws://localhost', {\n          agent: new CustomAgent()\n        });\n        ws.binaryType = 'arraybuffer';\n        assert.strictEqual(ws.binaryType, 'arraybuffer');\n        ws.binaryType = 'foo';\n        assert.strictEqual(ws.binaryType, 'arraybuffer');\n        ws.binaryType = 'fragments';\n        assert.strictEqual(ws.binaryType, 'fragments');\n        ws.binaryType = '';\n        assert.strictEqual(ws.binaryType, 'fragments');\n        ws.binaryType = 'nodebuffer';\n        assert.strictEqual(ws.binaryType, 'nodebuffer');\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":213,"column":40,"index":6782},"line":213,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'bufferedAmount');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"defaults to zero","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":220,"column":26,"index":7142},"line":220,"code":"      it('defaults to zero', () => {\n        const ws = new WebSocket('ws://localhost', {\n          agent: new CustomAgent()\n        });\n        assert.strictEqual(ws.bufferedAmount, 0);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"defaults to zero upon \"open\"","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":226,"column":38,"index":7351},"line":226,"code":"      it('defaults to zero upon \"open\"', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n\n          ws.onopen = () => {\n            assert.strictEqual(ws.bufferedAmount, 0);\n            wss.close(done);\n          };\n        });\n        wss.on('connection', ws => {\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"takes into account the data in the sender queue","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":241,"column":57,"index":7797},"line":241,"code":"      it('takes into account the data in the sender queue', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send('foo');\n            assert.strictEqual(ws.bufferedAmount, 3);\n            ws.send('bar', err => {\n              assert.ifError(err);\n              assert.strictEqual(ws.bufferedAmount, 0);\n              wss.close(done);\n            });\n            assert.strictEqual(ws.bufferedAmount, 6);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"takes into account the data in the socket queue","suites":["WebSocket","Attributes","`bufferedAmount`"],"updatePoint":{"line":266,"column":57,"index":8596},"line":266,"code":"      it('takes into account the data in the socket queue', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        });\n        wss.on('connection', ws => {\n          const data = Buffer.alloc(1024, 61);\n\n          while (ws.bufferedAmount === 0) {\n            ws.send(data);\n          }\n\n          assert.ok(ws.bufferedAmount > 0);\n          assert.strictEqual(ws.bufferedAmount, ws._socket._writableState.length);\n          ws.on('close', () => wss.close(done));\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`extensions`"],"updatePoint":{"line":287,"column":40,"index":9251},"line":287,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'bufferedAmount');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"exposes the negotiated extensions names (1/2)","suites":["WebSocket","Attributes","`extensions`"],"updatePoint":{"line":294,"column":55,"index":9640},"line":294,"code":"      it('exposes the negotiated extensions names (1/2)', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          assert.strictEqual(ws.extensions, '');\n          ws.on('open', () => {\n            assert.strictEqual(ws.extensions, '');\n            ws.on('close', () => wss.close(done));\n          });\n        });\n        wss.on('connection', ws => {\n          assert.strictEqual(ws.extensions, '');\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"exposes the negotiated extensions names (2/2)","suites":["WebSocket","Attributes","`extensions`"],"updatePoint":{"line":310,"column":55,"index":10203},"line":310,"code":"      it('exposes the negotiated extensions names (2/2)', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          assert.strictEqual(ws.extensions, '');\n          ws.on('open', () => {\n            assert.strictEqual(ws.extensions, 'permessage-deflate');\n            ws.on('close', () => wss.close(done));\n          });\n        });\n        wss.on('connection', ws => {\n          assert.strictEqual(ws.extensions, 'permessage-deflate');\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`isPaused`"],"updatePoint":{"line":329,"column":40,"index":10865},"line":329,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'isPaused');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"indicates whether the websocket is paused","suites":["WebSocket","Attributes","`isPaused`"],"updatePoint":{"line":336,"column":51,"index":11244},"line":336,"code":"      it('indicates whether the websocket is paused', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', () => {\n            ws.pause();\n            assert.ok(ws.isPaused);\n            ws.resume();\n            assert.ok(!ws.isPaused);\n            ws.close();\n            wss.close(done);\n          });\n          assert.ok(!ws.isPaused);\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`protocol`"],"updatePoint":{"line":354,"column":40,"index":11774},"line":354,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'protocol');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"exposes the subprotocol selected by the server","suites":["WebSocket","Attributes","`protocol`"],"updatePoint":{"line":361,"column":56,"index":12158},"line":361,"code":"      it('exposes the subprotocol selected by the server', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const port = wss.address().port;\n          const ws = new WebSocket(`ws://localhost:${port}`, 'foo');\n          assert.strictEqual(ws.extensions, '');\n          ws.on('open', () => {\n            assert.strictEqual(ws.protocol, 'foo');\n            ws.on('close', () => wss.close(done));\n          });\n        });\n        wss.on('connection', ws => {\n          assert.strictEqual(ws.protocol, 'foo');\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":380,"column":40,"index":12789},"line":380,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'readyState');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"defaults to `CONNECTING`","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":387,"column":34,"index":13153},"line":387,"code":"      it('defaults to `CONNECTING`', () => {\n        const ws = new WebSocket('ws://localhost', {\n          agent: new CustomAgent()\n        });\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is set to `OPEN` once connection is established","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":393,"column":57,"index":13396},"line":393,"code":"      it('is set to `OPEN` once connection is established', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', () => {\n            assert.strictEqual(ws.readyState, WebSocket.OPEN);\n            ws.close();\n          });\n          ws.on('close', () => wss.close(done));\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is set to `CLOSED` once connection is closed","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":405,"column":54,"index":13823},"line":405,"code":"      it('is set to `CLOSED` once connection is closed', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('close', () => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n            wss.close(done);\n          });\n          ws.on('open', () => ws.close(1001));\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is set to `CLOSED` once connection is terminated","suites":["WebSocket","Attributes","`readyState`"],"updatePoint":{"line":417,"column":58,"index":14260},"line":417,"code":"      it('is set to `CLOSED` once connection is terminated', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('close', () => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n            wss.close(done);\n          });\n          ws.on('open', () => ws.terminate());\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enumerable and configurable","suites":["WebSocket","Attributes","`url`"],"updatePoint":{"line":431,"column":40,"index":14717},"line":431,"code":"      it('is enumerable and configurable', () => {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, 'url');\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set === undefined);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"exposes the server url","suites":["WebSocket","Attributes","`url`"],"updatePoint":{"line":438,"column":32,"index":15072},"line":438,"code":"      it('exposes the server url', () => {\n        const url = 'ws://localhost';\n        const ws = new WebSocket(url, {\n          agent: new CustomAgent()\n        });\n        assert.strictEqual(ws.url, url);\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits an 'error' event if an error occurs","suites":["WebSocket","Events"],"updatePoint":{"line":448,"column":49,"index":15351},"line":448,"code":"    it(\"emits an 'error' event if an error occurs\", done => {\n      let clientCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            clientCloseEventEmitted = true;\n            if (serverClientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1002);\n          assert.deepStrictEqual(reason, EMPTY_BUFFER);\n          serverClientCloseEventEmitted = true;\n          if (clientCloseEventEmitted) wss.close(done);\n        });\n\n        ws._socket.write(Buffer.from([0x85, 0x00]));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not re-emit `net.Socket` errors","suites":["WebSocket","Events"],"updatePoint":{"line":478,"column":44,"index":16532},"line":478,"code":"    it('does not re-emit `net.Socket` errors', done => {\n      const codes = ['EPIPE', 'ECONNABORTED', 'ECANCELED', 'ECONNRESET'];\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws._socket.on('error', err => {\n            assert.ok(err instanceof Error);\n            assert.ok(codes.includes(err.code), `Unexpected code: ${err.code}`);\n            ws.on('close', (code, message) => {\n              assert.strictEqual(code, 1006);\n              assert.strictEqual(message, EMPTY_BUFFER);\n              wss.close(done);\n            });\n          });\n\n          for (const client of wss.clients) client.terminate();\n\n          ws.send('foo');\n          ws.send('bar');\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits an 'upgrade' event","suites":["WebSocket","Events"],"updatePoint":{"line":502,"column":32,"index":17357},"line":502,"code":"    it(\"emits an 'upgrade' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('upgrade', res => {\n          assert.ok(res instanceof http.IncomingMessage);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits a 'ping' event","suites":["WebSocket","Events"],"updatePoint":{"line":516,"column":28,"index":17760},"line":516,"code":"    it(\"emits a 'ping' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('ping', () => wss.close(done));\n      });\n      wss.on('connection', ws => {\n        ws.ping();\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits a 'pong' event","suites":["WebSocket","Events"],"updatePoint":{"line":528,"column":28,"index":18097},"line":528,"code":"    it(\"emits a 'pong' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('pong', () => wss.close(done));\n      });\n      wss.on('connection', ws => {\n        ws.pong();\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits a 'redirect' event","suites":["WebSocket","Events"],"updatePoint":{"line":540,"column":32,"index":18438},"line":540,"code":"    it(\"emits a 'redirect' event\", done => {\n      const server = http.createServer();\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n        server.once('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, ws => {\n            ws.close();\n          });\n        });\n      });\n      server.listen(() => {\n        const port = server.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}`, {\n          followRedirects: true\n        });\n        ws.on('redirect', (url, req) => {\n          assert.strictEqual(ws._redirects, 1);\n          assert.strictEqual(url, `ws://localhost:${port}/foo`);\n          assert.ok(req instanceof http.ClientRequest);\n          ws.on('close', code => {\n            assert.strictEqual(code, 1005);\n            server.close(done);\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the Upgrade header field value is not \"websocket\"","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":575,"column":66,"index":19668},"line":575,"code":"    it('fails if the Upgrade header field value is not \"websocket\"', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.on('end', socket.end);\n        socket.write('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Connection: Upgrade\\r\\n' + 'Upgrade: foo\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid Upgrade header');\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Accept header is invalid","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":587,"column":59,"index":20203},"line":587,"code":"    it('fails if the Sec-WebSocket-Accept header is invalid', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.on('end', socket.end);\n        socket.write('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + 'Sec-WebSocket-Accept: CxYS6+NgJSBG74mdgLvGscRvpns=\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid Sec-WebSocket-Accept header');\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"close event is raised when server closes connection","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":599,"column":59,"index":20816},"line":599,"code":"    it('close event is raised when server closes connection', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('close', (code, reason) => {\n        assert.strictEqual(code, 1006);\n        assert.strictEqual(reason, EMPTY_BUFFER);\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"error is emitted if server aborts connection","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":611,"column":52,"index":21452},"line":611,"code":"    it('error is emitted if server aborts connection', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end(`HTTP/1.1 401 ${http.STATUS_CODES[401]}\\r\\n` + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + `Content-Length: ${http.STATUS_CODES[401].length}\\r\\n` + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Unexpected server response: 401');\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"unexpected response can be read when sent by server","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":623,"column":59,"index":22099},"line":623,"code":"    it('unexpected response can be read when sent by server', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end(`HTTP/1.1 401 ${http.STATUS_CODES[401]}\\r\\n` + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: 3\\r\\n' + '\\r\\n' + 'foo');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', () => done(new Error(\"Unexpected 'error' event\")));\n      ws.on('unexpected-response', (req, res) => {\n        assert.strictEqual(res.statusCode, 401);\n        let data = '';\n        res.on('data', v => {\n          data += v;\n        });\n        res.on('end', () => {\n          assert.strictEqual(data, 'foo');\n          done();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"request can be aborted when unexpected response is sent by server","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":642,"column":73,"index":22936},"line":642,"code":"    it('request can be aborted when unexpected response is sent by server', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end(`HTTP/1.1 401 ${http.STATUS_CODES[401]}\\r\\n` + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: 3\\r\\n' + '\\r\\n' + 'foo');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', () => done(new Error(\"Unexpected 'error' event\")));\n      ws.on('unexpected-response', (req, res) => {\n        assert.strictEqual(res.statusCode, 401);\n        res.on('end', done);\n        req.abort();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the opening handshake timeout expires","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":655,"column":54,"index":23615},"line":655,"code":"    it('fails if the opening handshake timeout expires', done => {\n      server.once('upgrade', (req, socket) => socket.on('end', socket.end));\n      const port = server.address().port;\n      const ws = new WebSocket(`ws://localhost:${port}`, {\n        handshakeTimeout: 100\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Opening handshake has timed out');\n        done();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if an unexpected Sec-WebSocket-Extensions header is received","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":668,"column":74,"index":24172},"line":668,"code":"    it('fails if an unexpected Sec-WebSocket-Extensions header is received', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: foo\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n        perMessageDeflate: false\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Extensions header is invalid (1/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":683,"column":69,"index":25066},"line":683,"code":"    it('fails if the Sec-WebSocket-Extensions header is invalid (1/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: foo;=\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid Sec-WebSocket-Extensions header');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if the Sec-WebSocket-Extensions header is invalid (2/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":696,"column":69,"index":25876},"line":696,"code":"    it('fails if the Sec-WebSocket-Extensions header is invalid (2/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: ' + 'permessage-deflate; client_max_window_bits=7\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Invalid Sec-WebSocket-Extensions header');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if an unexpected extension is received (1/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":709,"column":58,"index":26719},"line":709,"code":"    it('fails if an unexpected extension is received (1/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: foo\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server indicated an extension that was not requested');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if an unexpected extension is received (2/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":722,"column":58,"index":27529},"line":722,"code":"    it('fails if an unexpected extension is received (2/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Extensions: permessage-deflate,foo\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server indicated an extension that was not requested');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if server sends a subprotocol when none was requested","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":735,"column":67,"index":28367},"line":735,"code":"    it('fails if server sends a subprotocol when none was requested', done => {\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('headers', headers => {\n        headers.push('Sec-WebSocket-Protocol: foo');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent a subprotocol but none was requested');\n        ws.on('close', () => wss.close(done));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if server sends an invalid subprotocol (1/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":750,"column":58,"index":28979},"line":750,"code":"    it('fails if server sends an invalid subprotocol (1/2)', done => {\n      const wss = new WebSocket.Server({\n        handleProtocols: () => 'baz',\n        server\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, ['foo', 'bar']);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent an invalid subprotocol');\n        ws.on('close', () => wss.close(done));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if server sends an invalid subprotocol (2/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":763,"column":58,"index":29531},"line":763,"code":"    it('fails if server sends an invalid subprotocol (2/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + GUID).digest('base64');\n        socket.end('HTTP/1.1 101 Switching Protocols\\r\\n' + 'Upgrade: websocket\\r\\n' + 'Connection: Upgrade\\r\\n' + `Sec-WebSocket-Accept: ${key}\\r\\n` + 'Sec-WebSocket-Protocol:\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, ['foo', 'bar']);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent an invalid subprotocol');\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"fails if server sends no subprotocol","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":776,"column":44,"index":30319},"line":776,"code":"    it('fails if server sends no subprotocol', done => {\n      const wss = new WebSocket.Server({\n        handleProtocols() {},\n\n        server\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, ['foo', 'bar']);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Server sent no subprotocol');\n        ws.on('close', () => wss.close(done));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not follow redirects by default","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":790,"column":44,"index":30842},"line":790,"code":"    it('does not follow redirects by default', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 301 Moved Permanently\\r\\n' + 'Location: ws://localhost:8080\\r\\n' + '\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Unexpected server response: 301');\n        assert.strictEqual(ws._redirects, 0);\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `followRedirects` option","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":803,"column":43,"index":31456},"line":803,"code":"    it('honors the `followRedirects` option', done => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n        server.once('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, NOOP);\n        });\n      });\n      const port = server.address().port;\n      const ws = new WebSocket(`ws://localhost:${port}`, {\n        followRedirects: true\n      });\n      ws.on('open', () => {\n        assert.strictEqual(ws.url, `ws://localhost:${port}/foo`);\n        assert.strictEqual(ws._redirects, 1);\n        ws.on('close', () => done());\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `maxRedirects` option","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":825,"column":40,"index":32210},"line":825,"code":"    it('honors the `maxRedirects` option', done => {\n      const onUpgrade = (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /\\r\\n\\r\\n');\n      };\n\n      server.on('upgrade', onUpgrade);\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n        followRedirects: true,\n        maxRedirects: 1\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'Maximum redirects exceeded');\n        assert.strictEqual(ws._redirects, 2);\n        server.removeListener('upgrade', onUpgrade);\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the redirect URL is invalid (1/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":844,"column":59,"index":32948},"line":844,"code":"    it('emits an error if the redirect URL is invalid (1/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: ws://\\r\\n\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n        followRedirects: true\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof SyntaxError);\n        assert.strictEqual(err.message, 'Invalid URL: ws://');\n        assert.strictEqual(ws._redirects, 1);\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"emits an error if the redirect URL is invalid (2/2)","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":859,"column":59,"index":33576},"line":859,"code":"    it('emits an error if the redirect URL is invalid (2/2)', done => {\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: http://localhost\\r\\n\\r\\n');\n      });\n      const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n        followRedirects: true\n      });\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof SyntaxError);\n        assert.strictEqual(err.message, 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"');\n        assert.strictEqual(ws._redirects, 1);\n        ws.on('close', () => done());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"uses the first url userinfo when following redirects","suites":["WebSocket","Connection establishing"],"updatePoint":{"line":874,"column":60,"index":34261},"line":874,"code":"    it('uses the first url userinfo when following redirects', done => {\n      const wss = new WebSocket.Server({\n        noServer: true,\n        path: '/foo'\n      });\n      const authorization = 'Basic Zm9vOmJhcg==';\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://baz:qux@localhost:${port}/foo\\r\\n\\r\\n`);\n        server.once('upgrade', (req, socket, head) => {\n          wss.handleUpgrade(req, socket, head, (ws, req) => {\n            assert.strictEqual(req.headers.authorization, authorization);\n            ws.close();\n          });\n        });\n      });\n      const port = server.address().port;\n      const ws = new WebSocket(`ws://foo:bar@localhost:${port}`, {\n        followRedirects: true\n      });\n      assert.strictEqual(ws._req.getHeader('Authorization'), authorization);\n      ws.on('close', code => {\n        assert.strictEqual(code, 1005);\n        assert.strictEqual(ws.url, `ws://baz:qux@localhost:${port}/foo`);\n        assert.strictEqual(ws._redirects, 1);\n        wss.close(done);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the `auth` option","suites":["WebSocket","Connection establishing","When moving away from a secure context","If there is no 'redirect' event listener"],"updatePoint":{"line":920,"column":35,"index":36006},"line":920,"code":"        it('drops the `auth` option', done => {\n          const httpServer = http.createServer();\n          const httpsServer = https.createServer({\n            cert: fs.readFileSync('test/fixtures/certificate.pem'),\n            key: fs.readFileSync('test/fixtures/key.pem')\n          });\n          const server = proxy(httpServer, httpsServer);\n          server.listen(() => {\n            const port = server.address().port;\n            httpsServer.on('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const wss = new WebSocket.Server({\n              server: httpServer\n            });\n            wss.on('connection', (ws, req) => {\n              assert.strictEqual(req.headers.authorization, undefined);\n              ws.close();\n            });\n            const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n              auth: 'foo:bar',\n              followRedirects: true,\n              rejectUnauthorized: false\n            });\n            assert.strictEqual(ws._req.getHeader('Authorization'), 'Basic Zm9vOmJhcg==');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              server.close(done);\n            });\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the Authorization, and Cookie headers","suites":["WebSocket","Connection establishing","When moving away from a secure context","If there is no 'redirect' event listener"],"updatePoint":{"line":953,"column":55,"index":37458},"line":953,"code":"        it('drops the Authorization, and Cookie headers', done => {\n          const headers = {\n            authorization: 'Basic Zm9vOmJhcg==',\n            cookie: 'foo=bar',\n            host: 'foo'\n          };\n          const httpServer = http.createServer();\n          const httpsServer = https.createServer({\n            cert: fs.readFileSync('test/fixtures/certificate.pem'),\n            key: fs.readFileSync('test/fixtures/key.pem')\n          });\n          const server = proxy(httpServer, httpsServer);\n          server.listen(() => {\n            const port = server.address().port;\n            httpsServer.on('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const wss = new WebSocket.Server({\n              server: httpServer\n            });\n            wss.on('connection', (ws, req) => {\n              assert.strictEqual(req.headers.authorization, undefined);\n              assert.strictEqual(req.headers.cookie, undefined);\n              assert.strictEqual(req.headers.host, 'foo');\n              ws.close();\n            });\n            const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n              headers,\n              followRedirects: true,\n              rejectUnauthorized: false\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              server.close(done);\n            });\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not drop any headers by default","suites":["WebSocket","Connection establishing","When moving away from a secure context","If there is at least one 'redirect' event listener"],"updatePoint":{"line":998,"column":48,"index":39459},"line":998,"code":"        it('does not drop any headers by default', done => {\n          const headers = {\n            authorization: 'Basic Zm9vOmJhcg==',\n            cookie: 'foo=bar',\n            host: 'foo'\n          };\n          const httpServer = http.createServer();\n          const httpsServer = https.createServer({\n            cert: fs.readFileSync('test/fixtures/certificate.pem'),\n            key: fs.readFileSync('test/fixtures/key.pem')\n          });\n          const server = proxy(httpServer, httpsServer);\n          server.listen(() => {\n            const port = server.address().port;\n            httpsServer.on('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const wss = new WebSocket.Server({\n              server: httpServer\n            });\n            wss.on('connection', (ws, req) => {\n              assert.strictEqual(req.headers.authorization, headers.authorization);\n              assert.strictEqual(req.headers.cookie, headers.cookie);\n              assert.strictEqual(req.headers.host, headers.host);\n              ws.close();\n            });\n            const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n              headers,\n              followRedirects: true,\n              rejectUnauthorized: false\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('redirect', (url, req) => {\n              assert.strictEqual(ws._redirects, 1);\n              assert.strictEqual(url, `ws://localhost:${port}/`);\n              assert.notStrictEqual(firstRequest, req);\n              assert.strictEqual(req.getHeader('Authorization'), headers.authorization);\n              assert.strictEqual(req.getHeader('Cookie'), headers.cookie);\n              assert.strictEqual(req.getHeader('Host'), headers.host);\n              ws.on('close', code => {\n                assert.strictEqual(code, 1005);\n                server.close(done);\n              });\n            });\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the `auth` option","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is no 'redirect' event listener"],"updatePoint":{"line":1051,"column":35,"index":41887},"line":1051,"code":"        it('drops the `auth` option', done => {\n          const wss = new WebSocket.Server({\n            port: 0\n          }, () => {\n            const port = wss.address().port;\n            server.once('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n              auth: 'foo:bar',\n              followRedirects: true\n            });\n            assert.strictEqual(ws._req.getHeader('Authorization'), 'Basic Zm9vOmJhcg==');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              wss.close(done);\n            });\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, undefined);\n            ws.close();\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"drops the Authorization, Cookie, and Host headers","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is no 'redirect' event listener"],"updatePoint":{"line":1076,"column":61,"index":42946},"line":1076,"code":"        it('drops the Authorization, Cookie, and Host headers', done => {\n          const wss = new WebSocket.Server({\n            port: 0\n          }, () => {\n            const port = wss.address().port;\n            server.once('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n              headers: {\n                Authorization: 'Basic Zm9vOmJhcg==',\n                Cookie: 'foo=bar',\n                Host: 'foo'\n              },\n              followRedirects: true\n            });\n            assert.strictEqual(ws._req.getHeader('Authorization'), 'Basic Zm9vOmJhcg==');\n            assert.strictEqual(ws._req.getHeader('Cookie'), 'foo=bar');\n            assert.strictEqual(ws._req.getHeader('Host'), 'foo');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              assert.strictEqual(ws.url, `ws://localhost:${port}/`);\n              assert.strictEqual(ws._redirects, 1);\n              wss.close(done);\n            });\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, undefined);\n            assert.strictEqual(req.headers.cookie, undefined);\n            assert.strictEqual(req.headers.host, `localhost:${wss.address().port}`);\n            ws.close();\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not drop any headers by default","suites":["WebSocket","Connection establishing","When the redirect host is different","If there is at least one 'redirect' event listener"],"updatePoint":{"line":1111,"column":48,"index":44492},"line":1111,"code":"        it('does not drop any headers by default', done => {\n          const headers = {\n            authorization: 'Basic Zm9vOmJhcg==',\n            cookie: 'foo=bar',\n            host: 'foo'\n          };\n          const wss = new WebSocket.Server({\n            port: 0\n          }, () => {\n            const port = wss.address().port;\n            server.once('upgrade', (req, socket) => {\n              socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n            });\n            const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n              headers,\n              followRedirects: true\n            });\n            const firstRequest = ws._req;\n            assert.strictEqual(firstRequest.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(firstRequest.getHeader('Cookie'), headers.cookie);\n            assert.strictEqual(firstRequest.getHeader('Host'), headers.host);\n            ws.on('redirect', (url, req) => {\n              assert.strictEqual(ws._redirects, 1);\n              assert.strictEqual(url, `ws://localhost:${port}/`);\n              assert.notStrictEqual(firstRequest, req);\n              assert.strictEqual(req.getHeader('Authorization'), headers.authorization);\n              assert.strictEqual(req.getHeader('Cookie'), headers.cookie);\n              assert.strictEqual(req.getHeader('Host'), headers.host);\n              ws.on('close', code => {\n                assert.strictEqual(code, 1005);\n                wss.close(done);\n              });\n            });\n          });\n          wss.on('connection', (ws, req) => {\n            assert.strictEqual(req.headers.authorization, headers.authorization);\n            assert.strictEqual(req.headers.cookie, headers.cookie);\n            assert.strictEqual(req.headers.host, headers.host);\n            ws.close();\n          });\n        });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows to abort the request without swallowing errors","suites":["WebSocket","Connection establishing","In a listener of the 'redirect' event"],"updatePoint":{"line":1155,"column":63,"index":46480},"line":1155,"code":"      it('allows to abort the request without swallowing errors', done => {\n        server.once('upgrade', (req, socket) => {\n          socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n        });\n        const port = server.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}`, {\n          followRedirects: true\n        });\n        ws.on('redirect', (url, req) => {\n          assert.strictEqual(ws._redirects, 1);\n          assert.strictEqual(url, `ws://localhost:${port}/foo`);\n          req.on('socket', () => {\n            req.abort();\n          });\n          ws.on('error', err => {\n            assert.ok(err instanceof Error);\n            assert.strictEqual(err.message, 'socket hang up');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1006);\n              done();\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows to remove headers","suites":["WebSocket","Connection establishing","In a listener of the 'redirect' event"],"updatePoint":{"line":1179,"column":34,"index":47336},"line":1179,"code":"      it('allows to remove headers', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const port = wss.address().port;\n          server.once('upgrade', (req, socket) => {\n            socket.end('HTTP/1.1 302 Found\\r\\n' + `Location: ws://localhost:${port}/\\r\\n\\r\\n`);\n          });\n          const headers = {\n            authorization: 'Basic Zm9vOmJhcg==',\n            cookie: 'foo=bar'\n          };\n          const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n            headers,\n            followRedirects: true\n          });\n          ws.on('redirect', (url, req) => {\n            assert.strictEqual(ws._redirects, 1);\n            assert.strictEqual(url, `ws://localhost:${port}/`);\n            assert.strictEqual(req.getHeader('Authorization'), headers.authorization);\n            assert.strictEqual(req.getHeader('Cookie'), headers.cookie);\n            req.removeHeader('authorization');\n            req.removeHeader('cookie');\n            ws.on('close', code => {\n              assert.strictEqual(code, 1005);\n              wss.close(done);\n            });\n          });\n        });\n        wss.on('connection', (ws, req) => {\n          assert.strictEqual(req.headers.authorization, undefined);\n          assert.strictEqual(req.headers.cookie, undefined);\n          ws.close();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"connects when pathname is not null","suites":["WebSocket","Connection with query string"],"updatePoint":{"line":1217,"column":42,"index":48788},"line":1217,"code":"    it('connects when pathname is not null', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const port = wss.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}/?token=qwerty`);\n        ws.on('open', () => {\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"connects when pathname is null","suites":["WebSocket","Connection with query string"],"updatePoint":{"line":1231,"column":38,"index":49180},"line":1231,"code":"    it('connects when pathname is null', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const port = wss.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}?token=qwerty`);\n        ws.on('open', () => {\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does nothing if `readyState` is `CONNECTING` or `CLOSED`","suites":["WebSocket","#pause"],"updatePoint":{"line":1247,"column":64,"index":49632},"line":1247,"code":"    it('does nothing if `readyState` is `CONNECTING` or `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n        assert.ok(!ws.isPaused);\n        ws.pause();\n        assert.ok(!ws.isPaused);\n        ws.on('open', () => {\n          ws.on('close', () => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n            ws.pause();\n            assert.ok(!ws.isPaused);\n            wss.close(done);\n          });\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"pauses the socket","suites":["WebSocket","#pause"],"updatePoint":{"line":1267,"column":25,"index":50253},"line":1267,"code":"    it('pauses the socket', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        assert.ok(!ws.isPaused);\n        assert.ok(!ws._socket.isPaused());\n        ws.pause();\n        assert.ok(ws.isPaused);\n        assert.ok(ws._socket.isPaused());\n        ws.terminate();\n        wss.close(done);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if `readyState` is `CONNECTING`","suites":["WebSocket","#ping"],"updatePoint":{"line":1285,"column":55,"index":50785},"line":1285,"code":"    it('throws an error if `readyState` is `CONNECTING`', () => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n\n      });\n      assert.throws(() => ws.ping(), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n      assert.throws(() => ws.ping(NOOP), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"increases `bufferedAmount` if `readyState` is 2 or 3","suites":["WebSocket","#ping"],"updatePoint":{"line":1293,"column":60,"index":51152},"line":1293,"code":"    it('increases `bufferedAmount` if `readyState` is 2 or 3', done => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n\n      });\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n        assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.ping('hi');\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.ping();\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.on('close', () => {\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.ping('hi');\n          assert.strictEqual(ws.bufferedAmount, 4);\n          ws.ping();\n          assert.strictEqual(ws.bufferedAmount, 4);\n          done();\n        });\n      });\n      ws.close();\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback w/ an error if `readyState` is 2 or 3","suites":["WebSocket","#ping"],"updatePoint":{"line":1318,"column":64,"index":52049},"line":1318,"code":"    it('calls the callback w/ an error if `readyState` is 2 or 3', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        ws.close();\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.ping('hi', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 2 (CLOSING)');\n          assert.strictEqual(ws.bufferedAmount, 2);\n          ws.on('close', () => {\n            ws.ping(err => {\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'WebSocket is not open: readyState 3 (CLOSED)');\n              assert.strictEqual(ws.bufferedAmount, 2);\n              wss.close(done);\n            });\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a ping with no data","suites":["WebSocket","#ping"],"updatePoint":{"line":1342,"column":36,"index":52930},"line":1342,"code":"    it('can send a ping with no data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.ping(() => {\n            ws.ping();\n            ws.close();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        let pings = 0;\n        ws.on('ping', data => {\n          assert.ok(Buffer.isBuffer(data));\n          assert.strictEqual(data.length, 0);\n          if (++pings === 2) wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a ping with data","suites":["WebSocket","#ping"],"updatePoint":{"line":1363,"column":33,"index":53519},"line":1363,"code":"    it('can send a ping with data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.ping('hi', () => {\n            ws.ping('hi', true);\n            ws.close();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        let pings = 0;\n        ws.on('ping', message => {\n          assert.strictEqual(message.toString(), 'hi');\n          if (++pings === 2) wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send numbers as ping payload","suites":["WebSocket","#ping"],"updatePoint":{"line":1383,"column":40,"index":54100},"line":1383,"code":"    it('can send numbers as ping payload', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.ping(0);\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('ping', message => {\n          assert.strictEqual(message.toString(), '0');\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the data size is greater than 125 bytes","suites":["WebSocket","#ping"],"updatePoint":{"line":1400,"column":66,"index":54605},"line":1400,"code":"    it('throws an error if the data size is greater than 125 bytes', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          assert.throws(() => ws.ping(Buffer.alloc(126)), /^RangeError: The data size must not be greater than 125 bytes$/);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if `readyState` is `CONNECTING`","suites":["WebSocket","#pong"],"updatePoint":{"line":1416,"column":55,"index":55132},"line":1416,"code":"    it('throws an error if `readyState` is `CONNECTING`', () => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n\n      });\n      assert.throws(() => ws.pong(), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n      assert.throws(() => ws.pong(NOOP), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"increases `bufferedAmount` if `readyState` is 2 or 3","suites":["WebSocket","#pong"],"updatePoint":{"line":1424,"column":60,"index":55499},"line":1424,"code":"    it('increases `bufferedAmount` if `readyState` is 2 or 3', done => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n\n      });\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n        assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.pong('hi');\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.pong();\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.on('close', () => {\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.pong('hi');\n          assert.strictEqual(ws.bufferedAmount, 4);\n          ws.pong();\n          assert.strictEqual(ws.bufferedAmount, 4);\n          done();\n        });\n      });\n      ws.close();\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback w/ an error if `readyState` is 2 or 3","suites":["WebSocket","#pong"],"updatePoint":{"line":1449,"column":64,"index":56396},"line":1449,"code":"    it('calls the callback w/ an error if `readyState` is 2 or 3', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        ws.close();\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.pong('hi', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 2 (CLOSING)');\n          assert.strictEqual(ws.bufferedAmount, 2);\n          ws.on('close', () => {\n            ws.pong(err => {\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'WebSocket is not open: readyState 3 (CLOSED)');\n              assert.strictEqual(ws.bufferedAmount, 2);\n              wss.close(done);\n            });\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a pong with no data","suites":["WebSocket","#pong"],"updatePoint":{"line":1473,"column":36,"index":57277},"line":1473,"code":"    it('can send a pong with no data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.pong(() => {\n            ws.pong();\n            ws.close();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        let pongs = 0;\n        ws.on('pong', data => {\n          assert.ok(Buffer.isBuffer(data));\n          assert.strictEqual(data.length, 0);\n          if (++pongs === 2) wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a pong with data","suites":["WebSocket","#pong"],"updatePoint":{"line":1494,"column":33,"index":57866},"line":1494,"code":"    it('can send a pong with data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.pong('hi', () => {\n            ws.pong('hi', true);\n            ws.close();\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        let pongs = 0;\n        ws.on('pong', message => {\n          assert.strictEqual(message.toString(), 'hi');\n          if (++pongs === 2) wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send numbers as pong payload","suites":["WebSocket","#pong"],"updatePoint":{"line":1514,"column":40,"index":58447},"line":1514,"code":"    it('can send numbers as pong payload', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.pong(0);\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('pong', message => {\n          assert.strictEqual(message.toString(), '0');\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if the data size is greater than 125 bytes","suites":["WebSocket","#pong"],"updatePoint":{"line":1531,"column":66,"index":58952},"line":1531,"code":"    it('throws an error if the data size is greater than 125 bytes', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          assert.throws(() => ws.pong(Buffer.alloc(126)), /^RangeError: The data size must not be greater than 125 bytes$/);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does nothing if `readyState` is `CONNECTING` or `CLOSED`","suites":["WebSocket","#resume"],"updatePoint":{"line":1547,"column":64,"index":59490},"line":1547,"code":"    it('does nothing if `readyState` is `CONNECTING` or `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        assert.strictEqual(ws.readyState, WebSocket.CONNECTING);\n        assert.ok(!ws.isPaused); // Verify that no exception is thrown.\n\n        ws.resume();\n        ws.on('open', () => {\n          ws.pause();\n          assert.ok(ws.isPaused);\n          ws.on('close', () => {\n            assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n            ws.resume();\n            assert.ok(ws.isPaused);\n            wss.close(done);\n          });\n          ws.terminate();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"resumes the socket","suites":["WebSocket","#resume"],"updatePoint":{"line":1569,"column":26,"index":60180},"line":1569,"code":"    it('resumes the socket', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        assert.ok(!ws.isPaused);\n        assert.ok(!ws._socket.isPaused());\n        ws.pause();\n        assert.ok(ws.isPaused);\n        assert.ok(ws._socket.isPaused());\n        ws.resume();\n        assert.ok(!ws.isPaused);\n        assert.ok(!ws._socket.isPaused());\n        ws.close();\n        wss.close(done);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"throws an error if `readyState` is `CONNECTING`","suites":["WebSocket","#send"],"updatePoint":{"line":1590,"column":55,"index":60805},"line":1590,"code":"    it('throws an error if `readyState` is `CONNECTING`', () => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n\n      });\n      assert.throws(() => ws.send('hi'), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n      assert.throws(() => ws.send('hi', NOOP), /^Error: WebSocket is not open: readyState 0 \\(CONNECTING\\)$/);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"increases `bufferedAmount` if `readyState` is 2 or 3","suites":["WebSocket","#send"],"updatePoint":{"line":1598,"column":60,"index":61182},"line":1598,"code":"    it('increases `bufferedAmount` if `readyState` is 2 or 3', done => {\n      const ws = new WebSocket('ws://localhost', {\n        lookup() {}\n\n      });\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n        assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.send('hi');\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.send();\n        assert.strictEqual(ws.bufferedAmount, 2);\n        ws.on('close', () => {\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.send('hi');\n          assert.strictEqual(ws.bufferedAmount, 4);\n          ws.send();\n          assert.strictEqual(ws.bufferedAmount, 4);\n          done();\n        });\n      });\n      ws.close();\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback w/ an error if `readyState` is 2 or 3","suites":["WebSocket","#send"],"updatePoint":{"line":1623,"column":64,"index":62079},"line":1623,"code":"    it('calls the callback w/ an error if `readyState` is 2 or 3', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        ws.close();\n        assert.strictEqual(ws.bufferedAmount, 0);\n        ws.send('hi', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket is not open: readyState 2 (CLOSING)');\n          assert.strictEqual(ws.bufferedAmount, 2);\n          ws.on('close', () => {\n            ws.send('hi', err => {\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'WebSocket is not open: readyState 3 (CLOSED)');\n              assert.strictEqual(ws.bufferedAmount, 4);\n              wss.close(done);\n            });\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a big binary message","suites":["WebSocket","#send"],"updatePoint":{"line":1647,"column":37,"index":62967},"line":1647,"code":"    it('can send a big binary message', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const array = new Float32Array(5 * 1024 * 1024);\n\n        for (let i = 0; i < array.length; i++) {\n          array[i] = i / 5;\n        }\n\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.send(array));\n        ws.on('message', (msg, isBinary) => {\n          assert.deepStrictEqual(msg, Buffer.from(array.buffer));\n          assert.ok(isBinary);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send text data","suites":["WebSocket","#send"],"updatePoint":{"line":1673,"column":26,"index":63725},"line":1673,"code":"    it('can send text data', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.send('hi'));\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, Buffer.from('hi'));\n          assert.ok(!isBinary);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          ws.send(msg, {\n            binary: isBinary\n          });\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does not override the `fin` option","suites":["WebSocket","#send"],"updatePoint":{"line":1694,"column":42,"index":64366},"line":1694,"code":"    it('does not override the `fin` option', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send('fragment', {\n            fin: false\n          });\n          ws.send('fragment', {\n            fin: true\n          });\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.deepStrictEqual(msg, Buffer.from('fragmentfragment'));\n          assert.ok(!isBinary);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"sends numbers as strings","suites":["WebSocket","#send"],"updatePoint":{"line":1717,"column":32,"index":65012},"line":1717,"code":"    it('sends numbers as strings', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send(0);\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.deepStrictEqual(msg, Buffer.from('0'));\n          assert.ok(!isBinary);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a `TypedArray`","suites":["WebSocket","#send"],"updatePoint":{"line":1735,"column":31,"index":65527},"line":1735,"code":"    it('can send a `TypedArray`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const array = new Float32Array(6);\n\n        for (let i = 0; i < array.length; ++i) {\n          array[i] = i / 2;\n        }\n\n        const partial = array.subarray(2, 5);\n        const buf = Buffer.from(partial.buffer, partial.byteOffset, partial.byteLength);\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send(partial);\n          ws.close();\n        });\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, buf);\n          assert.ok(isBinary);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send an `ArrayBuffer`","suites":["WebSocket","#send"],"updatePoint":{"line":1765,"column":33,"index":66424},"line":1765,"code":"    it('can send an `ArrayBuffer`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const array = new Float32Array(5);\n\n        for (let i = 0; i < array.length; ++i) {\n          array[i] = i / 2;\n        }\n\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send(array.buffer);\n          ws.close();\n        });\n\n        ws.onmessage = event => {\n          assert.ok(event.data.equals(Buffer.from(array.buffer)));\n          wss.close(done);\n        };\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a `Buffer`","suites":["WebSocket","#send"],"updatePoint":{"line":1793,"column":27,"index":67157},"line":1793,"code":"    it('can send a `Buffer`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const buf = Buffer.from('foobar');\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send(buf);\n          ws.close();\n        });\n\n        ws.onmessage = event => {\n          assert.deepStrictEqual(event.data, buf);\n          wss.close(done);\n        };\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback when data is written out","suites":["WebSocket","#send"],"updatePoint":{"line":1816,"column":51,"index":67800},"line":1816,"code":"    it('calls the callback when data is written out', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send('hi', err => {\n            assert.ifError(err);\n            wss.close(done);\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works when the `data` argument is falsy","suites":["WebSocket","#send"],"updatePoint":{"line":1832,"column":47,"index":68242},"line":1832,"code":"    it('works when the `data` argument is falsy', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws.send();\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (message, isBinary) => {\n          assert.strictEqual(message, EMPTY_BUFFER);\n          assert.ok(isBinary);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `mask` option","suites":["WebSocket","#send"],"updatePoint":{"line":1850,"column":32,"index":68756},"line":1850,"code":"    it('honors the `mask` option', done => {\n      let clientCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.send('hi', {\n          mask: false\n        }));\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1002);\n          assert.deepStrictEqual(reason, EMPTY_BUFFER);\n          clientCloseEventEmitted = true;\n          if (serverClientCloseEventEmitted) wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        const chunks = [];\n\n        ws._socket.prependListener('data', chunk => {\n          chunks.push(chunk);\n        });\n\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: MASK must be set');\n          assert.ok(Buffer.concat(chunks).slice(0, 2).equals(Buffer.from('8102', 'hex')));\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            serverClientCloseEventEmitted = true;\n            if (clientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (1/3)","suites":["WebSocket","#close"],"updatePoint":{"line":1889,"column":62,"index":70166},"line":1889,"code":"    it('closes the connection if called while connecting (1/3)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        ws.close(1001);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (2/3)","suites":["WebSocket","#close"],"updatePoint":{"line":1903,"column":62,"index":70745},"line":1903,"code":"    it('closes the connection if called while connecting (2/3)', done => {\n      const wss = new WebSocket.Server({\n        verifyClient: (info, cb) => setTimeout(cb, 300, true),\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        setTimeout(() => ws.close(1001), 150);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (3/3)","suites":["WebSocket","#close"],"updatePoint":{"line":1918,"column":62,"index":71410},"line":1918,"code":"    it('closes the connection if called while connecting (3/3)', done => {\n      const server = http.createServer();\n      server.listen(0, () => {\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => {\n            server.close(done);\n          });\n        });\n        ws.on('unexpected-response', (req, res) => {\n          assert.strictEqual(res.statusCode, 502);\n          const chunks = [];\n          res.on('data', chunk => {\n            chunks.push(chunk);\n          });\n          res.on('end', () => {\n            assert.strictEqual(Buffer.concat(chunks).toString(), 'foo');\n            ws.close();\n          });\n        });\n      });\n      server.on('upgrade', (req, socket) => {\n        socket.on('end', socket.end);\n        socket.write(`HTTP/1.1 502 ${http.STATUS_CODES[502]}\\r\\n` + 'Connection: keep-alive\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: 3\\r\\n' + '\\r\\n' + 'foo');\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from an error listener while connecting","suites":["WebSocket","#close"],"updatePoint":{"line":1947,"column":61,"index":72634},"line":1947,"code":"    it('can be called from an error listener while connecting', done => {\n      const ws = new WebSocket('ws://localhost:1337');\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.code, 'ECONNREFUSED');\n        ws.close();\n        ws.on('close', () => done());\n      });\n    }).timeout(4000);","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from a listener of the 'redirect' event","suites":["WebSocket","#close"],"updatePoint":{"line":1957,"column":61,"index":73049},"line":1957,"code":"    it(\"can be called from a listener of the 'redirect' event\", done => {\n      const server = http.createServer();\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n      });\n      server.listen(() => {\n        const port = server.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}`, {\n          followRedirects: true\n        });\n        ws.on('open', () => {\n          done(new Error(\"Unexpected 'open' event\"));\n        });\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', code => {\n            assert.strictEqual(code, 1006);\n            server.close(done);\n          });\n        });\n        ws.on('redirect', () => {\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from a listener of the 'upgrade' event","suites":["WebSocket","#close"],"updatePoint":{"line":1983,"column":60,"index":73966},"line":1983,"code":"    it(\"can be called from a listener of the 'upgrade' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        ws.on('upgrade', () => ws.close());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"sends the close status code only when necessary","suites":["WebSocket","#close"],"updatePoint":{"line":1997,"column":55,"index":74558},"line":1997,"code":"    it('sends the close status code only when necessary', done => {\n      let sent;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws._socket.once('data', data => {\n            sent = data;\n          });\n        });\n      });\n      wss.on('connection', ws => {\n        ws._socket.once('data', received => {\n          assert.deepStrictEqual(received.slice(0, 2), Buffer.from([0x88, 0x80]));\n          assert.deepStrictEqual(sent, Buffer.from([0x88, 0x00]));\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1005);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works when close reason is not specified","suites":["WebSocket","#close"],"updatePoint":{"line":2023,"column":48,"index":75386},"line":2023,"code":"    it('works when close reason is not specified', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.close(1000));\n      });\n      wss.on('connection', ws => {\n        ws.on('close', (code, message) => {\n          assert.strictEqual(code, 1000);\n          assert.deepStrictEqual(message, EMPTY_BUFFER);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works when close reason is specified","suites":["WebSocket","#close"],"updatePoint":{"line":2038,"column":44,"index":75881},"line":2038,"code":"    it('works when close reason is specified', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => ws.close(1000, 'some reason'));\n      });\n      wss.on('connection', ws => {\n        ws.on('close', (code, message) => {\n          assert.strictEqual(code, 1000);\n          assert.deepStrictEqual(message, Buffer.from('some reason'));\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"permits all buffered data to be delivered","suites":["WebSocket","#close"],"updatePoint":{"line":2053,"column":49,"index":76410},"line":2053,"code":"    it('permits all buffered data to be delivered', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: {\n          threshold: 0\n        },\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        const messages = [];\n        ws.on('message', (message, isBinary) => {\n          assert.ok(!isBinary);\n          messages.push(message.toString());\n        });\n        ws.on('close', code => {\n          assert.strictEqual(code, 1005);\n          assert.deepStrictEqual(messages, ['foo', 'bar', 'baz']);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        const callback = err => assert.ifError(err);\n\n        ws.send('foo', callback);\n        ws.send('bar', callback);\n        ws.send('baz', callback);\n        ws.close();\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows close code 1013","suites":["WebSocket","#close"],"updatePoint":{"line":2082,"column":30,"index":77272},"line":2082,"code":"    it('allows close code 1013', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', code => {\n          assert.strictEqual(code, 1013);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close(1013));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows close code 1014","suites":["WebSocket","#close"],"updatePoint":{"line":2094,"column":30,"index":77645},"line":2094,"code":"    it('allows close code 1014', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', code => {\n          assert.strictEqual(code, 1014);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close(1014));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does nothing if `readyState` is `CLOSED`","suites":["WebSocket","#close"],"updatePoint":{"line":2106,"column":48,"index":78036},"line":2106,"code":"    it('does nothing if `readyState` is `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', code => {\n          assert.strictEqual(code, 1005);\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.close();\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close());\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"sets a timer for the closing handshake to complete","suites":["WebSocket","#close"],"updatePoint":{"line":2120,"column":58,"index":78518},"line":2120,"code":"    it('sets a timer for the closing handshake to complete', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1000);\n          assert.deepStrictEqual(reason, Buffer.from('some reason'));\n          wss.close(done);\n        });\n        ws.on('open', () => {\n          let callbackCalled = false;\n          assert.strictEqual(ws._closeTimer, null);\n          ws.send('foo', () => {\n            callbackCalled = true;\n          });\n          ws.close(1000, 'some reason'); //\n          // Check that the close timer is set even if the `Sender.close()`\n          // callback is not called.\n          //\n\n          assert.strictEqual(callbackCalled, false);\n          assert.strictEqual(ws._closeTimer._idleTimeout, 30000);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (1/2)","suites":["WebSocket","#terminate"],"updatePoint":{"line":2148,"column":62,"index":79496},"line":2148,"code":"    it('closes the connection if called while connecting (1/2)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        ws.terminate();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes the connection if called while connecting (2/2)","suites":["WebSocket","#terminate"],"updatePoint":{"line":2162,"column":62,"index":80075},"line":2162,"code":"    it('closes the connection if called while connecting (2/2)', done => {\n      const wss = new WebSocket.Server({\n        verifyClient: (info, cb) => setTimeout(cb, 300, true),\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        setTimeout(() => ws.terminate(), 150);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from an error listener while connecting","suites":["WebSocket","#terminate"],"updatePoint":{"line":2177,"column":61,"index":80739},"line":2177,"code":"    it('can be called from an error listener while connecting', done => {\n      const ws = new WebSocket('ws://localhost:1337');\n      ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n      ws.on('error', err => {\n        assert.ok(err instanceof Error);\n        assert.strictEqual(err.code, 'ECONNREFUSED');\n        ws.terminate();\n        ws.on('close', () => done());\n      });\n    }).timeout(4000);","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from a listener of the 'redirect' event","suites":["WebSocket","#terminate"],"updatePoint":{"line":2187,"column":61,"index":81158},"line":2187,"code":"    it(\"can be called from a listener of the 'redirect' event\", done => {\n      const server = http.createServer();\n      server.once('upgrade', (req, socket) => {\n        socket.end('HTTP/1.1 302 Found\\r\\nLocation: /foo\\r\\n\\r\\n');\n      });\n      server.listen(() => {\n        const port = server.address().port;\n        const ws = new WebSocket(`ws://localhost:${port}`, {\n          followRedirects: true\n        });\n        ws.on('open', () => {\n          done(new Error(\"Unexpected 'open' event\"));\n        });\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', code => {\n            assert.strictEqual(code, 1006);\n            server.close(done);\n          });\n        });\n        ws.on('redirect', () => {\n          ws.terminate();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be called from a listener of the 'upgrade' event","suites":["WebSocket","#terminate"],"updatePoint":{"line":2213,"column":60,"index":82079},"line":2213,"code":"    it(\"can be called from a listener of the 'upgrade' event\", done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => done(new Error(\"Unexpected 'open' event\")));\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          assert.strictEqual(err.message, 'WebSocket was closed before the connection was established');\n          ws.on('close', () => wss.close(done));\n        });\n        ws.on('upgrade', () => ws.terminate());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"does nothing if `readyState` is `CLOSED`","suites":["WebSocket","#terminate"],"updatePoint":{"line":2227,"column":48,"index":82668},"line":2227,"code":"    it('does nothing if `readyState` is `CLOSED`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('close', code => {\n          assert.strictEqual(code, 1006);\n          assert.strictEqual(ws.readyState, WebSocket.CLOSED);\n          ws.terminate();\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.terminate());\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"supports the `on{close,error,message,open}` attributes","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2243,"column":62,"index":83211},"line":2243,"code":"    it('supports the `on{close,error,message,open}` attributes', () => {\n      for (const property of ['onclose', 'onerror', 'onmessage', 'onopen']) {\n        const descriptor = Object.getOwnPropertyDescriptor(WebSocket.prototype, property);\n        assert.strictEqual(descriptor.configurable, true);\n        assert.strictEqual(descriptor.enumerable, true);\n        assert.ok(descriptor.get !== undefined);\n        assert.ok(descriptor.set !== undefined);\n      }\n\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      assert.strictEqual(ws.onmessage, null);\n      assert.strictEqual(ws.onclose, null);\n      assert.strictEqual(ws.onerror, null);\n      assert.strictEqual(ws.onopen, null);\n      ws.onmessage = NOOP;\n      ws.onerror = NOOP;\n      ws.onclose = NOOP;\n      ws.onopen = NOOP;\n      assert.strictEqual(ws.onmessage, NOOP);\n      assert.strictEqual(ws.onclose, NOOP);\n      assert.strictEqual(ws.onerror, NOOP);\n      assert.strictEqual(ws.onopen, NOOP);\n      ws.onmessage = 'foo';\n      assert.strictEqual(ws.onmessage, null);\n      assert.strictEqual(ws.listenerCount('onmessage'), 0);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works like the `EventEmitter` interface","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2271,"column":47,"index":84352},"line":2271,"code":"    it('works like the `EventEmitter` interface', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n\n        ws.onmessage = messageEvent => {\n          assert.strictEqual(messageEvent.data, 'foo');\n\n          ws.onclose = closeEvent => {\n            assert.strictEqual(closeEvent.wasClean, true);\n            assert.strictEqual(closeEvent.code, 1005);\n            assert.strictEqual(closeEvent.reason, '');\n            wss.close(done);\n          };\n\n          ws.close();\n        };\n\n        ws.onopen = () => ws.send('foo');\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          ws.send(msg, {\n            binary: isBinary\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't return listeners added with `on`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2300,"column":48,"index":85176},"line":2300,"code":"    it(\"doesn't return listeners added with `on`\", () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.on('open', NOOP);\n      assert.deepStrictEqual(ws.listeners('open'), [NOOP]);\n      assert.strictEqual(ws.onopen, null);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't remove listeners added with `on`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2308,"column":48,"index":85467},"line":2308,"code":"    it(\"doesn't remove listeners added with `on`\", () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.on('close', NOOP);\n      ws.onclose = NOOP;\n      let listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n      ws.onclose = NOOP;\n      listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"supports the `addEventListener` method","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2324,"column":46,"index":86090},"line":2324,"code":"    it('supports the `addEventListener` method', () => {\n      const events = [];\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.addEventListener('foo', () => {});\n      assert.strictEqual(ws.listenerCount('foo'), 0);\n      ws.addEventListener('open', () => {\n        events.push('open');\n        assert.strictEqual(ws.listenerCount('open'), 1);\n      });\n      assert.strictEqual(ws.listenerCount('open'), 1);\n      ws.addEventListener('message', () => {\n        events.push('message');\n        assert.strictEqual(ws.listenerCount('message'), 0);\n      }, {\n        once: true\n      });\n      assert.strictEqual(ws.listenerCount('message'), 1);\n      ws.emit('open');\n      ws.emit('message', EMPTY_BUFFER, false);\n      assert.deepStrictEqual(events, ['open', 'message']);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't return listeners added with `addEventListener`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2347,"column":62,"index":86945},"line":2347,"code":"    it(\"doesn't return listeners added with `addEventListener`\", () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.addEventListener('open', NOOP);\n      const listeners = ws.listeners('open');\n      assert.strictEqual(listeners.length, 1);\n      assert.strictEqual(listeners[0][kListener], NOOP);\n      assert.strictEqual(ws.onopen, null);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't remove listeners added with `addEventListener`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2357,"column":62,"index":87354},"line":2357,"code":"    it(\"doesn't remove listeners added with `addEventListener`\", () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.addEventListener('close', NOOP);\n      ws.onclose = NOOP;\n      let listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0][kListener], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n      ws.onclose = NOOP;\n      listeners = ws.listeners('close');\n      assert.strictEqual(listeners.length, 2);\n      assert.strictEqual(listeners[0][kListener], NOOP);\n      assert.strictEqual(listeners[1][kListener], NOOP);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"supports the `removeEventListener` method","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2373,"column":49,"index":88016},"line":2373,"code":"    it('supports the `removeEventListener` method', () => {\n      const ws = new WebSocket('ws://localhost', {\n        agent: new CustomAgent()\n      });\n      ws.addEventListener('message', NOOP);\n      ws.addEventListener('open', NOOP);\n      assert.strictEqual(ws.listeners('message')[0][kListener], NOOP);\n      assert.strictEqual(ws.listeners('open')[0][kListener], NOOP);\n      ws.removeEventListener('message', () => {});\n      assert.strictEqual(ws.listeners('message')[0][kListener], NOOP);\n      ws.removeEventListener('message', NOOP);\n      ws.removeEventListener('open', NOOP);\n      assert.strictEqual(ws.listenerCount('message'), 0);\n      assert.strictEqual(ws.listenerCount('open'), 0);\n      ws.addEventListener('message', NOOP, {\n        once: true\n      });\n      ws.addEventListener('open', NOOP, {\n        once: true\n      });\n      assert.strictEqual(ws.listeners('message')[0][kListener], NOOP);\n      assert.strictEqual(ws.listeners('open')[0][kListener], NOOP);\n      ws.removeEventListener('message', () => {});\n      assert.strictEqual(ws.listeners('message')[0][kListener], NOOP);\n      ws.removeEventListener('message', NOOP);\n      ws.removeEventListener('open', NOOP);\n      assert.strictEqual(ws.listenerCount('message'), 0);\n      assert.strictEqual(ws.listenerCount('open'), 0); // Multiple listeners.\n\n      ws.addEventListener('message', NOOP);\n      ws.addEventListener('message', NOOP);\n      assert.strictEqual(ws.listeners('message')[0][kListener], NOOP);\n      assert.strictEqual(ws.listeners('message')[1][kListener], NOOP);\n      ws.removeEventListener('message', NOOP);\n      assert.strictEqual(ws.listeners('message')[0][kListener], NOOP);\n      ws.removeEventListener('message', NOOP);\n      assert.strictEqual(ws.listenerCount('message'), 0); // Listeners not added with `websocket.addEventListener()`.\n\n      ws.on('message', NOOP);\n      assert.deepStrictEqual(ws.listeners('message'), [NOOP]);\n      ws.removeEventListener('message', NOOP);\n      assert.deepStrictEqual(ws.listeners('message'), [NOOP]);\n      ws.onclose = NOOP;\n      assert.strictEqual(ws.listeners('close')[0][kListener], NOOP);\n      ws.removeEventListener('close', NOOP);\n      assert.strictEqual(ws.listeners('close')[0][kListener], NOOP);\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"wraps text data in a `MessageEvent`","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2420,"column":43,"index":90281},"line":2420,"code":"    it('wraps text data in a `MessageEvent`', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.addEventListener('open', () => {\n          ws.send('hi');\n          ws.close();\n        });\n        ws.addEventListener('message', event => {\n          assert.ok(event instanceof MessageEvent);\n          assert.strictEqual(event.data, 'hi');\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          ws.send(msg, {\n            binary: isBinary\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"receives a `CloseEvent` when server closes (1000)","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2443,"column":57,"index":90980},"line":2443,"code":"    it('receives a `CloseEvent` when server closes (1000)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.addEventListener('close', event => {\n          assert.ok(event instanceof CloseEvent);\n          assert.ok(event.wasClean);\n          assert.strictEqual(event.reason, '');\n          assert.strictEqual(event.code, 1000);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close(1000));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"receives a `CloseEvent` when server closes (4000)","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2458,"column":57,"index":91536},"line":2458,"code":"    it('receives a `CloseEvent` when server closes (4000)', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.addEventListener('close', event => {\n          assert.ok(event instanceof CloseEvent);\n          assert.ok(event.wasClean);\n          assert.strictEqual(event.reason, 'some daft reason');\n          assert.strictEqual(event.code, 4000);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => ws.close(4000, 'some daft reason'));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"sets `target` and `type` on events","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2473,"column":42,"index":92113},"line":2473,"code":"    it('sets `target` and `type` on events', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const err = new Error('forced');\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.addEventListener('open', event => {\n          assert.ok(event instanceof Event);\n          assert.strictEqual(event.type, 'open');\n          assert.strictEqual(event.target, ws);\n        });\n        ws.addEventListener('message', event => {\n          assert.ok(event instanceof MessageEvent);\n          assert.strictEqual(event.type, 'message');\n          assert.strictEqual(event.target, ws);\n          ws.close();\n        });\n        ws.addEventListener('close', event => {\n          assert.ok(event instanceof CloseEvent);\n          assert.strictEqual(event.type, 'close');\n          assert.strictEqual(event.target, ws);\n          ws.emit('error', err);\n        });\n        ws.addEventListener('error', event => {\n          assert.ok(event instanceof ErrorEvent);\n          assert.strictEqual(event.message, 'forced');\n          assert.strictEqual(event.type, 'error');\n          assert.strictEqual(event.target, ws);\n          assert.strictEqual(event.error, err);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', client => client.send('hi'));\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"passes binary data as a Node.js `Buffer` by default","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2507,"column":59,"index":93469},"line":2507,"code":"    it('passes binary data as a Node.js `Buffer` by default', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n\n        ws.onmessage = evt => {\n          assert.ok(Buffer.isBuffer(evt.data));\n          wss.close(done);\n        };\n      });\n      wss.on('connection', ws => {\n        ws.send(new Uint8Array(4096));\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"ignores `binaryType` for text messages","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2523,"column":46,"index":93917},"line":2523,"code":"    it('ignores `binaryType` for text messages', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.binaryType = 'arraybuffer';\n\n        ws.onmessage = evt => {\n          assert.strictEqual(evt.data, 'foo');\n          wss.close(done);\n        };\n      });\n      wss.on('connection', ws => {\n        ws.send('foo');\n        ws.close();\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows to update `binaryType` on the fly","suites":["WebSocket","WHATWG API emulation"],"updatePoint":{"line":2540,"column":48,"index":94390},"line":2540,"code":"    it('allows to update `binaryType` on the fly', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n\n        function testType(binaryType, next) {\n          const buf = Buffer.from(binaryType);\n          ws.binaryType = binaryType;\n\n          ws.onmessage = evt => {\n            if (binaryType === 'nodebuffer') {\n              assert.ok(Buffer.isBuffer(evt.data));\n              assert.ok(evt.data.equals(buf));\n            } else if (binaryType === 'arraybuffer') {\n              assert.ok(evt.data instanceof ArrayBuffer);\n              assert.ok(Buffer.from(evt.data).equals(buf));\n            } else if (binaryType === 'fragments') {\n              assert.deepStrictEqual(evt.data, [buf]);\n            }\n\n            next();\n          };\n\n          ws.send(buf);\n        }\n\n        ws.onopen = () => {\n          testType('nodebuffer', () => {\n            testType('arraybuffer', () => {\n              testType('fragments', () => {\n                ws.close();\n                wss.close(done);\n              });\n            });\n          });\n        };\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (msg, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(msg);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"connects to secure websocket server","suites":["WebSocket","SSL"],"updatePoint":{"line":2587,"column":43,"index":95757},"line":2587,"code":"    it('connects to secure websocket server', done => {\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem')\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('connection', () => {\n        server.close(done);\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://127.0.0.1:${server.address().port}`, {\n          rejectUnauthorized: false\n        });\n        ws.on('open', ws.close);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"connects to secure websocket server with client side certificate","suites":["WebSocket","SSL"],"updatePoint":{"line":2605,"column":72,"index":96360},"line":2605,"code":"    it('connects to secure websocket server with client side certificate', done => {\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        ca: [fs.readFileSync('test/fixtures/ca-certificate.pem')],\n        key: fs.readFileSync('test/fixtures/key.pem'),\n        requestCert: true\n      });\n      const wss = new WebSocket.Server({\n        noServer: true\n      });\n      server.on('upgrade', (request, socket, head) => {\n        assert.ok(socket.authorized);\n        wss.handleUpgrade(request, socket, head, ws => {\n          ws.on('close', code => {\n            assert.strictEqual(code, 1005);\n            server.close(done);\n          });\n        });\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n          cert: fs.readFileSync('test/fixtures/client-certificate.pem'),\n          key: fs.readFileSync('test/fixtures/client-key.pem'),\n          rejectUnauthorized: false\n        });\n        ws.on('open', ws.close);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"cannot connect to secure websocket server via ws://","suites":["WebSocket","SSL"],"updatePoint":{"line":2633,"column":59,"index":97414},"line":2633,"code":"    it('cannot connect to secure websocket server via ws://', done => {\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem')\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`ws://localhost:${server.address().port}`, {\n          rejectUnauthorized: false\n        });\n        ws.on('error', () => {\n          server.close(done);\n          wss.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send and receive text data","suites":["WebSocket","SSL"],"updatePoint":{"line":2651,"column":38,"index":97972},"line":2651,"code":"    it('can send and receive text data', done => {\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem')\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, Buffer.from('foobar'));\n          assert.ok(!isBinary);\n          server.close(done);\n        });\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n          rejectUnauthorized: false\n        });\n        ws.on('open', () => {\n          ws.send('foobar');\n          ws.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a big binary message","suites":["WebSocket","SSL"],"updatePoint":{"line":2676,"column":37,"index":98762},"line":2676,"code":"    it('can send a big binary message', done => {\n      const buf = crypto.randomBytes(5 * 1024 * 1024);\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem')\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      wss.on('connection', ws => {\n        ws.on('message', (message, isBinary) => {\n          assert.ok(isBinary);\n          ws.send(message);\n          ws.close();\n        });\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n          rejectUnauthorized: false\n        });\n        ws.on('open', () => ws.send(buf));\n        ws.on('message', (message, isBinary) => {\n          assert.deepStrictEqual(message, buf);\n          assert.ok(isBinary);\n          server.close(done);\n        });\n      });\n    }).timeout(4000);","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"allows to disable sending the SNI extension","suites":["WebSocket","SSL"],"updatePoint":{"line":2704,"column":51,"index":99709},"line":2704,"code":"    it('allows to disable sending the SNI extension', done => {\n      const original = tls.connect;\n\n      tls.connect = options => {\n        assert.strictEqual(options.servername, '');\n        tls.connect = original;\n        done();\n      };\n\n      const ws = new WebSocket('wss://127.0.0.1', {\n        servername: ''\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"works around a double 'error' event bug in Node.js","suites":["WebSocket","SSL"],"updatePoint":{"line":2717,"column":58,"index":100053},"line":2717,"code":"    it(\"works around a double 'error' event bug in Node.js\", function (done) {\n      //\n      // The `minVersion` and `maxVersion` options are not supported in\n      // Node.js < 10.16.0.\n      //\n      if (process.versions.modules < 64) return this.skip(); //\n      // The `'error'` event can be emitted multiple times by the\n      // `http.ClientRequest` object in Node.js < 13. This test reproduces the\n      // issue in Node.js 12.\n      //\n\n      const server = https.createServer({\n        cert: fs.readFileSync('test/fixtures/certificate.pem'),\n        key: fs.readFileSync('test/fixtures/key.pem'),\n        minVersion: 'TLSv1.2'\n      });\n      const wss = new WebSocket.Server({\n        server\n      });\n      server.listen(0, () => {\n        const ws = new WebSocket(`wss://localhost:${server.address().port}`, {\n          maxVersion: 'TLSv1.1',\n          rejectUnauthorized: false\n        });\n        ws.on('error', err => {\n          assert.ok(err instanceof Error);\n          server.close(done);\n          wss.close();\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"adds the authorization header if the url has userinfo","suites":["WebSocket","Request headers"],"updatePoint":{"line":2750,"column":61,"index":101162},"line":2750,"code":"    it('adds the authorization header if the url has userinfo', done => {\n      const agent = new CustomAgent();\n      const userinfo = 'test:testpass';\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('authorization'), `Basic ${Buffer.from(userinfo).toString('base64')}`);\n        done();\n      };\n\n      const ws = new WebSocket(`ws://${userinfo}@localhost`, {\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `auth` option","suites":["WebSocket","Request headers"],"updatePoint":{"line":2763,"column":32,"index":101555},"line":2763,"code":"    it('honors the `auth` option', done => {\n      const agent = new CustomAgent();\n      const auth = 'user:pass';\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('authorization'), `Basic ${Buffer.from(auth).toString('base64')}`);\n        done();\n      };\n\n      const ws = new WebSocket('ws://localhost', {\n        agent,\n        auth\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"favors the url userinfo over the `auth` option","suites":["WebSocket","Request headers"],"updatePoint":{"line":2777,"column":54,"index":101960},"line":2777,"code":"    it('favors the url userinfo over the `auth` option', done => {\n      const agent = new CustomAgent();\n      const auth = 'foo:bar';\n      const userinfo = 'baz:qux';\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('authorization'), `Basic ${Buffer.from(userinfo).toString('base64')}`);\n        done();\n      };\n\n      const ws = new WebSocket(`ws://${userinfo}@localhost`, {\n        agent,\n        auth\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"adds custom headers","suites":["WebSocket","Request headers"],"updatePoint":{"line":2792,"column":27,"index":102386},"line":2792,"code":"    it('adds custom headers', done => {\n      const agent = new CustomAgent();\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('cookie'), 'foo=bar');\n        done();\n      };\n\n      const ws = new WebSocket('ws://localhost', {\n        headers: {\n          Cookie: 'foo=bar'\n        },\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"excludes default ports from host header","suites":["WebSocket","Request headers"],"updatePoint":{"line":2807,"column":47,"index":102751},"line":2807,"code":"    it('excludes default ports from host header', () => {\n      const options = {\n        lookup() {}\n\n      };\n      const variants = [['wss://localhost:8443', 'localhost:8443'], ['wss://localhost:443', 'localhost'], ['ws://localhost:88', 'localhost:88'], ['ws://localhost:80', 'localhost']];\n\n      for (const [url, host] of variants) {\n        const ws = new WebSocket(url, options);\n        assert.strictEqual(ws._req.getHeader('host'), host);\n      }\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"doesn't add the origin header by default","suites":["WebSocket","Request headers"],"updatePoint":{"line":2819,"column":48,"index":103216},"line":2819,"code":"    it(\"doesn't add the origin header by default\", done => {\n      const agent = new CustomAgent();\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('origin'), undefined);\n        done();\n      };\n\n      const ws = new WebSocket('ws://localhost', {\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `origin` option (1/2)","suites":["WebSocket","Request headers"],"updatePoint":{"line":2831,"column":40,"index":103516},"line":2831,"code":"    it('honors the `origin` option (1/2)', done => {\n      const agent = new CustomAgent();\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('origin'), 'https://example.com:8000');\n        done();\n      };\n\n      const ws = new WebSocket('ws://localhost', {\n        origin: 'https://example.com:8000',\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"honors the `origin` option (2/2)","suites":["WebSocket","Request headers"],"updatePoint":{"line":2844,"column":40,"index":103877},"line":2844,"code":"    it('honors the `origin` option (2/2)', done => {\n      const agent = new CustomAgent();\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('sec-websocket-origin'), 'https://example.com:8000');\n        done();\n      };\n\n      const ws = new WebSocket('ws://localhost', {\n        origin: 'https://example.com:8000',\n        protocolVersion: 8,\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"is enabled by default","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2860,"column":29,"index":104316},"line":2860,"code":"    it('is enabled by default', done => {\n      const agent = new CustomAgent();\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('sec-websocket-extensions'), 'permessage-deflate; client_max_window_bits');\n        done();\n      };\n\n      const ws = new WebSocket('ws://localhost', {\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be disabled","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2872,"column":23,"index":104652},"line":2872,"code":"    it('can be disabled', done => {\n      const agent = new CustomAgent();\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('sec-websocket-extensions'), undefined);\n        done();\n      };\n\n      const ws = new WebSocket('ws://localhost', {\n        perMessageDeflate: false,\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send extension parameters","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2885,"column":37,"index":105001},"line":2885,"code":"    it('can send extension parameters', done => {\n      const agent = new CustomAgent();\n      const value = 'permessage-deflate; server_no_context_takeover;' + ' client_no_context_takeover; server_max_window_bits=10;' + ' client_max_window_bits';\n\n      agent.addRequest = req => {\n        assert.strictEqual(req.getHeader('sec-websocket-extensions'), value);\n        done();\n      };\n\n      const ws = new WebSocket('ws://localhost', {\n        perMessageDeflate: {\n          clientNoContextTakeover: true,\n          serverNoContextTakeover: true,\n          clientMaxWindowBits: true,\n          serverMaxWindowBits: 10\n        },\n        agent\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"consumes all received data when connection is closed (1/2)","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2904,"column":66,"index":105693},"line":2904,"code":"    it('consumes all received data when connection is closed (1/2)', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: {\n          threshold: 0\n        },\n        port: 0\n      }, () => {\n        const messages = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws._socket.on('close', () => {\n            assert.strictEqual(ws._receiver._state, 5);\n          });\n        });\n        ws.on('message', (message, isBinary) => {\n          assert.ok(!isBinary);\n          messages.push(message.toString());\n        });\n        ws.on('close', code => {\n          assert.strictEqual(code, 1006);\n          assert.deepStrictEqual(messages, ['foo', 'bar', 'baz', 'qux']);\n          wss.close(done);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.send('foo');\n        ws.send('bar');\n        ws.send('baz');\n        ws.send('qux', () => ws._socket.end());\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"consumes all received data when connection is closed (2/2)","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":2935,"column":66,"index":106675},"line":2935,"code":"    it('consumes all received data when connection is closed (2/2)', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const messageLengths = [];\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('open', () => {\n          ws._socket.prependListener('close', () => {\n            assert.strictEqual(ws._receiver._state, 5);\n            assert.strictEqual(ws._socket._readableState.length, 3);\n          });\n\n          const push = ws._socket.push; // Override `ws._socket.push()` to know exactly when data is\n          // received and call `ws.terminate()` immediately after that without\n          // relying on a timer.\n\n          ws._socket.push = data => {\n            ws._socket.push = push;\n\n            ws._socket.push(data);\n\n            ws.terminate();\n          };\n\n          const payload1 = Buffer.alloc(15 * 1024);\n          const payload2 = Buffer.alloc(1);\n          const opts = {\n            fin: true,\n            opcode: 0x02,\n            mask: false,\n            readOnly: false\n          };\n          const list = [...Sender.frame(payload1, {\n            rsv1: false,\n            ...opts\n          }), ...Sender.frame(payload2, {\n            rsv1: true,\n            ...opts\n          })];\n\n          for (let i = 0; i < 399; i++) {\n            list.push(list[list.length - 2], list[list.length - 1]);\n          } // This hack is used because there is no guarantee that more than\n          // 16 KiB will be sent as a single TCP packet.\n\n\n          push.call(ws._socket, Buffer.concat(list));\n          wss.clients.values().next().value.send(payload2, {\n            compress: false\n          });\n        });\n        ws.on('message', (message, isBinary) => {\n          assert.ok(isBinary);\n          messageLengths.push(message.length);\n        });\n        ws.on('close', code => {\n          assert.strictEqual(code, 1006);\n          assert.strictEqual(messageLengths.length, 402);\n          assert.strictEqual(messageLengths[0], 15360);\n          assert.strictEqual(messageLengths[messageLengths.length - 1], 1);\n          wss.close(done);\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"handles a close frame received while compressing data","suites":["WebSocket","permessage-deflate"],"updatePoint":{"line":3000,"column":61,"index":108870},"line":3000,"code":"    it('handles a close frame received while compressing data', done => {\n      const wss = new WebSocket.Server({\n        perMessageDeflate: true,\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n          perMessageDeflate: {\n            threshold: 0\n          }\n        });\n        ws.on('open', () => {\n          ws._receiver.on('conclude', () => {\n            assert.ok(ws._sender._deflating);\n          });\n\n          ws.send('foo');\n          ws.send('bar');\n          ws.send('baz');\n          ws.send('qux');\n        });\n      });\n      wss.on('connection', ws => {\n        const messages = [];\n        ws.on('message', (message, isBinary) => {\n          assert.ok(!isBinary);\n          messages.push(message.toString());\n        });\n        ws.on('close', (code, reason) => {\n          assert.deepStrictEqual(messages, ['foo', 'bar', 'baz', 'qux']);\n          assert.strictEqual(code, 1000);\n          assert.deepStrictEqual(reason, EMPTY_BUFFER);\n          wss.close(done);\n        });\n        ws.close(1000);\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be used while data is being decompressed","suites":["WebSocket","permessage-deflate","#close"],"updatePoint":{"line":3037,"column":54,"index":109992},"line":3037,"code":"      it('can be used while data is being decompressed', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const messages = [];\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          ws.on('open', () => {\n            ws._socket.on('end', () => {\n              assert.strictEqual(ws._receiver._state, 5);\n            });\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.ok(!isBinary);\n            if (messages.push(message.toString()) > 1) return;\n            ws.close(1000);\n          });\n          ws.on('close', (code, reason) => {\n            assert.deepStrictEqual(messages, ['', '', '', '']);\n            assert.strictEqual(code, 1000);\n            assert.deepStrictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          const buf = Buffer.from('c10100c10100c10100c10100', 'hex');\n\n          ws._socket.write(buf);\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send text data","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3069,"column":28,"index":111074},"line":3069,"code":"      it('can send text data', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: {\n            threshold: 0\n          },\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send('hi', {\n              compress: true\n            });\n            ws.close();\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.deepStrictEqual(message, Buffer.from('hi'));\n            assert.ok(!isBinary);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('message', (message, isBinary) => {\n            ws.send(message, {\n              binary: isBinary,\n              compress: true\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send a `TypedArray`","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3102,"column":33,"index":112015},"line":3102,"code":"      it('can send a `TypedArray`', done => {\n        const array = new Float32Array(5);\n\n        for (let i = 0; i < array.length; i++) {\n          array[i] = i / 2;\n        }\n\n        const wss = new WebSocket.Server({\n          perMessageDeflate: {\n            threshold: 0\n          },\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send(array, {\n              compress: true\n            });\n            ws.close();\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.deepStrictEqual(message, Buffer.from(array.buffer));\n            assert.ok(isBinary);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('message', (message, isBinary) => {\n            assert.ok(isBinary);\n            ws.send(message, {\n              compress: true\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can send an `ArrayBuffer`","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3141,"column":35,"index":113099},"line":3141,"code":"      it('can send an `ArrayBuffer`', done => {\n        const array = new Float32Array(5);\n\n        for (let i = 0; i < array.length; i++) {\n          array[i] = i / 2;\n        }\n\n        const wss = new WebSocket.Server({\n          perMessageDeflate: {\n            threshold: 0\n          },\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send(array.buffer, {\n              compress: true\n            });\n            ws.close();\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.deepStrictEqual(message, Buffer.from(array.buffer));\n            assert.ok(isBinary);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('message', (message, isBinary) => {\n            assert.ok(isBinary);\n            ws.send(message, {\n              compress: true\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"ignores the `compress` option if the extension is disabled","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3180,"column":68,"index":114223},"line":3180,"code":"      it('ignores the `compress` option if the extension is disabled', done => {\n        const wss = new WebSocket.Server({\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: false\n          });\n          ws.on('open', () => {\n            ws.send('hi', {\n              compress: true\n            });\n            ws.close();\n          });\n          ws.on('message', (message, isBinary) => {\n            assert.deepStrictEqual(message, Buffer.from('hi'));\n            assert.ok(!isBinary);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('message', (message, isBinary) => {\n            ws.send(message, {\n              binary: isBinary,\n              compress: true\n            });\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"calls the callback if the socket is closed prematurely","suites":["WebSocket","permessage-deflate","#send"],"updatePoint":{"line":3208,"column":64,"index":115089},"line":3208,"code":"      it('calls the callback if the socket is closed prematurely', done => {\n        const called = [];\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send('foo');\n            ws.send('bar', err => {\n              called.push(1);\n              assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'The socket was closed while data was being compressed');\n            });\n            ws.send('baz');\n            ws.send('qux', err => {\n              called.push(2);\n              assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'The socket was closed while data was being compressed');\n            });\n          });\n        });\n        wss.on('connection', ws => {\n          ws.on('close', () => {\n            assert.deepStrictEqual(called, [1, 2]);\n            wss.close(done);\n          });\n\n          ws._socket.end();\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be used while data is being compressed","suites":["WebSocket","permessage-deflate","#terminate"],"updatePoint":{"line":3247,"column":52,"index":116436},"line":3247,"code":"      it('can be used while data is being compressed', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: {\n            threshold: 0\n          },\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`, {\n            perMessageDeflate: {\n              threshold: 0\n            }\n          });\n          ws.on('open', () => {\n            ws.send('hi', err => {\n              assert.strictEqual(ws.readyState, WebSocket.CLOSING);\n              assert.ok(err instanceof Error);\n              assert.strictEqual(err.message, 'The socket was closed while data was being compressed');\n              ws.on('close', () => {\n                wss.close(done);\n              });\n            });\n            ws.terminate();\n          });\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"can be used while data is being decompressed","suites":["WebSocket","permessage-deflate","#terminate"],"updatePoint":{"line":3272,"column":54,"index":117271},"line":3272,"code":"      it('can be used while data is being decompressed', done => {\n        const wss = new WebSocket.Server({\n          perMessageDeflate: true,\n          port: 0\n        }, () => {\n          const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n          const messages = [];\n          ws.on('message', (message, isBinary) => {\n            assert.ok(!isBinary);\n            if (messages.push(message.toString()) > 1) return;\n            process.nextTick(() => {\n              assert.strictEqual(ws._receiver._state, 5);\n              ws.terminate();\n            });\n          });\n          ws.on('close', (code, reason) => {\n            assert.deepStrictEqual(messages, ['', '', '', '']);\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n        wss.on('connection', ws => {\n          const buf = Buffer.from('c10100c10100c10100c10100', 'hex');\n\n          ws._socket.write(buf);\n        });\n      });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes cleanly after simultaneous errors (1/2)","suites":["WebSocket","Connection close"],"updatePoint":{"line":3303,"column":54,"index":118342},"line":3303,"code":"    it('closes cleanly after simultaneous errors (1/2)', done => {\n      let clientCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            clientCloseEventEmitted = true;\n            if (serverClientCloseEventEmitted) wss.close(done);\n          });\n        });\n        ws.on('open', () => {\n          // Write an invalid frame in both directions to trigger simultaneous\n          // failure.\n          const chunk = Buffer.from([0x85, 0x00]);\n\n          wss.clients.values().next().value._socket.write(chunk);\n\n          ws._socket.write(chunk);\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            serverClientCloseEventEmitted = true;\n            if (clientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"closes cleanly after simultaneous errors (2/2)","suites":["WebSocket","Connection close"],"updatePoint":{"line":3345,"column":54,"index":120029},"line":3345,"code":"    it('closes cleanly after simultaneous errors (2/2)', done => {\n      let clientCloseEventEmitted = false;\n      let serverClientCloseEventEmitted = false;\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            clientCloseEventEmitted = true;\n            if (serverClientCloseEventEmitted) wss.close(done);\n          });\n        });\n        ws.on('open', () => {\n          // Write an invalid frame in both directions and change the\n          // `readyState` to `WebSocket.CLOSING`.\n          const chunk = Buffer.from([0x85, 0x00]);\n          const serverWs = wss.clients.values().next().value;\n\n          serverWs._socket.write(chunk);\n\n          serverWs.close();\n\n          ws._socket.write(chunk);\n\n          ws.close();\n        });\n      });\n      wss.on('connection', ws => {\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_INVALID_OPCODE');\n          assert.strictEqual(err.message, 'Invalid WebSocket frame: invalid opcode 5');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            serverClientCloseEventEmitted = true;\n            if (clientCloseEventEmitted) wss.close(done);\n          });\n        });\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"resumes the socket when an error occurs","suites":["WebSocket","Connection close"],"updatePoint":{"line":3392,"column":47,"index":121817},"line":3392,"code":"    it('resumes the socket when an error occurs', done => {\n      const maxPayload = 16 * 1024;\n      const wss = new WebSocket.Server({\n        maxPayload,\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        const list = [...Sender.frame(Buffer.alloc(maxPayload + 1), {\n          fin: true,\n          opcode: 0x02,\n          mask: true,\n          readOnly: false\n        })];\n        ws.on('error', err => {\n          assert.ok(err instanceof RangeError);\n          assert.strictEqual(err.code, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n          assert.strictEqual(err.message, 'Max payload size exceeded');\n          ws.on('close', (code, reason) => {\n            assert.strictEqual(code, 1006);\n            assert.strictEqual(reason, EMPTY_BUFFER);\n            wss.close(done);\n          });\n        });\n\n        ws._socket.push(Buffer.concat(list));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"},{"name":"resumes the socket when the close frame is received","suites":["WebSocket","Connection close"],"updatePoint":{"line":3421,"column":59,"index":122806},"line":3421,"code":"    it('resumes the socket when the close frame is received', done => {\n      const wss = new WebSocket.Server({\n        port: 0\n      }, () => {\n        const ws = new WebSocket(`ws://localhost:${wss.address().port}`);\n      });\n      wss.on('connection', ws => {\n        const opts = {\n          fin: true,\n          mask: true,\n          readOnly: false\n        };\n        const list = [...Sender.frame(Buffer.alloc(16 * 1024), {\n          opcode: 0x02,\n          ...opts\n        }), ...Sender.frame(EMPTY_BUFFER, {\n          opcode: 0x08,\n          ...opts\n        })];\n        ws.on('close', (code, reason) => {\n          assert.strictEqual(code, 1005);\n          assert.strictEqual(reason, EMPTY_BUFFER);\n          wss.close(done);\n        });\n\n        ws._socket.push(Buffer.concat(list));\n      });\n    });","file":"websocket.test.js","skipped":false,"dir":"test"}]}