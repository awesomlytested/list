{"repo":"puppeteer/puppeteer","url":"https://github.com/puppeteer/puppeteer","branch":"main","configs":[{"package":"puppeteer","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should work","suites":[],"updatePoint":{"line":29,"column":17},"line":29,"code":"  it('should work', async () => {\n    const { page, isFirefox } = getTestState();\n\n    await page.setContent(`\n      <head>\n        <title>Accessibility Test</title>\n      </head>\n      <body>\n        <div>Hello World</div>\n        <h1>Inputs</h1>\n        <input placeholder=\"Empty input\" autofocus />\n        <input placeholder=\"readonly input\" readonly />\n        <input placeholder=\"disabled input\" disabled />\n        <input aria-label=\"Input with whitespace\" value=\"  \" />\n        <input value=\"value only\" />\n        <input aria-placeholder=\"placeholder\" value=\"and a value\" />\n        <div aria-hidden=\"true\" id=\"desc\">This is a description!</div>\n        <input aria-placeholder=\"placeholder\" value=\"and a value\" aria-describedby=\"desc\" />\n        <select>\n          <option>First Option</option>\n          <option>Second Option</option>\n        </select>\n      </body>`);\n\n    await page.focus('[placeholder=\"Empty input\"]');\n    const golden = isFirefox\n      ? {\n          role: 'document',\n          name: 'Accessibility Test',\n          children: [\n            { role: 'text leaf', name: 'Hello World' },\n            { role: 'heading', name: 'Inputs', level: 1 },\n            { role: 'entry', name: 'Empty input', focused: true },\n            { role: 'entry', name: 'readonly input', readonly: true },\n            { role: 'entry', name: 'disabled input', disabled: true },\n            { role: 'entry', name: 'Input with whitespace', value: '  ' },\n            { role: 'entry', name: '', value: 'value only' },\n            { role: 'entry', name: '', value: 'and a value' }, // firefox doesn't use aria-placeholder for the name\n            {\n              role: 'entry',\n              name: '',\n              value: 'and a value',\n              description: 'This is a description!',\n            }, // and here\n            {\n              role: 'combobox',\n              name: '',\n              value: 'First Option',\n              haspopup: true,\n              children: [\n                {\n                  role: 'combobox option',\n                  name: 'First Option',\n                  selected: true,\n                },\n                { role: 'combobox option', name: 'Second Option' },\n              ],\n            },\n          ],\n        }\n      : {\n          role: 'RootWebArea',\n          name: 'Accessibility Test',\n          children: [\n            { role: 'StaticText', name: 'Hello World' },\n            { role: 'heading', name: 'Inputs', level: 1 },\n            { role: 'textbox', name: 'Empty input', focused: true },\n            { role: 'textbox', name: 'readonly input', readonly: true },\n            { role: 'textbox', name: 'disabled input', disabled: true },\n            { role: 'textbox', name: 'Input with whitespace', value: '  ' },\n            { role: 'textbox', name: '', value: 'value only' },\n            { role: 'textbox', name: 'placeholder', value: 'and a value' },\n            {\n              role: 'textbox',\n              name: 'placeholder',\n              value: 'and a value',\n              description: 'This is a description!',\n            },\n            {\n              role: 'combobox',\n              name: '',\n              value: 'First Option',\n              haspopup: 'menu',\n              children: [\n                { role: 'menuitem', name: 'First Option', selected: true },\n                { role: 'menuitem', name: 'Second Option' },\n              ],\n            },\n          ],\n        };\n    expect(await page.accessibility.snapshot()).toEqual(golden);\n  });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should report uninteresting nodes","suites":[],"updatePoint":{"line":121,"column":39},"line":121,"code":"  it('should report uninteresting nodes', async () => {\n    const { page, isFirefox } = getTestState();\n\n    await page.setContent(`<textarea>hi</textarea>`);\n    await page.focus('textarea');\n    const golden = isFirefox\n      ? {\n          role: 'entry',\n          name: '',\n          value: 'hi',\n          focused: true,\n          multiline: true,\n          children: [\n            {\n              role: 'text leaf',\n              name: 'hi',\n            },\n          ],\n        }\n      : {\n          role: 'textbox',\n          name: '',\n          value: 'hi',\n          focused: true,\n          multiline: true,\n          children: [\n            {\n              role: 'generic',\n              name: '',\n              children: [\n                {\n                  role: 'StaticText',\n                  name: 'hi',\n                },\n              ],\n            },\n          ],\n        };\n    expect(\n      findFocusedNode(\n        await page.accessibility.snapshot({ interestingOnly: false })\n      )\n    ).toEqual(golden);\n  });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"roledescription","suites":[],"updatePoint":{"line":165,"column":21},"line":165,"code":"  it('roledescription', async () => {\n    const { page } = getTestState();\n\n    await page.setContent(\n      '<div tabIndex=-1 aria-roledescription=\"foo\">Hi</div>'\n    );\n    const snapshot = await page.accessibility.snapshot();\n    // See https://chromium-review.googlesource.com/c/chromium/src/+/3088862\n    expect(snapshot.children[0].roledescription).toEqual(undefined);\n  });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"orientation","suites":[],"updatePoint":{"line":175,"column":17},"line":175,"code":"  it('orientation', async () => {\n    const { page } = getTestState();\n\n    await page.setContent(\n      '<a href=\"\" role=\"slider\" aria-orientation=\"vertical\">11</a>'\n    );\n    const snapshot = await page.accessibility.snapshot();\n    expect(snapshot.children[0].orientation).toEqual('vertical');\n  });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"autocomplete","suites":[],"updatePoint":{"line":184,"column":18},"line":184,"code":"  it('autocomplete', async () => {\n    const { page } = getTestState();\n\n    await page.setContent('<input type=\"number\" aria-autocomplete=\"list\" />');\n    const snapshot = await page.accessibility.snapshot();\n    expect(snapshot.children[0].autocomplete).toEqual('list');\n  });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"multiselectable","suites":[],"updatePoint":{"line":191,"column":21},"line":191,"code":"  it('multiselectable', async () => {\n    const { page } = getTestState();\n\n    await page.setContent(\n      '<div role=\"grid\" tabIndex=-1 aria-multiselectable=true>hey</div>'\n    );\n    const snapshot = await page.accessibility.snapshot();\n    expect(snapshot.children[0].multiselectable).toEqual(true);\n  });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"keyshortcuts","suites":[],"updatePoint":{"line":200,"column":18},"line":200,"code":"  it('keyshortcuts', async () => {\n    const { page } = getTestState();\n\n    await page.setContent(\n      '<div role=\"grid\" tabIndex=-1 aria-keyshortcuts=\"foo\">hey</div>'\n    );\n    const snapshot = await page.accessibility.snapshot();\n    expect(snapshot.children[0].keyshortcuts).toEqual('foo');\n  });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should not report text nodes inside controls","suites":["filtering children of leaf nodes"],"updatePoint":{"line":210,"column":52},"line":210,"code":"    it('should not report text nodes inside controls', async () => {\n      const { page, isFirefox } = getTestState();\n\n      await page.setContent(`\n        <div role=\"tablist\">\n          <div role=\"tab\" aria-selected=\"true\"><b>Tab1</b></div>\n          <div role=\"tab\">Tab2</div>\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'document',\n            name: '',\n            children: [\n              {\n                role: 'pagetab',\n                name: 'Tab1',\n                selected: true,\n              },\n              {\n                role: 'pagetab',\n                name: 'Tab2',\n              },\n            ],\n          }\n        : {\n            role: 'RootWebArea',\n            name: '',\n            children: [\n              {\n                role: 'tab',\n                name: 'Tab1',\n                selected: true,\n              },\n              {\n                role: 'tab',\n                name: 'Tab2',\n              },\n            ],\n          };\n      expect(await page.accessibility.snapshot()).toEqual(golden);\n    });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"rich text editable fields should have children","suites":["filtering children of leaf nodes"],"updatePoint":{"line":251,"column":54},"line":251,"code":"    it('rich text editable fields should have children', async () => {\n      const { page, isFirefox } = getTestState();\n\n      await page.setContent(`\n        <div contenteditable=\"true\">\n          Edit this image: <img src=\"fakeimage.png\" alt=\"my fake image\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'section',\n            name: '',\n            children: [\n              {\n                role: 'text leaf',\n                name: 'Edit this image: ',\n              },\n              {\n                role: 'StaticText',\n                name: 'my fake image',\n              },\n            ],\n          }\n        : {\n            role: 'generic',\n            name: '',\n            value: 'Edit this image: ',\n            children: [\n              {\n                role: 'StaticText',\n                name: 'Edit this image:',\n              },\n              {\n                role: 'img',\n                name: 'my fake image',\n              },\n            ],\n          };\n      const snapshot = await page.accessibility.snapshot();\n      expect(snapshot.children[0]).toEqual(golden);\n    });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"rich text editable fields with role should have children","suites":["filtering children of leaf nodes"],"updatePoint":{"line":291,"column":64},"line":291,"code":"    it('rich text editable fields with role should have children', async () => {\n      const { page, isFirefox } = getTestState();\n\n      await page.setContent(`\n        <div contenteditable=\"true\" role='textbox'>\n          Edit this image: <img src=\"fakeimage.png\" alt=\"my fake image\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'entry',\n            name: '',\n            value: 'Edit this image: my fake image',\n            children: [\n              {\n                role: 'StaticText',\n                name: 'my fake image',\n              },\n            ],\n          }\n        : {\n            role: 'textbox',\n            name: '',\n            value: 'Edit this image: ',\n            multiline: true,\n            children: [\n              {\n                role: 'StaticText',\n                name: 'Edit this image:',\n              },\n              {\n                role: 'img',\n                name: 'my fake image',\n              },\n            ],\n          };\n      const snapshot = await page.accessibility.snapshot();\n      expect(snapshot.children[0]).toEqual(golden);\n    });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"plain text field with role should not have children","suites":["filtering children of leaf nodes"],"updatePoint":{"line":332,"column":61},"line":332,"code":"      it('plain text field with role should not have children', async () => {\n        const { page } = getTestState();\n\n        await page.setContent(`\n          <div contenteditable=\"plaintext-only\" role='textbox'>Edit this image:<img src=\"fakeimage.png\" alt=\"my fake image\"></div>`);\n        const snapshot = await page.accessibility.snapshot();\n        expect(snapshot.children[0]).toEqual({\n          role: 'textbox',\n          name: '',\n          value: 'Edit this image:',\n          multiline: true,\n        });\n      });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"non editable textbox with role and tabIndex and label should not have children","suites":["filtering children of leaf nodes"],"updatePoint":{"line":346,"column":86},"line":346,"code":"    it('non editable textbox with role and tabIndex and label should not have children', async () => {\n      const { page, isFirefox } = getTestState();\n\n      await page.setContent(`\n        <div role=\"textbox\" tabIndex=0 aria-checked=\"true\" aria-label=\"my favorite textbox\">\n          this is the inner content\n          <img alt=\"yo\" src=\"fakeimg.png\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'entry',\n            name: 'my favorite textbox',\n            value: 'this is the inner content yo',\n          }\n        : {\n            role: 'textbox',\n            name: 'my favorite textbox',\n            value: 'this is the inner content ',\n          };\n      const snapshot = await page.accessibility.snapshot();\n      expect(snapshot.children[0]).toEqual(golden);\n    });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"checkbox with and tabIndex and label should not have children","suites":["filtering children of leaf nodes"],"updatePoint":{"line":368,"column":69},"line":368,"code":"    it('checkbox with and tabIndex and label should not have children', async () => {\n      const { page, isFirefox } = getTestState();\n\n      await page.setContent(`\n        <div role=\"checkbox\" tabIndex=0 aria-checked=\"true\" aria-label=\"my favorite checkbox\">\n          this is the inner content\n          <img alt=\"yo\" src=\"fakeimg.png\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'checkbutton',\n            name: 'my favorite checkbox',\n            checked: true,\n          }\n        : {\n            role: 'checkbox',\n            name: 'my favorite checkbox',\n            checked: true,\n          };\n      const snapshot = await page.accessibility.snapshot();\n      expect(snapshot.children[0]).toEqual(golden);\n    });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"checkbox without label should not have children","suites":["filtering children of leaf nodes"],"updatePoint":{"line":390,"column":55},"line":390,"code":"    it('checkbox without label should not have children', async () => {\n      const { page, isFirefox } = getTestState();\n\n      await page.setContent(`\n        <div role=\"checkbox\" aria-checked=\"true\">\n          this is the inner content\n          <img alt=\"yo\" src=\"fakeimg.png\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'checkbutton',\n            name: 'this is the inner content yo',\n            checked: true,\n          }\n        : {\n            role: 'checkbox',\n            name: 'this is the inner content yo',\n            checked: true,\n          };\n      const snapshot = await page.accessibility.snapshot();\n      expect(snapshot.children[0]).toEqual(golden);\n    });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should work a button","suites":["filtering children of leaf nodes","root option"],"updatePoint":{"line":414,"column":30},"line":414,"code":"      it('should work a button', async () => {\n        const { page } = getTestState();\n\n        await page.setContent(`<button>My Button</button>`);\n\n        const button = await page.$<HTMLButtonElement>('button');\n        expect(await page.accessibility.snapshot({ root: button })).toEqual({\n          role: 'button',\n          name: 'My Button',\n        });\n      });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should work an input","suites":["filtering children of leaf nodes","root option"],"updatePoint":{"line":425,"column":30},"line":425,"code":"      it('should work an input', async () => {\n        const { page } = getTestState();\n\n        await page.setContent(`<input title=\"My Input\" value=\"My Value\">`);\n\n        const input = await page.$('input');\n        expect(await page.accessibility.snapshot({ root: input })).toEqual({\n          role: 'textbox',\n          name: 'My Input',\n          value: 'My Value',\n        });\n      });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should work a menu","suites":["filtering children of leaf nodes","root option"],"updatePoint":{"line":437,"column":28},"line":437,"code":"      it('should work a menu', async () => {\n        const { page } = getTestState();\n\n        await page.setContent(`\n            <div role=\"menu\" title=\"My Menu\">\n              <div role=\"menuitem\">First Item</div>\n              <div role=\"menuitem\">Second Item</div>\n              <div role=\"menuitem\">Third Item</div>\n            </div>\n          `);\n\n        const menu = await page.$('div[role=\"menu\"]');\n        expect(await page.accessibility.snapshot({ root: menu })).toEqual({\n          role: 'menu',\n          name: 'My Menu',\n          children: [\n            { role: 'menuitem', name: 'First Item' },\n            { role: 'menuitem', name: 'Second Item' },\n            { role: 'menuitem', name: 'Third Item' },\n          ],\n          orientation: 'vertical',\n        });\n      });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should return null when the element is no longer in DOM","suites":["filtering children of leaf nodes","root option"],"updatePoint":{"line":460,"column":65},"line":460,"code":"      it('should return null when the element is no longer in DOM', async () => {\n        const { page } = getTestState();\n\n        await page.setContent(`<button>My Button</button>`);\n        const button = await page.$('button');\n        await page.$eval('button', (button) => button.remove());\n        expect(await page.accessibility.snapshot({ root: button })).toEqual(\n          null\n        );\n      });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should support the interestingOnly option","suites":["filtering children of leaf nodes","root option"],"updatePoint":{"line":470,"column":51},"line":470,"code":"      it('should support the interestingOnly option', async () => {\n        const { page } = getTestState();\n\n        await page.setContent(`<div><button>My Button</button></div>`);\n        const div = await page.$('div');\n        expect(await page.accessibility.snapshot({ root: div })).toEqual(null);\n        expect(\n          await page.accessibility.snapshot({\n            root: div,\n            interestingOnly: false,\n          })\n        ).toEqual({\n          role: 'generic',\n          name: '',\n          children: [\n            {\n              role: 'button',\n              name: 'My Button',\n              children: [{ role: 'StaticText', name: 'My Button' }],\n            },\n          ],\n        });\n      });","file":"accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should find button","suites":["parseAriaSelector"],"updatePoint":{"line":39,"column":26},"line":39,"code":"    it('should find button', async () => {\n      const { page } = getTestState();\n      const expectFound = async (button: ElementHandle) => {\n        const id = await button.evaluate((button: Element) => button.id);\n        expect(id).toBe('btn');\n      };\n      let button = await page.$(\n        'aria/Submit button and some spaces[role=\"button\"]'\n      );\n      await expectFound(button);\n      button = await page.$(\n        \"aria/Submit button and some spaces[role='button']\"\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/  Submit button and some spaces[role=\"button\"]'\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/Submit button and some spaces  [role=\"button\"]'\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/Submit  button   and  some  spaces   [  role  =  \"button\" ] '\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/[role=\"button\"]Submit button and some spaces'\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/Submit button [role=\"button\"]and some spaces'\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/[name=\"  Submit  button and some  spaces\"][role=\"button\"]'\n      );\n      await expectFound(button);\n      button = await page.$(\n        \"aria/[name='  Submit  button and some  spaces'][role='button']\"\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/ignored[name=\"Submit  button and some  spaces\"][role=\"button\"]'\n      );\n      await expectFound(button);\n      await expect(page.$('aria/smth[smth=\"true\"]')).rejects.toThrow(\n        'Unknown aria attribute \"smth\" in selector'\n      );\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find button by role","suites":["queryOne"],"updatePoint":{"line":92,"column":34},"line":92,"code":"    it('should find button by role', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        '<div id=\"div\"><button id=\"btn\" role=\"button\">Submit</button></div>'\n      );\n      const button = await page.$('aria/[role=\"button\"]');\n      const id = await button.evaluate((button: Element) => button.id);\n      expect(id).toBe('btn');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find button by name and role","suites":["queryOne"],"updatePoint":{"line":102,"column":43},"line":102,"code":"    it('should find button by name and role', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        '<div id=\"div\"><button id=\"btn\" role=\"button\">Submit</button></div>'\n      );\n      const button = await page.$('aria/Submit[role=\"button\"]');\n      const id = await button.evaluate((button: Element) => button.id);\n      expect(id).toBe('btn');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find first matching element","suites":["queryOne"],"updatePoint":{"line":112,"column":42},"line":112,"code":"    it('should find first matching element', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        `\n        <div role=\"menu\" id=\"mnu1\" aria-label=\"menu div\"></div>\n        <div role=\"menu\" id=\"mnu2\" aria-label=\"menu div\"></div>\n        `\n      );\n      const div = await page.$('aria/menu div');\n      const id = await div.evaluate((div: Element) => div.id);\n      expect(id).toBe('mnu1');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by name","suites":["queryOne"],"updatePoint":{"line":125,"column":27},"line":125,"code":"    it('should find by name', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        `\n        <div role=\"menu\" id=\"mnu1\" aria-label=\"menu-label1\">menu div</div>\n        <div role=\"menu\" id=\"mnu2\" aria-label=\"menu-label2\">menu div</div>\n        `\n      );\n      const menu = await page.$('aria/menu-label1');\n      const id = await menu.evaluate((div: Element) => div.id);\n      expect(id).toBe('mnu1');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by name","suites":["queryOne"],"updatePoint":{"line":138,"column":27},"line":138,"code":"    it('should find by name', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        `\n        <div role=\"menu\" id=\"mnu1\" aria-label=\"menu-label1\">menu div</div>\n        <div role=\"menu\" id=\"mnu2\" aria-label=\"menu-label2\">menu div</div>\n        `\n      );\n      const menu = await page.$('aria/menu-label2');\n      const id = await menu.evaluate((div: Element) => div.id);\n      expect(id).toBe('mnu2');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find menu by name","suites":["queryAll"],"updatePoint":{"line":153,"column":32},"line":153,"code":"    it('should find menu by name', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        `\n        <div role=\"menu\" id=\"mnu1\" aria-label=\"menu div\"></div>\n        <div role=\"menu\" id=\"mnu2\" aria-label=\"menu div\"></div>\n        `\n      );\n      const divs = await page.$$('aria/menu div');\n      const ids = await Promise.all(\n        divs.map((n) => n.evaluate((div: Element) => div.id))\n      );\n      expect(ids.join(', ')).toBe('mnu1, mnu2');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should handle many elements","suites":["queryAllArray"],"updatePoint":{"line":169,"column":42},"line":169,"code":"    it('$$eval should handle many elements', async () => {\n      const { page } = getTestState();\n      await page.setContent('');\n      await page.evaluate(\n        `\n        for (var i = 0; i <= 10000; i++) {\n            const button = document.createElement('button');\n            button.textContent = i;\n            document.body.appendChild(button);\n        }\n        `\n      );\n      const sum = await page.$$eval('aria/[role=\"button\"]', (buttons) =>\n        buttons.reduce((acc, button) => acc + Number(button.textContent), 0)\n      );\n      expect(sum).toBe(50005000);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should immediately resolve promise if node exists","suites":["waitForSelector (aria)"],"updatePoint":{"line":192,"column":57},"line":192,"code":"    it('should immediately resolve promise if node exists', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work for ElementHandler.waitForSelector","suites":["waitForSelector (aria)"],"updatePoint":{"line":199,"column":54},"line":199,"code":"    it('should work for ElementHandler.waitForSelector', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(\n        () => (document.body.innerHTML = `<div><button>test</button></div>`)\n      );\n      const element = await page.$('div');\n      await element.waitForSelector('aria/test');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should persist query handler bindings across reloads","suites":["waitForSelector (aria)"],"updatePoint":{"line":209,"column":60},"line":209,"code":"    it('should persist query handler bindings across reloads', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n      await page.reload();\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should persist query handler bindings across navigations","suites":["waitForSelector (aria)"],"updatePoint":{"line":219,"column":64},"line":219,"code":"    it('should persist query handler bindings across navigations', async () => {\n      const { page, server } = getTestState();\n\n      // Reset page but make sure that execution context ids start with 1.\n      await page.goto('data:text/html,');\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n\n      // Reset page but again make sure that execution context ids start with 1.\n      await page.goto('data:text/html,');\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work independently of `exposeFunction`","suites":["waitForSelector (aria)"],"updatePoint":{"line":235,"column":53},"line":235,"code":"    it('should work independently of `exposeFunction`', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.exposeFunction('ariaQuerySelector', (a, b) => a + b);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n      const result = await page.evaluate('globalThis.ariaQuerySelector(2,8)');\n      expect(result).toBe(10);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work with removed MutationObserver","suites":["waitForSelector (aria)"],"updatePoint":{"line":245,"column":49},"line":245,"code":"    it('should work with removed MutationObserver', async () => {\n      const { page } = getTestState();\n\n      await page.evaluate(() => delete window.MutationObserver);\n      const [handle] = await Promise.all([\n        page.waitForSelector('aria/anything'),\n        page.setContent(`<h1>anything</h1>`),\n      ]);\n      expect(\n        await page.evaluate((x: HTMLElement) => x.textContent, handle)\n      ).toBe('anything');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve promise when node is added","suites":["waitForSelector (aria)"],"updatePoint":{"line":258,"column":49},"line":258,"code":"    it('should resolve promise when node is added', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const frame = page.mainFrame();\n      const watchdog = frame.waitForSelector('aria/[role=\"heading\"]');\n      await frame.evaluate(addElement, 'br');\n      await frame.evaluate(addElement, 'h1');\n      const elementHandle = await watchdog;\n      const tagName = await elementHandle\n        .getProperty('tagName')\n        .then((element) => element.jsonValue());\n      expect(tagName).toBe('H1');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work when node is added through innerHTML","suites":["waitForSelector (aria)"],"updatePoint":{"line":273,"column":56},"line":273,"code":"    it('should work when node is added through innerHTML', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const watchdog = page.waitForSelector('aria/name');\n      await page.evaluate(addElement, 'span');\n      await page.evaluate(\n        () =>\n          (document.querySelector('span').innerHTML =\n            '<h3><div aria-label=\"name\"></div></h3>')\n      );\n      await watchdog;\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"Page.waitForSelector is shortcut for main frame","suites":["waitForSelector (aria)"],"updatePoint":{"line":287,"column":55},"line":287,"code":"    it('Page.waitForSelector is shortcut for main frame', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const otherFrame = page.frames()[1];\n      const watchdog = page.waitForSelector('aria/[role=\"button\"]');\n      await otherFrame.evaluate(addElement, 'button');\n      await page.evaluate(addElement, 'button');\n      const elementHandle = await watchdog;\n      expect(elementHandle.executionContext().frame()).toBe(page.mainFrame());\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should run in specified frame","suites":["waitForSelector (aria)"],"updatePoint":{"line":300,"column":37},"line":300,"code":"    it('should run in specified frame', async () => {\n      const { page, server } = getTestState();\n\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame2', server.EMPTY_PAGE);\n      const frame1 = page.frames()[1];\n      const frame2 = page.frames()[2];\n      const waitForSelectorPromise = frame2.waitForSelector(\n        'aria/[role=\"button\"]'\n      );\n      await frame1.evaluate(addElement, 'button');\n      await frame2.evaluate(addElement, 'button');\n      const elementHandle = await waitForSelectorPromise;\n      expect(elementHandle.executionContext().frame()).toBe(frame2);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when frame is detached","suites":["waitForSelector (aria)"],"updatePoint":{"line":316,"column":43},"line":316,"code":"    it('should throw when frame is detached', async () => {\n      const { page, server } = getTestState();\n\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const frame = page.frames()[1];\n      let waitError = null;\n      const waitPromise = frame\n        .waitForSelector('aria/does-not-exist')\n        .catch((error) => (waitError = error));\n      await utils.detachFrame(page, 'frame1');\n      await waitPromise;\n      expect(waitError).toBeTruthy();\n      expect(waitError.message).toContain(\n        'waitForFunction failed: frame got detached.'\n      );\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should survive cross-process navigation","suites":["waitForSelector (aria)"],"updatePoint":{"line":333,"column":47},"line":333,"code":"    it('should survive cross-process navigation', async () => {\n      const { page, server } = getTestState();\n\n      let imgFound = false;\n      const waitForSelector = page\n        .waitForSelector('aria/[role=\"img\"]')\n        .then(() => (imgFound = true));\n      await page.goto(server.EMPTY_PAGE);\n      expect(imgFound).toBe(false);\n      await page.reload();\n      expect(imgFound).toBe(false);\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/grid.html');\n      await waitForSelector;\n      expect(imgFound).toBe(true);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for visible","suites":["waitForSelector (aria)"],"updatePoint":{"line":349,"column":31},"line":349,"code":"    it('should wait for visible', async () => {\n      const { page } = getTestState();\n\n      let divFound = false;\n      const waitForSelector = page\n        .waitForSelector('aria/name', { visible: true })\n        .then(() => (divFound = true));\n      await page.setContent(\n        `<div aria-label='name' style='display: none; visibility: hidden;'>1</div>`\n      );\n      expect(divFound).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.removeProperty('display')\n      );\n      expect(divFound).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.removeProperty('visibility')\n      );\n      expect(await waitForSelector).toBe(true);\n      expect(divFound).toBe(true);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for visible recursively","suites":["waitForSelector (aria)"],"updatePoint":{"line":371,"column":43},"line":371,"code":"    it('should wait for visible recursively', async () => {\n      const { page } = getTestState();\n\n      let divVisible = false;\n      const waitForSelector = page\n        .waitForSelector('aria/inner', { visible: true })\n        .then(() => (divVisible = true));\n      await page.setContent(\n        `<div style='display: none; visibility: hidden;'><div aria-label=\"inner\">hi</div></div>`\n      );\n      expect(divVisible).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.removeProperty('display')\n      );\n      expect(divVisible).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.removeProperty('visibility')\n      );\n      expect(await waitForSelector).toBe(true);\n      expect(divVisible).toBe(true);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for visibility: hidden","suites":["waitForSelector (aria)"],"updatePoint":{"line":393,"column":49},"line":393,"code":"    it('hidden should wait for visibility: hidden', async () => {\n      const { page } = getTestState();\n\n      let divHidden = false;\n      await page.setContent(\n        `<div role='button' style='display: block;'></div>`\n      );\n      const waitForSelector = page\n        .waitForSelector('aria/[role=\"button\"]', { hidden: true })\n        .then(() => (divHidden = true));\n      await page.waitForSelector('aria/[role=\"button\"]'); // do a round trip\n      expect(divHidden).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.setProperty('visibility', 'hidden')\n      );\n      expect(await waitForSelector).toBe(true);\n      expect(divHidden).toBe(true);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for display: none","suites":["waitForSelector (aria)"],"updatePoint":{"line":412,"column":44},"line":412,"code":"    it('hidden should wait for display: none', async () => {\n      const { page } = getTestState();\n\n      let divHidden = false;\n      await page.setContent(`<div role='main' style='display: block;'></div>`);\n      const waitForSelector = page\n        .waitForSelector('aria/[role=\"main\"]', { hidden: true })\n        .then(() => (divHidden = true));\n      await page.waitForSelector('aria/[role=\"main\"]'); // do a round trip\n      expect(divHidden).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.setProperty('display', 'none')\n      );\n      expect(await waitForSelector).toBe(true);\n      expect(divHidden).toBe(true);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for removal","suites":["waitForSelector (aria)"],"updatePoint":{"line":429,"column":38},"line":429,"code":"    it('hidden should wait for removal', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<div role='main'></div>`);\n      let divRemoved = false;\n      const waitForSelector = page\n        .waitForSelector('aria/[role=\"main\"]', { hidden: true })\n        .then(() => (divRemoved = true));\n      await page.waitForSelector('aria/[role=\"main\"]'); // do a round trip\n      expect(divRemoved).toBe(false);\n      await page.evaluate(() => document.querySelector('div').remove());\n      expect(await waitForSelector).toBe(true);\n      expect(divRemoved).toBe(true);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return null if waiting to hide non-existing element","suites":["waitForSelector (aria)"],"updatePoint":{"line":444,"column":66},"line":444,"code":"    it('should return null if waiting to hide non-existing element', async () => {\n      const { page } = getTestState();\n\n      const handle = await page.waitForSelector('aria/non-existing', {\n        hidden: true,\n      });\n      expect(handle).toBe(null);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["waitForSelector (aria)"],"updatePoint":{"line":453,"column":30},"line":453,"code":"    it('should respect timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      await page\n        .waitForSelector('aria/[role=\"button\"]', { timeout: 10 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain(\n        'waiting for selector `[role=\"button\"]` failed: timeout'\n      );\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should have an error message specifically for awaiting an element to be hidden","suites":["waitForSelector (aria)"],"updatePoint":{"line":467,"column":86},"line":467,"code":"    it('should have an error message specifically for awaiting an element to be hidden', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<div role='main'></div>`);\n      let error = null;\n      await page\n        .waitForSelector('aria/[role=\"main\"]', { hidden: true, timeout: 10 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain(\n        'waiting for selector `[role=\"main\"]` to be hidden failed: timeout'\n      );\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should respond to node attribute mutation","suites":["waitForSelector (aria)"],"updatePoint":{"line":481,"column":49},"line":481,"code":"    it('should respond to node attribute mutation', async () => {\n      const { page } = getTestState();\n\n      let divFound = false;\n      const waitForSelector = page\n        .waitForSelector('aria/zombo')\n        .then(() => (divFound = true));\n      await page.setContent(`<div aria-label='notZombo'></div>`);\n      expect(divFound).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').setAttribute('aria-label', 'zombo')\n      );\n      expect(await waitForSelector).toBe(true);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return the element handle","suites":["waitForSelector (aria)"],"updatePoint":{"line":496,"column":40},"line":496,"code":"    it('should return the element handle', async () => {\n      const { page } = getTestState();\n\n      const waitForSelector = page.waitForSelector('aria/zombo');\n      await page.setContent(`<div aria-label='zombo'>anything</div>`);\n      expect(\n        await page.evaluate(\n          (x: HTMLElement) => x.textContent,\n          await waitForSelector\n        )\n      ).toBe('anything');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should have correct stack trace for timeout","suites":["waitForSelector (aria)"],"updatePoint":{"line":509,"column":51},"line":509,"code":"    it('should have correct stack trace for timeout', async () => {\n      const { page } = getTestState();\n\n      let error;\n      await page\n        .waitForSelector('aria/zombo', { timeout: 10 })\n        .catch((error_) => (error = error_));\n      expect(error.stack).toContain('waiting for selector `zombo` failed');\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by name \"foo\"","suites":["queryOne (Chromium web test)"],"updatePoint":{"line":575,"column":33},"line":575,"code":"    it('should find by name \"foo\"', async () => {\n      const { page } = getTestState();\n      const found = await page.$$('aria/foo');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['node3', 'node5', 'node6']);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by name \"bar\"","suites":["queryOne (Chromium web test)"],"updatePoint":{"line":581,"column":33},"line":581,"code":"    it('should find by name \"bar\"', async () => {\n      const { page } = getTestState();\n      const found = await page.$$('aria/bar');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['node1', 'node2', 'node8']);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find treeitem by name","suites":["queryOne (Chromium web test)"],"updatePoint":{"line":587,"column":36},"line":587,"code":"    it('should find treeitem by name', async () => {\n      const { page } = getTestState();\n      const found = await page.$$('aria/item1 item2 item3');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['node30']);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by role \"button\"","suites":["queryOne (Chromium web test)"],"updatePoint":{"line":593,"column":36},"line":593,"code":"    it('should find by role \"button\"', async () => {\n      const { page } = getTestState();\n      const found = await page.$$<HTMLButtonElement>('aria/[role=\"button\"]');\n      const ids = await getIds(found);\n      expect(ids).toEqual([\n        'node5',\n        'node6',\n        'node7',\n        'node8',\n        'node10',\n        'node21',\n      ]);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by role \"heading\"","suites":["queryOne (Chromium web test)"],"updatePoint":{"line":606,"column":37},"line":606,"code":"    it('should find by role \"heading\"', async () => {\n      const { page } = getTestState();\n      const found = await page.$$('aria/[role=\"heading\"]');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['shown', 'hidden', 'node11', 'node13']);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find both ignored and unignored","suites":["queryOne (Chromium web test)"],"updatePoint":{"line":612,"column":46},"line":612,"code":"    it('should find both ignored and unignored', async () => {\n      const { page } = getTestState();\n      const found = await page.$$('aria/title');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['shown', 'hidden']);\n    });","file":"ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"calls every method","suites":["API coverage test"],"updatePoint":{"line":6,"column":24},"line":6,"code":"  it('calls every method', () => {\n    if (!process.env.COVERAGE) return;\n\n    const coverageMap = getCoverageResults();\n    const missingMethods = [];\n    for (const method of coverageMap.keys()) {\n      if (!coverageMap.get(method)) missingMethods.push(method);\n    }\n    if (missingMethods.length) {\n      console.error(\n        '\\nCoverage check failed: not all API methods called. See above output for list of missing methods.'\n      );\n      console.error(missingMethods.join('\\n'));\n    }\n\n    // We know this will fail because we checked above\n    // but we need the actual test to fail.\n    expect(missingMethods.length).toEqual(0);\n  });","file":"assert-coverage-test.js","skipped":false,"dir":"test"},{"name":"should return whether we are in headless","suites":["Browser specs","Browser.version"],"updatePoint":{"line":24,"column":48},"line":24,"code":"    it('should return whether we are in headless', async () => {\n      const { browser, isHeadless } = getTestState();\n\n      const version = await browser.version();\n      expect(version.length).toBeGreaterThan(0);\n      expect(version.startsWith('Headless')).toBe(isHeadless);\n    });","file":"browser.spec.ts","skipped":false,"dir":"test"},{"name":"should include WebKit","suites":["Browser specs","Browser.userAgent"],"updatePoint":{"line":34,"column":29},"line":34,"code":"    it('should include WebKit', async () => {\n      const { browser, isChrome } = getTestState();\n\n      const userAgent = await browser.userAgent();\n      expect(userAgent.length).toBeGreaterThan(0);\n      if (isChrome) expect(userAgent).toContain('WebKit');\n      else expect(userAgent).toContain('Gecko');\n    });","file":"browser.spec.ts","skipped":false,"dir":"test"},{"name":"should return browser target","suites":["Browser specs","Browser.target"],"updatePoint":{"line":45,"column":36},"line":45,"code":"    it('should return browser target', async () => {\n      const { browser } = getTestState();\n\n      const target = browser.target();\n      expect(target.type()).toBe('browser');\n    });","file":"browser.spec.ts","skipped":false,"dir":"test"},{"name":"should return child_process instance","suites":["Browser specs","Browser.process"],"updatePoint":{"line":54,"column":44},"line":54,"code":"    it('should return child_process instance', async () => {\n      const { browser } = getTestState();\n\n      const process = await browser.process();\n      expect(process.pid).toBeGreaterThan(0);\n    });","file":"browser.spec.ts","skipped":false,"dir":"test"},{"name":"should not return child_process for remote browser","suites":["Browser specs","Browser.process"],"updatePoint":{"line":60,"column":58},"line":60,"code":"    it('should not return child_process for remote browser', async () => {\n      const { browser, puppeteer } = getTestState();\n\n      const browserWSEndpoint = browser.wsEndpoint();\n      const remoteBrowser = await puppeteer.connect({ browserWSEndpoint });\n      expect(remoteBrowser.process()).toBe(null);\n      remoteBrowser.disconnect();\n    });","file":"browser.spec.ts","skipped":false,"dir":"test"},{"name":"should set the browser connected state","suites":["Browser specs","Browser.isConnected"],"updatePoint":{"line":71,"column":46},"line":71,"code":"    it('should set the browser connected state', async () => {\n      const { browser, puppeteer } = getTestState();\n\n      const browserWSEndpoint = browser.wsEndpoint();\n      const newBrowser = await puppeteer.connect({ browserWSEndpoint });\n      expect(newBrowser.isConnected()).toBe(true);\n      newBrowser.disconnect();\n      expect(newBrowser.isConnected()).toBe(false);\n    });","file":"browser.spec.ts","skipped":false,"dir":"test"},{"name":"should have default context","suites":["BrowserContext"],"updatePoint":{"line":27,"column":33},"line":27,"code":"  it('should have default context', async () => {\n    const { browser } = getTestState();\n    expect(browser.browserContexts().length).toEqual(1);\n    const defaultContext = browser.browserContexts()[0];\n    expect(defaultContext.isIncognito()).toBe(false);\n    let error = null;\n    await defaultContext.close().catch((error_) => (error = error_));\n    expect(browser.defaultBrowserContext()).toBe(defaultContext);\n    expect(error.message).toContain('cannot be closed');\n  });","file":"browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should create new incognito context","suites":["BrowserContext"],"updatePoint":{"line":37,"column":41},"line":37,"code":"  it('should create new incognito context', async () => {\n    const { browser } = getTestState();\n\n    expect(browser.browserContexts().length).toBe(1);\n    const context = await browser.createIncognitoBrowserContext();\n    expect(context.isIncognito()).toBe(true);\n    expect(browser.browserContexts().length).toBe(2);\n    expect(browser.browserContexts().indexOf(context) !== -1).toBe(true);\n    await context.close();\n    expect(browser.browserContexts().length).toBe(1);\n  });","file":"browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should close all belonging targets once closing context","suites":["BrowserContext"],"updatePoint":{"line":48,"column":61},"line":48,"code":"  it('should close all belonging targets once closing context', async () => {\n    const { browser } = getTestState();\n\n    expect((await browser.pages()).length).toBe(1);\n\n    const context = await browser.createIncognitoBrowserContext();\n    await context.newPage();\n    expect((await browser.pages()).length).toBe(2);\n    expect((await context.pages()).length).toBe(1);\n\n    await context.close();\n    expect((await browser.pages()).length).toBe(1);\n  });","file":"browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should timeout waiting for a non-existent target","suites":["BrowserContext"],"updatePoint":{"line":132,"column":54},"line":132,"code":"  it('should timeout waiting for a non-existent target', async () => {\n    const { browser, puppeteer, server } = getTestState();\n\n    const context = await browser.createIncognitoBrowserContext();\n    const error = await context\n      .waitForTarget((target) => target.url() === server.EMPTY_PAGE, {\n        timeout: 1,\n      })\n      .catch((error_) => error_);\n    expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    await context.close();\n  });","file":"browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":[],"updatePoint":{"line":30,"column":17},"line":30,"code":"  it('should work', async () => {\n    const { page } = getTestState();\n\n    const client = await page.target().createCDPSession();\n\n    await Promise.all([\n      client.send('Runtime.enable'),\n      client.send('Runtime.evaluate', { expression: 'window.foo = \"bar\"' }),\n    ]);\n    const foo = await page.evaluate(() => globalThis.foo);\n    expect(foo).toBe('bar');\n  });","file":"CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should send events","suites":[],"updatePoint":{"line":42,"column":24},"line":42,"code":"  it('should send events', async () => {\n    const { page, server } = getTestState();\n\n    const client = await page.target().createCDPSession();\n    await client.send('Network.enable');\n    const events = [];\n    client.on('Network.requestWillBeSent', (event) => events.push(event));\n    await page.goto(server.EMPTY_PAGE);\n    expect(events.length).toBe(1);\n  });","file":"CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should enable and disable domains independently","suites":[],"updatePoint":{"line":52,"column":53},"line":52,"code":"  it('should enable and disable domains independently', async () => {\n    const { page } = getTestState();\n\n    const client = await page.target().createCDPSession();\n    await client.send('Runtime.enable');\n    await client.send('Debugger.enable');\n    // JS coverage enables and then disables Debugger domain.\n    await page.coverage.startJSCoverage();\n    await page.coverage.stopJSCoverage();\n    // generate a script in page and wait for the event.\n    const [event] = await Promise.all([\n      waitEvent(client, 'Debugger.scriptParsed'),\n      page.evaluate('//# sourceURL=foo.js'),\n    ]);\n    // expect events to be dispatched.\n    expect(event.url).toBe('foo.js');\n  });","file":"CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to detach session","suites":[],"updatePoint":{"line":69,"column":38},"line":69,"code":"  it('should be able to detach session', async () => {\n    const { page } = getTestState();\n\n    const client = await page.target().createCDPSession();\n    await client.send('Runtime.enable');\n    const evalResponse = await client.send('Runtime.evaluate', {\n      expression: '1 + 2',\n      returnByValue: true,\n    });\n    expect(evalResponse.result.value).toBe(3);\n    await client.detach();\n    let error = null;\n    try {\n      await client.send('Runtime.evaluate', {\n        expression: '3 + 1',\n        returnByValue: true,\n      });\n    } catch (error_) {\n      error = error_;\n    }\n    expect(error.message).toContain('Session closed.');\n  });","file":"CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should throw nice errors","suites":[],"updatePoint":{"line":91,"column":30},"line":91,"code":"  it('should throw nice errors', async () => {\n    const { page } = getTestState();\n\n    const client = await page.target().createCDPSession();\n    const error = await theSourceOfTheProblems().catch((error) => error);\n    expect(error.stack).toContain('theSourceOfTheProblems');\n    expect(error.message).toContain('ThisCommand.DoesNotExist');\n\n    async function theSourceOfTheProblems() {\n      // @ts-expect-error This fails in TS as it knows that command does not\n      // exist but we want to have this tests for our users who consume in JS\n      // not TS.\n      await client.send('ThisCommand.DoesNotExist');\n    }\n  });","file":"CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should expose the underlying connection","suites":[],"updatePoint":{"line":107,"column":45},"line":107,"code":"  it('should expose the underlying connection', async () => {\n    const { page } = getTestState();\n\n    const client = await page.target().createCDPSession();\n    expect(client.connection()).toBeTruthy();\n  });","file":"CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to connect using browserUrl, with and without trailing slash","suites":["Puppeteer.launch |browserURL| option"],"updatePoint":{"line":26,"column":83},"line":26,"code":"    it('should be able to connect using browserUrl, with and without trailing slash', async () => {\n      const { defaultBrowserOptions, puppeteer } = getTestState();\n\n      const originalBrowser = await puppeteer.launch(\n        Object.assign({}, defaultBrowserOptions, {\n          args: ['--remote-debugging-port=21222'],\n        })\n      );\n      const browserURL = 'http://127.0.0.1:21222';\n\n      const browser1 = await puppeteer.connect({ browserURL });\n      const page1 = await browser1.newPage();\n      expect(await page1.evaluate(() => 7 * 8)).toBe(56);\n      browser1.disconnect();\n\n      const browser2 = await puppeteer.connect({\n        browserURL: browserURL + '/',\n      });\n      const page2 = await browser2.newPage();\n      expect(await page2.evaluate(() => 8 * 7)).toBe(56);\n      browser2.disconnect();\n      originalBrowser.close();\n    });","file":"chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when using both browserWSEndpoint and browserURL","suites":["Puppeteer.launch |browserURL| option"],"updatePoint":{"line":49,"column":69},"line":49,"code":"    it('should throw when using both browserWSEndpoint and browserURL', async () => {\n      const { defaultBrowserOptions, puppeteer } = getTestState();\n\n      const originalBrowser = await puppeteer.launch(\n        Object.assign({}, defaultBrowserOptions, {\n          args: ['--remote-debugging-port=21222'],\n        })\n      );\n      const browserURL = 'http://127.0.0.1:21222';\n\n      let error = null;\n      await puppeteer\n        .connect({\n          browserURL,\n          browserWSEndpoint: originalBrowser.wsEndpoint(),\n        })\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain(\n        'Exactly one of browserWSEndpoint, browserURL or transport'\n      );\n\n      originalBrowser.close();\n    });","file":"chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when trying to connect to non-existing browser","suites":["Puppeteer.launch |browserURL| option"],"updatePoint":{"line":72,"column":67},"line":72,"code":"    it('should throw when trying to connect to non-existing browser', async () => {\n      const { defaultBrowserOptions, puppeteer } = getTestState();\n\n      const originalBrowser = await puppeteer.launch(\n        Object.assign({}, defaultBrowserOptions, {\n          args: ['--remote-debugging-port=21222'],\n        })\n      );\n      const browserURL = 'http://127.0.0.1:32333';\n\n      let error = null;\n      await puppeteer\n        .connect({ browserURL })\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain(\n        'Failed to fetch browser webSocket URL from'\n      );\n      originalBrowser.close();\n    });","file":"chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should support the pipe option","suites":["Puppeteer.launch |pipe| option"],"updatePoint":{"line":94,"column":38},"line":94,"code":"    it('should support the pipe option', async () => {\n      const { defaultBrowserOptions, puppeteer } = getTestState();\n      const options = Object.assign({ pipe: true }, defaultBrowserOptions);\n      const browser = await puppeteer.launch(options);\n      expect((await browser.pages()).length).toBe(1);\n      expect(browser.wsEndpoint()).toBe('');\n      const page = await browser.newPage();\n      expect(await page.evaluate('11 * 11')).toBe(121);\n      await page.close();\n      await browser.close();\n    });","file":"chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should support the pipe argument","suites":["Puppeteer.launch |pipe| option"],"updatePoint":{"line":105,"column":40},"line":105,"code":"    it('should support the pipe argument', async () => {\n      const { defaultBrowserOptions, puppeteer } = getTestState();\n      const options = Object.assign({}, defaultBrowserOptions);\n      options.args = ['--remote-debugging-pipe'].concat(options.args || []);\n      const browser = await puppeteer.launch(options);\n      expect(browser.wsEndpoint()).toBe('');\n      const page = await browser.newPage();\n      expect(await page.evaluate('11 * 11')).toBe(121);\n      await page.close();\n      await browser.close();\n    });","file":"chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should fire \"disconnected\" when closing with pipe","suites":["Puppeteer.launch |pipe| option"],"updatePoint":{"line":116,"column":57},"line":116,"code":"    it('should fire \"disconnected\" when closing with pipe', async () => {\n      const { defaultBrowserOptions, puppeteer } = getTestState();\n      const options = Object.assign({ pipe: true }, defaultBrowserOptions);\n      const browser = await puppeteer.launch(options);\n      const disconnectedEventPromise = new Promise((resolve) =>\n        browser.once('disconnected', resolve)\n      );\n      // Emulate user exiting browser.\n      browser.process().kill();\n      await disconnectedEventPromise;\n    });","file":"chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"Page.setRequestInterception should work with intervention headers","suites":["Puppeteer.launch |pipe| option"],"updatePoint":{"line":133,"column":71},"line":133,"code":"  it('Page.setRequestInterception should work with intervention headers', async () => {\n    const { server, page } = getTestState();\n\n    server.setRoute('/intervention', (req, res) =>\n      res.end(`\n        <script>\n          document.write('<script src=\"${server.CROSS_PROCESS_PREFIX}/intervention.js\">' + '</scr' + 'ipt>');\n        </script>\n      `)\n    );\n    server.setRedirect('/intervention.js', '/redirect.js');\n    let serverRequest = null;\n    server.setRoute('/redirect.js', (req, res) => {\n      serverRequest = req;\n      res.end('console.log(1);');\n    });\n\n    await page.setRequestInterception(true);\n    page.on('request', (request) => request.continue());\n    await page.goto(server.PREFIX + '/intervention');\n    // Check for feature URL substring rather than https://www.chromestatus.com to\n    // make it work with Edgium.\n    expect(serverRequest.headers.intervention).toContain(\n      'feature/5718547946799104'\n    );\n  });","file":"chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button","suites":["Page.click"],"updatePoint":{"line":29,"column":29},"line":29,"code":"  it('should click the button', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.click('button');\n    expect(await page.evaluate(() => globalThis.result)).toBe('Clicked');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click svg","suites":["Page.click"],"updatePoint":{"line":36,"column":22},"line":36,"code":"  it('should click svg', async () => {\n    const { page } = getTestState();\n\n    await page.setContent(`\n        <svg height=\"100\" width=\"100\">\n          <circle onclick=\"javascript:window.__CLICKED=42\" cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\n        </svg>\n      `);\n    await page.click('circle');\n    expect(await page.evaluate(() => globalThis.__CLICKED)).toBe(42);\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click on a span with an inline element inside","suites":["Page.click"],"updatePoint":{"line":59,"column":58},"line":59,"code":"  it('should click on a span with an inline element inside', async () => {\n    const { page } = getTestState();\n\n    await page.setContent(`\n        <style>\n        span::before {\n          content: 'q';\n        }\n        </style>\n        <span onclick='javascript:window.CLICKED=42'></span>\n      `);\n    await page.click('span');\n    expect(await page.evaluate(() => globalThis.CLICKED)).toBe(42);\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw UnhandledPromiseRejection when page closes","suites":["Page.click"],"updatePoint":{"line":73,"column":65},"line":73,"code":"  it('should not throw UnhandledPromiseRejection when page closes', async () => {\n    const { page } = getTestState();\n\n    const newPage = await page.browser().newPage();\n    await Promise.all([newPage.close(), newPage.mouse.click(1, 2)]).catch(\n      () => {}\n    );\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button after navigation ","suites":["Page.click"],"updatePoint":{"line":81,"column":47},"line":81,"code":"  it('should click the button after navigation ', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.click('button');\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.click('button');\n    expect(await page.evaluate(() => globalThis.result)).toBe('Clicked');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click when one of inline box children is outside of viewport","suites":["Page.click"],"updatePoint":{"line":98,"column":73},"line":98,"code":"  it('should click when one of inline box children is outside of viewport', async () => {\n    const { page } = getTestState();\n\n    await page.setContent(`\n        <style>\n        i {\n          position: absolute;\n          top: -1000px;\n        }\n        </style>\n        <span onclick='javascript:window.CLICKED = 42;'><i>woof</i><b>doggo</b></span>\n      `);\n    await page.click('span');\n    expect(await page.evaluate(() => globalThis.CLICKED)).toBe(42);\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should select the text by triple clicking","suites":["Page.click"],"updatePoint":{"line":113,"column":47},"line":113,"code":"  it('should select the text by triple clicking', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    const text =\n      \"This is the text that we are going to try to select. Let's see how it goes.\";\n    await page.keyboard.type(text);\n    await page.click('textarea');\n    await page.click('textarea', { clickCount: 2 });\n    await page.click('textarea', { clickCount: 3 });\n    expect(\n      await page.evaluate(() => {\n        const textarea = document.querySelector('textarea');\n        return textarea.value.substring(\n          textarea.selectionStart,\n          textarea.selectionEnd\n        );\n      })\n    ).toBe(text);\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click offscreen buttons","suites":["Page.click"],"updatePoint":{"line":134,"column":36},"line":134,"code":"  it('should click offscreen buttons', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/offscreenbuttons.html');\n    const messages = [];\n    page.on('console', (msg) => messages.push(msg.text()));\n    for (let i = 0; i < 11; ++i) {\n      // We might've scrolled to click a button - reset to (0, 0).\n      await page.evaluate(() => window.scrollTo(0, 0));\n      await page.click(`#btn${i}`);\n    }\n    expect(messages).toEqual([\n      'button #0 clicked',\n      'button #1 clicked',\n      'button #2 clicked',\n      'button #3 clicked',\n      'button #4 clicked',\n      'button #5 clicked',\n      'button #6 clicked',\n      'button #7 clicked',\n      'button #8 clicked',\n      'button #9 clicked',\n      'button #10 clicked',\n    ]);\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click wrapped links","suites":["Page.click"],"updatePoint":{"line":160,"column":32},"line":160,"code":"  it('should click wrapped links', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/wrappedlink.html');\n    await page.click('a');\n    expect(await page.evaluate(() => globalThis.__clicked)).toBe(true);\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click on checkbox input and toggle","suites":["Page.click"],"updatePoint":{"line":168,"column":47},"line":168,"code":"  it('should click on checkbox input and toggle', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/checkbox.html');\n    expect(await page.evaluate(() => globalThis.result.check)).toBe(null);\n    await page.click('input#agree');\n    expect(await page.evaluate(() => globalThis.result.check)).toBe(true);\n    expect(await page.evaluate(() => globalThis.result.events)).toEqual([\n      'mouseover',\n      'mouseenter',\n      'mousemove',\n      'mousedown',\n      'mouseup',\n      'click',\n      'input',\n      'change',\n    ]);\n    await page.click('input#agree');\n    expect(await page.evaluate(() => globalThis.result.check)).toBe(false);\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should fail to click a missing button","suites":["Page.click"],"updatePoint":{"line":205,"column":43},"line":205,"code":"  it('should fail to click a missing button', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    let error = null;\n    await page\n      .click('button.does-not-exist')\n      .catch((error_) => (error = error_));\n    expect(error.message).toBe(\n      'No node found for selector: button.does-not-exist'\n    );\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should not hang with touch-enabled viewports","suites":["Page.click"],"updatePoint":{"line":218,"column":50},"line":218,"code":"  it('should not hang with touch-enabled viewports', async () => {\n    const { page, puppeteer } = getTestState();\n\n    await page.setViewport(puppeteer.devices['iPhone 6'].viewport);\n    await page.mouse.down();\n    await page.mouse.move(100, 10);\n    await page.mouse.up();\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should scroll and click the button","suites":["Page.click"],"updatePoint":{"line":226,"column":40},"line":226,"code":"  it('should scroll and click the button', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.click('#button-5');\n    expect(\n      await page.evaluate(() => document.querySelector('#button-5').textContent)\n    ).toBe('clicked');\n    await page.click('#button-80');\n    expect(\n      await page.evaluate(\n        () => document.querySelector('#button-80').textContent\n      )\n    ).toBe('clicked');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should double click the button","suites":["Page.click"],"updatePoint":{"line":241,"column":36},"line":241,"code":"  it('should double click the button', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.evaluate(() => {\n      globalThis.double = false;\n      const button = document.querySelector('button');\n      button.addEventListener('dblclick', () => {\n        globalThis.double = true;\n      });\n    });\n    const button = await page.$('button');\n    await button.click({ clickCount: 2 });\n    expect(await page.evaluate('double')).toBe(true);\n    expect(await page.evaluate('result')).toBe('Clicked');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click a partially obscured button","suites":["Page.click"],"updatePoint":{"line":257,"column":46},"line":257,"code":"  it('should click a partially obscured button', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.evaluate(() => {\n      const button = document.querySelector('button');\n      button.textContent = 'Some really long text that will go offscreen';\n      button.style.position = 'absolute';\n      button.style.left = '368px';\n    });\n    await page.click('button');\n    expect(await page.evaluate(() => globalThis.result)).toBe('Clicked');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click a rotated button","suites":["Page.click"],"updatePoint":{"line":270,"column":35},"line":270,"code":"  it('should click a rotated button', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/rotatedButton.html');\n    await page.click('button');\n    expect(await page.evaluate(() => globalThis.result)).toBe('Clicked');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should fire contextmenu event on right click","suites":["Page.click"],"updatePoint":{"line":277,"column":50},"line":277,"code":"  it('should fire contextmenu event on right click', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.click('#button-8', { button: 'right' });\n    expect(\n      await page.evaluate(() => document.querySelector('#button-8').textContent)\n    ).toBe('context menu');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click links which cause navigation","suites":["Page.click"],"updatePoint":{"line":287,"column":47},"line":287,"code":"  it('should click links which cause navigation', async () => {\n    const { page, server } = getTestState();\n\n    await page.setContent(`<a href=\"${server.EMPTY_PAGE}\">empty.html</a>`);\n    // This await should not hang.\n    await page.click('a');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button inside an iframe","suites":["Page.click"],"updatePoint":{"line":294,"column":46},"line":294,"code":"  it('should click the button inside an iframe', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.setContent('<div style=\"width:100px;height:100px\">spacer</div>');\n    await utils.attachFrame(\n      page,\n      'button-test',\n      server.PREFIX + '/input/button.html'\n    );\n    const frame = page.frames()[1];\n    const button = await frame.$('button');\n    await button.click();\n    expect(await frame.evaluate(() => globalThis.result)).toBe('Clicked');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button with fixed position inside an iframe","suites":["Page.click"],"updatePoint":{"line":310,"column":67},"line":310,"code":"  xit('should click the button with fixed position inside an iframe', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.setViewport({ width: 500, height: 500 });\n    await page.setContent(\n      '<div style=\"width:100px;height:2000px\">spacer</div>'\n    );\n    await utils.attachFrame(\n      page,\n      'button-test',\n      server.CROSS_PROCESS_PREFIX + '/input/button.html'\n    );\n    const frame = page.frames()[1];\n    await frame.$eval('button', (button: HTMLElement) =>\n      button.style.setProperty('position', 'fixed')\n    );\n    await frame.click('button');\n    expect(await frame.evaluate(() => globalThis.result)).toBe('Clicked');\n  });","skipped":true,"file":"click.spec.ts","dir":"test"},{"name":"should click the button with deviceScaleFactor set","suites":["Page.click"],"updatePoint":{"line":330,"column":56},"line":330,"code":"  it('should click the button with deviceScaleFactor set', async () => {\n    const { page, server } = getTestState();\n\n    await page.setViewport({ width: 400, height: 400, deviceScaleFactor: 5 });\n    expect(await page.evaluate(() => window.devicePixelRatio)).toBe(5);\n    await page.setContent('<div style=\"width:100px;height:100px\">spacer</div>');\n    await utils.attachFrame(\n      page,\n      'button-test',\n      server.PREFIX + '/input/button.html'\n    );\n    const frame = page.frames()[1];\n    const button = await frame.$('button');\n    await button.click();\n    expect(await frame.evaluate(() => globalThis.result)).toBe('Clicked');\n  });","file":"click.spec.ts","skipped":false,"dir":"test"},{"name":"should return no cookies in pristine browser context","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":30,"column":60},"line":30,"code":"    it('should return no cookies in pristine browser context', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      expectCookieEquals(await page.cookies(), []);\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should get a cookie","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":35,"column":27},"line":35,"code":"    it('should get a cookie', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        document.cookie = 'username=John Doe';\n      });\n\n      expectCookieEquals(await page.cookies(), [\n        {\n          name: 'username',\n          value: 'John Doe',\n          domain: 'localhost',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 16,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourcePort: 8907,\n          sourceScheme: 'NonSecure',\n        },\n      ]);\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should properly report httpOnly cookie","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":59,"column":46},"line":59,"code":"    it('should properly report httpOnly cookie', async () => {\n      const { page, server } = getTestState();\n      server.setRoute('/empty.html', (req, res) => {\n        res.setHeader('Set-Cookie', 'a=b; HttpOnly; Path=/');\n        res.end();\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const cookies = await page.cookies();\n      expect(cookies.length).toBe(1);\n      expect(cookies[0].httpOnly).toBe(true);\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should properly report \"Strict\" sameSite cookie","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":70,"column":55},"line":70,"code":"    it('should properly report \"Strict\" sameSite cookie', async () => {\n      const { page, server } = getTestState();\n      server.setRoute('/empty.html', (req, res) => {\n        res.setHeader('Set-Cookie', 'a=b; SameSite=Strict');\n        res.end();\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const cookies = await page.cookies();\n      expect(cookies.length).toBe(1);\n      expect(cookies[0].sameSite).toBe('Strict');\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should properly report \"Lax\" sameSite cookie","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":81,"column":52},"line":81,"code":"    it('should properly report \"Lax\" sameSite cookie', async () => {\n      const { page, server } = getTestState();\n      server.setRoute('/empty.html', (req, res) => {\n        res.setHeader('Set-Cookie', 'a=b; SameSite=Lax');\n        res.end();\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const cookies = await page.cookies();\n      expect(cookies.length).toBe(1);\n      expect(cookies[0].sameSite).toBe('Lax');\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should get multiple cookies","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":92,"column":35},"line":92,"code":"    it('should get multiple cookies', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        document.cookie = 'username=John Doe';\n        document.cookie = 'password=1234';\n      });\n      const cookies = await page.cookies();\n      cookies.sort((a, b) => a.name.localeCompare(b.name));\n      expectCookieEquals(cookies, [\n        {\n          name: 'password',\n          value: '1234',\n          domain: 'localhost',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 12,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourcePort: 8907,\n          sourceScheme: 'NonSecure',\n        },\n        {\n          name: 'username',\n          value: 'John Doe',\n          domain: 'localhost',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 16,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourcePort: 8907,\n          sourceScheme: 'NonSecure',\n        },\n      ]);\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should have |expires| set to |-1| for session cookies","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":241,"column":61},"line":241,"code":"    it('should have |expires| set to |-1| for session cookies', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({\n        name: 'password',\n        value: '123456',\n      });\n      const cookies = await page.cookies();\n      expect(cookies[0].session).toBe(true);\n      expect(cookies[0].expires).toBe(-1);\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should not set a cookie on a blank page","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":314,"column":47},"line":314,"code":"    it('should not set a cookie on a blank page', async () => {\n      const { page } = getTestState();\n\n      await page.goto('about:blank');\n      let error = null;\n      try {\n        await page.setCookie({ name: 'example-cookie', value: 'best' });\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toContain(\n        'At least one of the url and domain needs to be specified'\n      );\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should not set a cookie with blank page URL","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":328,"column":51},"line":328,"code":"    it('should not set a cookie with blank page URL', async () => {\n      const { page, server } = getTestState();\n\n      let error = null;\n      await page.goto(server.EMPTY_PAGE);\n      try {\n        await page.setCookie(\n          { name: 'example-cookie', value: 'best' },\n          { url: 'about:blank', name: 'example-cookie-blank', value: 'best' }\n        );\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toEqual(\n        `Blank page can not have cookie \"example-cookie-blank\"`\n      );\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should not set a cookie on a data URL page","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":345,"column":50},"line":345,"code":"    it('should not set a cookie on a data URL page', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page.goto('data:,Hello%2C%20World!');\n      try {\n        await page.setCookie({ name: 'example-cookie', value: 'best' });\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toContain(\n        'At least one of the url and domain needs to be specified'\n      );\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to set unsecure cookie for HTTP website","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":375,"column":62},"line":375,"code":"    it('should be able to set unsecure cookie for HTTP website', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const HTTP_URL = 'http://example.com';\n      await page.setCookie({\n        url: HTTP_URL,\n        name: 'foo',\n        value: 'bar',\n      });\n      const [cookie] = await page.cookies(HTTP_URL);\n      expect(cookie.secure).toBe(false);\n    });","file":"cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Coverage specs"],"updatePoint":{"line":30,"column":19},"line":30,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/simple.html', {\n        waitUntil: 'networkidle0',\n      });\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0].url).toContain('/jscoverage/simple.html');\n      expect(coverage[0].ranges).toEqual([\n        { start: 0, end: 17 },\n        { start: 35, end: 61 },\n      ]);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report sourceURLs","suites":["Coverage specs"],"updatePoint":{"line":44,"column":32},"line":44,"code":"    it('should report sourceURLs', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/sourceurl.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0].url).toBe('nicename.js');\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore eval() scripts by default","suites":["Coverage specs"],"updatePoint":{"line":53,"column":47},"line":53,"code":"    it('should ignore eval() scripts by default', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/eval.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't ignore eval() scripts if reportAnonymousScripts is true","suites":["Coverage specs"],"updatePoint":{"line":61,"column":73},"line":61,"code":"    it(\"shouldn't ignore eval() scripts if reportAnonymousScripts is true\", async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage({ reportAnonymousScripts: true });\n      await page.goto(server.PREFIX + '/jscoverage/eval.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(\n        coverage.find((entry) => entry.url.startsWith('debugger://'))\n      ).not.toBe(null);\n      expect(coverage.length).toBe(2);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore pptr internal scripts if reportAnonymousScripts is true","suites":["Coverage specs"],"updatePoint":{"line":72,"column":77},"line":72,"code":"    it('should ignore pptr internal scripts if reportAnonymousScripts is true', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage({ reportAnonymousScripts: true });\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate('console.log(\"foo\")');\n      await page.evaluate(() => console.log('bar'));\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(0);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report multiple scripts","suites":["Coverage specs"],"updatePoint":{"line":82,"column":38},"line":82,"code":"    it('should report multiple scripts', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/multiple.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(2);\n      coverage.sort((a, b) => a.url.localeCompare(b.url));\n      expect(coverage[0].url).toContain('/jscoverage/script1.js');\n      expect(coverage[1].url).toContain('/jscoverage/script2.js');\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report right ranges","suites":["Coverage specs"],"updatePoint":{"line":93,"column":34},"line":93,"code":"    it('should report right ranges', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/ranges.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      const entry = coverage[0];\n      expect(entry.ranges.length).toBe(1);\n      const range = entry.ranges[0];\n      expect(entry.text.substring(range.start, range.end)).toBe(\n        `console.log('used!');`\n      );\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report scripts that have no coverage","suites":["Coverage specs"],"updatePoint":{"line":107,"column":51},"line":107,"code":"    it('should report scripts that have no coverage', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/unused.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      const entry = coverage[0];\n      expect(entry.url).toContain('unused.html');\n      expect(entry.ranges.length).toBe(0);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with conditionals","suites":["Coverage specs"],"updatePoint":{"line":118,"column":37},"line":118,"code":"    it('should work with conditionals', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/involved.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(\n        JSON.stringify(coverage, null, 2).replace(/:\\d{4}\\//g, ':<PORT>/')\n      ).toBeGolden('jscoverage-involved.txt');\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should not hang when there is a debugger statement","suites":["Coverage specs"],"updatePoint":{"line":129,"column":59},"line":129,"code":"    xit('should not hang when there is a debugger statement', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        debugger; // eslint-disable-line no-debugger\n      });\n      await page.coverage.stopJSCoverage();\n    });","skipped":true,"file":"coverage.spec.ts","dir":"test"},{"name":"should report scripts across navigations when disabled","suites":["Coverage specs","resetOnNavigation"],"updatePoint":{"line":140,"column":64},"line":140,"code":"      it('should report scripts across navigations when disabled', async () => {\n        const { page, server } = getTestState();\n\n        await page.coverage.startJSCoverage({ resetOnNavigation: false });\n        await page.goto(server.PREFIX + '/jscoverage/multiple.html');\n        await page.goto(server.EMPTY_PAGE);\n        const coverage = await page.coverage.stopJSCoverage();\n        expect(coverage.length).toBe(2);\n      });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should NOT report scripts across navigations when enabled","suites":["Coverage specs","resetOnNavigation"],"updatePoint":{"line":150,"column":67},"line":150,"code":"      it('should NOT report scripts across navigations when enabled', async () => {\n        const { page, server } = getTestState();\n\n        await page.coverage.startJSCoverage(); // Enabled by default.\n        await page.goto(server.PREFIX + '/jscoverage/multiple.html');\n        await page.goto(server.EMPTY_PAGE);\n        const coverage = await page.coverage.stopJSCoverage();\n        expect(coverage.length).toBe(0);\n      });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should not include rawScriptCoverage field when disabled","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":161,"column":66},"line":161,"code":"      it('should not include rawScriptCoverage field when disabled', async () => {\n        const { page, server } = getTestState();\n        await page.coverage.startJSCoverage();\n        await page.goto(server.PREFIX + '/jscoverage/simple.html', {\n          waitUntil: 'networkidle0',\n        });\n        const coverage = await page.coverage.stopJSCoverage();\n        expect(coverage.length).toBe(1);\n        expect(coverage[0].rawScriptCoverage).toBeUndefined();\n      });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should include rawScriptCoverage field when enabled","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":171,"column":61},"line":171,"code":"      it('should include rawScriptCoverage field when enabled', async () => {\n        const { page, server } = getTestState();\n        await page.coverage.startJSCoverage({\n          includeRawScriptCoverage: true,\n        });\n        await page.goto(server.PREFIX + '/jscoverage/simple.html', {\n          waitUntil: 'networkidle0',\n        });\n        const coverage = await page.coverage.stopJSCoverage();\n        expect(coverage.length).toBe(1);\n        expect(coverage[0].rawScriptCoverage).toBeTruthy();\n      });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should not hang when there is a debugger statement","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":185,"column":59},"line":185,"code":"    xit('should not hang when there is a debugger statement', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        debugger; // eslint-disable-line no-debugger\n      });\n      await page.coverage.stopJSCoverage();\n    });","skipped":true,"file":"coverage.spec.ts","dir":"test"},{"name":"should work","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":201,"column":19},"line":201,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/simple.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0].url).toContain('/csscoverage/simple.html');\n      expect(coverage[0].ranges).toEqual([{ start: 1, end: 22 }]);\n      const range = coverage[0].ranges[0];\n      expect(coverage[0].text.substring(range.start, range.end)).toBe(\n        'div { color: green; }'\n      );\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report sourceURLs","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":215,"column":32},"line":215,"code":"    it('should report sourceURLs', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/sourceurl.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0].url).toBe('nicename.css');\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report multiple stylesheets","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":224,"column":42},"line":224,"code":"    it('should report multiple stylesheets', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/multiple.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(2);\n      coverage.sort((a, b) => a.url.localeCompare(b.url));\n      expect(coverage[0].url).toContain('/csscoverage/stylesheet1.css');\n      expect(coverage[1].url).toContain('/csscoverage/stylesheet2.css');\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report stylesheets that have no coverage","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":235,"column":55},"line":235,"code":"    it('should report stylesheets that have no coverage', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/unused.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0].url).toBe('unused.css');\n      expect(coverage[0].ranges.length).toBe(0);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with media queries","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":245,"column":38},"line":245,"code":"    it('should work with media queries', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/media.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0].url).toContain('/csscoverage/media.html');\n      expect(coverage[0].ranges).toEqual([{ start: 17, end: 38 }]);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with complicated usecases","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":255,"column":45},"line":255,"code":"    it('should work with complicated usecases', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/involved.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(\n        JSON.stringify(coverage, null, 2).replace(/:\\d{4}\\//g, ':<PORT>/')\n      ).toBeGolden('csscoverage-involved.txt');\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore injected stylesheets","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":265,"column":42},"line":265,"code":"    it('should ignore injected stylesheets', async () => {\n      const { page } = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.addStyleTag({ content: 'body { margin: 10px;}' });\n      // trigger style recalc\n      const margin = await page.evaluate(\n        () => window.getComputedStyle(document.body).margin\n      );\n      expect(margin).toBe('10px');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(0);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a recently loaded stylesheet","suites":["Coverage specs","includeRawScriptCoverage"],"updatePoint":{"line":278,"column":53},"line":278,"code":"    it('should work with a recently loaded stylesheet', async () => {\n      const { page, server } = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.evaluate<(url: string) => Promise<void>>(async (url) => {\n        document.body.textContent = 'hello, world';\n\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = url;\n        document.head.appendChild(link);\n        await new Promise((x) => (link.onload = x));\n      }, server.PREFIX + '/csscoverage/stylesheet1.css');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n    });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report stylesheets across navigations","suites":["Coverage specs","resetOnNavigation"],"updatePoint":{"line":295,"column":54},"line":295,"code":"      it('should report stylesheets across navigations', async () => {\n        const { page, server } = getTestState();\n\n        await page.coverage.startCSSCoverage({ resetOnNavigation: false });\n        await page.goto(server.PREFIX + '/csscoverage/multiple.html');\n        await page.goto(server.EMPTY_PAGE);\n        const coverage = await page.coverage.stopCSSCoverage();\n        expect(coverage.length).toBe(2);\n      });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should NOT report scripts across navigations","suites":["Coverage specs","resetOnNavigation"],"updatePoint":{"line":304,"column":54},"line":304,"code":"      it('should NOT report scripts across navigations', async () => {\n        const { page, server } = getTestState();\n\n        await page.coverage.startCSSCoverage(); // Enabled by default.\n        await page.goto(server.PREFIX + '/csscoverage/multiple.html');\n        await page.goto(server.EMPTY_PAGE);\n        const coverage = await page.coverage.stopCSSCoverage();\n        expect(coverage.length).toBe(0);\n      });","file":"coverage.spec.ts","skipped":false,"dir":"test"},{"name":"page.cookies() should work","suites":["DefaultBrowserContext"],"updatePoint":{"line":28,"column":32},"line":28,"code":"  it('page.cookies() should work', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.evaluate(() => {\n      document.cookie = 'username=John Doe';\n    });\n    expectCookieEquals(await page.cookies(), [\n      {\n        name: 'username',\n        value: 'John Doe',\n        domain: 'localhost',\n        path: '/',\n        sameParty: false,\n        expires: -1,\n        size: 16,\n        httpOnly: false,\n        secure: false,\n        session: true,\n        sourcePort: 8907,\n        sourceScheme: 'NonSecure',\n      },\n    ]);\n  });","file":"defaultbrowsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should fire","suites":["Page.Events.Dialog"],"updatePoint":{"line":30,"column":17},"line":30,"code":"  it('should fire', async () => {\n    const { page } = getTestState();\n\n    const onDialog = sinon.stub().callsFake((dialog) => {\n      dialog.accept();\n    });\n    page.on('dialog', onDialog);\n\n    await page.evaluate(() => alert('yo'));\n\n    expect(onDialog.callCount).toEqual(1);\n    const dialog = onDialog.firstCall.args[0];\n    expect(dialog.type()).toBe('alert');\n    expect(dialog.defaultValue()).toBe('');\n    expect(dialog.message()).toBe('yo');\n  });","file":"dialog.spec.ts","skipped":false,"dir":"test"},{"name":"should dismiss the prompt","suites":["Page.Events.Dialog"],"updatePoint":{"line":65,"column":31},"line":65,"code":"  it('should dismiss the prompt', async () => {\n    const { page } = getTestState();\n\n    page.on('dialog', (dialog) => {\n      dialog.dismiss();\n    });\n    const result = await page.evaluate(() => prompt('question?'));\n    expect(result).toBe(null);\n  });","file":"dialog.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an exception if not enabled before usage","suites":[],"updatePoint":{"line":28,"column":59},"line":28,"code":"  it('should throw an exception if not enabled before usage', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    const draggable = await page.$('#drag');\n\n    try {\n      await draggable.drag({ x: 1, y: 1 });\n    } catch (error) {\n      expect(error.message).toContain('Drag Interception is not enabled!');\n    }\n  });","file":"drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"should emit a dragIntercepted event when dragged","suites":[],"updatePoint":{"line":40,"column":54},"line":40,"code":"  it('should emit a dragIntercepted event when dragged', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = await page.$('#drag');\n    const data = await draggable.drag({ x: 1, y: 1 });\n\n    expect(data.items.length).toBe(1);\n    expect(await page.evaluate(() => globalThis.didDragStart)).toBe(true);\n  });","file":"drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"should emit a dragEnter","suites":[],"updatePoint":{"line":53,"column":29},"line":53,"code":"  it('should emit a dragEnter', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = await page.$('#drag');\n    const data = await draggable.drag({ x: 1, y: 1 });\n    const dropzone = await page.$('#drop');\n    await dropzone.dragEnter(data);\n\n    expect(await page.evaluate(() => globalThis.didDragStart)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDragEnter)).toBe(true);\n  });","file":"drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"should emit a dragOver event","suites":[],"updatePoint":{"line":68,"column":34},"line":68,"code":"  it('should emit a dragOver event', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = await page.$('#drag');\n    const data = await draggable.drag({ x: 1, y: 1 });\n    const dropzone = await page.$('#drop');\n    await dropzone.dragEnter(data);\n    await dropzone.dragOver(data);\n\n    expect(await page.evaluate(() => globalThis.didDragStart)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDragEnter)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDragOver)).toBe(true);\n  });","file":"drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"can be dropped","suites":[],"updatePoint":{"line":85,"column":20},"line":85,"code":"  it('can be dropped', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = await page.$('#drag');\n    const dropzone = await page.$('#drop');\n    const data = await draggable.drag({ x: 1, y: 1 });\n    await dropzone.dragEnter(data);\n    await dropzone.dragOver(data);\n    await dropzone.drop(data);\n\n    expect(await page.evaluate(() => globalThis.didDragStart)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDragEnter)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDragOver)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDrop)).toBe(true);\n  });","file":"drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"can be dragged and dropped with a single function","suites":[],"updatePoint":{"line":104,"column":55},"line":104,"code":"  it('can be dragged and dropped with a single function', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = await page.$('#drag');\n    const dropzone = await page.$('#drop');\n    await draggable.dragAndDrop(dropzone);\n\n    expect(await page.evaluate(() => globalThis.didDragStart)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDragEnter)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDragOver)).toBe(true);\n    expect(await page.evaluate(() => globalThis.didDrop)).toBe(true);\n  });","file":"drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"can be disabled","suites":[],"updatePoint":{"line":120,"column":21},"line":120,"code":"  it('can be disabled', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = await page.$('#drag');\n    await draggable.drag({ x: 1, y: 1 });\n    await page.setDragInterception(false);\n\n    try {\n      await draggable.drag({ x: 1, y: 1 });\n    } catch (error) {\n      expect(error.message).toContain('Drag Interception is not enabled!');\n    }\n  });","file":"drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs"],"updatePoint":{"line":35,"column":19},"line":35,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setViewport({ width: 500, height: 500 });\n      await page.goto(server.PREFIX + '/grid.html');\n      const elementHandle = await page.$('.box:nth-of-type(13)');\n      const box = await elementHandle.boundingBox();\n      expect(box).toEqual({ x: 100, y: 50, width: 50, height: 50 });\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should handle nested frames","suites":["ElementHandle specs"],"updatePoint":{"line":44,"column":35},"line":44,"code":"    it('should handle nested frames', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      await page.setViewport({ width: 500, height: 500 });\n      await page.goto(server.PREFIX + '/frames/nested-frames.html');\n      const nestedFrame = page.frames()[1].childFrames()[1];\n      const elementHandle = await nestedFrame.$('div');\n      const box = await elementHandle.boundingBox();\n      if (isChrome)\n        expect(box).toEqual({ x: 28, y: 182, width: 264, height: 18 });\n      else expect(box).toEqual({ x: 28, y: 182, width: 254, height: 18 });\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for invisible elements","suites":["ElementHandle specs"],"updatePoint":{"line":56,"column":49},"line":56,"code":"    it('should return null for invisible elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div style=\"display:none\">hi</div>');\n      const element = await page.$('div');\n      expect(await element.boundingBox()).toBe(null);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should force a layout","suites":["ElementHandle specs"],"updatePoint":{"line":63,"column":29},"line":63,"code":"    it('should force a layout', async () => {\n      const { page } = getTestState();\n\n      await page.setViewport({ width: 500, height: 500 });\n      await page.setContent(\n        '<div style=\"width: 100px; height: 100px\">hello</div>'\n      );\n      const elementHandle = await page.$('div');\n      await page.evaluate<(element: HTMLElement) => void>(\n        (element) => (element.style.height = '200px'),\n        elementHandle\n      );\n      const box = await elementHandle.boundingBox();\n      expect(box).toEqual({ x: 8, y: 8, width: 100, height: 200 });\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work with SVG nodes","suites":["ElementHandle specs"],"updatePoint":{"line":78,"column":34},"line":78,"code":"    it('should work with SVG nodes', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"500\" height=\"500\">\n          <rect id=\"theRect\" x=\"30\" y=\"50\" width=\"200\" height=\"300\"></rect>\n        </svg>\n      `);\n      const element = await page.$('#therect');\n      const pptrBoundingBox = await element.boundingBox();\n      const webBoundingBox = await page.evaluate((e: HTMLElement) => {\n        const rect = e.getBoundingClientRect();\n        return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };\n      }, element);\n      expect(pptrBoundingBox).toEqual(webBoundingBox);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs"],"updatePoint":{"line":97,"column":19},"line":97,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/resetcss.html');\n\n      // Step 1: Add Frame and position it absolutely.\n      await utils.attachFrame(page, 'frame1', server.PREFIX + '/resetcss.html');\n      await page.evaluate(() => {\n        const frame = document.querySelector<HTMLElement>('#frame1');\n        frame.style.position = 'absolute';\n        frame.style.left = '1px';\n        frame.style.top = '2px';\n      });\n\n      // Step 2: Add div and position it absolutely inside frame.\n      const frame = page.frames()[1];\n      const divHandle = (\n        await frame.evaluateHandle(() => {\n          const div = document.createElement('div');\n          document.body.appendChild(div);\n          div.style.boxSizing = 'border-box';\n          div.style.position = 'absolute';\n          div.style.borderLeft = '1px solid black';\n          div.style.paddingLeft = '2px';\n          div.style.marginLeft = '3px';\n          div.style.left = '4px';\n          div.style.top = '5px';\n          div.style.width = '6px';\n          div.style.height = '7px';\n          return div;\n        })\n      ).asElement();\n\n      // Step 3: query div's boxModel and assert box values.\n      const box = await divHandle.boxModel();\n      expect(box.width).toBe(6);\n      expect(box.height).toBe(7);\n      expect(box.margin[0]).toEqual({\n        x: 1 + 4, // frame.left + div.left\n        y: 2 + 5,\n      });\n      expect(box.border[0]).toEqual({\n        x: 1 + 4 + 3, // frame.left + div.left + div.margin-left\n        y: 2 + 5,\n      });\n      expect(box.padding[0]).toEqual({\n        x: 1 + 4 + 3 + 1, // frame.left + div.left + div.marginLeft + div.borderLeft\n        y: 2 + 5,\n      });\n      expect(box.content[0]).toEqual({\n        x: 1 + 4 + 3 + 1 + 2, // frame.left + div.left + div.marginLeft + div.borderLeft + dif.paddingLeft\n        y: 2 + 5,\n      });\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for invisible elements","suites":["ElementHandle specs"],"updatePoint":{"line":152,"column":49},"line":152,"code":"    it('should return null for invisible elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div style=\"display:none\">hi</div>');\n      const element = await page.$('div');\n      expect(await element.boxModel()).toBe(null);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for Shadow DOM v1","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":183,"column":37},"line":183,"code":"    it('should work for Shadow DOM v1', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/shadow.html');\n      const buttonHandle = await page.evaluateHandle<ElementHandle>(\n        // @ts-expect-error button is expected to be in the page's scope.\n        () => button\n      );\n      await buttonHandle.click();\n      expect(\n        await page.evaluate(\n          // @ts-expect-error clicked is expected to be in the page's scope.\n          () => clicked\n        )\n      ).toBe(true);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for TextNodes","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":199,"column":33},"line":199,"code":"    it('should work for TextNodes', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const buttonTextNode = await page.evaluateHandle<ElementHandle>(\n        () => document.querySelector('button').firstChild\n      );\n      let error = null;\n      await buttonTextNode.click().catch((error_) => (error = error_));\n      expect(error.message).toBe('Node is not of type HTMLElement');\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for detached nodes","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":210,"column":39},"line":210,"code":"    it('should throw for detached nodes', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const button = await page.$('button');\n      await page.evaluate((button: HTMLElement) => button.remove(), button);\n      let error = null;\n      await button.click().catch((error_) => (error = error_));\n      expect(error.message).toBe('Node is detached from document');\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for hidden nodes","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":220,"column":37},"line":220,"code":"    it('should throw for hidden nodes', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const button = await page.$('button');\n      await page.evaluate(\n        (button: HTMLElement) => (button.style.display = 'none'),\n        button\n      );\n      const error = await button.click().catch((error_) => error_);\n      expect(error.message).toBe(\n        'Node is either not clickable or not an HTMLElement'\n      );\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for recursively hidden nodes","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":234,"column":49},"line":234,"code":"    it('should throw for recursively hidden nodes', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const button = await page.$('button');\n      await page.evaluate(\n        (button: HTMLElement) => (button.parentElement.style.display = 'none'),\n        button\n      );\n      const error = await button.click().catch((error_) => error_);\n      expect(error.message).toBe(\n        'Node is either not clickable or not an HTMLElement'\n      );\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for <br> elements","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":248,"column":38},"line":248,"code":"    it('should throw for <br> elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('hello<br>goodbye');\n      const br = await page.$('br');\n      const error = await br.click().catch((error_) => error_);\n      expect(error.message).toBe(\n        'Node is either not clickable or not an HTMLElement'\n      );\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitForSelector on an element","suites":["ElementHandle specs","Element.waitForSelector"],"updatePoint":{"line":261,"column":64},"line":261,"code":"    it('should wait correctly with waitForSelector on an element', async () => {\n      const { page } = getTestState();\n      const waitFor = page.waitForSelector('.foo');\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"bar\">bar2</div><div class=\"foo\">Foo1</div>'\n      );\n      let element = await waitFor;\n      expect(element).toBeDefined();\n\n      const innerWaitFor = element.waitForSelector('.bar');\n      await element.evaluate((el) => {\n        el.innerHTML = '<div class=\"bar\">bar1</div>';\n      });\n      element = await innerWaitFor;\n      expect(element).toBeDefined();\n      expect(\n        await element.evaluate((el: HTMLElement) => el.innerText)\n      ).toStrictEqual('bar1');\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","ElementHandle.hover"],"updatePoint":{"line":284,"column":19},"line":284,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/scrollable.html');\n      const button = await page.$('#button-6');\n      await button.hover();\n      expect(\n        await page.evaluate(() => document.querySelector('button:hover').id)\n      ).toBe('button-6');\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","ElementHandle.isIntersectingViewport"],"updatePoint":{"line":297,"column":19},"line":297,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/offscreenbuttons.html');\n      for (let i = 0; i < 11; ++i) {\n        const button = await page.$('#btn' + i);\n        // All but last button are visible.\n        const visible = i < 10;\n        expect(await button.isIntersectingViewport()).toBe(visible);\n      }\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work with threshold","suites":["ElementHandle specs","ElementHandle.isIntersectingViewport"],"updatePoint":{"line":308,"column":34},"line":308,"code":"    it('should work with threshold', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/offscreenbuttons.html');\n      // a button almost cannot be seen\n      // sometimes we expect to return false by isIntersectingViewport1\n      const button = await page.$('#btn11');\n      expect(\n        await button.isIntersectingViewport({\n          threshold: 0.001,\n        })\n      ).toBe(false);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work with threshold of 1","suites":["ElementHandle specs","ElementHandle.isIntersectingViewport"],"updatePoint":{"line":321,"column":39},"line":321,"code":"    it('should work with threshold of 1', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/offscreenbuttons.html');\n      // a button almost cannot be seen\n      // sometimes we expect to return false by isIntersectingViewport1\n      const button = await page.$('#btn0');\n      expect(\n        await button.isIntersectingViewport({\n          threshold: 1,\n        })\n      ).toBe(true);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should register and unregister","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":341,"column":38},"line":341,"code":"    it('should register and unregister', async () => {\n      const { page, puppeteer } = getTestState();\n      await page.setContent('<div id=\"not-foo\"></div><div id=\"foo\"></div>');\n\n      // Register.\n      puppeteer.registerCustomQueryHandler('getById', {\n        queryOne: (element, selector) =>\n          document.querySelector(`[id=\"${selector}\"]`),\n      });\n      const element = await page.$('getById/foo');\n      expect(\n        await page.evaluate<(element: HTMLElement) => string>(\n          (element) => element.id,\n          element\n        )\n      ).toBe('foo');\n      const handlerNamesAfterRegistering = puppeteer.customQueryHandlerNames();\n      expect(handlerNamesAfterRegistering.includes('getById')).toBeTruthy();\n\n      // Unregister.\n      puppeteer.unregisterCustomQueryHandler('getById');\n      try {\n        await page.$('getById/foo');\n        throw new Error('Custom query handler name not set - throw expected');\n      } catch (error) {\n        expect(error).toStrictEqual(\n          new Error(\n            'Query set to use \"getById\", but no query handler of that name was found'\n          )\n        );\n      }\n      const handlerNamesAfterUnregistering =\n        puppeteer.customQueryHandlerNames();\n      expect(handlerNamesAfterUnregistering.includes('getById')).toBeFalsy();\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw with invalid query names","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":376,"column":45},"line":376,"code":"    it('should throw with invalid query names', () => {\n      try {\n        const { puppeteer } = getTestState();\n        puppeteer.registerCustomQueryHandler('1/2/3', {\n          queryOne: () => document.querySelector('foo'),\n        });\n        throw new Error(\n          'Custom query handler name was invalid - throw expected'\n        );\n      } catch (error) {\n        expect(error).toStrictEqual(\n          new Error('Custom query handler names may only contain [a-zA-Z]')\n        );\n      }\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for multiple elements","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":391,"column":41},"line":391,"code":"    it('should work for multiple elements', async () => {\n      const { page, puppeteer } = getTestState();\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">Foo1</div><div class=\"foo baz\">Foo2</div>'\n      );\n      puppeteer.registerCustomQueryHandler('getByClass', {\n        queryAll: (element, selector) =>\n          document.querySelectorAll(`.${selector}`),\n      });\n      const elements = await page.$$('getByClass/foo');\n      const classNames = await Promise.all(\n        elements.map(\n          async (element) =>\n            await page.evaluate<(element: HTMLElement) => string>(\n              (element) => element.className,\n              element\n            )\n        )\n      );\n\n      expect(classNames).toStrictEqual(['foo', 'foo baz']);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should eval correctly","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":413,"column":29},"line":413,"code":"    it('should eval correctly', async () => {\n      const { page, puppeteer } = getTestState();\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">Foo1</div><div class=\"foo baz\">Foo2</div>'\n      );\n      puppeteer.registerCustomQueryHandler('getByClass', {\n        queryAll: (element, selector) =>\n          document.querySelectorAll(`.${selector}`),\n      });\n      const elements = await page.$$eval(\n        'getByClass/foo',\n        (divs) => divs.length\n      );\n\n      expect(elements).toBe(2);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitForSelector","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":429,"column":50},"line":429,"code":"    it('should wait correctly with waitForSelector', async () => {\n      const { page, puppeteer } = getTestState();\n      puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => element.querySelector(`.${selector}`),\n      });\n      const waitFor = page.waitForSelector('getByClass/foo');\n\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">Foo1</div>'\n      );\n      const element = await waitFor;\n\n      expect(element).toBeDefined();\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitForSelector on an element","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":445,"column":64},"line":445,"code":"    it('should wait correctly with waitForSelector on an element', async () => {\n      const { page, puppeteer } = getTestState();\n      puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => element.querySelector(`.${selector}`),\n      });\n      const waitFor = page.waitForSelector('getByClass/foo');\n\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"bar\">bar2</div><div class=\"foo\">Foo1</div>'\n      );\n      let element = await waitFor;\n      expect(element).toBeDefined();\n\n      const innerWaitFor = element.waitForSelector('getByClass/bar');\n\n      await element.evaluate((el) => {\n        el.innerHTML = '<div class=\"bar\">bar1</div>';\n      });\n\n      element = await innerWaitFor;\n      expect(element).toBeDefined();\n      expect(\n        await element.evaluate((el: HTMLElement) => el.innerText)\n      ).toStrictEqual('bar1');\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitFor","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":472,"column":42},"line":472,"code":"    it('should wait correctly with waitFor', async () => {\n      /* page.waitFor is deprecated so we silence the warning to avoid test noise */\n      sinon.stub(console, 'warn').callsFake(() => {});\n      const { page, puppeteer } = getTestState();\n      puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => element.querySelector(`.${selector}`),\n      });\n      const waitFor = page.waitFor('getByClass/foo');\n\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">Foo1</div>'\n      );\n      const element = await waitFor;\n\n      expect(element).toBeDefined();\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work when both queryOne and queryAll are registered","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":489,"column":66},"line":489,"code":"    it('should work when both queryOne and queryAll are registered', async () => {\n      const { page, puppeteer } = getTestState();\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\"><div id=\"nested-foo\" class=\"foo\"/></div><div class=\"foo baz\">Foo2</div>'\n      );\n      puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => element.querySelector(`.${selector}`),\n        queryAll: (element, selector) =>\n          element.querySelectorAll(`.${selector}`),\n      });\n\n      const element = await page.$('getByClass/foo');\n      expect(element).toBeDefined();\n\n      const elements = await page.$$('getByClass/foo');\n      expect(elements.length).toBe(3);\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should eval when both queryOne and queryAll are registered","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":506,"column":66},"line":506,"code":"    it('should eval when both queryOne and queryAll are registered', async () => {\n      const { page, puppeteer } = getTestState();\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">text</div><div class=\"foo baz\">content</div>'\n      );\n      puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => element.querySelector(`.${selector}`),\n        queryAll: (element, selector) =>\n          element.querySelectorAll(`.${selector}`),\n      });\n\n      const txtContent = await page.$eval(\n        'getByClass/foo',\n        (div) => div.textContent\n      );\n      expect(txtContent).toBe('text');\n\n      const txtContents = await page.$$eval('getByClass/foo', (divs) =>\n        divs.map((d) => d.textContent).join('')\n      );\n      expect(txtContents).toBe('textcontent');\n    });","file":"elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should get the proper viewport size","suites":["Emulation","Page.viewport"],"updatePoint":{"line":39,"column":43},"line":39,"code":"    it('should get the proper viewport size', async () => {\n      const { page } = getTestState();\n\n      expect(page.viewport()).toEqual({ width: 800, height: 600 });\n      await page.setViewport({ width: 123, height: 456 });\n      expect(page.viewport()).toEqual({ width: 123, height: 456 });\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should support mobile emulation","suites":["Emulation","Page.viewport"],"updatePoint":{"line":46,"column":39},"line":46,"code":"    it('should support mobile emulation', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      expect(await page.evaluate(() => window.innerWidth)).toBe(800);\n      await page.setViewport(iPhone.viewport);\n      expect(await page.evaluate(() => window.innerWidth)).toBe(375);\n      await page.setViewport({ width: 400, height: 300 });\n      expect(await page.evaluate(() => window.innerWidth)).toBe(400);\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should support touch emulation","suites":["Emulation","Page.viewport"],"updatePoint":{"line":56,"column":38},"line":56,"code":"    it('should support touch emulation', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      expect(await page.evaluate(() => 'ontouchstart' in window)).toBe(false);\n      await page.setViewport(iPhone.viewport);\n      expect(await page.evaluate(() => 'ontouchstart' in window)).toBe(true);\n      expect(await page.evaluate(dispatchTouch)).toBe('Received touch');\n      await page.setViewport({ width: 100, height: 100 });\n      expect(await page.evaluate(() => 'ontouchstart' in window)).toBe(false);\n\n      function dispatchTouch() {\n        let fulfill;\n        const promise = new Promise((x) => (fulfill = x));\n        window.ontouchstart = () => {\n          fulfill('Received touch');\n        };\n        window.dispatchEvent(new Event('touchstart'));\n\n        fulfill('Did not receive touch');\n\n        return promise;\n      }\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should be detectable by Modernizr","suites":["Emulation","Page.viewport"],"updatePoint":{"line":80,"column":41},"line":80,"code":"    it('should be detectable by Modernizr', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/detect-touch.html');\n      expect(await page.evaluate(() => document.body.textContent.trim())).toBe(\n        'NO'\n      );\n      await page.setViewport(iPhone.viewport);\n      await page.goto(server.PREFIX + '/detect-touch.html');\n      expect(await page.evaluate(() => document.body.textContent.trim())).toBe(\n        'YES'\n      );\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should detect touch when applying viewport with touches","suites":["Emulation","Page.viewport"],"updatePoint":{"line":93,"column":63},"line":93,"code":"    it('should detect touch when applying viewport with touches', async () => {\n      const { page, server } = getTestState();\n\n      await page.setViewport({ width: 800, height: 600, hasTouch: true });\n      await page.addScriptTag({ url: server.PREFIX + '/modernizr.js' });\n      expect(await page.evaluate(() => globalThis.Modernizr.touchevents)).toBe(\n        true\n      );\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Emulation","Page.emulate"],"updatePoint":{"line":121,"column":19},"line":121,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      await page.emulate(iPhone);\n      expect(await page.evaluate(() => window.innerWidth)).toBe(375);\n      expect(await page.evaluate(() => navigator.userAgent)).toContain(\n        'iPhone'\n      );\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw in case of bad argument","suites":["Emulation","Page.emulateMediaType"],"updatePoint":{"line":169,"column":44},"line":169,"code":"    it('should throw in case of bad argument', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page.emulateMediaType('bad').catch((error_) => (error = error_));\n      expect(error.message).toBe('Unsupported media type: bad');\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw in case of bad argument","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":278,"column":44},"line":278,"code":"    it('should throw in case of bad argument', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page\n        .emulateMediaFeatures([{ name: 'bad', value: '' }])\n        .catch((error_) => (error = error_));\n      expect(error.message).toBe('Unsupported media feature: bad');\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":290,"column":19},"line":290,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.evaluate(() => {\n        globalThis.date = new Date(1479579154987);\n      });\n      await page.emulateTimezone('America/Jamaica');\n      expect(await page.evaluate(() => globalThis.date.toString())).toBe(\n        'Sat Nov 19 2016 13:12:34 GMT-0500 (Eastern Standard Time)'\n      );\n\n      await page.emulateTimezone('Pacific/Honolulu');\n      expect(await page.evaluate(() => globalThis.date.toString())).toBe(\n        'Sat Nov 19 2016 08:12:34 GMT-1000 (Hawaii-Aleutian Standard Time)'\n      );\n\n      await page.emulateTimezone('America/Buenos_Aires');\n      expect(await page.evaluate(() => globalThis.date.toString())).toBe(\n        'Sat Nov 19 2016 15:12:34 GMT-0300 (Argentina Standard Time)'\n      );\n\n      await page.emulateTimezone('Europe/Berlin');\n      expect(await page.evaluate(() => globalThis.date.toString())).toBe(\n        'Sat Nov 19 2016 19:12:34 GMT+0100 (Central European Standard Time)'\n      );\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for invalid timezone IDs","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":317,"column":45},"line":317,"code":"    it('should throw for invalid timezone IDs', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page.emulateTimezone('Foo/Bar').catch((error_) => (error = error_));\n      expect(error.message).toBe('Invalid timezone ID: Foo/Bar');\n      await page.emulateTimezone('Baz/Qux').catch((error_) => (error = error_));\n      expect(error.message).toBe('Invalid timezone ID: Baz/Qux');\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":329,"column":19},"line":329,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setViewport({ width: 500, height: 500 });\n      await page.goto(server.PREFIX + '/grid.html');\n\n      {\n        await page.emulateVisionDeficiency('none');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('screenshot-sanity.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('achromatopsia');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-achromatopsia.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('blurredVision');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-blurredVision.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('deuteranopia');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-deuteranopia.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('protanopia');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-protanopia.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('tritanopia');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-tritanopia.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('none');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('screenshot-sanity.png');\n      }\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for invalid vision deficiencies","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":378,"column":52},"line":378,"code":"    it('should throw for invalid vision deficiencies', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page\n        // @ts-expect-error deliberately passign invalid deficiency\n        .emulateVisionDeficiency('invalid')\n        .catch((error_) => (error = error_));\n      expect(error.message).toBe('Unsupported vision deficiency: invalid');\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should change navigator.connection.effectiveType","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":391,"column":56},"line":391,"code":"    it('should change navigator.connection.effectiveType', async () => {\n      const { page, puppeteer } = getTestState();\n\n      const slow3G = puppeteer.networkConditions['Slow 3G'];\n      const fast3G = puppeteer.networkConditions['Fast 3G'];\n\n      expect(\n        await page.evaluate('window.navigator.connection.effectiveType')\n      ).toBe('4g');\n      await page.emulateNetworkConditions(fast3G);\n      expect(\n        await page.evaluate('window.navigator.connection.effectiveType')\n      ).toBe('3g');\n      await page.emulateNetworkConditions(slow3G);\n      expect(\n        await page.evaluate('window.navigator.connection.effectiveType')\n      ).toBe('2g');\n      await page.emulateNetworkConditions(null);\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should change the CPU throttling rate successfully","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":413,"column":58},"line":413,"code":"    it('should change the CPU throttling rate successfully', async () => {\n      const { page } = getTestState();\n\n      await page.emulateCPUThrottling(100);\n      await page.emulateCPUThrottling(null);\n    });","file":"emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":34,"column":19},"line":34,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate(() => 7 * 3);\n      expect(result).toBe(21);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer NaN","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":46,"column":27},"line":46,"code":"    it('should transfer NaN', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate((a) => a, NaN);\n      expect(Object.is(result, NaN)).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer -0","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":52,"column":26},"line":52,"code":"    it('should transfer -0', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate((a) => a, -0);\n      expect(Object.is(result, -0)).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer Infinity","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":58,"column":32},"line":58,"code":"    it('should transfer Infinity', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate((a) => a, Infinity);\n      expect(Object.is(result, Infinity)).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer -Infinity","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":64,"column":33},"line":64,"code":"    it('should transfer -Infinity', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate((a) => a, -Infinity);\n      expect(Object.is(result, -Infinity)).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer arrays","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":70,"column":30},"line":70,"code":"    it('should transfer arrays', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate((a) => a, [1, 2, 3]);\n      expect(result).toEqual([1, 2, 3]);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer arrays as arrays, not objects","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":76,"column":53},"line":76,"code":"    it('should transfer arrays as arrays, not objects', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate((a) => Array.isArray(a), [1, 2, 3]);\n      expect(result).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should modify global environment","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":82,"column":40},"line":82,"code":"    it('should modify global environment', async () => {\n      const { page } = getTestState();\n\n      await page.evaluate(() => (globalThis.globalVar = 123));\n      expect(await page.evaluate('globalVar')).toBe(123);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate in the page context","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":88,"column":43},"line":88,"code":"    it('should evaluate in the page context', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/global-var.html');\n      expect(await page.evaluate('globalVar')).toBe(123);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with function shorthands","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":102,"column":44},"line":102,"code":"    it('should work with function shorthands', async () => {\n      const { page } = getTestState();\n\n      const a = {\n        sum(a, b) {\n          return a + b;\n        },\n\n        async mult(a, b) {\n          return a * b;\n        },\n      };\n      expect(await page.evaluate(a.sum, 1, 2)).toBe(3);\n      expect(await page.evaluate(a.mult, 2, 4)).toBe(8);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with unicode chars","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":117,"column":38},"line":117,"code":"    it('should work with unicode chars', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate((a) => a['中文字符'], {\n        中文字符: 42,\n      });\n      expect(result).toBe(42);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should await promise","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":137,"column":28},"line":137,"code":"    it('should await promise', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate(() => Promise.resolve(8 * 7));\n      expect(result).toBe(56);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work right after framenavigated","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":143,"column":46},"line":143,"code":"    it('should work right after framenavigated', async () => {\n      const { page, server } = getTestState();\n\n      let frameEvaluation = null;\n      page.on('framenavigated', async (frame) => {\n        frameEvaluation = frame.evaluate(() => 6 * 7);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(await frameEvaluation).toBe(42);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should reject promise with exception","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":169,"column":44},"line":169,"code":"    it('should reject promise with exception', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page\n        // @ts-expect-error we know the object doesn't exist\n        .evaluate(() => notExistingObject.property)\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('notExistingObject');\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should support thrown strings as error messages","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":180,"column":55},"line":180,"code":"    it('should support thrown strings as error messages', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page\n        .evaluate(() => {\n          throw 'qwerty';\n        })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('qwerty');\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should support thrown numbers as error messages","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":192,"column":55},"line":192,"code":"    it('should support thrown numbers as error messages', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page\n        .evaluate(() => {\n          throw 100500;\n        })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('100500');\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return complex objects","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":204,"column":37},"line":204,"code":"    it('should return complex objects', async () => {\n      const { page } = getTestState();\n\n      const object = { foo: 'bar!' };\n      const result = await page.evaluate((a) => a, object);\n      expect(result).not.toBe(object);\n      expect(result).toEqual(object);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return NaN","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":218,"column":25},"line":218,"code":"    it('should return NaN', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate(() => NaN);\n      expect(Object.is(result, NaN)).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return -0","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":224,"column":24},"line":224,"code":"    it('should return -0', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate(() => -0);\n      expect(Object.is(result, -0)).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return Infinity","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":230,"column":30},"line":230,"code":"    it('should return Infinity', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate(() => Infinity);\n      expect(Object.is(result, Infinity)).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return -Infinity","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":236,"column":31},"line":236,"code":"    it('should return -Infinity', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate(() => -Infinity);\n      expect(Object.is(result, -Infinity)).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept \"undefined\" as one of multiple parameters","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":242,"column":63},"line":242,"code":"    it('should accept \"undefined\" as one of multiple parameters', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate(\n        (a, b) => Object.is(a, undefined) && Object.is(b, 'foo'),\n        undefined,\n        'foo'\n      );\n      expect(result).toBe(true);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should properly serialize null fields","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":252,"column":45},"line":252,"code":"    it('should properly serialize null fields', async () => {\n      const { page } = getTestState();\n\n      expect(await page.evaluate(() => ({ a: undefined }))).toEqual({});\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept a string","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":290,"column":30},"line":290,"code":"    it('should accept a string', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate('1 + 2');\n      expect(result).toBe(3);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept a string with semi colons","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":296,"column":47},"line":296,"code":"    it('should accept a string with semi colons', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate('1 + 5;');\n      expect(result).toBe(6);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept a string with comments","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":302,"column":44},"line":302,"code":"    it('should accept a string with comments', async () => {\n      const { page } = getTestState();\n\n      const result = await page.evaluate('2 + 5;\\n// do some math!');\n      expect(result).toBe(7);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept element handle as an argument","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":308,"column":51},"line":308,"code":"    it('should accept element handle as an argument', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<section>42</section>');\n      const element = await page.$('section');\n      const text = await page.evaluate<(e: HTMLElement) => string>(\n        (e) => e.textContent,\n        element\n      );\n      expect(text).toBe('42');\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if underlying element was disposed","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":319,"column":55},"line":319,"code":"    it('should throw if underlying element was disposed', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<section>39</section>');\n      const element = await page.$('section');\n      expect(element).toBeTruthy();\n      await element.dispose();\n      let error = null;\n      await page\n        .evaluate((e: HTMLElement) => e.textContent, element)\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain('JSHandle is disposed');\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer 100Mb of data from page to node.js","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":386,"column":58},"line":386,"code":"    it('should transfer 100Mb of data from page to node.js', async function () {\n      const { page } = getTestState();\n\n      const a = await page.evaluate<() => string>(() =>\n        Array(100 * 1024 * 1024 + 1).join('a')\n      );\n      expect(a.length).toBe(100 * 1024 * 1024);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw error with detailed information on exception inside promise ","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":394,"column":81},"line":394,"code":"    it('should throw error with detailed information on exception inside promise ', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page\n        .evaluate(\n          () =>\n            new Promise(() => {\n              throw new Error('Error in promise');\n            })\n        )\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain('Error in promise');\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate before anything else on the page","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":411,"column":56},"line":411,"code":"    it('should evaluate before anything else on the page', async () => {\n      const { page, server } = getTestState();\n\n      await page.evaluateOnNewDocument(function () {\n        globalThis.injected = 123;\n      });\n      await page.goto(server.PREFIX + '/tamperable.html');\n      expect(await page.evaluate(() => globalThis.result)).toBe(123);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with CSP","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":420,"column":28},"line":420,"code":"    it('should work with CSP', async () => {\n      const { page, server } = getTestState();\n\n      server.setCSP('/empty.html', 'script-src ' + server.PREFIX);\n      await page.evaluateOnNewDocument(function () {\n        globalThis.injected = 123;\n      });\n      await page.goto(server.PREFIX + '/empty.html');\n      expect(await page.evaluate(() => globalThis.injected)).toBe(123);\n\n      // Make sure CSP works.\n      await page\n        .addScriptTag({ content: 'window.e = 10;' })\n        .catch((error) => void error);\n      expect(await page.evaluate(() => (window as any).e)).toBe(undefined);\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should execute after cross-site navigation","suites":["Evaluation specs","Frame.evaluate"],"updatePoint":{"line":462,"column":50},"line":462,"code":"    it('should execute after cross-site navigation', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n      expect(await mainFrame.evaluate(() => window.location.href)).toContain(\n        'localhost'\n      );\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/empty.html');\n      expect(await mainFrame.evaluate(() => window.location.href)).toContain(\n        '127'\n      );\n    });","file":"evaluation.spec.ts","skipped":false,"dir":"test"},{"name":": adds an event listener that is fired when the event is emitted","suites":["EventEmitter","on"],"updatePoint":{"line":30,"column":87},"line":30,"code":"      it(`${methodName}: adds an event listener that is fired when the event is emitted`, () => {\n        const listener = sinon.spy();\n        emitter[methodName]('foo', listener);\n        emitter.emit('foo');\n        expect(listener.callCount).toEqual(1);\n      });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":" sends the event data to the handler","suites":["EventEmitter","on"],"updatePoint":{"line":37,"column":59},"line":37,"code":"      it(`${methodName} sends the event data to the handler`, () => {\n        const listener = sinon.spy();\n        const data = {};\n        emitter[methodName]('foo', listener);\n        emitter.emit('foo', data);\n        expect(listener.callCount).toEqual(1);\n        expect(listener.firstCall.args[0]).toBe(data);\n      });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":": supports chaining","suites":["EventEmitter","on"],"updatePoint":{"line":46,"column":42},"line":46,"code":"      it(`${methodName}: supports chaining`, () => {\n        const listener = sinon.spy();\n        const returnValue = emitter[methodName]('foo', listener);\n        expect(returnValue).toBe(emitter);\n      });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":": removes the listener so it is no longer called","suites":["EventEmitter","off"],"updatePoint":{"line":59,"column":71},"line":59,"code":"      it(`${methodName}: removes the listener so it is no longer called`, () => {\n        const listener = sinon.spy();\n        emitter.on('foo', listener);\n        emitter.emit('foo');\n        expect(listener.callCount).toEqual(1);\n        emitter.off('foo', listener);\n        emitter.emit('foo');\n        expect(listener.callCount).toEqual(1);\n      });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":": supports chaining","suites":["EventEmitter","off"],"updatePoint":{"line":69,"column":42},"line":69,"code":"      it(`${methodName}: supports chaining`, () => {\n        const listener = sinon.spy();\n        emitter.on('foo', listener);\n        const returnValue = emitter.off('foo', listener);\n        expect(returnValue).toBe(emitter);\n      });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"only calls the listener once and then removes it","suites":["EventEmitter","once"],"updatePoint":{"line":82,"column":56},"line":82,"code":"    it('only calls the listener once and then removes it', () => {\n      const listener = sinon.spy();\n      emitter.once('foo', listener);\n      emitter.emit('foo');\n      expect(listener.callCount).toEqual(1);\n      emitter.emit('foo');\n      expect(listener.callCount).toEqual(1);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"supports chaining","suites":["EventEmitter","once"],"updatePoint":{"line":91,"column":25},"line":91,"code":"    it('supports chaining', () => {\n      const listener = sinon.spy();\n      const returnValue = emitter.once('foo', listener);\n      expect(returnValue).toBe(emitter);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"calls all the listeners for an event","suites":["EventEmitter","emit"],"updatePoint":{"line":99,"column":44},"line":99,"code":"    it('calls all the listeners for an event', () => {\n      const listener1 = sinon.spy();\n      const listener2 = sinon.spy();\n      const listener3 = sinon.spy();\n      emitter.on('foo', listener1).on('foo', listener2).on('bar', listener3);\n\n      emitter.emit('foo');\n\n      expect(listener1.callCount).toEqual(1);\n      expect(listener2.callCount).toEqual(1);\n      expect(listener3.callCount).toEqual(0);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"passes data through to the listener","suites":["EventEmitter","emit"],"updatePoint":{"line":112,"column":43},"line":112,"code":"    it('passes data through to the listener', () => {\n      const listener = sinon.spy();\n      emitter.on('foo', listener);\n      const data = {};\n\n      emitter.emit('foo', data);\n      expect(listener.callCount).toEqual(1);\n      expect(listener.firstCall.args[0]).toBe(data);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"returns true if the event has listeners","suites":["EventEmitter","emit"],"updatePoint":{"line":122,"column":47},"line":122,"code":"    it('returns true if the event has listeners', () => {\n      const listener = sinon.spy();\n      emitter.on('foo', listener);\n      expect(emitter.emit('foo')).toBe(true);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"returns false if the event has listeners","suites":["EventEmitter","emit"],"updatePoint":{"line":128,"column":48},"line":128,"code":"    it('returns false if the event has listeners', () => {\n      const listener = sinon.spy();\n      emitter.on('foo', listener);\n      expect(emitter.emit('notFoo')).toBe(false);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"returns the number of listeners for the given event","suites":["EventEmitter","listenerCount"],"updatePoint":{"line":136,"column":59},"line":136,"code":"    it('returns the number of listeners for the given event', () => {\n      emitter.on('foo', () => {});\n      emitter.on('foo', () => {});\n      emitter.on('bar', () => {});\n      expect(emitter.listenerCount('foo')).toEqual(2);\n      expect(emitter.listenerCount('bar')).toEqual(1);\n      expect(emitter.listenerCount('noListeners')).toEqual(0);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"removes every listener from all events by default","suites":["EventEmitter","removeAllListeners"],"updatePoint":{"line":147,"column":57},"line":147,"code":"    it('removes every listener from all events by default', () => {\n      emitter.on('foo', () => {}).on('bar', () => {});\n\n      emitter.removeAllListeners();\n      expect(emitter.emit('foo')).toBe(false);\n      expect(emitter.emit('bar')).toBe(false);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"returns the emitter for chaining","suites":["EventEmitter","removeAllListeners"],"updatePoint":{"line":155,"column":40},"line":155,"code":"    it('returns the emitter for chaining', () => {\n      expect(emitter.removeAllListeners()).toBe(emitter);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"can filter to remove only listeners for a given event name","suites":["EventEmitter","removeAllListeners"],"updatePoint":{"line":159,"column":66},"line":159,"code":"    it('can filter to remove only listeners for a given event name', () => {\n      emitter\n        .on('foo', () => {})\n        .on('bar', () => {})\n        .on('bar', () => {});\n\n      emitter.removeAllListeners('bar');\n      expect(emitter.emit('foo')).toBe(true);\n      expect(emitter.emit('bar')).toBe(false);\n    });","file":"EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"should dump browser process stderr","suites":["Fixtures"],"updatePoint":{"line":43,"column":40},"line":43,"code":"  it('should dump browser process stderr', async () => {\n    const { defaultBrowserOptions, puppeteerPath } = getTestState();\n\n    let dumpioData = '';\n    const { spawn } = require('child_process');\n    const options = Object.assign({}, defaultBrowserOptions, { dumpio: true });\n    const res = spawn('node', [\n      path.join(__dirname, 'fixtures', 'dumpio.js'),\n      puppeteerPath,\n      JSON.stringify(options),\n    ]);\n    res.stderr.on('data', (data) => (dumpioData += data.toString('utf8')));\n    await new Promise((resolve) => res.on('close', resolve));\n    expect(dumpioData).toContain('DevTools listening on ws://');\n  });","file":"fixtures.spec.ts","skipped":false,"dir":"test"},{"name":"should close the browser when the node process closes","suites":["Fixtures"],"updatePoint":{"line":58,"column":59},"line":58,"code":"  it('should close the browser when the node process closes', async () => {\n    const { defaultBrowserOptions, puppeteerPath, puppeteer } = getTestState();\n\n    const { spawn, execSync } = require('child_process');\n    const options = Object.assign({}, defaultBrowserOptions, {\n      // Disable DUMPIO to cleanly read stdout.\n      dumpio: false,\n    });\n    const res = spawn('node', [\n      path.join(__dirname, 'fixtures', 'closeme.js'),\n      puppeteerPath,\n      JSON.stringify(options),\n    ]);\n    let wsEndPointCallback;\n    const wsEndPointPromise = new Promise<string>(\n      (x) => (wsEndPointCallback = x)\n    );\n    let output = '';\n    res.stdout.on('data', (data) => {\n      output += data;\n      if (output.indexOf('\\n'))\n        wsEndPointCallback(output.substring(0, output.indexOf('\\n')));\n    });\n    const browser = await puppeteer.connect({\n      browserWSEndpoint: await wsEndPointPromise,\n    });\n    const promises = [\n      new Promise((resolve) => browser.once('disconnected', resolve)),\n      new Promise((resolve) => res.on('close', resolve)),\n    ];\n    if (process.platform === 'win32')\n      execSync(`taskkill /pid ${res.pid} /T /F`);\n    else process.kill(res.pid);\n    await Promise.all(promises);\n  });","file":"fixtures.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Frame specs","Frame.evaluateHandle"],"updatePoint":{"line":61,"column":19},"line":61,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n      const windowHandle = await mainFrame.evaluateHandle(() => window);\n      expect(windowHandle).toBeTruthy();\n    });","file":"frame.spec.ts","skipped":false,"dir":"test"},{"name":"allows readonly array to be an argument","suites":["Frame specs","Frame.evaluate"],"updatePoint":{"line":84,"column":47},"line":84,"code":"    it('allows readonly array to be an argument', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n\n      // This test checks if Frame.evaluate allows a readonly array to be an argument.\n      // See https://github.com/puppeteer/puppeteer/issues/6953.\n      const readonlyArray: readonly string[] = ['a', 'b', 'c'];\n      await mainFrame.evaluate((arr) => arr, readonlyArray);\n    });","file":"frame.spec.ts","skipped":false,"dir":"test"},{"name":"should persist mainFrame on cross-process navigation","suites":["Frame specs","Frame Management"],"updatePoint":{"line":150,"column":60},"line":150,"code":"    it('should persist mainFrame on cross-process navigation', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/empty.html');\n      expect(page.mainFrame() === mainFrame).toBeTruthy();\n    });","file":"frame.spec.ts","skipped":false,"dir":"test"},{"name":"should not send attach/detach events for main frame","suites":["Frame specs","Frame Management"],"updatePoint":{"line":158,"column":59},"line":158,"code":"    it('should not send attach/detach events for main frame', async () => {\n      const { page, server } = getTestState();\n\n      let hasEvents = false;\n      page.on('frameattached', () => (hasEvents = true));\n      page.on('framedetached', () => (hasEvents = true));\n      await page.goto(server.EMPTY_PAGE);\n      expect(hasEvents).toBe(false);\n    });","file":"frame.spec.ts","skipped":false,"dir":"test"},{"name":"should support url fragment","suites":["Frame specs","Frame Management"],"updatePoint":{"line":271,"column":35},"line":271,"code":"    it('should support url fragment', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame-url-fragment.html');\n\n      expect(page.frames().length).toBe(2);\n      expect(page.frames()[1].url()).toBe(\n        server.PREFIX + '/frames/frame.html?param=value#fragment'\n      );\n    });","file":"frame.spec.ts","skipped":false,"dir":"test"},{"name":"should return the client instance","suites":["Frame specs","Frame.client"],"updatePoint":{"line":284,"column":41},"line":284,"code":"    it('should return the client instance', async () => {\n      const { page } = getTestState();\n      expect(page.mainFrame().client()).toBeInstanceOf(CDPSession);\n    });","file":"frame.spec.ts","skipped":false,"dir":"test"},{"name":"background_page target type should be available","suites":["HEADFUL"],"updatePoint":{"line":95,"column":55},"line":95,"code":"    it('background_page target type should be available', async () => {\n      const { puppeteer } = getTestState();\n      const browserWithExtension = await launchBrowser(\n        puppeteer,\n        extensionOptions\n      );\n      const page = await browserWithExtension.newPage();\n      const backgroundPageTarget = await browserWithExtension.waitForTarget(\n        (target) => target.type() === 'background_page'\n      );\n      await page.close();\n      await browserWithExtension.close();\n      expect(backgroundPageTarget).toBeTruthy();\n    });","file":"headful.spec.ts","skipped":false,"dir":"test"},{"name":"target.page() should return a background_page","suites":["HEADFUL"],"updatePoint":{"line":109,"column":53},"line":109,"code":"    it('target.page() should return a background_page', async function () {\n      const { puppeteer } = getTestState();\n      const browserWithExtension = await launchBrowser(\n        puppeteer,\n        extensionOptions\n      );\n      const backgroundPageTarget = await browserWithExtension.waitForTarget(\n        (target) => target.type() === 'background_page'\n      );\n      const page = await backgroundPageTarget.page();\n      expect(await page.evaluate(() => 2 * 3)).toBe(6);\n      expect(await page.evaluate(() => globalThis.MAGIC)).toBe(42);\n      await browserWithExtension.close();\n    });","file":"headful.spec.ts","skipped":false,"dir":"test"},{"name":"should have default url when launching browser","suites":["HEADFUL"],"updatePoint":{"line":123,"column":54},"line":123,"code":"    it('should have default url when launching browser', async function () {\n      const { puppeteer } = getTestState();\n      const browser = await launchBrowser(puppeteer, extensionOptions);\n      const pages = (await browser.pages()).map((page) => page.url());\n      expect(pages).toEqual(['about:blank']);\n      await browser.close();\n    });","file":"headful.spec.ts","skipped":false,"dir":"test"},{"name":"OOPIF: should report google.com frame","suites":["HEADFUL"],"updatePoint":{"line":165,"column":46},"line":165,"code":"    xit('OOPIF: should report google.com frame', async () => {\n      const { server, puppeteer } = getTestState();\n\n      // https://google.com is isolated by default in Chromium embedder.\n      const browser = await launchBrowser(puppeteer, headfulOptions);\n      const page = await browser.newPage();\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      page.on('request', (r) => r.respond({ body: 'YO, GOOGLE.COM' }));\n      await page.evaluate(() => {\n        const frame = document.createElement('iframe');\n        frame.setAttribute('src', 'https://google.com/');\n        document.body.appendChild(frame);\n        return new Promise((x) => (frame.onload = x));\n      });\n      await page.waitForSelector('iframe[src=\"https://google.com/\"]');\n      const urls = page\n        .frames()\n        .map((frame) => frame.url())\n        .sort();\n      expect(urls).toEqual([server.EMPTY_PAGE, 'https://google.com/']);\n      await browser.close();\n    });","skipped":true,"file":"headful.spec.ts","dir":"test"},{"name":"OOPIF: should expose events within OOPIFs","suites":["HEADFUL"],"updatePoint":{"line":188,"column":49},"line":188,"code":"    it('OOPIF: should expose events within OOPIFs', async () => {\n      const { server, puppeteer } = getTestState();\n\n      const browser = await launchBrowser(puppeteer, forcedOopifOptions);\n      const page = await browser.newPage();\n\n      // Setup our session listeners to observe OOPIF activity.\n      const session = await page.target().createCDPSession();\n      const networkEvents = [];\n      const otherSessions = [];\n      await session.send('Target.setAutoAttach', {\n        autoAttach: true,\n        flatten: true,\n        waitForDebuggerOnStart: true,\n      });\n      session.on('sessionattached', async (session) => {\n        otherSessions.push(session);\n\n        session.on('Network.requestWillBeSent', (params) =>\n          networkEvents.push(params)\n        );\n        await session.send('Network.enable');\n        await session.send('Runtime.runIfWaitingForDebugger');\n      });\n\n      // Navigate to the empty page and add an OOPIF iframe with at least one request.\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate((frameUrl) => {\n        const frame = document.createElement('iframe');\n        frame.setAttribute('src', frameUrl);\n        document.body.appendChild(frame);\n        return new Promise((x, y) => {\n          frame.onload = x;\n          frame.onerror = y;\n        });\n      }, server.PREFIX.replace('localhost', 'oopifdomain') + '/one-style.html');\n      await page.waitForSelector('iframe');\n\n      // Ensure we found the iframe session.\n      expect(otherSessions).toHaveLength(1);\n\n      // Resume the iframe and trigger another request.\n      const iframeSession = otherSessions[0];\n      await iframeSession.send('Runtime.evaluate', {\n        expression: `fetch('/fetch')`,\n        awaitPromise: true,\n      });\n      await browser.close();\n\n      const requests = networkEvents.map((event) => event.request.url);\n      expect(requests).toContain(`http://oopifdomain:${server.PORT}/fetch`);\n    });","file":"headful.spec.ts","skipped":false,"dir":"test"},{"name":"should close browser with beforeunload page","suites":["HEADFUL"],"updatePoint":{"line":240,"column":51},"line":240,"code":"    it('should close browser with beforeunload page', async () => {\n      const { server, puppeteer } = getTestState();\n\n      const browser = await launchBrowser(puppeteer, headfulOptions);\n      const page = await browser.newPage();\n      await page.goto(server.PREFIX + '/beforeunload.html');\n      // We have to interact with a page so that 'beforeunload' handlers\n      // fire.\n      await page.click('body');\n      await browser.close();\n    });","file":"headful.spec.ts","skipped":false,"dir":"test"},{"name":"should open devtools when \"devtools: true\" option is given","suites":["HEADFUL"],"updatePoint":{"line":251,"column":66},"line":251,"code":"    it('should open devtools when \"devtools: true\" option is given', async () => {\n      const { puppeteer } = getTestState();\n\n      const browser = await launchBrowser(\n        puppeteer,\n        Object.assign({ devtools: true }, headfulOptions)\n      );\n      const context = await browser.createIncognitoBrowserContext();\n      await Promise.all([\n        context.newPage(),\n        browser.waitForTarget((target) => target.url().includes('devtools://')),\n      ]);\n      await browser.close();\n    });","file":"headful.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page.bringToFront"],"updatePoint":{"line":268,"column":19},"line":268,"code":"    it('should work', async () => {\n      const { puppeteer } = getTestState();\n      const browser = await launchBrowser(puppeteer, headfulOptions);\n      const page1 = await browser.newPage();\n      const page2 = await browser.newPage();\n\n      await page1.bringToFront();\n      expect(await page1.evaluate(() => document.visibilityState)).toBe(\n        'visible'\n      );\n      expect(await page2.evaluate(() => document.visibilityState)).toBe(\n        'hidden'\n      );\n\n      await page2.bringToFront();\n      expect(await page1.evaluate(() => document.visibilityState)).toBe(\n        'hidden'\n      );\n      expect(await page2.evaluate(() => document.visibilityState)).toBe(\n        'visible'\n      );\n\n      await page1.close();\n      await page2.close();\n      await browser.close();\n    });","file":"headful.spec.ts","skipped":false,"dir":"test"},{"name":"should run in parallel in multiple pages","suites":["Page.screenshot"],"updatePoint":{"line":297,"column":48},"line":297,"code":"    it('should run in parallel in multiple pages', async () => {\n      const { server, puppeteer } = getTestState();\n      const browser = await puppeteer.launch(headfulOptions);\n      const context = await browser.createIncognitoBrowserContext();\n\n      const N = 2;\n      const pages = await Promise.all(\n        Array(N)\n          .fill(0)\n          .map(async () => {\n            const page = await context.newPage();\n            await page.goto(server.PREFIX + '/grid.html');\n            return page;\n          })\n      );\n      const promises = [];\n      for (let i = 0; i < N; ++i)\n        promises.push(\n          pages[i].screenshot({\n            clip: { x: 50 * i, y: 0, width: 50, height: 50 },\n          })\n        );\n      const screenshots = await Promise.all(promises);\n      for (let i = 0; i < N; ++i)\n        expect(screenshots[i]).toBeGolden(`grid-cell-${i}.png`);\n      await Promise.all(pages.map((page) => page.close()));\n\n      await browser.close();\n    });","file":"headful.spec.ts","skipped":false,"dir":"test"},{"name":"changing idle state emulation causes change of the IdleDetector state","suites":[],"updatePoint":{"line":43,"column":75},"line":43,"code":"  it('changing idle state emulation causes change of the IdleDetector state', async () => {\n    const { page, server, context } = getTestState();\n    await context.overridePermissions(server.PREFIX + '/idle-detector.html', [\n      'idle-detection',\n    ]);\n\n    await page.goto(server.PREFIX + '/idle-detector.html');\n\n    // Store initial state, as soon as it is not guaranteed to be `active, unlocked`.\n    const initialState = await getIdleState();\n\n    // Emulate Idle states and verify IdleDetector updates state accordingly.\n    await page.emulateIdleState({\n      isUserActive: false,\n      isScreenUnlocked: false,\n    });\n    await verifyState('Idle state: idle, locked.');\n\n    await page.emulateIdleState({\n      isUserActive: true,\n      isScreenUnlocked: false,\n    });\n    await verifyState('Idle state: active, locked.');\n\n    await page.emulateIdleState({\n      isUserActive: true,\n      isScreenUnlocked: true,\n    });\n    await verifyState('Idle state: active, unlocked.');\n\n    await page.emulateIdleState({\n      isUserActive: false,\n      isScreenUnlocked: true,\n    });\n    await verifyState('Idle state: idle, unlocked.');\n\n    // Remove Idle emulation and verify IdleDetector is in initial state.\n    await page.emulateIdleState();\n    await verifyState(initialState);\n\n    // Emulate idle state again after removing emulation.\n    await page.emulateIdleState({\n      isUserActive: false,\n      isScreenUnlocked: false,\n    });\n    await verifyState('Idle state: idle, locked.');\n\n    // Remove emulation second time.\n    await page.emulateIdleState();\n    await verifyState(initialState);\n  });","file":"idle_override.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ignoreHTTPSErrors"],"updatePoint":{"line":59,"column":19},"line":59,"code":"    it('should work', async () => {\n      const { httpsServer } = getTestState();\n\n      const [serverRequest, response] = await Promise.all([\n        httpsServer.waitForRequest('/empty.html'),\n        page.goto(httpsServer.EMPTY_PAGE),\n      ]);\n      const securityDetails = response.securityDetails();\n      expect(securityDetails.issuer()).toBe('puppeteer-tests');\n      const protocol = serverRequest.socket.getProtocol().replace('v', ' ');\n      expect(securityDetails.protocol()).toBe(protocol);\n      expect(securityDetails.subjectName()).toBe('puppeteer-tests');\n      expect(securityDetails.validFrom()).toBe(1589357069);\n      expect(securityDetails.validTo()).toBe(1904717069);\n      expect(securityDetails.subjectAlternativeNames()).toEqual([\n        'www.puppeteer-tests.test',\n        'www.puppeteer-tests-1.test',\n      ]);\n    });","file":"ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"should be |null| for non-secure requests","suites":["ignoreHTTPSErrors"],"updatePoint":{"line":78,"column":48},"line":78,"code":"    it('should be |null| for non-secure requests', async () => {\n      const { server } = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.securityDetails()).toBe(null);\n    });","file":"ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"Network redirects should report SecurityDetails","suites":["ignoreHTTPSErrors"],"updatePoint":{"line":84,"column":55},"line":84,"code":"    it('Network redirects should report SecurityDetails', async () => {\n      const { httpsServer } = getTestState();\n\n      httpsServer.setRedirect('/plzredirect', '/empty.html');\n      const responses = [];\n      page.on('response', (response) => responses.push(response));\n      const [serverRequest] = await Promise.all([\n        httpsServer.waitForRequest('/plzredirect'),\n        page.goto(httpsServer.PREFIX + '/plzredirect'),\n      ]);\n      expect(responses.length).toBe(2);\n      expect(responses[0].status()).toBe(302);\n      const securityDetails = responses[0].securityDetails();\n      const protocol = serverRequest.socket.getProtocol().replace('v', ' ');\n      expect(securityDetails.protocol()).toBe(protocol);\n    });","file":"ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ignoreHTTPSErrors"],"updatePoint":{"line":102,"column":17},"line":102,"code":"  it('should work', async () => {\n    const { httpsServer } = getTestState();\n\n    let error = null;\n    const response = await page\n      .goto(httpsServer.EMPTY_PAGE)\n      .catch((error_) => (error = error_));\n    expect(error).toBe(null);\n    expect(response.ok()).toBe(true);\n  });","file":"ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"should upload the file","suites":["input tests"],"updatePoint":{"line":33,"column":30},"line":33,"code":"    it('should upload the file', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/fileupload.html');\n      const filePath = path.relative(process.cwd(), FILE_TO_UPLOAD);\n      const input = await page.$('input');\n      await page.evaluate((e: HTMLElement) => {\n        globalThis._inputEvents = [];\n        e.addEventListener('change', (ev) =>\n          globalThis._inputEvents.push(ev.type)\n        );\n        e.addEventListener('input', (ev) =>\n          globalThis._inputEvents.push(ev.type)\n        );\n      }, input);\n      await input.uploadFile(filePath);\n      expect(\n        await page.evaluate((e: HTMLInputElement) => e.files[0].name, input)\n      ).toBe('file-to-upload.txt');\n      expect(\n        await page.evaluate((e: HTMLInputElement) => e.files[0].type, input)\n      ).toBe('text/plain');\n      expect(await page.evaluate(() => globalThis._inputEvents)).toEqual([\n        'input',\n        'change',\n      ]);\n      expect(\n        await page.evaluate((e: HTMLInputElement) => {\n          const reader = new FileReader();\n          const promise = new Promise((fulfill) => (reader.onload = fulfill));\n          reader.readAsText(e.files[0]);\n          return promise.then(() => reader.result);\n        }, input)\n      ).toBe('contents of the file');\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should work when file input is attached to DOM","suites":["input tests"],"updatePoint":{"line":71,"column":54},"line":71,"code":"    it('should work when file input is attached to DOM', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      expect(chooser).toBeTruthy();\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should work when file input is not attached to DOM","suites":["input tests"],"updatePoint":{"line":81,"column":58},"line":81,"code":"    it('should work when file input is not attached to DOM', async () => {\n      const { page } = getTestState();\n\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.evaluate(() => {\n          const el = document.createElement('input');\n          el.type = 'file';\n          el.click();\n        }),\n      ]);\n      expect(chooser).toBeTruthy();\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["input tests"],"updatePoint":{"line":94,"column":30},"line":94,"code":"    it('should respect timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      await page\n        .waitForFileChooser({ timeout: 1 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default timeout when there is no custom timeout","suites":["input tests"],"updatePoint":{"line":103,"column":70},"line":103,"code":"    it('should respect default timeout when there is no custom timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      page.setDefaultTimeout(1);\n      let error = null;\n      await page.waitForFileChooser().catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should prioritize exact timeout over default timeout","suites":["input tests"],"updatePoint":{"line":111,"column":60},"line":111,"code":"    it('should prioritize exact timeout over default timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      page.setDefaultTimeout(0);\n      let error = null;\n      await page\n        .waitForFileChooser({ timeout: 1 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no timeout","suites":["input tests"],"updatePoint":{"line":121,"column":35},"line":121,"code":"    it('should work with no timeout', async () => {\n      const { page } = getTestState();\n\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser({ timeout: 0 }),\n        page.evaluate(() =>\n          setTimeout(() => {\n            const el = document.createElement('input');\n            el.type = 'file';\n            el.click();\n          }, 50)\n        ),\n      ]);\n      expect(chooser).toBeTruthy();\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should return the same file chooser when there are many watchdogs simultaneously","suites":["input tests"],"updatePoint":{"line":136,"column":88},"line":136,"code":"    it('should return the same file chooser when there are many watchdogs simultaneously', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [fileChooser1, fileChooser2] = await Promise.all([\n        page.waitForFileChooser(),\n        page.waitForFileChooser(),\n        page.$eval('input', (input: HTMLInputElement) => input.click()),\n      ]);\n      expect(fileChooser1 === fileChooser2).toBe(true);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should accept single file","suites":["input tests"],"updatePoint":{"line":150,"column":33},"line":150,"code":"    it('should accept single file', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        `<input type=file oninput='javascript:console.timeStamp()'>`\n      );\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      await Promise.all([\n        chooser.accept([FILE_TO_UPLOAD]),\n        new Promise((x) => page.once('metrics', x)),\n      ]);\n      expect(\n        await page.$eval(\n          'input',\n          (input: HTMLInputElement) => input.files.length\n        )\n      ).toBe(1);\n      expect(\n        await page.$eval(\n          'input',\n          (input: HTMLInputElement) => input.files[0].name\n        )\n      ).toBe('file-to-upload.txt');\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to read selected file","suites":["input tests"],"updatePoint":{"line":177,"column":44},"line":177,"code":"    it('should be able to read selected file', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      page\n        .waitForFileChooser()\n        .then((chooser) => chooser.accept([FILE_TO_UPLOAD]));\n      expect(\n        await page.$eval('input', async (picker: HTMLInputElement) => {\n          picker.click();\n          await new Promise((x) => (picker.oninput = x));\n          const reader = new FileReader();\n          const promise = new Promise((fulfill) => (reader.onload = fulfill));\n          reader.readAsText(picker.files[0]);\n          return promise.then(() => reader.result);\n        })\n      ).toBe('contents of the file');\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to reset selected files with empty file list","suites":["input tests"],"updatePoint":{"line":195,"column":67},"line":195,"code":"    it('should be able to reset selected files with empty file list', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      page\n        .waitForFileChooser()\n        .then((chooser) => chooser.accept([FILE_TO_UPLOAD]));\n      expect(\n        await page.$eval('input', async (picker: HTMLInputElement) => {\n          picker.click();\n          await new Promise((x) => (picker.oninput = x));\n          return picker.files.length;\n        })\n      ).toBe(1);\n      page.waitForFileChooser().then((chooser) => chooser.accept([]));\n      expect(\n        await page.$eval('input', async (picker: HTMLInputElement) => {\n          picker.click();\n          await new Promise((x) => (picker.oninput = x));\n          return picker.files.length;\n        })\n      ).toBe(0);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should not accept multiple files for single-file input","suites":["input tests"],"updatePoint":{"line":218,"column":62},"line":218,"code":"    it('should not accept multiple files for single-file input', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      let error = null;\n      await chooser\n        .accept([\n          path.relative(\n            process.cwd(),\n            __dirname + '/assets/file-to-upload.txt'\n          ),\n          path.relative(process.cwd(), __dirname + '/assets/pptr.png'),\n        ])\n        .catch((error_) => (error = error_));\n      expect(error).not.toBe(null);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should fail for non-existent files","suites":["input tests"],"updatePoint":{"line":238,"column":42},"line":238,"code":"    it('should fail for non-existent files', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      let error = null;\n      await chooser\n        .accept(['file-does-not-exist.txt'])\n        .catch((error_) => (error = error_));\n      expect(error).not.toBe(null);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when accepting file chooser twice","suites":["input tests"],"updatePoint":{"line":252,"column":53},"line":252,"code":"    it('should fail when accepting file chooser twice', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [fileChooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.$eval('input', (input: HTMLInputElement) => input.click()),\n      ]);\n      await fileChooser.accept([]);\n      let error = null;\n      await fileChooser.accept([]).catch((error_) => (error = error_));\n      expect(error.message).toBe(\n        'Cannot accept FileChooser which is already handled!'\n      );\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should cancel dialog","suites":["input tests"],"updatePoint":{"line":270,"column":28},"line":270,"code":"    it('should cancel dialog', async () => {\n      const { page } = getTestState();\n\n      // Consider file chooser canceled if we can summon another one.\n      // There's no reliable way in WebPlatform to see that FileChooser was\n      // canceled.\n      await page.setContent(`<input type=file>`);\n      const [fileChooser1] = await Promise.all([\n        page.waitForFileChooser(),\n        page.$eval('input', (input: HTMLInputElement) => input.click()),\n      ]);\n      await fileChooser1.cancel();\n      // If this resolves, than we successfully canceled file chooser.\n      await Promise.all([\n        page.waitForFileChooser(),\n        page.$eval('input', (input: HTMLInputElement) => input.click()),\n      ]);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when canceling file chooser twice","suites":["input tests"],"updatePoint":{"line":288,"column":53},"line":288,"code":"    it('should fail when canceling file chooser twice', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [fileChooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.$eval('input', (input: HTMLInputElement) => input.click()),\n      ]);\n      await fileChooser.cancel();\n      let error = null;\n\n      try {\n        fileChooser.cancel();\n      } catch (error_) {\n        error = error_;\n      }\n\n      expect(error.message).toBe(\n        'Cannot cancel FileChooser which is already handled!'\n      );\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should work for single file pick","suites":["input tests"],"updatePoint":{"line":312,"column":40},"line":312,"code":"    it('should work for single file pick', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      expect(chooser.isMultiple()).toBe(false);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should work for \"multiple\"","suites":["input tests"],"updatePoint":{"line":322,"column":34},"line":322,"code":"    it('should work for \"multiple\"', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input multiple type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      expect(chooser.isMultiple()).toBe(true);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should work for \"webkitdirectory\"","suites":["input tests"],"updatePoint":{"line":332,"column":41},"line":332,"code":"    it('should work for \"webkitdirectory\"', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<input multiple webkitdirectory type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      expect(chooser.isMultiple()).toBe(true);\n    });","file":"input.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":32,"column":19},"line":32,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      const windowHandle = await page.evaluateHandle(() => window);\n      expect(windowHandle).toBeTruthy();\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should accept object handle as an argument","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":38,"column":50},"line":38,"code":"    it('should accept object handle as an argument', async () => {\n      const { page } = getTestState();\n\n      const navigatorHandle = await page.evaluateHandle(() => navigator);\n      const text = await page.evaluate(\n        (e: Navigator) => e.userAgent,\n        navigatorHandle\n      );\n      expect(text).toContain('Mozilla');\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should accept object handle to primitive types","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":48,"column":54},"line":48,"code":"    it('should accept object handle to primitive types', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => 5);\n      const isFive = await page.evaluate((e) => Object.is(e, 5), aHandle);\n      expect(isFive).toBeTruthy();\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should warn on nested object handles","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":55,"column":44},"line":55,"code":"    it('should warn on nested object handles', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => document.body);\n      let error = null;\n      await page\n        // @ts-expect-error we are deliberately passing a bad type here (nested object)\n        .evaluateHandle((opts) => opts.elem.querySelector('p'), {\n          elem: aHandle,\n        })\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain('Are you passing a nested JSHandle?');\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should accept object handle to unserializable value","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":68,"column":59},"line":68,"code":"    it('should accept object handle to unserializable value', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => Infinity);\n      expect(await page.evaluate((e) => Object.is(e, Infinity), aHandle)).toBe(\n        true\n      );\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should use the same JS wrappers","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":76,"column":39},"line":76,"code":"    it('should use the same JS wrappers', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        globalThis.FOO = 123;\n        return window;\n      });\n      expect(await page.evaluate((e: { FOO: number }) => e.FOO, aHandle)).toBe(\n        123\n      );\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.getProperty"],"updatePoint":{"line":90,"column":19},"line":90,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => ({\n        one: 1,\n        two: 2,\n        three: 3,\n      }));\n      const twoHandle = await aHandle.getProperty('two');\n      expect(await twoHandle.jsonValue()).toEqual(2);\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return a JSHandle even if the property does not exist","suites":["JSHandle","JSHandle.getProperty"],"updatePoint":{"line":102,"column":68},"line":102,"code":"    it('should return a JSHandle even if the property does not exist', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => ({\n        one: 1,\n        two: 2,\n        three: 3,\n      }));\n      const undefinedHandle = await aHandle.getProperty('doesnotexist');\n      expect(undefinedHandle).toBeInstanceOf(JSHandle);\n      expect(await undefinedHandle.jsonValue()).toBe(undefined);\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":117,"column":19},"line":117,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => ({ foo: 'bar' }));\n      const json = await aHandle.jsonValue<Record<string, string>>();\n      expect(json).toEqual({ foo: 'bar' });\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"works with jsonValues that are not objects","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":125,"column":50},"line":125,"code":"    it('works with jsonValues that are not objects', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => ['a', 'b']);\n      const json = await aHandle.jsonValue<string[]>();\n      expect(json).toEqual(['a', 'b']);\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"works with jsonValues that are primitives","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":133,"column":49},"line":133,"code":"    it('works with jsonValues that are primitives', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => 'foo');\n      const json = await aHandle.jsonValue<string>();\n      expect(json).toEqual('foo');\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for circular objects","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":150,"column":41},"line":150,"code":"    it('should throw for circular objects', async () => {\n      const { page, isChrome } = getTestState();\n\n      const windowHandle = await page.evaluateHandle('window');\n      let error = null;\n      await windowHandle.jsonValue().catch((error_) => (error = error_));\n      if (isChrome)\n        expect(error.message).toContain('Object reference chain is too long');\n      else expect(error.message).toContain('Object is not serializable');\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.getProperties"],"updatePoint":{"line":163,"column":19},"line":163,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => ({\n        foo: 'bar',\n      }));\n      const properties = await aHandle.getProperties();\n      const foo = properties.get('foo');\n      expect(foo).toBeTruthy();\n      expect(await foo.jsonValue()).toBe('bar');\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return even non-own properties","suites":["JSHandle","JSHandle.getProperties"],"updatePoint":{"line":174,"column":45},"line":174,"code":"    it('should return even non-own properties', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        class A {\n          a: string;\n          constructor() {\n            this.a = '1';\n          }\n        }\n        class B extends A {\n          b: string;\n          constructor() {\n            super();\n            this.b = '2';\n          }\n        }\n        return new B();\n      });\n      const properties = await aHandle.getProperties();\n      expect(await properties.get('a').jsonValue()).toBe('1');\n      expect(await properties.get('b').jsonValue()).toBe('2');\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.asElement"],"updatePoint":{"line":200,"column":19},"line":200,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => document.body);\n      const element = aHandle.asElement();\n      expect(element).toBeTruthy();\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-elements","suites":["JSHandle","JSHandle.asElement"],"updatePoint":{"line":207,"column":43},"line":207,"code":"    it('should return null for non-elements', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => 2);\n      const element = aHandle.asElement();\n      expect(element).toBeFalsy();\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return ElementHandle for TextNodes","suites":["JSHandle","JSHandle.asElement"],"updatePoint":{"line":214,"column":49},"line":214,"code":"    it('should return ElementHandle for TextNodes', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div>ee!</div>');\n      const aHandle = await page.evaluateHandle(\n        () => document.querySelector('div').firstChild\n      );\n      const element = aHandle.asElement();\n      expect(element).toBeTruthy();\n      expect(\n        await page.evaluate(\n          (e: HTMLElement) => e.nodeType === Node.TEXT_NODE,\n          element\n        )\n      );\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for primitives","suites":["JSHandle","JSHandle.toString"],"updatePoint":{"line":233,"column":34},"line":233,"code":"    it('should work for primitives', async () => {\n      const { page } = getTestState();\n\n      const numberHandle = await page.evaluateHandle(() => 2);\n      expect(numberHandle.toString()).toBe('JSHandle:2');\n      const stringHandle = await page.evaluateHandle(() => 'a');\n      expect(stringHandle.toString()).toBe('JSHandle:a');\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for complicated objects","suites":["JSHandle","JSHandle.toString"],"updatePoint":{"line":241,"column":43},"line":241,"code":"    it('should work for complicated objects', async () => {\n      const { page } = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => window);\n      expect(aHandle.toString()).toBe('JSHandle@object');\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work with different subtypes","suites":["JSHandle","JSHandle.toString"],"updatePoint":{"line":247,"column":43},"line":247,"code":"    it('should work with different subtypes', async () => {\n      const { page } = getTestState();\n\n      expect((await page.evaluateHandle('(function(){})')).toString()).toBe(\n        'JSHandle@function'\n      );\n      expect((await page.evaluateHandle('12')).toString()).toBe('JSHandle:12');\n      expect((await page.evaluateHandle('true')).toString()).toBe(\n        'JSHandle:true'\n      );\n      expect((await page.evaluateHandle('undefined')).toString()).toBe(\n        'JSHandle:undefined'\n      );\n      expect((await page.evaluateHandle('\"foo\"')).toString()).toBe(\n        'JSHandle:foo'\n      );\n      expect((await page.evaluateHandle('Symbol()')).toString()).toBe(\n        'JSHandle@symbol'\n      );\n      expect((await page.evaluateHandle('new Map()')).toString()).toBe(\n        'JSHandle@map'\n      );\n      expect((await page.evaluateHandle('new Set()')).toString()).toBe(\n        'JSHandle@set'\n      );\n      expect((await page.evaluateHandle('[]')).toString()).toBe(\n        'JSHandle@array'\n      );\n      expect((await page.evaluateHandle('null')).toString()).toBe(\n        'JSHandle:null'\n      );\n      expect((await page.evaluateHandle('/foo/')).toString()).toBe(\n        'JSHandle@regexp'\n      );\n      expect((await page.evaluateHandle('document.body')).toString()).toBe(\n        'JSHandle@node'\n      );\n      expect((await page.evaluateHandle('new Date()')).toString()).toBe(\n        'JSHandle@date'\n      );\n      expect((await page.evaluateHandle('new WeakMap()')).toString()).toBe(\n        'JSHandle@weakmap'\n      );\n      expect((await page.evaluateHandle('new WeakSet()')).toString()).toBe(\n        'JSHandle@weakset'\n      );\n      expect((await page.evaluateHandle('new Error()')).toString()).toBe(\n        'JSHandle@error'\n      );\n      expect((await page.evaluateHandle('new Int32Array()')).toString()).toBe(\n        'JSHandle@typedarray'\n      );\n      expect((await page.evaluateHandle('new Proxy({}, {})')).toString()).toBe(\n        'JSHandle@proxy'\n      );\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.clickablePoint"],"updatePoint":{"line":306,"column":19},"line":306,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.evaluate(() => {\n        document.body.style.padding = '0';\n        document.body.style.margin = '0';\n        document.body.innerHTML = `\n          <div style=\"cursor: pointer; width: 120px; height: 60px; margin: 30px; padding: 15px;\"></div>\n        `;\n      });\n      await page.evaluate(async () => {\n        return new Promise((resolve) => window.requestAnimationFrame(resolve));\n      });\n      const divHandle = await page.$('div');\n      expect(await divHandle.clickablePoint()).toEqual({\n        x: 45 + 60, // margin + middle point offset\n        y: 45 + 30, // margin + middle point offset\n      });\n      expect(\n        await divHandle.clickablePoint({\n          x: 10,\n          y: 15,\n        })\n      ).toEqual({\n        x: 30 + 10, // margin + offset\n        y: 30 + 15, // margin + offset\n      });\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for iframes","suites":["JSHandle","JSHandle.clickablePoint"],"updatePoint":{"line":335,"column":31},"line":335,"code":"    it('should work for iframes', async () => {\n      const { page } = getTestState();\n      await page.evaluate(() => {\n        document.body.style.padding = '10px';\n        document.body.style.margin = '10px';\n        document.body.innerHTML = `\n          <iframe style=\"border: none; margin: 0; padding: 0;\" seamless sandbox srcdoc=\"<style>* { margin: 0; padding: 0;}</style><div style='cursor: pointer; width: 120px; height: 60px; margin: 30px; padding: 15px;' />\"></iframe>\n        `;\n      });\n      await page.evaluate(async () => {\n        return new Promise((resolve) => window.requestAnimationFrame(resolve));\n      });\n      const frame = page.frames()[1];\n      const divHandle = await frame.$('div');\n      expect(await divHandle.clickablePoint()).toEqual({\n        x: 20 + 45 + 60, // iframe pos + margin + middle point offset\n        y: 20 + 45 + 30, // iframe pos + margin + middle point offset\n      });\n      expect(\n        await divHandle.clickablePoint({\n          x: 10,\n          y: 15,\n        })\n      ).toEqual({\n        x: 20 + 30 + 10, // iframe pos + margin + offset\n        y: 20 + 30 + 15, // iframe pos + margin + offset\n      });\n    });","file":"jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should type into a textarea","suites":["Keyboard"],"updatePoint":{"line":32,"column":33},"line":32,"code":"  it('should type into a textarea', async () => {\n    const { page } = getTestState();\n\n    await page.evaluate(() => {\n      const textarea = document.createElement('textarea');\n      document.body.appendChild(textarea);\n      textarea.focus();\n    });\n    const text = 'Hello world. I am the text that was typed!';\n    await page.keyboard.type(text);\n    expect(\n      await page.evaluate(() => document.querySelector('textarea').value)\n    ).toBe(text);\n  });","file":"keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should move with the arrow keys","suites":["Keyboard"],"updatePoint":{"line":59,"column":37},"line":59,"code":"  it('should move with the arrow keys', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.type('textarea', 'Hello World!');\n    expect(\n      await page.evaluate(() => document.querySelector('textarea').value)\n    ).toBe('Hello World!');\n    for (let i = 0; i < 'World!'.length; i++) page.keyboard.press('ArrowLeft');\n    await page.keyboard.type('inserted ');\n    expect(\n      await page.evaluate(() => document.querySelector('textarea').value)\n    ).toBe('Hello inserted World!');\n    page.keyboard.down('Shift');\n    for (let i = 0; i < 'inserted '.length; i++)\n      page.keyboard.press('ArrowLeft');\n    page.keyboard.up('Shift');\n    await page.keyboard.press('Backspace');\n    expect(\n      await page.evaluate(() => document.querySelector('textarea').value)\n    ).toBe('Hello World!');\n  });","file":"keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should send a character with ElementHandle.press","suites":["Keyboard"],"updatePoint":{"line":81,"column":54},"line":81,"code":"  it('should send a character with ElementHandle.press', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    const textarea = await page.$('textarea');\n    await textarea.press('a');\n    expect(\n      await page.evaluate(() => document.querySelector('textarea').value)\n    ).toBe('a');\n\n    await page.evaluate(() =>\n      window.addEventListener('keydown', (e) => e.preventDefault(), true)\n    );\n\n    await textarea.press('b');\n    expect(\n      await page.evaluate(() => document.querySelector('textarea').value)\n    ).toBe('a');\n  });","file":"keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should report multiple modifiers","suites":["Keyboard"],"updatePoint":{"line":184,"column":38},"line":184,"code":"  it('should report multiple modifiers', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/keyboard.html');\n    const keyboard = page.keyboard;\n    await keyboard.down('Control');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      'Keydown: Control ControlLeft 17 [Control]'\n    );\n    await keyboard.down('Alt');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      'Keydown: Alt AltLeft 18 [Alt Control]'\n    );\n    await keyboard.down(';');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      'Keydown: ; Semicolon 186 [Alt Control]'\n    );\n    await keyboard.up(';');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      'Keyup: ; Semicolon 186 [Alt Control]'\n    );\n    await keyboard.up('Control');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      'Keyup: Control ControlLeft 17 [Alt]'\n    );\n    await keyboard.up('Alt');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      'Keyup: Alt AltLeft 18 []'\n    );\n  });","file":"keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should send proper codes while typing","suites":["Keyboard"],"updatePoint":{"line":214,"column":43},"line":214,"code":"  it('should send proper codes while typing', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/keyboard.html');\n    await page.keyboard.type('!');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      [\n        'Keydown: ! Digit1 49 []',\n        'Keypress: ! Digit1 33 33 []',\n        'Keyup: ! Digit1 49 []',\n      ].join('\\n')\n    );\n    await page.keyboard.type('^');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      [\n        'Keydown: ^ Digit6 54 []',\n        'Keypress: ^ Digit6 94 94 []',\n        'Keyup: ^ Digit6 54 []',\n      ].join('\\n')\n    );\n  });","file":"keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should send proper codes while typing with shift","suites":["Keyboard"],"updatePoint":{"line":235,"column":54},"line":235,"code":"  it('should send proper codes while typing with shift', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/keyboard.html');\n    const keyboard = page.keyboard;\n    await keyboard.down('Shift');\n    await page.keyboard.type('~');\n    expect(await page.evaluate(() => globalThis.getResult())).toBe(\n      [\n        'Keydown: Shift ShiftLeft 16 [Shift]',\n        'Keydown: ~ Backquote 192 [Shift]', // 192 is ` keyCode\n        'Keypress: ~ Backquote 126 126 [Shift]', // 126 is ~ charCode\n        'Keyup: ~ Backquote 192 [Shift]',\n      ].join('\\n')\n    );\n    await keyboard.up('Shift');\n  });","file":"keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should not type canceled events","suites":["Keyboard"],"updatePoint":{"line":252,"column":37},"line":252,"code":"  it('should not type canceled events', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    await page.evaluate(() => {\n      window.addEventListener(\n        'keydown',\n        (event) => {\n          event.stopPropagation();\n          event.stopImmediatePropagation();\n          if (event.key === 'l') event.preventDefault();\n          if (event.key === 'o') event.preventDefault();\n        },\n        false\n      );\n    });\n    await page.keyboard.type('Hello World!');\n    expect(await page.evaluate(() => globalThis.textarea.value)).toBe(\n      'He Wrd!'\n    );\n  });","file":"keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should throw on unknown keys","suites":["Keyboard"],"updatePoint":{"line":332,"column":34},"line":332,"code":"  it('should throw on unknown keys', async () => {\n    const { page } = getTestState();\n\n    let error = await page.keyboard\n      // @ts-expect-error bad input\n      .press('NotARealKey')\n      .catch((error_) => error_);\n    expect(error.message).toBe('Unknown key: \"NotARealKey\"');\n\n    // @ts-expect-error bad input\n    error = await page.keyboard.press('ё').catch((error_) => error_);\n    expect(error && error.message).toBe('Unknown key: \"ё\"');\n\n    // @ts-expect-error bad input\n    error = await page.keyboard.press('😊').catch((error_) => error_);\n    expect(error && error.message).toBe('Unknown key: \"😊\"');\n  });","file":"keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should download and extract chrome linux binary","suites":["Launcher specs","Puppeteer","BrowserFetcher"],"updatePoint":{"line":48,"column":57},"line":48,"code":"      it('should download and extract chrome linux binary', async () => {\n        const { server, puppeteer } = getTestState();\n\n        const downloadsFolder = await mkdtempAsync(TMP_FOLDER);\n        const browserFetcher = puppeteer.createBrowserFetcher({\n          platform: 'linux',\n          path: downloadsFolder,\n          host: server.PREFIX,\n        });\n        const expectedRevision = '123456';\n        let revisionInfo = browserFetcher.revisionInfo(expectedRevision);\n        server.setRoute(\n          revisionInfo.url.substring(server.PREFIX.length),\n          (req, res) => {\n            server.serveFile(req, res, '/chromium-linux.zip');\n          }\n        );\n\n        expect(revisionInfo.local).toBe(false);\n        expect(browserFetcher.platform()).toBe('linux');\n        expect(browserFetcher.product()).toBe('chrome');\n        expect(!!browserFetcher.host()).toBe(true);\n        expect(await browserFetcher.canDownload('100000')).toBe(false);\n        expect(await browserFetcher.canDownload(expectedRevision)).toBe(true);\n\n        revisionInfo = await browserFetcher.download(expectedRevision);\n        expect(revisionInfo.local).toBe(true);\n        expect(await readFileAsync(revisionInfo.executablePath, 'utf8')).toBe(\n          'LINUX BINARY\\n'\n        );\n        const expectedPermissions = os.platform() === 'win32' ? 0o666 : 0o755;\n        expect(\n          (await statAsync(revisionInfo.executablePath)).mode & 0o777\n        ).toBe(expectedPermissions);\n        expect(await browserFetcher.localRevisions()).toEqual([\n          expectedRevision,\n        ]);\n        await browserFetcher.remove(expectedRevision);\n        expect(await browserFetcher.localRevisions()).toEqual([]);\n        await rmAsync(downloadsFolder);\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should download and extract firefox linux binary","suites":["Launcher specs","Puppeteer","BrowserFetcher"],"updatePoint":{"line":89,"column":58},"line":89,"code":"      it('should download and extract firefox linux binary', async () => {\n        const { server, puppeteer } = getTestState();\n\n        const downloadsFolder = await mkdtempAsync(TMP_FOLDER);\n        const browserFetcher = puppeteer.createBrowserFetcher({\n          platform: 'linux',\n          path: downloadsFolder,\n          host: server.PREFIX,\n          product: 'firefox',\n        });\n        const expectedVersion = '75.0a1';\n        let revisionInfo = browserFetcher.revisionInfo(expectedVersion);\n        server.setRoute(\n          revisionInfo.url.substring(server.PREFIX.length),\n          (req, res) => {\n            server.serveFile(\n              req,\n              res,\n              `/firefox-${expectedVersion}.en-US.linux-x86_64.tar.bz2`\n            );\n          }\n        );\n\n        expect(revisionInfo.local).toBe(false);\n        expect(browserFetcher.platform()).toBe('linux');\n        expect(browserFetcher.product()).toBe('firefox');\n        expect(await browserFetcher.canDownload('100000')).toBe(false);\n        expect(await browserFetcher.canDownload(expectedVersion)).toBe(true);\n\n        revisionInfo = await browserFetcher.download(expectedVersion);\n        expect(revisionInfo.local).toBe(true);\n        expect(await readFileAsync(revisionInfo.executablePath, 'utf8')).toBe(\n          'FIREFOX LINUX BINARY\\n'\n        );\n        const expectedPermissions = os.platform() === 'win32' ? 0o666 : 0o755;\n        expect(\n          (await statAsync(revisionInfo.executablePath)).mode & 0o777\n        ).toBe(expectedPermissions);\n        expect(await browserFetcher.localRevisions()).toEqual([\n          expectedVersion,\n        ]);\n        await browserFetcher.remove(expectedVersion);\n        expect(await browserFetcher.localRevisions()).toEqual([]);\n        await rmAsync(downloadsFolder);\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should reject navigation when browser closes","suites":["Launcher specs","Puppeteer","Browser.disconnect"],"updatePoint":{"line":137,"column":54},"line":137,"code":"      it('should reject navigation when browser closes', async () => {\n        const { server, puppeteer, defaultBrowserOptions } = getTestState();\n        server.setRoute('/one-style.css', () => {});\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const remote = await puppeteer.connect({\n          browserWSEndpoint: browser.wsEndpoint(),\n        });\n        const page = await remote.newPage();\n        const navigationPromise = page\n          .goto(server.PREFIX + '/one-style.html', { timeout: 60000 })\n          .catch((error_) => error_);\n        await server.waitForRequest('/one-style.css');\n        remote.disconnect();\n        const error = await navigationPromise;\n        expect(error.message).toBe(\n          'Navigation failed because browser has disconnected!'\n        );\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should reject waitForSelector when browser closes","suites":["Launcher specs","Puppeteer","Browser.disconnect"],"updatePoint":{"line":156,"column":59},"line":156,"code":"      it('should reject waitForSelector when browser closes', async () => {\n        const { server, puppeteer, defaultBrowserOptions } = getTestState();\n\n        server.setRoute('/empty.html', () => {});\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const remote = await puppeteer.connect({\n          browserWSEndpoint: browser.wsEndpoint(),\n        });\n        const page = await remote.newPage();\n        const watchdog = page\n          .waitForSelector('div', { timeout: 60000 })\n          .catch((error_) => error_);\n        remote.disconnect();\n        const error = await watchdog;\n        expect(error.message).toContain('Protocol error');\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should terminate network waiters","suites":["Launcher specs","Puppeteer","Browser.close"],"updatePoint":{"line":175,"column":42},"line":175,"code":"      it('should terminate network waiters', async () => {\n        const { server, puppeteer, defaultBrowserOptions } = getTestState();\n\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const remote = await puppeteer.connect({\n          browserWSEndpoint: browser.wsEndpoint(),\n        });\n        const newPage = await remote.newPage();\n        const results = await Promise.all([\n          newPage.waitForRequest(server.EMPTY_PAGE).catch((error) => error),\n          newPage.waitForResponse(server.EMPTY_PAGE).catch((error) => error),\n          browser.close(),\n        ]);\n        for (let i = 0; i < 2; i++) {\n          const message = results[i].message;\n          expect(message).toContain('Target closed');\n          expect(message).not.toContain('Timeout');\n        }\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should reject all promises when browser is closed","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":197,"column":59},"line":197,"code":"      it('should reject all promises when browser is closed', async () => {\n        const { defaultBrowserOptions, puppeteer } = getTestState();\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const page = await browser.newPage();\n        let error = null;\n        const neverResolves = page\n          .evaluate(() => new Promise(() => {}))\n          .catch((error_) => (error = error_));\n        await browser.close();\n        await neverResolves;\n        expect(error.message).toContain('Protocol error');\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should reject if executable path is invalid","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":209,"column":53},"line":209,"code":"      it('should reject if executable path is invalid', async () => {\n        const { defaultBrowserOptions, puppeteer } = getTestState();\n\n        let waitError = null;\n        const options = Object.assign({}, defaultBrowserOptions, {\n          executablePath: 'random-invalid-path',\n        });\n        await puppeteer.launch(options).catch((error) => (waitError = error));\n        expect(waitError.message).toContain('Failed to launch');\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir option","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":219,"column":28},"line":219,"code":"      it('userDataDir option', async () => {\n        const { defaultBrowserOptions, puppeteer } = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        const options = Object.assign({ userDataDir }, defaultBrowserOptions);\n        const browser = await puppeteer.launch(options);\n        // Open a page to make sure its functional.\n        await browser.newPage();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        await browser.close();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir argument","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":255,"column":30},"line":255,"code":"      it('userDataDir argument', async () => {\n        const { isChrome, puppeteer, defaultBrowserOptions } = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        const options = Object.assign({}, defaultBrowserOptions);\n        if (isChrome) {\n          options.args = [\n            ...(defaultBrowserOptions.args || []),\n            `--user-data-dir=${userDataDir}`,\n          ];\n        } else {\n          options.args = [\n            ...(defaultBrowserOptions.args || []),\n            '-profile',\n            userDataDir,\n          ];\n        }\n        const browser = await puppeteer.launch(options);\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        await browser.close();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir option should restore state","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":279,"column":49},"line":279,"code":"      it('userDataDir option should restore state', async () => {\n        const { server, puppeteer, defaultBrowserOptions } = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        const options = Object.assign({ userDataDir }, defaultBrowserOptions);\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        await page.goto(server.EMPTY_PAGE);\n        await page.evaluate(() => (localStorage.hey = 'hello'));\n        await browser.close();\n\n        const browser2 = await puppeteer.launch(options);\n        const page2 = await browser2.newPage();\n        await page2.goto(server.EMPTY_PAGE);\n        expect(await page2.evaluate(() => localStorage.hey)).toBe('hello');\n        await browser2.close();\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir option should restore cookies","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":300,"column":52},"line":300,"code":"      xit('userDataDir option should restore cookies', async () => {\n        const { server, puppeteer, defaultBrowserOptions } = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        const options = Object.assign({ userDataDir }, defaultBrowserOptions);\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        await page.goto(server.EMPTY_PAGE);\n        await page.evaluate(\n          () =>\n            (document.cookie =\n              'doSomethingOnlyOnce=true; expires=Fri, 31 Dec 9999 23:59:59 GMT')\n        );\n        await browser.close();\n\n        const browser2 = await puppeteer.launch(options);\n        const page2 = await browser2.newPage();\n        await page2.goto(server.EMPTY_PAGE);\n        expect(await page2.evaluate(() => document.cookie)).toBe(\n          'doSomethingOnlyOnce=true'\n        );\n        await browser2.close();\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","skipped":true,"file":"launcher.spec.ts","dir":"test"},{"name":"should return the default arguments","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":325,"column":45},"line":325,"code":"      it('should return the default arguments', async () => {\n        const { isChrome, isFirefox, puppeteer } = getTestState();\n\n        if (isChrome) {\n          expect(puppeteer.defaultArgs()).toContain('--no-first-run');\n          expect(puppeteer.defaultArgs()).toContain('--headless');\n          expect(puppeteer.defaultArgs({ headless: false })).not.toContain(\n            '--headless'\n          );\n          expect(puppeteer.defaultArgs({ userDataDir: 'foo' })).toContain(\n            `--user-data-dir=${path.resolve('foo')}`\n          );\n        } else if (isFirefox) {\n          expect(puppeteer.defaultArgs()).toContain('--headless');\n          expect(puppeteer.defaultArgs()).toContain('--no-remote');\n          if (os.platform() === 'darwin') {\n            expect(puppeteer.defaultArgs()).toContain('--foreground');\n          } else {\n            expect(puppeteer.defaultArgs()).not.toContain('--foreground');\n          }\n          expect(puppeteer.defaultArgs({ headless: false })).not.toContain(\n            '--headless'\n          );\n          expect(puppeteer.defaultArgs({ userDataDir: 'foo' })).toContain(\n            '--profile'\n          );\n          expect(puppeteer.defaultArgs({ userDataDir: 'foo' })).toContain(\n            'foo'\n          );\n        } else {\n          expect(puppeteer.defaultArgs()).toContain('-headless');\n          expect(puppeteer.defaultArgs({ headless: false })).not.toContain(\n            '-headless'\n          );\n          expect(puppeteer.defaultArgs({ userDataDir: 'foo' })).toContain(\n            '-profile'\n          );\n          expect(puppeteer.defaultArgs({ userDataDir: 'foo' })).toContain(\n            path.resolve('foo')\n          );\n        }\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should report the correct product","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":367,"column":43},"line":367,"code":"      it('should report the correct product', async () => {\n        const { isChrome, isFirefox, puppeteer } = getTestState();\n        if (isChrome) expect(puppeteer.product).toBe('chrome');\n        else if (isFirefox) expect(puppeteer.product).toBe('firefox');\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no default arguments","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":372,"column":47},"line":372,"code":"      it('should work with no default arguments', async () => {\n        const { defaultBrowserOptions, puppeteer } = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions);\n        options.ignoreDefaultArgs = true;\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        expect(await page.evaluate('11 * 11')).toBe(121);\n        await page.close();\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should filter out ignored default arguments","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":382,"column":53},"line":382,"code":"      it('should filter out ignored default arguments', async () => {\n        const { defaultBrowserOptions, puppeteer } = getTestState();\n        // Make sure we launch with `--enable-automation` by default.\n        const defaultArgs = puppeteer.defaultArgs();\n        const browser = await puppeteer.launch(\n          Object.assign({}, defaultBrowserOptions, {\n            // Ignore first and third default argument.\n            ignoreDefaultArgs: [defaultArgs[0], defaultArgs[2]],\n          })\n        );\n        const spawnargs = browser.process().spawnargs;\n        if (!spawnargs) {\n          throw new Error('spawnargs not present');\n        }\n        expect(spawnargs.indexOf(defaultArgs[0])).toBe(-1);\n        expect(spawnargs.indexOf(defaultArgs[1])).not.toBe(-1);\n        expect(spawnargs.indexOf(defaultArgs[2])).toBe(-1);\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should have default URL when launching browser","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":401,"column":56},"line":401,"code":"      it('should have default URL when launching browser', async function () {\n        const { defaultBrowserOptions, puppeteer } = getTestState();\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const pages = (await browser.pages()).map((page) => page.url());\n        expect(pages).toEqual(['about:blank']);\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should have custom URL when launching browser","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":408,"column":55},"line":408,"code":"      it('should have custom URL when launching browser', async () => {\n        const { server, puppeteer, defaultBrowserOptions } = getTestState();\n\n        const options = Object.assign({}, defaultBrowserOptions);\n        options.args = [server.EMPTY_PAGE].concat(options.args || []);\n        const browser = await puppeteer.launch(options);\n        const pages = await browser.pages();\n        expect(pages.length).toBe(1);\n        const page = pages[0];\n        if (page.url() !== server.EMPTY_PAGE) await page.waitForNavigation();\n        expect(page.url()).toBe(server.EMPTY_PAGE);\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should pass the timeout parameter to browser.waitForTarget","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":421,"column":68},"line":421,"code":"      it('should pass the timeout parameter to browser.waitForTarget', async () => {\n        const { puppeteer, defaultBrowserOptions } = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions, {\n          timeout: 1,\n        });\n        let error = null;\n        await puppeteer.launch(options).catch((error_) => (error = error_));\n        expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should set the default viewport","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":430,"column":41},"line":430,"code":"      it('should set the default viewport', async () => {\n        const { puppeteer, defaultBrowserOptions } = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: {\n            width: 456,\n            height: 789,\n          },\n        });\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        expect(await page.evaluate('window.innerWidth')).toBe(456);\n        expect(await page.evaluate('window.innerHeight')).toBe(789);\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should disable the default viewport","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":444,"column":45},"line":444,"code":"      it('should disable the default viewport', async () => {\n        const { puppeteer, defaultBrowserOptions } = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: null,\n        });\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        expect(page.viewport()).toBe(null);\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should take fullPage screenshots when defaultViewport is null","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":454,"column":71},"line":454,"code":"      it('should take fullPage screenshots when defaultViewport is null', async () => {\n        const { server, puppeteer, defaultBrowserOptions } = getTestState();\n\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: null,\n        });\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        await page.goto(server.PREFIX + '/grid.html');\n        const screenshot = await page.screenshot({\n          fullPage: true,\n        });\n        expect(screenshot).toBeInstanceOf(Buffer);\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should set the debugging port","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":469,"column":39},"line":469,"code":"      it('should set the debugging port', async () => {\n        const { puppeteer, defaultBrowserOptions } = getTestState();\n\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: null,\n          debuggingPort: 9999,\n        });\n        const browser = await puppeteer.launch(options);\n        const url = new URL(browser.wsEndpoint());\n        await browser.close();\n        expect(url.port).toBe('9999');\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should not allow setting debuggingPort and pipe","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":481,"column":57},"line":481,"code":"      it('should not allow setting debuggingPort and pipe', async () => {\n        const { puppeteer, defaultBrowserOptions } = getTestState();\n\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: null,\n          debuggingPort: 9999,\n          pipe: true,\n        });\n\n        let error = null;\n        await puppeteer.launch(options).catch((error_) => (error = error_));\n        expect(error.message).toContain('either pipe or debugging port');\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to connect multiple times to the same browser","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":571,"column":70},"line":571,"code":"      it('should be able to connect multiple times to the same browser', async () => {\n        const { puppeteer, defaultBrowserOptions } = getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const otherBrowser = await puppeteer.connect({\n          browserWSEndpoint: originalBrowser.wsEndpoint(),\n        });\n        const page = await otherBrowser.newPage();\n        expect(await page.evaluate(() => 7 * 8)).toBe(56);\n        otherBrowser.disconnect();\n\n        const secondPage = await originalBrowser.newPage();\n        expect(await secondPage.evaluate(() => 7 * 6)).toBe(42);\n        await originalBrowser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to close remote browser","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":586,"column":48},"line":586,"code":"      it('should be able to close remote browser', async () => {\n        const { defaultBrowserOptions, puppeteer } = getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const remoteBrowser = await puppeteer.connect({\n          browserWSEndpoint: originalBrowser.wsEndpoint(),\n        });\n        await Promise.all([\n          utils.waitEvent(originalBrowser, 'disconnected'),\n          remoteBrowser.close(),\n        ]);\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should support ignoreHTTPSErrors option","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":598,"column":49},"line":598,"code":"      it('should support ignoreHTTPSErrors option', async () => {\n        const { httpsServer, puppeteer, defaultBrowserOptions } =\n          getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const browserWSEndpoint = originalBrowser.wsEndpoint();\n\n        const browser = await puppeteer.connect({\n          browserWSEndpoint,\n          ignoreHTTPSErrors: true,\n        });\n        const page = await browser.newPage();\n        let error = null;\n        const [serverRequest, response] = await Promise.all([\n          httpsServer.waitForRequest('/empty.html'),\n          page.goto(httpsServer.EMPTY_PAGE).catch((error_) => (error = error_)),\n        ]);\n        expect(error).toBe(null);\n        expect(response.ok()).toBe(true);\n        expect(response.securityDetails()).toBeTruthy();\n        const protocol = serverRequest.socket.getProtocol().replace('v', ' ');\n        expect(response.securityDetails().protocol()).toBe(protocol);\n        await page.close();\n        await browser.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to reconnect","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":703,"column":37},"line":703,"code":"      it('should be able to reconnect', async () => {\n        const { puppeteer, server } = getTestState();\n        const browserOne = await puppeteer.launch();\n        const browserWSEndpoint = browserOne.wsEndpoint();\n        const pageOne = await browserOne.newPage();\n        await pageOne.goto(server.EMPTY_PAGE);\n        browserOne.disconnect();\n\n        const browserTwo = await puppeteer.connect({ browserWSEndpoint });\n        const pages = await browserTwo.pages();\n        const pageTwo = pages.find((page) => page.url() === server.EMPTY_PAGE);\n        await pageTwo.reload();\n        const bodyHandle = await pageTwo.waitForSelector('body', {\n          timeout: 10000,\n        });\n        await bodyHandle.dispose();\n        await browserTwo.close();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"returns executablePath for channel","suites":["Launcher specs","Puppeteer","Puppeteer.executablePath"],"updatePoint":{"line":730,"column":44},"line":730,"code":"      it('returns executablePath for channel', () => {\n        const { puppeteer } = getTestState();\n\n        const executablePath = puppeteer.executablePath('chrome');\n        expect(executablePath).toBeTruthy();\n      });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"its value is returned","suites":["Launcher specs","Puppeteer","Puppeteer.executablePath","when PUPPETEER_EXECUTABLE_PATH is set"],"updatePoint":{"line":748,"column":33},"line":748,"code":"        it('its value is returned', async () => {\n          const { puppeteer } = getTestState();\n\n          const executablePath = puppeteer.executablePath();\n\n          expect(executablePath).toEqual('SOME_CUSTOM_EXECUTABLE');\n        });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"its value is returned","suites":["Launcher specs","Puppeteer","Puppeteer.executablePath","when the product is chrome, platform is not darwin, and arch is arm64","and the executable exists","and PUPPETEER_EXECUTABLE_PATH is set"],"updatePoint":{"line":786,"column":37},"line":786,"code":"            it('its value is returned', async () => {\n              const { puppeteer } = getTestState();\n\n              const executablePath = puppeteer.executablePath();\n\n              expect(executablePath).toEqual('SOME_CUSTOM_EXECUTABLE');\n            });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be emitted when: browser gets closed, disconnected or underlying websocket gets closed","suites":["Launcher specs","Browser.Events.disconnected"],"updatePoint":{"line":839,"column":101},"line":839,"code":"    it('should be emitted when: browser gets closed, disconnected or underlying websocket gets closed', async () => {\n      const { puppeteer, defaultBrowserOptions } = getTestState();\n      const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n      const browserWSEndpoint = originalBrowser.wsEndpoint();\n      const remoteBrowser1 = await puppeteer.connect({ browserWSEndpoint });\n      const remoteBrowser2 = await puppeteer.connect({ browserWSEndpoint });\n\n      let disconnectedOriginal = 0;\n      let disconnectedRemote1 = 0;\n      let disconnectedRemote2 = 0;\n      originalBrowser.on('disconnected', () => ++disconnectedOriginal);\n      remoteBrowser1.on('disconnected', () => ++disconnectedRemote1);\n      remoteBrowser2.on('disconnected', () => ++disconnectedRemote2);\n\n      await Promise.all([\n        utils.waitEvent(remoteBrowser2, 'disconnected'),\n        remoteBrowser2.disconnect(),\n      ]);\n\n      expect(disconnectedOriginal).toBe(0);\n      expect(disconnectedRemote1).toBe(0);\n      expect(disconnectedRemote2).toBe(1);\n\n      await Promise.all([\n        utils.waitEvent(remoteBrowser1, 'disconnected'),\n        utils.waitEvent(originalBrowser, 'disconnected'),\n        originalBrowser.close(),\n      ]);\n\n      expect(disconnectedOriginal).toBe(1);\n      expect(disconnectedRemote1).toBe(1);\n      expect(disconnectedRemote2).toBe(1);\n    });","file":"launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should click the document","suites":["Mouse"],"updatePoint":{"line":46,"column":31},"line":46,"code":"  it('should click the document', async () => {\n    const { page } = getTestState();\n\n    await page.evaluate(() => {\n      globalThis.clickPromise = new Promise((resolve) => {\n        document.addEventListener('click', (event) => {\n          resolve({\n            type: event.type,\n            detail: event.detail,\n            clientX: event.clientX,\n            clientY: event.clientY,\n            isTrusted: event.isTrusted,\n            button: event.button,\n          });\n        });\n      });\n    });\n    await page.mouse.click(50, 60);\n    const event = await page.evaluate<() => MouseEvent>(\n      () => globalThis.clickPromise\n    );\n    expect(event.type).toBe('click');\n    expect(event.detail).toBe(1);\n    expect(event.clientX).toBe(50);\n    expect(event.clientY).toBe(60);\n    expect(event.isTrusted).toBe(true);\n    expect(event.button).toBe(0);\n  });","file":"mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should resize the textarea","suites":["Mouse"],"updatePoint":{"line":74,"column":32},"line":74,"code":"  it('should resize the textarea', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    const { x, y, width, height } = await page.evaluate<() => Dimensions>(\n      dimensions\n    );\n    const mouse = page.mouse;\n    await mouse.move(x + width - 4, y + height - 4);\n    await mouse.down();\n    await mouse.move(x + width + 100, y + height + 100);\n    await mouse.up();\n    const newDimensions = await page.evaluate<() => Dimensions>(dimensions);\n    expect(newDimensions.width).toBe(Math.round(width + 104));\n    expect(newDimensions.height).toBe(Math.round(height + 104));\n  });","file":"mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should select the text with mouse","suites":["Mouse"],"updatePoint":{"line":90,"column":39},"line":90,"code":"  it('should select the text with mouse', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    const text =\n      \"This is the text that we are going to try to select. Let's see how it goes.\";\n    await page.keyboard.type(text);\n    // Firefox needs an extra frame here after typing or it will fail to set the scrollTop\n    await page.evaluate(() => new Promise(requestAnimationFrame));\n    await page.evaluate(\n      () => (document.querySelector('textarea').scrollTop = 0)\n    );\n    const { x, y } = await page.evaluate(dimensions);\n    await page.mouse.move(x + 2, y + 2);\n    await page.mouse.down();\n    await page.mouse.move(100, 100);\n    await page.mouse.up();\n    expect(\n      await page.evaluate(() => {\n        const textarea = document.querySelector('textarea');\n        return textarea.value.substring(\n          textarea.selectionStart,\n          textarea.selectionEnd\n        );\n      })\n    ).toBe(text);\n  });","file":"mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should set modifier keys on click","suites":["Mouse"],"updatePoint":{"line":148,"column":39},"line":148,"code":"  it('should set modifier keys on click', async () => {\n    const { page, server, isFirefox } = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.evaluate(() =>\n      document\n        .querySelector('#button-3')\n        .addEventListener('mousedown', (e) => (globalThis.lastEvent = e), true)\n    );\n    const modifiers = new Map<KeyInput, string>([\n      ['Shift', 'shiftKey'],\n      ['Control', 'ctrlKey'],\n      ['Alt', 'altKey'],\n      ['Meta', 'metaKey'],\n    ]);\n    // In Firefox, the Meta modifier only exists on Mac\n    if (isFirefox && os.platform() !== 'darwin') delete modifiers['Meta'];\n    for (const [modifier, key] of modifiers) {\n      await page.keyboard.down(modifier);\n      await page.click('#button-3');\n      if (\n        !(await page.evaluate((mod: string) => globalThis.lastEvent[mod], key))\n      )\n        throw new Error(key + ' should be true');\n      await page.keyboard.up(modifier);\n    }\n    await page.click('#button-3');\n    for (const [modifier, key] of modifiers) {\n      if (await page.evaluate((mod: string) => globalThis.lastEvent[mod], key))\n        throw new Error(modifiers[modifier] + ' should be false');\n    }\n  });","file":"mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should work with mobile viewports and cross process navigations","suites":["Mouse"],"updatePoint":{"line":223,"column":69},"line":223,"code":"  it('should work with mobile viewports and cross process navigations', async () => {\n    const { page, server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.setViewport({ width: 360, height: 640, isMobile: true });\n    await page.goto(server.CROSS_PROCESS_PREFIX + '/mobile.html');\n    await page.evaluate(() => {\n      document.addEventListener('click', (event) => {\n        globalThis.result = { x: event.clientX, y: event.clientY };\n      });\n    });\n\n    await page.mouse.click(30, 40);\n\n    expect(await page.evaluate('result')).toEqual({ x: 30, y: 40 });\n  });","file":"mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Page.goto"],"updatePoint":{"line":32,"column":19},"line":32,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects","suites":["navigation","Page.goto"],"updatePoint":{"line":48,"column":34},"line":48,"code":"    it('should work with redirects', async () => {\n      const { page, server } = getTestState();\n\n      server.setRedirect('/redirect/1.html', '/redirect/2.html');\n      server.setRedirect('/redirect/2.html', '/empty.html');\n      await page.goto(server.PREFIX + '/redirect/1.html');\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to about:blank","suites":["navigation","Page.goto"],"updatePoint":{"line":56,"column":38},"line":56,"code":"    it('should navigate to about:blank', async () => {\n      const { page } = getTestState();\n\n      const response = await page.goto('about:blank');\n      expect(response).toBe(null);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should return response when page changes its URL after load","suites":["navigation","Page.goto"],"updatePoint":{"line":62,"column":67},"line":62,"code":"    it('should return response when page changes its URL after load', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.PREFIX + '/historyapi.html');\n      expect(response.status()).toBe(200);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to empty page with domcontentloaded","suites":["navigation","Page.goto"],"updatePoint":{"line":94,"column":59},"line":94,"code":"    it('should navigate to empty page with domcontentloaded', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE, {\n        waitUntil: 'domcontentloaded',\n      });\n      expect(response.status()).toBe(200);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work when page calls history API in beforeunload","suites":["navigation","Page.goto"],"updatePoint":{"line":102,"column":63},"line":102,"code":"    it('should work when page calls history API in beforeunload', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        window.addEventListener(\n          'beforeunload',\n          () => history.replaceState(null, 'initial', window.location.href),\n          false\n        );\n      });\n      const response = await page.goto(server.PREFIX + '/grid.html');\n      expect(response.status()).toBe(200);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when navigating to bad SSL after redirects","suites":["navigation","Page.goto"],"updatePoint":{"line":179,"column":62},"line":179,"code":"    it('should fail when navigating to bad SSL after redirects', async () => {\n      const { page, server, httpsServer, isChrome } = getTestState();\n\n      server.setRedirect('/redirect/1.html', '/redirect/2.html');\n      server.setRedirect('/redirect/2.html', '/empty.html');\n      let error = null;\n      await page\n        .goto(httpsServer.PREFIX + '/redirect/1.html')\n        .catch((error_) => (error = error_));\n      if (isChrome) expect(error.message).toContain(EXPECTED_SSL_CERT_MESSAGE);\n      else expect(error.message).toContain('SSL_ERROR_UNKNOWN');\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if networkidle is passed as an option","suites":["navigation","Page.goto"],"updatePoint":{"line":191,"column":58},"line":191,"code":"    it('should throw if networkidle is passed as an option', async () => {\n      const { page, server } = getTestState();\n\n      let error = null;\n      await page\n        // @ts-expect-error purposefully passing an old option\n        .goto(server.EMPTY_PAGE, { waitUntil: 'networkidle' })\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain(\n        '\"networkidle\" option is no longer supported'\n      );\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when main resources failed to load","suites":["navigation","Page.goto"],"updatePoint":{"line":203,"column":54},"line":203,"code":"    it('should fail when main resources failed to load', async () => {\n      const { page, isChrome } = getTestState();\n\n      let error = null;\n      await page\n        .goto('http://localhost:44123/non-existing-url')\n        .catch((error_) => (error = error_));\n      if (isChrome)\n        expect(error.message).toContain('net::ERR_CONNECTION_REFUSED');\n      else expect(error.message).toContain('NS_ERROR_CONNECTION_REFUSED');\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when exceeding maximum navigation timeout","suites":["navigation","Page.goto"],"updatePoint":{"line":214,"column":61},"line":214,"code":"    it('should fail when exceeding maximum navigation timeout', async () => {\n      const { page, server, puppeteer } = getTestState();\n\n      // Hang for request to the empty.html\n      server.setRoute('/empty.html', () => {});\n      let error = null;\n      await page\n        .goto(server.PREFIX + '/empty.html', { timeout: 1 })\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain('Navigation timeout of 1 ms exceeded');\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when exceeding default maximum navigation timeout","suites":["navigation","Page.goto"],"updatePoint":{"line":226,"column":69},"line":226,"code":"    it('should fail when exceeding default maximum navigation timeout', async () => {\n      const { page, server, puppeteer } = getTestState();\n\n      // Hang for request to the empty.html\n      server.setRoute('/empty.html', () => {});\n      let error = null;\n      page.setDefaultNavigationTimeout(1);\n      await page\n        .goto(server.PREFIX + '/empty.html')\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain('Navigation timeout of 1 ms exceeded');\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when exceeding default maximum timeout","suites":["navigation","Page.goto"],"updatePoint":{"line":239,"column":58},"line":239,"code":"    it('should fail when exceeding default maximum timeout', async () => {\n      const { page, server, puppeteer } = getTestState();\n\n      // Hang for request to the empty.html\n      server.setRoute('/empty.html', () => {});\n      let error = null;\n      page.setDefaultTimeout(1);\n      await page\n        .goto(server.PREFIX + '/empty.html')\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain('Navigation timeout of 1 ms exceeded');\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should prioritize default navigation timeout over default timeout","suites":["navigation","Page.goto"],"updatePoint":{"line":252,"column":73},"line":252,"code":"    it('should prioritize default navigation timeout over default timeout', async () => {\n      const { page, server, puppeteer } = getTestState();\n\n      // Hang for request to the empty.html\n      server.setRoute('/empty.html', () => {});\n      let error = null;\n      page.setDefaultTimeout(0);\n      page.setDefaultNavigationTimeout(1);\n      await page\n        .goto(server.PREFIX + '/empty.html')\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain('Navigation timeout of 1 ms exceeded');\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should disable timeout when its set to 0","suites":["navigation","Page.goto"],"updatePoint":{"line":266,"column":48},"line":266,"code":"    it('should disable timeout when its set to 0', async () => {\n      const { page, server } = getTestState();\n\n      let error = null;\n      let loaded = false;\n      page.once('load', () => (loaded = true));\n      await page\n        .goto(server.PREFIX + '/grid.html', { timeout: 0, waitUntil: ['load'] })\n        .catch((error_) => (error = error_));\n      expect(error).toBe(null);\n      expect(loaded).toBe(true);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work when navigating to valid url","suites":["navigation","Page.goto"],"updatePoint":{"line":278,"column":48},"line":278,"code":"    it('should work when navigating to valid url', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.ok()).toBe(true);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work when navigating to 404","suites":["navigation","Page.goto"],"updatePoint":{"line":290,"column":42},"line":290,"code":"    it('should work when navigating to 404', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.PREFIX + '/not-found');\n      expect(response.ok()).toBe(false);\n      expect(response.status()).toBe(404);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should return last response in redirect chain","suites":["navigation","Page.goto"],"updatePoint":{"line":297,"column":53},"line":297,"code":"    it('should return last response in redirect chain', async () => {\n      const { page, server } = getTestState();\n\n      server.setRedirect('/redirect/1.html', '/redirect/2.html');\n      server.setRedirect('/redirect/2.html', '/redirect/3.html');\n      server.setRedirect('/redirect/3.html', server.EMPTY_PAGE);\n      const response = await page.goto(server.PREFIX + '/redirect/1.html');\n      expect(response.ok()).toBe(true);\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should not leak listeners during navigation","suites":["navigation","Page.goto"],"updatePoint":{"line":382,"column":51},"line":382,"code":"    it('should not leak listeners during navigation', async () => {\n      const { page, server } = getTestState();\n\n      let warning = null;\n      const warningHandler = (w) => (warning = w);\n      process.on('warning', warningHandler);\n      for (let i = 0; i < 20; ++i) await page.goto(server.EMPTY_PAGE);\n      process.removeListener('warning', warningHandler);\n      expect(warning).toBe(null);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should not leak listeners during bad navigation","suites":["navigation","Page.goto"],"updatePoint":{"line":392,"column":55},"line":392,"code":"    it('should not leak listeners during bad navigation', async () => {\n      const { page } = getTestState();\n\n      let warning = null;\n      const warningHandler = (w) => (warning = w);\n      process.on('warning', warningHandler);\n      for (let i = 0; i < 20; ++i)\n        await page.goto('asdf').catch(() => {\n          /* swallow navigation error */\n        });\n      process.removeListener('warning', warningHandler);\n      expect(warning).toBe(null);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should not leak listeners during navigation of 11 pages","suites":["navigation","Page.goto"],"updatePoint":{"line":405,"column":63},"line":405,"code":"    it('should not leak listeners during navigation of 11 pages', async () => {\n      const { context, server } = getTestState();\n\n      let warning = null;\n      const warningHandler = (w) => (warning = w);\n      process.on('warning', warningHandler);\n      await Promise.all(\n        [...Array(20)].map(async () => {\n          const page = await context.newPage();\n          await page.goto(server.EMPTY_PAGE);\n          await page.close();\n        })\n      );\n      process.removeListener('warning', warningHandler);\n      expect(warning).toBe(null);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with self requesting page","suites":["navigation","Page.goto"],"updatePoint":{"line":455,"column":45},"line":455,"code":"    it('should work with self requesting page', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.PREFIX + '/self-request.html');\n      expect(response.status()).toBe(200);\n      expect(response.url()).toContain('self-request.html');\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when navigating and show the url at the error message","suites":["navigation","Page.goto"],"updatePoint":{"line":462,"column":73},"line":462,"code":"    it('should fail when navigating and show the url at the error message', async () => {\n      const { page, httpsServer } = getTestState();\n\n      const url = httpsServer.PREFIX + '/redirect/1.html';\n      let error = null;\n      try {\n        await page.goto(url);\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toContain(url);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with both domcontentloaded and load","suites":["navigation","Page.waitForNavigation"],"updatePoint":{"line":505,"column":55},"line":505,"code":"    it('should work with both domcontentloaded and load', async () => {\n      const { page, server } = getTestState();\n\n      let response = null;\n      server.setRoute('/one-style.css', (req, res) => (response = res));\n      const navigationPromise = page.goto(server.PREFIX + '/one-style.html');\n      const domContentLoadedPromise = page.waitForNavigation({\n        waitUntil: 'domcontentloaded',\n      });\n\n      let bothFired = false;\n      const bothFiredPromise = page\n        .waitForNavigation({\n          waitUntil: ['load', 'domcontentloaded'],\n        })\n        .then(() => (bothFired = true));\n\n      await server.waitForRequest('/one-style.css');\n      await domContentLoadedPromise;\n      expect(bothFired).toBe(false);\n      response.end();\n      await bothFiredPromise;\n      await navigationPromise;\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Page.goBack"],"updatePoint":{"line":630,"column":19},"line":630,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.goto(server.PREFIX + '/grid.html');\n\n      let response = await page.goBack();\n      expect(response.ok()).toBe(true);\n      expect(response.url()).toContain(server.EMPTY_PAGE);\n\n      response = await page.goForward();\n      expect(response.ok()).toBe(true);\n      expect(response.url()).toContain('/grid.html');\n\n      response = await page.goForward();\n      expect(response).toBe(null);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate subframes","suites":["navigation","Page.goBack"],"updatePoint":{"line":667,"column":33},"line":667,"code":"    it('should navigate subframes', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n      expect(page.frames()[0].url()).toContain('/frames/one-frame.html');\n      expect(page.frames()[1].url()).toContain('/frames/frame.html');\n\n      const response = await page.frames()[1].goto(server.EMPTY_PAGE);\n      expect(response.ok()).toBe(true);\n      expect(response.frame()).toBe(page.frames()[1]);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should reject when frame detaches","suites":["navigation","Page.goBack"],"updatePoint":{"line":678,"column":41},"line":678,"code":"    it('should reject when frame detaches', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n\n      server.setRoute('/empty.html', () => {});\n      const navigationPromise = page\n        .frames()[1]\n        .goto(server.EMPTY_PAGE)\n        .catch((error_) => error_);\n      await server.waitForRequest('/empty.html');\n\n      await page.$eval('iframe', (frame) => frame.remove());\n      const error = await navigationPromise;\n      expect(error.message).toBe('Navigating frame was detached');\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should return matching responses","suites":["navigation","Page.goBack"],"updatePoint":{"line":694,"column":40},"line":694,"code":"    it('should return matching responses', async () => {\n      const { page, server } = getTestState();\n\n      // Disable cache: otherwise, chromium will cache similar requests.\n      await page.setCacheEnabled(false);\n      await page.goto(server.EMPTY_PAGE);\n      // Attach three frames.\n      const frames = await Promise.all([\n        utils.attachFrame(page, 'frame1', server.EMPTY_PAGE),\n        utils.attachFrame(page, 'frame2', server.EMPTY_PAGE),\n        utils.attachFrame(page, 'frame3', server.EMPTY_PAGE),\n      ]);\n      // Navigate all frames to the same URL.\n      const serverResponses = [];\n      server.setRoute('/one-style.html', (req, res) =>\n        serverResponses.push(res)\n      );\n      const navigations = [];\n      for (let i = 0; i < 3; ++i) {\n        navigations.push(frames[i].goto(server.PREFIX + '/one-style.html'));\n        await server.waitForRequest('/one-style.html');\n      }\n      // Respond from server out-of-order.\n      const serverResponseTexts = ['AAA', 'BBB', 'CCC'];\n      for (const i of [1, 2, 0]) {\n        serverResponses[i].end(serverResponseTexts[i]);\n        const response = await navigations[i];\n        expect(response.frame()).toBe(frames[i]);\n        expect(await response.text()).toBe(serverResponseTexts[i]);\n      }\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Page.goBack"],"updatePoint":{"line":728,"column":19},"line":728,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n      const frame = page.frames()[1];\n      const [response] = await Promise.all([\n        frame.waitForNavigation(),\n        frame.evaluate(\n          (url: string) => (window.location.href = url),\n          server.PREFIX + '/grid.html'\n        ),\n      ]);\n      expect(response.ok()).toBe(true);\n      expect(response.url()).toContain('grid.html');\n      expect(response.frame()).toBe(frame);\n      expect(page.url()).toContain('/frames/one-frame.html');\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when frame detaches","suites":["navigation","Page.goBack"],"updatePoint":{"line":745,"column":39},"line":745,"code":"    it('should fail when frame detaches', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n      const frame = page.frames()[1];\n\n      server.setRoute('/empty.html', () => {});\n      let error = null;\n      const navigationPromise = frame\n        .waitForNavigation()\n        .catch((error_) => (error = error_));\n      await Promise.all([\n        server.waitForRequest('/empty.html'),\n        frame.evaluate(() => ((window as any).location = '/empty.html')),\n      ]);\n      await page.$eval('iframe', (frame) => frame.remove());\n      await navigationPromise;\n      expect(error.message).toBe('Navigating frame was detached');\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Page.reload"],"updatePoint":{"line":767,"column":19},"line":767,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => (globalThis._foo = 10));\n      await page.reload();\n      expect(await page.evaluate(() => globalThis._foo)).toBe(undefined);\n    });","file":"navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fire for navigation requests","suites":["network","Page.Events.Request"],"updatePoint":{"line":35,"column":43},"line":35,"code":"    it('should fire for navigation requests', async () => {\n      const { page, server } = getTestState();\n\n      const requests = [];\n      page.on(\n        'request',\n        (request) => !utils.isFavicon(request) && requests.push(request)\n      );\n      await page.goto(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should fire for iframes","suites":["network","Page.Events.Request"],"updatePoint":{"line":46,"column":31},"line":46,"code":"    it('should fire for iframes', async () => {\n      const { page, server } = getTestState();\n\n      const requests = [];\n      page.on(\n        'request',\n        (request) => !utils.isFavicon(request) && requests.push(request)\n      );\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      expect(requests.length).toBe(2);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should fire for fetches","suites":["network","Page.Events.Request"],"updatePoint":{"line":58,"column":31},"line":58,"code":"    it('should fire for fetches', async () => {\n      const { page, server } = getTestState();\n\n      const requests = [];\n      page.on(\n        'request',\n        (request) => !utils.isFavicon(request) && requests.push(request)\n      );\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => fetch('/empty.html'));\n      expect(requests.length).toBe(2);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work for main frame navigation request","suites":["network","Request.frame"],"updatePoint":{"line":72,"column":53},"line":72,"code":"    it('should work for main frame navigation request', async () => {\n      const { page, server } = getTestState();\n\n      const requests = [];\n      page.on(\n        'request',\n        (request) => !utils.isFavicon(request) && requests.push(request)\n      );\n      await page.goto(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0].frame()).toBe(page.mainFrame());\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work for fetch requests","suites":["network","Request.frame"],"updatePoint":{"line":97,"column":38},"line":97,"code":"    it('should work for fetch requests', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let requests = [];\n      page.on(\n        'request',\n        (request) => !utils.isFavicon(request) && requests.push(request)\n      );\n      await page.evaluate(() => fetch('/digits/1.png'));\n      requests = requests.filter(\n        (request) => !request.url().includes('favicon')\n      );\n      expect(requests.length).toBe(1);\n      expect(requests[0].frame()).toBe(page.mainFrame());\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Request.headers"],"updatePoint":{"line":116,"column":19},"line":116,"code":"    it('should work', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE);\n      if (isChrome)\n        expect(response.request().headers()['user-agent']).toContain('Chrome');\n      else\n        expect(response.request().headers()['user-agent']).toContain('Firefox');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.headers"],"updatePoint":{"line":128,"column":19},"line":128,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      server.setRoute('/empty.html', (req, res) => {\n        res.setHeader('foo', 'bar');\n        res.end();\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.headers()['foo']).toBe('bar');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"shoud return the initiator","suites":["network","Response.headers"],"updatePoint":{"line":141,"column":34},"line":141,"code":"    it('shoud return the initiator', async () => {\n      const { page, server } = getTestState();\n\n      const initiators = new Map();\n      page.on('request', (request) =>\n        initiators.set(request.url().split('/').pop(), request.initiator())\n      );\n      await page.goto(server.PREFIX + '/initiator.html');\n\n      expect(initiators.get('initiator.html').type).toBe('other');\n      expect(initiators.get('initiator.js').type).toBe('parser');\n      expect(initiators.get('initiator.js').url).toBe(\n        server.PREFIX + '/initiator.html'\n      );\n      expect(initiators.get('frame.html').type).toBe('parser');\n      expect(initiators.get('frame.html').url).toBe(\n        server.PREFIX + '/initiator.html'\n      );\n      expect(initiators.get('script.js').type).toBe('parser');\n      expect(initiators.get('script.js').url).toBe(\n        server.PREFIX + '/frames/frame.html'\n      );\n      expect(initiators.get('style.css').type).toBe('parser');\n      expect(initiators.get('style.css').url).toBe(\n        server.PREFIX + '/frames/frame.html'\n      );\n      expect(initiators.get('initiator.js').type).toBe('parser');\n      expect(initiators.get('injectedfile.js').type).toBe('script');\n      expect(initiators.get('injectedfile.js').stack.callFrames[0].url).toBe(\n        server.PREFIX + '/initiator.js'\n      );\n      expect(initiators.get('injectedstyle.css').type).toBe('script');\n      expect(initiators.get('injectedstyle.css').stack.callFrames[0].url).toBe(\n        server.PREFIX + '/initiator.js'\n      );\n      expect(initiators.get('initiator.js').url).toBe(\n        server.PREFIX + '/initiator.html'\n      );\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should return |false| for non-cached content","suites":["network","Response.headers"],"updatePoint":{"line":183,"column":52},"line":183,"code":"    it('should return |false| for non-cached content', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.fromCache()).toBe(false);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.headers"],"updatePoint":{"line":190,"column":19},"line":190,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      const responses = new Map();\n      page.on(\n        'response',\n        (r) =>\n          !utils.isFavicon(r.request()) &&\n          responses.set(r.url().split('/').pop(), r)\n      );\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      await page.reload();\n\n      expect(responses.size).toBe(2);\n      expect(responses.get('one-style.css').status()).toBe(200);\n      expect(responses.get('one-style.css').fromCache()).toBe(true);\n      expect(responses.get('one-style.html').status()).toBe(304);\n      expect(responses.get('one-style.html').fromCache()).toBe(false);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should return |false| for non-service-worker content","suites":["network","Response.headers"],"updatePoint":{"line":214,"column":60},"line":214,"code":"    it('should return |false| for non-service-worker content', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.fromServiceWorker()).toBe(false);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Response.fromServiceWorker","suites":["network","Response.headers"],"updatePoint":{"line":221,"column":34},"line":221,"code":"    it('Response.fromServiceWorker', async () => {\n      const { page, server } = getTestState();\n\n      const responses = new Map();\n      page.on('response', (r) => responses.set(r.url().split('/').pop(), r));\n\n      // Load and re-load to make sure serviceworker is installed and running.\n      await page.goto(server.PREFIX + '/serviceworkers/fetch/sw.html', {\n        waitUntil: 'networkidle2',\n      });\n      await page.evaluate(async () => await globalThis.activationPromise);\n      await page.reload();\n\n      expect(responses.size).toBe(2);\n      expect(responses.get('sw.html').status()).toBe(200);\n      expect(responses.get('sw.html').fromServiceWorker()).toBe(true);\n      expect(responses.get('style.css').status()).toBe(200);\n      expect(responses.get('style.css').fromServiceWorker()).toBe(true);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.headers"],"updatePoint":{"line":243,"column":19},"line":243,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      server.setRoute('/post', (req, res) => res.end());\n      let request = null;\n      page.on('request', (r) => (request = r));\n      await page.evaluate(() =>\n        fetch('./post', {\n          method: 'POST',\n          body: JSON.stringify({ foo: 'bar' }),\n        })\n      );\n      expect(request).toBeTruthy();\n      expect(request.postData()).toBe('{\"foo\":\"bar\"}');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should be |undefined| when there is no post data","suites":["network","Response.headers"],"updatePoint":{"line":259,"column":56},"line":259,"code":"    it('should be |undefined| when there is no post data', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.request().postData()).toBe(undefined);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.headers"],"updatePoint":{"line":268,"column":19},"line":268,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.PREFIX + '/simple.json');\n      const responseText = (await response.text()).trimEnd();\n      expect(responseText).toBe('{\"foo\": \"bar\"}');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should return uncompressed text","suites":["network","Response.headers"],"updatePoint":{"line":275,"column":39},"line":275,"code":"    it('should return uncompressed text', async () => {\n      const { page, server } = getTestState();\n\n      server.enableGzip('/simple.json');\n      const response = await page.goto(server.PREFIX + '/simple.json');\n      expect(response.headers()['content-encoding']).toBe('gzip');\n      const responseText = (await response.text()).trimEnd();\n      expect(responseText).toBe('{\"foo\": \"bar\"}');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when requesting body of redirected response","suites":["network","Response.headers"],"updatePoint":{"line":284,"column":64},"line":284,"code":"    it('should throw when requesting body of redirected response', async () => {\n      const { page, server } = getTestState();\n\n      server.setRedirect('/foo.html', '/empty.html');\n      const response = await page.goto(server.PREFIX + '/foo.html');\n      const redirectChain = response.request().redirectChain();\n      expect(redirectChain.length).toBe(1);\n      const redirected = redirectChain[0].response();\n      expect(redirected.status()).toBe(302);\n      let error = null;\n      await redirected.text().catch((error_) => (error = error_));\n      expect(error.message).toContain(\n        'Response body is unavailable for redirect responses'\n      );\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should wait until response completes","suites":["network","Response.headers"],"updatePoint":{"line":299,"column":44},"line":299,"code":"    it('should wait until response completes', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      // Setup server to trap request.\n      let serverResponse = null;\n      server.setRoute('/get', (req, res) => {\n        serverResponse = res;\n        // In Firefox, |fetch| will be hanging until it receives |Content-Type| header\n        // from server.\n        res.setHeader('Content-Type', 'text/plain; charset=utf-8');\n        res.write('hello ');\n      });\n      // Setup page to trap response.\n      let requestFinished = false;\n      page.on(\n        'requestfinished',\n        (r) => (requestFinished = requestFinished || r.url().includes('/get'))\n      );\n      // send request and wait for server response\n      const [pageResponse] = await Promise.all([\n        page.waitForResponse((r) => !utils.isFavicon(r.request())),\n        page.evaluate(() => fetch('./get', { method: 'GET' })),\n        server.waitForRequest('/get'),\n      ]);\n\n      expect(serverResponse).toBeTruthy();\n      expect(pageResponse).toBeTruthy();\n      expect(pageResponse.status()).toBe(200);\n      expect(requestFinished).toBe(false);\n\n      const responseText = pageResponse.text();\n      // Write part of the response and wait for it to be flushed.\n      await new Promise((x) => serverResponse.write('wor', x));\n      // Finish response.\n      await new Promise((x) => serverResponse.end('ld!', x));\n      expect(await responseText).toBe('hello world!');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.headers"],"updatePoint":{"line":340,"column":19},"line":340,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.PREFIX + '/simple.json');\n      expect(await response.json()).toEqual({ foo: 'bar' });\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.headers"],"updatePoint":{"line":349,"column":19},"line":349,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      const response = await page.goto(server.PREFIX + '/pptr.png');\n      const imageBuffer = fs.readFileSync(\n        path.join(__dirname, 'assets', 'pptr.png')\n      );\n      const responseBuffer = await response.buffer();\n      expect(responseBuffer.equals(imageBuffer)).toBe(true);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work with compression","suites":["network","Response.headers"],"updatePoint":{"line":359,"column":36},"line":359,"code":"    it('should work with compression', async () => {\n      const { page, server } = getTestState();\n\n      server.enableGzip('/pptr.png');\n      const response = await page.goto(server.PREFIX + '/pptr.png');\n      const imageBuffer = fs.readFileSync(\n        path.join(__dirname, 'assets', 'pptr.png')\n      );\n      const responseBuffer = await response.buffer();\n      expect(responseBuffer.equals(imageBuffer)).toBe(true);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if the response does not have a body","suites":["network","Response.headers"],"updatePoint":{"line":370,"column":57},"line":370,"code":"    it('should throw if the response does not have a body', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/empty.html');\n\n      server.setRoute('/test.html', (req, res) => {\n        res.setHeader('Access-Control-Allow-Origin', '*');\n        res.setHeader('Access-Control-Allow-Headers', 'x-ping');\n        res.end('Hello World');\n      });\n      const url = server.CROSS_PROCESS_PREFIX + '/test.html';\n      const responsePromise = new Promise<HTTPResponse>((resolve) => {\n        page.on('response', (response) => {\n          // Get the preflight response.\n          if (\n            response.request().method() === 'OPTIONS' &&\n            response.url() === url\n          ) {\n            resolve(response);\n          }\n        });\n      });\n\n      // Trigger a request with a preflight.\n      await page.evaluate<(src: string) => void>(async (src) => {\n        const response = await fetch(src, {\n          method: 'POST',\n          headers: { 'x-ping': 'pong' },\n        });\n        return response;\n      }, url);\n\n      const response = await responsePromise;\n      await expect(response.buffer()).rejects.toThrowError(\n        'Could not load body for this request. This might happen if the request is a preflight request.'\n      );\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.statusText"],"updatePoint":{"line":410,"column":19},"line":410,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      server.setRoute('/cool', (req, res) => {\n        res.writeHead(200, 'cool!');\n        res.end();\n      });\n      const response = await page.goto(server.PREFIX + '/cool');\n      expect(response.statusText()).toBe('cool!');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"handles missing status text","suites":["network","Response.statusText"],"updatePoint":{"line":421,"column":35},"line":421,"code":"    it('handles missing status text', async () => {\n      const { page, server } = getTestState();\n\n      server.setRoute('/nostatus', (req, res) => {\n        res.writeHead(200, '');\n        res.end();\n      });\n      const response = await page.goto(server.PREFIX + '/nostatus');\n      expect(response.statusText()).toBe('');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"returns timing information","suites":["network","Response.statusText"],"updatePoint":{"line":434,"column":34},"line":434,"code":"    it('returns timing information', async () => {\n      const { page, server } = getTestState();\n      const responses = [];\n      page.on('response', (response) => responses.push(response));\n      await page.goto(server.EMPTY_PAGE);\n      expect(responses.length).toBe(1);\n      expect(responses[0].timing().receiveHeadersEnd).toBeGreaterThan(0);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.Request","suites":["network","Response.statusText"],"updatePoint":{"line":445,"column":27},"line":445,"code":"    it('Page.Events.Request', async () => {\n      const { page, server } = getTestState();\n\n      const requests = [];\n      page.on('request', (request) => requests.push(request));\n      await page.goto(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0].url()).toBe(server.EMPTY_PAGE);\n      expect(requests[0].resourceType()).toBe('document');\n      expect(requests[0].method()).toBe('GET');\n      expect(requests[0].response()).toBeTruthy();\n      expect(requests[0].frame() === page.mainFrame()).toBe(true);\n      expect(requests[0].frame().url()).toBe(server.EMPTY_PAGE);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.RequestServedFromCache","suites":["network","Response.statusText"],"updatePoint":{"line":459,"column":42},"line":459,"code":"    it('Page.Events.RequestServedFromCache', async () => {\n      const { page, server } = getTestState();\n\n      const cached = [];\n      page.on('requestservedfromcache', (r) =>\n        cached.push(r.url().split('/').pop())\n      );\n\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      expect(cached).toEqual([]);\n\n      await page.reload();\n      expect(cached).toEqual(['one-style.css']);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.Response","suites":["network","Response.statusText"],"updatePoint":{"line":473,"column":28},"line":473,"code":"    it('Page.Events.Response', async () => {\n      const { page, server } = getTestState();\n\n      const responses = [];\n      page.on('response', (response) => responses.push(response));\n      await page.goto(server.EMPTY_PAGE);\n      expect(responses.length).toBe(1);\n      expect(responses[0].url()).toBe(server.EMPTY_PAGE);\n      expect(responses[0].status()).toBe(200);\n      expect(responses[0].ok()).toBe(true);\n      expect(responses[0].request()).toBeTruthy();\n      const remoteAddress = responses[0].remoteAddress();\n      // Either IPv6 or IPv4, depending on environment.\n      expect(\n        remoteAddress.ip.includes('::1') || remoteAddress.ip === '127.0.0.1'\n      ).toBe(true);\n      expect(remoteAddress.port).toBe(server.PORT);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.RequestFailed","suites":["network","Response.statusText"],"updatePoint":{"line":492,"column":33},"line":492,"code":"    it('Page.Events.RequestFailed', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        if (request.url().endsWith('css')) request.abort();\n        else request.continue();\n      });\n      const failedRequests = [];\n      page.on('requestfailed', (request) => failedRequests.push(request));\n      await page.goto(server.PREFIX + '/one-style.html');\n      expect(failedRequests.length).toBe(1);\n      expect(failedRequests[0].url()).toContain('one-style.css');\n      expect(failedRequests[0].response()).toBe(null);\n      expect(failedRequests[0].resourceType()).toBe('stylesheet');\n      if (isChrome)\n        expect(failedRequests[0].failure().errorText).toBe('net::ERR_FAILED');\n      else\n        expect(failedRequests[0].failure().errorText).toBe('NS_ERROR_FAILURE');\n      expect(failedRequests[0].frame()).toBeTruthy();\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.RequestFinished","suites":["network","Response.statusText"],"updatePoint":{"line":513,"column":35},"line":513,"code":"    it('Page.Events.RequestFinished', async () => {\n      const { page, server } = getTestState();\n\n      const requests = [];\n      page.on('requestfinished', (request) => requests.push(request));\n      await page.goto(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0].url()).toBe(server.EMPTY_PAGE);\n      expect(requests[0].response()).toBeTruthy();\n      expect(requests[0].frame() === page.mainFrame()).toBe(true);\n      expect(requests[0].frame().url()).toBe(server.EMPTY_PAGE);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should fire events in proper order","suites":["network","Response.statusText"],"updatePoint":{"line":525,"column":42},"line":525,"code":"    it('should fire events in proper order', async () => {\n      const { page, server } = getTestState();\n\n      const events = [];\n      page.on('request', () => events.push('request'));\n      page.on('response', () => events.push('response'));\n      page.on('requestfinished', () => events.push('requestfinished'));\n      await page.goto(server.EMPTY_PAGE);\n      expect(events).toEqual(['request', 'response', 'requestfinished']);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should support redirects","suites":["network","Response.statusText"],"updatePoint":{"line":535,"column":32},"line":535,"code":"    it('should support redirects', async () => {\n      const { page, server } = getTestState();\n\n      const events = [];\n      page.on('request', (request) =>\n        events.push(`${request.method()} ${request.url()}`)\n      );\n      page.on('response', (response) =>\n        events.push(`${response.status()} ${response.url()}`)\n      );\n      page.on('requestfinished', (request) =>\n        events.push(`DONE ${request.url()}`)\n      );\n      page.on('requestfailed', (request) =>\n        events.push(`FAIL ${request.url()}`)\n      );\n      server.setRedirect('/foo.html', '/empty.html');\n      const FOO_URL = server.PREFIX + '/foo.html';\n      const response = await page.goto(FOO_URL);\n      expect(events).toEqual([\n        `GET ${FOO_URL}`,\n        `302 ${FOO_URL}`,\n        `DONE ${FOO_URL}`,\n        `GET ${server.EMPTY_PAGE}`,\n        `200 ${server.EMPTY_PAGE}`,\n        `DONE ${server.EMPTY_PAGE}`,\n      ]);\n\n      // Check redirect chain\n      const redirectChain = response.request().redirectChain();\n      expect(redirectChain.length).toBe(1);\n      expect(redirectChain[0].url()).toContain('/foo.html');\n      expect(redirectChain[0].response().remoteAddress().port).toBe(\n        server.PORT\n      );\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":617,"column":19},"line":617,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        foo: 'bar',\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(request.headers['foo']).toBe('bar');\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for non-string header values","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":629,"column":49},"line":629,"code":"    it('should throw for non-string header values', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      try {\n        // @ts-expect-error purposeful bad input\n        await page.setExtraHTTPHeaders({ foo: 1 });\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toBe(\n        'Expected value of header \"foo\" to be String, but \"number\" is found.'\n      );\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":646,"column":19},"line":646,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      server.setAuth('/empty.html', 'user', 'pass');\n      let response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(401);\n      await page.authenticate({\n        username: 'user',\n        password: 'pass',\n      });\n      response = await page.reload();\n      expect(response.status()).toBe(200);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should fail if wrong credentials","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":659,"column":40},"line":659,"code":"    it('should fail if wrong credentials', async () => {\n      const { page, server } = getTestState();\n\n      // Use unique user/password since Chrome caches credentials per origin.\n      server.setAuth('/empty.html', 'user2', 'pass2');\n      await page.authenticate({\n        username: 'foo',\n        password: 'bar',\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(401);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should allow disable authentication","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":671,"column":43},"line":671,"code":"    it('should allow disable authentication', async () => {\n      const { page, server } = getTestState();\n\n      // Use unique user/password since Chrome caches credentials per origin.\n      server.setAuth('/empty.html', 'user3', 'pass3');\n      await page.authenticate({\n        username: 'user3',\n        password: 'pass3',\n      });\n      let response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(200);\n      await page.authenticate(null);\n      // Navigate to a different origin to bust Chrome's credential caching.\n      response = await page.goto(server.CROSS_PROCESS_PREFIX + '/empty.html');\n      expect(response.status()).toBe(401);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should not disable caching","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":687,"column":34},"line":687,"code":"    it('should not disable caching', async () => {\n      const { page, server } = getTestState();\n\n      // Use unique user/password since Chrome caches credentials per origin.\n      server.setAuth('/cached/one-style.css', 'user4', 'pass4');\n      server.setAuth('/cached/one-style.html', 'user4', 'pass4');\n      await page.authenticate({\n        username: 'user4',\n        password: 'pass4',\n      });\n\n      const responses = new Map();\n      page.on('response', (r) => responses.set(r.url().split('/').pop(), r));\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      await page.reload();\n\n      expect(responses.get('one-style.css').status()).toBe(200);\n      expect(responses.get('one-style.css').fromCache()).toBe(true);\n      expect(responses.get('one-style.html').status()).toBe(304);\n      expect(responses.get('one-style.html').fromCache()).toBe(false);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Same-origin set-cookie navigation","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":713,"column":41},"line":713,"code":"    it('Same-origin set-cookie navigation', async () => {\n      const { page, server } = getTestState();\n\n      const setCookieString = 'foo=bar';\n      server.setRoute('/empty.html', (req, res) => {\n        res.setHeader('set-cookie', setCookieString);\n        res.end('hello world');\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.headers()['set-cookie']).toBe(setCookieString);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Same-origin set-cookie subresource","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":725,"column":42},"line":725,"code":"    it('Same-origin set-cookie subresource', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n\n      const setCookieString = 'foo=bar';\n      server.setRoute('/foo', (req, res) => {\n        res.setHeader('set-cookie', setCookieString);\n        res.end('hello world');\n      });\n\n      const responsePromise = new Promise<HTTPResponse>((resolve) =>\n        page.on('response', (response) => resolve(response))\n      );\n      page.evaluate(() => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', '/foo');\n        xhr.send();\n      });\n      const subresourceResponse = await responsePromise;\n      expect(subresourceResponse.headers()['set-cookie']).toBe(setCookieString);\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"Cross-origin set-cookie","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":747,"column":31},"line":747,"code":"    it('Cross-origin set-cookie', async () => {\n      const { httpsServer, puppeteer, defaultBrowserOptions } = getTestState();\n\n      const browser = await puppeteer.launch({\n        ...defaultBrowserOptions,\n        ignoreHTTPSErrors: true,\n      });\n\n      const page = await browser.newPage();\n\n      try {\n        await page.goto(httpsServer.PREFIX + '/empty.html');\n\n        const setCookieString = 'hello=world';\n        httpsServer.setRoute('/setcookie.html', (req, res) => {\n          res.setHeader('Access-Control-Allow-Origin', '*');\n          res.setHeader('set-cookie', setCookieString);\n          res.end();\n        });\n        await page.goto(httpsServer.PREFIX + '/setcookie.html');\n\n        const response = await new Promise<HTTPResponse>((resolve) => {\n          page.on('response', resolve);\n          const url = httpsServer.CROSS_PROCESS_PREFIX + '/setcookie.html';\n          page.evaluate<(src: string) => void>((src) => {\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', src);\n            xhr.send();\n          }, url);\n        });\n        expect(response.headers()['set-cookie']).toBe(setCookieString);\n      } finally {\n        await page.close();\n        await browser.close();\n      }\n    });","file":"network.spec.ts","skipped":false,"dir":"test"},{"name":"should process extra info on multiple redirects","suites":[],"updatePoint":{"line":33,"column":53},"line":33,"code":"  it('should process extra info on multiple redirects', async () => {\n    const mockCDPSession = new MockCDPSession();\n    new NetworkManager(mockCDPSession, true, {\n      frame(): Frame | null {\n        return null;\n      },\n    });\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      documentURL: 'http://localhost:8907/redirect/1.html',\n      request: {\n        url: 'http://localhost:8907/redirect/1.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 2111.55635,\n      wallTime: 1637315638.473634,\n      initiator: { type: 'other' },\n      redirectHasExtraInfo: false,\n      type: 'Document',\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n      hasUserGesture: false,\n    });\n\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      associatedCookies: [],\n      headers: {\n        Host: 'localhost:8907',\n        Connection: 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-User': '?1',\n        'Sec-Fetch-Dest': 'document',\n        'Accept-Encoding': 'gzip, deflate, br',\n      },\n      connectTiming: { requestTime: 2111.557593 },\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      blockedCookies: [],\n      headers: {\n        location: '/redirect/2.html',\n        Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n        Connection: 'keep-alive',\n        'Keep-Alive': 'timeout=5',\n        'Transfer-Encoding': 'chunked',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 302,\n      headersText:\n        'HTTP/1.1 302 Found\\r\\nlocation: /redirect/2.html\\r\\nDate: Fri, 19 Nov 2021 09:53:58 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      documentURL: 'http://localhost:8907/redirect/2.html',\n      request: {\n        url: 'http://localhost:8907/redirect/2.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 2111.559124,\n      wallTime: 1637315638.47642,\n      initiator: { type: 'other' },\n      redirectHasExtraInfo: true,\n      redirectResponse: {\n        url: 'http://localhost:8907/redirect/1.html',\n        status: 302,\n        statusText: 'Found',\n        headers: {\n          location: '/redirect/2.html',\n          Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n          Connection: 'keep-alive',\n          'Keep-Alive': 'timeout=5',\n          'Transfer-Encoding': 'chunked',\n        },\n        mimeType: '',\n        connectionReused: false,\n        connectionId: 322,\n        remoteIPAddress: '[::1]',\n        remotePort: 8907,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 162,\n        timing: {\n          requestTime: 2111.557593,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: 0.241,\n          dnsEnd: 0.251,\n          connectStart: 0.251,\n          connectEnd: 0.47,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.537,\n          sendEnd: 0.611,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 0.939,\n        },\n        responseTime: 1.637315638475744e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      type: 'Document',\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      associatedCookies: [],\n      headers: {\n        Host: 'localhost:8907',\n        Connection: 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-User': '?1',\n        'Sec-Fetch-Dest': 'document',\n        'Accept-Encoding': 'gzip, deflate, br',\n      },\n      connectTiming: { requestTime: 2111.559346 },\n    });\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      documentURL: 'http://localhost:8907/redirect/3.html',\n      request: {\n        url: 'http://localhost:8907/redirect/3.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 2111.560249,\n      wallTime: 1637315638.477543,\n      initiator: { type: 'other' },\n      redirectHasExtraInfo: true,\n      redirectResponse: {\n        url: 'http://localhost:8907/redirect/2.html',\n        status: 302,\n        statusText: 'Found',\n        headers: {\n          location: '/redirect/3.html',\n          Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n          Connection: 'keep-alive',\n          'Keep-Alive': 'timeout=5',\n          'Transfer-Encoding': 'chunked',\n        },\n        mimeType: '',\n        connectionReused: true,\n        connectionId: 322,\n        remoteIPAddress: '[::1]',\n        remotePort: 8907,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 162,\n        timing: {\n          requestTime: 2111.559346,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.15,\n          sendEnd: 0.196,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 0.507,\n        },\n        responseTime: 1.637315638477063e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      type: 'Document',\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      blockedCookies: [],\n      headers: {\n        location: '/redirect/3.html',\n        Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n        Connection: 'keep-alive',\n        'Keep-Alive': 'timeout=5',\n        'Transfer-Encoding': 'chunked',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 302,\n      headersText:\n        'HTTP/1.1 302 Found\\r\\nlocation: /redirect/3.html\\r\\nDate: Fri, 19 Nov 2021 09:53:58 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      associatedCookies: [],\n      headers: {\n        Host: 'localhost:8907',\n        Connection: 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-User': '?1',\n        'Sec-Fetch-Dest': 'document',\n        'Accept-Encoding': 'gzip, deflate, br',\n      },\n      connectTiming: { requestTime: 2111.560482 },\n    });\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      documentURL: 'http://localhost:8907/empty.html',\n      request: {\n        url: 'http://localhost:8907/empty.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 2111.561542,\n      wallTime: 1637315638.478837,\n      initiator: { type: 'other' },\n      redirectHasExtraInfo: true,\n      redirectResponse: {\n        url: 'http://localhost:8907/redirect/3.html',\n        status: 302,\n        statusText: 'Found',\n        headers: {\n          location: 'http://localhost:8907/empty.html',\n          Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n          Connection: 'keep-alive',\n          'Keep-Alive': 'timeout=5',\n          'Transfer-Encoding': 'chunked',\n        },\n        mimeType: '',\n        connectionReused: true,\n        connectionId: 322,\n        remoteIPAddress: '[::1]',\n        remotePort: 8907,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 178,\n        timing: {\n          requestTime: 2111.560482,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.149,\n          sendEnd: 0.198,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 0.478,\n        },\n        responseTime: 1.637315638478184e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      type: 'Document',\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      blockedCookies: [],\n      headers: {\n        location: 'http://localhost:8907/empty.html',\n        Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n        Connection: 'keep-alive',\n        'Keep-Alive': 'timeout=5',\n        'Transfer-Encoding': 'chunked',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 302,\n      headersText:\n        'HTTP/1.1 302 Found\\r\\nlocation: http://localhost:8907/empty.html\\r\\nDate: Fri, 19 Nov 2021 09:53:58 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      associatedCookies: [],\n      headers: {\n        Host: 'localhost:8907',\n        Connection: 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-User': '?1',\n        'Sec-Fetch-Dest': 'document',\n        'Accept-Encoding': 'gzip, deflate, br',\n      },\n      connectTiming: { requestTime: 2111.561759 },\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      blockedCookies: [],\n      headers: {\n        'Cache-Control': 'no-cache, no-store',\n        'Content-Type': 'text/html; charset=utf-8',\n        Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n        Connection: 'keep-alive',\n        'Keep-Alive': 'timeout=5',\n        'Content-Length': '0',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 200,\n      headersText:\n        'HTTP/1.1 200 OK\\r\\nCache-Control: no-cache, no-store\\r\\nContent-Type: text/html; charset=utf-8\\r\\nDate: Fri, 19 Nov 2021 09:53:58 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nContent-Length: 0\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.responseReceived', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      timestamp: 2111.563565,\n      type: 'Document',\n      response: {\n        url: 'http://localhost:8907/empty.html',\n        status: 200,\n        statusText: 'OK',\n        headers: {\n          'Cache-Control': 'no-cache, no-store',\n          'Content-Type': 'text/html; charset=utf-8',\n          Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n          Connection: 'keep-alive',\n          'Keep-Alive': 'timeout=5',\n          'Content-Length': '0',\n        },\n        mimeType: 'text/html',\n        connectionReused: true,\n        connectionId: 322,\n        remoteIPAddress: '[::1]',\n        remotePort: 8907,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 197,\n        timing: {\n          requestTime: 2111.561759,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.148,\n          sendEnd: 0.19,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 0.925,\n        },\n        responseTime: 1.637315638479928e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      hasExtraInfo: true,\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n    });\n  });","file":"NetworkManager.spec.ts","skipped":false,"dir":"test"},{"name":"should handle \"double pause\" (crbug.com/1196004) Fetch.requestPaused events for the same Network.requestWillBeSent event","suites":[],"updatePoint":{"line":464,"column":126},"line":464,"code":"  it(`should handle \"double pause\" (crbug.com/1196004) Fetch.requestPaused events for the same Network.requestWillBeSent event`, async () => {\n    const mockCDPSession = new MockCDPSession();\n    const manager = new NetworkManager(mockCDPSession, true, {\n      frame(): Frame | null {\n        return null;\n      },\n    });\n    manager.setRequestInterception(true);\n\n    const requests: HTTPRequest[] = [];\n    manager.on(NetworkManagerEmittedEvents.Request, (request: HTTPRequest) => {\n      request.continue();\n      requests.push(request);\n    });\n\n    /**\n     * This sequence was taken from an actual CDP session produced by the following\n     * test script:\n     *\n     * const browser = await puppeteer.launch({ headless: false });\n     * const page = await browser.newPage();\n     * await page.setCacheEnabled(false);\n     *\n     * await page.setRequestInterception(true)\n     * page.on('request', (interceptedRequest) => {\n     *   interceptedRequest.continue();\n     * });\n     *\n     * await page.goto('https://www.google.com');\n     * await browser.close();\n     *\n     */\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '11ACE9783588040D644B905E8B55285B',\n      loaderId: '11ACE9783588040D644B905E8B55285B',\n      documentURL: 'https://www.google.com/',\n      request: {\n        url: 'https://www.google.com/',\n        method: 'GET',\n        headers: [Object],\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 224604.980827,\n      wallTime: 1637955746.786191,\n      initiator: { type: 'other' },\n      redirectHasExtraInfo: false,\n      type: 'Document',\n      frameId: '84AC261A351B86932B775B76D1DD79F8',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Fetch.requestPaused', {\n      requestId: 'interception-job-1.0',\n      request: {\n        url: 'https://www.google.com/',\n        method: 'GET',\n        headers: [Object],\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n      },\n      frameId: '84AC261A351B86932B775B76D1DD79F8',\n      resourceType: 'Document',\n      networkId: '11ACE9783588040D644B905E8B55285B',\n    });\n    mockCDPSession.emit('Fetch.requestPaused', {\n      requestId: 'interception-job-2.0',\n      request: {\n        url: 'https://www.google.com/',\n        method: 'GET',\n        headers: [Object],\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n      },\n      frameId: '84AC261A351B86932B775B76D1DD79F8',\n      resourceType: 'Document',\n      networkId: '11ACE9783588040D644B905E8B55285B',\n    });\n\n    expect(requests.length).toBe(2);\n  });","file":"NetworkManager.spec.ts","skipped":false,"dir":"test"},{"name":"should treat OOP iframes and normal iframes the same","suites":[],"updatePoint":{"line":54,"column":58},"line":54,"code":"  it('should treat OOP iframes and normal iframes the same', async () => {\n    const { server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame((frame) =>\n      frame.url().endsWith('/empty.html')\n    );\n    await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n    await utils.attachFrame(\n      page,\n      'frame2',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    await framePromise;\n    expect(page.mainFrame().childFrames()).toHaveLength(2);\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should track navigations within OOP iframes","suites":[],"updatePoint":{"line":70,"column":49},"line":70,"code":"  it('should track navigations within OOP iframes', async () => {\n    const { server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    const frame = await framePromise;\n    expect(frame.url()).toContain('/empty.html');\n    await utils.navigateFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/assets/frame.html'\n    );\n    expect(frame.url()).toContain('/assets/frame.html');\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support OOP iframes becoming normal iframes again","suites":[],"updatePoint":{"line":91,"column":62},"line":91,"code":"  it('should support OOP iframes becoming normal iframes again', async () => {\n    const { server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n\n    const frame = await framePromise;\n    expect(frame.isOOPFrame()).toBe(false);\n    await utils.navigateFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    expect(frame.isOOPFrame()).toBe(true);\n    await utils.navigateFrame(page, 'frame1', server.EMPTY_PAGE);\n    expect(frame.isOOPFrame()).toBe(false);\n    expect(page.frames()).toHaveLength(2);\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support frames within OOP frames","suites":[],"updatePoint":{"line":112,"column":45},"line":112,"code":"  it('should support frames within OOP frames', async () => {\n    const { server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const frame1Promise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    const frame2Promise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 2;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/frames/one-frame.html'\n    );\n\n    const [frame1, frame2] = await Promise.all([frame1Promise, frame2Promise]);\n\n    expect(await frame1.evaluate(() => document.location.href)).toMatch(\n      /one-frame\\.html$/\n    );\n    expect(await frame2.evaluate(() => document.location.href)).toMatch(\n      /frames\\/frame\\.html$/\n    );\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support OOP iframes getting detached","suites":[],"updatePoint":{"line":137,"column":49},"line":137,"code":"  it('should support OOP iframes getting detached', async () => {\n    const { server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n\n    const frame = await framePromise;\n    expect(frame.isOOPFrame()).toBe(false);\n    await utils.navigateFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    expect(frame.isOOPFrame()).toBe(true);\n    await utils.detachFrame(page, 'frame1');\n    expect(page.frames()).toHaveLength(1);\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should keep track of a frames OOP state","suites":[],"updatePoint":{"line":157,"column":45},"line":157,"code":"  it('should keep track of a frames OOP state', async () => {\n    const { server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    const frame = await framePromise;\n    expect(frame.url()).toContain('/empty.html');\n    await utils.navigateFrame(page, 'frame1', server.EMPTY_PAGE);\n    expect(frame.url()).toBe(server.EMPTY_PAGE);\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support evaluating in oop iframes","suites":[],"updatePoint":{"line":174,"column":46},"line":174,"code":"  it('should support evaluating in oop iframes', async () => {\n    const { server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    const frame = await framePromise;\n    await frame.evaluate(() => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      _test = 'Test 123!';\n    });\n    const result = await frame.evaluate(() => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      return window._test;\n    });\n    expect(result).toBe('Test 123!');\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should provide access to elements","suites":[],"updatePoint":{"line":199,"column":39},"line":199,"code":"  it('should provide access to elements', async () => {\n    const { server } = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n\n    const frame = await framePromise;\n    await frame.evaluate(() => {\n      const button = document.createElement('button');\n      button.id = 'test-button';\n      button.innerText = 'click';\n      button.onclick = () => {\n        button.id = 'clicked';\n      };\n      document.body.appendChild(button);\n    });\n    await page.evaluate(() => {\n      document.body.style.border = '150px solid black';\n      document.body.style.margin = '250px';\n      document.body.style.padding = '50px';\n    });\n    await frame.waitForSelector('#test-button', { visible: true });\n    await frame.click('#test-button');\n    await frame.waitForSelector('#clicked');\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should report oopif frames","suites":[],"updatePoint":{"line":231,"column":32},"line":231,"code":"  it('should report oopif frames', async () => {\n    const { server } = getTestState();\n\n    const frame = page.waitForFrame((frame) =>\n      frame.url().endsWith('/oopif.html')\n    );\n    await page.goto(server.PREFIX + '/dynamic-oopif.html');\n    await frame;\n    expect(oopifs(context).length).toBe(1);\n    expect(page.frames().length).toBe(2);\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should load oopif iframes with subresources and request interception","suites":[],"updatePoint":{"line":242,"column":74},"line":242,"code":"  it('should load oopif iframes with subresources and request interception', async () => {\n    const { server } = getTestState();\n\n    const frame = page.waitForFrame((frame) =>\n      frame.url().endsWith('/oopif.html')\n    );\n    await page.setRequestInterception(true);\n    page.on('request', (request) => request.continue());\n    await page.goto(server.PREFIX + '/dynamic-oopif.html');\n    await frame;\n    expect(oopifs(context).length).toBe(1);\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support frames within OOP iframes","suites":[],"updatePoint":{"line":254,"column":46},"line":254,"code":"  it('should support frames within OOP iframes', async () => {\n    const { server } = getTestState();\n\n    const oopIframePromise = page.waitForFrame((frame) => {\n      return frame.url().endsWith('/oopif.html');\n    });\n    await page.goto(server.PREFIX + '/dynamic-oopif.html');\n    const oopIframe = await oopIframePromise;\n    await utils.attachFrame(\n      oopIframe,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n\n    const frame1 = oopIframe.childFrames()[0];\n    expect(frame1.url()).toMatch(/empty.html$/);\n    await utils.navigateFrame(\n      oopIframe,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/oopif.html'\n    );\n    expect(frame1.url()).toMatch(/oopif.html$/);\n    await frame1.goto(\n      server.CROSS_PROCESS_PREFIX + '/oopif.html#navigate-within-document',\n      { waitUntil: 'load' }\n    );\n    expect(frame1.url()).toMatch(/oopif.html#navigate-within-document$/);\n    await utils.detachFrame(oopIframe, 'frame1');\n    expect(oopIframe.childFrames()).toHaveLength(0);\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"clickablePoint, boundingBox, boxModel should work for elements inside OOPIFs","suites":[],"updatePoint":{"line":285,"column":82},"line":285,"code":"  it('clickablePoint, boundingBox, boxModel should work for elements inside OOPIFs', async () => {\n    const { server } = getTestState();\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame((frame) => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    const frame = await framePromise;\n    await page.evaluate(() => {\n      document.body.style.border = '50px solid black';\n      document.body.style.margin = '50px';\n      document.body.style.padding = '50px';\n    });\n    await frame.evaluate(() => {\n      const button = document.createElement('button');\n      button.id = 'test-button';\n      button.innerText = 'click';\n      document.body.appendChild(button);\n    });\n    const button = await frame.waitForSelector('#test-button', {\n      visible: true,\n    });\n    const result = await button.clickablePoint();\n    expect(result.x).toBeGreaterThan(150); // padding + margin + border left\n    expect(result.y).toBeGreaterThan(150); // padding + margin + border top\n    const resultBoxModel = await button.boxModel();\n    for (const quad of [\n      resultBoxModel.content,\n      resultBoxModel.border,\n      resultBoxModel.margin,\n      resultBoxModel.padding,\n    ]) {\n      for (const part of quad) {\n        expect(part.x).toBeGreaterThan(150); // padding + margin + border left\n        expect(part.y).toBeGreaterThan(150); // padding + margin + border top\n      }\n    }\n    const resultBoundingBox = await button.boundingBox();\n    expect(resultBoundingBox.x).toBeGreaterThan(150); // padding + margin + border left\n    expect(resultBoundingBox.y).toBeGreaterThan(150); // padding + margin + border top\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should detect existing OOPIFs when Puppeteer connects to an existing page","suites":[],"updatePoint":{"line":331,"column":79},"line":331,"code":"  it('should detect existing OOPIFs when Puppeteer connects to an existing page', async () => {\n    const { server, puppeteer } = getTestState();\n\n    const frame = page.waitForFrame((frame) =>\n      frame.url().endsWith('/oopif.html')\n    );\n    await page.goto(server.PREFIX + '/dynamic-oopif.html');\n    await frame;\n    expect(oopifs(context).length).toBe(1);\n    expect(page.frames().length).toBe(2);\n\n    const browserURL = 'http://127.0.0.1:21222';\n    const browser1 = await puppeteer.connect({ browserURL });\n    const target = await browser1.waitForTarget((target) =>\n      target.url().endsWith('dynamic-oopif.html')\n    );\n    await target.page();\n    browser1.disconnect();\n  });","file":"oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should reject all promises when page is closed","suites":["Page","Page.close"],"updatePoint":{"line":37,"column":54},"line":37,"code":"    it('should reject all promises when page is closed', async () => {\n      const { context } = getTestState();\n\n      const newPage = await context.newPage();\n      let error = null;\n      await Promise.all([\n        newPage\n          .evaluate(() => new Promise(() => {}))\n          .catch((error_) => (error = error_)),\n        newPage.close(),\n      ]);\n      expect(error.message).toContain('Protocol error');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should not be visible in browser.pages","suites":["Page","Page.close"],"updatePoint":{"line":50,"column":46},"line":50,"code":"    it('should not be visible in browser.pages', async () => {\n      const { browser } = getTestState();\n\n      const newPage = await browser.newPage();\n      expect(await browser.pages()).toContain(newPage);\n      await newPage.close();\n      expect(await browser.pages()).not.toContain(newPage);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should set the page close state","suites":["Page","Page.close"],"updatePoint":{"line":85,"column":39},"line":85,"code":"    it('should set the page close state', async () => {\n      const { context } = getTestState();\n\n      const newPage = await context.newPage();\n      expect(newPage.isClosed()).toBe(false);\n      await newPage.close();\n      expect(newPage.isClosed()).toBe(true);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should fire when expected","suites":["Page","Page.Events.Load"],"updatePoint":{"line":111,"column":33},"line":111,"code":"    it('should fire when expected', async () => {\n      const { page } = getTestState();\n\n      await Promise.all([\n        page.goto('about:blank'),\n        utils.waitEvent(page, 'load'),\n      ]);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly fire event handlers as they are added and then removed","suites":["Page","Page.Events.Load"],"updatePoint":{"line":126,"column":79},"line":126,"code":"    it('should correctly fire event handlers as they are added and then removed', async () => {\n      const { page, server } = getTestState();\n\n      const handler = sinon.spy();\n      page.on('response', handler);\n      await page.goto(server.EMPTY_PAGE);\n      expect(handler.callCount).toBe(1);\n      page.off('response', handler);\n      await page.goto(server.EMPTY_PAGE);\n      // Still one because we removed the handler.\n      expect(handler.callCount).toBe(1);\n      page.on('response', handler);\n      await page.goto(server.EMPTY_PAGE);\n      // Two now because we added the handler back.\n      expect(handler.callCount).toBe(2);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly added and removed request events","suites":["Page","Page.Events.Load"],"updatePoint":{"line":143,"column":57},"line":143,"code":"    it('should correctly added and removed request events', async () => {\n      const { page, server } = getTestState();\n\n      const handler = sinon.spy();\n      page.on('request', handler);\n      await page.goto(server.EMPTY_PAGE);\n      expect(handler.callCount).toBe(1);\n      page.off('request', handler);\n      await page.goto(server.EMPTY_PAGE);\n      // Still one because we removed the handler.\n      expect(handler.callCount).toBe(1);\n      page.on('request', handler);\n      await page.goto(server.EMPTY_PAGE);\n      // Two now because we added the handler back.\n      expect(handler.callCount).toBe(2);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when page crashes","suites":["Page","Page.Events.Load"],"updatePoint":{"line":162,"column":38},"line":162,"code":"    it('should throw when page crashes', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      page.on('error', (err) => (error = err));\n      page.goto('chrome://crash').catch(() => {});\n      await waitEvent(page, 'error');\n      expect(error.message).toBe('Page crashed!');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.Events.Load"],"updatePoint":{"line":174,"column":19},"line":174,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      const [popup] = await Promise.all([\n        new Promise<Page>((x) => page.once('popup', x)),\n        page.evaluate(() => window.open('about:blank')),\n      ]);\n      expect(await page.evaluate(() => !!window.opener)).toBe(false);\n      expect(await popup.evaluate(() => !!window.opener)).toBe(true);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with noopener","suites":["Page","Page.Events.Load"],"updatePoint":{"line":184,"column":33},"line":184,"code":"    it('should work with noopener', async () => {\n      const { page } = getTestState();\n\n      const [popup] = await Promise.all([\n        new Promise<Page>((x) => page.once('popup', x)),\n        page.evaluate(() => window.open('about:blank', null, 'noopener')),\n      ]);\n      expect(await page.evaluate(() => !!window.opener)).toBe(false);\n      expect(await popup.evaluate(() => !!window.opener)).toBe(false);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with clicking target=_blank and without rel=opener","suites":["Page","Page.Events.Load"],"updatePoint":{"line":194,"column":70},"line":194,"code":"    it('should work with clicking target=_blank and without rel=opener', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent('<a target=_blank href=\"/one-style.html\">yo</a>');\n      const [popup] = await Promise.all([\n        new Promise<Page>((x) => page.once('popup', x)),\n        page.click('a'),\n      ]);\n      expect(await page.evaluate(() => !!window.opener)).toBe(false);\n      expect(await popup.evaluate(() => !!window.opener)).toBe(false);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with clicking target=_blank and with rel=opener","suites":["Page","Page.Events.Load"],"updatePoint":{"line":206,"column":67},"line":206,"code":"    it('should work with clicking target=_blank and with rel=opener', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(\n        '<a target=_blank rel=opener href=\"/one-style.html\">yo</a>'\n      );\n      const [popup] = await Promise.all([\n        new Promise<Page>((x) => page.once('popup', x)),\n        page.click('a'),\n      ]);\n      expect(await page.evaluate(() => !!window.opener)).toBe(false);\n      expect(await popup.evaluate(() => !!window.opener)).toBe(true);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with fake-clicking target=_blank and rel=noopener","suites":["Page","Page.Events.Load"],"updatePoint":{"line":220,"column":69},"line":220,"code":"    it('should work with fake-clicking target=_blank and rel=noopener', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(\n        '<a target=_blank rel=noopener href=\"/one-style.html\">yo</a>'\n      );\n      const [popup] = await Promise.all([\n        new Promise<Page>((x) => page.once('popup', x)),\n        page.$eval('a', (a: HTMLAnchorElement) => a.click()),\n      ]);\n      expect(await page.evaluate(() => !!window.opener)).toBe(false);\n      expect(await popup.evaluate(() => !!window.opener)).toBe(false);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with clicking target=_blank and rel=noopener","suites":["Page","Page.Events.Load"],"updatePoint":{"line":234,"column":64},"line":234,"code":"    it('should work with clicking target=_blank and rel=noopener', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(\n        '<a target=_blank rel=noopener href=\"/one-style.html\">yo</a>'\n      );\n      const [popup] = await Promise.all([\n        new Promise<Page>((x) => page.once('popup', x)),\n        page.click('a'),\n      ]);\n      expect(await page.evaluate(() => !!window.opener)).toBe(false);\n      expect(await popup.evaluate(() => !!window.opener)).toBe(false);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should be prompt by default","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":259,"column":35},"line":259,"code":"    it('should be prompt by default', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      expect(await getPermission(page, 'geolocation')).toBe('prompt');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when bad permission is given","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":272,"column":48},"line":272,"code":"    it('should fail when bad permission is given', async () => {\n      const { page, server, context } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let error = null;\n      await context\n        // @ts-expect-error purposeful bad input for test\n        .overridePermissions(server.EMPTY_PAGE, ['foo'])\n        .catch((error_) => (error = error_));\n      expect(error.message).toBe('Unknown permission: foo');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when invalid longitude","suites":["Page","Page.setGeolocation"],"updatePoint":{"line":397,"column":43},"line":397,"code":"    it('should throw when invalid longitude', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      try {\n        await page.setGeolocation({ longitude: 200, latitude: 10 });\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toContain('Invalid longitude \"200\"');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.setGeolocation"],"updatePoint":{"line":411,"column":19},"line":411,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setOfflineMode(true);\n      let error = null;\n      await page.goto(server.EMPTY_PAGE).catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      await page.setOfflineMode(false);\n      const response = await page.reload();\n      expect(response.status()).toBe(200);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should emulate navigator.onLine","suites":["Page","Page.setGeolocation"],"updatePoint":{"line":422,"column":39},"line":422,"code":"    it('should emulate navigator.onLine', async () => {\n      const { page } = getTestState();\n\n      expect(await page.evaluate(() => window.navigator.onLine)).toBe(true);\n      await page.setOfflineMode(true);\n      expect(await page.evaluate(() => window.navigator.onLine)).toBe(false);\n      await page.setOfflineMode(false);\n      expect(await page.evaluate(() => window.navigator.onLine)).toBe(true);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should fail for disposed handles","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":466,"column":40},"line":466,"code":"    it('should fail for disposed handles', async () => {\n      const { page } = getTestState();\n\n      const prototypeHandle = await page.evaluateHandle(\n        () => HTMLBodyElement.prototype\n      );\n      await prototypeHandle.dispose();\n      let error = null;\n      await page\n        .queryObjects(prototypeHandle)\n        .catch((error_) => (error = error_));\n      expect(error.message).toBe('Prototype JSHandle is disposed!');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should fail primitive values as prototypes","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":479,"column":50},"line":479,"code":"    it('should fail primitive values as prototypes', async () => {\n      const { page } = getTestState();\n\n      const prototypeHandle = await page.evaluateHandle(() => 42);\n      let error = null;\n      await page\n        .queryObjects(prototypeHandle)\n        .catch((error_) => (error = error_));\n      expect(error.message).toBe(\n        'Prototype JSHandle must not be referencing primitive value'\n      );\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":494,"column":19},"line":494,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      let message = null;\n      page.once('console', (m) => (message = m));\n      await Promise.all([\n        page.evaluate(() => console.log('hello', 5, { foo: 'bar' })),\n        waitEvent(page, 'console'),\n      ]);\n      expect(message.text()).toEqual('hello 5 JSHandle@object');\n      expect(message.type()).toEqual('log');\n      expect(message.args()).toHaveLength(3);\n      expect(message.location()).toEqual({\n        url: expect.any(String),\n        lineNumber: expect.any(Number),\n        columnNumber: expect.any(Number),\n      });\n\n      expect(await message.args()[0].jsonValue()).toEqual('hello');\n      expect(await message.args()[1].jsonValue()).toEqual(5);\n      expect(await message.args()[2].jsonValue()).toEqual({ foo: 'bar' });\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work for different console API calls","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":516,"column":51},"line":516,"code":"    it('should work for different console API calls', async () => {\n      const { page } = getTestState();\n\n      const messages = [];\n      page.on('console', (msg) => messages.push(msg));\n      // All console events will be reported before `page.evaluate` is finished.\n      await page.evaluate(() => {\n        // A pair of time/timeEnd generates only one Console API call.\n        console.time('calling console.time');\n        console.timeEnd('calling console.time');\n        console.trace('calling console.trace');\n        console.dir('calling console.dir');\n        console.warn('calling console.warn');\n        console.error('calling console.error');\n        console.log(Promise.resolve('should not wait until resolved!'));\n      });\n      expect(messages.map((msg) => msg.type())).toEqual([\n        'timeEnd',\n        'trace',\n        'dir',\n        'warning',\n        'error',\n        'log',\n      ]);\n      expect(messages[0].text()).toContain('calling console.time');\n      expect(messages.slice(1).map((msg) => msg.text())).toEqual([\n        'calling console.trace',\n        'calling console.dir',\n        'calling console.warn',\n        'calling console.error',\n        'JSHandle@promise',\n      ]);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should not fail for window object","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":549,"column":41},"line":549,"code":"    it('should not fail for window object', async () => {\n      const { page } = getTestState();\n\n      let message = null;\n      page.once('console', (msg) => (message = msg));\n      await Promise.all([\n        page.evaluate(() => console.error(window)),\n        waitEvent(page, 'console'),\n      ]);\n      expect(message.text()).toBe('JSHandle@object');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should trigger correct Log","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":560,"column":34},"line":560,"code":"    it('should trigger correct Log', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      await page.goto('about:blank');\n      const [message] = await Promise.all([\n        waitEvent(page, 'console'),\n        page.evaluate(\n          async (url: string) => fetch(url).catch(() => {}),\n          server.EMPTY_PAGE\n        ),\n      ]);\n      expect(message.text()).toContain('Access-Control-Allow-Origin');\n      if (isChrome) expect(message.type()).toEqual('error');\n      else expect(message.type()).toEqual('warn');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should have location when fetch fails","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":575,"column":45},"line":575,"code":"    it('should have location when fetch fails', async () => {\n      const { page, server } = getTestState();\n\n      // The point of this test is to make sure that we report console messages from\n      // Log domain: https://vanilla.aslushnikov.com/?Log.entryAdded\n      await page.goto(server.EMPTY_PAGE);\n      const [message] = await Promise.all([\n        waitEvent(page, 'console'),\n        page.setContent(`<script>fetch('http://wat');</script>`),\n      ]);\n      expect(message.text()).toContain(`ERR_NAME_NOT_RESOLVED`);\n      expect(message.type()).toEqual('error');\n      expect(message.location()).toEqual({\n        url: 'http://wat/',\n        lineNumber: undefined,\n      });\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should have location and stack trace for console API calls","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":592,"column":66},"line":592,"code":"    it('should have location and stack trace for console API calls', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [message] = await Promise.all([\n        waitEvent(page, 'console'),\n        page.goto(server.PREFIX + '/consolelog.html'),\n      ]);\n      expect(message.text()).toBe('yellow');\n      expect(message.type()).toBe('log');\n      expect(message.location()).toEqual({\n        url: server.PREFIX + '/consolelog.html',\n        lineNumber: 8,\n        columnNumber: isChrome ? 16 : 8, // console.|log vs |console.log\n      });\n      expect(message.stackTrace()).toEqual([\n        {\n          url: server.PREFIX + '/consolelog.html',\n          lineNumber: 8,\n          columnNumber: isChrome ? 16 : 8, // console.|log vs |console.log\n        },\n        {\n          url: server.PREFIX + '/consolelog.html',\n          lineNumber: 11,\n          columnNumber: 8,\n        },\n        {\n          url: server.PREFIX + '/consolelog.html',\n          lineNumber: 13,\n          columnNumber: 6,\n        },\n      ]);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw when there are console messages in detached iframes","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":626,"column":76},"line":626,"code":"    it('should not throw when there are console messages in detached iframes', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(async () => {\n        // 1. Create a popup that Puppeteer is not connected to.\n        const win = window.open(\n          window.location.href,\n          'Title',\n          'toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=780,height=200,top=0,left=0'\n        );\n        await new Promise((x) => (win.onload = x));\n        // 2. In this popup, create an iframe that console.logs a message.\n        win.document.body.innerHTML = `<iframe src='/consolelog.html'></iframe>`;\n        const frame = win.document.querySelector('iframe');\n        await new Promise((x) => (frame.onload = x));\n        // 3. After that, remove the iframe.\n        frame.remove();\n      });\n      const popupTarget = page\n        .browserContext()\n        .targets()\n        .find((target) => target !== page.target());\n      // 4. Connect to the popup and make sure it doesn't throw.\n      await popupTarget.page();\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should fire when expected","suites":["Page","Page.Events.DOMContentLoaded"],"updatePoint":{"line":655,"column":33},"line":655,"code":"    it('should fire when expected', async () => {\n      const { page } = getTestState();\n\n      page.goto('about:blank');\n      await waitEvent(page, 'domcontentloaded');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should get metrics from a page","suites":["Page","Page.Events.DOMContentLoaded"],"updatePoint":{"line":664,"column":38},"line":664,"code":"    it('should get metrics from a page', async () => {\n      const { page } = getTestState();\n\n      await page.goto('about:blank');\n      const metrics = await page.metrics();\n      checkMetrics(metrics);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"metrics event fired on console.timeStamp","suites":["Page","Page.Events.DOMContentLoaded"],"updatePoint":{"line":671,"column":48},"line":671,"code":"    it('metrics event fired on console.timeStamp', async () => {\n      const { page } = getTestState();\n\n      const metricsPromise = new Promise<{ metrics: Metrics; title: string }>(\n        (fulfill) => page.once('metrics', fulfill)\n      );\n      await page.evaluate(() => console.timeStamp('test42'));\n      const metrics = await metricsPromise;\n      expect(metrics.title).toBe('test42');\n      checkMetrics(metrics.metrics);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":708,"column":19},"line":708,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        page.waitForRequest(server.PREFIX + '/digits/2.png'),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(request.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with predicate","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":722,"column":34},"line":722,"code":"    it('should work with predicate', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        page.waitForRequest(\n          (request) => request.url() === server.PREFIX + '/digits/2.png'\n        ),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(request.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":738,"column":30},"line":738,"code":"    it('should respect timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      await page\n        .waitForRequest(() => false, { timeout: 1 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default timeout","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":747,"column":38},"line":747,"code":"    it('should respect default timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      page.setDefaultTimeout(1);\n      await page\n        .waitForRequest(() => false)\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with async predicate","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":757,"column":40},"line":757,"code":"    it('should work with async predicate', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForResponse(async (response) => {\n          return response.url() === server.PREFIX + '/digits/2.png';\n        }),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(response.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no timeout","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":772,"column":35},"line":772,"code":"    it('should work with no timeout', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        page.waitForRequest(server.PREFIX + '/digits/2.png', { timeout: 0 }),\n        page.evaluate(() =>\n          setTimeout(() => {\n            fetch('/digits/1.png');\n            fetch('/digits/2.png');\n            fetch('/digits/3.png');\n          }, 50)\n        ),\n      ]);\n      expect(request.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":791,"column":19},"line":791,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForResponse(server.PREFIX + '/digits/2.png'),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(response.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":805,"column":30},"line":805,"code":"    it('should respect timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      await page\n        .waitForResponse(() => false, { timeout: 1 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default timeout","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":814,"column":38},"line":814,"code":"    it('should respect default timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      page.setDefaultTimeout(1);\n      await page\n        .waitForResponse(() => false)\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with predicate","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":824,"column":34},"line":824,"code":"    it('should work with predicate', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForResponse(\n          (response) => response.url() === server.PREFIX + '/digits/2.png'\n        ),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(response.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no timeout","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":840,"column":35},"line":840,"code":"    it('should work with no timeout', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForResponse(server.PREFIX + '/digits/2.png', { timeout: 0 }),\n        page.evaluate(() =>\n          setTimeout(() => {\n            fetch('/digits/1.png');\n            fetch('/digits/2.png');\n            fetch('/digits/3.png');\n          }, 50)\n        ),\n      ]);\n      expect(response.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":859,"column":19},"line":859,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      let res;\n      const [t1, t2] = await Promise.all([\n        page.waitForNetworkIdle().then((r) => {\n          res = r;\n          return Date.now();\n        }),\n        page\n          .evaluate(() =>\n            (async () => {\n              await Promise.all([\n                fetch('/digits/1.png'),\n                fetch('/digits/2.png'),\n              ]);\n              await new Promise((resolve) => setTimeout(resolve, 200));\n              await fetch('/digits/3.png');\n              await new Promise((resolve) => setTimeout(resolve, 200));\n              await fetch('/digits/4.png');\n            })()\n          )\n          .then(() => Date.now()),\n      ]);\n      expect(res).toBe(undefined);\n      expect(t1).toBeGreaterThan(t2);\n      expect(t1 - t2).toBeGreaterThanOrEqual(400);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":887,"column":30},"line":887,"code":"    it('should respect timeout', async () => {\n      const { page, puppeteer } = getTestState();\n      let error = null;\n      await page\n        .waitForNetworkIdle({ timeout: 1 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect idleTime","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":895,"column":31},"line":895,"code":"    it('should respect idleTime', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const [t1, t2] = await Promise.all([\n        page.waitForNetworkIdle({ idleTime: 10 }).then(() => Date.now()),\n        page\n          .evaluate(() =>\n            (async () => {\n              await Promise.all([\n                fetch('/digits/1.png'),\n                fetch('/digits/2.png'),\n              ]);\n              await new Promise((resolve) => setTimeout(resolve, 250));\n            })()\n          )\n          .then(() => Date.now()),\n      ]);\n      expect(t2).toBeGreaterThan(t1);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no timeout","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":914,"column":35},"line":914,"code":"    it('should work with no timeout', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const [result] = await Promise.all([\n        page.waitForNetworkIdle({ timeout: 0 }),\n        page.evaluate(() =>\n          setTimeout(() => {\n            fetch('/digits/1.png');\n            fetch('/digits/2.png');\n            fetch('/digits/3.png');\n          }, 50)\n        ),\n      ]);\n      expect(result).toBe(undefined);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":932,"column":19},"line":932,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.exposeFunction('compute', function (a, b) {\n        return a * b;\n      });\n      const result = await page.evaluate(async function () {\n        return await globalThis.compute(9, 4);\n      });\n      expect(result).toBe(36);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw exception in page context","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":943,"column":46},"line":943,"code":"    it('should throw exception in page context', async () => {\n      const { page } = getTestState();\n\n      await page.exposeFunction('woof', function () {\n        throw new Error('WOOF WOOF');\n      });\n      const { message, stack } = await page.evaluate(async () => {\n        try {\n          await globalThis.woof();\n        } catch (error) {\n          return { message: error.message, stack: error.stack };\n        }\n      });\n      expect(message).toBe('WOOF WOOF');\n      expect(stack).toContain(__filename);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should support throwing \"null\"","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":959,"column":38},"line":959,"code":"    it('should support throwing \"null\"', async () => {\n      const { page } = getTestState();\n\n      await page.exposeFunction('woof', function () {\n        throw null;\n      });\n      const thrown = await page.evaluate(async () => {\n        try {\n          await globalThis.woof();\n        } catch (error) {\n          return error;\n        }\n      });\n      expect(thrown).toBe(null);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should be callable from-inside evaluateOnNewDocument","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":974,"column":60},"line":974,"code":"    it('should be callable from-inside evaluateOnNewDocument', async () => {\n      const { page } = getTestState();\n\n      let called = false;\n      await page.exposeFunction('woof', function () {\n        called = true;\n      });\n      await page.evaluateOnNewDocument(() => globalThis.woof());\n      await page.reload();\n      expect(called).toBe(true);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should survive navigation","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":985,"column":33},"line":985,"code":"    it('should survive navigation', async () => {\n      const { page, server } = getTestState();\n\n      await page.exposeFunction('compute', function (a, b) {\n        return a * b;\n      });\n\n      await page.goto(server.EMPTY_PAGE);\n      const result = await page.evaluate(async function () {\n        return await globalThis.compute(9, 4);\n      });\n      expect(result).toBe(36);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should await returned promise","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":998,"column":37},"line":998,"code":"    it('should await returned promise', async () => {\n      const { page } = getTestState();\n\n      await page.exposeFunction('compute', function (a, b) {\n        return Promise.resolve(a * b);\n      });\n\n      const result = await page.evaluate(async function () {\n        return await globalThis.compute(3, 5);\n      });\n      expect(result).toBe(15);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work on frames","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1010,"column":29},"line":1010,"code":"    it('should work on frames', async () => {\n      const { page, server } = getTestState();\n\n      await page.exposeFunction('compute', function (a, b) {\n        return Promise.resolve(a * b);\n      });\n\n      await page.goto(server.PREFIX + '/frames/nested-frames.html');\n      const frame = page.frames()[1];\n      const result = await frame.evaluate(async function () {\n        return await globalThis.compute(3, 5);\n      });\n      expect(result).toBe(15);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work on frames before navigation","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1024,"column":47},"line":1024,"code":"    it('should work on frames before navigation', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/nested-frames.html');\n      await page.exposeFunction('compute', function (a, b) {\n        return Promise.resolve(a * b);\n      });\n\n      const frame = page.frames()[1];\n      const result = await frame.evaluate(async function () {\n        return await globalThis.compute(3, 5);\n      });\n      expect(result).toBe(15);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw when frames detach","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1038,"column":43},"line":1038,"code":"    it('should not throw when frames detach', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      await page.exposeFunction('compute', function (a, b) {\n        return Promise.resolve(a * b);\n      });\n      await utils.detachFrame(page, 'frame1');\n\n      await expect(\n        page.evaluate(async function () {\n          return await globalThis.compute(3, 5);\n        })\n      ).resolves.toEqual(15);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with complex objects","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1054,"column":40},"line":1054,"code":"    it('should work with complex objects', async () => {\n      const { page } = getTestState();\n\n      await page.exposeFunction('complexObject', function (a, b) {\n        return { x: a.x + b.x };\n      });\n      const result = await page.evaluate<() => Promise<{ x: number }>>(\n        async () => globalThis.complexObject({ x: 5 }, { x: 2 })\n      );\n      expect(result.x).toBe(7);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should fallback to default export when passed a module object","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1065,"column":69},"line":1065,"code":"    it('should fallback to default export when passed a module object', async () => {\n      const { page, server } = getTestState();\n      const moduleObject = {\n        default: function (a, b) {\n          return a * b;\n        },\n      };\n      await page.goto(server.EMPTY_PAGE);\n      await page.exposeFunction('compute', moduleObject);\n      const result = await page.evaluate(async function () {\n        return await globalThis.compute(9, 4);\n      });\n      expect(result).toBe(36);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should fire","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1082,"column":19},"line":1082,"code":"    it('should fire', async () => {\n      const { page, server } = getTestState();\n\n      let error = null;\n      page.once('pageerror', (e) => (error = e));\n      await Promise.all([\n        page.goto(server.PREFIX + '/error.html'),\n        waitEvent(page, 'pageerror'),\n      ]);\n      expect(error.message).toContain('Fancy');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.setUserAgent"],"updatePoint":{"line":1096,"column":19},"line":1096,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      expect(await page.evaluate(() => navigator.userAgent)).toContain(\n        'Mozilla'\n      );\n      await page.setUserAgent('foobar');\n      const [request] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(request.headers['user-agent']).toBe('foobar');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work for subframes","suites":["Page","Page.setUserAgent"],"updatePoint":{"line":1109,"column":33},"line":1109,"code":"    it('should work for subframes', async () => {\n      const { page, server } = getTestState();\n\n      expect(await page.evaluate(() => navigator.userAgent)).toContain(\n        'Mozilla'\n      );\n      await page.setUserAgent('foobar');\n      const [request] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        utils.attachFrame(page, 'frame1', server.EMPTY_PAGE),\n      ]);\n      expect(request.headers['user-agent']).toBe('foobar');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should emulate device user-agent","suites":["Page","Page.setUserAgent"],"updatePoint":{"line":1122,"column":40},"line":1122,"code":"    it('should emulate device user-agent', async () => {\n      const { page, server, puppeteer } = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      expect(await page.evaluate(() => navigator.userAgent)).not.toContain(\n        'iPhone'\n      );\n      await page.setUserAgent(puppeteer.devices['iPhone 6'].userAgent);\n      expect(await page.evaluate(() => navigator.userAgent)).toContain(\n        'iPhone'\n      );\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.setContent"],"updatePoint":{"line":1177,"column":19},"line":1177,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div>hello</div>');\n      const result = await page.content();\n      expect(result).toBe(expectedOutput);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with doctype","suites":["Page","Page.setContent"],"updatePoint":{"line":1184,"column":32},"line":1184,"code":"    it('should work with doctype', async () => {\n      const { page } = getTestState();\n\n      const doctype = '<!DOCTYPE html>';\n      await page.setContent(`${doctype}<div>hello</div>`);\n      const result = await page.content();\n      expect(result).toBe(`${doctype}${expectedOutput}`);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with HTML 4 doctype","suites":["Page","Page.setContent"],"updatePoint":{"line":1192,"column":39},"line":1192,"code":"    it('should work with HTML 4 doctype', async () => {\n      const { page } = getTestState();\n\n      const doctype =\n        '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" ' +\n        '\"http://www.w3.org/TR/html4/strict.dtd\">';\n      await page.setContent(`${doctype}<div>hello</div>`);\n      const result = await page.content();\n      expect(result).toBe(`${doctype}${expectedOutput}`);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","Page.setContent"],"updatePoint":{"line":1202,"column":30},"line":1202,"code":"    it('should respect timeout', async () => {\n      const { page, server, puppeteer } = getTestState();\n\n      const imgPath = '/img.png';\n      // stall for image\n      server.setRoute(imgPath, () => {});\n      let error = null;\n      await page\n        .setContent(`<img src=\"${server.PREFIX + imgPath}\"></img>`, {\n          timeout: 1,\n        })\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default navigation timeout","suites":["Page","Page.setContent"],"updatePoint":{"line":1216,"column":49},"line":1216,"code":"    it('should respect default navigation timeout', async () => {\n      const { page, server, puppeteer } = getTestState();\n\n      page.setDefaultNavigationTimeout(1);\n      const imgPath = '/img.png';\n      // stall for image\n      server.setRoute(imgPath, () => {});\n      let error = null;\n      await page\n        .setContent(`<img src=\"${server.PREFIX + imgPath}\"></img>`)\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should await resources to load","suites":["Page","Page.setContent"],"updatePoint":{"line":1229,"column":38},"line":1229,"code":"    it('should await resources to load', async () => {\n      const { page, server } = getTestState();\n\n      const imgPath = '/img.png';\n      let imgResponse = null;\n      server.setRoute(imgPath, (req, res) => (imgResponse = res));\n      let loaded = false;\n      const contentPromise = page\n        .setContent(`<img src=\"${server.PREFIX + imgPath}\"></img>`)\n        .then(() => (loaded = true));\n      await server.waitForRequest(imgPath);\n      expect(loaded).toBe(false);\n      imgResponse.end();\n      await contentPromise;\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work fast enough","suites":["Page","Page.setContent"],"updatePoint":{"line":1244,"column":31},"line":1244,"code":"    it('should work fast enough', async () => {\n      const { page } = getTestState();\n\n      for (let i = 0; i < 20; ++i) await page.setContent('<div>yo</div>');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with tricky content","suites":["Page","Page.setContent"],"updatePoint":{"line":1249,"column":39},"line":1249,"code":"    it('should work with tricky content', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div>hello world</div>' + '\\x7F');\n      expect(await page.$eval('div', (div) => div.textContent)).toBe(\n        'hello world'\n      );\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with accents","suites":["Page","Page.setContent"],"updatePoint":{"line":1257,"column":32},"line":1257,"code":"    it('should work with accents', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div>aberración</div>');\n      expect(await page.$eval('div', (div) => div.textContent)).toBe(\n        'aberración'\n      );\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with emojis","suites":["Page","Page.setContent"],"updatePoint":{"line":1265,"column":31},"line":1265,"code":"    it('should work with emojis', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div>🐥</div>');\n      expect(await page.$eval('div', (div) => div.textContent)).toBe('🐥');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with newline","suites":["Page","Page.setContent"],"updatePoint":{"line":1271,"column":32},"line":1271,"code":"    it('should work with newline', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div>\\n</div>');\n      expect(await page.$eval('div', (div) => div.textContent)).toBe('\\n');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should bypass CSP meta tag","suites":["Page","Page.setContent"],"updatePoint":{"line":1280,"column":34},"line":1280,"code":"    it('should bypass CSP meta tag', async () => {\n      const { page, server } = getTestState();\n\n      // Make sure CSP prohibits addScriptTag.\n      await page.goto(server.PREFIX + '/csp.html');\n      await page\n        .addScriptTag({ content: 'window.__injected = 42;' })\n        .catch((error) => void error);\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(undefined);\n\n      // By-pass CSP and try one more time.\n      await page.setBypassCSP(true);\n      await page.reload();\n      await page.addScriptTag({ content: 'window.__injected = 42;' });\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(42);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should bypass CSP header","suites":["Page","Page.setContent"],"updatePoint":{"line":1297,"column":32},"line":1297,"code":"    it('should bypass CSP header', async () => {\n      const { page, server } = getTestState();\n\n      // Make sure CSP prohibits addScriptTag.\n      server.setCSP('/empty.html', 'default-src \"self\"');\n      await page.goto(server.EMPTY_PAGE);\n      await page\n        .addScriptTag({ content: 'window.__injected = 42;' })\n        .catch((error) => void error);\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(undefined);\n\n      // By-pass CSP and try one more time.\n      await page.setBypassCSP(true);\n      await page.reload();\n      await page.addScriptTag({ content: 'window.__injected = 42;' });\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(42);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should bypass after cross-process navigation","suites":["Page","Page.setContent"],"updatePoint":{"line":1315,"column":52},"line":1315,"code":"    it('should bypass after cross-process navigation', async () => {\n      const { page, server } = getTestState();\n\n      await page.setBypassCSP(true);\n      await page.goto(server.PREFIX + '/csp.html');\n      await page.addScriptTag({ content: 'window.__injected = 42;' });\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(42);\n\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/csp.html');\n      await page.addScriptTag({ content: 'window.__injected = 42;' });\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(42);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should bypass CSP in iframes as well","suites":["Page","Page.setContent"],"updatePoint":{"line":1327,"column":44},"line":1327,"code":"    it('should bypass CSP in iframes as well', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      {\n        // Make sure CSP prohibits addScriptTag in an iframe.\n        const frame = await utils.attachFrame(\n          page,\n          'frame1',\n          server.PREFIX + '/csp.html'\n        );\n        await frame\n          .addScriptTag({ content: 'window.__injected = 42;' })\n          .catch((error) => void error);\n        expect(await frame.evaluate(() => globalThis.__injected)).toBe(\n          undefined\n        );\n      }\n\n      // By-pass CSP and try one more time.\n      await page.setBypassCSP(true);\n      await page.reload();\n\n      {\n        const frame = await utils.attachFrame(\n          page,\n          'frame1',\n          server.PREFIX + '/csp.html'\n        );\n        await frame\n          .addScriptTag({ content: 'window.__injected = 42;' })\n          .catch((error) => void error);\n        expect(await frame.evaluate(() => globalThis.__injected)).toBe(42);\n      }\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if no options are provided","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1365,"column":56},"line":1365,"code":"    it('should throw an error if no options are provided', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      try {\n        // @ts-expect-error purposefully passing bad options\n        await page.addScriptTag('/injectedfile.js');\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toBe(\n        'Provide an object with a `url`, `path` or `content` property'\n      );\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a url","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1380,"column":30},"line":1380,"code":"    it('should work with a url', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const scriptHandle = await page.addScriptTag({ url: '/injectedfile.js' });\n      expect(scriptHandle.asElement()).not.toBeNull();\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(42);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a url and type=module","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1389,"column":46},"line":1389,"code":"    it('should work with a url and type=module', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({ url: '/es6/es6import.js', type: 'module' });\n      expect(await page.evaluate(() => globalThis.__es6injected)).toBe(42);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a path and type=module","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1397,"column":47},"line":1397,"code":"    it('should work with a path and type=module', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({\n        path: path.join(__dirname, 'assets/es6/es6pathimport.js'),\n        type: 'module',\n      });\n      await page.waitForFunction('window.__es6injected');\n      expect(await page.evaluate(() => globalThis.__es6injected)).toBe(42);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a content and type=module","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1409,"column":50},"line":1409,"code":"    it('should work with a content and type=module', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({\n        content: `import num from '/es6/es6module.js';window.__es6injected = num;`,\n        type: 'module',\n      });\n      await page.waitForFunction('window.__es6injected');\n      expect(await page.evaluate(() => globalThis.__es6injected)).toBe(42);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if loading from url fail","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1421,"column":54},"line":1421,"code":"    it('should throw an error if loading from url fail', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let error = null;\n      try {\n        await page.addScriptTag({ url: '/nonexistfile.js' });\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toBe('Loading script from /nonexistfile.js failed');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a path","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1434,"column":31},"line":1434,"code":"    it('should work with a path', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const scriptHandle = await page.addScriptTag({\n        path: path.join(__dirname, 'assets/injectedfile.js'),\n      });\n      expect(scriptHandle.asElement()).not.toBeNull();\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(42);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should include sourcemap when path is provided","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1445,"column":54},"line":1445,"code":"    it('should include sourcemap when path is provided', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({\n        path: path.join(__dirname, 'assets/injectedfile.js'),\n      });\n      const result = await page.evaluate(\n        () => globalThis.__injectedError.stack\n      );\n      expect(result).toContain(path.join('assets', 'injectedfile.js'));\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with content","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1458,"column":32},"line":1458,"code":"    it('should work with content', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const scriptHandle = await page.addScriptTag({\n        content: 'window.__injected = 35;',\n      });\n      expect(scriptHandle.asElement()).not.toBeNull();\n      expect(await page.evaluate(() => globalThis.__injected)).toBe(35);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should add id when provided","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1469,"column":35},"line":1469,"code":"    it('should add id when provided', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({ content: 'window.__injected = 1;', id: 'one' });\n      await page.addScriptTag({ url: '/injectedfile.js', id: 'two' });\n      expect(await page.$('#one')).not.toBeNull();\n      expect(await page.$('#two')).not.toBeNull();\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when added with content to the CSP page","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1479,"column":61},"line":1479,"code":"    xit('should throw when added with content to the CSP page', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/csp.html');\n      let error = null;\n      await page\n        .addScriptTag({ content: 'window.__injected = 35;' })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n    });","skipped":true,"file":"page.spec.ts","dir":"test"},{"name":"should throw when added with URL to the CSP page","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1490,"column":56},"line":1490,"code":"    it('should throw when added with URL to the CSP page', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/csp.html');\n      let error = null;\n      await page\n        .addScriptTag({ url: server.CROSS_PROCESS_PREFIX + '/injectedfile.js' })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if no options are provided","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1503,"column":56},"line":1503,"code":"    it('should throw an error if no options are provided', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      try {\n        // @ts-expect-error purposefully passing bad input\n        await page.addStyleTag('/injectedstyle.css');\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toBe(\n        'Provide an object with a `url`, `path` or `content` property'\n      );\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a url","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1518,"column":30},"line":1518,"code":"    it('should work with a url', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const styleHandle = await page.addStyleTag({ url: '/injectedstyle.css' });\n      expect(styleHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(\n          `window.getComputedStyle(document.querySelector('body')).getPropertyValue('background-color')`\n        )\n      ).toBe('rgb(255, 0, 0)');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if loading from url fail","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1531,"column":54},"line":1531,"code":"    it('should throw an error if loading from url fail', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let error = null;\n      try {\n        await page.addStyleTag({ url: '/nonexistfile.js' });\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toBe('Loading style from /nonexistfile.js failed');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a path","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1544,"column":31},"line":1544,"code":"    it('should work with a path', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const styleHandle = await page.addStyleTag({\n        path: path.join(__dirname, 'assets/injectedstyle.css'),\n      });\n      expect(styleHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(\n          `window.getComputedStyle(document.querySelector('body')).getPropertyValue('background-color')`\n        )\n      ).toBe('rgb(255, 0, 0)');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should include sourcemap when path is provided","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1559,"column":54},"line":1559,"code":"    it('should include sourcemap when path is provided', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addStyleTag({\n        path: path.join(__dirname, 'assets/injectedstyle.css'),\n      });\n      const styleHandle = await page.$('style');\n      const styleContent = await page.evaluate(\n        (style: HTMLStyleElement) => style.innerHTML,\n        styleHandle\n      );\n      expect(styleContent).toContain(path.join('assets', 'injectedstyle.css'));\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with content","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1574,"column":32},"line":1574,"code":"    it('should work with content', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const styleHandle = await page.addStyleTag({\n        content: 'body { background-color: green; }',\n      });\n      expect(styleHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(\n          `window.getComputedStyle(document.querySelector('body')).getPropertyValue('background-color')`\n        )\n      ).toBe('rgb(0, 128, 0)');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when added with URL to the CSP page","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1603,"column":56},"line":1603,"code":"    it('should throw when added with URL to the CSP page', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/csp.html');\n      let error = null;\n      await page\n        .addStyleTag({\n          url: server.CROSS_PROCESS_PREFIX + '/injectedstyle.css',\n        })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.url"],"updatePoint":{"line":1618,"column":19},"line":1618,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      expect(page.url()).toBe('about:blank');\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.url"],"updatePoint":{"line":1628,"column":19},"line":1628,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.setJavaScriptEnabled(false);\n      await page.goto(\n        'data:text/html, <script>var something = \"forbidden\"</script>'\n      );\n      let error = null;\n      await page.evaluate('something').catch((error_) => (error = error_));\n      expect(error.message).toContain('something is not defined');\n\n      await page.setJavaScriptEnabled(true);\n      await page.goto(\n        'data:text/html, <script>var something = \"forbidden\"</script>'\n      );\n      expect(await page.evaluate('something')).toBe('forbidden');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should enable or disable the cache based on the state passed","suites":["Page","Page.setCacheEnabled"],"updatePoint":{"line":1648,"column":68},"line":1648,"code":"    it('should enable or disable the cache based on the state passed', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      const [cachedRequest] = await Promise.all([\n        server.waitForRequest('/cached/one-style.html'),\n        page.reload(),\n      ]);\n      // Rely on \"if-modified-since\" caching in our test server.\n      expect(cachedRequest.headers['if-modified-since']).not.toBe(undefined);\n\n      await page.setCacheEnabled(false);\n      const [nonCachedRequest] = await Promise.all([\n        server.waitForRequest('/cached/one-style.html'),\n        page.reload(),\n      ]);\n      expect(nonCachedRequest.headers['if-modified-since']).toBe(undefined);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"can print to PDF and save to file","suites":["Page","printing to PDF"],"updatePoint":{"line":1686,"column":41},"line":1686,"code":"    it('can print to PDF and save to file', async () => {\n      // Printing to pdf is currently only supported in headless\n      const { isHeadless, page } = getTestState();\n\n      if (!isHeadless) return;\n\n      const outputFile = __dirname + '/assets/output.pdf';\n      await page.pdf({ path: outputFile });\n      expect(fs.readFileSync(outputFile).byteLength).toBeGreaterThan(0);\n      fs.unlinkSync(outputFile);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"can print to PDF and stream the result","suites":["Page","printing to PDF"],"updatePoint":{"line":1698,"column":46},"line":1698,"code":"    it('can print to PDF and stream the result', async () => {\n      // Printing to pdf is currently only supported in headless\n      const { isHeadless, page } = getTestState();\n\n      if (!isHeadless) return;\n\n      const stream = await page.createPDFStream();\n      let size = 0;\n      for await (const chunk of stream) {\n        size += chunk.length;\n      }\n      expect(size).toBeGreaterThan(0);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","printing to PDF"],"updatePoint":{"line":1712,"column":30},"line":1712,"code":"    it('should respect timeout', async () => {\n      const { isHeadless, page, server, puppeteer } = getTestState();\n      if (!isHeadless) return;\n\n      await page.goto(server.PREFIX + '/pdf.html');\n\n      let error = null;\n      await page.pdf({ timeout: 1 }).catch((_error) => (error = _error));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should return the page title","suites":["Page","Page.title"],"updatePoint":{"line":1725,"column":36},"line":1725,"code":"    it('should return the page title', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/title.html');\n      expect(await page.title()).toBe('Woof-Woof');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should select single option","suites":["Page","Page.select"],"updatePoint":{"line":1734,"column":35},"line":1734,"code":"    it('should select single option', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('select', 'blue');\n      expect(await page.evaluate(() => globalThis.result.onInput)).toEqual([\n        'blue',\n      ]);\n      expect(await page.evaluate(() => globalThis.result.onChange)).toEqual([\n        'blue',\n      ]);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should select only first option","suites":["Page","Page.select"],"updatePoint":{"line":1746,"column":39},"line":1746,"code":"    it('should select only first option', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('select', 'blue', 'green', 'red');\n      expect(await page.evaluate(() => globalThis.result.onInput)).toEqual([\n        'blue',\n      ]);\n      expect(await page.evaluate(() => globalThis.result.onChange)).toEqual([\n        'blue',\n      ]);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw when select causes navigation","suites":["Page","Page.select"],"updatePoint":{"line":1758,"column":54},"line":1758,"code":"    it('should not throw when select causes navigation', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.$eval('select', (select) =>\n        select.addEventListener(\n          'input',\n          () => ((window as any).location = '/empty.html')\n        )\n      );\n      await Promise.all([\n        page.select('select', 'blue'),\n        page.waitForNavigation(),\n      ]);\n      expect(page.url()).toContain('empty.html');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should select multiple options","suites":["Page","Page.select"],"updatePoint":{"line":1774,"column":38},"line":1774,"code":"    it('should select multiple options', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.evaluate(() => globalThis.makeMultiple());\n      await page.select('select', 'blue', 'green', 'red');\n      expect(await page.evaluate(() => globalThis.result.onInput)).toEqual([\n        'blue',\n        'green',\n        'red',\n      ]);\n      expect(await page.evaluate(() => globalThis.result.onChange)).toEqual([\n        'blue',\n        'green',\n        'red',\n      ]);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect event bubbling","suites":["Page","Page.select"],"updatePoint":{"line":1791,"column":37},"line":1791,"code":"    it('should respect event bubbling', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('select', 'blue');\n      expect(\n        await page.evaluate(() => globalThis.result.onBubblingInput)\n      ).toEqual(['blue']);\n      expect(\n        await page.evaluate(() => globalThis.result.onBubblingChange)\n      ).toEqual(['blue']);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when element is not a <select>","suites":["Page","Page.select"],"updatePoint":{"line":1803,"column":51},"line":1803,"code":"    it('should throw when element is not a <select>', async () => {\n      const { page, server } = getTestState();\n\n      let error = null;\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('body', '').catch((error_) => (error = error_));\n      expect(error.message).toContain('Element is not a <select> element.');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should return [] on no matched values","suites":["Page","Page.select"],"updatePoint":{"line":1811,"column":45},"line":1811,"code":"    it('should return [] on no matched values', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      const result = await page.select('select', '42', 'abc');\n      expect(result).toEqual([]);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should return an array of matched values","suites":["Page","Page.select"],"updatePoint":{"line":1818,"column":48},"line":1818,"code":"    it('should return an array of matched values', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.evaluate(() => globalThis.makeMultiple());\n      const result = await page.select('select', 'blue', 'black', 'magenta');\n      expect(\n        result.reduce(\n          (accumulator, current) =>\n            ['blue', 'black', 'magenta'].includes(current) && accumulator,\n          true\n        )\n      ).toEqual(true);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should return an array of one element when multiple is not set","suites":["Page","Page.select"],"updatePoint":{"line":1832,"column":70},"line":1832,"code":"    it('should return an array of one element when multiple is not set', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      const result = await page.select(\n        'select',\n        '42',\n        'blue',\n        'black',\n        'magenta'\n      );\n      expect(result.length).toEqual(1);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should return [] on no values","suites":["Page","Page.select"],"updatePoint":{"line":1845,"column":37},"line":1845,"code":"    it('should return [] on no values', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      const result = await page.select('select');\n      expect(result).toEqual([]);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should deselect all options when passed no values for a multiple select","suites":["Page","Page.select"],"updatePoint":{"line":1852,"column":79},"line":1852,"code":"    it('should deselect all options when passed no values for a multiple select', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.evaluate(() => globalThis.makeMultiple());\n      await page.select('select', 'blue', 'black', 'magenta');\n      await page.select('select');\n      expect(\n        await page.$eval('select', (select: HTMLSelectElement) =>\n          Array.from(select.options).every(\n            (option: HTMLOptionElement) => !option.selected\n          )\n        )\n      ).toEqual(true);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should deselect all options when passed no values for a select without multiple","suites":["Page","Page.select"],"updatePoint":{"line":1867,"column":87},"line":1867,"code":"    it('should deselect all options when passed no values for a select without multiple', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('select', 'blue', 'black', 'magenta');\n      await page.select('select');\n      expect(\n        await page.$eval('select', (select: HTMLSelectElement) =>\n          Array.from(select.options).every(\n            (option: HTMLOptionElement) => !option.selected\n          )\n        )\n      ).toEqual(true);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if passed in non-strings","suites":["Page","Page.select"],"updatePoint":{"line":1881,"column":45},"line":1881,"code":"    it('should throw if passed in non-strings', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<select><option value=\"12\"/></select>');\n      let error = null;\n      try {\n        // @ts-expect-error purposefully passing bad input\n        await page.select('select', 12);\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error.message).toContain('Values must be strings');\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with page.close","suites":["Page","Page.Events.Close"],"updatePoint":{"line":1928,"column":35},"line":1928,"code":"    it('should work with page.close', async () => {\n      const { context } = getTestState();\n\n      const newPage = await context.newPage();\n      const closedPromise = new Promise((x) => newPage.on('close', x));\n      await newPage.close();\n      await closedPromise;\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should return the correct browser instance","suites":["Page","Page.browser"],"updatePoint":{"line":1939,"column":50},"line":1939,"code":"    it('should return the correct browser instance', async () => {\n      const { page, browser } = getTestState();\n\n      expect(page.browser()).toBe(browser);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should return the correct browser context instance","suites":["Page","Page.browserContext"],"updatePoint":{"line":1947,"column":58},"line":1947,"code":"    it('should return the correct browser context instance', async () => {\n      const { page, context } = getTestState();\n\n      expect(page.browserContext()).toBe(context);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should return the client instance","suites":["Page","Page.client"],"updatePoint":{"line":1955,"column":41},"line":1955,"code":"    it('should return the client instance', async () => {\n      const { page } = getTestState();\n      expect(page.client()).toBeInstanceOf(CDPSession);\n    });","file":"page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["querySelector","Page.$eval"],"updatePoint":{"line":28,"column":19},"line":28,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<section id=\"testAttribute\">43543</section>');\n      const idAttribute = await page.$eval('section', (e) => e.id);\n      expect(idAttribute).toBe('testAttribute');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should accept arguments","suites":["querySelector","Page.$eval"],"updatePoint":{"line":35,"column":31},"line":35,"code":"    it('should accept arguments', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<section>hello</section>');\n      const text = await page.$eval(\n        'section',\n        (e, suffix) => e.textContent + suffix,\n        ' world!'\n      );\n      expect(text).toBe('hello world!');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should accept ElementHandles as arguments","suites":["querySelector","Page.$eval"],"updatePoint":{"line":46,"column":49},"line":46,"code":"    it('should accept ElementHandles as arguments', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<section>hello</section><div> world</div>');\n      const divHandle = await page.$('div');\n      const text = await page.$eval(\n        'section',\n        (e, div: HTMLElement) => e.textContent + div.textContent,\n        divHandle\n      );\n      expect(text).toBe('hello world');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should throw error if no element is found","suites":["querySelector","Page.$eval"],"updatePoint":{"line":58,"column":49},"line":58,"code":"    it('should throw error if no element is found', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      await page\n        .$eval('section', (e) => e.id)\n        .catch((error_) => (error = error_));\n      expect(error.message).toContain(\n        'failed to find element matching selector \"section\"'\n      );\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should find first element in shadow","suites":["querySelector","pierceHandler"],"updatePoint":{"line":90,"column":43},"line":90,"code":"    it('should find first element in shadow', async () => {\n      const { page } = getTestState();\n      const div = await page.$('pierce/.foo');\n      const text = await div.evaluate(\n        (element: Element) => element.textContent\n      );\n      expect(text).toBe('Hello');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should find all elements in shadow","suites":["querySelector","pierceHandler"],"updatePoint":{"line":98,"column":42},"line":98,"code":"    it('should find all elements in shadow', async () => {\n      const { page } = getTestState();\n      const divs = await page.$$('pierce/.foo');\n      const text = await Promise.all(\n        divs.map((div) =>\n          div.evaluate((element: Element) => element.textContent)\n        )\n      );\n      expect(text.join(' ')).toBe('Hello World');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["querySelector","Page.$$eval"],"updatePoint":{"line":114,"column":19},"line":114,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<div>hello</div><div>beautiful</div><div>world!</div>'\n      );\n      const divsCount = await page.$$eval('div', (divs) => divs.length);\n      expect(divsCount).toBe(3);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should accept extra arguments","suites":["querySelector","Page.$$eval"],"updatePoint":{"line":123,"column":37},"line":123,"code":"    it('should accept extra arguments', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        '<div>hello</div><div>beautiful</div><div>world!</div>'\n      );\n      const divsCountPlus5 = await page.$$eval(\n        'div',\n        (divs, two: number, three: number) => divs.length + two + three,\n        2,\n        3\n      );\n      expect(divsCountPlus5).toBe(8);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should accept ElementHandles as arguments","suites":["querySelector","Page.$$eval"],"updatePoint":{"line":136,"column":49},"line":136,"code":"    it('should accept ElementHandles as arguments', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        '<section>2</section><section>2</section><section>1</section><div>3</div>'\n      );\n      const divHandle = await page.$('div');\n      const sum = await page.$$eval(\n        'section',\n        (sections, div: HTMLElement) =>\n          sections.reduce(\n            (acc, section) => acc + Number(section.textContent),\n            0\n          ) + Number(div.textContent),\n        divHandle\n      );\n      expect(sum).toBe(8);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should handle many elements","suites":["querySelector","Page.$$eval"],"updatePoint":{"line":153,"column":35},"line":153,"code":"    it('should handle many elements', async () => {\n      const { page } = getTestState();\n      await page.evaluate(\n        `\n        for (var i = 0; i <= 1000; i++) {\n            const section = document.createElement('section');\n            section.textContent = i;\n            document.body.appendChild(section);\n        }\n        `\n      );\n      const sum = await page.$$eval('section', (sections) =>\n        sections.reduce((acc, section) => acc + Number(section.textContent), 0)\n      );\n      expect(sum).toBe(500500);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["querySelector","Page.$"],"updatePoint":{"line":172,"column":37},"line":172,"code":"    it('should query existing element', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<section>test</section>');\n      const element = await page.$('section');\n      expect(element).toBeTruthy();\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-existing element","suites":["querySelector","Page.$"],"updatePoint":{"line":179,"column":51},"line":179,"code":"    it('should return null for non-existing element', async () => {\n      const { page } = getTestState();\n\n      const element = await page.$('non-existing-element');\n      expect(element).toBe(null);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing elements","suites":["querySelector","Page.$$"],"updatePoint":{"line":188,"column":38},"line":188,"code":"    it('should query existing elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div>A</div><br/><div>B</div>');\n      const elements = await page.$$('div');\n      expect(elements.length).toBe(2);\n      const promises = elements.map((element) =>\n        page.evaluate((e: HTMLElement) => e.textContent, element)\n      );\n      expect(await Promise.all(promises)).toEqual(['A', 'B']);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array if nothing is found","suites":["querySelector","Page.$$"],"updatePoint":{"line":199,"column":53},"line":199,"code":"    it('should return empty array if nothing is found', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const elements = await page.$$('div');\n      expect(elements.length).toBe(0);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["querySelector","Path.$x"],"updatePoint":{"line":209,"column":37},"line":209,"code":"    it('should query existing element', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<section>test</section>');\n      const elements = await page.$x('/html/body/section');\n      expect(elements[0]).toBeTruthy();\n      expect(elements.length).toBe(1);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array for non-existing element","suites":["querySelector","Path.$x"],"updatePoint":{"line":217,"column":58},"line":217,"code":"    it('should return empty array for non-existing element', async () => {\n      const { page } = getTestState();\n\n      const element = await page.$x('/html/body/non-existing-element');\n      expect(element).toEqual([]);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return multiple elements","suites":["querySelector","Path.$x"],"updatePoint":{"line":223,"column":39},"line":223,"code":"    it('should return multiple elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div></div><div></div>');\n      const elements = await page.$x('/html/body/div');\n      expect(elements.length).toBe(2);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["querySelector","ElementHandle.$"],"updatePoint":{"line":233,"column":37},"line":233,"code":"    it('should query existing element', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/playground.html');\n      await page.setContent(\n        '<html><body><div class=\"second\"><div class=\"inner\">A</div></div></body></html>'\n      );\n      const html = await page.$('html');\n      const second = await html.$('.second');\n      const inner = await second.$('.inner');\n      const content = await page.evaluate(\n        (e: HTMLElement) => e.textContent,\n        inner\n      );\n      expect(content).toBe('A');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-existing element","suites":["querySelector","ElementHandle.$"],"updatePoint":{"line":250,"column":51},"line":250,"code":"    it('should return null for non-existing element', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<html><body><div class=\"second\"><div class=\"inner\">B</div></div></body></html>'\n      );\n      const html = await page.$('html');\n      const second = await html.$('.third');\n      expect(second).toBe(null);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["querySelector","ElementHandle.$eval"],"updatePoint":{"line":262,"column":19},"line":262,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<html><body><div class=\"tweet\"><div class=\"like\">100</div><div class=\"retweets\">10</div></div></body></html>'\n      );\n      const tweet = await page.$('.tweet');\n      const content = await tweet.$eval(\n        '.like',\n        (node: HTMLElement) => node.innerText\n      );\n      expect(content).toBe('100');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should retrieve content from subtree","suites":["querySelector","ElementHandle.$eval"],"updatePoint":{"line":276,"column":44},"line":276,"code":"    it('should retrieve content from subtree', async () => {\n      const { page } = getTestState();\n\n      const htmlContent =\n        '<div class=\"a\">not-a-child-div</div><div id=\"myId\"><div class=\"a\">a-child-div</div></div>';\n      await page.setContent(htmlContent);\n      const elementHandle = await page.$('#myId');\n      const content = await elementHandle.$eval(\n        '.a',\n        (node: HTMLElement) => node.innerText\n      );\n      expect(content).toBe('a-child-div');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should throw in case of missing selector","suites":["querySelector","ElementHandle.$eval"],"updatePoint":{"line":290,"column":48},"line":290,"code":"    it('should throw in case of missing selector', async () => {\n      const { page } = getTestState();\n\n      const htmlContent =\n        '<div class=\"a\">not-a-child-div</div><div id=\"myId\"></div>';\n      await page.setContent(htmlContent);\n      const elementHandle = await page.$('#myId');\n      const errorMessage = await elementHandle\n        .$eval('.a', (node: HTMLElement) => node.innerText)\n        .catch((error) => error.message);\n      expect(errorMessage).toBe(\n        `Error: failed to find element matching selector \".a\"`\n      );\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["querySelector","ElementHandle.$$eval"],"updatePoint":{"line":306,"column":19},"line":306,"code":"    it('should work', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<html><body><div class=\"tweet\"><div class=\"like\">100</div><div class=\"like\">10</div></div></body></html>'\n      );\n      const tweet = await page.$('.tweet');\n      const content = await tweet.$$eval('.like', (nodes: HTMLElement[]) =>\n        nodes.map((n) => n.innerText)\n      );\n      expect(content).toEqual(['100', '10']);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should retrieve content from subtree","suites":["querySelector","ElementHandle.$$eval"],"updatePoint":{"line":319,"column":44},"line":319,"code":"    it('should retrieve content from subtree', async () => {\n      const { page } = getTestState();\n\n      const htmlContent =\n        '<div class=\"a\">not-a-child-div</div><div id=\"myId\"><div class=\"a\">a1-child-div</div><div class=\"a\">a2-child-div</div></div>';\n      await page.setContent(htmlContent);\n      const elementHandle = await page.$('#myId');\n      const content = await elementHandle.$$eval('.a', (nodes: HTMLElement[]) =>\n        nodes.map((n) => n.innerText)\n      );\n      expect(content).toEqual(['a1-child-div', 'a2-child-div']);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw in case of missing selector","suites":["querySelector","ElementHandle.$$eval"],"updatePoint":{"line":332,"column":52},"line":332,"code":"    it('should not throw in case of missing selector', async () => {\n      const { page } = getTestState();\n\n      const htmlContent =\n        '<div class=\"a\">not-a-child-div</div><div id=\"myId\"></div>';\n      await page.setContent(htmlContent);\n      const elementHandle = await page.$('#myId');\n      const nodesLength = await elementHandle.$$eval(\n        '.a',\n        (nodes) => nodes.length\n      );\n      expect(nodesLength).toBe(0);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing elements","suites":["querySelector","ElementHandle.$$"],"updatePoint":{"line":348,"column":38},"line":348,"code":"    it('should query existing elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<html><body><div>A</div><br/><div>B</div></body></html>'\n      );\n      const html = await page.$('html');\n      const elements = await html.$$('div');\n      expect(elements.length).toBe(2);\n      const promises = elements.map((element) =>\n        page.evaluate((e: HTMLElement) => e.textContent, element)\n      );\n      expect(await Promise.all(promises)).toEqual(['A', 'B']);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array for non-existing elements","suites":["querySelector","ElementHandle.$$"],"updatePoint":{"line":363,"column":59},"line":363,"code":"    it('should return empty array for non-existing elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<html><body><span>A</span><br/><span>B</span></body></html>'\n      );\n      const html = await page.$('html');\n      const elements = await html.$$('div');\n      expect(elements.length).toBe(0);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["querySelector","ElementHandle.$x"],"updatePoint":{"line":376,"column":37},"line":376,"code":"    it('should query existing element', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.PREFIX + '/playground.html');\n      await page.setContent(\n        '<html><body><div class=\"second\"><div class=\"inner\">A</div></div></body></html>'\n      );\n      const html = await page.$('html');\n      const second = await html.$x(`./body/div[contains(@class, 'second')]`);\n      const inner = await second[0].$x(`./div[contains(@class, 'inner')]`);\n      const content = await page.evaluate(\n        (e: HTMLElement) => e.textContent,\n        inner[0]\n      );\n      expect(content).toBe('A');\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-existing element","suites":["querySelector","ElementHandle.$x"],"updatePoint":{"line":393,"column":51},"line":393,"code":"    it('should return null for non-existing element', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<html><body><div class=\"second\"><div class=\"inner\">B</div></div></body></html>'\n      );\n      const html = await page.$('html');\n      const second = await html.$x(`/div[contains(@class, 'third')]`);\n      expect(second).toEqual([]);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should have registered handler","suites":["querySelector","QueryAll"],"updatePoint":{"line":417,"column":38},"line":417,"code":"    it('should have registered handler', async () => {\n      const { puppeteer } = getTestState();\n      expect(\n        puppeteer.customQueryHandlerNames().includes('allArray')\n      ).toBeTruthy();\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$ should query existing elements","suites":["querySelector","QueryAll"],"updatePoint":{"line":423,"column":41},"line":423,"code":"    it('$$ should query existing elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<html><body><div>A</div><br/><div>B</div></body></html>'\n      );\n      const html = await page.$('html');\n      const elements = await html.$$('allArray/div');\n      expect(elements.length).toBe(2);\n      const promises = elements.map((element) =>\n        page.evaluate((e: HTMLElement) => e.textContent, element)\n      );\n      expect(await Promise.all(promises)).toEqual(['A', 'B']);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$ should return empty array for non-existing elements","suites":["querySelector","QueryAll"],"updatePoint":{"line":438,"column":62},"line":438,"code":"    it('$$ should return empty array for non-existing elements', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<html><body><span>A</span><br/><span>B</span></body></html>'\n      );\n      const html = await page.$('html');\n      const elements = await html.$$('allArray/div');\n      expect(elements.length).toBe(0);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should work","suites":["querySelector","QueryAll"],"updatePoint":{"line":448,"column":26},"line":448,"code":"    it('$$eval should work', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<div>hello</div><div>beautiful</div><div>world!</div>'\n      );\n      const divsCount = await page.$$eval(\n        'allArray/div',\n        (divs) => divs.length\n      );\n      expect(divsCount).toBe(3);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should accept extra arguments","suites":["querySelector","QueryAll"],"updatePoint":{"line":460,"column":44},"line":460,"code":"    it('$$eval should accept extra arguments', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        '<div>hello</div><div>beautiful</div><div>world!</div>'\n      );\n      const divsCountPlus5 = await page.$$eval(\n        'allArray/div',\n        (divs, two: number, three: number) => divs.length + two + three,\n        2,\n        3\n      );\n      expect(divsCountPlus5).toBe(8);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should accept ElementHandles as arguments","suites":["querySelector","QueryAll"],"updatePoint":{"line":473,"column":56},"line":473,"code":"    it('$$eval should accept ElementHandles as arguments', async () => {\n      const { page } = getTestState();\n      await page.setContent(\n        '<section>2</section><section>2</section><section>1</section><div>3</div>'\n      );\n      const divHandle = await page.$('div');\n      const sum = await page.$$eval(\n        'allArray/section',\n        (sections, div: HTMLElement) =>\n          sections.reduce(\n            (acc, section) => acc + Number(section.textContent),\n            0\n          ) + Number(div.textContent),\n        divHandle\n      );\n      expect(sum).toBe(8);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should handle many elements","suites":["querySelector","QueryAll"],"updatePoint":{"line":490,"column":42},"line":490,"code":"    it('$$eval should handle many elements', async () => {\n      const { page } = getTestState();\n      await page.evaluate(\n        `\n        for (var i = 0; i <= 1000; i++) {\n            const section = document.createElement('section');\n            section.textContent = i;\n            document.body.appendChild(section);\n        }\n        `\n      );\n      const sum = await page.$$eval('allArray/section', (sections) =>\n        sections.reduce((acc, section) => acc + Number(section.textContent), 0)\n      );\n      expect(sum).toBe(500500);\n    });","file":"queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should cooperatively  by priority","suites":["request interception"],"updatePoint":{"line":37,"column":60},"line":37,"code":"      it(`should cooperatively ${expectedAction} by priority`, async () => {\n        const { page, server } = getTestState();\n\n        const actionResults: ActionResult[] = [];\n        await page.setRequestInterception(true);\n        page.on('request', (request) => {\n          if (request.url().endsWith('.css'))\n            request.continue(\n              { headers: { ...request.headers(), xaction: 'continue' } },\n              expectedAction === 'continue' ? 1 : 0\n            );\n          else request.continue({}, 0);\n        });\n        page.on('request', (request) => {\n          if (request.url().endsWith('.css'))\n            request.respond(\n              { headers: { xaction: 'respond' } },\n              expectedAction === 'respond' ? 1 : 0\n            );\n          else request.continue({}, 0);\n        });\n        page.on('request', (request) => {\n          if (request.url().endsWith('.css'))\n            request.abort('aborted', expectedAction === 'abort' ? 1 : 0);\n          else request.continue({}, 0);\n        });\n        page.on('response', (response) => {\n          const { xaction } = response.headers();\n          if (response.url().endsWith('.css') && !!xaction)\n            actionResults.push(xaction as ActionResult);\n        });\n        page.on('requestfailed', (request) => {\n          if (request.url().endsWith('.css')) actionResults.push('abort');\n        });\n\n        const response = await (async () => {\n          if (expectedAction === 'continue') {\n            const [serverRequest, response] = await Promise.all([\n              server.waitForRequest('/one-style.css'),\n              page.goto(server.PREFIX + '/one-style.html'),\n            ]);\n            actionResults.push(serverRequest.headers.xaction as ActionResult);\n            return response;\n          } else {\n            return await page.goto(server.PREFIX + '/one-style.html');\n          }\n        })();\n\n        expect(actionResults.length).toBe(1);\n        expect(actionResults[0]).toBe(expectedAction);\n        expect(response.ok()).toBe(true);\n      });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should intercept","suites":["request interception"],"updatePoint":{"line":91,"column":24},"line":91,"code":"    it('should intercept', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        if (utils.isFavicon(request)) {\n          request.continue({}, 0);\n          return;\n        }\n        expect(request.url()).toContain('empty.html');\n        expect(request.headers()['user-agent']).toBeTruthy();\n        expect(request.method()).toBe('GET');\n        expect(request.postData()).toBe(undefined);\n        expect(request.isNavigationRequest()).toBe(true);\n        expect(request.resourceType()).toBe('document');\n        expect(request.frame() === page.mainFrame()).toBe(true);\n        expect(request.frame().url()).toBe('about:blank');\n        request.continue({}, 0);\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.ok()).toBe(true);\n      expect(response.remoteAddress().port).toBe(server.PORT);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work when POST is redirected with 302","suites":["request interception"],"updatePoint":{"line":115,"column":52},"line":115,"code":"    it('should work when POST is redirected with 302', async () => {\n      const { page, server } = getTestState();\n\n      server.setRedirect('/rredirect', '/empty.html');\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue({}, 0));\n      await page.setContent(`\n        <form action='/rredirect' method='post'>\n          <input type=\"hidden\" id=\"foo\" name=\"foo\" value=\"FOOBAR\">\n        </form>\n      `);\n      await Promise.all([\n        page.$eval('form', (form: HTMLFormElement) => form.submit()),\n        page.waitForNavigation(),\n      ]);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work when header manipulation headers with redirect","suites":["request interception"],"updatePoint":{"line":133,"column":66},"line":133,"code":"    it('should work when header manipulation headers with redirect', async () => {\n      const { page, server } = getTestState();\n\n      server.setRedirect('/rrredirect', '/empty.html');\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const headers = Object.assign({}, request.headers(), {\n          foo: 'bar',\n        });\n        request.continue({ headers }, 0);\n\n        expect(request.continueRequestOverrides()).toEqual({ headers });\n      });\n      // Make sure that the goto does not time out.\n      await page.goto(server.PREFIX + '/rrredirect');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to remove headers","suites":["request interception"],"updatePoint":{"line":150,"column":40},"line":150,"code":"    it('should be able to remove headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const headers = Object.assign({}, request.headers(), {\n          foo: 'bar',\n          origin: undefined, // remove \"origin\" header\n        });\n        request.continue({ headers }, 0);\n      });\n\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.PREFIX + '/empty.html'),\n      ]);\n\n      expect(serverRequest.headers.origin).toBe(undefined);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should contain referer header","suites":["request interception"],"updatePoint":{"line":169,"column":37},"line":169,"code":"    it('should contain referer header', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        if (!utils.isFavicon(request)) requests.push(request);\n        request.continue({}, 0);\n      });\n      await page.goto(server.PREFIX + '/one-style.html');\n      expect(requests[1].url()).toContain('/one-style.css');\n      expect(requests[1].headers().referer).toContain('/one-style.html');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should properly return navigation response when URL has cookies","suites":["request interception"],"updatePoint":{"line":182,"column":71},"line":182,"code":"    it('should properly return navigation response when URL has cookies', async () => {\n      const { page, server } = getTestState();\n\n      // Setup cookie.\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({ name: 'foo', value: 'bar' });\n\n      // Setup request interception.\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue({}, 0));\n      const response = await page.reload();\n      expect(response.status()).toBe(200);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should stop intercepting","suites":["request interception"],"updatePoint":{"line":195,"column":32},"line":195,"code":"    it('should stop intercepting', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.once('request', (request) => request.continue({}, 0));\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(false);\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should show custom HTTP headers","suites":["request interception"],"updatePoint":{"line":204,"column":39},"line":204,"code":"    it('should show custom HTTP headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        foo: 'bar',\n      });\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        expect(request.headers()['foo']).toBe('bar');\n        request.continue({}, 0);\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.ok()).toBe(true);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirect inside sync XHR","suites":["request interception"],"updatePoint":{"line":219,"column":49},"line":219,"code":"    it('should work with redirect inside sync XHR', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      server.setRedirect('/logo.png', '/pptr.png');\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue({}, 0));\n      const status = await page.evaluate(async () => {\n        const request = new XMLHttpRequest();\n        request.open('GET', '/logo.png', false); // `false` makes the request synchronous\n        request.send(null);\n        return request.status;\n      });\n      expect(status).toBe(200);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with custom referer headers","suites":["request interception"],"updatePoint":{"line":234,"column":47},"line":234,"code":"    it('should work with custom referer headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setExtraHTTPHeaders({ referer: server.EMPTY_PAGE });\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        expect(request.headers()['referer']).toBe(server.EMPTY_PAGE);\n        request.continue({}, 0);\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.ok()).toBe(true);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be abortable","suites":["request interception"],"updatePoint":{"line":246,"column":27},"line":246,"code":"    it('should be abortable', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        if (request.url().endsWith('.css')) request.abort('failed', 0);\n        else request.continue({}, 0);\n      });\n      let failedRequests = 0;\n      page.on('requestfailed', () => ++failedRequests);\n      const response = await page.goto(server.PREFIX + '/one-style.html');\n      expect(response.ok()).toBe(true);\n      expect(response.request().failure()).toBe(null);\n      expect(failedRequests).toBe(1);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to access the error reason","suites":["request interception"],"updatePoint":{"line":261,"column":49},"line":261,"code":"    it('should be able to access the error reason', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.abort('failed', 0);\n      });\n      let abortReason = null;\n      page.on('request', (request) => {\n        abortReason = request.abortErrorReason();\n        request.continue({}, 0);\n      });\n      await page.goto(server.EMPTY_PAGE).catch(() => {});\n      expect(abortReason).toBe('Failed');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be abortable with custom error codes","suites":["request interception"],"updatePoint":{"line":276,"column":51},"line":276,"code":"    it('should be abortable with custom error codes', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.abort('internetdisconnected', 0);\n      });\n      let failedRequest = null;\n      page.on('requestfailed', (request) => (failedRequest = request));\n      await page.goto(server.EMPTY_PAGE).catch(() => {});\n      expect(failedRequest).toBeTruthy();\n      expect(failedRequest.failure().errorText).toBe(\n        'net::ERR_INTERNET_DISCONNECTED'\n      );\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should send referer","suites":["request interception"],"updatePoint":{"line":291,"column":27},"line":291,"code":"    it('should send referer', async () => {\n      const { page, server } = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        referer: 'http://google.com/',\n      });\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue({}, 0));\n      const [request] = await Promise.all([\n        server.waitForRequest('/grid.html'),\n        page.goto(server.PREFIX + '/grid.html'),\n      ]);\n      expect(request.headers['referer']).toBe('http://google.com/');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should fail navigation when aborting main resource","suites":["request interception"],"updatePoint":{"line":305,"column":58},"line":305,"code":"    it('should fail navigation when aborting main resource', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.abort('failed', 0));\n      let error = null;\n      await page.goto(server.EMPTY_PAGE).catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      if (isChrome) expect(error.message).toContain('net::ERR_FAILED');\n      else expect(error.message).toContain('NS_ERROR_FAILURE');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects","suites":["request interception"],"updatePoint":{"line":316,"column":34},"line":316,"code":"    it('should work with redirects', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        request.continue({}, 0);\n        requests.push(request);\n      });\n      server.setRedirect(\n        '/non-existing-page.html',\n        '/non-existing-page-2.html'\n      );\n      server.setRedirect(\n        '/non-existing-page-2.html',\n        '/non-existing-page-3.html'\n      );\n      server.setRedirect(\n        '/non-existing-page-3.html',\n        '/non-existing-page-4.html'\n      );\n      server.setRedirect('/non-existing-page-4.html', '/empty.html');\n      const response = await page.goto(\n        server.PREFIX + '/non-existing-page.html'\n      );\n      expect(response.status()).toBe(200);\n      expect(response.url()).toContain('empty.html');\n      expect(requests.length).toBe(5);\n      expect(requests[2].resourceType()).toBe('document');\n      // Check redirect chain\n      const redirectChain = response.request().redirectChain();\n      expect(redirectChain.length).toBe(4);\n      expect(redirectChain[0].url()).toContain('/non-existing-page.html');\n      expect(redirectChain[2].url()).toContain('/non-existing-page-3.html');\n      for (let i = 0; i < redirectChain.length; ++i) {\n        const request = redirectChain[i];\n        expect(request.isNavigationRequest()).toBe(true);\n        expect(request.redirectChain().indexOf(request)).toBe(i);\n      }\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects for subresources","suites":["request interception"],"updatePoint":{"line":356,"column":51},"line":356,"code":"    it('should work with redirects for subresources', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        request.continue({}, 0);\n        if (!utils.isFavicon(request)) requests.push(request);\n      });\n      server.setRedirect('/one-style.css', '/two-style.css');\n      server.setRedirect('/two-style.css', '/three-style.css');\n      server.setRedirect('/three-style.css', '/four-style.css');\n      server.setRoute('/four-style.css', (req, res) =>\n        res.end('body {box-sizing: border-box; }')\n      );\n\n      const response = await page.goto(server.PREFIX + '/one-style.html');\n      expect(response.status()).toBe(200);\n      expect(response.url()).toContain('one-style.html');\n      expect(requests.length).toBe(5);\n      expect(requests[0].resourceType()).toBe('document');\n      expect(requests[1].resourceType()).toBe('stylesheet');\n      // Check redirect chain\n      const redirectChain = requests[1].redirectChain();\n      expect(redirectChain.length).toBe(3);\n      expect(redirectChain[0].url()).toContain('/one-style.css');\n      expect(redirectChain[2].url()).toContain('/three-style.css');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to abort redirects","suites":["request interception"],"updatePoint":{"line":384,"column":41},"line":384,"code":"    it('should be able to abort redirects', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      await page.setRequestInterception(true);\n      server.setRedirect('/non-existing.json', '/non-existing-2.json');\n      server.setRedirect('/non-existing-2.json', '/simple.html');\n      page.on('request', (request) => {\n        if (request.url().includes('non-existing-2'))\n          request.abort('failed', 0);\n        else request.continue({}, 0);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const result = await page.evaluate(async () => {\n        try {\n          await fetch('/non-existing.json');\n        } catch (error) {\n          return error.message;\n        }\n      });\n      if (isChrome) expect(result).toContain('Failed to fetch');\n      else expect(result).toContain('NetworkError');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with equal requests","suites":["request interception"],"updatePoint":{"line":406,"column":39},"line":406,"code":"    it('should work with equal requests', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let responseCount = 1;\n      server.setRoute('/zzz', (req, res) => res.end(responseCount++ * 11 + ''));\n      await page.setRequestInterception(true);\n\n      let spinner = false;\n      // Cancel 2nd request.\n      page.on('request', (request) => {\n        if (utils.isFavicon(request)) {\n          request.continue({}, 0);\n          return;\n        }\n        spinner ? request.abort('failed', 0) : request.continue({}, 0);\n        spinner = !spinner;\n      });\n      const results = await page.evaluate(() =>\n        Promise.all([\n          fetch('/zzz')\n            .then((response) => response.text())\n            .catch(() => 'FAILED'),\n          fetch('/zzz')\n            .then((response) => response.text())\n            .catch(() => 'FAILED'),\n          fetch('/zzz')\n            .then((response) => response.text())\n            .catch(() => 'FAILED'),\n        ])\n      );\n      expect(results).toEqual(['11', 'FAILED', '22']);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to dataURL and fire dataURL requests","suites":["request interception"],"updatePoint":{"line":439,"column":60},"line":439,"code":"    it('should navigate to dataURL and fire dataURL requests', async () => {\n      const { page } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        requests.push(request);\n        request.continue({}, 0);\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const response = await page.goto(dataURL);\n      expect(response.status()).toBe(200);\n      expect(requests.length).toBe(1);\n      expect(requests[0].url()).toBe(dataURL);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to fetch dataURL and fire dataURL requests","suites":["request interception"],"updatePoint":{"line":454,"column":65},"line":454,"code":"    it('should be able to fetch dataURL and fire dataURL requests', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        requests.push(request);\n        request.continue({}, 0);\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const text = await page.evaluate(\n        (url: string) => fetch(url).then((r) => r.text()),\n        dataURL\n      );\n      expect(text).toBe('<div>yo</div>');\n      expect(requests.length).toBe(1);\n      expect(requests[0].url()).toBe(dataURL);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to URL with hash and fire requests without hash","suites":["request interception"],"updatePoint":{"line":473,"column":71},"line":473,"code":"    it('should navigate to URL with hash and fire requests without hash', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        requests.push(request);\n        request.continue({}, 0);\n      });\n      const response = await page.goto(server.EMPTY_PAGE + '#hash');\n      expect(response.status()).toBe(200);\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0].url()).toBe(server.EMPTY_PAGE);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with encoded server","suites":["request interception"],"updatePoint":{"line":488,"column":39},"line":488,"code":"    it('should work with encoded server', async () => {\n      const { page, server } = getTestState();\n\n      // The requestWillBeSent will report encoded URL, whereas interception will\n      // report URL as-is. @see crbug.com/759388\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue({}, 0));\n      const response = await page.goto(\n        server.PREFIX + '/some nonexisting page'\n      );\n      expect(response.status()).toBe(404);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with badly encoded server","suites":["request interception"],"updatePoint":{"line":500,"column":45},"line":500,"code":"    it('should work with badly encoded server', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      server.setRoute('/malformed?rnd=%911', (req, res) => res.end());\n      page.on('request', (request) => request.continue({}, 0));\n      const response = await page.goto(server.PREFIX + '/malformed?rnd=%911');\n      expect(response.status()).toBe(200);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with encoded server - 2","suites":["request interception"],"updatePoint":{"line":509,"column":43},"line":509,"code":"    it('should work with encoded server - 2', async () => {\n      const { page, server } = getTestState();\n\n      // The requestWillBeSent will report URL as-is, whereas interception will\n      // report encoded URL for stylesheet. @see crbug.com/759388\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        request.continue({}, 0);\n        requests.push(request);\n      });\n      const response = await page.goto(\n        `data:text/html,<link rel=\"stylesheet\" href=\"${server.PREFIX}/fonts?helvetica|arial\"/>`\n      );\n      expect(response.status()).toBe(200);\n      expect(requests.length).toBe(2);\n      expect(requests[1].response().status()).toBe(404);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw \"Invalid Interception Id\" if the request was cancelled","suites":["request interception"],"updatePoint":{"line":527,"column":79},"line":527,"code":"    it('should not throw \"Invalid Interception Id\" if the request was cancelled', async () => {\n      const { page, server } = getTestState();\n\n      await page.setContent('<iframe></iframe>');\n      await page.setRequestInterception(true);\n      let request = null;\n      page.on('request', async (r) => (request = r));\n      page.$eval(\n        'iframe',\n        (frame: HTMLIFrameElement, url: string) => (frame.src = url),\n        server.EMPTY_PAGE\n      ),\n        // Wait for request interception.\n        await utils.waitEvent(page, 'request');\n      // Delete frame to cause request to be canceled.\n      await page.$eval('iframe', (frame) => frame.remove());\n      let error = null;\n      await request.continue({}, 0).catch((error_) => (error = error_));\n      expect(error).toBe(null);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if interception is not enabled","suites":["request interception"],"updatePoint":{"line":547,"column":51},"line":547,"code":"    it('should throw if interception is not enabled', async () => {\n      const { page, server } = getTestState();\n\n      let error = null;\n      page.on('request', async (request) => {\n        try {\n          await request.continue({}, 0);\n        } catch (error_) {\n          error = error_;\n        }\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(error.message).toContain('Request Interception is not enabled');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with file URLs","suites":["request interception"],"updatePoint":{"line":561,"column":34},"line":561,"code":"    it('should work with file URLs', async () => {\n      const { page } = getTestState();\n\n      await page.setRequestInterception(true);\n      const urls = new Set();\n      page.on('request', (request) => {\n        urls.add(request.url().split('/').pop());\n        request.continue({}, 0);\n      });\n      await page.goto(\n        pathToFileURL(path.join(__dirname, 'assets', 'one-style.html'))\n      );\n      expect(urls.size).toBe(2);\n      expect(urls.has('one-style.html')).toBe(true);\n      expect(urls.has('one-style.css')).toBe(true);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should not cache if cache disabled","suites":["request interception"],"updatePoint":{"line":577,"column":42},"line":577,"code":"    it('should not cache if cache disabled', async () => {\n      const { page, server } = getTestState();\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(false);\n      page.on('request', (request) => request.continue({}, 0));\n\n      const cached = [];\n      page.on('requestservedfromcache', (r) => cached.push(r));\n\n      await page.reload();\n      expect(cached.length).toBe(0);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should cache if cache enabled","suites":["request interception"],"updatePoint":{"line":593,"column":37},"line":593,"code":"    it('should cache if cache enabled', async () => {\n      const { page, server } = getTestState();\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(true);\n      page.on('request', (request) => request.continue({}, 0));\n\n      const cached = [];\n      page.on('requestservedfromcache', (r) => cached.push(r));\n\n      await page.reload();\n      expect(cached.length).toBe(1);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should load fonts if cache enabled","suites":["request interception"],"updatePoint":{"line":609,"column":42},"line":609,"code":"    it('should load fonts if cache enabled', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(true);\n      page.on('request', (request) => request.continue({}, 0));\n\n      await page.goto(server.PREFIX + '/cached/one-style-font.html');\n      await page.waitForResponse((r) => r.url().endsWith('/one-style.woff'));\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["request interception"],"updatePoint":{"line":622,"column":19},"line":622,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue({}, 0));\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should amend HTTP headers","suites":["request interception"],"updatePoint":{"line":629,"column":33},"line":629,"code":"    it('should amend HTTP headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const headers = Object.assign({}, request.headers());\n        headers['FOO'] = 'bar';\n        request.continue({ headers }, 0);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => fetch('/sleep.zzz')),\n      ]);\n      expect(request.headers['foo']).toBe('bar');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should redirect in a way non-observable to page","suites":["request interception"],"updatePoint":{"line":645,"column":55},"line":645,"code":"    it('should redirect in a way non-observable to page', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const redirectURL = request.url().includes('/empty.html')\n          ? server.PREFIX + '/consolelog.html'\n          : undefined;\n        request.continue({ url: redirectURL }, 0);\n      });\n      let consoleMessage = null;\n      page.on('console', (msg) => (consoleMessage = msg));\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n      expect(consoleMessage.text()).toBe('yellow');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should amend method","suites":["request interception"],"updatePoint":{"line":661,"column":27},"line":661,"code":"    it('should amend method', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.continue({ method: 'POST' }, 0);\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => fetch('/sleep.zzz')),\n      ]);\n      expect(request.method).toBe('POST');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should amend post data","suites":["request interception"],"updatePoint":{"line":676,"column":30},"line":676,"code":"    it('should amend post data', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.continue({ postData: 'doggo' }, 0);\n      });\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() =>\n          fetch('/sleep.zzz', { method: 'POST', body: 'birdy' })\n        ),\n      ]);\n      expect(await serverRequest.postBody).toBe('doggo');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should amend both post data and method on navigation","suites":["request interception"],"updatePoint":{"line":693,"column":60},"line":693,"code":"    it('should amend both post data and method on navigation', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.continue({ method: 'POST', postData: 'doggo' }, 0);\n      });\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(serverRequest.method).toBe('POST');\n      expect(await serverRequest.postBody).toBe('doggo');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["request interception"],"updatePoint":{"line":710,"column":19},"line":710,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.respond(\n          {\n            status: 201,\n            headers: {\n              foo: 'bar',\n            },\n            body: 'Yo, page!',\n          },\n          0\n        );\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(201);\n      expect(response.headers().foo).toBe('bar');\n      expect(await page.evaluate(() => document.body.textContent)).toBe(\n        'Yo, page!'\n      );\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to access the response","suites":["request interception"],"updatePoint":{"line":733,"column":45},"line":733,"code":"    it('should be able to access the response', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.respond(\n          {\n            status: 200,\n            body: 'Yo, page!',\n          },\n          0\n        );\n      });\n      let response = null;\n      page.on('request', (request) => {\n        response = request.responseForRequest();\n        request.continue({}, 0);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(response).toEqual({ status: 200, body: 'Yo, page!' });\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with status code 422","suites":["request interception"],"updatePoint":{"line":754,"column":40},"line":754,"code":"    it('should work with status code 422', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.respond(\n          {\n            status: 422,\n            body: 'Yo, page!',\n          },\n          0\n        );\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(422);\n      expect(response.statusText()).toBe('Unprocessable Entity');\n      expect(await page.evaluate(() => document.body.textContent)).toBe(\n        'Yo, page!'\n      );\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should redirect","suites":["request interception"],"updatePoint":{"line":774,"column":23},"line":774,"code":"    it('should redirect', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        if (!request.url().includes('rrredirect')) {\n          request.continue({}, 0);\n          return;\n        }\n        request.respond(\n          {\n            status: 302,\n            headers: {\n              location: server.EMPTY_PAGE,\n            },\n          },\n          0\n        );\n      });\n      const response = await page.goto(server.PREFIX + '/rrredirect');\n      expect(response.request().redirectChain().length).toBe(1);\n      expect(response.request().redirectChain()[0].url()).toBe(\n        server.PREFIX + '/rrredirect'\n      );\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should allow mocking binary responses","suites":["request interception"],"updatePoint":{"line":800,"column":45},"line":800,"code":"    it('should allow mocking binary responses', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const imageBuffer = fs.readFileSync(\n          path.join(__dirname, 'assets', 'pptr.png')\n        );\n        request.respond(\n          {\n            contentType: 'image/png',\n            body: imageBuffer,\n          },\n          0\n        );\n      });\n      await page.evaluate((PREFIX) => {\n        const img = document.createElement('img');\n        img.src = PREFIX + '/does-not-exist.png';\n        document.body.appendChild(img);\n        return new Promise((fulfill) => (img.onload = fulfill));\n      }, server.PREFIX);\n      const img = await page.$('img');\n      expect(await img.screenshot()).toBeGolden('mock-binary-response.png');\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should stringify intercepted request response headers","suites":["request interception"],"updatePoint":{"line":825,"column":61},"line":825,"code":"    it('should stringify intercepted request response headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.respond(\n          {\n            status: 200,\n            headers: {\n              foo: true,\n            },\n            body: 'Yo, page!',\n          },\n          0\n        );\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(200);\n      const headers = response.headers();\n      expect(headers.foo).toBe('true');\n      expect(await page.evaluate(() => document.body.textContent)).toBe(\n        'Yo, page!'\n      );\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should indicate already-handled if an intercept has been handled","suites":["request interception"],"updatePoint":{"line":849,"column":72},"line":849,"code":"    it('should indicate already-handled if an intercept has been handled', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.continue();\n      });\n      page.on('request', (request) => {\n        expect(request.isInterceptResolutionHandled()).toBeTruthy();\n      });\n      page.on('request', (request) => {\n        const { action } = request.interceptResolutionState();\n        expect(action).toBe(InterceptResolutionAction.AlreadyHandled);\n      });\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should intercept","suites":["request interception"],"updatePoint":{"line":32,"column":24},"line":32,"code":"    it('should intercept', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        if (utils.isFavicon(request)) {\n          request.continue();\n          return;\n        }\n        expect(request.url()).toContain('empty.html');\n        expect(request.headers()['user-agent']).toBeTruthy();\n        expect(request.method()).toBe('GET');\n        expect(request.postData()).toBe(undefined);\n        expect(request.isNavigationRequest()).toBe(true);\n        expect(request.resourceType()).toBe('document');\n        expect(request.frame() === page.mainFrame()).toBe(true);\n        expect(request.frame().url()).toBe('about:blank');\n        request.continue();\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.ok()).toBe(true);\n      expect(response.remoteAddress().port).toBe(server.PORT);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work when POST is redirected with 302","suites":["request interception"],"updatePoint":{"line":56,"column":52},"line":56,"code":"    it('should work when POST is redirected with 302', async () => {\n      const { page, server } = getTestState();\n\n      server.setRedirect('/rredirect', '/empty.html');\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue());\n      await page.setContent(`\n        <form action='/rredirect' method='post'>\n          <input type=\"hidden\" id=\"foo\" name=\"foo\" value=\"FOOBAR\">\n        </form>\n      `);\n      await Promise.all([\n        page.$eval('form', (form: HTMLFormElement) => form.submit()),\n        page.waitForNavigation(),\n      ]);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work when header manipulation headers with redirect","suites":["request interception"],"updatePoint":{"line":74,"column":66},"line":74,"code":"    it('should work when header manipulation headers with redirect', async () => {\n      const { page, server } = getTestState();\n\n      server.setRedirect('/rrredirect', '/empty.html');\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const headers = Object.assign({}, request.headers(), {\n          foo: 'bar',\n        });\n        request.continue({ headers });\n      });\n      await page.goto(server.PREFIX + '/rrredirect');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to remove headers","suites":["request interception"],"updatePoint":{"line":88,"column":40},"line":88,"code":"    it('should be able to remove headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const headers = Object.assign({}, request.headers(), {\n          foo: 'bar',\n          origin: undefined, // remove \"origin\" header\n        });\n        request.continue({ headers });\n      });\n\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.PREFIX + '/empty.html'),\n      ]);\n\n      expect(serverRequest.headers.origin).toBe(undefined);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should contain referer header","suites":["request interception"],"updatePoint":{"line":107,"column":37},"line":107,"code":"    it('should contain referer header', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        if (!utils.isFavicon(request)) requests.push(request);\n        request.continue();\n      });\n      await page.goto(server.PREFIX + '/one-style.html');\n      expect(requests[1].url()).toContain('/one-style.css');\n      expect(requests[1].headers().referer).toContain('/one-style.html');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should properly return navigation response when URL has cookies","suites":["request interception"],"updatePoint":{"line":120,"column":71},"line":120,"code":"    it('should properly return navigation response when URL has cookies', async () => {\n      const { page, server } = getTestState();\n\n      // Setup cookie.\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({ name: 'foo', value: 'bar' });\n\n      // Setup request interception.\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue());\n      const response = await page.reload();\n      expect(response.status()).toBe(200);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should stop intercepting","suites":["request interception"],"updatePoint":{"line":133,"column":32},"line":133,"code":"    it('should stop intercepting', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.once('request', (request) => request.continue());\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(false);\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should show custom HTTP headers","suites":["request interception"],"updatePoint":{"line":142,"column":39},"line":142,"code":"    it('should show custom HTTP headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        foo: 'bar',\n      });\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        expect(request.headers()['foo']).toBe('bar');\n        request.continue();\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.ok()).toBe(true);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirect inside sync XHR","suites":["request interception"],"updatePoint":{"line":157,"column":49},"line":157,"code":"    it('should work with redirect inside sync XHR', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      server.setRedirect('/logo.png', '/pptr.png');\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue());\n      const status = await page.evaluate(async () => {\n        const request = new XMLHttpRequest();\n        request.open('GET', '/logo.png', false); // `false` makes the request synchronous\n        request.send(null);\n        return request.status;\n      });\n      expect(status).toBe(200);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with custom referer headers","suites":["request interception"],"updatePoint":{"line":172,"column":47},"line":172,"code":"    it('should work with custom referer headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setExtraHTTPHeaders({ referer: server.EMPTY_PAGE });\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        expect(request.headers()['referer']).toBe(server.EMPTY_PAGE);\n        request.continue();\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.ok()).toBe(true);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be abortable","suites":["request interception"],"updatePoint":{"line":184,"column":27},"line":184,"code":"    it('should be abortable', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        if (request.url().endsWith('.css')) request.abort();\n        else request.continue();\n      });\n      let failedRequests = 0;\n      page.on('requestfailed', () => ++failedRequests);\n      const response = await page.goto(server.PREFIX + '/one-style.html');\n      expect(response.ok()).toBe(true);\n      expect(response.request().failure()).toBe(null);\n      expect(failedRequests).toBe(1);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be abortable with custom error codes","suites":["request interception"],"updatePoint":{"line":199,"column":51},"line":199,"code":"    it('should be abortable with custom error codes', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.abort('internetdisconnected');\n      });\n      let failedRequest = null;\n      page.on('requestfailed', (request) => (failedRequest = request));\n      await page.goto(server.EMPTY_PAGE).catch(() => {});\n      expect(failedRequest).toBeTruthy();\n      expect(failedRequest.failure().errorText).toBe(\n        'net::ERR_INTERNET_DISCONNECTED'\n      );\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should send referer","suites":["request interception"],"updatePoint":{"line":214,"column":27},"line":214,"code":"    it('should send referer', async () => {\n      const { page, server } = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        referer: 'http://google.com/',\n      });\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue());\n      const [request] = await Promise.all([\n        server.waitForRequest('/grid.html'),\n        page.goto(server.PREFIX + '/grid.html'),\n      ]);\n      expect(request.headers['referer']).toBe('http://google.com/');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should fail navigation when aborting main resource","suites":["request interception"],"updatePoint":{"line":228,"column":58},"line":228,"code":"    it('should fail navigation when aborting main resource', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.abort());\n      let error = null;\n      await page.goto(server.EMPTY_PAGE).catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      if (isChrome) expect(error.message).toContain('net::ERR_FAILED');\n      else expect(error.message).toContain('NS_ERROR_FAILURE');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects","suites":["request interception"],"updatePoint":{"line":239,"column":34},"line":239,"code":"    it('should work with redirects', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        request.continue();\n        requests.push(request);\n      });\n      server.setRedirect(\n        '/non-existing-page.html',\n        '/non-existing-page-2.html'\n      );\n      server.setRedirect(\n        '/non-existing-page-2.html',\n        '/non-existing-page-3.html'\n      );\n      server.setRedirect(\n        '/non-existing-page-3.html',\n        '/non-existing-page-4.html'\n      );\n      server.setRedirect('/non-existing-page-4.html', '/empty.html');\n      const response = await page.goto(\n        server.PREFIX + '/non-existing-page.html'\n      );\n      expect(response.status()).toBe(200);\n      expect(response.url()).toContain('empty.html');\n      expect(requests.length).toBe(5);\n      expect(requests[2].resourceType()).toBe('document');\n      // Check redirect chain\n      const redirectChain = response.request().redirectChain();\n      expect(redirectChain.length).toBe(4);\n      expect(redirectChain[0].url()).toContain('/non-existing-page.html');\n      expect(redirectChain[2].url()).toContain('/non-existing-page-3.html');\n      for (let i = 0; i < redirectChain.length; ++i) {\n        const request = redirectChain[i];\n        expect(request.isNavigationRequest()).toBe(true);\n        expect(request.redirectChain().indexOf(request)).toBe(i);\n      }\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects for subresources","suites":["request interception"],"updatePoint":{"line":279,"column":51},"line":279,"code":"    it('should work with redirects for subresources', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        request.continue();\n        if (!utils.isFavicon(request)) requests.push(request);\n      });\n      server.setRedirect('/one-style.css', '/two-style.css');\n      server.setRedirect('/two-style.css', '/three-style.css');\n      server.setRedirect('/three-style.css', '/four-style.css');\n      server.setRoute('/four-style.css', (req, res) =>\n        res.end('body {box-sizing: border-box; }')\n      );\n\n      const response = await page.goto(server.PREFIX + '/one-style.html');\n      expect(response.status()).toBe(200);\n      expect(response.url()).toContain('one-style.html');\n      expect(requests.length).toBe(5);\n      expect(requests[0].resourceType()).toBe('document');\n      expect(requests[1].resourceType()).toBe('stylesheet');\n      // Check redirect chain\n      const redirectChain = requests[1].redirectChain();\n      expect(redirectChain.length).toBe(3);\n      expect(redirectChain[0].url()).toContain('/one-style.css');\n      expect(redirectChain[2].url()).toContain('/three-style.css');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to abort redirects","suites":["request interception"],"updatePoint":{"line":307,"column":41},"line":307,"code":"    it('should be able to abort redirects', async () => {\n      const { page, server, isChrome } = getTestState();\n\n      await page.setRequestInterception(true);\n      server.setRedirect('/non-existing.json', '/non-existing-2.json');\n      server.setRedirect('/non-existing-2.json', '/simple.html');\n      page.on('request', (request) => {\n        if (request.url().includes('non-existing-2')) request.abort();\n        else request.continue();\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const result = await page.evaluate(async () => {\n        try {\n          await fetch('/non-existing.json');\n        } catch (error) {\n          return error.message;\n        }\n      });\n      if (isChrome) expect(result).toContain('Failed to fetch');\n      else expect(result).toContain('NetworkError');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with equal requests","suites":["request interception"],"updatePoint":{"line":328,"column":39},"line":328,"code":"    it('should work with equal requests', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let responseCount = 1;\n      server.setRoute('/zzz', (req, res) => res.end(responseCount++ * 11 + ''));\n      await page.setRequestInterception(true);\n\n      let spinner = false;\n      // Cancel 2nd request.\n      page.on('request', (request) => {\n        if (utils.isFavicon(request)) {\n          request.continue();\n          return;\n        }\n        spinner ? request.abort() : request.continue();\n        spinner = !spinner;\n      });\n      const results = await page.evaluate(() =>\n        Promise.all([\n          fetch('/zzz')\n            .then((response) => response.text())\n            .catch(() => 'FAILED'),\n          fetch('/zzz')\n            .then((response) => response.text())\n            .catch(() => 'FAILED'),\n          fetch('/zzz')\n            .then((response) => response.text())\n            .catch(() => 'FAILED'),\n        ])\n      );\n      expect(results).toEqual(['11', 'FAILED', '22']);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to dataURL and fire dataURL requests","suites":["request interception"],"updatePoint":{"line":361,"column":60},"line":361,"code":"    it('should navigate to dataURL and fire dataURL requests', async () => {\n      const { page } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        requests.push(request);\n        request.continue();\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const response = await page.goto(dataURL);\n      expect(response.status()).toBe(200);\n      expect(requests.length).toBe(1);\n      expect(requests[0].url()).toBe(dataURL);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to fetch dataURL and fire dataURL requests","suites":["request interception"],"updatePoint":{"line":376,"column":65},"line":376,"code":"    it('should be able to fetch dataURL and fire dataURL requests', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        requests.push(request);\n        request.continue();\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const text = await page.evaluate(\n        (url: string) => fetch(url).then((r) => r.text()),\n        dataURL\n      );\n      expect(text).toBe('<div>yo</div>');\n      expect(requests.length).toBe(1);\n      expect(requests[0].url()).toBe(dataURL);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to URL with hash and fire requests without hash","suites":["request interception"],"updatePoint":{"line":395,"column":71},"line":395,"code":"    it('should navigate to URL with hash and fire requests without hash', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        requests.push(request);\n        request.continue();\n      });\n      const response = await page.goto(server.EMPTY_PAGE + '#hash');\n      expect(response.status()).toBe(200);\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0].url()).toBe(server.EMPTY_PAGE);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with encoded server","suites":["request interception"],"updatePoint":{"line":410,"column":39},"line":410,"code":"    it('should work with encoded server', async () => {\n      const { page, server } = getTestState();\n\n      // The requestWillBeSent will report encoded URL, whereas interception will\n      // report URL as-is. @see crbug.com/759388\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue());\n      const response = await page.goto(\n        server.PREFIX + '/some nonexisting page'\n      );\n      expect(response.status()).toBe(404);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with badly encoded server","suites":["request interception"],"updatePoint":{"line":422,"column":45},"line":422,"code":"    it('should work with badly encoded server', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      server.setRoute('/malformed?rnd=%911', (req, res) => res.end());\n      page.on('request', (request) => request.continue());\n      const response = await page.goto(server.PREFIX + '/malformed?rnd=%911');\n      expect(response.status()).toBe(200);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with encoded server - 2","suites":["request interception"],"updatePoint":{"line":431,"column":43},"line":431,"code":"    it('should work with encoded server - 2', async () => {\n      const { page, server } = getTestState();\n\n      // The requestWillBeSent will report URL as-is, whereas interception will\n      // report encoded URL for stylesheet. @see crbug.com/759388\n      await page.setRequestInterception(true);\n      const requests = [];\n      page.on('request', (request) => {\n        request.continue();\n        requests.push(request);\n      });\n      const response = await page.goto(\n        `data:text/html,<link rel=\"stylesheet\" href=\"${server.PREFIX}/fonts?helvetica|arial\"/>`\n      );\n      expect(response.status()).toBe(200);\n      expect(requests.length).toBe(2);\n      expect(requests[1].response().status()).toBe(404);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw \"Invalid Interception Id\" if the request was cancelled","suites":["request interception"],"updatePoint":{"line":449,"column":79},"line":449,"code":"    it('should not throw \"Invalid Interception Id\" if the request was cancelled', async () => {\n      const { page, server } = getTestState();\n\n      await page.setContent('<iframe></iframe>');\n      await page.setRequestInterception(true);\n      let request = null;\n      page.on('request', async (r) => (request = r));\n      page.$eval(\n        'iframe',\n        (frame: HTMLIFrameElement, url: string) => (frame.src = url),\n        server.EMPTY_PAGE\n      ),\n        // Wait for request interception.\n        await utils.waitEvent(page, 'request');\n      // Delete frame to cause request to be canceled.\n      await page.$eval('iframe', (frame) => frame.remove());\n      let error = null;\n      await request.continue().catch((error_) => (error = error_));\n      expect(error).toBe(null);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if interception is not enabled","suites":["request interception"],"updatePoint":{"line":469,"column":51},"line":469,"code":"    it('should throw if interception is not enabled', async () => {\n      const { page, server } = getTestState();\n\n      let error = null;\n      page.on('request', async (request) => {\n        try {\n          await request.continue();\n        } catch (error_) {\n          error = error_;\n        }\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(error.message).toContain('Request Interception is not enabled');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with file URLs","suites":["request interception"],"updatePoint":{"line":483,"column":34},"line":483,"code":"    it('should work with file URLs', async () => {\n      const { page } = getTestState();\n\n      await page.setRequestInterception(true);\n      const urls = new Set();\n      page.on('request', (request) => {\n        urls.add(request.url().split('/').pop());\n        request.continue();\n      });\n      await page.goto(\n        pathToFileURL(path.join(__dirname, 'assets', 'one-style.html'))\n      );\n      expect(urls.size).toBe(2);\n      expect(urls.has('one-style.html')).toBe(true);\n      expect(urls.has('one-style.css')).toBe(true);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should not cache if cache disabled","suites":["request interception"],"updatePoint":{"line":499,"column":42},"line":499,"code":"    it('should not cache if cache disabled', async () => {\n      const { page, server } = getTestState();\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(false);\n      page.on('request', (request) => request.continue());\n\n      const cached = [];\n      page.on('requestservedfromcache', (r) => cached.push(r));\n\n      await page.reload();\n      expect(cached.length).toBe(0);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should cache if cache enabled","suites":["request interception"],"updatePoint":{"line":515,"column":37},"line":515,"code":"    it('should cache if cache enabled', async () => {\n      const { page, server } = getTestState();\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(true);\n      page.on('request', (request) => request.continue());\n\n      const cached = [];\n      page.on('requestservedfromcache', (r) => cached.push(r));\n\n      await page.reload();\n      expect(cached.length).toBe(1);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should load fonts if cache enabled","suites":["request interception"],"updatePoint":{"line":531,"column":42},"line":531,"code":"    it('should load fonts if cache enabled', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(true);\n      page.on('request', (request) => request.continue());\n\n      await page.goto(server.PREFIX + '/cached/one-style-font.html');\n      await page.waitForResponse((r) => r.url().endsWith('/one-style.woff'));\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["request interception"],"updatePoint":{"line":544,"column":19},"line":544,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => request.continue());\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should amend HTTP headers","suites":["request interception"],"updatePoint":{"line":551,"column":33},"line":551,"code":"    it('should amend HTTP headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const headers = Object.assign({}, request.headers());\n        headers['FOO'] = 'bar';\n        request.continue({ headers });\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => fetch('/sleep.zzz')),\n      ]);\n      expect(request.headers['foo']).toBe('bar');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should redirect in a way non-observable to page","suites":["request interception"],"updatePoint":{"line":567,"column":55},"line":567,"code":"    it('should redirect in a way non-observable to page', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const redirectURL = request.url().includes('/empty.html')\n          ? server.PREFIX + '/consolelog.html'\n          : undefined;\n        request.continue({ url: redirectURL });\n      });\n      let consoleMessage = null;\n      page.on('console', (msg) => (consoleMessage = msg));\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n      expect(consoleMessage.text()).toBe('yellow');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should amend method","suites":["request interception"],"updatePoint":{"line":583,"column":27},"line":583,"code":"    it('should amend method', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.continue({ method: 'POST' });\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => fetch('/sleep.zzz')),\n      ]);\n      expect(request.method).toBe('POST');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should amend post data","suites":["request interception"],"updatePoint":{"line":598,"column":30},"line":598,"code":"    it('should amend post data', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.continue({ postData: 'doggo' });\n      });\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() =>\n          fetch('/sleep.zzz', { method: 'POST', body: 'birdy' })\n        ),\n      ]);\n      expect(await serverRequest.postBody).toBe('doggo');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should amend both post data and method on navigation","suites":["request interception"],"updatePoint":{"line":615,"column":60},"line":615,"code":"    it('should amend both post data and method on navigation', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.continue({ method: 'POST', postData: 'doggo' });\n      });\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(serverRequest.method).toBe('POST');\n      expect(await serverRequest.postBody).toBe('doggo');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should fail if the header value is invalid","suites":["request interception"],"updatePoint":{"line":629,"column":50},"line":629,"code":"    it('should fail if the header value is invalid', async () => {\n      const { page, server } = getTestState();\n\n      let error;\n      await page.setRequestInterception(true);\n      page.on('request', async (request) => {\n        await request\n          .continue({\n            headers: {\n              'X-Invalid-Header': 'a\\nb',\n            },\n          })\n          .catch((error_) => {\n            error = error_;\n          });\n        await request.continue();\n      });\n      await page.goto(server.PREFIX + '/empty.html');\n      expect(error.message).toMatch(/Invalid header/);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["request interception"],"updatePoint":{"line":652,"column":19},"line":652,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.respond({\n          status: 201,\n          headers: {\n            foo: 'bar',\n          },\n          body: 'Yo, page!',\n        });\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(201);\n      expect(response.headers().foo).toBe('bar');\n      expect(await page.evaluate(() => document.body.textContent)).toBe(\n        'Yo, page!'\n      );\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with status code 422","suites":["request interception"],"updatePoint":{"line":672,"column":40},"line":672,"code":"    it('should work with status code 422', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.respond({\n          status: 422,\n          body: 'Yo, page!',\n        });\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(422);\n      expect(response.statusText()).toBe('Unprocessable Entity');\n      expect(await page.evaluate(() => document.body.textContent)).toBe(\n        'Yo, page!'\n      );\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should redirect","suites":["request interception"],"updatePoint":{"line":689,"column":23},"line":689,"code":"    it('should redirect', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        if (!request.url().includes('rrredirect')) {\n          request.continue();\n          return;\n        }\n        request.respond({\n          status: 302,\n          headers: {\n            location: server.EMPTY_PAGE,\n          },\n        });\n      });\n      const response = await page.goto(server.PREFIX + '/rrredirect');\n      expect(response.request().redirectChain().length).toBe(1);\n      expect(response.request().redirectChain()[0].url()).toBe(\n        server.PREFIX + '/rrredirect'\n      );\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should allow mocking binary responses","suites":["request interception"],"updatePoint":{"line":712,"column":45},"line":712,"code":"    it('should allow mocking binary responses', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        const imageBuffer = fs.readFileSync(\n          path.join(__dirname, 'assets', 'pptr.png')\n        );\n        request.respond({\n          contentType: 'image/png',\n          body: imageBuffer,\n        });\n      });\n      await page.evaluate((PREFIX) => {\n        const img = document.createElement('img');\n        img.src = PREFIX + '/does-not-exist.png';\n        document.body.appendChild(img);\n        return new Promise((fulfill) => (img.onload = fulfill));\n      }, server.PREFIX);\n      const img = await page.$('img');\n      expect(await img.screenshot()).toBeGolden('mock-binary-response.png');\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should stringify intercepted request response headers","suites":["request interception"],"updatePoint":{"line":734,"column":61},"line":734,"code":"    it('should stringify intercepted request response headers', async () => {\n      const { page, server } = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', (request) => {\n        request.respond({\n          status: 200,\n          headers: {\n            foo: true,\n          },\n          body: 'Yo, page!',\n        });\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response.status()).toBe(200);\n      const headers = response.headers();\n      expect(headers.foo).toBe('true');\n      expect(await page.evaluate(() => document.body.textContent)).toBe(\n        'Yo, page!'\n      );\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should fail if the header value is invalid","suites":["request interception"],"updatePoint":{"line":755,"column":50},"line":755,"code":"    it('should fail if the header value is invalid', async () => {\n      const { page, server } = getTestState();\n\n      let error;\n      await page.setRequestInterception(true);\n      page.on('request', async (request) => {\n        await request\n          .respond({\n            headers: {\n              'X-Invalid-Header': 'a\\nb',\n            },\n          })\n          .catch((error_) => {\n            error = error_;\n          });\n        await request.respond({\n          status: 200,\n          body: 'Hello World',\n        });\n      });\n      await page.goto(server.PREFIX + '/empty.html');\n      expect(error.message).toMatch(/Invalid header/);\n    });","file":"requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should run in parallel","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":70,"column":30},"line":70,"code":"    it('should run in parallel', async () => {\n      const { page, server } = getTestState();\n\n      await page.setViewport({ width: 500, height: 500 });\n      await page.goto(server.PREFIX + '/grid.html');\n      const promises = [];\n      for (let i = 0; i < 3; ++i) {\n        promises.push(\n          page.screenshot({\n            clip: {\n              x: 50 * i,\n              y: 0,\n              width: 50,\n              height: 50,\n            },\n          })\n        );\n      }\n      const screenshots = await Promise.all(promises);\n      expect(screenshots[1]).toBeGolden('grid-cell-1.png');\n    });","file":"screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should run in parallel in multiple pages","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":101,"column":48},"line":101,"code":"    it('should run in parallel in multiple pages', async () => {\n      const { server, context } = getTestState();\n\n      const N = 2;\n      const pages = await Promise.all(\n        Array(N)\n          .fill(0)\n          .map(async () => {\n            const page = await context.newPage();\n            await page.goto(server.PREFIX + '/grid.html');\n            return page;\n          })\n      );\n      const promises = [];\n      for (let i = 0; i < N; ++i)\n        promises.push(\n          pages[i].screenshot({\n            clip: { x: 50 * i, y: 0, width: 50, height: 50 },\n          })\n        );\n      const screenshots = await Promise.all(promises);\n      for (let i = 0; i < N; ++i)\n        expect(screenshots[i]).toBeGolden(`grid-cell-${i}.png`);\n      await Promise.all(pages.map((page) => page.close()));\n    });","file":"screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work with odd clip size on Retina displays","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":156,"column":57},"line":156,"code":"    it('should work with odd clip size on Retina displays', async () => {\n      const { page } = getTestState();\n\n      const screenshot = await page.screenshot({\n        clip: {\n          x: 0,\n          y: 0,\n          width: 11,\n          height: 11,\n        },\n      });\n      expect(screenshot).toBeGolden('screenshot-clip-odd-size.png');\n    });","file":"screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":188,"column":19},"line":188,"code":"    it('should work', async () => {\n      const { page, server } = getTestState();\n\n      await page.setViewport({ width: 500, height: 500 });\n      await page.goto(server.PREFIX + '/grid.html');\n      await page.evaluate(() => window.scrollBy(50, 100));\n      const elementHandle = await page.$('.box:nth-of-type(3)');\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden('screenshot-element-bounding-box.png');\n    });","file":"screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should take into account padding and border","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":198,"column":51},"line":198,"code":"    it('should take into account padding and border', async () => {\n      const { page } = getTestState();\n\n      await page.setViewport({ width: 500, height: 500 });\n      await page.setContent(`\n        something above\n        <style>div {\n          border: 2px solid blue;\n          background: green;\n          width: 50px;\n          height: 50px;\n        }\n        </style>\n        <div></div>\n      `);\n      const elementHandle = await page.$('div');\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden('screenshot-element-padding-border.png');\n    });","file":"screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should scroll element into view","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":253,"column":39},"line":253,"code":"    it('should scroll element into view', async () => {\n      const { page } = getTestState();\n\n      await page.setViewport({ width: 500, height: 500 });\n      await page.setContent(`\n        something above\n        <style>div.above {\n          border: 2px solid blue;\n          background: red;\n          height: 1500px;\n        }\n        div.to-screenshot {\n          border: 2px solid blue;\n          background: green;\n          width: 50px;\n          height: 50px;\n        }\n        </style>\n        <div class=\"above\"></div>\n        <div class=\"to-screenshot\"></div>\n      `);\n      const elementHandle = await page.$('div.to-screenshot');\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden(\n        'screenshot-element-scrolled-into-view.png'\n      );\n    });","file":"screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should not hang with zero width/height element","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":311,"column":54},"line":311,"code":"    it('should not hang with zero width/height element', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div style=\"width: 50px; height: 0\"></div>');\n      const div = await page.$('div');\n      const error = await div.screenshot().catch((error_) => error_);\n      expect(error.message).toBe('Node has 0 height.');\n    });","file":"screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work for an element with fractional dimensions","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":319,"column":61},"line":319,"code":"    it('should work for an element with fractional dimensions', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(\n        '<div style=\"width:48.51px;height:19.8px;border:1px solid black;\"></div>'\n      );\n      const elementHandle = await page.$('div');\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden('screenshot-element-fractional.png');\n    });","file":"screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"Browser.targets should return all of the targets","suites":["Target"],"updatePoint":{"line":32,"column":54},"line":32,"code":"  it('Browser.targets should return all of the targets', async () => {\n    const { browser } = getTestState();\n\n    // The pages will be the testing page and the original newtab page\n    const targets = browser.targets();\n    expect(\n      targets.some(\n        (target) => target.type() === 'page' && target.url() === 'about:blank'\n      )\n    ).toBeTruthy();\n    expect(targets.some((target) => target.type() === 'browser')).toBeTruthy();\n  });","file":"target.spec.ts","skipped":false,"dir":"test"},{"name":"Browser.pages should return all of the pages","suites":["Target"],"updatePoint":{"line":44,"column":50},"line":44,"code":"  it('Browser.pages should return all of the pages', async () => {\n    const { page, context } = getTestState();\n\n    // The pages will be the testing page\n    const allPages = await context.pages();\n    expect(allPages.length).toBe(1);\n    expect(allPages).toContain(page);\n  });","file":"target.spec.ts","skipped":false,"dir":"test"},{"name":"should contain browser target","suites":["Target"],"updatePoint":{"line":52,"column":35},"line":52,"code":"  it('should contain browser target', async () => {\n    const { browser } = getTestState();\n\n    const targets = browser.targets();\n    const browserTarget = targets.find((target) => target.type() === 'browser');\n    expect(browserTarget).toBeTruthy();\n  });","file":"target.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to use the default page in the browser","suites":["Target"],"updatePoint":{"line":59,"column":59},"line":59,"code":"  it('should be able to use the default page in the browser', async () => {\n    const { page, browser } = getTestState();\n\n    // The pages will be the testing page and the original newtab page\n    const allPages = await browser.pages();\n    const originalPage = allPages.find((p) => p !== page);\n    expect(\n      await originalPage.evaluate(() => ['Hello', 'world'].join(' '))\n    ).toBe('Hello world');\n    expect(await originalPage.$('body')).toBeTruthy();\n  });","file":"target.spec.ts","skipped":false,"dir":"test"},{"name":"should timeout waiting for a non-existent target","suites":["Target","Browser.waitForTarget"],"updatePoint":{"line":306,"column":56},"line":306,"code":"    it('should timeout waiting for a non-existent target', async () => {\n      const { browser, server, puppeteer } = getTestState();\n\n      let error = null;\n      await browser\n        .waitForTarget((target) => target.url() === server.EMPTY_PAGE, {\n          timeout: 1,\n        })\n        .catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"target.spec.ts","skipped":false,"dir":"test"},{"name":"should tap the button","suites":[],"updatePoint":{"line":29,"column":27},"line":29,"code":"  it('should tap the button', async () => {\n    const { puppeteer, page, server } = getTestState();\n    const iPhone = puppeteer.devices['iPhone 6'];\n    await page.emulate(iPhone);\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.tap('button');\n    expect(await page.evaluate(() => globalThis.result)).toBe('Clicked');\n  });","file":"touchscreen.spec.ts","skipped":false,"dir":"test"},{"name":"should report touches","suites":[],"updatePoint":{"line":37,"column":27},"line":37,"code":"  it('should report touches', async () => {\n    const { puppeteer, page, server } = getTestState();\n    const iPhone = puppeteer.devices['iPhone 6'];\n    await page.emulate(iPhone);\n    await page.goto(server.PREFIX + '/input/touches.html');\n    const button = await page.$('button');\n    await button.tap();\n    expect(await page.evaluate(() => globalThis.getResult())).toEqual([\n      'Touchstart: 0',\n      'Touchend: 0',\n    ]);\n  });","file":"touchscreen.spec.ts","skipped":false,"dir":"test"},{"name":"should output a trace","suites":[],"updatePoint":{"line":47,"column":27},"line":47,"code":"  it('should output a trace', async () => {\n    const { server } = getTestState();\n\n    await page.tracing.start({ screenshots: true, path: outputFile });\n    await page.goto(server.PREFIX + '/grid.html');\n    await page.tracing.stop();\n    expect(fs.existsSync(outputFile)).toBe(true);\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should run with custom categories if provided","suites":[],"updatePoint":{"line":56,"column":51},"line":56,"code":"  it('should run with custom categories if provided', async () => {\n    await page.tracing.start({\n      path: outputFile,\n      categories: ['-*', 'disabled-by-default-devtools.timeline.frame'],\n    });\n    await page.tracing.stop();\n\n    const traceJson = JSON.parse(\n      fs.readFileSync(outputFile, { encoding: 'utf8' })\n    );\n    const traceConfig = JSON.parse(traceJson.metadata['trace-config']);\n    expect(traceConfig.included_categories).toEqual([\n      'disabled-by-default-devtools.timeline.frame',\n    ]);\n    expect(traceConfig.excluded_categories).toEqual(['*']);\n    expect(traceJson.traceEvents).not.toContainEqual(\n      expect.objectContaining({\n        cat: 'toplevel',\n      })\n    );\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should run with default categories","suites":[],"updatePoint":{"line":78,"column":40},"line":78,"code":"  it('should run with default categories', async () => {\n    await page.tracing.start({\n      path: outputFile,\n    });\n    await page.tracing.stop();\n\n    const traceJson = JSON.parse(\n      fs.readFileSync(outputFile, { encoding: 'utf8' })\n    );\n    expect(traceJson.traceEvents).toContainEqual(\n      expect.objectContaining({\n        cat: 'toplevel',\n      })\n    );\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if tracing on two pages","suites":[],"updatePoint":{"line":93,"column":42},"line":93,"code":"  it('should throw if tracing on two pages', async () => {\n    await page.tracing.start({ path: outputFile });\n    const newPage = await browser.newPage();\n    let error = null;\n    await newPage.tracing\n      .start({ path: outputFile })\n      .catch((error_) => (error = error_));\n    await newPage.close();\n    expect(error).toBeTruthy();\n    await page.tracing.stop();\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should return a buffer","suites":[],"updatePoint":{"line":104,"column":28},"line":104,"code":"  it('should return a buffer', async () => {\n    const { server } = getTestState();\n\n    await page.tracing.start({ screenshots: true, path: outputFile });\n    await page.goto(server.PREFIX + '/grid.html');\n    const trace = await page.tracing.stop();\n    const buf = fs.readFileSync(outputFile);\n    expect(trace.toString()).toEqual(buf.toString());\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should work without options","suites":[],"updatePoint":{"line":113,"column":33},"line":113,"code":"  it('should work without options', async () => {\n    const { server } = getTestState();\n\n    await page.tracing.start();\n    await page.goto(server.PREFIX + '/grid.html');\n    const trace = await page.tracing.stop();\n    expect(trace).toBeTruthy();\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should return null in case of Buffer error","suites":[],"updatePoint":{"line":122,"column":48},"line":122,"code":"  it('should return null in case of Buffer error', async () => {\n    const { server } = getTestState();\n\n    await page.tracing.start({ screenshots: true });\n    await page.goto(server.PREFIX + '/grid.html');\n    const oldBufferConcat = Buffer.concat;\n    Buffer.concat = () => {\n      throw 'error';\n    };\n    const trace = await page.tracing.stop();\n    expect(trace).toEqual(null);\n    Buffer.concat = oldBufferConcat;\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should support a buffer without a path","suites":[],"updatePoint":{"line":136,"column":44},"line":136,"code":"  it('should support a buffer without a path', async () => {\n    const { server } = getTestState();\n\n    await page.tracing.start({ screenshots: true });\n    await page.goto(server.PREFIX + '/grid.html');\n    const trace = await page.tracing.stop();\n    expect(trace.toString()).toContain('screenshot');\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should properly fail if readProtocolStream errors out","suites":[],"updatePoint":{"line":145,"column":59},"line":145,"code":"  it('should properly fail if readProtocolStream errors out', async () => {\n    await page.tracing.start({ path: __dirname });\n\n    let error: Error = null;\n    try {\n      await page.tracing.stop();\n    } catch (error_) {\n      error = error_;\n    }\n    expect(error).toBeDefined();\n  });","file":"tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for selector","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":38,"column":32},"line":38,"code":"    it('should wait for selector', async () => {\n      const { page, server } = getTestState();\n\n      let found = false;\n      const waitFor = page.waitFor('div').then(() => (found = true));\n      await page.goto(server.EMPTY_PAGE);\n      expect(found).toBe(false);\n      await page.goto(server.PREFIX + '/grid.html');\n      await waitFor;\n      expect(found).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for an xpath","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":50,"column":32},"line":50,"code":"    it('should wait for an xpath', async () => {\n      const { page, server } = getTestState();\n\n      let found = false;\n      const waitFor = page.waitFor('//div').then(() => (found = true));\n      await page.goto(server.EMPTY_PAGE);\n      expect(found).toBe(false);\n      await page.goto(server.PREFIX + '/grid.html');\n      await waitFor;\n      expect(found).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should allow you to select an element with parenthesis-starting xpath","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":61,"column":77},"line":61,"code":"    it('should allow you to select an element with parenthesis-starting xpath', async () => {\n      const { page, server } = getTestState();\n      let found = false;\n      const waitFor = page.waitFor('(//img)[200]').then(() => {\n        found = true;\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(found).toBe(false);\n      await page.goto(server.PREFIX + '/grid.html');\n      await waitFor;\n      expect(found).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should not allow you to select an element with single slash xpath","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":73,"column":73},"line":73,"code":"    it('should not allow you to select an element with single slash xpath', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<div>some text</div>`);\n      let error = null;\n      await page.waitFor('/html/body/div').catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should timeout","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":81,"column":22},"line":81,"code":"    it('should timeout', async () => {\n      const { page } = getTestState();\n\n      const startTime = Date.now();\n      const timeout = 42;\n      await page.waitFor(timeout);\n      expect(Date.now() - startTime).not.toBeLessThan(timeout / 2);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should work with multiline body","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":89,"column":39},"line":89,"code":"    it('should work with multiline body', async () => {\n      const { page } = getTestState();\n\n      const result = await page.waitForFunction(`\n        (() => true)()\n      `);\n      expect(await result.jsonValue()).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for predicate","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":97,"column":33},"line":97,"code":"    it('should wait for predicate', async () => {\n      const { page } = getTestState();\n\n      await Promise.all([\n        page.waitFor(() => window.innerWidth < 100),\n        page.setViewport({ width: 10, height: 10 }),\n      ]);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when unknown type","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":105,"column":38},"line":105,"code":"    it('should throw when unknown type', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      // @ts-expect-error purposefully passing bad type for test\n      await page.waitFor({ foo: 'bar' }).catch((error_) => (error = error_));\n      expect(error.message).toContain('Unsupported target type');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for predicate with arguments","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":113,"column":48},"line":113,"code":"    it('should wait for predicate with arguments', async () => {\n      const { page } = getTestState();\n\n      await page.waitFor((arg1, arg2) => arg1 !== arg2, {}, 1, 2);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should log a deprecation warning","suites":["waittask specs","Page.waitFor"],"updatePoint":{"line":119,"column":40},"line":119,"code":"    it('should log a deprecation warning', async () => {\n      const { page } = getTestState();\n\n      await page.waitFor(() => true);\n\n      const consoleWarnStub = console.warn as sinon.SinonSpy;\n\n      expect(consoleWarnStub.calledOnce).toBe(true);\n      expect(\n        consoleWarnStub.firstCall.calledWith(\n          'waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.'\n        )\n      ).toBe(true);\n      expect((console.warn as sinon.SinonSpy).calledOnce).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should accept a string","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":137,"column":30},"line":137,"code":"    it('should accept a string', async () => {\n      const { page } = getTestState();\n\n      const watchdog = page.waitForFunction('window.__FOO === 1');\n      await page.evaluate(() => (globalThis.__FOO = 1));\n      await watchdog;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should work when resolved right before execution context disposal","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":144,"column":73},"line":144,"code":"    it('should work when resolved right before execution context disposal', async () => {\n      const { page } = getTestState();\n\n      await page.evaluateOnNewDocument(() => (globalThis.__RELOADED = true));\n      await page.waitForFunction(() => {\n        if (!globalThis.__RELOADED) window.location.reload();\n        return true;\n      });\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on interval","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":153,"column":31},"line":153,"code":"    it('should poll on interval', async () => {\n      const { page } = getTestState();\n\n      let success = false;\n      const startTime = Date.now();\n      const polling = 100;\n      const watchdog = page\n        .waitForFunction(() => globalThis.__FOO === 'hit', { polling })\n        .then(() => (success = true));\n      await page.evaluate(() => (globalThis.__FOO = 'hit'));\n      expect(success).toBe(false);\n      await page.evaluate(() =>\n        document.body.appendChild(document.createElement('div'))\n      );\n      await watchdog;\n      expect(Date.now() - startTime).not.toBeLessThan(polling / 2);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on interval async","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":170,"column":37},"line":170,"code":"    it('should poll on interval async', async () => {\n      const { page } = getTestState();\n      let success = false;\n      const startTime = Date.now();\n      const polling = 100;\n      const watchdog = page\n        .waitForFunction(async () => globalThis.__FOO === 'hit', { polling })\n        .then(() => (success = true));\n      await page.evaluate(async () => (globalThis.__FOO = 'hit'));\n      expect(success).toBe(false);\n      await page.evaluate(async () =>\n        document.body.appendChild(document.createElement('div'))\n      );\n      await watchdog;\n      expect(Date.now() - startTime).not.toBeLessThan(polling / 2);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on mutation","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":186,"column":31},"line":186,"code":"    it('should poll on mutation', async () => {\n      const { page } = getTestState();\n\n      let success = false;\n      const watchdog = page\n        .waitForFunction(() => globalThis.__FOO === 'hit', {\n          polling: 'mutation',\n        })\n        .then(() => (success = true));\n      await page.evaluate(() => (globalThis.__FOO = 'hit'));\n      expect(success).toBe(false);\n      await page.evaluate(() =>\n        document.body.appendChild(document.createElement('div'))\n      );\n      await watchdog;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on mutation async","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":202,"column":37},"line":202,"code":"    it('should poll on mutation async', async () => {\n      const { page } = getTestState();\n\n      let success = false;\n      const watchdog = page\n        .waitForFunction(async () => globalThis.__FOO === 'hit', {\n          polling: 'mutation',\n        })\n        .then(() => (success = true));\n      await page.evaluate(async () => (globalThis.__FOO = 'hit'));\n      expect(success).toBe(false);\n      await page.evaluate(async () =>\n        document.body.appendChild(document.createElement('div'))\n      );\n      await watchdog;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on raf","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":218,"column":26},"line":218,"code":"    it('should poll on raf', async () => {\n      const { page } = getTestState();\n\n      const watchdog = page.waitForFunction(() => globalThis.__FOO === 'hit', {\n        polling: 'raf',\n      });\n      await page.evaluate(() => (globalThis.__FOO = 'hit'));\n      await watchdog;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on raf async","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":227,"column":32},"line":227,"code":"    it('should poll on raf async', async () => {\n      const { page } = getTestState();\n\n      const watchdog = page.waitForFunction(\n        async () => globalThis.__FOO === 'hit',\n        {\n          polling: 'raf',\n        }\n      );\n      await page.evaluate(async () => (globalThis.__FOO = 'hit'));\n      await watchdog;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should throw on bad polling value","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":253,"column":41},"line":253,"code":"    it('should throw on bad polling value', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      try {\n        await page.waitForFunction(() => !!document.body, {\n          polling: 'unknown',\n        });\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('polling');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should throw negative polling interval","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":267,"column":46},"line":267,"code":"    it('should throw negative polling interval', async () => {\n      const { page } = getTestState();\n\n      let error = null;\n      try {\n        await page.waitForFunction(() => !!document.body, { polling: -10 });\n      } catch (error_) {\n        error = error_;\n      }\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('Cannot poll with non-positive interval');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return the success value as a JSHandle","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":279,"column":53},"line":279,"code":"    it('should return the success value as a JSHandle', async () => {\n      const { page } = getTestState();\n\n      expect(await (await page.waitForFunction(() => 5)).jsonValue()).toBe(5);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return the window as a success value","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":284,"column":51},"line":284,"code":"    it('should return the window as a success value', async () => {\n      const { page } = getTestState();\n\n      expect(await page.waitForFunction(() => window)).toBeTruthy();\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should accept ElementHandle arguments","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":289,"column":45},"line":289,"code":"    it('should accept ElementHandle arguments', async () => {\n      const { page } = getTestState();\n\n      await page.setContent('<div></div>');\n      const div = await page.$('div');\n      let resolved = false;\n      const waitForFunction = page\n        .waitForFunction(\n          (element) => element.localName === 'div' && !element.parentElement,\n          {},\n          div\n        )\n        .then(() => (resolved = true));\n      expect(resolved).toBe(false);\n      await page.evaluate((element: HTMLElement) => element.remove(), div);\n      await waitForFunction;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":306,"column":30},"line":306,"code":"    it('should respect timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      await page\n        .waitForFunction('false', { timeout: 10 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('waiting for function failed: timeout');\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default timeout","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":317,"column":38},"line":317,"code":"    it('should respect default timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      page.setDefaultTimeout(1);\n      let error = null;\n      await page.waitForFunction('false').catch((error_) => (error = error_));\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n      expect(error.message).toContain('waiting for function failed: timeout');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should disable timeout when its set to 0","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":326,"column":48},"line":326,"code":"    it('should disable timeout when its set to 0', async () => {\n      const { page } = getTestState();\n\n      const watchdog = page.waitForFunction(\n        () => {\n          globalThis.__counter = (globalThis.__counter || 0) + 1;\n          return globalThis.__injected;\n        },\n        { timeout: 0, polling: 10 }\n      );\n      await page.waitForFunction(() => globalThis.__counter > 10);\n      await page.evaluate(() => (globalThis.__injected = true));\n      await watchdog;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should survive cross-process navigation","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":340,"column":47},"line":340,"code":"    it('should survive cross-process navigation', async () => {\n      const { page, server } = getTestState();\n\n      let fooFound = false;\n      const waitForFunction = page\n        .waitForFunction('globalThis.__FOO === 1')\n        .then(() => (fooFound = true));\n      await page.goto(server.EMPTY_PAGE);\n      expect(fooFound).toBe(false);\n      await page.reload();\n      expect(fooFound).toBe(false);\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/grid.html');\n      expect(fooFound).toBe(false);\n      await page.evaluate(() => (globalThis.__FOO = 1));\n      await waitForFunction;\n      expect(fooFound).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should survive navigations","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":357,"column":34},"line":357,"code":"    it('should survive navigations', async () => {\n      const { page, server } = getTestState();\n\n      const watchdog = page.waitForFunction(() => globalThis.__done);\n      await page.goto(server.EMPTY_PAGE);\n      await page.goto(server.PREFIX + '/consolelog.html');\n      await page.evaluate(() => (globalThis.__done = true));\n      await watchdog;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"waits for the given timeout before resolving","suites":["waittask specs","Page.waitForTimeout"],"updatePoint":{"line":369,"column":52},"line":369,"code":"    it('waits for the given timeout before resolving', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const startTime = Date.now();\n      await page.waitForTimeout(1000);\n      const endTime = Date.now();\n      /* In a perfect world endTime - startTime would be exactly 1000 but we\n       * expect some fluctuations and for it to be off by a little bit. So to\n       * avoid a flaky test we'll make sure it waited for roughly 1 second.\n       */\n      expect(endTime - startTime).toBeGreaterThan(700);\n      expect(endTime - startTime).toBeLessThan(1300);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"waits for the given timeout before resolving","suites":["waittask specs","Frame.waitForTimeout"],"updatePoint":{"line":385,"column":52},"line":385,"code":"    it('waits for the given timeout before resolving', async () => {\n      const { page, server } = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const frame = page.mainFrame();\n      const startTime = Date.now();\n      await frame.waitForTimeout(1000);\n      const endTime = Date.now();\n      /* In a perfect world endTime - startTime would be exactly 1000 but we\n       * expect some fluctuations and for it to be off by a little bit. So to\n       * avoid a flaky test we'll make sure it waited for roughly 1 second\n       */\n      expect(endTime - startTime).toBeGreaterThan(700);\n      expect(endTime - startTime).toBeLessThan(1300);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should immediately resolve promise if node exists","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":405,"column":57},"line":405,"code":"    it('should immediately resolve promise if node exists', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const frame = page.mainFrame();\n      await frame.waitForSelector('*');\n      await frame.evaluate(addElement, 'div');\n      await frame.waitForSelector('div');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve promise when node is added","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":428,"column":49},"line":428,"code":"    it('should resolve promise when node is added', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const frame = page.mainFrame();\n      const watchdog = frame.waitForSelector('div');\n      await frame.evaluate(addElement, 'br');\n      await frame.evaluate(addElement, 'div');\n      const eHandle = await watchdog;\n      const tagName = await eHandle\n        .getProperty('tagName')\n        .then((e) => e.jsonValue());\n      expect(tagName).toBe('DIV');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should work when node is added through innerHTML","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":443,"column":56},"line":443,"code":"    it('should work when node is added through innerHTML', async () => {\n      const { page, server } = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const watchdog = page.waitForSelector('h3 div');\n      await page.evaluate(addElement, 'span');\n      await page.evaluate(\n        () =>\n          (document.querySelector('span').innerHTML = '<h3><div></div></h3>')\n      );\n      await watchdog;\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should survive cross-process navigation","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":502,"column":47},"line":502,"code":"    it('should survive cross-process navigation', async () => {\n      const { page, server } = getTestState();\n\n      let boxFound = false;\n      const waitForSelector = page\n        .waitForSelector('.box')\n        .then(() => (boxFound = true));\n      await page.goto(server.EMPTY_PAGE);\n      expect(boxFound).toBe(false);\n      await page.reload();\n      expect(boxFound).toBe(false);\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/grid.html');\n      await waitForSelector;\n      expect(boxFound).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for visible","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":517,"column":31},"line":517,"code":"    it('should wait for visible', async () => {\n      const { page } = getTestState();\n\n      let divFound = false;\n      const waitForSelector = page\n        .waitForSelector('div', { visible: true })\n        .then(() => (divFound = true));\n      await page.setContent(\n        `<div style='display: none; visibility: hidden;'>1</div>`\n      );\n      expect(divFound).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.removeProperty('display')\n      );\n      expect(divFound).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.removeProperty('visibility')\n      );\n      expect(await waitForSelector).toBe(true);\n      expect(divFound).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for visible recursively","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":538,"column":43},"line":538,"code":"    it('should wait for visible recursively', async () => {\n      const { page } = getTestState();\n\n      let divVisible = false;\n      const waitForSelector = page\n        .waitForSelector('div#inner', { visible: true })\n        .then(() => (divVisible = true));\n      await page.setContent(\n        `<div style='display: none; visibility: hidden;'><div id=\"inner\">hi</div></div>`\n      );\n      expect(divVisible).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.removeProperty('display')\n      );\n      expect(divVisible).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.removeProperty('visibility')\n      );\n      expect(await waitForSelector).toBe(true);\n      expect(divVisible).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for visibility: hidden","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":559,"column":49},"line":559,"code":"    it('hidden should wait for visibility: hidden', async () => {\n      const { page } = getTestState();\n\n      let divHidden = false;\n      await page.setContent(`<div style='display: block;'></div>`);\n      const waitForSelector = page\n        .waitForSelector('div', { hidden: true })\n        .then(() => (divHidden = true));\n      await page.waitForSelector('div'); // do a round trip\n      expect(divHidden).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.setProperty('visibility', 'hidden')\n      );\n      expect(await waitForSelector).toBe(true);\n      expect(divHidden).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for display: none","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":575,"column":44},"line":575,"code":"    it('hidden should wait for display: none', async () => {\n      const { page } = getTestState();\n\n      let divHidden = false;\n      await page.setContent(`<div style='display: block;'></div>`);\n      const waitForSelector = page\n        .waitForSelector('div', { hidden: true })\n        .then(() => (divHidden = true));\n      await page.waitForSelector('div'); // do a round trip\n      expect(divHidden).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.setProperty('display', 'none')\n      );\n      expect(await waitForSelector).toBe(true);\n      expect(divHidden).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for removal","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":591,"column":38},"line":591,"code":"    it('hidden should wait for removal', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<div></div>`);\n      let divRemoved = false;\n      const waitForSelector = page\n        .waitForSelector('div', { hidden: true })\n        .then(() => (divRemoved = true));\n      await page.waitForSelector('div'); // do a round trip\n      expect(divRemoved).toBe(false);\n      await page.evaluate(() => document.querySelector('div').remove());\n      expect(await waitForSelector).toBe(true);\n      expect(divRemoved).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return null if waiting to hide non-existing element","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":605,"column":66},"line":605,"code":"    it('should return null if waiting to hide non-existing element', async () => {\n      const { page } = getTestState();\n\n      const handle = await page.waitForSelector('non-existing', {\n        hidden: true,\n      });\n      expect(handle).toBe(null);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":613,"column":30},"line":613,"code":"    it('should respect timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      await page\n        .waitForSelector('div', { timeout: 10 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain(\n        'waiting for selector `div` failed: timeout'\n      );\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should have an error message specifically for awaiting an element to be hidden","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":626,"column":86},"line":626,"code":"    it('should have an error message specifically for awaiting an element to be hidden', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<div></div>`);\n      let error = null;\n      await page\n        .waitForSelector('div', { hidden: true, timeout: 10 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain(\n        'waiting for selector `div` to be hidden failed: timeout'\n      );\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respond to node attribute mutation","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":640,"column":49},"line":640,"code":"    it('should respond to node attribute mutation', async () => {\n      const { page } = getTestState();\n\n      let divFound = false;\n      const waitForSelector = page\n        .waitForSelector('.zombo')\n        .then(() => (divFound = true));\n      await page.setContent(`<div class='notZombo'></div>`);\n      expect(divFound).toBe(false);\n      await page.evaluate(\n        () => (document.querySelector('div').className = 'zombo')\n      );\n      expect(await waitForSelector).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return the element handle","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":654,"column":40},"line":654,"code":"    it('should return the element handle', async () => {\n      const { page } = getTestState();\n\n      const waitForSelector = page.waitForSelector('.zombo');\n      await page.setContent(`<div class='zombo'>anything</div>`);\n      expect(\n        await page.evaluate(\n          (x: HTMLElement) => x.textContent,\n          await waitForSelector\n        )\n      ).toBe('anything');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should have correct stack trace for timeout","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":666,"column":51},"line":666,"code":"    it('should have correct stack trace for timeout', async () => {\n      const { page } = getTestState();\n\n      let error;\n      await page\n        .waitForSelector('.zombo', { timeout: 10 })\n        .catch((error_) => (error = error_));\n      expect(error.stack).toContain('waiting for selector `.zombo` failed');\n      // The extension is ts here as Mocha maps back via sourcemaps.\n      expect(error.stack).toContain('waittask.spec.ts');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should support some fancy xpath","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":683,"column":39},"line":683,"code":"    it('should support some fancy xpath', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<p>red herring</p><p>hello  world  </p>`);\n      const waitForXPath = page.waitForXPath(\n        '//p[normalize-space(.)=\"hello world\"]'\n      );\n      expect(\n        await page.evaluate(\n          (x: HTMLElement) => x.textContent,\n          await waitForXPath\n        )\n      ).toBe('hello  world  ');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":697,"column":30},"line":697,"code":"    it('should respect timeout', async () => {\n      const { page, puppeteer } = getTestState();\n\n      let error = null;\n      await page\n        .waitForXPath('//div', { timeout: 10 })\n        .catch((error_) => (error = error_));\n      expect(error).toBeTruthy();\n      expect(error.message).toContain(\n        'waiting for XPath `//div` failed: timeout'\n      );\n      expect(error).toBeInstanceOf(puppeteer.errors.TimeoutError);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for display: none","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":739,"column":44},"line":739,"code":"    it('hidden should wait for display: none', async () => {\n      const { page } = getTestState();\n\n      let divHidden = false;\n      await page.setContent(`<div style='display: block;'></div>`);\n      const waitForXPath = page\n        .waitForXPath('//div', { hidden: true })\n        .then(() => (divHidden = true));\n      await page.waitForXPath('//div'); // do a round trip\n      expect(divHidden).toBe(false);\n      await page.evaluate(() =>\n        document.querySelector('div').style.setProperty('display', 'none')\n      );\n      expect(await waitForXPath).toBe(true);\n      expect(divHidden).toBe(true);\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return the element handle","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":755,"column":40},"line":755,"code":"    it('should return the element handle', async () => {\n      const { page } = getTestState();\n\n      const waitForXPath = page.waitForXPath('//*[@class=\"zombo\"]');\n      await page.setContent(`<div class='zombo'>anything</div>`);\n      expect(\n        await page.evaluate(\n          (x: HTMLElement) => x.textContent,\n          await waitForXPath\n        )\n      ).toBe('anything');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should allow you to select a text node","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":767,"column":46},"line":767,"code":"    it('should allow you to select a text node', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<div>some text</div>`);\n      const text = await page.waitForXPath('//div/text()');\n      expect(await (await text.getProperty('nodeType')).jsonValue()).toBe(\n        3 /* Node.TEXT_NODE */\n      );\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should allow you to select an element with single slash","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":776,"column":63},"line":776,"code":"    it('should allow you to select an element with single slash', async () => {\n      const { page } = getTestState();\n\n      await page.setContent(`<div>some text</div>`);\n      const waitForXPath = page.waitForXPath('/html/body/div');\n      expect(\n        await page.evaluate(\n          (x: HTMLElement) => x.textContent,\n          await waitForXPath\n        )\n      ).toBe('some text');\n    });","file":"waittask.spec.ts","skipped":false,"dir":"test"},{"name":"Page.workers","suites":[],"updatePoint":{"line":32,"column":18},"line":32,"code":"  it('Page.workers', async () => {\n    const { page, server } = getTestState();\n\n    await Promise.all([\n      new Promise((x) => page.once('workercreated', x)),\n      page.goto(server.PREFIX + '/worker/worker.html'),\n    ]);\n    const worker = page.workers()[0];\n    expect(worker.url()).toContain('worker.js');\n\n    expect(await worker.evaluate(() => globalThis.workerFunction())).toBe(\n      'worker function result'\n    );\n\n    await page.goto(server.EMPTY_PAGE);\n    expect(page.workers().length).toBe(0);\n  });","file":"worker.spec.ts","skipped":false,"dir":"test"},{"name":"should emit created and destroyed events","suites":[],"updatePoint":{"line":49,"column":46},"line":49,"code":"  it('should emit created and destroyed events', async () => {\n    const { page } = getTestState();\n\n    const workerCreatedPromise = new Promise<WebWorker>((x) =>\n      page.once('workercreated', x)\n    );\n    const workerObj = await page.evaluateHandle(\n      () => new Worker('data:text/javascript,1')\n    );\n    const worker = await workerCreatedPromise;\n    const workerThisObj = await worker.evaluateHandle(() => this);\n    const workerDestroyedPromise = new Promise((x) =>\n      page.once('workerdestroyed', x)\n    );\n    await page.evaluate(\n      (workerObj: Worker) => workerObj.terminate(),\n      workerObj\n    );\n    expect(await workerDestroyedPromise).toBe(worker);\n    const error = await workerThisObj\n      .getProperty('self')\n      .catch((error) => error);\n    expect(error.message).toContain('Most likely the worker has been closed.');\n  });","file":"worker.spec.ts","skipped":false,"dir":"test"},{"name":"should report console logs","suites":[],"updatePoint":{"line":73,"column":32},"line":73,"code":"  it('should report console logs', async () => {\n    const { page } = getTestState();\n\n    const [message] = await Promise.all([\n      waitEvent(page, 'console'),\n      page.evaluate(() => new Worker(`data:text/javascript,console.log(1)`)),\n    ]);\n    expect(message.text()).toBe('1');\n    expect(message.location()).toEqual({\n      url: '',\n      lineNumber: 0,\n      columnNumber: 8,\n    });\n  });","file":"worker.spec.ts","skipped":false,"dir":"test"},{"name":"should have JSHandles for console logs","suites":[],"updatePoint":{"line":87,"column":44},"line":87,"code":"  it('should have JSHandles for console logs', async () => {\n    const { page } = getTestState();\n\n    const logPromise = new Promise<ConsoleMessage>((x) =>\n      page.on('console', x)\n    );\n    await page.evaluate(\n      () => new Worker(`data:text/javascript,console.log(1,2,3,this)`)\n    );\n    const log = await logPromise;\n    expect(log.text()).toBe('1 2 3 JSHandle@object');\n    expect(log.args().length).toBe(4);\n    expect(await (await log.args()[3].getProperty('origin')).jsonValue()).toBe(\n      'null'\n    );\n  });","file":"worker.spec.ts","skipped":false,"dir":"test"},{"name":"should have an execution context","suites":[],"updatePoint":{"line":103,"column":38},"line":103,"code":"  it('should have an execution context', async () => {\n    const { page } = getTestState();\n\n    const workerCreatedPromise = new Promise<WebWorker>((x) =>\n      page.once('workercreated', x)\n    );\n    await page.evaluate(\n      () => new Worker(`data:text/javascript,console.log(1)`)\n    );\n    const worker = await workerCreatedPromise;\n    expect(await (await worker.executionContext()).evaluate('1+1')).toBe(2);\n  });","file":"worker.spec.ts","skipped":false,"dir":"test"},{"name":"should report errors","suites":[],"updatePoint":{"line":115,"column":26},"line":115,"code":"  it('should report errors', async () => {\n    const { page } = getTestState();\n\n    const errorPromise = new Promise<Error>((x) => page.on('pageerror', x));\n    await page.evaluate(\n      () =>\n        new Worker(`data:text/javascript, throw new Error('this is my error');`)\n    );\n    const errorLog = await errorPromise;\n    expect(errorLog.message).toContain('this is my error');\n  });","file":"worker.spec.ts","skipped":false,"dir":"test"}]}